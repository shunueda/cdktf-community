import * as cdktf from 'cdktf';
import { PackSourceInputSplunkAuthTokens,
packSourceInputSplunkAuthTokensToTerraform,
packSourceInputSplunkAuthTokensToHclTerraform,
PackSourceInputSplunkAuthTokensList,
PackSourceInputSplunkConnections,
packSourceInputSplunkConnectionsToTerraform,
packSourceInputSplunkConnectionsToHclTerraform,
PackSourceInputSplunkConnectionsList,
PackSourceInputSplunkMetadata,
packSourceInputSplunkMetadataToTerraform,
packSourceInputSplunkMetadataToHclTerraform,
PackSourceInputSplunkMetadataList } from './structs400'
export interface PackSourceInputSplunkPq {
  /**
  * The number of events to send downstream before committing that Stream has read them. Default: 42
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#commit_frequency PackSource#commit_frequency}
  */
  readonly commitFrequency?: number;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#compress PackSource#compress}
  */
  readonly compress?: string;
  /**
  * The maximum number of events to hold in memory before writing the events to disk. Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_buffer_size PackSource#max_buffer_size}
  */
  readonly maxBufferSize?: number;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc. Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_file_size PackSource#max_file_size}
  */
  readonly maxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_size PackSource#max_size}
  */
  readonly maxSize?: string;
  /**
  * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine. Default: "always"; must be one of ["smart", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#mode PackSource#mode}
  */
  readonly mode?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#path PackSource#path}
  */
  readonly path?: string;
}

export function packSourceInputSplunkPqToTerraform(struct?: PackSourceInputSplunkPq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    commit_frequency: cdktf.numberToTerraform(struct!.commitFrequency),
    compress: cdktf.stringToTerraform(struct!.compress),
    max_buffer_size: cdktf.numberToTerraform(struct!.maxBufferSize),
    max_file_size: cdktf.stringToTerraform(struct!.maxFileSize),
    max_size: cdktf.stringToTerraform(struct!.maxSize),
    mode: cdktf.stringToTerraform(struct!.mode),
    path: cdktf.stringToTerraform(struct!.path),
  }
}


export function packSourceInputSplunkPqToHclTerraform(struct?: PackSourceInputSplunkPq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    commit_frequency: {
      value: cdktf.numberToHclTerraform(struct!.commitFrequency),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    compress: {
      value: cdktf.stringToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_buffer_size: {
      value: cdktf.numberToHclTerraform(struct!.maxBufferSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.maxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_size: {
      value: cdktf.stringToHclTerraform(struct!.maxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputSplunkPqOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputSplunkPq | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._commitFrequency !== undefined) {
      hasAnyValues = true;
      internalValueResult.commitFrequency = this._commitFrequency;
    }
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._maxBufferSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBufferSize = this._maxBufferSize;
    }
    if (this._maxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxFileSize = this._maxFileSize;
    }
    if (this._maxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxSize = this._maxSize;
    }
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputSplunkPq | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._commitFrequency = undefined;
      this._compress = undefined;
      this._maxBufferSize = undefined;
      this._maxFileSize = undefined;
      this._maxSize = undefined;
      this._mode = undefined;
      this._path = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._commitFrequency = value.commitFrequency;
      this._compress = value.compress;
      this._maxBufferSize = value.maxBufferSize;
      this._maxFileSize = value.maxFileSize;
      this._maxSize = value.maxSize;
      this._mode = value.mode;
      this._path = value.path;
    }
  }

  // commit_frequency - computed: true, optional: true, required: false
  private _commitFrequency?: number; 
  public get commitFrequency() {
    return this.getNumberAttribute('commit_frequency');
  }
  public set commitFrequency(value: number) {
    this._commitFrequency = value;
  }
  public resetCommitFrequency() {
    this._commitFrequency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commitFrequencyInput() {
    return this._commitFrequency;
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: string; 
  public get compress() {
    return this.getStringAttribute('compress');
  }
  public set compress(value: string) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // max_buffer_size - computed: true, optional: true, required: false
  private _maxBufferSize?: number; 
  public get maxBufferSize() {
    return this.getNumberAttribute('max_buffer_size');
  }
  public set maxBufferSize(value: number) {
    this._maxBufferSize = value;
  }
  public resetMaxBufferSize() {
    this._maxBufferSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBufferSizeInput() {
    return this._maxBufferSize;
  }

  // max_file_size - computed: true, optional: true, required: false
  private _maxFileSize?: string; 
  public get maxFileSize() {
    return this.getStringAttribute('max_file_size');
  }
  public set maxFileSize(value: string) {
    this._maxFileSize = value;
  }
  public resetMaxFileSize() {
    this._maxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxFileSizeInput() {
    return this._maxFileSize;
  }

  // max_size - computed: true, optional: true, required: false
  private _maxSize?: string; 
  public get maxSize() {
    return this.getStringAttribute('max_size');
  }
  public set maxSize(value: string) {
    this._maxSize = value;
  }
  public resetMaxSize() {
    this._maxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxSizeInput() {
    return this._maxSize;
  }

  // mode - computed: true, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // path - computed: true, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }
}
export interface PackSourceInputSplunkTls {
  /**
  * Path on server containing CA certificates to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#ca_path PackSource#ca_path}
  */
  readonly caPath?: string;
  /**
  * Path on server containing certificates to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#cert_path PackSource#cert_path}
  */
  readonly certPath?: string;
  /**
  * The name of the predefined certificate
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#certificate_name PackSource#certificate_name}
  */
  readonly certificateName?: string;
  /**
  * Parsed as JSON.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#common_name_regex PackSource#common_name_regex}
  */
  readonly commonNameRegex?: string;
  /**
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#disabled PackSource#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_version PackSource#max_version}
  */
  readonly maxVersion?: string;
  /**
  * must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#min_version PackSource#min_version}
  */
  readonly minVersion?: string;
  /**
  * Passphrase to use to decrypt private key
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#passphrase PackSource#passphrase}
  */
  readonly passphrase?: string;
  /**
  * Path on server containing the private key to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#priv_key_path PackSource#priv_key_path}
  */
  readonly privKeyPath?: string;
  /**
  * Parsed as JSON.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#reject_unauthorized PackSource#reject_unauthorized}
  */
  readonly rejectUnauthorized?: string;
  /**
  * Require clients to present their certificates. Used to perform client authentication using SSL certs. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#request_cert PackSource#request_cert}
  */
  readonly requestCert?: boolean | cdktf.IResolvable;
}

export function packSourceInputSplunkTlsToTerraform(struct?: PackSourceInputSplunkTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ca_path: cdktf.stringToTerraform(struct!.caPath),
    cert_path: cdktf.stringToTerraform(struct!.certPath),
    certificate_name: cdktf.stringToTerraform(struct!.certificateName),
    common_name_regex: cdktf.stringToTerraform(struct!.commonNameRegex),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    max_version: cdktf.stringToTerraform(struct!.maxVersion),
    min_version: cdktf.stringToTerraform(struct!.minVersion),
    passphrase: cdktf.stringToTerraform(struct!.passphrase),
    priv_key_path: cdktf.stringToTerraform(struct!.privKeyPath),
    reject_unauthorized: cdktf.stringToTerraform(struct!.rejectUnauthorized),
    request_cert: cdktf.booleanToTerraform(struct!.requestCert),
  }
}


export function packSourceInputSplunkTlsToHclTerraform(struct?: PackSourceInputSplunkTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ca_path: {
      value: cdktf.stringToHclTerraform(struct!.caPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    cert_path: {
      value: cdktf.stringToHclTerraform(struct!.certPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    certificate_name: {
      value: cdktf.stringToHclTerraform(struct!.certificateName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    common_name_regex: {
      value: cdktf.stringToHclTerraform(struct!.commonNameRegex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    max_version: {
      value: cdktf.stringToHclTerraform(struct!.maxVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    min_version: {
      value: cdktf.stringToHclTerraform(struct!.minVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    passphrase: {
      value: cdktf.stringToHclTerraform(struct!.passphrase),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    priv_key_path: {
      value: cdktf.stringToHclTerraform(struct!.privKeyPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reject_unauthorized: {
      value: cdktf.stringToHclTerraform(struct!.rejectUnauthorized),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    request_cert: {
      value: cdktf.booleanToHclTerraform(struct!.requestCert),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputSplunkTlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputSplunkTls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._caPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.caPath = this._caPath;
    }
    if (this._certPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.certPath = this._certPath;
    }
    if (this._certificateName !== undefined) {
      hasAnyValues = true;
      internalValueResult.certificateName = this._certificateName;
    }
    if (this._commonNameRegex !== undefined) {
      hasAnyValues = true;
      internalValueResult.commonNameRegex = this._commonNameRegex;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._maxVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxVersion = this._maxVersion;
    }
    if (this._minVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.minVersion = this._minVersion;
    }
    if (this._passphrase !== undefined) {
      hasAnyValues = true;
      internalValueResult.passphrase = this._passphrase;
    }
    if (this._privKeyPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.privKeyPath = this._privKeyPath;
    }
    if (this._rejectUnauthorized !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectUnauthorized = this._rejectUnauthorized;
    }
    if (this._requestCert !== undefined) {
      hasAnyValues = true;
      internalValueResult.requestCert = this._requestCert;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputSplunkTls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._caPath = undefined;
      this._certPath = undefined;
      this._certificateName = undefined;
      this._commonNameRegex = undefined;
      this._disabled = undefined;
      this._maxVersion = undefined;
      this._minVersion = undefined;
      this._passphrase = undefined;
      this._privKeyPath = undefined;
      this._rejectUnauthorized = undefined;
      this._requestCert = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._caPath = value.caPath;
      this._certPath = value.certPath;
      this._certificateName = value.certificateName;
      this._commonNameRegex = value.commonNameRegex;
      this._disabled = value.disabled;
      this._maxVersion = value.maxVersion;
      this._minVersion = value.minVersion;
      this._passphrase = value.passphrase;
      this._privKeyPath = value.privKeyPath;
      this._rejectUnauthorized = value.rejectUnauthorized;
      this._requestCert = value.requestCert;
    }
  }

  // ca_path - computed: false, optional: true, required: false
  private _caPath?: string; 
  public get caPath() {
    return this.getStringAttribute('ca_path');
  }
  public set caPath(value: string) {
    this._caPath = value;
  }
  public resetCaPath() {
    this._caPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get caPathInput() {
    return this._caPath;
  }

  // cert_path - computed: false, optional: true, required: false
  private _certPath?: string; 
  public get certPath() {
    return this.getStringAttribute('cert_path');
  }
  public set certPath(value: string) {
    this._certPath = value;
  }
  public resetCertPath() {
    this._certPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certPathInput() {
    return this._certPath;
  }

  // certificate_name - computed: false, optional: true, required: false
  private _certificateName?: string; 
  public get certificateName() {
    return this.getStringAttribute('certificate_name');
  }
  public set certificateName(value: string) {
    this._certificateName = value;
  }
  public resetCertificateName() {
    this._certificateName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certificateNameInput() {
    return this._certificateName;
  }

  // common_name_regex - computed: false, optional: true, required: false
  private _commonNameRegex?: string; 
  public get commonNameRegex() {
    return this.getStringAttribute('common_name_regex');
  }
  public set commonNameRegex(value: string) {
    this._commonNameRegex = value;
  }
  public resetCommonNameRegex() {
    this._commonNameRegex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commonNameRegexInput() {
    return this._commonNameRegex;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // max_version - computed: false, optional: true, required: false
  private _maxVersion?: string; 
  public get maxVersion() {
    return this.getStringAttribute('max_version');
  }
  public set maxVersion(value: string) {
    this._maxVersion = value;
  }
  public resetMaxVersion() {
    this._maxVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxVersionInput() {
    return this._maxVersion;
  }

  // min_version - computed: false, optional: true, required: false
  private _minVersion?: string; 
  public get minVersion() {
    return this.getStringAttribute('min_version');
  }
  public set minVersion(value: string) {
    this._minVersion = value;
  }
  public resetMinVersion() {
    this._minVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get minVersionInput() {
    return this._minVersion;
  }

  // passphrase - computed: false, optional: true, required: false
  private _passphrase?: string; 
  public get passphrase() {
    return this.getStringAttribute('passphrase');
  }
  public set passphrase(value: string) {
    this._passphrase = value;
  }
  public resetPassphrase() {
    this._passphrase = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passphraseInput() {
    return this._passphrase;
  }

  // priv_key_path - computed: false, optional: true, required: false
  private _privKeyPath?: string; 
  public get privKeyPath() {
    return this.getStringAttribute('priv_key_path');
  }
  public set privKeyPath(value: string) {
    this._privKeyPath = value;
  }
  public resetPrivKeyPath() {
    this._privKeyPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get privKeyPathInput() {
    return this._privKeyPath;
  }

  // reject_unauthorized - computed: false, optional: true, required: false
  private _rejectUnauthorized?: string; 
  public get rejectUnauthorized() {
    return this.getStringAttribute('reject_unauthorized');
  }
  public set rejectUnauthorized(value: string) {
    this._rejectUnauthorized = value;
  }
  public resetRejectUnauthorized() {
    this._rejectUnauthorized = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectUnauthorizedInput() {
    return this._rejectUnauthorized;
  }

  // request_cert - computed: true, optional: true, required: false
  private _requestCert?: boolean | cdktf.IResolvable; 
  public get requestCert() {
    return this.getBooleanAttribute('request_cert');
  }
  public set requestCert(value: boolean | cdktf.IResolvable) {
    this._requestCert = value;
  }
  public resetRequestCert() {
    this._requestCert = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestCertInput() {
    return this._requestCert;
  }
}
export interface PackSourceInputSplunk {
  /**
  * Shared secrets to be provided by any Splunk forwarder. If empty, unauthorized access is permitted.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#auth_tokens PackSource#auth_tokens}
  */
  readonly authTokens?: PackSourceInputSplunkAuthTokens[] | cdktf.IResolvable;
  /**
  * A list of event-breaking rulesets that will be applied, in order, to the input data stream
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#breaker_rulesets PackSource#breaker_rulesets}
  */
  readonly breakerRulesets?: string[];
  /**
  * Controls whether to support reading compressed data from a forwarder. Select 'Automatic' to match the forwarder's configuration, or 'Disabled' to reject compressed connections. Default: "disabled"; must be one of ["disabled", "auto", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#compress PackSource#compress}
  */
  readonly compress?: string;
  /**
  * Direct connections to Destinations, and optionally via a Pipeline or a Pack
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#connections PackSource#connections}
  */
  readonly connections?: PackSourceInputSplunkConnections[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#description PackSource#description}
  */
  readonly description?: string;
  /**
  * Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#disabled PackSource#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * Drop Splunk control fields such as `crcSalt` and `_savedPort`. If disabled, control fields are stored in the internal field `__ctrlFields`. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#drop_control_fields PackSource#drop_control_fields}
  */
  readonly dropControlFields?: boolean | cdktf.IResolvable;
  /**
  * Enable if the connection is proxied by a device that supports proxy protocol v1 or v2. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#enable_proxy_header PackSource#enable_proxy_header}
  */
  readonly enableProxyHeader?: boolean | cdktf.IResolvable;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#environment PackSource#environment}
  */
  readonly environment?: string;
  /**
  * Extract and process Splunk-generated metrics as Cribl metrics. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#extract_metrics PackSource#extract_metrics}
  */
  readonly extractMetrics?: boolean | cdktf.IResolvable;
  /**
  * Address to bind on. Defaults to 0.0.0.0 (all addresses). Default: "0.0.0.0"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#host PackSource#host}
  */
  readonly host?: string;
  /**
  * Unique ID for this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#id PackSource#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * Regex matching IP addresses that are allowed to establish a connection. Default: "/.* /"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#ip_whitelist_regex PackSource#ip_whitelist_regex}
   *
  * Note: The above comment contained a comment block ending sequence (* followed by /). We have introduced a space between to prevent syntax errors. Please ignore the space.
  */
  readonly ipWhitelistRegex?: string;
  /**
  * Maximum number of active connections allowed per Worker Process. Use 0 for unlimited. Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_active_cxn PackSource#max_active_cxn}
  */
  readonly maxActiveCxn?: number;
  /**
  * The highest S2S protocol version to advertise during handshake. Default: "v3"; must be one of ["v3", "v4"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_s2_sversion PackSource#max_s2_sversion}
  */
  readonly maxS2Sversion?: string;
  /**
  * Fields to add to events from this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#metadata PackSource#metadata}
  */
  readonly metadata?: PackSourceInputSplunkMetadata[] | cdktf.IResolvable;
  /**
  * Pipeline to process data from this Source before sending it through the Routes
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pipeline PackSource#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Port to listen on
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#port PackSource#port}
  */
  readonly port: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pq PackSource#pq}
  */
  readonly pq?: PackSourceInputSplunkPq;
  /**
  * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers). Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pq_enabled PackSource#pq_enabled}
  */
  readonly pqEnabled?: boolean | cdktf.IResolvable;
  /**
  * Select whether to send data to Routes, or directly to Destinations. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#send_to_routes PackSource#send_to_routes}
  */
  readonly sendToRoutes?: boolean | cdktf.IResolvable;
  /**
  * How long the server will wait after initiating a closure for a client to close its end of the connection. If the client doesn't close the connection within this time, the server will forcefully terminate the socket to prevent resource leaks and ensure efficient connection cleanup and system stability. Leave at 0 for no inactive socket monitoring. Default: 30
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#socket_ending_max_wait PackSource#socket_ending_max_wait}
  */
  readonly socketEndingMaxWait?: number;
  /**
  * How long @{product} should wait before assuming that an inactive socket has timed out. After this time, the connection will be closed. Leave at 0 for no inactive socket monitoring. Default: 0
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#socket_idle_timeout PackSource#socket_idle_timeout}
  */
  readonly socketIdleTimeout?: number;
  /**
  * The maximum duration a socket can remain open, even if active. This helps manage resources and mitigate issues caused by TCP pinning. Set to 0 to disable. Default: 0
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#socket_max_lifespan PackSource#socket_max_lifespan}
  */
  readonly socketMaxLifespan?: number;
  /**
  * How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines. Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#stale_channel_flush_ms PackSource#stale_channel_flush_ms}
  */
  readonly staleChannelFlushMs?: number;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#streamtags PackSource#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#tls PackSource#tls}
  */
  readonly tls?: PackSourceInputSplunkTls;
  /**
  * must be "splunk"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#type PackSource#type}
  */
  readonly type?: string;
  /**
  * Event Breakers will determine events' time zone from UF-provided metadata, when TZ can't be inferred from the raw event. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#use_fwd_timezone PackSource#use_fwd_timezone}
  */
  readonly useFwdTimezone?: boolean | cdktf.IResolvable;
}

export function packSourceInputSplunkToTerraform(struct?: PackSourceInputSplunk | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    auth_tokens: cdktf.listMapper(packSourceInputSplunkAuthTokensToTerraform, false)(struct!.authTokens),
    breaker_rulesets: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.breakerRulesets),
    compress: cdktf.stringToTerraform(struct!.compress),
    connections: cdktf.listMapper(packSourceInputSplunkConnectionsToTerraform, false)(struct!.connections),
    description: cdktf.stringToTerraform(struct!.description),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    drop_control_fields: cdktf.booleanToTerraform(struct!.dropControlFields),
    enable_proxy_header: cdktf.booleanToTerraform(struct!.enableProxyHeader),
    environment: cdktf.stringToTerraform(struct!.environment),
    extract_metrics: cdktf.booleanToTerraform(struct!.extractMetrics),
    host: cdktf.stringToTerraform(struct!.host),
    id: cdktf.stringToTerraform(struct!.id),
    ip_whitelist_regex: cdktf.stringToTerraform(struct!.ipWhitelistRegex),
    max_active_cxn: cdktf.numberToTerraform(struct!.maxActiveCxn),
    max_s2_sversion: cdktf.stringToTerraform(struct!.maxS2Sversion),
    metadata: cdktf.listMapper(packSourceInputSplunkMetadataToTerraform, false)(struct!.metadata),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    port: cdktf.numberToTerraform(struct!.port),
    pq: packSourceInputSplunkPqToTerraform(struct!.pq),
    pq_enabled: cdktf.booleanToTerraform(struct!.pqEnabled),
    send_to_routes: cdktf.booleanToTerraform(struct!.sendToRoutes),
    socket_ending_max_wait: cdktf.numberToTerraform(struct!.socketEndingMaxWait),
    socket_idle_timeout: cdktf.numberToTerraform(struct!.socketIdleTimeout),
    socket_max_lifespan: cdktf.numberToTerraform(struct!.socketMaxLifespan),
    stale_channel_flush_ms: cdktf.numberToTerraform(struct!.staleChannelFlushMs),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    tls: packSourceInputSplunkTlsToTerraform(struct!.tls),
    type: cdktf.stringToTerraform(struct!.type),
    use_fwd_timezone: cdktf.booleanToTerraform(struct!.useFwdTimezone),
  }
}


export function packSourceInputSplunkToHclTerraform(struct?: PackSourceInputSplunk | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    auth_tokens: {
      value: cdktf.listMapperHcl(packSourceInputSplunkAuthTokensToHclTerraform, false)(struct!.authTokens),
      isBlock: true,
      type: "list",
      storageClassType: "PackSourceInputSplunkAuthTokensList",
    },
    breaker_rulesets: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.breakerRulesets),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    compress: {
      value: cdktf.stringToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    connections: {
      value: cdktf.listMapperHcl(packSourceInputSplunkConnectionsToHclTerraform, false)(struct!.connections),
      isBlock: true,
      type: "list",
      storageClassType: "PackSourceInputSplunkConnectionsList",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    drop_control_fields: {
      value: cdktf.booleanToHclTerraform(struct!.dropControlFields),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    enable_proxy_header: {
      value: cdktf.booleanToHclTerraform(struct!.enableProxyHeader),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    extract_metrics: {
      value: cdktf.booleanToHclTerraform(struct!.extractMetrics),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    host: {
      value: cdktf.stringToHclTerraform(struct!.host),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ip_whitelist_regex: {
      value: cdktf.stringToHclTerraform(struct!.ipWhitelistRegex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_active_cxn: {
      value: cdktf.numberToHclTerraform(struct!.maxActiveCxn),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_s2_sversion: {
      value: cdktf.stringToHclTerraform(struct!.maxS2Sversion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    metadata: {
      value: cdktf.listMapperHcl(packSourceInputSplunkMetadataToHclTerraform, false)(struct!.metadata),
      isBlock: true,
      type: "list",
      storageClassType: "PackSourceInputSplunkMetadataList",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    pq: {
      value: packSourceInputSplunkPqToHclTerraform(struct!.pq),
      isBlock: true,
      type: "struct",
      storageClassType: "PackSourceInputSplunkPq",
    },
    pq_enabled: {
      value: cdktf.booleanToHclTerraform(struct!.pqEnabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    send_to_routes: {
      value: cdktf.booleanToHclTerraform(struct!.sendToRoutes),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    socket_ending_max_wait: {
      value: cdktf.numberToHclTerraform(struct!.socketEndingMaxWait),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    socket_idle_timeout: {
      value: cdktf.numberToHclTerraform(struct!.socketIdleTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    socket_max_lifespan: {
      value: cdktf.numberToHclTerraform(struct!.socketMaxLifespan),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    stale_channel_flush_ms: {
      value: cdktf.numberToHclTerraform(struct!.staleChannelFlushMs),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    tls: {
      value: packSourceInputSplunkTlsToHclTerraform(struct!.tls),
      isBlock: true,
      type: "struct",
      storageClassType: "PackSourceInputSplunkTls",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    use_fwd_timezone: {
      value: cdktf.booleanToHclTerraform(struct!.useFwdTimezone),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputSplunkOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputSplunk | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._authTokens?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.authTokens = this._authTokens?.internalValue;
    }
    if (this._breakerRulesets !== undefined) {
      hasAnyValues = true;
      internalValueResult.breakerRulesets = this._breakerRulesets;
    }
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._connections?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.connections = this._connections?.internalValue;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._dropControlFields !== undefined) {
      hasAnyValues = true;
      internalValueResult.dropControlFields = this._dropControlFields;
    }
    if (this._enableProxyHeader !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableProxyHeader = this._enableProxyHeader;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._extractMetrics !== undefined) {
      hasAnyValues = true;
      internalValueResult.extractMetrics = this._extractMetrics;
    }
    if (this._host !== undefined) {
      hasAnyValues = true;
      internalValueResult.host = this._host;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._ipWhitelistRegex !== undefined) {
      hasAnyValues = true;
      internalValueResult.ipWhitelistRegex = this._ipWhitelistRegex;
    }
    if (this._maxActiveCxn !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxActiveCxn = this._maxActiveCxn;
    }
    if (this._maxS2Sversion !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxS2Sversion = this._maxS2Sversion;
    }
    if (this._metadata?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadata = this._metadata?.internalValue;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._pq?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pq = this._pq?.internalValue;
    }
    if (this._pqEnabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqEnabled = this._pqEnabled;
    }
    if (this._sendToRoutes !== undefined) {
      hasAnyValues = true;
      internalValueResult.sendToRoutes = this._sendToRoutes;
    }
    if (this._socketEndingMaxWait !== undefined) {
      hasAnyValues = true;
      internalValueResult.socketEndingMaxWait = this._socketEndingMaxWait;
    }
    if (this._socketIdleTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.socketIdleTimeout = this._socketIdleTimeout;
    }
    if (this._socketMaxLifespan !== undefined) {
      hasAnyValues = true;
      internalValueResult.socketMaxLifespan = this._socketMaxLifespan;
    }
    if (this._staleChannelFlushMs !== undefined) {
      hasAnyValues = true;
      internalValueResult.staleChannelFlushMs = this._staleChannelFlushMs;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._tls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tls = this._tls?.internalValue;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._useFwdTimezone !== undefined) {
      hasAnyValues = true;
      internalValueResult.useFwdTimezone = this._useFwdTimezone;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputSplunk | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._authTokens.internalValue = undefined;
      this._breakerRulesets = undefined;
      this._compress = undefined;
      this._connections.internalValue = undefined;
      this._description = undefined;
      this._disabled = undefined;
      this._dropControlFields = undefined;
      this._enableProxyHeader = undefined;
      this._environment = undefined;
      this._extractMetrics = undefined;
      this._host = undefined;
      this._id = undefined;
      this._ipWhitelistRegex = undefined;
      this._maxActiveCxn = undefined;
      this._maxS2Sversion = undefined;
      this._metadata.internalValue = undefined;
      this._pipeline = undefined;
      this._port = undefined;
      this._pq.internalValue = undefined;
      this._pqEnabled = undefined;
      this._sendToRoutes = undefined;
      this._socketEndingMaxWait = undefined;
      this._socketIdleTimeout = undefined;
      this._socketMaxLifespan = undefined;
      this._staleChannelFlushMs = undefined;
      this._streamtags = undefined;
      this._tls.internalValue = undefined;
      this._type = undefined;
      this._useFwdTimezone = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._authTokens.internalValue = value.authTokens;
      this._breakerRulesets = value.breakerRulesets;
      this._compress = value.compress;
      this._connections.internalValue = value.connections;
      this._description = value.description;
      this._disabled = value.disabled;
      this._dropControlFields = value.dropControlFields;
      this._enableProxyHeader = value.enableProxyHeader;
      this._environment = value.environment;
      this._extractMetrics = value.extractMetrics;
      this._host = value.host;
      this._id = value.id;
      this._ipWhitelistRegex = value.ipWhitelistRegex;
      this._maxActiveCxn = value.maxActiveCxn;
      this._maxS2Sversion = value.maxS2Sversion;
      this._metadata.internalValue = value.metadata;
      this._pipeline = value.pipeline;
      this._port = value.port;
      this._pq.internalValue = value.pq;
      this._pqEnabled = value.pqEnabled;
      this._sendToRoutes = value.sendToRoutes;
      this._socketEndingMaxWait = value.socketEndingMaxWait;
      this._socketIdleTimeout = value.socketIdleTimeout;
      this._socketMaxLifespan = value.socketMaxLifespan;
      this._staleChannelFlushMs = value.staleChannelFlushMs;
      this._streamtags = value.streamtags;
      this._tls.internalValue = value.tls;
      this._type = value.type;
      this._useFwdTimezone = value.useFwdTimezone;
    }
  }

  // auth_tokens - computed: false, optional: true, required: false
  private _authTokens = new PackSourceInputSplunkAuthTokensList(this, "auth_tokens", false);
  public get authTokens() {
    return this._authTokens;
  }
  public putAuthTokens(value: PackSourceInputSplunkAuthTokens[] | cdktf.IResolvable) {
    this._authTokens.internalValue = value;
  }
  public resetAuthTokens() {
    this._authTokens.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authTokensInput() {
    return this._authTokens.internalValue;
  }

  // breaker_rulesets - computed: false, optional: true, required: false
  private _breakerRulesets?: string[]; 
  public get breakerRulesets() {
    return this.getListAttribute('breaker_rulesets');
  }
  public set breakerRulesets(value: string[]) {
    this._breakerRulesets = value;
  }
  public resetBreakerRulesets() {
    this._breakerRulesets = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get breakerRulesetsInput() {
    return this._breakerRulesets;
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: string; 
  public get compress() {
    return this.getStringAttribute('compress');
  }
  public set compress(value: string) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // connections - computed: false, optional: true, required: false
  private _connections = new PackSourceInputSplunkConnectionsList(this, "connections", false);
  public get connections() {
    return this._connections;
  }
  public putConnections(value: PackSourceInputSplunkConnections[] | cdktf.IResolvable) {
    this._connections.internalValue = value;
  }
  public resetConnections() {
    this._connections.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectionsInput() {
    return this._connections.internalValue;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // drop_control_fields - computed: true, optional: true, required: false
  private _dropControlFields?: boolean | cdktf.IResolvable; 
  public get dropControlFields() {
    return this.getBooleanAttribute('drop_control_fields');
  }
  public set dropControlFields(value: boolean | cdktf.IResolvable) {
    this._dropControlFields = value;
  }
  public resetDropControlFields() {
    this._dropControlFields = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dropControlFieldsInput() {
    return this._dropControlFields;
  }

  // enable_proxy_header - computed: true, optional: true, required: false
  private _enableProxyHeader?: boolean | cdktf.IResolvable; 
  public get enableProxyHeader() {
    return this.getBooleanAttribute('enable_proxy_header');
  }
  public set enableProxyHeader(value: boolean | cdktf.IResolvable) {
    this._enableProxyHeader = value;
  }
  public resetEnableProxyHeader() {
    this._enableProxyHeader = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableProxyHeaderInput() {
    return this._enableProxyHeader;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // extract_metrics - computed: true, optional: true, required: false
  private _extractMetrics?: boolean | cdktf.IResolvable; 
  public get extractMetrics() {
    return this.getBooleanAttribute('extract_metrics');
  }
  public set extractMetrics(value: boolean | cdktf.IResolvable) {
    this._extractMetrics = value;
  }
  public resetExtractMetrics() {
    this._extractMetrics = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get extractMetricsInput() {
    return this._extractMetrics;
  }

  // host - computed: true, optional: true, required: false
  private _host?: string; 
  public get host() {
    return this.getStringAttribute('host');
  }
  public set host(value: string) {
    this._host = value;
  }
  public resetHost() {
    this._host = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostInput() {
    return this._host;
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // ip_whitelist_regex - computed: true, optional: true, required: false
  private _ipWhitelistRegex?: string; 
  public get ipWhitelistRegex() {
    return this.getStringAttribute('ip_whitelist_regex');
  }
  public set ipWhitelistRegex(value: string) {
    this._ipWhitelistRegex = value;
  }
  public resetIpWhitelistRegex() {
    this._ipWhitelistRegex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ipWhitelistRegexInput() {
    return this._ipWhitelistRegex;
  }

  // max_active_cxn - computed: true, optional: true, required: false
  private _maxActiveCxn?: number; 
  public get maxActiveCxn() {
    return this.getNumberAttribute('max_active_cxn');
  }
  public set maxActiveCxn(value: number) {
    this._maxActiveCxn = value;
  }
  public resetMaxActiveCxn() {
    this._maxActiveCxn = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxActiveCxnInput() {
    return this._maxActiveCxn;
  }

  // max_s2_sversion - computed: true, optional: true, required: false
  private _maxS2Sversion?: string; 
  public get maxS2Sversion() {
    return this.getStringAttribute('max_s2_sversion');
  }
  public set maxS2Sversion(value: string) {
    this._maxS2Sversion = value;
  }
  public resetMaxS2Sversion() {
    this._maxS2Sversion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxS2SversionInput() {
    return this._maxS2Sversion;
  }

  // metadata - computed: false, optional: true, required: false
  private _metadata = new PackSourceInputSplunkMetadataList(this, "metadata", false);
  public get metadata() {
    return this._metadata;
  }
  public putMetadata(value: PackSourceInputSplunkMetadata[] | cdktf.IResolvable) {
    this._metadata.internalValue = value;
  }
  public resetMetadata() {
    this._metadata.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataInput() {
    return this._metadata.internalValue;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // port - computed: false, optional: false, required: true
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // pq - computed: false, optional: true, required: false
  private _pq = new PackSourceInputSplunkPqOutputReference(this, "pq");
  public get pq() {
    return this._pq;
  }
  public putPq(value: PackSourceInputSplunkPq) {
    this._pq.internalValue = value;
  }
  public resetPq() {
    this._pq.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqInput() {
    return this._pq.internalValue;
  }

  // pq_enabled - computed: true, optional: true, required: false
  private _pqEnabled?: boolean | cdktf.IResolvable; 
  public get pqEnabled() {
    return this.getBooleanAttribute('pq_enabled');
  }
  public set pqEnabled(value: boolean | cdktf.IResolvable) {
    this._pqEnabled = value;
  }
  public resetPqEnabled() {
    this._pqEnabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqEnabledInput() {
    return this._pqEnabled;
  }

  // send_to_routes - computed: true, optional: true, required: false
  private _sendToRoutes?: boolean | cdktf.IResolvable; 
  public get sendToRoutes() {
    return this.getBooleanAttribute('send_to_routes');
  }
  public set sendToRoutes(value: boolean | cdktf.IResolvable) {
    this._sendToRoutes = value;
  }
  public resetSendToRoutes() {
    this._sendToRoutes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sendToRoutesInput() {
    return this._sendToRoutes;
  }

  // socket_ending_max_wait - computed: true, optional: true, required: false
  private _socketEndingMaxWait?: number; 
  public get socketEndingMaxWait() {
    return this.getNumberAttribute('socket_ending_max_wait');
  }
  public set socketEndingMaxWait(value: number) {
    this._socketEndingMaxWait = value;
  }
  public resetSocketEndingMaxWait() {
    this._socketEndingMaxWait = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get socketEndingMaxWaitInput() {
    return this._socketEndingMaxWait;
  }

  // socket_idle_timeout - computed: true, optional: true, required: false
  private _socketIdleTimeout?: number; 
  public get socketIdleTimeout() {
    return this.getNumberAttribute('socket_idle_timeout');
  }
  public set socketIdleTimeout(value: number) {
    this._socketIdleTimeout = value;
  }
  public resetSocketIdleTimeout() {
    this._socketIdleTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get socketIdleTimeoutInput() {
    return this._socketIdleTimeout;
  }

  // socket_max_lifespan - computed: true, optional: true, required: false
  private _socketMaxLifespan?: number; 
  public get socketMaxLifespan() {
    return this.getNumberAttribute('socket_max_lifespan');
  }
  public set socketMaxLifespan(value: number) {
    this._socketMaxLifespan = value;
  }
  public resetSocketMaxLifespan() {
    this._socketMaxLifespan = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get socketMaxLifespanInput() {
    return this._socketMaxLifespan;
  }

  // stale_channel_flush_ms - computed: true, optional: true, required: false
  private _staleChannelFlushMs?: number; 
  public get staleChannelFlushMs() {
    return this.getNumberAttribute('stale_channel_flush_ms');
  }
  public set staleChannelFlushMs(value: number) {
    this._staleChannelFlushMs = value;
  }
  public resetStaleChannelFlushMs() {
    this._staleChannelFlushMs = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get staleChannelFlushMsInput() {
    return this._staleChannelFlushMs;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // tls - computed: false, optional: true, required: false
  private _tls = new PackSourceInputSplunkTlsOutputReference(this, "tls");
  public get tls() {
    return this._tls;
  }
  public putTls(value: PackSourceInputSplunkTls) {
    this._tls.internalValue = value;
  }
  public resetTls() {
    this._tls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsInput() {
    return this._tls.internalValue;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // use_fwd_timezone - computed: true, optional: true, required: false
  private _useFwdTimezone?: boolean | cdktf.IResolvable; 
  public get useFwdTimezone() {
    return this.getBooleanAttribute('use_fwd_timezone');
  }
  public set useFwdTimezone(value: boolean | cdktf.IResolvable) {
    this._useFwdTimezone = value;
  }
  public resetUseFwdTimezone() {
    this._useFwdTimezone = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get useFwdTimezoneInput() {
    return this._useFwdTimezone;
  }
}
export interface PackSourceInputSplunkHecAuthTokensMetadata {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#name PackSource#name}
  */
  readonly name: string;
  /**
  * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#value PackSource#value}
  */
  readonly value: string;
}

export function packSourceInputSplunkHecAuthTokensMetadataToTerraform(struct?: PackSourceInputSplunkHecAuthTokensMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function packSourceInputSplunkHecAuthTokensMetadataToHclTerraform(struct?: PackSourceInputSplunkHecAuthTokensMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputSplunkHecAuthTokensMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackSourceInputSplunkHecAuthTokensMetadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputSplunkHecAuthTokensMetadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class PackSourceInputSplunkHecAuthTokensMetadataList extends cdktf.ComplexList {
  public internalValue? : PackSourceInputSplunkHecAuthTokensMetadata[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackSourceInputSplunkHecAuthTokensMetadataOutputReference {
    return new PackSourceInputSplunkHecAuthTokensMetadataOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackSourceInputSplunkHecAuthTokens {
  /**
  * Enter the values you want to allow in the HEC event index field at the token level. Supports wildcards. To skip validation, leave blank.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#allowed_indexes_at_token PackSource#allowed_indexes_at_token}
  */
  readonly allowedIndexesAtToken?: string[];
  /**
  * Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate. Default: "manual"; must be one of ["manual", "secret"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#auth_type PackSource#auth_type}
  */
  readonly authType?: string;
  /**
  * Optional token description
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#description PackSource#description}
  */
  readonly description?: string;
  /**
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#enabled PackSource#enabled}
  */
  readonly enabled?: boolean | cdktf.IResolvable;
  /**
  * Fields to add to events referencing this token
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#metadata PackSource#metadata}
  */
  readonly metadata?: PackSourceInputSplunkHecAuthTokensMetadata[] | cdktf.IResolvable;
  /**
  * Parsed as JSON.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#token PackSource#token}
  */
  readonly token: string;
  /**
  * Parsed as JSON.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#token_secret PackSource#token_secret}
  */
  readonly tokenSecret?: string;
}

export function packSourceInputSplunkHecAuthTokensToTerraform(struct?: PackSourceInputSplunkHecAuthTokens | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    allowed_indexes_at_token: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.allowedIndexesAtToken),
    auth_type: cdktf.stringToTerraform(struct!.authType),
    description: cdktf.stringToTerraform(struct!.description),
    enabled: cdktf.booleanToTerraform(struct!.enabled),
    metadata: cdktf.listMapper(packSourceInputSplunkHecAuthTokensMetadataToTerraform, false)(struct!.metadata),
    token: cdktf.stringToTerraform(struct!.token),
    token_secret: cdktf.stringToTerraform(struct!.tokenSecret),
  }
}


export function packSourceInputSplunkHecAuthTokensToHclTerraform(struct?: PackSourceInputSplunkHecAuthTokens | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    allowed_indexes_at_token: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.allowedIndexesAtToken),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    auth_type: {
      value: cdktf.stringToHclTerraform(struct!.authType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    enabled: {
      value: cdktf.booleanToHclTerraform(struct!.enabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    metadata: {
      value: cdktf.listMapperHcl(packSourceInputSplunkHecAuthTokensMetadataToHclTerraform, false)(struct!.metadata),
      isBlock: true,
      type: "list",
      storageClassType: "PackSourceInputSplunkHecAuthTokensMetadataList",
    },
    token: {
      value: cdktf.stringToHclTerraform(struct!.token),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    token_secret: {
      value: cdktf.stringToHclTerraform(struct!.tokenSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputSplunkHecAuthTokensOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackSourceInputSplunkHecAuthTokens | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._allowedIndexesAtToken !== undefined) {
      hasAnyValues = true;
      internalValueResult.allowedIndexesAtToken = this._allowedIndexesAtToken;
    }
    if (this._authType !== undefined) {
      hasAnyValues = true;
      internalValueResult.authType = this._authType;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._enabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.enabled = this._enabled;
    }
    if (this._metadata?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadata = this._metadata?.internalValue;
    }
    if (this._token !== undefined) {
      hasAnyValues = true;
      internalValueResult.token = this._token;
    }
    if (this._tokenSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.tokenSecret = this._tokenSecret;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputSplunkHecAuthTokens | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._allowedIndexesAtToken = undefined;
      this._authType = undefined;
      this._description = undefined;
      this._enabled = undefined;
      this._metadata.internalValue = undefined;
      this._token = undefined;
      this._tokenSecret = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._allowedIndexesAtToken = value.allowedIndexesAtToken;
      this._authType = value.authType;
      this._description = value.description;
      this._enabled = value.enabled;
      this._metadata.internalValue = value.metadata;
      this._token = value.token;
      this._tokenSecret = value.tokenSecret;
    }
  }

  // allowed_indexes_at_token - computed: false, optional: true, required: false
  private _allowedIndexesAtToken?: string[]; 
  public get allowedIndexesAtToken() {
    return this.getListAttribute('allowed_indexes_at_token');
  }
  public set allowedIndexesAtToken(value: string[]) {
    this._allowedIndexesAtToken = value;
  }
  public resetAllowedIndexesAtToken() {
    this._allowedIndexesAtToken = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get allowedIndexesAtTokenInput() {
    return this._allowedIndexesAtToken;
  }

  // auth_type - computed: true, optional: true, required: false
  private _authType?: string; 
  public get authType() {
    return this.getStringAttribute('auth_type');
  }
  public set authType(value: string) {
    this._authType = value;
  }
  public resetAuthType() {
    this._authType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authTypeInput() {
    return this._authType;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // enabled - computed: true, optional: true, required: false
  private _enabled?: boolean | cdktf.IResolvable; 
  public get enabled() {
    return this.getBooleanAttribute('enabled');
  }
  public set enabled(value: boolean | cdktf.IResolvable) {
    this._enabled = value;
  }
  public resetEnabled() {
    this._enabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enabledInput() {
    return this._enabled;
  }

  // metadata - computed: false, optional: true, required: false
  private _metadata = new PackSourceInputSplunkHecAuthTokensMetadataList(this, "metadata", false);
  public get metadata() {
    return this._metadata;
  }
  public putMetadata(value: PackSourceInputSplunkHecAuthTokensMetadata[] | cdktf.IResolvable) {
    this._metadata.internalValue = value;
  }
  public resetMetadata() {
    this._metadata.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataInput() {
    return this._metadata.internalValue;
  }

  // token - computed: false, optional: false, required: true
  private _token?: string; 
  public get token() {
    return this.getStringAttribute('token');
  }
  public set token(value: string) {
    this._token = value;
  }
  // Temporarily expose input value. Use with caution.
  public get tokenInput() {
    return this._token;
  }

  // token_secret - computed: false, optional: true, required: false
  private _tokenSecret?: string; 
  public get tokenSecret() {
    return this.getStringAttribute('token_secret');
  }
  public set tokenSecret(value: string) {
    this._tokenSecret = value;
  }
  public resetTokenSecret() {
    this._tokenSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tokenSecretInput() {
    return this._tokenSecret;
  }
}

export class PackSourceInputSplunkHecAuthTokensList extends cdktf.ComplexList {
  public internalValue? : PackSourceInputSplunkHecAuthTokens[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackSourceInputSplunkHecAuthTokensOutputReference {
    return new PackSourceInputSplunkHecAuthTokensOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackSourceInputSplunkHecConnections {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#output PackSource#output}
  */
  readonly output: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pipeline PackSource#pipeline}
  */
  readonly pipeline?: string;
}

export function packSourceInputSplunkHecConnectionsToTerraform(struct?: PackSourceInputSplunkHecConnections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    output: cdktf.stringToTerraform(struct!.output),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
  }
}


export function packSourceInputSplunkHecConnectionsToHclTerraform(struct?: PackSourceInputSplunkHecConnections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    output: {
      value: cdktf.stringToHclTerraform(struct!.output),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputSplunkHecConnectionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackSourceInputSplunkHecConnections | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._output !== undefined) {
      hasAnyValues = true;
      internalValueResult.output = this._output;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputSplunkHecConnections | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._output = undefined;
      this._pipeline = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._output = value.output;
      this._pipeline = value.pipeline;
    }
  }

  // output - computed: false, optional: false, required: true
  private _output?: string; 
  public get output() {
    return this.getStringAttribute('output');
  }
  public set output(value: string) {
    this._output = value;
  }
  // Temporarily expose input value. Use with caution.
  public get outputInput() {
    return this._output;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }
}

export class PackSourceInputSplunkHecConnectionsList extends cdktf.ComplexList {
  public internalValue? : PackSourceInputSplunkHecConnections[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackSourceInputSplunkHecConnectionsOutputReference {
    return new PackSourceInputSplunkHecConnectionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackSourceInputSplunkHecMetadata {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#name PackSource#name}
  */
  readonly name: string;
  /**
  * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#value PackSource#value}
  */
  readonly value: string;
}

export function packSourceInputSplunkHecMetadataToTerraform(struct?: PackSourceInputSplunkHecMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function packSourceInputSplunkHecMetadataToHclTerraform(struct?: PackSourceInputSplunkHecMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputSplunkHecMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackSourceInputSplunkHecMetadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputSplunkHecMetadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class PackSourceInputSplunkHecMetadataList extends cdktf.ComplexList {
  public internalValue? : PackSourceInputSplunkHecMetadata[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackSourceInputSplunkHecMetadataOutputReference {
    return new PackSourceInputSplunkHecMetadataOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackSourceInputSplunkHecPq {
  /**
  * The number of events to send downstream before committing that Stream has read them. Default: 42
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#commit_frequency PackSource#commit_frequency}
  */
  readonly commitFrequency?: number;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#compress PackSource#compress}
  */
  readonly compress?: string;
  /**
  * The maximum number of events to hold in memory before writing the events to disk. Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_buffer_size PackSource#max_buffer_size}
  */
  readonly maxBufferSize?: number;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc. Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_file_size PackSource#max_file_size}
  */
  readonly maxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_size PackSource#max_size}
  */
  readonly maxSize?: string;
  /**
  * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine. Default: "always"; must be one of ["smart", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#mode PackSource#mode}
  */
  readonly mode?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#path PackSource#path}
  */
  readonly path?: string;
}

export function packSourceInputSplunkHecPqToTerraform(struct?: PackSourceInputSplunkHecPq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    commit_frequency: cdktf.numberToTerraform(struct!.commitFrequency),
    compress: cdktf.stringToTerraform(struct!.compress),
    max_buffer_size: cdktf.numberToTerraform(struct!.maxBufferSize),
    max_file_size: cdktf.stringToTerraform(struct!.maxFileSize),
    max_size: cdktf.stringToTerraform(struct!.maxSize),
    mode: cdktf.stringToTerraform(struct!.mode),
    path: cdktf.stringToTerraform(struct!.path),
  }
}


export function packSourceInputSplunkHecPqToHclTerraform(struct?: PackSourceInputSplunkHecPq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    commit_frequency: {
      value: cdktf.numberToHclTerraform(struct!.commitFrequency),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    compress: {
      value: cdktf.stringToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_buffer_size: {
      value: cdktf.numberToHclTerraform(struct!.maxBufferSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.maxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_size: {
      value: cdktf.stringToHclTerraform(struct!.maxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputSplunkHecPqOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputSplunkHecPq | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._commitFrequency !== undefined) {
      hasAnyValues = true;
      internalValueResult.commitFrequency = this._commitFrequency;
    }
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._maxBufferSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBufferSize = this._maxBufferSize;
    }
    if (this._maxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxFileSize = this._maxFileSize;
    }
    if (this._maxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxSize = this._maxSize;
    }
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputSplunkHecPq | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._commitFrequency = undefined;
      this._compress = undefined;
      this._maxBufferSize = undefined;
      this._maxFileSize = undefined;
      this._maxSize = undefined;
      this._mode = undefined;
      this._path = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._commitFrequency = value.commitFrequency;
      this._compress = value.compress;
      this._maxBufferSize = value.maxBufferSize;
      this._maxFileSize = value.maxFileSize;
      this._maxSize = value.maxSize;
      this._mode = value.mode;
      this._path = value.path;
    }
  }

  // commit_frequency - computed: true, optional: true, required: false
  private _commitFrequency?: number; 
  public get commitFrequency() {
    return this.getNumberAttribute('commit_frequency');
  }
  public set commitFrequency(value: number) {
    this._commitFrequency = value;
  }
  public resetCommitFrequency() {
    this._commitFrequency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commitFrequencyInput() {
    return this._commitFrequency;
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: string; 
  public get compress() {
    return this.getStringAttribute('compress');
  }
  public set compress(value: string) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // max_buffer_size - computed: true, optional: true, required: false
  private _maxBufferSize?: number; 
  public get maxBufferSize() {
    return this.getNumberAttribute('max_buffer_size');
  }
  public set maxBufferSize(value: number) {
    this._maxBufferSize = value;
  }
  public resetMaxBufferSize() {
    this._maxBufferSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBufferSizeInput() {
    return this._maxBufferSize;
  }

  // max_file_size - computed: true, optional: true, required: false
  private _maxFileSize?: string; 
  public get maxFileSize() {
    return this.getStringAttribute('max_file_size');
  }
  public set maxFileSize(value: string) {
    this._maxFileSize = value;
  }
  public resetMaxFileSize() {
    this._maxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxFileSizeInput() {
    return this._maxFileSize;
  }

  // max_size - computed: true, optional: true, required: false
  private _maxSize?: string; 
  public get maxSize() {
    return this.getStringAttribute('max_size');
  }
  public set maxSize(value: string) {
    this._maxSize = value;
  }
  public resetMaxSize() {
    this._maxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxSizeInput() {
    return this._maxSize;
  }

  // mode - computed: true, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // path - computed: true, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }
}
export interface PackSourceInputSplunkHecTls {
  /**
  * Path on server containing CA certificates to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#ca_path PackSource#ca_path}
  */
  readonly caPath?: string;
  /**
  * Path on server containing certificates to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#cert_path PackSource#cert_path}
  */
  readonly certPath?: string;
  /**
  * The name of the predefined certificate
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#certificate_name PackSource#certificate_name}
  */
  readonly certificateName?: string;
  /**
  * Parsed as JSON.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#common_name_regex PackSource#common_name_regex}
  */
  readonly commonNameRegex?: string;
  /**
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#disabled PackSource#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_version PackSource#max_version}
  */
  readonly maxVersion?: string;
  /**
  * must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#min_version PackSource#min_version}
  */
  readonly minVersion?: string;
  /**
  * Passphrase to use to decrypt private key
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#passphrase PackSource#passphrase}
  */
  readonly passphrase?: string;
  /**
  * Path on server containing the private key to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#priv_key_path PackSource#priv_key_path}
  */
  readonly privKeyPath?: string;
  /**
  * Parsed as JSON.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#reject_unauthorized PackSource#reject_unauthorized}
  */
  readonly rejectUnauthorized?: string;
  /**
  * Require clients to present their certificates. Used to perform client authentication using SSL certs. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#request_cert PackSource#request_cert}
  */
  readonly requestCert?: boolean | cdktf.IResolvable;
}

export function packSourceInputSplunkHecTlsToTerraform(struct?: PackSourceInputSplunkHecTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ca_path: cdktf.stringToTerraform(struct!.caPath),
    cert_path: cdktf.stringToTerraform(struct!.certPath),
    certificate_name: cdktf.stringToTerraform(struct!.certificateName),
    common_name_regex: cdktf.stringToTerraform(struct!.commonNameRegex),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    max_version: cdktf.stringToTerraform(struct!.maxVersion),
    min_version: cdktf.stringToTerraform(struct!.minVersion),
    passphrase: cdktf.stringToTerraform(struct!.passphrase),
    priv_key_path: cdktf.stringToTerraform(struct!.privKeyPath),
    reject_unauthorized: cdktf.stringToTerraform(struct!.rejectUnauthorized),
    request_cert: cdktf.booleanToTerraform(struct!.requestCert),
  }
}


export function packSourceInputSplunkHecTlsToHclTerraform(struct?: PackSourceInputSplunkHecTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ca_path: {
      value: cdktf.stringToHclTerraform(struct!.caPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    cert_path: {
      value: cdktf.stringToHclTerraform(struct!.certPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    certificate_name: {
      value: cdktf.stringToHclTerraform(struct!.certificateName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    common_name_regex: {
      value: cdktf.stringToHclTerraform(struct!.commonNameRegex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    max_version: {
      value: cdktf.stringToHclTerraform(struct!.maxVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    min_version: {
      value: cdktf.stringToHclTerraform(struct!.minVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    passphrase: {
      value: cdktf.stringToHclTerraform(struct!.passphrase),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    priv_key_path: {
      value: cdktf.stringToHclTerraform(struct!.privKeyPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reject_unauthorized: {
      value: cdktf.stringToHclTerraform(struct!.rejectUnauthorized),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    request_cert: {
      value: cdktf.booleanToHclTerraform(struct!.requestCert),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputSplunkHecTlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputSplunkHecTls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._caPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.caPath = this._caPath;
    }
    if (this._certPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.certPath = this._certPath;
    }
    if (this._certificateName !== undefined) {
      hasAnyValues = true;
      internalValueResult.certificateName = this._certificateName;
    }
    if (this._commonNameRegex !== undefined) {
      hasAnyValues = true;
      internalValueResult.commonNameRegex = this._commonNameRegex;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._maxVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxVersion = this._maxVersion;
    }
    if (this._minVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.minVersion = this._minVersion;
    }
    if (this._passphrase !== undefined) {
      hasAnyValues = true;
      internalValueResult.passphrase = this._passphrase;
    }
    if (this._privKeyPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.privKeyPath = this._privKeyPath;
    }
    if (this._rejectUnauthorized !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectUnauthorized = this._rejectUnauthorized;
    }
    if (this._requestCert !== undefined) {
      hasAnyValues = true;
      internalValueResult.requestCert = this._requestCert;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputSplunkHecTls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._caPath = undefined;
      this._certPath = undefined;
      this._certificateName = undefined;
      this._commonNameRegex = undefined;
      this._disabled = undefined;
      this._maxVersion = undefined;
      this._minVersion = undefined;
      this._passphrase = undefined;
      this._privKeyPath = undefined;
      this._rejectUnauthorized = undefined;
      this._requestCert = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._caPath = value.caPath;
      this._certPath = value.certPath;
      this._certificateName = value.certificateName;
      this._commonNameRegex = value.commonNameRegex;
      this._disabled = value.disabled;
      this._maxVersion = value.maxVersion;
      this._minVersion = value.minVersion;
      this._passphrase = value.passphrase;
      this._privKeyPath = value.privKeyPath;
      this._rejectUnauthorized = value.rejectUnauthorized;
      this._requestCert = value.requestCert;
    }
  }

  // ca_path - computed: false, optional: true, required: false
  private _caPath?: string; 
  public get caPath() {
    return this.getStringAttribute('ca_path');
  }
  public set caPath(value: string) {
    this._caPath = value;
  }
  public resetCaPath() {
    this._caPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get caPathInput() {
    return this._caPath;
  }

  // cert_path - computed: false, optional: true, required: false
  private _certPath?: string; 
  public get certPath() {
    return this.getStringAttribute('cert_path');
  }
  public set certPath(value: string) {
    this._certPath = value;
  }
  public resetCertPath() {
    this._certPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certPathInput() {
    return this._certPath;
  }

  // certificate_name - computed: false, optional: true, required: false
  private _certificateName?: string; 
  public get certificateName() {
    return this.getStringAttribute('certificate_name');
  }
  public set certificateName(value: string) {
    this._certificateName = value;
  }
  public resetCertificateName() {
    this._certificateName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certificateNameInput() {
    return this._certificateName;
  }

  // common_name_regex - computed: false, optional: true, required: false
  private _commonNameRegex?: string; 
  public get commonNameRegex() {
    return this.getStringAttribute('common_name_regex');
  }
  public set commonNameRegex(value: string) {
    this._commonNameRegex = value;
  }
  public resetCommonNameRegex() {
    this._commonNameRegex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commonNameRegexInput() {
    return this._commonNameRegex;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // max_version - computed: false, optional: true, required: false
  private _maxVersion?: string; 
  public get maxVersion() {
    return this.getStringAttribute('max_version');
  }
  public set maxVersion(value: string) {
    this._maxVersion = value;
  }
  public resetMaxVersion() {
    this._maxVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxVersionInput() {
    return this._maxVersion;
  }

  // min_version - computed: false, optional: true, required: false
  private _minVersion?: string; 
  public get minVersion() {
    return this.getStringAttribute('min_version');
  }
  public set minVersion(value: string) {
    this._minVersion = value;
  }
  public resetMinVersion() {
    this._minVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get minVersionInput() {
    return this._minVersion;
  }

  // passphrase - computed: false, optional: true, required: false
  private _passphrase?: string; 
  public get passphrase() {
    return this.getStringAttribute('passphrase');
  }
  public set passphrase(value: string) {
    this._passphrase = value;
  }
  public resetPassphrase() {
    this._passphrase = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passphraseInput() {
    return this._passphrase;
  }

  // priv_key_path - computed: false, optional: true, required: false
  private _privKeyPath?: string; 
  public get privKeyPath() {
    return this.getStringAttribute('priv_key_path');
  }
  public set privKeyPath(value: string) {
    this._privKeyPath = value;
  }
  public resetPrivKeyPath() {
    this._privKeyPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get privKeyPathInput() {
    return this._privKeyPath;
  }

  // reject_unauthorized - computed: false, optional: true, required: false
  private _rejectUnauthorized?: string; 
  public get rejectUnauthorized() {
    return this.getStringAttribute('reject_unauthorized');
  }
  public set rejectUnauthorized(value: string) {
    this._rejectUnauthorized = value;
  }
  public resetRejectUnauthorized() {
    this._rejectUnauthorized = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectUnauthorizedInput() {
    return this._rejectUnauthorized;
  }

  // request_cert - computed: true, optional: true, required: false
  private _requestCert?: boolean | cdktf.IResolvable; 
  public get requestCert() {
    return this.getBooleanAttribute('request_cert');
  }
  public set requestCert(value: boolean | cdktf.IResolvable) {
    this._requestCert = value;
  }
  public resetRequestCert() {
    this._requestCert = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestCertInput() {
    return this._requestCert;
  }
}
export interface PackSourceInputSplunkHec {
  /**
  * Optionally, list HTTP headers that @{product} will send to allowed origins as "Access-Control-Allow-Headers" in a CORS preflight response. Use "*" to allow all headers.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#access_control_allow_headers PackSource#access_control_allow_headers}
  */
  readonly accessControlAllowHeaders?: string[];
  /**
  * Optionally, list HTTP origins to which @{product} should send CORS (cross-origin resource sharing) Access-Control-Allow-* headers. Supports wildcards.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#access_control_allow_origin PackSource#access_control_allow_origin}
  */
  readonly accessControlAllowOrigin?: string[];
  /**
  * How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc. Default: 100
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#activity_log_sample_rate PackSource#activity_log_sample_rate}
  */
  readonly activityLogSampleRate?: number;
  /**
  * List values allowed in HEC event index field. Leave blank to skip validation. Supports wildcards. The values here can expand index validation at the token level.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#allowed_indexes PackSource#allowed_indexes}
  */
  readonly allowedIndexes?: string[];
  /**
  * Shared secrets to be provided by any client (Authorization: <token>). If empty, unauthorized access is permitted.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#auth_tokens PackSource#auth_tokens}
  */
  readonly authTokens?: PackSourceInputSplunkHecAuthTokens[] | cdktf.IResolvable;
  /**
  * A list of event-breaking rulesets that will be applied, in order, to the input data stream
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#breaker_rulesets PackSource#breaker_rulesets}
  */
  readonly breakerRulesets?: string[];
  /**
  * Add request headers to events, in the __headers field. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#capture_headers PackSource#capture_headers}
  */
  readonly captureHeaders?: boolean | cdktf.IResolvable;
  /**
  * Direct connections to Destinations, and optionally via a Pipeline or a Pack
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#connections PackSource#connections}
  */
  readonly connections?: PackSourceInputSplunkHecConnections[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#description PackSource#description}
  */
  readonly description?: string;
  /**
  * Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#disabled PackSource#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * Drop Splunk control fields such as `crcSalt` and `_savedPort`. If disabled, control fields are stored in the internal field `__ctrlFields`. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#drop_control_fields PackSource#drop_control_fields}
  */
  readonly dropControlFields?: boolean | cdktf.IResolvable;
  /**
  * Emit per-token (<prefix>.http.perToken) and summary (<prefix>.http.summary) request metrics. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#emit_token_metrics PackSource#emit_token_metrics}
  */
  readonly emitTokenMetrics?: boolean | cdktf.IResolvable;
  /**
  * Parsed as JSON.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#enable_health_check PackSource#enable_health_check}
  */
  readonly enableHealthCheck?: string;
  /**
  * Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#enable_proxy_header PackSource#enable_proxy_header}
  */
  readonly enableProxyHeader?: boolean | cdktf.IResolvable;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#environment PackSource#environment}
  */
  readonly environment?: string;
  /**
  * Extract and process Splunk-generated metrics as Cribl metrics. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#extract_metrics PackSource#extract_metrics}
  */
  readonly extractMetrics?: boolean | cdktf.IResolvable;
  /**
  * Address to bind on. Defaults to 0.0.0.0 (all addresses). Default: "0.0.0.0"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#host PackSource#host}
  */
  readonly host?: string;
  /**
  * Unique ID for this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#id PackSource#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * Messages from matched IP addresses will be processed, unless also matched by the denylist. Default: "/.* /"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#ip_allowlist_regex PackSource#ip_allowlist_regex}
   *
  * Note: The above comment contained a comment block ending sequence (* followed by /). We have introduced a space between to prevent syntax errors. Please ignore the space.
  */
  readonly ipAllowlistRegex?: string;
  /**
  * Messages from matched IP addresses will be ignored. This takes precedence over the allowlist. Default: "/^$/"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#ip_denylist_regex PackSource#ip_denylist_regex}
  */
  readonly ipDenylistRegex?: string;
  /**
  * After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes). Default: 5
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#keep_alive_timeout PackSource#keep_alive_timeout}
  */
  readonly keepAliveTimeout?: number;
  /**
  * Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput. Default: 256
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_active_req PackSource#max_active_req}
  */
  readonly maxActiveReq?: number;
  /**
  * Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited). Default: 0
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_requests_per_socket PackSource#max_requests_per_socket}
  */
  readonly maxRequestsPerSocket?: number;
  /**
  * Fields to add to every event. Overrides fields added at the token or request level. See [the Source documentation](https://docs.cribl.io/stream/sources-splunk-hec/#fields) for more info.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#metadata PackSource#metadata}
  */
  readonly metadata?: PackSourceInputSplunkHecMetadata[] | cdktf.IResolvable;
  /**
  * Pipeline to process data from this Source before sending it through the Routes
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pipeline PackSource#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Port to listen on
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#port PackSource#port}
  */
  readonly port: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pq PackSource#pq}
  */
  readonly pq?: PackSourceInputSplunkHecPq;
  /**
  * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers). Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pq_enabled PackSource#pq_enabled}
  */
  readonly pqEnabled?: boolean | cdktf.IResolvable;
  /**
  * How long to wait for an incoming request to complete before aborting it. Use 0 to disable. Default: 0
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#request_timeout PackSource#request_timeout}
  */
  readonly requestTimeout?: number;
  /**
  * Select whether to send data to Routes, or directly to Destinations. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#send_to_routes PackSource#send_to_routes}
  */
  readonly sendToRoutes?: boolean | cdktf.IResolvable;
  /**
  * How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0. Default: 0
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#socket_timeout PackSource#socket_timeout}
  */
  readonly socketTimeout?: number;
  /**
  * Enable Splunk HEC acknowledgements. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#splunk_hec_acks PackSource#splunk_hec_acks}
  */
  readonly splunkHecAcks?: boolean | cdktf.IResolvable;
  /**
  * Absolute path on which to listen for the Splunk HTTP Event Collector API requests. This input supports the /event, /raw and /s2s endpoints. Default: "/services/collector"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#splunk_hec_api PackSource#splunk_hec_api}
  */
  readonly splunkHecApi?: string;
  /**
  * How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines. Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#stale_channel_flush_ms PackSource#stale_channel_flush_ms}
  */
  readonly staleChannelFlushMs?: number;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#streamtags PackSource#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#tls PackSource#tls}
  */
  readonly tls?: PackSourceInputSplunkHecTls;
  /**
  * must be "splunk_hec"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#type PackSource#type}
  */
  readonly type?: string;
  /**
  * Event Breakers will determine events' time zone from UF-provided metadata, when TZ can't be inferred from the raw event. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#use_fwd_timezone PackSource#use_fwd_timezone}
  */
  readonly useFwdTimezone?: boolean | cdktf.IResolvable;
}

export function packSourceInputSplunkHecToTerraform(struct?: PackSourceInputSplunkHec | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    access_control_allow_headers: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.accessControlAllowHeaders),
    access_control_allow_origin: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.accessControlAllowOrigin),
    activity_log_sample_rate: cdktf.numberToTerraform(struct!.activityLogSampleRate),
    allowed_indexes: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.allowedIndexes),
    auth_tokens: cdktf.listMapper(packSourceInputSplunkHecAuthTokensToTerraform, false)(struct!.authTokens),
    breaker_rulesets: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.breakerRulesets),
    capture_headers: cdktf.booleanToTerraform(struct!.captureHeaders),
    connections: cdktf.listMapper(packSourceInputSplunkHecConnectionsToTerraform, false)(struct!.connections),
    description: cdktf.stringToTerraform(struct!.description),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    drop_control_fields: cdktf.booleanToTerraform(struct!.dropControlFields),
    emit_token_metrics: cdktf.booleanToTerraform(struct!.emitTokenMetrics),
    enable_health_check: cdktf.stringToTerraform(struct!.enableHealthCheck),
    enable_proxy_header: cdktf.booleanToTerraform(struct!.enableProxyHeader),
    environment: cdktf.stringToTerraform(struct!.environment),
    extract_metrics: cdktf.booleanToTerraform(struct!.extractMetrics),
    host: cdktf.stringToTerraform(struct!.host),
    id: cdktf.stringToTerraform(struct!.id),
    ip_allowlist_regex: cdktf.stringToTerraform(struct!.ipAllowlistRegex),
    ip_denylist_regex: cdktf.stringToTerraform(struct!.ipDenylistRegex),
    keep_alive_timeout: cdktf.numberToTerraform(struct!.keepAliveTimeout),
    max_active_req: cdktf.numberToTerraform(struct!.maxActiveReq),
    max_requests_per_socket: cdktf.numberToTerraform(struct!.maxRequestsPerSocket),
    metadata: cdktf.listMapper(packSourceInputSplunkHecMetadataToTerraform, false)(struct!.metadata),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    port: cdktf.numberToTerraform(struct!.port),
    pq: packSourceInputSplunkHecPqToTerraform(struct!.pq),
    pq_enabled: cdktf.booleanToTerraform(struct!.pqEnabled),
    request_timeout: cdktf.numberToTerraform(struct!.requestTimeout),
    send_to_routes: cdktf.booleanToTerraform(struct!.sendToRoutes),
    socket_timeout: cdktf.numberToTerraform(struct!.socketTimeout),
    splunk_hec_acks: cdktf.booleanToTerraform(struct!.splunkHecAcks),
    splunk_hec_api: cdktf.stringToTerraform(struct!.splunkHecApi),
    stale_channel_flush_ms: cdktf.numberToTerraform(struct!.staleChannelFlushMs),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    tls: packSourceInputSplunkHecTlsToTerraform(struct!.tls),
    type: cdktf.stringToTerraform(struct!.type),
    use_fwd_timezone: cdktf.booleanToTerraform(struct!.useFwdTimezone),
  }
}


export function packSourceInputSplunkHecToHclTerraform(struct?: PackSourceInputSplunkHec | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    access_control_allow_headers: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.accessControlAllowHeaders),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    access_control_allow_origin: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.accessControlAllowOrigin),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    activity_log_sample_rate: {
      value: cdktf.numberToHclTerraform(struct!.activityLogSampleRate),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    allowed_indexes: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.allowedIndexes),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    auth_tokens: {
      value: cdktf.listMapperHcl(packSourceInputSplunkHecAuthTokensToHclTerraform, false)(struct!.authTokens),
      isBlock: true,
      type: "list",
      storageClassType: "PackSourceInputSplunkHecAuthTokensList",
    },
    breaker_rulesets: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.breakerRulesets),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    capture_headers: {
      value: cdktf.booleanToHclTerraform(struct!.captureHeaders),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    connections: {
      value: cdktf.listMapperHcl(packSourceInputSplunkHecConnectionsToHclTerraform, false)(struct!.connections),
      isBlock: true,
      type: "list",
      storageClassType: "PackSourceInputSplunkHecConnectionsList",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    drop_control_fields: {
      value: cdktf.booleanToHclTerraform(struct!.dropControlFields),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    emit_token_metrics: {
      value: cdktf.booleanToHclTerraform(struct!.emitTokenMetrics),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    enable_health_check: {
      value: cdktf.stringToHclTerraform(struct!.enableHealthCheck),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    enable_proxy_header: {
      value: cdktf.booleanToHclTerraform(struct!.enableProxyHeader),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    extract_metrics: {
      value: cdktf.booleanToHclTerraform(struct!.extractMetrics),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    host: {
      value: cdktf.stringToHclTerraform(struct!.host),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ip_allowlist_regex: {
      value: cdktf.stringToHclTerraform(struct!.ipAllowlistRegex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ip_denylist_regex: {
      value: cdktf.stringToHclTerraform(struct!.ipDenylistRegex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    keep_alive_timeout: {
      value: cdktf.numberToHclTerraform(struct!.keepAliveTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_active_req: {
      value: cdktf.numberToHclTerraform(struct!.maxActiveReq),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_requests_per_socket: {
      value: cdktf.numberToHclTerraform(struct!.maxRequestsPerSocket),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    metadata: {
      value: cdktf.listMapperHcl(packSourceInputSplunkHecMetadataToHclTerraform, false)(struct!.metadata),
      isBlock: true,
      type: "list",
      storageClassType: "PackSourceInputSplunkHecMetadataList",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    pq: {
      value: packSourceInputSplunkHecPqToHclTerraform(struct!.pq),
      isBlock: true,
      type: "struct",
      storageClassType: "PackSourceInputSplunkHecPq",
    },
    pq_enabled: {
      value: cdktf.booleanToHclTerraform(struct!.pqEnabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    request_timeout: {
      value: cdktf.numberToHclTerraform(struct!.requestTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    send_to_routes: {
      value: cdktf.booleanToHclTerraform(struct!.sendToRoutes),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    socket_timeout: {
      value: cdktf.numberToHclTerraform(struct!.socketTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    splunk_hec_acks: {
      value: cdktf.booleanToHclTerraform(struct!.splunkHecAcks),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    splunk_hec_api: {
      value: cdktf.stringToHclTerraform(struct!.splunkHecApi),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    stale_channel_flush_ms: {
      value: cdktf.numberToHclTerraform(struct!.staleChannelFlushMs),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    tls: {
      value: packSourceInputSplunkHecTlsToHclTerraform(struct!.tls),
      isBlock: true,
      type: "struct",
      storageClassType: "PackSourceInputSplunkHecTls",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    use_fwd_timezone: {
      value: cdktf.booleanToHclTerraform(struct!.useFwdTimezone),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputSplunkHecOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputSplunkHec | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._accessControlAllowHeaders !== undefined) {
      hasAnyValues = true;
      internalValueResult.accessControlAllowHeaders = this._accessControlAllowHeaders;
    }
    if (this._accessControlAllowOrigin !== undefined) {
      hasAnyValues = true;
      internalValueResult.accessControlAllowOrigin = this._accessControlAllowOrigin;
    }
    if (this._activityLogSampleRate !== undefined) {
      hasAnyValues = true;
      internalValueResult.activityLogSampleRate = this._activityLogSampleRate;
    }
    if (this._allowedIndexes !== undefined) {
      hasAnyValues = true;
      internalValueResult.allowedIndexes = this._allowedIndexes;
    }
    if (this._authTokens?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.authTokens = this._authTokens?.internalValue;
    }
    if (this._breakerRulesets !== undefined) {
      hasAnyValues = true;
      internalValueResult.breakerRulesets = this._breakerRulesets;
    }
    if (this._captureHeaders !== undefined) {
      hasAnyValues = true;
      internalValueResult.captureHeaders = this._captureHeaders;
    }
    if (this._connections?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.connections = this._connections?.internalValue;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._dropControlFields !== undefined) {
      hasAnyValues = true;
      internalValueResult.dropControlFields = this._dropControlFields;
    }
    if (this._emitTokenMetrics !== undefined) {
      hasAnyValues = true;
      internalValueResult.emitTokenMetrics = this._emitTokenMetrics;
    }
    if (this._enableHealthCheck !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableHealthCheck = this._enableHealthCheck;
    }
    if (this._enableProxyHeader !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableProxyHeader = this._enableProxyHeader;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._extractMetrics !== undefined) {
      hasAnyValues = true;
      internalValueResult.extractMetrics = this._extractMetrics;
    }
    if (this._host !== undefined) {
      hasAnyValues = true;
      internalValueResult.host = this._host;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._ipAllowlistRegex !== undefined) {
      hasAnyValues = true;
      internalValueResult.ipAllowlistRegex = this._ipAllowlistRegex;
    }
    if (this._ipDenylistRegex !== undefined) {
      hasAnyValues = true;
      internalValueResult.ipDenylistRegex = this._ipDenylistRegex;
    }
    if (this._keepAliveTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.keepAliveTimeout = this._keepAliveTimeout;
    }
    if (this._maxActiveReq !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxActiveReq = this._maxActiveReq;
    }
    if (this._maxRequestsPerSocket !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxRequestsPerSocket = this._maxRequestsPerSocket;
    }
    if (this._metadata?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadata = this._metadata?.internalValue;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._pq?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pq = this._pq?.internalValue;
    }
    if (this._pqEnabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqEnabled = this._pqEnabled;
    }
    if (this._requestTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.requestTimeout = this._requestTimeout;
    }
    if (this._sendToRoutes !== undefined) {
      hasAnyValues = true;
      internalValueResult.sendToRoutes = this._sendToRoutes;
    }
    if (this._socketTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.socketTimeout = this._socketTimeout;
    }
    if (this._splunkHecAcks !== undefined) {
      hasAnyValues = true;
      internalValueResult.splunkHecAcks = this._splunkHecAcks;
    }
    if (this._splunkHecApi !== undefined) {
      hasAnyValues = true;
      internalValueResult.splunkHecApi = this._splunkHecApi;
    }
    if (this._staleChannelFlushMs !== undefined) {
      hasAnyValues = true;
      internalValueResult.staleChannelFlushMs = this._staleChannelFlushMs;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._tls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tls = this._tls?.internalValue;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._useFwdTimezone !== undefined) {
      hasAnyValues = true;
      internalValueResult.useFwdTimezone = this._useFwdTimezone;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputSplunkHec | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._accessControlAllowHeaders = undefined;
      this._accessControlAllowOrigin = undefined;
      this._activityLogSampleRate = undefined;
      this._allowedIndexes = undefined;
      this._authTokens.internalValue = undefined;
      this._breakerRulesets = undefined;
      this._captureHeaders = undefined;
      this._connections.internalValue = undefined;
      this._description = undefined;
      this._disabled = undefined;
      this._dropControlFields = undefined;
      this._emitTokenMetrics = undefined;
      this._enableHealthCheck = undefined;
      this._enableProxyHeader = undefined;
      this._environment = undefined;
      this._extractMetrics = undefined;
      this._host = undefined;
      this._id = undefined;
      this._ipAllowlistRegex = undefined;
      this._ipDenylistRegex = undefined;
      this._keepAliveTimeout = undefined;
      this._maxActiveReq = undefined;
      this._maxRequestsPerSocket = undefined;
      this._metadata.internalValue = undefined;
      this._pipeline = undefined;
      this._port = undefined;
      this._pq.internalValue = undefined;
      this._pqEnabled = undefined;
      this._requestTimeout = undefined;
      this._sendToRoutes = undefined;
      this._socketTimeout = undefined;
      this._splunkHecAcks = undefined;
      this._splunkHecApi = undefined;
      this._staleChannelFlushMs = undefined;
      this._streamtags = undefined;
      this._tls.internalValue = undefined;
      this._type = undefined;
      this._useFwdTimezone = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._accessControlAllowHeaders = value.accessControlAllowHeaders;
      this._accessControlAllowOrigin = value.accessControlAllowOrigin;
      this._activityLogSampleRate = value.activityLogSampleRate;
      this._allowedIndexes = value.allowedIndexes;
      this._authTokens.internalValue = value.authTokens;
      this._breakerRulesets = value.breakerRulesets;
      this._captureHeaders = value.captureHeaders;
      this._connections.internalValue = value.connections;
      this._description = value.description;
      this._disabled = value.disabled;
      this._dropControlFields = value.dropControlFields;
      this._emitTokenMetrics = value.emitTokenMetrics;
      this._enableHealthCheck = value.enableHealthCheck;
      this._enableProxyHeader = value.enableProxyHeader;
      this._environment = value.environment;
      this._extractMetrics = value.extractMetrics;
      this._host = value.host;
      this._id = value.id;
      this._ipAllowlistRegex = value.ipAllowlistRegex;
      this._ipDenylistRegex = value.ipDenylistRegex;
      this._keepAliveTimeout = value.keepAliveTimeout;
      this._maxActiveReq = value.maxActiveReq;
      this._maxRequestsPerSocket = value.maxRequestsPerSocket;
      this._metadata.internalValue = value.metadata;
      this._pipeline = value.pipeline;
      this._port = value.port;
      this._pq.internalValue = value.pq;
      this._pqEnabled = value.pqEnabled;
      this._requestTimeout = value.requestTimeout;
      this._sendToRoutes = value.sendToRoutes;
      this._socketTimeout = value.socketTimeout;
      this._splunkHecAcks = value.splunkHecAcks;
      this._splunkHecApi = value.splunkHecApi;
      this._staleChannelFlushMs = value.staleChannelFlushMs;
      this._streamtags = value.streamtags;
      this._tls.internalValue = value.tls;
      this._type = value.type;
      this._useFwdTimezone = value.useFwdTimezone;
    }
  }

  // access_control_allow_headers - computed: false, optional: true, required: false
  private _accessControlAllowHeaders?: string[]; 
  public get accessControlAllowHeaders() {
    return this.getListAttribute('access_control_allow_headers');
  }
  public set accessControlAllowHeaders(value: string[]) {
    this._accessControlAllowHeaders = value;
  }
  public resetAccessControlAllowHeaders() {
    this._accessControlAllowHeaders = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get accessControlAllowHeadersInput() {
    return this._accessControlAllowHeaders;
  }

  // access_control_allow_origin - computed: false, optional: true, required: false
  private _accessControlAllowOrigin?: string[]; 
  public get accessControlAllowOrigin() {
    return this.getListAttribute('access_control_allow_origin');
  }
  public set accessControlAllowOrigin(value: string[]) {
    this._accessControlAllowOrigin = value;
  }
  public resetAccessControlAllowOrigin() {
    this._accessControlAllowOrigin = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get accessControlAllowOriginInput() {
    return this._accessControlAllowOrigin;
  }

  // activity_log_sample_rate - computed: true, optional: true, required: false
  private _activityLogSampleRate?: number; 
  public get activityLogSampleRate() {
    return this.getNumberAttribute('activity_log_sample_rate');
  }
  public set activityLogSampleRate(value: number) {
    this._activityLogSampleRate = value;
  }
  public resetActivityLogSampleRate() {
    this._activityLogSampleRate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get activityLogSampleRateInput() {
    return this._activityLogSampleRate;
  }

  // allowed_indexes - computed: false, optional: true, required: false
  private _allowedIndexes?: string[]; 
  public get allowedIndexes() {
    return this.getListAttribute('allowed_indexes');
  }
  public set allowedIndexes(value: string[]) {
    this._allowedIndexes = value;
  }
  public resetAllowedIndexes() {
    this._allowedIndexes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get allowedIndexesInput() {
    return this._allowedIndexes;
  }

  // auth_tokens - computed: false, optional: true, required: false
  private _authTokens = new PackSourceInputSplunkHecAuthTokensList(this, "auth_tokens", false);
  public get authTokens() {
    return this._authTokens;
  }
  public putAuthTokens(value: PackSourceInputSplunkHecAuthTokens[] | cdktf.IResolvable) {
    this._authTokens.internalValue = value;
  }
  public resetAuthTokens() {
    this._authTokens.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authTokensInput() {
    return this._authTokens.internalValue;
  }

  // breaker_rulesets - computed: false, optional: true, required: false
  private _breakerRulesets?: string[]; 
  public get breakerRulesets() {
    return this.getListAttribute('breaker_rulesets');
  }
  public set breakerRulesets(value: string[]) {
    this._breakerRulesets = value;
  }
  public resetBreakerRulesets() {
    this._breakerRulesets = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get breakerRulesetsInput() {
    return this._breakerRulesets;
  }

  // capture_headers - computed: true, optional: true, required: false
  private _captureHeaders?: boolean | cdktf.IResolvable; 
  public get captureHeaders() {
    return this.getBooleanAttribute('capture_headers');
  }
  public set captureHeaders(value: boolean | cdktf.IResolvable) {
    this._captureHeaders = value;
  }
  public resetCaptureHeaders() {
    this._captureHeaders = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get captureHeadersInput() {
    return this._captureHeaders;
  }

  // connections - computed: false, optional: true, required: false
  private _connections = new PackSourceInputSplunkHecConnectionsList(this, "connections", false);
  public get connections() {
    return this._connections;
  }
  public putConnections(value: PackSourceInputSplunkHecConnections[] | cdktf.IResolvable) {
    this._connections.internalValue = value;
  }
  public resetConnections() {
    this._connections.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectionsInput() {
    return this._connections.internalValue;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // drop_control_fields - computed: true, optional: true, required: false
  private _dropControlFields?: boolean | cdktf.IResolvable; 
  public get dropControlFields() {
    return this.getBooleanAttribute('drop_control_fields');
  }
  public set dropControlFields(value: boolean | cdktf.IResolvable) {
    this._dropControlFields = value;
  }
  public resetDropControlFields() {
    this._dropControlFields = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dropControlFieldsInput() {
    return this._dropControlFields;
  }

  // emit_token_metrics - computed: true, optional: true, required: false
  private _emitTokenMetrics?: boolean | cdktf.IResolvable; 
  public get emitTokenMetrics() {
    return this.getBooleanAttribute('emit_token_metrics');
  }
  public set emitTokenMetrics(value: boolean | cdktf.IResolvable) {
    this._emitTokenMetrics = value;
  }
  public resetEmitTokenMetrics() {
    this._emitTokenMetrics = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get emitTokenMetricsInput() {
    return this._emitTokenMetrics;
  }

  // enable_health_check - computed: false, optional: true, required: false
  private _enableHealthCheck?: string; 
  public get enableHealthCheck() {
    return this.getStringAttribute('enable_health_check');
  }
  public set enableHealthCheck(value: string) {
    this._enableHealthCheck = value;
  }
  public resetEnableHealthCheck() {
    this._enableHealthCheck = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableHealthCheckInput() {
    return this._enableHealthCheck;
  }

  // enable_proxy_header - computed: true, optional: true, required: false
  private _enableProxyHeader?: boolean | cdktf.IResolvable; 
  public get enableProxyHeader() {
    return this.getBooleanAttribute('enable_proxy_header');
  }
  public set enableProxyHeader(value: boolean | cdktf.IResolvable) {
    this._enableProxyHeader = value;
  }
  public resetEnableProxyHeader() {
    this._enableProxyHeader = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableProxyHeaderInput() {
    return this._enableProxyHeader;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // extract_metrics - computed: true, optional: true, required: false
  private _extractMetrics?: boolean | cdktf.IResolvable; 
  public get extractMetrics() {
    return this.getBooleanAttribute('extract_metrics');
  }
  public set extractMetrics(value: boolean | cdktf.IResolvable) {
    this._extractMetrics = value;
  }
  public resetExtractMetrics() {
    this._extractMetrics = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get extractMetricsInput() {
    return this._extractMetrics;
  }

  // host - computed: true, optional: true, required: false
  private _host?: string; 
  public get host() {
    return this.getStringAttribute('host');
  }
  public set host(value: string) {
    this._host = value;
  }
  public resetHost() {
    this._host = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostInput() {
    return this._host;
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // ip_allowlist_regex - computed: true, optional: true, required: false
  private _ipAllowlistRegex?: string; 
  public get ipAllowlistRegex() {
    return this.getStringAttribute('ip_allowlist_regex');
  }
  public set ipAllowlistRegex(value: string) {
    this._ipAllowlistRegex = value;
  }
  public resetIpAllowlistRegex() {
    this._ipAllowlistRegex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ipAllowlistRegexInput() {
    return this._ipAllowlistRegex;
  }

  // ip_denylist_regex - computed: true, optional: true, required: false
  private _ipDenylistRegex?: string; 
  public get ipDenylistRegex() {
    return this.getStringAttribute('ip_denylist_regex');
  }
  public set ipDenylistRegex(value: string) {
    this._ipDenylistRegex = value;
  }
  public resetIpDenylistRegex() {
    this._ipDenylistRegex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ipDenylistRegexInput() {
    return this._ipDenylistRegex;
  }

  // keep_alive_timeout - computed: true, optional: true, required: false
  private _keepAliveTimeout?: number; 
  public get keepAliveTimeout() {
    return this.getNumberAttribute('keep_alive_timeout');
  }
  public set keepAliveTimeout(value: number) {
    this._keepAliveTimeout = value;
  }
  public resetKeepAliveTimeout() {
    this._keepAliveTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keepAliveTimeoutInput() {
    return this._keepAliveTimeout;
  }

  // max_active_req - computed: true, optional: true, required: false
  private _maxActiveReq?: number; 
  public get maxActiveReq() {
    return this.getNumberAttribute('max_active_req');
  }
  public set maxActiveReq(value: number) {
    this._maxActiveReq = value;
  }
  public resetMaxActiveReq() {
    this._maxActiveReq = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxActiveReqInput() {
    return this._maxActiveReq;
  }

  // max_requests_per_socket - computed: true, optional: true, required: false
  private _maxRequestsPerSocket?: number; 
  public get maxRequestsPerSocket() {
    return this.getNumberAttribute('max_requests_per_socket');
  }
  public set maxRequestsPerSocket(value: number) {
    this._maxRequestsPerSocket = value;
  }
  public resetMaxRequestsPerSocket() {
    this._maxRequestsPerSocket = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxRequestsPerSocketInput() {
    return this._maxRequestsPerSocket;
  }

  // metadata - computed: false, optional: true, required: false
  private _metadata = new PackSourceInputSplunkHecMetadataList(this, "metadata", false);
  public get metadata() {
    return this._metadata;
  }
  public putMetadata(value: PackSourceInputSplunkHecMetadata[] | cdktf.IResolvable) {
    this._metadata.internalValue = value;
  }
  public resetMetadata() {
    this._metadata.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataInput() {
    return this._metadata.internalValue;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // port - computed: false, optional: false, required: true
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // pq - computed: false, optional: true, required: false
  private _pq = new PackSourceInputSplunkHecPqOutputReference(this, "pq");
  public get pq() {
    return this._pq;
  }
  public putPq(value: PackSourceInputSplunkHecPq) {
    this._pq.internalValue = value;
  }
  public resetPq() {
    this._pq.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqInput() {
    return this._pq.internalValue;
  }

  // pq_enabled - computed: true, optional: true, required: false
  private _pqEnabled?: boolean | cdktf.IResolvable; 
  public get pqEnabled() {
    return this.getBooleanAttribute('pq_enabled');
  }
  public set pqEnabled(value: boolean | cdktf.IResolvable) {
    this._pqEnabled = value;
  }
  public resetPqEnabled() {
    this._pqEnabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqEnabledInput() {
    return this._pqEnabled;
  }

  // request_timeout - computed: true, optional: true, required: false
  private _requestTimeout?: number; 
  public get requestTimeout() {
    return this.getNumberAttribute('request_timeout');
  }
  public set requestTimeout(value: number) {
    this._requestTimeout = value;
  }
  public resetRequestTimeout() {
    this._requestTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestTimeoutInput() {
    return this._requestTimeout;
  }

  // send_to_routes - computed: true, optional: true, required: false
  private _sendToRoutes?: boolean | cdktf.IResolvable; 
  public get sendToRoutes() {
    return this.getBooleanAttribute('send_to_routes');
  }
  public set sendToRoutes(value: boolean | cdktf.IResolvable) {
    this._sendToRoutes = value;
  }
  public resetSendToRoutes() {
    this._sendToRoutes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sendToRoutesInput() {
    return this._sendToRoutes;
  }

  // socket_timeout - computed: true, optional: true, required: false
  private _socketTimeout?: number; 
  public get socketTimeout() {
    return this.getNumberAttribute('socket_timeout');
  }
  public set socketTimeout(value: number) {
    this._socketTimeout = value;
  }
  public resetSocketTimeout() {
    this._socketTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get socketTimeoutInput() {
    return this._socketTimeout;
  }

  // splunk_hec_acks - computed: true, optional: true, required: false
  private _splunkHecAcks?: boolean | cdktf.IResolvable; 
  public get splunkHecAcks() {
    return this.getBooleanAttribute('splunk_hec_acks');
  }
  public set splunkHecAcks(value: boolean | cdktf.IResolvable) {
    this._splunkHecAcks = value;
  }
  public resetSplunkHecAcks() {
    this._splunkHecAcks = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get splunkHecAcksInput() {
    return this._splunkHecAcks;
  }

  // splunk_hec_api - computed: true, optional: true, required: false
  private _splunkHecApi?: string; 
  public get splunkHecApi() {
    return this.getStringAttribute('splunk_hec_api');
  }
  public set splunkHecApi(value: string) {
    this._splunkHecApi = value;
  }
  public resetSplunkHecApi() {
    this._splunkHecApi = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get splunkHecApiInput() {
    return this._splunkHecApi;
  }

  // stale_channel_flush_ms - computed: true, optional: true, required: false
  private _staleChannelFlushMs?: number; 
  public get staleChannelFlushMs() {
    return this.getNumberAttribute('stale_channel_flush_ms');
  }
  public set staleChannelFlushMs(value: number) {
    this._staleChannelFlushMs = value;
  }
  public resetStaleChannelFlushMs() {
    this._staleChannelFlushMs = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get staleChannelFlushMsInput() {
    return this._staleChannelFlushMs;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // tls - computed: false, optional: true, required: false
  private _tls = new PackSourceInputSplunkHecTlsOutputReference(this, "tls");
  public get tls() {
    return this._tls;
  }
  public putTls(value: PackSourceInputSplunkHecTls) {
    this._tls.internalValue = value;
  }
  public resetTls() {
    this._tls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsInput() {
    return this._tls.internalValue;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // use_fwd_timezone - computed: true, optional: true, required: false
  private _useFwdTimezone?: boolean | cdktf.IResolvable; 
  public get useFwdTimezone() {
    return this.getBooleanAttribute('use_fwd_timezone');
  }
  public set useFwdTimezone(value: boolean | cdktf.IResolvable) {
    this._useFwdTimezone = value;
  }
  public resetUseFwdTimezone() {
    this._useFwdTimezone = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get useFwdTimezoneInput() {
    return this._useFwdTimezone;
  }
}
export interface PackSourceInputSplunkSearchConnections {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#output PackSource#output}
  */
  readonly output: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pipeline PackSource#pipeline}
  */
  readonly pipeline?: string;
}

export function packSourceInputSplunkSearchConnectionsToTerraform(struct?: PackSourceInputSplunkSearchConnections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    output: cdktf.stringToTerraform(struct!.output),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
  }
}


export function packSourceInputSplunkSearchConnectionsToHclTerraform(struct?: PackSourceInputSplunkSearchConnections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    output: {
      value: cdktf.stringToHclTerraform(struct!.output),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputSplunkSearchConnectionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackSourceInputSplunkSearchConnections | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._output !== undefined) {
      hasAnyValues = true;
      internalValueResult.output = this._output;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputSplunkSearchConnections | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._output = undefined;
      this._pipeline = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._output = value.output;
      this._pipeline = value.pipeline;
    }
  }

  // output - computed: false, optional: false, required: true
  private _output?: string; 
  public get output() {
    return this.getStringAttribute('output');
  }
  public set output(value: string) {
    this._output = value;
  }
  // Temporarily expose input value. Use with caution.
  public get outputInput() {
    return this._output;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }
}

export class PackSourceInputSplunkSearchConnectionsList extends cdktf.ComplexList {
  public internalValue? : PackSourceInputSplunkSearchConnections[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackSourceInputSplunkSearchConnectionsOutputReference {
    return new PackSourceInputSplunkSearchConnectionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackSourceInputSplunkSearchEndpointHeaders {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#name PackSource#name}
  */
  readonly name: string;
  /**
  * JavaScript expression to compute the header's value, normally enclosed in backticks (e.g., `${earliest}`). If a constant, use single quotes (e.g., 'earliest'). Values without delimiters (e.g., earliest) are evaluated as strings.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#value PackSource#value}
  */
  readonly value: string;
}

export function packSourceInputSplunkSearchEndpointHeadersToTerraform(struct?: PackSourceInputSplunkSearchEndpointHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function packSourceInputSplunkSearchEndpointHeadersToHclTerraform(struct?: PackSourceInputSplunkSearchEndpointHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputSplunkSearchEndpointHeadersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackSourceInputSplunkSearchEndpointHeaders | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputSplunkSearchEndpointHeaders | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class PackSourceInputSplunkSearchEndpointHeadersList extends cdktf.ComplexList {
  public internalValue? : PackSourceInputSplunkSearchEndpointHeaders[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackSourceInputSplunkSearchEndpointHeadersOutputReference {
    return new PackSourceInputSplunkSearchEndpointHeadersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackSourceInputSplunkSearchEndpointParams {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#name PackSource#name}
  */
  readonly name: string;
  /**
  * JavaScript expression to compute the parameter's value, normally enclosed in backticks (e.g., `${earliest}`). If a constant, use single quotes (e.g., 'earliest'). Values without delimiters (e.g., earliest) are evaluated as strings.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#value PackSource#value}
  */
  readonly value: string;
}

export function packSourceInputSplunkSearchEndpointParamsToTerraform(struct?: PackSourceInputSplunkSearchEndpointParams | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function packSourceInputSplunkSearchEndpointParamsToHclTerraform(struct?: PackSourceInputSplunkSearchEndpointParams | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputSplunkSearchEndpointParamsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackSourceInputSplunkSearchEndpointParams | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputSplunkSearchEndpointParams | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class PackSourceInputSplunkSearchEndpointParamsList extends cdktf.ComplexList {
  public internalValue? : PackSourceInputSplunkSearchEndpointParams[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackSourceInputSplunkSearchEndpointParamsOutputReference {
    return new PackSourceInputSplunkSearchEndpointParamsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackSourceInputSplunkSearchMetadata {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#name PackSource#name}
  */
  readonly name: string;
  /**
  * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#value PackSource#value}
  */
  readonly value: string;
}

export function packSourceInputSplunkSearchMetadataToTerraform(struct?: PackSourceInputSplunkSearchMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function packSourceInputSplunkSearchMetadataToHclTerraform(struct?: PackSourceInputSplunkSearchMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputSplunkSearchMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackSourceInputSplunkSearchMetadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputSplunkSearchMetadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class PackSourceInputSplunkSearchMetadataList extends cdktf.ComplexList {
  public internalValue? : PackSourceInputSplunkSearchMetadata[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackSourceInputSplunkSearchMetadataOutputReference {
    return new PackSourceInputSplunkSearchMetadataOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackSourceInputSplunkSearchOauthHeaders {
  /**
  * OAuth header name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#name PackSource#name}
  */
  readonly name: string;
  /**
  * OAuth header value
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#value PackSource#value}
  */
  readonly value: string;
}

export function packSourceInputSplunkSearchOauthHeadersToTerraform(struct?: PackSourceInputSplunkSearchOauthHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function packSourceInputSplunkSearchOauthHeadersToHclTerraform(struct?: PackSourceInputSplunkSearchOauthHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputSplunkSearchOauthHeadersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackSourceInputSplunkSearchOauthHeaders | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputSplunkSearchOauthHeaders | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class PackSourceInputSplunkSearchOauthHeadersList extends cdktf.ComplexList {
  public internalValue? : PackSourceInputSplunkSearchOauthHeaders[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackSourceInputSplunkSearchOauthHeadersOutputReference {
    return new PackSourceInputSplunkSearchOauthHeadersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackSourceInputSplunkSearchOauthParams {
  /**
  * OAuth parameter name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#name PackSource#name}
  */
  readonly name: string;
  /**
  * OAuth parameter value
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#value PackSource#value}
  */
  readonly value: string;
}

export function packSourceInputSplunkSearchOauthParamsToTerraform(struct?: PackSourceInputSplunkSearchOauthParams | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function packSourceInputSplunkSearchOauthParamsToHclTerraform(struct?: PackSourceInputSplunkSearchOauthParams | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputSplunkSearchOauthParamsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackSourceInputSplunkSearchOauthParams | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputSplunkSearchOauthParams | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class PackSourceInputSplunkSearchOauthParamsList extends cdktf.ComplexList {
  public internalValue? : PackSourceInputSplunkSearchOauthParams[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackSourceInputSplunkSearchOauthParamsOutputReference {
    return new PackSourceInputSplunkSearchOauthParamsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackSourceInputSplunkSearchPq {
  /**
  * The number of events to send downstream before committing that Stream has read them. Default: 42
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#commit_frequency PackSource#commit_frequency}
  */
  readonly commitFrequency?: number;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#compress PackSource#compress}
  */
  readonly compress?: string;
  /**
  * The maximum number of events to hold in memory before writing the events to disk. Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_buffer_size PackSource#max_buffer_size}
  */
  readonly maxBufferSize?: number;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc. Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_file_size PackSource#max_file_size}
  */
  readonly maxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_size PackSource#max_size}
  */
  readonly maxSize?: string;
  /**
  * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine. Default: "always"; must be one of ["smart", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#mode PackSource#mode}
  */
  readonly mode?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#path PackSource#path}
  */
  readonly path?: string;
}

export function packSourceInputSplunkSearchPqToTerraform(struct?: PackSourceInputSplunkSearchPq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    commit_frequency: cdktf.numberToTerraform(struct!.commitFrequency),
    compress: cdktf.stringToTerraform(struct!.compress),
    max_buffer_size: cdktf.numberToTerraform(struct!.maxBufferSize),
    max_file_size: cdktf.stringToTerraform(struct!.maxFileSize),
    max_size: cdktf.stringToTerraform(struct!.maxSize),
    mode: cdktf.stringToTerraform(struct!.mode),
    path: cdktf.stringToTerraform(struct!.path),
  }
}


export function packSourceInputSplunkSearchPqToHclTerraform(struct?: PackSourceInputSplunkSearchPq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    commit_frequency: {
      value: cdktf.numberToHclTerraform(struct!.commitFrequency),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    compress: {
      value: cdktf.stringToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_buffer_size: {
      value: cdktf.numberToHclTerraform(struct!.maxBufferSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.maxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_size: {
      value: cdktf.stringToHclTerraform(struct!.maxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputSplunkSearchPqOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputSplunkSearchPq | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._commitFrequency !== undefined) {
      hasAnyValues = true;
      internalValueResult.commitFrequency = this._commitFrequency;
    }
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._maxBufferSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBufferSize = this._maxBufferSize;
    }
    if (this._maxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxFileSize = this._maxFileSize;
    }
    if (this._maxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxSize = this._maxSize;
    }
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputSplunkSearchPq | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._commitFrequency = undefined;
      this._compress = undefined;
      this._maxBufferSize = undefined;
      this._maxFileSize = undefined;
      this._maxSize = undefined;
      this._mode = undefined;
      this._path = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._commitFrequency = value.commitFrequency;
      this._compress = value.compress;
      this._maxBufferSize = value.maxBufferSize;
      this._maxFileSize = value.maxFileSize;
      this._maxSize = value.maxSize;
      this._mode = value.mode;
      this._path = value.path;
    }
  }

  // commit_frequency - computed: true, optional: true, required: false
  private _commitFrequency?: number; 
  public get commitFrequency() {
    return this.getNumberAttribute('commit_frequency');
  }
  public set commitFrequency(value: number) {
    this._commitFrequency = value;
  }
  public resetCommitFrequency() {
    this._commitFrequency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commitFrequencyInput() {
    return this._commitFrequency;
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: string; 
  public get compress() {
    return this.getStringAttribute('compress');
  }
  public set compress(value: string) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // max_buffer_size - computed: true, optional: true, required: false
  private _maxBufferSize?: number; 
  public get maxBufferSize() {
    return this.getNumberAttribute('max_buffer_size');
  }
  public set maxBufferSize(value: number) {
    this._maxBufferSize = value;
  }
  public resetMaxBufferSize() {
    this._maxBufferSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBufferSizeInput() {
    return this._maxBufferSize;
  }

  // max_file_size - computed: true, optional: true, required: false
  private _maxFileSize?: string; 
  public get maxFileSize() {
    return this.getStringAttribute('max_file_size');
  }
  public set maxFileSize(value: string) {
    this._maxFileSize = value;
  }
  public resetMaxFileSize() {
    this._maxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxFileSizeInput() {
    return this._maxFileSize;
  }

  // max_size - computed: true, optional: true, required: false
  private _maxSize?: string; 
  public get maxSize() {
    return this.getStringAttribute('max_size');
  }
  public set maxSize(value: string) {
    this._maxSize = value;
  }
  public resetMaxSize() {
    this._maxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxSizeInput() {
    return this._maxSize;
  }

  // mode - computed: true, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // path - computed: true, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }
}
export interface PackSourceInputSplunkSearchRetryRules {
  /**
  * List of HTTP codes that trigger a retry. Leave empty to use the default list of 429 and 503. Default: [429,503]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#codes PackSource#codes}
  */
  readonly codes?: number[];
  /**
  * Honor any Retry-After header that specifies a delay (in seconds) or a timestamp after which to retry the request. The delay is limited to 20 seconds, even if the Retry-After header specifies a longer delay. When disabled, all Retry-After headers are ignored. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#enable_header PackSource#enable_header}
  */
  readonly enableHeader?: boolean | cdktf.IResolvable;
  /**
  * Time interval between failed request and first retry (kickoff). Maximum allowed value is 20,000 ms (1/3 minute). Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#interval PackSource#interval}
  */
  readonly interval?: number;
  /**
  * The maximum number of times to retry a failed HTTP request. Default: 5
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#limit PackSource#limit}
  */
  readonly limit?: number;
  /**
  * Base for exponential backoff, e.g., base 2 means that retries will occur after 2, then 4, then 8 seconds, and so on. Default: 2
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#multiplier PackSource#multiplier}
  */
  readonly multiplier?: number;
  /**
  * Retry request when a connection reset (ECONNRESET) error occurs. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#retry_connect_reset PackSource#retry_connect_reset}
  */
  readonly retryConnectReset?: boolean | cdktf.IResolvable;
  /**
  * Make a single retry attempt when a connection timeout (ETIMEDOUT) error occurs. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#retry_connect_timeout PackSource#retry_connect_timeout}
  */
  readonly retryConnectTimeout?: boolean | cdktf.IResolvable;
  /**
  * The algorithm to use when performing HTTP retries. Default: "backoff"; must be one of ["none", "backoff", "static"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#type PackSource#type}
  */
  readonly type?: string;
}

export function packSourceInputSplunkSearchRetryRulesToTerraform(struct?: PackSourceInputSplunkSearchRetryRules | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    codes: cdktf.listMapper(cdktf.numberToTerraform, false)(struct!.codes),
    enable_header: cdktf.booleanToTerraform(struct!.enableHeader),
    interval: cdktf.numberToTerraform(struct!.interval),
    limit: cdktf.numberToTerraform(struct!.limit),
    multiplier: cdktf.numberToTerraform(struct!.multiplier),
    retry_connect_reset: cdktf.booleanToTerraform(struct!.retryConnectReset),
    retry_connect_timeout: cdktf.booleanToTerraform(struct!.retryConnectTimeout),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function packSourceInputSplunkSearchRetryRulesToHclTerraform(struct?: PackSourceInputSplunkSearchRetryRules | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    codes: {
      value: cdktf.listMapperHcl(cdktf.numberToHclTerraform, false)(struct!.codes),
      isBlock: false,
      type: "list",
      storageClassType: "numberList",
    },
    enable_header: {
      value: cdktf.booleanToHclTerraform(struct!.enableHeader),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    interval: {
      value: cdktf.numberToHclTerraform(struct!.interval),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    limit: {
      value: cdktf.numberToHclTerraform(struct!.limit),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    multiplier: {
      value: cdktf.numberToHclTerraform(struct!.multiplier),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    retry_connect_reset: {
      value: cdktf.booleanToHclTerraform(struct!.retryConnectReset),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    retry_connect_timeout: {
      value: cdktf.booleanToHclTerraform(struct!.retryConnectTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputSplunkSearchRetryRulesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputSplunkSearchRetryRules | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._codes !== undefined) {
      hasAnyValues = true;
      internalValueResult.codes = this._codes;
    }
    if (this._enableHeader !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableHeader = this._enableHeader;
    }
    if (this._interval !== undefined) {
      hasAnyValues = true;
      internalValueResult.interval = this._interval;
    }
    if (this._limit !== undefined) {
      hasAnyValues = true;
      internalValueResult.limit = this._limit;
    }
    if (this._multiplier !== undefined) {
      hasAnyValues = true;
      internalValueResult.multiplier = this._multiplier;
    }
    if (this._retryConnectReset !== undefined) {
      hasAnyValues = true;
      internalValueResult.retryConnectReset = this._retryConnectReset;
    }
    if (this._retryConnectTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.retryConnectTimeout = this._retryConnectTimeout;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputSplunkSearchRetryRules | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._codes = undefined;
      this._enableHeader = undefined;
      this._interval = undefined;
      this._limit = undefined;
      this._multiplier = undefined;
      this._retryConnectReset = undefined;
      this._retryConnectTimeout = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._codes = value.codes;
      this._enableHeader = value.enableHeader;
      this._interval = value.interval;
      this._limit = value.limit;
      this._multiplier = value.multiplier;
      this._retryConnectReset = value.retryConnectReset;
      this._retryConnectTimeout = value.retryConnectTimeout;
      this._type = value.type;
    }
  }

  // codes - computed: true, optional: true, required: false
  private _codes?: number[]; 
  public get codes() {
    return this.getNumberListAttribute('codes');
  }
  public set codes(value: number[]) {
    this._codes = value;
  }
  public resetCodes() {
    this._codes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get codesInput() {
    return this._codes;
  }

  // enable_header - computed: true, optional: true, required: false
  private _enableHeader?: boolean | cdktf.IResolvable; 
  public get enableHeader() {
    return this.getBooleanAttribute('enable_header');
  }
  public set enableHeader(value: boolean | cdktf.IResolvable) {
    this._enableHeader = value;
  }
  public resetEnableHeader() {
    this._enableHeader = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableHeaderInput() {
    return this._enableHeader;
  }

  // interval - computed: true, optional: true, required: false
  private _interval?: number; 
  public get interval() {
    return this.getNumberAttribute('interval');
  }
  public set interval(value: number) {
    this._interval = value;
  }
  public resetInterval() {
    this._interval = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get intervalInput() {
    return this._interval;
  }

  // limit - computed: true, optional: true, required: false
  private _limit?: number; 
  public get limit() {
    return this.getNumberAttribute('limit');
  }
  public set limit(value: number) {
    this._limit = value;
  }
  public resetLimit() {
    this._limit = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get limitInput() {
    return this._limit;
  }

  // multiplier - computed: true, optional: true, required: false
  private _multiplier?: number; 
  public get multiplier() {
    return this.getNumberAttribute('multiplier');
  }
  public set multiplier(value: number) {
    this._multiplier = value;
  }
  public resetMultiplier() {
    this._multiplier = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get multiplierInput() {
    return this._multiplier;
  }

  // retry_connect_reset - computed: true, optional: true, required: false
  private _retryConnectReset?: boolean | cdktf.IResolvable; 
  public get retryConnectReset() {
    return this.getBooleanAttribute('retry_connect_reset');
  }
  public set retryConnectReset(value: boolean | cdktf.IResolvable) {
    this._retryConnectReset = value;
  }
  public resetRetryConnectReset() {
    this._retryConnectReset = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get retryConnectResetInput() {
    return this._retryConnectReset;
  }

  // retry_connect_timeout - computed: true, optional: true, required: false
  private _retryConnectTimeout?: boolean | cdktf.IResolvable; 
  public get retryConnectTimeout() {
    return this.getBooleanAttribute('retry_connect_timeout');
  }
  public set retryConnectTimeout(value: boolean | cdktf.IResolvable) {
    this._retryConnectTimeout = value;
  }
  public resetRetryConnectTimeout() {
    this._retryConnectTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get retryConnectTimeoutInput() {
    return this._retryConnectTimeout;
  }

  // type - computed: true, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface PackSourceInputSplunkSearch {
  /**
  * JavaScript expression to compute the Authorization header value to pass in requests. The value `${token}` is used to reference the token obtained from authentication, e.g.: `Bearer ${token}`. Default: "`Bearer ${token}`"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#auth_header_expr PackSource#auth_header_expr}
  */
  readonly authHeaderExpr?: string;
  /**
  * Splunk Search authentication type. Default: "basic"; must be one of ["none", "basic", "credentialsSecret", "token", "textSecret", "oauth"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#auth_type PackSource#auth_type}
  */
  readonly authType?: string;
  /**
  * A list of event-breaking rulesets that will be applied, in order, to the input data stream. Default: ["Splunk Search Ruleset"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#breaker_rulesets PackSource#breaker_rulesets}
  */
  readonly breakerRulesets?: string[];
  /**
  * Direct connections to Destinations, and optionally via a Pipeline or a Pack
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#connections PackSource#connections}
  */
  readonly connections?: PackSourceInputSplunkSearchConnections[] | cdktf.IResolvable;
  /**
  * Select or create a secret that references your credentials
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#credentials_secret PackSource#credentials_secret}
  */
  readonly credentialsSecret?: string;
  /**
  * A cron schedule on which to run this job. Default: "* /15 * * * *"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#cron_schedule PackSource#cron_schedule}
   *
  * Note: The above comment contained a comment block ending sequence (* followed by /). We have introduced a space between to prevent syntax errors. Please ignore the space.
  */
  readonly cronSchedule?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#description PackSource#description}
  */
  readonly description?: string;
  /**
  * Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#disabled PackSource#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * The earliest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-16m@m'. Default: "-16m@m"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#earliest PackSource#earliest}
  */
  readonly earliest?: string;
  /**
  * Character encoding to use when parsing ingested data. When not set, @{product} will default to UTF-8 but may incorrectly interpret multi-byte characters.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#encoding PackSource#encoding}
  */
  readonly encoding?: string;
  /**
  * REST API used to create a search. Default: "/services/search/v2/jobs/export"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#endpoint PackSource#endpoint}
  */
  readonly endpoint?: string;
  /**
  * Optional request headers to send to the endpoint
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#endpoint_headers PackSource#endpoint_headers}
  */
  readonly endpointHeaders?: PackSourceInputSplunkSearchEndpointHeaders[] | cdktf.IResolvable;
  /**
  * Optional request parameters to send to the endpoint
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#endpoint_params PackSource#endpoint_params}
  */
  readonly endpointParams?: PackSourceInputSplunkSearchEndpointParams[] | cdktf.IResolvable;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#environment PackSource#environment}
  */
  readonly environment?: string;
  /**
  * Unique ID for this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#id PackSource#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * When enabled, this job's artifacts are not counted toward the Worker Group's finished job artifacts limit. Artifacts will be removed only after the Collector's configured time to live. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#ignore_group_jobs_limit PackSource#ignore_group_jobs_limit}
  */
  readonly ignoreGroupJobsLimit?: boolean | cdktf.IResolvable;
  /**
  * Maximum time the job is allowed to run (e.g., 30, 45s or 15m). Units are seconds, if not specified. Enter 0 for unlimited time. Default: "0"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#job_timeout PackSource#job_timeout}
  */
  readonly jobTimeout?: string;
  /**
  * How often workers should check in with the scheduler to keep job subscription alive. Default: 30
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#keep_alive_time PackSource#keep_alive_time}
  */
  readonly keepAliveTime?: number;
  /**
  * The latest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-1m@m'. Default: "-1m@m"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#latest PackSource#latest}
  */
  readonly latest?: string;
  /**
  * Collector runtime log level (verbosity). must be one of ["error", "warn", "info", "debug"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#log_level PackSource#log_level}
  */
  readonly logLevel?: string;
  /**
  * URL for OAuth
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#login_url PackSource#login_url}
  */
  readonly loginUrl?: string;
  /**
  * The number of Keep Alive Time periods before an inactive worker will have its job subscription revoked. Default: 3
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_missed_keep_alives PackSource#max_missed_keep_alives}
  */
  readonly maxMissedKeepAlives?: number;
  /**
  * Fields to add to events from this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#metadata PackSource#metadata}
  */
  readonly metadata?: PackSourceInputSplunkSearchMetadata[] | cdktf.IResolvable;
  /**
  * Additional headers to send in the OAuth login request. @{product} will automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#oauth_headers PackSource#oauth_headers}
  */
  readonly oauthHeaders?: PackSourceInputSplunkSearchOauthHeaders[] | cdktf.IResolvable;
  /**
  * Additional parameters to send in the OAuth login request. @{product} will combine the secret with these parameters, and will send the URL-encoded result in a POST request to the endpoint specified in the 'Login URL'. We'll automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#oauth_params PackSource#oauth_params}
  */
  readonly oauthParams?: PackSourceInputSplunkSearchOauthParams[] | cdktf.IResolvable;
  /**
  * Format of the returned output. Default: "json"; must be one of ["csv", "json"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#output_mode PackSource#output_mode}
  */
  readonly outputMode?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#password PackSource#password}
  */
  readonly password?: string;
  /**
  * Pipeline to process data from this Source before sending it through the Routes
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pipeline PackSource#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pq PackSource#pq}
  */
  readonly pq?: PackSourceInputSplunkSearchPq;
  /**
  * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers). Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pq_enabled PackSource#pq_enabled}
  */
  readonly pqEnabled?: boolean | cdktf.IResolvable;
  /**
  * Reject certificates that cannot be verified against a valid CA (such as self-signed certificates). Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#reject_unauthorized PackSource#reject_unauthorized}
  */
  readonly rejectUnauthorized?: boolean | cdktf.IResolvable;
  /**
  * HTTP request inactivity timeout. Use 0 for no timeout. Default: 0
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#request_timeout PackSource#request_timeout}
  */
  readonly requestTimeout?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#retry_rules PackSource#retry_rules}
  */
  readonly retryRules?: PackSourceInputSplunkSearchRetryRules;
  /**
  * Enter Splunk search here. Examples: 'index=myAppLogs level=error channel=myApp' OR '| mstats avg(myStat) as myStat WHERE index=myStatsIndex.'
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#search PackSource#search}
  */
  readonly search: string;
  /**
  * Search head base URL. Can be an expression. Default is https://localhost:8089. Default: "https://localhost:8089"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#search_head PackSource#search_head}
  */
  readonly searchHead?: string;
  /**
  * Secret parameter value to pass in request body
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#secret PackSource#secret}
  */
  readonly secret?: string;
  /**
  * Secret parameter name to pass in request body
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#secret_param_name PackSource#secret_param_name}
  */
  readonly secretParamName?: string;
  /**
  * Select whether to send data to Routes, or directly to Destinations. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#send_to_routes PackSource#send_to_routes}
  */
  readonly sendToRoutes?: boolean | cdktf.IResolvable;
  /**
  * How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines. Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#stale_channel_flush_ms PackSource#stale_channel_flush_ms}
  */
  readonly staleChannelFlushMs?: number;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#streamtags PackSource#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Select or create a stored text secret
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#text_secret PackSource#text_secret}
  */
  readonly textSecret?: string;
  /**
  * Bearer token to include in the authorization header
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#token PackSource#token}
  */
  readonly token?: string;
  /**
  * Name of the auth token attribute in the OAuth response. Can be top-level (e.g., 'token'); or nested, using a period (e.g., 'data.token').
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#token_attribute_name PackSource#token_attribute_name}
  */
  readonly tokenAttributeName?: string;
  /**
  * How often the OAuth token should be refreshed. Default: 3600
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#token_timeout_secs PackSource#token_timeout_secs}
  */
  readonly tokenTimeoutSecs?: number;
  /**
  * Time to keep the job's artifacts on disk after job completion. This also affects how long a job is listed in the Job Inspector. Default: "4h"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#ttl PackSource#ttl}
  */
  readonly ttl?: string;
  /**
  * must be "splunk_search"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#type PackSource#type}
  */
  readonly type?: string;
  /**
  * When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#use_round_robin_dns PackSource#use_round_robin_dns}
  */
  readonly useRoundRobinDns?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#username PackSource#username}
  */
  readonly username?: string;
}

export function packSourceInputSplunkSearchToTerraform(struct?: PackSourceInputSplunkSearch | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    auth_header_expr: cdktf.stringToTerraform(struct!.authHeaderExpr),
    auth_type: cdktf.stringToTerraform(struct!.authType),
    breaker_rulesets: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.breakerRulesets),
    connections: cdktf.listMapper(packSourceInputSplunkSearchConnectionsToTerraform, false)(struct!.connections),
    credentials_secret: cdktf.stringToTerraform(struct!.credentialsSecret),
    cron_schedule: cdktf.stringToTerraform(struct!.cronSchedule),
    description: cdktf.stringToTerraform(struct!.description),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    earliest: cdktf.stringToTerraform(struct!.earliest),
    encoding: cdktf.stringToTerraform(struct!.encoding),
    endpoint: cdktf.stringToTerraform(struct!.endpoint),
    endpoint_headers: cdktf.listMapper(packSourceInputSplunkSearchEndpointHeadersToTerraform, false)(struct!.endpointHeaders),
    endpoint_params: cdktf.listMapper(packSourceInputSplunkSearchEndpointParamsToTerraform, false)(struct!.endpointParams),
    environment: cdktf.stringToTerraform(struct!.environment),
    id: cdktf.stringToTerraform(struct!.id),
    ignore_group_jobs_limit: cdktf.booleanToTerraform(struct!.ignoreGroupJobsLimit),
    job_timeout: cdktf.stringToTerraform(struct!.jobTimeout),
    keep_alive_time: cdktf.numberToTerraform(struct!.keepAliveTime),
    latest: cdktf.stringToTerraform(struct!.latest),
    log_level: cdktf.stringToTerraform(struct!.logLevel),
    login_url: cdktf.stringToTerraform(struct!.loginUrl),
    max_missed_keep_alives: cdktf.numberToTerraform(struct!.maxMissedKeepAlives),
    metadata: cdktf.listMapper(packSourceInputSplunkSearchMetadataToTerraform, false)(struct!.metadata),
    oauth_headers: cdktf.listMapper(packSourceInputSplunkSearchOauthHeadersToTerraform, false)(struct!.oauthHeaders),
    oauth_params: cdktf.listMapper(packSourceInputSplunkSearchOauthParamsToTerraform, false)(struct!.oauthParams),
    output_mode: cdktf.stringToTerraform(struct!.outputMode),
    password: cdktf.stringToTerraform(struct!.password),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    pq: packSourceInputSplunkSearchPqToTerraform(struct!.pq),
    pq_enabled: cdktf.booleanToTerraform(struct!.pqEnabled),
    reject_unauthorized: cdktf.booleanToTerraform(struct!.rejectUnauthorized),
    request_timeout: cdktf.numberToTerraform(struct!.requestTimeout),
    retry_rules: packSourceInputSplunkSearchRetryRulesToTerraform(struct!.retryRules),
    search: cdktf.stringToTerraform(struct!.search),
    search_head: cdktf.stringToTerraform(struct!.searchHead),
    secret: cdktf.stringToTerraform(struct!.secret),
    secret_param_name: cdktf.stringToTerraform(struct!.secretParamName),
    send_to_routes: cdktf.booleanToTerraform(struct!.sendToRoutes),
    stale_channel_flush_ms: cdktf.numberToTerraform(struct!.staleChannelFlushMs),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    text_secret: cdktf.stringToTerraform(struct!.textSecret),
    token: cdktf.stringToTerraform(struct!.token),
    token_attribute_name: cdktf.stringToTerraform(struct!.tokenAttributeName),
    token_timeout_secs: cdktf.numberToTerraform(struct!.tokenTimeoutSecs),
    ttl: cdktf.stringToTerraform(struct!.ttl),
    type: cdktf.stringToTerraform(struct!.type),
    use_round_robin_dns: cdktf.booleanToTerraform(struct!.useRoundRobinDns),
    username: cdktf.stringToTerraform(struct!.username),
  }
}


export function packSourceInputSplunkSearchToHclTerraform(struct?: PackSourceInputSplunkSearch | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    auth_header_expr: {
      value: cdktf.stringToHclTerraform(struct!.authHeaderExpr),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    auth_type: {
      value: cdktf.stringToHclTerraform(struct!.authType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    breaker_rulesets: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.breakerRulesets),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    connections: {
      value: cdktf.listMapperHcl(packSourceInputSplunkSearchConnectionsToHclTerraform, false)(struct!.connections),
      isBlock: true,
      type: "list",
      storageClassType: "PackSourceInputSplunkSearchConnectionsList",
    },
    credentials_secret: {
      value: cdktf.stringToHclTerraform(struct!.credentialsSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    cron_schedule: {
      value: cdktf.stringToHclTerraform(struct!.cronSchedule),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    earliest: {
      value: cdktf.stringToHclTerraform(struct!.earliest),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    encoding: {
      value: cdktf.stringToHclTerraform(struct!.encoding),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    endpoint: {
      value: cdktf.stringToHclTerraform(struct!.endpoint),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    endpoint_headers: {
      value: cdktf.listMapperHcl(packSourceInputSplunkSearchEndpointHeadersToHclTerraform, false)(struct!.endpointHeaders),
      isBlock: true,
      type: "list",
      storageClassType: "PackSourceInputSplunkSearchEndpointHeadersList",
    },
    endpoint_params: {
      value: cdktf.listMapperHcl(packSourceInputSplunkSearchEndpointParamsToHclTerraform, false)(struct!.endpointParams),
      isBlock: true,
      type: "list",
      storageClassType: "PackSourceInputSplunkSearchEndpointParamsList",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ignore_group_jobs_limit: {
      value: cdktf.booleanToHclTerraform(struct!.ignoreGroupJobsLimit),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    job_timeout: {
      value: cdktf.stringToHclTerraform(struct!.jobTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    keep_alive_time: {
      value: cdktf.numberToHclTerraform(struct!.keepAliveTime),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    latest: {
      value: cdktf.stringToHclTerraform(struct!.latest),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    log_level: {
      value: cdktf.stringToHclTerraform(struct!.logLevel),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    login_url: {
      value: cdktf.stringToHclTerraform(struct!.loginUrl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_missed_keep_alives: {
      value: cdktf.numberToHclTerraform(struct!.maxMissedKeepAlives),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    metadata: {
      value: cdktf.listMapperHcl(packSourceInputSplunkSearchMetadataToHclTerraform, false)(struct!.metadata),
      isBlock: true,
      type: "list",
      storageClassType: "PackSourceInputSplunkSearchMetadataList",
    },
    oauth_headers: {
      value: cdktf.listMapperHcl(packSourceInputSplunkSearchOauthHeadersToHclTerraform, false)(struct!.oauthHeaders),
      isBlock: true,
      type: "list",
      storageClassType: "PackSourceInputSplunkSearchOauthHeadersList",
    },
    oauth_params: {
      value: cdktf.listMapperHcl(packSourceInputSplunkSearchOauthParamsToHclTerraform, false)(struct!.oauthParams),
      isBlock: true,
      type: "list",
      storageClassType: "PackSourceInputSplunkSearchOauthParamsList",
    },
    output_mode: {
      value: cdktf.stringToHclTerraform(struct!.outputMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    password: {
      value: cdktf.stringToHclTerraform(struct!.password),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq: {
      value: packSourceInputSplunkSearchPqToHclTerraform(struct!.pq),
      isBlock: true,
      type: "struct",
      storageClassType: "PackSourceInputSplunkSearchPq",
    },
    pq_enabled: {
      value: cdktf.booleanToHclTerraform(struct!.pqEnabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    reject_unauthorized: {
      value: cdktf.booleanToHclTerraform(struct!.rejectUnauthorized),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    request_timeout: {
      value: cdktf.numberToHclTerraform(struct!.requestTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    retry_rules: {
      value: packSourceInputSplunkSearchRetryRulesToHclTerraform(struct!.retryRules),
      isBlock: true,
      type: "struct",
      storageClassType: "PackSourceInputSplunkSearchRetryRules",
    },
    search: {
      value: cdktf.stringToHclTerraform(struct!.search),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    search_head: {
      value: cdktf.stringToHclTerraform(struct!.searchHead),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret: {
      value: cdktf.stringToHclTerraform(struct!.secret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_param_name: {
      value: cdktf.stringToHclTerraform(struct!.secretParamName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    send_to_routes: {
      value: cdktf.booleanToHclTerraform(struct!.sendToRoutes),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    stale_channel_flush_ms: {
      value: cdktf.numberToHclTerraform(struct!.staleChannelFlushMs),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    text_secret: {
      value: cdktf.stringToHclTerraform(struct!.textSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    token: {
      value: cdktf.stringToHclTerraform(struct!.token),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    token_attribute_name: {
      value: cdktf.stringToHclTerraform(struct!.tokenAttributeName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    token_timeout_secs: {
      value: cdktf.numberToHclTerraform(struct!.tokenTimeoutSecs),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    ttl: {
      value: cdktf.stringToHclTerraform(struct!.ttl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    use_round_robin_dns: {
      value: cdktf.booleanToHclTerraform(struct!.useRoundRobinDns),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    username: {
      value: cdktf.stringToHclTerraform(struct!.username),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputSplunkSearchOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputSplunkSearch | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._authHeaderExpr !== undefined) {
      hasAnyValues = true;
      internalValueResult.authHeaderExpr = this._authHeaderExpr;
    }
    if (this._authType !== undefined) {
      hasAnyValues = true;
      internalValueResult.authType = this._authType;
    }
    if (this._breakerRulesets !== undefined) {
      hasAnyValues = true;
      internalValueResult.breakerRulesets = this._breakerRulesets;
    }
    if (this._connections?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.connections = this._connections?.internalValue;
    }
    if (this._credentialsSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.credentialsSecret = this._credentialsSecret;
    }
    if (this._cronSchedule !== undefined) {
      hasAnyValues = true;
      internalValueResult.cronSchedule = this._cronSchedule;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._earliest !== undefined) {
      hasAnyValues = true;
      internalValueResult.earliest = this._earliest;
    }
    if (this._encoding !== undefined) {
      hasAnyValues = true;
      internalValueResult.encoding = this._encoding;
    }
    if (this._endpoint !== undefined) {
      hasAnyValues = true;
      internalValueResult.endpoint = this._endpoint;
    }
    if (this._endpointHeaders?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.endpointHeaders = this._endpointHeaders?.internalValue;
    }
    if (this._endpointParams?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.endpointParams = this._endpointParams?.internalValue;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._ignoreGroupJobsLimit !== undefined) {
      hasAnyValues = true;
      internalValueResult.ignoreGroupJobsLimit = this._ignoreGroupJobsLimit;
    }
    if (this._jobTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.jobTimeout = this._jobTimeout;
    }
    if (this._keepAliveTime !== undefined) {
      hasAnyValues = true;
      internalValueResult.keepAliveTime = this._keepAliveTime;
    }
    if (this._latest !== undefined) {
      hasAnyValues = true;
      internalValueResult.latest = this._latest;
    }
    if (this._logLevel !== undefined) {
      hasAnyValues = true;
      internalValueResult.logLevel = this._logLevel;
    }
    if (this._loginUrl !== undefined) {
      hasAnyValues = true;
      internalValueResult.loginUrl = this._loginUrl;
    }
    if (this._maxMissedKeepAlives !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxMissedKeepAlives = this._maxMissedKeepAlives;
    }
    if (this._metadata?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadata = this._metadata?.internalValue;
    }
    if (this._oauthHeaders?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.oauthHeaders = this._oauthHeaders?.internalValue;
    }
    if (this._oauthParams?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.oauthParams = this._oauthParams?.internalValue;
    }
    if (this._outputMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.outputMode = this._outputMode;
    }
    if (this._password !== undefined) {
      hasAnyValues = true;
      internalValueResult.password = this._password;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._pq?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pq = this._pq?.internalValue;
    }
    if (this._pqEnabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqEnabled = this._pqEnabled;
    }
    if (this._rejectUnauthorized !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectUnauthorized = this._rejectUnauthorized;
    }
    if (this._requestTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.requestTimeout = this._requestTimeout;
    }
    if (this._retryRules?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.retryRules = this._retryRules?.internalValue;
    }
    if (this._search !== undefined) {
      hasAnyValues = true;
      internalValueResult.search = this._search;
    }
    if (this._searchHead !== undefined) {
      hasAnyValues = true;
      internalValueResult.searchHead = this._searchHead;
    }
    if (this._secret !== undefined) {
      hasAnyValues = true;
      internalValueResult.secret = this._secret;
    }
    if (this._secretParamName !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretParamName = this._secretParamName;
    }
    if (this._sendToRoutes !== undefined) {
      hasAnyValues = true;
      internalValueResult.sendToRoutes = this._sendToRoutes;
    }
    if (this._staleChannelFlushMs !== undefined) {
      hasAnyValues = true;
      internalValueResult.staleChannelFlushMs = this._staleChannelFlushMs;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._textSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.textSecret = this._textSecret;
    }
    if (this._token !== undefined) {
      hasAnyValues = true;
      internalValueResult.token = this._token;
    }
    if (this._tokenAttributeName !== undefined) {
      hasAnyValues = true;
      internalValueResult.tokenAttributeName = this._tokenAttributeName;
    }
    if (this._tokenTimeoutSecs !== undefined) {
      hasAnyValues = true;
      internalValueResult.tokenTimeoutSecs = this._tokenTimeoutSecs;
    }
    if (this._ttl !== undefined) {
      hasAnyValues = true;
      internalValueResult.ttl = this._ttl;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._useRoundRobinDns !== undefined) {
      hasAnyValues = true;
      internalValueResult.useRoundRobinDns = this._useRoundRobinDns;
    }
    if (this._username !== undefined) {
      hasAnyValues = true;
      internalValueResult.username = this._username;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputSplunkSearch | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._authHeaderExpr = undefined;
      this._authType = undefined;
      this._breakerRulesets = undefined;
      this._connections.internalValue = undefined;
      this._credentialsSecret = undefined;
      this._cronSchedule = undefined;
      this._description = undefined;
      this._disabled = undefined;
      this._earliest = undefined;
      this._encoding = undefined;
      this._endpoint = undefined;
      this._endpointHeaders.internalValue = undefined;
      this._endpointParams.internalValue = undefined;
      this._environment = undefined;
      this._id = undefined;
      this._ignoreGroupJobsLimit = undefined;
      this._jobTimeout = undefined;
      this._keepAliveTime = undefined;
      this._latest = undefined;
      this._logLevel = undefined;
      this._loginUrl = undefined;
      this._maxMissedKeepAlives = undefined;
      this._metadata.internalValue = undefined;
      this._oauthHeaders.internalValue = undefined;
      this._oauthParams.internalValue = undefined;
      this._outputMode = undefined;
      this._password = undefined;
      this._pipeline = undefined;
      this._pq.internalValue = undefined;
      this._pqEnabled = undefined;
      this._rejectUnauthorized = undefined;
      this._requestTimeout = undefined;
      this._retryRules.internalValue = undefined;
      this._search = undefined;
      this._searchHead = undefined;
      this._secret = undefined;
      this._secretParamName = undefined;
      this._sendToRoutes = undefined;
      this._staleChannelFlushMs = undefined;
      this._streamtags = undefined;
      this._textSecret = undefined;
      this._token = undefined;
      this._tokenAttributeName = undefined;
      this._tokenTimeoutSecs = undefined;
      this._ttl = undefined;
      this._type = undefined;
      this._useRoundRobinDns = undefined;
      this._username = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._authHeaderExpr = value.authHeaderExpr;
      this._authType = value.authType;
      this._breakerRulesets = value.breakerRulesets;
      this._connections.internalValue = value.connections;
      this._credentialsSecret = value.credentialsSecret;
      this._cronSchedule = value.cronSchedule;
      this._description = value.description;
      this._disabled = value.disabled;
      this._earliest = value.earliest;
      this._encoding = value.encoding;
      this._endpoint = value.endpoint;
      this._endpointHeaders.internalValue = value.endpointHeaders;
      this._endpointParams.internalValue = value.endpointParams;
      this._environment = value.environment;
      this._id = value.id;
      this._ignoreGroupJobsLimit = value.ignoreGroupJobsLimit;
      this._jobTimeout = value.jobTimeout;
      this._keepAliveTime = value.keepAliveTime;
      this._latest = value.latest;
      this._logLevel = value.logLevel;
      this._loginUrl = value.loginUrl;
      this._maxMissedKeepAlives = value.maxMissedKeepAlives;
      this._metadata.internalValue = value.metadata;
      this._oauthHeaders.internalValue = value.oauthHeaders;
      this._oauthParams.internalValue = value.oauthParams;
      this._outputMode = value.outputMode;
      this._password = value.password;
      this._pipeline = value.pipeline;
      this._pq.internalValue = value.pq;
      this._pqEnabled = value.pqEnabled;
      this._rejectUnauthorized = value.rejectUnauthorized;
      this._requestTimeout = value.requestTimeout;
      this._retryRules.internalValue = value.retryRules;
      this._search = value.search;
      this._searchHead = value.searchHead;
      this._secret = value.secret;
      this._secretParamName = value.secretParamName;
      this._sendToRoutes = value.sendToRoutes;
      this._staleChannelFlushMs = value.staleChannelFlushMs;
      this._streamtags = value.streamtags;
      this._textSecret = value.textSecret;
      this._token = value.token;
      this._tokenAttributeName = value.tokenAttributeName;
      this._tokenTimeoutSecs = value.tokenTimeoutSecs;
      this._ttl = value.ttl;
      this._type = value.type;
      this._useRoundRobinDns = value.useRoundRobinDns;
      this._username = value.username;
    }
  }

  // auth_header_expr - computed: true, optional: true, required: false
  private _authHeaderExpr?: string; 
  public get authHeaderExpr() {
    return this.getStringAttribute('auth_header_expr');
  }
  public set authHeaderExpr(value: string) {
    this._authHeaderExpr = value;
  }
  public resetAuthHeaderExpr() {
    this._authHeaderExpr = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authHeaderExprInput() {
    return this._authHeaderExpr;
  }

  // auth_type - computed: true, optional: true, required: false
  private _authType?: string; 
  public get authType() {
    return this.getStringAttribute('auth_type');
  }
  public set authType(value: string) {
    this._authType = value;
  }
  public resetAuthType() {
    this._authType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authTypeInput() {
    return this._authType;
  }

  // breaker_rulesets - computed: true, optional: true, required: false
  private _breakerRulesets?: string[]; 
  public get breakerRulesets() {
    return this.getListAttribute('breaker_rulesets');
  }
  public set breakerRulesets(value: string[]) {
    this._breakerRulesets = value;
  }
  public resetBreakerRulesets() {
    this._breakerRulesets = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get breakerRulesetsInput() {
    return this._breakerRulesets;
  }

  // connections - computed: false, optional: true, required: false
  private _connections = new PackSourceInputSplunkSearchConnectionsList(this, "connections", false);
  public get connections() {
    return this._connections;
  }
  public putConnections(value: PackSourceInputSplunkSearchConnections[] | cdktf.IResolvable) {
    this._connections.internalValue = value;
  }
  public resetConnections() {
    this._connections.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectionsInput() {
    return this._connections.internalValue;
  }

  // credentials_secret - computed: false, optional: true, required: false
  private _credentialsSecret?: string; 
  public get credentialsSecret() {
    return this.getStringAttribute('credentials_secret');
  }
  public set credentialsSecret(value: string) {
    this._credentialsSecret = value;
  }
  public resetCredentialsSecret() {
    this._credentialsSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get credentialsSecretInput() {
    return this._credentialsSecret;
  }

  // cron_schedule - computed: true, optional: true, required: false
  private _cronSchedule?: string; 
  public get cronSchedule() {
    return this.getStringAttribute('cron_schedule');
  }
  public set cronSchedule(value: string) {
    this._cronSchedule = value;
  }
  public resetCronSchedule() {
    this._cronSchedule = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cronScheduleInput() {
    return this._cronSchedule;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // earliest - computed: true, optional: true, required: false
  private _earliest?: string; 
  public get earliest() {
    return this.getStringAttribute('earliest');
  }
  public set earliest(value: string) {
    this._earliest = value;
  }
  public resetEarliest() {
    this._earliest = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get earliestInput() {
    return this._earliest;
  }

  // encoding - computed: false, optional: true, required: false
  private _encoding?: string; 
  public get encoding() {
    return this.getStringAttribute('encoding');
  }
  public set encoding(value: string) {
    this._encoding = value;
  }
  public resetEncoding() {
    this._encoding = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get encodingInput() {
    return this._encoding;
  }

  // endpoint - computed: true, optional: true, required: false
  private _endpoint?: string; 
  public get endpoint() {
    return this.getStringAttribute('endpoint');
  }
  public set endpoint(value: string) {
    this._endpoint = value;
  }
  public resetEndpoint() {
    this._endpoint = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get endpointInput() {
    return this._endpoint;
  }

  // endpoint_headers - computed: false, optional: true, required: false
  private _endpointHeaders = new PackSourceInputSplunkSearchEndpointHeadersList(this, "endpoint_headers", false);
  public get endpointHeaders() {
    return this._endpointHeaders;
  }
  public putEndpointHeaders(value: PackSourceInputSplunkSearchEndpointHeaders[] | cdktf.IResolvable) {
    this._endpointHeaders.internalValue = value;
  }
  public resetEndpointHeaders() {
    this._endpointHeaders.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get endpointHeadersInput() {
    return this._endpointHeaders.internalValue;
  }

  // endpoint_params - computed: false, optional: true, required: false
  private _endpointParams = new PackSourceInputSplunkSearchEndpointParamsList(this, "endpoint_params", false);
  public get endpointParams() {
    return this._endpointParams;
  }
  public putEndpointParams(value: PackSourceInputSplunkSearchEndpointParams[] | cdktf.IResolvable) {
    this._endpointParams.internalValue = value;
  }
  public resetEndpointParams() {
    this._endpointParams.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get endpointParamsInput() {
    return this._endpointParams.internalValue;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // ignore_group_jobs_limit - computed: true, optional: true, required: false
  private _ignoreGroupJobsLimit?: boolean | cdktf.IResolvable; 
  public get ignoreGroupJobsLimit() {
    return this.getBooleanAttribute('ignore_group_jobs_limit');
  }
  public set ignoreGroupJobsLimit(value: boolean | cdktf.IResolvable) {
    this._ignoreGroupJobsLimit = value;
  }
  public resetIgnoreGroupJobsLimit() {
    this._ignoreGroupJobsLimit = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ignoreGroupJobsLimitInput() {
    return this._ignoreGroupJobsLimit;
  }

  // job_timeout - computed: true, optional: true, required: false
  private _jobTimeout?: string; 
  public get jobTimeout() {
    return this.getStringAttribute('job_timeout');
  }
  public set jobTimeout(value: string) {
    this._jobTimeout = value;
  }
  public resetJobTimeout() {
    this._jobTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get jobTimeoutInput() {
    return this._jobTimeout;
  }

  // keep_alive_time - computed: true, optional: true, required: false
  private _keepAliveTime?: number; 
  public get keepAliveTime() {
    return this.getNumberAttribute('keep_alive_time');
  }
  public set keepAliveTime(value: number) {
    this._keepAliveTime = value;
  }
  public resetKeepAliveTime() {
    this._keepAliveTime = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keepAliveTimeInput() {
    return this._keepAliveTime;
  }

  // latest - computed: true, optional: true, required: false
  private _latest?: string; 
  public get latest() {
    return this.getStringAttribute('latest');
  }
  public set latest(value: string) {
    this._latest = value;
  }
  public resetLatest() {
    this._latest = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get latestInput() {
    return this._latest;
  }

  // log_level - computed: false, optional: true, required: false
  private _logLevel?: string; 
  public get logLevel() {
    return this.getStringAttribute('log_level');
  }
  public set logLevel(value: string) {
    this._logLevel = value;
  }
  public resetLogLevel() {
    this._logLevel = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get logLevelInput() {
    return this._logLevel;
  }

  // login_url - computed: false, optional: true, required: false
  private _loginUrl?: string; 
  public get loginUrl() {
    return this.getStringAttribute('login_url');
  }
  public set loginUrl(value: string) {
    this._loginUrl = value;
  }
  public resetLoginUrl() {
    this._loginUrl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get loginUrlInput() {
    return this._loginUrl;
  }

  // max_missed_keep_alives - computed: true, optional: true, required: false
  private _maxMissedKeepAlives?: number; 
  public get maxMissedKeepAlives() {
    return this.getNumberAttribute('max_missed_keep_alives');
  }
  public set maxMissedKeepAlives(value: number) {
    this._maxMissedKeepAlives = value;
  }
  public resetMaxMissedKeepAlives() {
    this._maxMissedKeepAlives = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxMissedKeepAlivesInput() {
    return this._maxMissedKeepAlives;
  }

  // metadata - computed: false, optional: true, required: false
  private _metadata = new PackSourceInputSplunkSearchMetadataList(this, "metadata", false);
  public get metadata() {
    return this._metadata;
  }
  public putMetadata(value: PackSourceInputSplunkSearchMetadata[] | cdktf.IResolvable) {
    this._metadata.internalValue = value;
  }
  public resetMetadata() {
    this._metadata.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataInput() {
    return this._metadata.internalValue;
  }

  // oauth_headers - computed: false, optional: true, required: false
  private _oauthHeaders = new PackSourceInputSplunkSearchOauthHeadersList(this, "oauth_headers", false);
  public get oauthHeaders() {
    return this._oauthHeaders;
  }
  public putOauthHeaders(value: PackSourceInputSplunkSearchOauthHeaders[] | cdktf.IResolvable) {
    this._oauthHeaders.internalValue = value;
  }
  public resetOauthHeaders() {
    this._oauthHeaders.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get oauthHeadersInput() {
    return this._oauthHeaders.internalValue;
  }

  // oauth_params - computed: false, optional: true, required: false
  private _oauthParams = new PackSourceInputSplunkSearchOauthParamsList(this, "oauth_params", false);
  public get oauthParams() {
    return this._oauthParams;
  }
  public putOauthParams(value: PackSourceInputSplunkSearchOauthParams[] | cdktf.IResolvable) {
    this._oauthParams.internalValue = value;
  }
  public resetOauthParams() {
    this._oauthParams.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get oauthParamsInput() {
    return this._oauthParams.internalValue;
  }

  // output_mode - computed: true, optional: true, required: false
  private _outputMode?: string; 
  public get outputMode() {
    return this.getStringAttribute('output_mode');
  }
  public set outputMode(value: string) {
    this._outputMode = value;
  }
  public resetOutputMode() {
    this._outputMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get outputModeInput() {
    return this._outputMode;
  }

  // password - computed: false, optional: true, required: false
  private _password?: string; 
  public get password() {
    return this.getStringAttribute('password');
  }
  public set password(value: string) {
    this._password = value;
  }
  public resetPassword() {
    this._password = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passwordInput() {
    return this._password;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // pq - computed: false, optional: true, required: false
  private _pq = new PackSourceInputSplunkSearchPqOutputReference(this, "pq");
  public get pq() {
    return this._pq;
  }
  public putPq(value: PackSourceInputSplunkSearchPq) {
    this._pq.internalValue = value;
  }
  public resetPq() {
    this._pq.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqInput() {
    return this._pq.internalValue;
  }

  // pq_enabled - computed: true, optional: true, required: false
  private _pqEnabled?: boolean | cdktf.IResolvable; 
  public get pqEnabled() {
    return this.getBooleanAttribute('pq_enabled');
  }
  public set pqEnabled(value: boolean | cdktf.IResolvable) {
    this._pqEnabled = value;
  }
  public resetPqEnabled() {
    this._pqEnabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqEnabledInput() {
    return this._pqEnabled;
  }

  // reject_unauthorized - computed: true, optional: true, required: false
  private _rejectUnauthorized?: boolean | cdktf.IResolvable; 
  public get rejectUnauthorized() {
    return this.getBooleanAttribute('reject_unauthorized');
  }
  public set rejectUnauthorized(value: boolean | cdktf.IResolvable) {
    this._rejectUnauthorized = value;
  }
  public resetRejectUnauthorized() {
    this._rejectUnauthorized = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectUnauthorizedInput() {
    return this._rejectUnauthorized;
  }

  // request_timeout - computed: true, optional: true, required: false
  private _requestTimeout?: number; 
  public get requestTimeout() {
    return this.getNumberAttribute('request_timeout');
  }
  public set requestTimeout(value: number) {
    this._requestTimeout = value;
  }
  public resetRequestTimeout() {
    this._requestTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestTimeoutInput() {
    return this._requestTimeout;
  }

  // retry_rules - computed: false, optional: true, required: false
  private _retryRules = new PackSourceInputSplunkSearchRetryRulesOutputReference(this, "retry_rules");
  public get retryRules() {
    return this._retryRules;
  }
  public putRetryRules(value: PackSourceInputSplunkSearchRetryRules) {
    this._retryRules.internalValue = value;
  }
  public resetRetryRules() {
    this._retryRules.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get retryRulesInput() {
    return this._retryRules.internalValue;
  }

  // search - computed: false, optional: false, required: true
  private _search?: string; 
  public get search() {
    return this.getStringAttribute('search');
  }
  public set search(value: string) {
    this._search = value;
  }
  // Temporarily expose input value. Use with caution.
  public get searchInput() {
    return this._search;
  }

  // search_head - computed: true, optional: true, required: false
  private _searchHead?: string; 
  public get searchHead() {
    return this.getStringAttribute('search_head');
  }
  public set searchHead(value: string) {
    this._searchHead = value;
  }
  public resetSearchHead() {
    this._searchHead = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get searchHeadInput() {
    return this._searchHead;
  }

  // secret - computed: false, optional: true, required: false
  private _secret?: string; 
  public get secret() {
    return this.getStringAttribute('secret');
  }
  public set secret(value: string) {
    this._secret = value;
  }
  public resetSecret() {
    this._secret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretInput() {
    return this._secret;
  }

  // secret_param_name - computed: false, optional: true, required: false
  private _secretParamName?: string; 
  public get secretParamName() {
    return this.getStringAttribute('secret_param_name');
  }
  public set secretParamName(value: string) {
    this._secretParamName = value;
  }
  public resetSecretParamName() {
    this._secretParamName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretParamNameInput() {
    return this._secretParamName;
  }

  // send_to_routes - computed: true, optional: true, required: false
  private _sendToRoutes?: boolean | cdktf.IResolvable; 
  public get sendToRoutes() {
    return this.getBooleanAttribute('send_to_routes');
  }
  public set sendToRoutes(value: boolean | cdktf.IResolvable) {
    this._sendToRoutes = value;
  }
  public resetSendToRoutes() {
    this._sendToRoutes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sendToRoutesInput() {
    return this._sendToRoutes;
  }

  // stale_channel_flush_ms - computed: true, optional: true, required: false
  private _staleChannelFlushMs?: number; 
  public get staleChannelFlushMs() {
    return this.getNumberAttribute('stale_channel_flush_ms');
  }
  public set staleChannelFlushMs(value: number) {
    this._staleChannelFlushMs = value;
  }
  public resetStaleChannelFlushMs() {
    this._staleChannelFlushMs = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get staleChannelFlushMsInput() {
    return this._staleChannelFlushMs;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // text_secret - computed: false, optional: true, required: false
  private _textSecret?: string; 
  public get textSecret() {
    return this.getStringAttribute('text_secret');
  }
  public set textSecret(value: string) {
    this._textSecret = value;
  }
  public resetTextSecret() {
    this._textSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get textSecretInput() {
    return this._textSecret;
  }

  // token - computed: false, optional: true, required: false
  private _token?: string; 
  public get token() {
    return this.getStringAttribute('token');
  }
  public set token(value: string) {
    this._token = value;
  }
  public resetToken() {
    this._token = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tokenInput() {
    return this._token;
  }

  // token_attribute_name - computed: false, optional: true, required: false
  private _tokenAttributeName?: string; 
  public get tokenAttributeName() {
    return this.getStringAttribute('token_attribute_name');
  }
  public set tokenAttributeName(value: string) {
    this._tokenAttributeName = value;
  }
  public resetTokenAttributeName() {
    this._tokenAttributeName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tokenAttributeNameInput() {
    return this._tokenAttributeName;
  }

  // token_timeout_secs - computed: true, optional: true, required: false
  private _tokenTimeoutSecs?: number; 
  public get tokenTimeoutSecs() {
    return this.getNumberAttribute('token_timeout_secs');
  }
  public set tokenTimeoutSecs(value: number) {
    this._tokenTimeoutSecs = value;
  }
  public resetTokenTimeoutSecs() {
    this._tokenTimeoutSecs = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tokenTimeoutSecsInput() {
    return this._tokenTimeoutSecs;
  }

  // ttl - computed: true, optional: true, required: false
  private _ttl?: string; 
  public get ttl() {
    return this.getStringAttribute('ttl');
  }
  public set ttl(value: string) {
    this._ttl = value;
  }
  public resetTtl() {
    this._ttl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ttlInput() {
    return this._ttl;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // use_round_robin_dns - computed: true, optional: true, required: false
  private _useRoundRobinDns?: boolean | cdktf.IResolvable; 
  public get useRoundRobinDns() {
    return this.getBooleanAttribute('use_round_robin_dns');
  }
  public set useRoundRobinDns(value: boolean | cdktf.IResolvable) {
    this._useRoundRobinDns = value;
  }
  public resetUseRoundRobinDns() {
    this._useRoundRobinDns = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get useRoundRobinDnsInput() {
    return this._useRoundRobinDns;
  }

  // username - computed: false, optional: true, required: false
  private _username?: string; 
  public get username() {
    return this.getStringAttribute('username');
  }
  public set username(value: string) {
    this._username = value;
  }
  public resetUsername() {
    this._username = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usernameInput() {
    return this._username;
  }
}
export interface PackSourceInputSqsConnections {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#output PackSource#output}
  */
  readonly output: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pipeline PackSource#pipeline}
  */
  readonly pipeline?: string;
}

export function packSourceInputSqsConnectionsToTerraform(struct?: PackSourceInputSqsConnections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    output: cdktf.stringToTerraform(struct!.output),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
  }
}


export function packSourceInputSqsConnectionsToHclTerraform(struct?: PackSourceInputSqsConnections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    output: {
      value: cdktf.stringToHclTerraform(struct!.output),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputSqsConnectionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackSourceInputSqsConnections | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._output !== undefined) {
      hasAnyValues = true;
      internalValueResult.output = this._output;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputSqsConnections | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._output = undefined;
      this._pipeline = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._output = value.output;
      this._pipeline = value.pipeline;
    }
  }

  // output - computed: false, optional: false, required: true
  private _output?: string; 
  public get output() {
    return this.getStringAttribute('output');
  }
  public set output(value: string) {
    this._output = value;
  }
  // Temporarily expose input value. Use with caution.
  public get outputInput() {
    return this._output;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }
}

export class PackSourceInputSqsConnectionsList extends cdktf.ComplexList {
  public internalValue? : PackSourceInputSqsConnections[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackSourceInputSqsConnectionsOutputReference {
    return new PackSourceInputSqsConnectionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackSourceInputSqsMetadata {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#name PackSource#name}
  */
  readonly name: string;
  /**
  * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#value PackSource#value}
  */
  readonly value: string;
}

export function packSourceInputSqsMetadataToTerraform(struct?: PackSourceInputSqsMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function packSourceInputSqsMetadataToHclTerraform(struct?: PackSourceInputSqsMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputSqsMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackSourceInputSqsMetadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputSqsMetadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class PackSourceInputSqsMetadataList extends cdktf.ComplexList {
  public internalValue? : PackSourceInputSqsMetadata[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackSourceInputSqsMetadataOutputReference {
    return new PackSourceInputSqsMetadataOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackSourceInputSqsPq {
  /**
  * The number of events to send downstream before committing that Stream has read them. Default: 42
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#commit_frequency PackSource#commit_frequency}
  */
  readonly commitFrequency?: number;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#compress PackSource#compress}
  */
  readonly compress?: string;
  /**
  * The maximum number of events to hold in memory before writing the events to disk. Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_buffer_size PackSource#max_buffer_size}
  */
  readonly maxBufferSize?: number;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc. Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_file_size PackSource#max_file_size}
  */
  readonly maxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_size PackSource#max_size}
  */
  readonly maxSize?: string;
  /**
  * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine. Default: "always"; must be one of ["smart", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#mode PackSource#mode}
  */
  readonly mode?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#path PackSource#path}
  */
  readonly path?: string;
}

export function packSourceInputSqsPqToTerraform(struct?: PackSourceInputSqsPq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    commit_frequency: cdktf.numberToTerraform(struct!.commitFrequency),
    compress: cdktf.stringToTerraform(struct!.compress),
    max_buffer_size: cdktf.numberToTerraform(struct!.maxBufferSize),
    max_file_size: cdktf.stringToTerraform(struct!.maxFileSize),
    max_size: cdktf.stringToTerraform(struct!.maxSize),
    mode: cdktf.stringToTerraform(struct!.mode),
    path: cdktf.stringToTerraform(struct!.path),
  }
}


export function packSourceInputSqsPqToHclTerraform(struct?: PackSourceInputSqsPq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    commit_frequency: {
      value: cdktf.numberToHclTerraform(struct!.commitFrequency),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    compress: {
      value: cdktf.stringToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_buffer_size: {
      value: cdktf.numberToHclTerraform(struct!.maxBufferSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.maxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_size: {
      value: cdktf.stringToHclTerraform(struct!.maxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputSqsPqOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputSqsPq | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._commitFrequency !== undefined) {
      hasAnyValues = true;
      internalValueResult.commitFrequency = this._commitFrequency;
    }
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._maxBufferSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBufferSize = this._maxBufferSize;
    }
    if (this._maxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxFileSize = this._maxFileSize;
    }
    if (this._maxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxSize = this._maxSize;
    }
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputSqsPq | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._commitFrequency = undefined;
      this._compress = undefined;
      this._maxBufferSize = undefined;
      this._maxFileSize = undefined;
      this._maxSize = undefined;
      this._mode = undefined;
      this._path = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._commitFrequency = value.commitFrequency;
      this._compress = value.compress;
      this._maxBufferSize = value.maxBufferSize;
      this._maxFileSize = value.maxFileSize;
      this._maxSize = value.maxSize;
      this._mode = value.mode;
      this._path = value.path;
    }
  }

  // commit_frequency - computed: true, optional: true, required: false
  private _commitFrequency?: number; 
  public get commitFrequency() {
    return this.getNumberAttribute('commit_frequency');
  }
  public set commitFrequency(value: number) {
    this._commitFrequency = value;
  }
  public resetCommitFrequency() {
    this._commitFrequency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commitFrequencyInput() {
    return this._commitFrequency;
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: string; 
  public get compress() {
    return this.getStringAttribute('compress');
  }
  public set compress(value: string) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // max_buffer_size - computed: true, optional: true, required: false
  private _maxBufferSize?: number; 
  public get maxBufferSize() {
    return this.getNumberAttribute('max_buffer_size');
  }
  public set maxBufferSize(value: number) {
    this._maxBufferSize = value;
  }
  public resetMaxBufferSize() {
    this._maxBufferSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBufferSizeInput() {
    return this._maxBufferSize;
  }

  // max_file_size - computed: true, optional: true, required: false
  private _maxFileSize?: string; 
  public get maxFileSize() {
    return this.getStringAttribute('max_file_size');
  }
  public set maxFileSize(value: string) {
    this._maxFileSize = value;
  }
  public resetMaxFileSize() {
    this._maxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxFileSizeInput() {
    return this._maxFileSize;
  }

  // max_size - computed: true, optional: true, required: false
  private _maxSize?: string; 
  public get maxSize() {
    return this.getStringAttribute('max_size');
  }
  public set maxSize(value: string) {
    this._maxSize = value;
  }
  public resetMaxSize() {
    this._maxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxSizeInput() {
    return this._maxSize;
  }

  // mode - computed: true, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // path - computed: true, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }
}
export interface PackSourceInputSqs {
  /**
  * Amazon Resource Name (ARN) of the role to assume
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#assume_role_arn PackSource#assume_role_arn}
  */
  readonly assumeRoleArn?: string;
  /**
  * External ID to use when assuming role
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#assume_role_external_id PackSource#assume_role_external_id}
  */
  readonly assumeRoleExternalId?: string;
  /**
  * SQS queue owner's AWS account ID. Leave empty if SQS queue is in same AWS account.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#aws_account_id PackSource#aws_account_id}
  */
  readonly awsAccountId?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#aws_api_key PackSource#aws_api_key}
  */
  readonly awsApiKey?: string;
  /**
  * AWS authentication method. Choose Auto to use IAM roles. Default: "auto"; must be one of ["auto", "manual", "secret"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#aws_authentication_method PackSource#aws_authentication_method}
  */
  readonly awsAuthenticationMethod?: string;
  /**
  * Select or create a stored secret that references your access key and secret key
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#aws_secret PackSource#aws_secret}
  */
  readonly awsSecret?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#aws_secret_key PackSource#aws_secret_key}
  */
  readonly awsSecretKey?: string;
  /**
  * Direct connections to Destinations, and optionally via a Pipeline or a Pack
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#connections PackSource#connections}
  */
  readonly connections?: PackSourceInputSqsConnections[] | cdktf.IResolvable;
  /**
  * Create queue if it does not exist. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#create_queue PackSource#create_queue}
  */
  readonly createQueue?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#description PackSource#description}
  */
  readonly description?: string;
  /**
  * Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#disabled PackSource#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours). Default: 3600
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#duration_seconds PackSource#duration_seconds}
  */
  readonly durationSeconds?: number;
  /**
  * Use Assume Role credentials to access SQS. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#enable_assume_role PackSource#enable_assume_role}
  */
  readonly enableAssumeRole?: boolean | cdktf.IResolvable;
  /**
  * SQS service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to SQS-compatible endpoint.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#endpoint PackSource#endpoint}
  */
  readonly endpoint?: string;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#environment PackSource#environment}
  */
  readonly environment?: string;
  /**
  * Unique ID for this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#id PackSource#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * The maximum number of messages SQS should return in a poll request. Amazon SQS never returns more messages than this value (however, fewer messages might be returned). Valid values: 1 to 10. Default: 10
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_messages PackSource#max_messages}
  */
  readonly maxMessages?: number;
  /**
  * Fields to add to events from this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#metadata PackSource#metadata}
  */
  readonly metadata?: PackSourceInputSqsMetadata[] | cdktf.IResolvable;
  /**
  * How many receiver processes to run. The higher the number, the better the throughput - at the expense of CPU overhead. Default: 3
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#num_receivers PackSource#num_receivers}
  */
  readonly numReceivers?: number;
  /**
  * Pipeline to process data from this Source before sending it through the Routes
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pipeline PackSource#pipeline}
  */
  readonly pipeline?: string;
  /**
  * How long to wait for events before trying polling again. The lower the number the higher the AWS bill. The higher the number the longer it will take for the source to react to configuration changes and system restarts. Default: 10
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#poll_timeout PackSource#poll_timeout}
  */
  readonly pollTimeout?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pq PackSource#pq}
  */
  readonly pq?: PackSourceInputSqsPq;
  /**
  * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers). Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pq_enabled PackSource#pq_enabled}
  */
  readonly pqEnabled?: boolean | cdktf.IResolvable;
  /**
  * The name, URL, or ARN of the SQS queue to read events from. When a non-AWS URL is specified, format must be: '{url}/myQueueName'. Example: 'https://host:port/myQueueName'. Value must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can only be evaluated at init time. Example referencing a Global Variable: `https://host:port/myQueue-${C.vars.myVar}`.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#queue_name PackSource#queue_name}
  */
  readonly queueName: string;
  /**
  * The queue type used (or created). Default: "standard"; must be one of ["standard", "fifo"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#queue_type PackSource#queue_type}
  */
  readonly queueType?: string;
  /**
  * AWS Region where the SQS queue is located. Required, unless the Queue entry is a URL or ARN that includes a Region.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#region PackSource#region}
  */
  readonly region?: string;
  /**
  * Reject certificates that cannot be verified against a valid CA, such as self-signed certificates. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#reject_unauthorized PackSource#reject_unauthorized}
  */
  readonly rejectUnauthorized?: boolean | cdktf.IResolvable;
  /**
  * Reuse connections between requests, which can improve performance. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#reuse_connections PackSource#reuse_connections}
  */
  readonly reuseConnections?: boolean | cdktf.IResolvable;
  /**
  * Select whether to send data to Routes, or directly to Destinations. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#send_to_routes PackSource#send_to_routes}
  */
  readonly sendToRoutes?: boolean | cdktf.IResolvable;
  /**
  * Signature version to use for signing SQS requests. Default: "v4"; must be one of ["v2", "v4"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#signature_version PackSource#signature_version}
  */
  readonly signatureVersion?: string;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#streamtags PackSource#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * must be "sqs"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#type PackSource#type}
  */
  readonly type?: string;
  /**
  * After messages are retrieved by a ReceiveMessage request, @{product} will hide them from subsequent retrieve requests for at least this duration. You can set this as high as 43200 sec. (12 hours). Default: 600
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#visibility_timeout PackSource#visibility_timeout}
  */
  readonly visibilityTimeout?: number;
}

export function packSourceInputSqsToTerraform(struct?: PackSourceInputSqs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    assume_role_arn: cdktf.stringToTerraform(struct!.assumeRoleArn),
    assume_role_external_id: cdktf.stringToTerraform(struct!.assumeRoleExternalId),
    aws_account_id: cdktf.stringToTerraform(struct!.awsAccountId),
    aws_api_key: cdktf.stringToTerraform(struct!.awsApiKey),
    aws_authentication_method: cdktf.stringToTerraform(struct!.awsAuthenticationMethod),
    aws_secret: cdktf.stringToTerraform(struct!.awsSecret),
    aws_secret_key: cdktf.stringToTerraform(struct!.awsSecretKey),
    connections: cdktf.listMapper(packSourceInputSqsConnectionsToTerraform, false)(struct!.connections),
    create_queue: cdktf.booleanToTerraform(struct!.createQueue),
    description: cdktf.stringToTerraform(struct!.description),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    duration_seconds: cdktf.numberToTerraform(struct!.durationSeconds),
    enable_assume_role: cdktf.booleanToTerraform(struct!.enableAssumeRole),
    endpoint: cdktf.stringToTerraform(struct!.endpoint),
    environment: cdktf.stringToTerraform(struct!.environment),
    id: cdktf.stringToTerraform(struct!.id),
    max_messages: cdktf.numberToTerraform(struct!.maxMessages),
    metadata: cdktf.listMapper(packSourceInputSqsMetadataToTerraform, false)(struct!.metadata),
    num_receivers: cdktf.numberToTerraform(struct!.numReceivers),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    poll_timeout: cdktf.numberToTerraform(struct!.pollTimeout),
    pq: packSourceInputSqsPqToTerraform(struct!.pq),
    pq_enabled: cdktf.booleanToTerraform(struct!.pqEnabled),
    queue_name: cdktf.stringToTerraform(struct!.queueName),
    queue_type: cdktf.stringToTerraform(struct!.queueType),
    region: cdktf.stringToTerraform(struct!.region),
    reject_unauthorized: cdktf.booleanToTerraform(struct!.rejectUnauthorized),
    reuse_connections: cdktf.booleanToTerraform(struct!.reuseConnections),
    send_to_routes: cdktf.booleanToTerraform(struct!.sendToRoutes),
    signature_version: cdktf.stringToTerraform(struct!.signatureVersion),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    type: cdktf.stringToTerraform(struct!.type),
    visibility_timeout: cdktf.numberToTerraform(struct!.visibilityTimeout),
  }
}


export function packSourceInputSqsToHclTerraform(struct?: PackSourceInputSqs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    assume_role_arn: {
      value: cdktf.stringToHclTerraform(struct!.assumeRoleArn),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    assume_role_external_id: {
      value: cdktf.stringToHclTerraform(struct!.assumeRoleExternalId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    aws_account_id: {
      value: cdktf.stringToHclTerraform(struct!.awsAccountId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    aws_api_key: {
      value: cdktf.stringToHclTerraform(struct!.awsApiKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    aws_authentication_method: {
      value: cdktf.stringToHclTerraform(struct!.awsAuthenticationMethod),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    aws_secret: {
      value: cdktf.stringToHclTerraform(struct!.awsSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    aws_secret_key: {
      value: cdktf.stringToHclTerraform(struct!.awsSecretKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    connections: {
      value: cdktf.listMapperHcl(packSourceInputSqsConnectionsToHclTerraform, false)(struct!.connections),
      isBlock: true,
      type: "list",
      storageClassType: "PackSourceInputSqsConnectionsList",
    },
    create_queue: {
      value: cdktf.booleanToHclTerraform(struct!.createQueue),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    duration_seconds: {
      value: cdktf.numberToHclTerraform(struct!.durationSeconds),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    enable_assume_role: {
      value: cdktf.booleanToHclTerraform(struct!.enableAssumeRole),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    endpoint: {
      value: cdktf.stringToHclTerraform(struct!.endpoint),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_messages: {
      value: cdktf.numberToHclTerraform(struct!.maxMessages),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    metadata: {
      value: cdktf.listMapperHcl(packSourceInputSqsMetadataToHclTerraform, false)(struct!.metadata),
      isBlock: true,
      type: "list",
      storageClassType: "PackSourceInputSqsMetadataList",
    },
    num_receivers: {
      value: cdktf.numberToHclTerraform(struct!.numReceivers),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    poll_timeout: {
      value: cdktf.numberToHclTerraform(struct!.pollTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    pq: {
      value: packSourceInputSqsPqToHclTerraform(struct!.pq),
      isBlock: true,
      type: "struct",
      storageClassType: "PackSourceInputSqsPq",
    },
    pq_enabled: {
      value: cdktf.booleanToHclTerraform(struct!.pqEnabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    queue_name: {
      value: cdktf.stringToHclTerraform(struct!.queueName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    queue_type: {
      value: cdktf.stringToHclTerraform(struct!.queueType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    region: {
      value: cdktf.stringToHclTerraform(struct!.region),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reject_unauthorized: {
      value: cdktf.booleanToHclTerraform(struct!.rejectUnauthorized),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    reuse_connections: {
      value: cdktf.booleanToHclTerraform(struct!.reuseConnections),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    send_to_routes: {
      value: cdktf.booleanToHclTerraform(struct!.sendToRoutes),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    signature_version: {
      value: cdktf.stringToHclTerraform(struct!.signatureVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    visibility_timeout: {
      value: cdktf.numberToHclTerraform(struct!.visibilityTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputSqsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputSqs | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._assumeRoleArn !== undefined) {
      hasAnyValues = true;
      internalValueResult.assumeRoleArn = this._assumeRoleArn;
    }
    if (this._assumeRoleExternalId !== undefined) {
      hasAnyValues = true;
      internalValueResult.assumeRoleExternalId = this._assumeRoleExternalId;
    }
    if (this._awsAccountId !== undefined) {
      hasAnyValues = true;
      internalValueResult.awsAccountId = this._awsAccountId;
    }
    if (this._awsApiKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.awsApiKey = this._awsApiKey;
    }
    if (this._awsAuthenticationMethod !== undefined) {
      hasAnyValues = true;
      internalValueResult.awsAuthenticationMethod = this._awsAuthenticationMethod;
    }
    if (this._awsSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.awsSecret = this._awsSecret;
    }
    if (this._awsSecretKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.awsSecretKey = this._awsSecretKey;
    }
    if (this._connections?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.connections = this._connections?.internalValue;
    }
    if (this._createQueue !== undefined) {
      hasAnyValues = true;
      internalValueResult.createQueue = this._createQueue;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._durationSeconds !== undefined) {
      hasAnyValues = true;
      internalValueResult.durationSeconds = this._durationSeconds;
    }
    if (this._enableAssumeRole !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableAssumeRole = this._enableAssumeRole;
    }
    if (this._endpoint !== undefined) {
      hasAnyValues = true;
      internalValueResult.endpoint = this._endpoint;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._maxMessages !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxMessages = this._maxMessages;
    }
    if (this._metadata?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadata = this._metadata?.internalValue;
    }
    if (this._numReceivers !== undefined) {
      hasAnyValues = true;
      internalValueResult.numReceivers = this._numReceivers;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._pollTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.pollTimeout = this._pollTimeout;
    }
    if (this._pq?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pq = this._pq?.internalValue;
    }
    if (this._pqEnabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqEnabled = this._pqEnabled;
    }
    if (this._queueName !== undefined) {
      hasAnyValues = true;
      internalValueResult.queueName = this._queueName;
    }
    if (this._queueType !== undefined) {
      hasAnyValues = true;
      internalValueResult.queueType = this._queueType;
    }
    if (this._region !== undefined) {
      hasAnyValues = true;
      internalValueResult.region = this._region;
    }
    if (this._rejectUnauthorized !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectUnauthorized = this._rejectUnauthorized;
    }
    if (this._reuseConnections !== undefined) {
      hasAnyValues = true;
      internalValueResult.reuseConnections = this._reuseConnections;
    }
    if (this._sendToRoutes !== undefined) {
      hasAnyValues = true;
      internalValueResult.sendToRoutes = this._sendToRoutes;
    }
    if (this._signatureVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.signatureVersion = this._signatureVersion;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._visibilityTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.visibilityTimeout = this._visibilityTimeout;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputSqs | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._assumeRoleArn = undefined;
      this._assumeRoleExternalId = undefined;
      this._awsAccountId = undefined;
      this._awsApiKey = undefined;
      this._awsAuthenticationMethod = undefined;
      this._awsSecret = undefined;
      this._awsSecretKey = undefined;
      this._connections.internalValue = undefined;
      this._createQueue = undefined;
      this._description = undefined;
      this._disabled = undefined;
      this._durationSeconds = undefined;
      this._enableAssumeRole = undefined;
      this._endpoint = undefined;
      this._environment = undefined;
      this._id = undefined;
      this._maxMessages = undefined;
      this._metadata.internalValue = undefined;
      this._numReceivers = undefined;
      this._pipeline = undefined;
      this._pollTimeout = undefined;
      this._pq.internalValue = undefined;
      this._pqEnabled = undefined;
      this._queueName = undefined;
      this._queueType = undefined;
      this._region = undefined;
      this._rejectUnauthorized = undefined;
      this._reuseConnections = undefined;
      this._sendToRoutes = undefined;
      this._signatureVersion = undefined;
      this._streamtags = undefined;
      this._type = undefined;
      this._visibilityTimeout = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._assumeRoleArn = value.assumeRoleArn;
      this._assumeRoleExternalId = value.assumeRoleExternalId;
      this._awsAccountId = value.awsAccountId;
      this._awsApiKey = value.awsApiKey;
      this._awsAuthenticationMethod = value.awsAuthenticationMethod;
      this._awsSecret = value.awsSecret;
      this._awsSecretKey = value.awsSecretKey;
      this._connections.internalValue = value.connections;
      this._createQueue = value.createQueue;
      this._description = value.description;
      this._disabled = value.disabled;
      this._durationSeconds = value.durationSeconds;
      this._enableAssumeRole = value.enableAssumeRole;
      this._endpoint = value.endpoint;
      this._environment = value.environment;
      this._id = value.id;
      this._maxMessages = value.maxMessages;
      this._metadata.internalValue = value.metadata;
      this._numReceivers = value.numReceivers;
      this._pipeline = value.pipeline;
      this._pollTimeout = value.pollTimeout;
      this._pq.internalValue = value.pq;
      this._pqEnabled = value.pqEnabled;
      this._queueName = value.queueName;
      this._queueType = value.queueType;
      this._region = value.region;
      this._rejectUnauthorized = value.rejectUnauthorized;
      this._reuseConnections = value.reuseConnections;
      this._sendToRoutes = value.sendToRoutes;
      this._signatureVersion = value.signatureVersion;
      this._streamtags = value.streamtags;
      this._type = value.type;
      this._visibilityTimeout = value.visibilityTimeout;
    }
  }

  // assume_role_arn - computed: false, optional: true, required: false
  private _assumeRoleArn?: string; 
  public get assumeRoleArn() {
    return this.getStringAttribute('assume_role_arn');
  }
  public set assumeRoleArn(value: string) {
    this._assumeRoleArn = value;
  }
  public resetAssumeRoleArn() {
    this._assumeRoleArn = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get assumeRoleArnInput() {
    return this._assumeRoleArn;
  }

  // assume_role_external_id - computed: false, optional: true, required: false
  private _assumeRoleExternalId?: string; 
  public get assumeRoleExternalId() {
    return this.getStringAttribute('assume_role_external_id');
  }
  public set assumeRoleExternalId(value: string) {
    this._assumeRoleExternalId = value;
  }
  public resetAssumeRoleExternalId() {
    this._assumeRoleExternalId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get assumeRoleExternalIdInput() {
    return this._assumeRoleExternalId;
  }

  // aws_account_id - computed: false, optional: true, required: false
  private _awsAccountId?: string; 
  public get awsAccountId() {
    return this.getStringAttribute('aws_account_id');
  }
  public set awsAccountId(value: string) {
    this._awsAccountId = value;
  }
  public resetAwsAccountId() {
    this._awsAccountId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsAccountIdInput() {
    return this._awsAccountId;
  }

  // aws_api_key - computed: false, optional: true, required: false
  private _awsApiKey?: string; 
  public get awsApiKey() {
    return this.getStringAttribute('aws_api_key');
  }
  public set awsApiKey(value: string) {
    this._awsApiKey = value;
  }
  public resetAwsApiKey() {
    this._awsApiKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsApiKeyInput() {
    return this._awsApiKey;
  }

  // aws_authentication_method - computed: true, optional: true, required: false
  private _awsAuthenticationMethod?: string; 
  public get awsAuthenticationMethod() {
    return this.getStringAttribute('aws_authentication_method');
  }
  public set awsAuthenticationMethod(value: string) {
    this._awsAuthenticationMethod = value;
  }
  public resetAwsAuthenticationMethod() {
    this._awsAuthenticationMethod = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsAuthenticationMethodInput() {
    return this._awsAuthenticationMethod;
  }

  // aws_secret - computed: false, optional: true, required: false
  private _awsSecret?: string; 
  public get awsSecret() {
    return this.getStringAttribute('aws_secret');
  }
  public set awsSecret(value: string) {
    this._awsSecret = value;
  }
  public resetAwsSecret() {
    this._awsSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsSecretInput() {
    return this._awsSecret;
  }

  // aws_secret_key - computed: false, optional: true, required: false
  private _awsSecretKey?: string; 
  public get awsSecretKey() {
    return this.getStringAttribute('aws_secret_key');
  }
  public set awsSecretKey(value: string) {
    this._awsSecretKey = value;
  }
  public resetAwsSecretKey() {
    this._awsSecretKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsSecretKeyInput() {
    return this._awsSecretKey;
  }

  // connections - computed: false, optional: true, required: false
  private _connections = new PackSourceInputSqsConnectionsList(this, "connections", false);
  public get connections() {
    return this._connections;
  }
  public putConnections(value: PackSourceInputSqsConnections[] | cdktf.IResolvable) {
    this._connections.internalValue = value;
  }
  public resetConnections() {
    this._connections.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectionsInput() {
    return this._connections.internalValue;
  }

  // create_queue - computed: true, optional: true, required: false
  private _createQueue?: boolean | cdktf.IResolvable; 
  public get createQueue() {
    return this.getBooleanAttribute('create_queue');
  }
  public set createQueue(value: boolean | cdktf.IResolvable) {
    this._createQueue = value;
  }
  public resetCreateQueue() {
    this._createQueue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get createQueueInput() {
    return this._createQueue;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // duration_seconds - computed: true, optional: true, required: false
  private _durationSeconds?: number; 
  public get durationSeconds() {
    return this.getNumberAttribute('duration_seconds');
  }
  public set durationSeconds(value: number) {
    this._durationSeconds = value;
  }
  public resetDurationSeconds() {
    this._durationSeconds = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get durationSecondsInput() {
    return this._durationSeconds;
  }

  // enable_assume_role - computed: true, optional: true, required: false
  private _enableAssumeRole?: boolean | cdktf.IResolvable; 
  public get enableAssumeRole() {
    return this.getBooleanAttribute('enable_assume_role');
  }
  public set enableAssumeRole(value: boolean | cdktf.IResolvable) {
    this._enableAssumeRole = value;
  }
  public resetEnableAssumeRole() {
    this._enableAssumeRole = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableAssumeRoleInput() {
    return this._enableAssumeRole;
  }

  // endpoint - computed: false, optional: true, required: false
  private _endpoint?: string; 
  public get endpoint() {
    return this.getStringAttribute('endpoint');
  }
  public set endpoint(value: string) {
    this._endpoint = value;
  }
  public resetEndpoint() {
    this._endpoint = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get endpointInput() {
    return this._endpoint;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // max_messages - computed: true, optional: true, required: false
  private _maxMessages?: number; 
  public get maxMessages() {
    return this.getNumberAttribute('max_messages');
  }
  public set maxMessages(value: number) {
    this._maxMessages = value;
  }
  public resetMaxMessages() {
    this._maxMessages = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxMessagesInput() {
    return this._maxMessages;
  }

  // metadata - computed: false, optional: true, required: false
  private _metadata = new PackSourceInputSqsMetadataList(this, "metadata", false);
  public get metadata() {
    return this._metadata;
  }
  public putMetadata(value: PackSourceInputSqsMetadata[] | cdktf.IResolvable) {
    this._metadata.internalValue = value;
  }
  public resetMetadata() {
    this._metadata.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataInput() {
    return this._metadata.internalValue;
  }

  // num_receivers - computed: true, optional: true, required: false
  private _numReceivers?: number; 
  public get numReceivers() {
    return this.getNumberAttribute('num_receivers');
  }
  public set numReceivers(value: number) {
    this._numReceivers = value;
  }
  public resetNumReceivers() {
    this._numReceivers = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get numReceiversInput() {
    return this._numReceivers;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // poll_timeout - computed: true, optional: true, required: false
  private _pollTimeout?: number; 
  public get pollTimeout() {
    return this.getNumberAttribute('poll_timeout');
  }
  public set pollTimeout(value: number) {
    this._pollTimeout = value;
  }
  public resetPollTimeout() {
    this._pollTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pollTimeoutInput() {
    return this._pollTimeout;
  }

  // pq - computed: false, optional: true, required: false
  private _pq = new PackSourceInputSqsPqOutputReference(this, "pq");
  public get pq() {
    return this._pq;
  }
  public putPq(value: PackSourceInputSqsPq) {
    this._pq.internalValue = value;
  }
  public resetPq() {
    this._pq.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqInput() {
    return this._pq.internalValue;
  }

  // pq_enabled - computed: true, optional: true, required: false
  private _pqEnabled?: boolean | cdktf.IResolvable; 
  public get pqEnabled() {
    return this.getBooleanAttribute('pq_enabled');
  }
  public set pqEnabled(value: boolean | cdktf.IResolvable) {
    this._pqEnabled = value;
  }
  public resetPqEnabled() {
    this._pqEnabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqEnabledInput() {
    return this._pqEnabled;
  }

  // queue_name - computed: false, optional: false, required: true
  private _queueName?: string; 
  public get queueName() {
    return this.getStringAttribute('queue_name');
  }
  public set queueName(value: string) {
    this._queueName = value;
  }
  // Temporarily expose input value. Use with caution.
  public get queueNameInput() {
    return this._queueName;
  }

  // queue_type - computed: true, optional: true, required: false
  private _queueType?: string; 
  public get queueType() {
    return this.getStringAttribute('queue_type');
  }
  public set queueType(value: string) {
    this._queueType = value;
  }
  public resetQueueType() {
    this._queueType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get queueTypeInput() {
    return this._queueType;
  }

  // region - computed: false, optional: true, required: false
  private _region?: string; 
  public get region() {
    return this.getStringAttribute('region');
  }
  public set region(value: string) {
    this._region = value;
  }
  public resetRegion() {
    this._region = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get regionInput() {
    return this._region;
  }

  // reject_unauthorized - computed: true, optional: true, required: false
  private _rejectUnauthorized?: boolean | cdktf.IResolvable; 
  public get rejectUnauthorized() {
    return this.getBooleanAttribute('reject_unauthorized');
  }
  public set rejectUnauthorized(value: boolean | cdktf.IResolvable) {
    this._rejectUnauthorized = value;
  }
  public resetRejectUnauthorized() {
    this._rejectUnauthorized = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectUnauthorizedInput() {
    return this._rejectUnauthorized;
  }

  // reuse_connections - computed: true, optional: true, required: false
  private _reuseConnections?: boolean | cdktf.IResolvable; 
  public get reuseConnections() {
    return this.getBooleanAttribute('reuse_connections');
  }
  public set reuseConnections(value: boolean | cdktf.IResolvable) {
    this._reuseConnections = value;
  }
  public resetReuseConnections() {
    this._reuseConnections = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get reuseConnectionsInput() {
    return this._reuseConnections;
  }

  // send_to_routes - computed: true, optional: true, required: false
  private _sendToRoutes?: boolean | cdktf.IResolvable; 
  public get sendToRoutes() {
    return this.getBooleanAttribute('send_to_routes');
  }
  public set sendToRoutes(value: boolean | cdktf.IResolvable) {
    this._sendToRoutes = value;
  }
  public resetSendToRoutes() {
    this._sendToRoutes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sendToRoutesInput() {
    return this._sendToRoutes;
  }

  // signature_version - computed: true, optional: true, required: false
  private _signatureVersion?: string; 
  public get signatureVersion() {
    return this.getStringAttribute('signature_version');
  }
  public set signatureVersion(value: string) {
    this._signatureVersion = value;
  }
  public resetSignatureVersion() {
    this._signatureVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get signatureVersionInput() {
    return this._signatureVersion;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // visibility_timeout - computed: true, optional: true, required: false
  private _visibilityTimeout?: number; 
  public get visibilityTimeout() {
    return this.getNumberAttribute('visibility_timeout');
  }
  public set visibilityTimeout(value: number) {
    this._visibilityTimeout = value;
  }
  public resetVisibilityTimeout() {
    this._visibilityTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get visibilityTimeoutInput() {
    return this._visibilityTimeout;
  }
}
export interface PackSourceInputSyslogInputSyslogSyslog1Connections {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#output PackSource#output}
  */
  readonly output: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pipeline PackSource#pipeline}
  */
  readonly pipeline?: string;
}

export function packSourceInputSyslogInputSyslogSyslog1ConnectionsToTerraform(struct?: PackSourceInputSyslogInputSyslogSyslog1Connections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    output: cdktf.stringToTerraform(struct!.output),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
  }
}


export function packSourceInputSyslogInputSyslogSyslog1ConnectionsToHclTerraform(struct?: PackSourceInputSyslogInputSyslogSyslog1Connections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    output: {
      value: cdktf.stringToHclTerraform(struct!.output),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputSyslogInputSyslogSyslog1ConnectionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackSourceInputSyslogInputSyslogSyslog1Connections | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._output !== undefined) {
      hasAnyValues = true;
      internalValueResult.output = this._output;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputSyslogInputSyslogSyslog1Connections | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._output = undefined;
      this._pipeline = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._output = value.output;
      this._pipeline = value.pipeline;
    }
  }

  // output - computed: false, optional: false, required: true
  private _output?: string; 
  public get output() {
    return this.getStringAttribute('output');
  }
  public set output(value: string) {
    this._output = value;
  }
  // Temporarily expose input value. Use with caution.
  public get outputInput() {
    return this._output;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }
}

export class PackSourceInputSyslogInputSyslogSyslog1ConnectionsList extends cdktf.ComplexList {
  public internalValue? : PackSourceInputSyslogInputSyslogSyslog1Connections[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackSourceInputSyslogInputSyslogSyslog1ConnectionsOutputReference {
    return new PackSourceInputSyslogInputSyslogSyslog1ConnectionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackSourceInputSyslogInputSyslogSyslog1Metadata {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#name PackSource#name}
  */
  readonly name: string;
  /**
  * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#value PackSource#value}
  */
  readonly value: string;
}

export function packSourceInputSyslogInputSyslogSyslog1MetadataToTerraform(struct?: PackSourceInputSyslogInputSyslogSyslog1Metadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function packSourceInputSyslogInputSyslogSyslog1MetadataToHclTerraform(struct?: PackSourceInputSyslogInputSyslogSyslog1Metadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputSyslogInputSyslogSyslog1MetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackSourceInputSyslogInputSyslogSyslog1Metadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputSyslogInputSyslogSyslog1Metadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class PackSourceInputSyslogInputSyslogSyslog1MetadataList extends cdktf.ComplexList {
  public internalValue? : PackSourceInputSyslogInputSyslogSyslog1Metadata[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackSourceInputSyslogInputSyslogSyslog1MetadataOutputReference {
    return new PackSourceInputSyslogInputSyslogSyslog1MetadataOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackSourceInputSyslogInputSyslogSyslog1Pq {
  /**
  * The number of events to send downstream before committing that Stream has read them. Default: 42
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#commit_frequency PackSource#commit_frequency}
  */
  readonly commitFrequency?: number;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#compress PackSource#compress}
  */
  readonly compress?: string;
  /**
  * The maximum number of events to hold in memory before writing the events to disk. Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_buffer_size PackSource#max_buffer_size}
  */
  readonly maxBufferSize?: number;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc. Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_file_size PackSource#max_file_size}
  */
  readonly maxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_size PackSource#max_size}
  */
  readonly maxSize?: string;
  /**
  * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine. Default: "always"; must be one of ["smart", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#mode PackSource#mode}
  */
  readonly mode?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#path PackSource#path}
  */
  readonly path?: string;
}

export function packSourceInputSyslogInputSyslogSyslog1PqToTerraform(struct?: PackSourceInputSyslogInputSyslogSyslog1Pq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    commit_frequency: cdktf.numberToTerraform(struct!.commitFrequency),
    compress: cdktf.stringToTerraform(struct!.compress),
    max_buffer_size: cdktf.numberToTerraform(struct!.maxBufferSize),
    max_file_size: cdktf.stringToTerraform(struct!.maxFileSize),
    max_size: cdktf.stringToTerraform(struct!.maxSize),
    mode: cdktf.stringToTerraform(struct!.mode),
    path: cdktf.stringToTerraform(struct!.path),
  }
}


export function packSourceInputSyslogInputSyslogSyslog1PqToHclTerraform(struct?: PackSourceInputSyslogInputSyslogSyslog1Pq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    commit_frequency: {
      value: cdktf.numberToHclTerraform(struct!.commitFrequency),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    compress: {
      value: cdktf.stringToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_buffer_size: {
      value: cdktf.numberToHclTerraform(struct!.maxBufferSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.maxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_size: {
      value: cdktf.stringToHclTerraform(struct!.maxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputSyslogInputSyslogSyslog1PqOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputSyslogInputSyslogSyslog1Pq | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._commitFrequency !== undefined) {
      hasAnyValues = true;
      internalValueResult.commitFrequency = this._commitFrequency;
    }
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._maxBufferSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBufferSize = this._maxBufferSize;
    }
    if (this._maxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxFileSize = this._maxFileSize;
    }
    if (this._maxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxSize = this._maxSize;
    }
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputSyslogInputSyslogSyslog1Pq | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._commitFrequency = undefined;
      this._compress = undefined;
      this._maxBufferSize = undefined;
      this._maxFileSize = undefined;
      this._maxSize = undefined;
      this._mode = undefined;
      this._path = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._commitFrequency = value.commitFrequency;
      this._compress = value.compress;
      this._maxBufferSize = value.maxBufferSize;
      this._maxFileSize = value.maxFileSize;
      this._maxSize = value.maxSize;
      this._mode = value.mode;
      this._path = value.path;
    }
  }

  // commit_frequency - computed: true, optional: true, required: false
  private _commitFrequency?: number; 
  public get commitFrequency() {
    return this.getNumberAttribute('commit_frequency');
  }
  public set commitFrequency(value: number) {
    this._commitFrequency = value;
  }
  public resetCommitFrequency() {
    this._commitFrequency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commitFrequencyInput() {
    return this._commitFrequency;
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: string; 
  public get compress() {
    return this.getStringAttribute('compress');
  }
  public set compress(value: string) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // max_buffer_size - computed: true, optional: true, required: false
  private _maxBufferSize?: number; 
  public get maxBufferSize() {
    return this.getNumberAttribute('max_buffer_size');
  }
  public set maxBufferSize(value: number) {
    this._maxBufferSize = value;
  }
  public resetMaxBufferSize() {
    this._maxBufferSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBufferSizeInput() {
    return this._maxBufferSize;
  }

  // max_file_size - computed: true, optional: true, required: false
  private _maxFileSize?: string; 
  public get maxFileSize() {
    return this.getStringAttribute('max_file_size');
  }
  public set maxFileSize(value: string) {
    this._maxFileSize = value;
  }
  public resetMaxFileSize() {
    this._maxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxFileSizeInput() {
    return this._maxFileSize;
  }

  // max_size - computed: true, optional: true, required: false
  private _maxSize?: string; 
  public get maxSize() {
    return this.getStringAttribute('max_size');
  }
  public set maxSize(value: string) {
    this._maxSize = value;
  }
  public resetMaxSize() {
    this._maxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxSizeInput() {
    return this._maxSize;
  }

  // mode - computed: true, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // path - computed: true, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }
}
export interface PackSourceInputSyslogInputSyslogSyslog1Tls {
  /**
  * Path on server containing CA certificates to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#ca_path PackSource#ca_path}
  */
  readonly caPath?: string;
  /**
  * Path on server containing certificates to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#cert_path PackSource#cert_path}
  */
  readonly certPath?: string;
  /**
  * The name of the predefined certificate
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#certificate_name PackSource#certificate_name}
  */
  readonly certificateName?: string;
  /**
  * Parsed as JSON.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#common_name_regex PackSource#common_name_regex}
  */
  readonly commonNameRegex?: string;
  /**
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#disabled PackSource#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_version PackSource#max_version}
  */
  readonly maxVersion?: string;
  /**
  * must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#min_version PackSource#min_version}
  */
  readonly minVersion?: string;
  /**
  * Passphrase to use to decrypt private key
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#passphrase PackSource#passphrase}
  */
  readonly passphrase?: string;
  /**
  * Path on server containing the private key to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#priv_key_path PackSource#priv_key_path}
  */
  readonly privKeyPath?: string;
  /**
  * Parsed as JSON.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#reject_unauthorized PackSource#reject_unauthorized}
  */
  readonly rejectUnauthorized?: string;
  /**
  * Require clients to present their certificates. Used to perform client authentication using SSL certs. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#request_cert PackSource#request_cert}
  */
  readonly requestCert?: boolean | cdktf.IResolvable;
}

export function packSourceInputSyslogInputSyslogSyslog1TlsToTerraform(struct?: PackSourceInputSyslogInputSyslogSyslog1Tls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ca_path: cdktf.stringToTerraform(struct!.caPath),
    cert_path: cdktf.stringToTerraform(struct!.certPath),
    certificate_name: cdktf.stringToTerraform(struct!.certificateName),
    common_name_regex: cdktf.stringToTerraform(struct!.commonNameRegex),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    max_version: cdktf.stringToTerraform(struct!.maxVersion),
    min_version: cdktf.stringToTerraform(struct!.minVersion),
    passphrase: cdktf.stringToTerraform(struct!.passphrase),
    priv_key_path: cdktf.stringToTerraform(struct!.privKeyPath),
    reject_unauthorized: cdktf.stringToTerraform(struct!.rejectUnauthorized),
    request_cert: cdktf.booleanToTerraform(struct!.requestCert),
  }
}


export function packSourceInputSyslogInputSyslogSyslog1TlsToHclTerraform(struct?: PackSourceInputSyslogInputSyslogSyslog1Tls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ca_path: {
      value: cdktf.stringToHclTerraform(struct!.caPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    cert_path: {
      value: cdktf.stringToHclTerraform(struct!.certPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    certificate_name: {
      value: cdktf.stringToHclTerraform(struct!.certificateName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    common_name_regex: {
      value: cdktf.stringToHclTerraform(struct!.commonNameRegex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    max_version: {
      value: cdktf.stringToHclTerraform(struct!.maxVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    min_version: {
      value: cdktf.stringToHclTerraform(struct!.minVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    passphrase: {
      value: cdktf.stringToHclTerraform(struct!.passphrase),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    priv_key_path: {
      value: cdktf.stringToHclTerraform(struct!.privKeyPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reject_unauthorized: {
      value: cdktf.stringToHclTerraform(struct!.rejectUnauthorized),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    request_cert: {
      value: cdktf.booleanToHclTerraform(struct!.requestCert),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputSyslogInputSyslogSyslog1TlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputSyslogInputSyslogSyslog1Tls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._caPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.caPath = this._caPath;
    }
    if (this._certPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.certPath = this._certPath;
    }
    if (this._certificateName !== undefined) {
      hasAnyValues = true;
      internalValueResult.certificateName = this._certificateName;
    }
    if (this._commonNameRegex !== undefined) {
      hasAnyValues = true;
      internalValueResult.commonNameRegex = this._commonNameRegex;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._maxVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxVersion = this._maxVersion;
    }
    if (this._minVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.minVersion = this._minVersion;
    }
    if (this._passphrase !== undefined) {
      hasAnyValues = true;
      internalValueResult.passphrase = this._passphrase;
    }
    if (this._privKeyPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.privKeyPath = this._privKeyPath;
    }
    if (this._rejectUnauthorized !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectUnauthorized = this._rejectUnauthorized;
    }
    if (this._requestCert !== undefined) {
      hasAnyValues = true;
      internalValueResult.requestCert = this._requestCert;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputSyslogInputSyslogSyslog1Tls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._caPath = undefined;
      this._certPath = undefined;
      this._certificateName = undefined;
      this._commonNameRegex = undefined;
      this._disabled = undefined;
      this._maxVersion = undefined;
      this._minVersion = undefined;
      this._passphrase = undefined;
      this._privKeyPath = undefined;
      this._rejectUnauthorized = undefined;
      this._requestCert = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._caPath = value.caPath;
      this._certPath = value.certPath;
      this._certificateName = value.certificateName;
      this._commonNameRegex = value.commonNameRegex;
      this._disabled = value.disabled;
      this._maxVersion = value.maxVersion;
      this._minVersion = value.minVersion;
      this._passphrase = value.passphrase;
      this._privKeyPath = value.privKeyPath;
      this._rejectUnauthorized = value.rejectUnauthorized;
      this._requestCert = value.requestCert;
    }
  }

  // ca_path - computed: false, optional: true, required: false
  private _caPath?: string; 
  public get caPath() {
    return this.getStringAttribute('ca_path');
  }
  public set caPath(value: string) {
    this._caPath = value;
  }
  public resetCaPath() {
    this._caPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get caPathInput() {
    return this._caPath;
  }

  // cert_path - computed: false, optional: true, required: false
  private _certPath?: string; 
  public get certPath() {
    return this.getStringAttribute('cert_path');
  }
  public set certPath(value: string) {
    this._certPath = value;
  }
  public resetCertPath() {
    this._certPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certPathInput() {
    return this._certPath;
  }

  // certificate_name - computed: false, optional: true, required: false
  private _certificateName?: string; 
  public get certificateName() {
    return this.getStringAttribute('certificate_name');
  }
  public set certificateName(value: string) {
    this._certificateName = value;
  }
  public resetCertificateName() {
    this._certificateName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certificateNameInput() {
    return this._certificateName;
  }

  // common_name_regex - computed: false, optional: true, required: false
  private _commonNameRegex?: string; 
  public get commonNameRegex() {
    return this.getStringAttribute('common_name_regex');
  }
  public set commonNameRegex(value: string) {
    this._commonNameRegex = value;
  }
  public resetCommonNameRegex() {
    this._commonNameRegex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commonNameRegexInput() {
    return this._commonNameRegex;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // max_version - computed: false, optional: true, required: false
  private _maxVersion?: string; 
  public get maxVersion() {
    return this.getStringAttribute('max_version');
  }
  public set maxVersion(value: string) {
    this._maxVersion = value;
  }
  public resetMaxVersion() {
    this._maxVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxVersionInput() {
    return this._maxVersion;
  }

  // min_version - computed: false, optional: true, required: false
  private _minVersion?: string; 
  public get minVersion() {
    return this.getStringAttribute('min_version');
  }
  public set minVersion(value: string) {
    this._minVersion = value;
  }
  public resetMinVersion() {
    this._minVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get minVersionInput() {
    return this._minVersion;
  }

  // passphrase - computed: false, optional: true, required: false
  private _passphrase?: string; 
  public get passphrase() {
    return this.getStringAttribute('passphrase');
  }
  public set passphrase(value: string) {
    this._passphrase = value;
  }
  public resetPassphrase() {
    this._passphrase = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passphraseInput() {
    return this._passphrase;
  }

  // priv_key_path - computed: false, optional: true, required: false
  private _privKeyPath?: string; 
  public get privKeyPath() {
    return this.getStringAttribute('priv_key_path');
  }
  public set privKeyPath(value: string) {
    this._privKeyPath = value;
  }
  public resetPrivKeyPath() {
    this._privKeyPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get privKeyPathInput() {
    return this._privKeyPath;
  }

  // reject_unauthorized - computed: false, optional: true, required: false
  private _rejectUnauthorized?: string; 
  public get rejectUnauthorized() {
    return this.getStringAttribute('reject_unauthorized');
  }
  public set rejectUnauthorized(value: string) {
    this._rejectUnauthorized = value;
  }
  public resetRejectUnauthorized() {
    this._rejectUnauthorized = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectUnauthorizedInput() {
    return this._rejectUnauthorized;
  }

  // request_cert - computed: true, optional: true, required: false
  private _requestCert?: boolean | cdktf.IResolvable; 
  public get requestCert() {
    return this.getBooleanAttribute('request_cert');
  }
  public set requestCert(value: boolean | cdktf.IResolvable) {
    this._requestCert = value;
  }
  public resetRequestCert() {
    this._requestCert = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestCertInput() {
    return this._requestCert;
  }
}
export interface PackSourceInputSyslogInputSyslogSyslog1 {
  /**
  * Enable if RFC 3164-formatted messages have hyphens in the app name portion of the TAG section. If disabled, only alphanumeric characters and underscores are allowed. Ignored for RFC 5424-formatted messages. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#allow_non_standard_app_name PackSource#allow_non_standard_app_name}
  */
  readonly allowNonStandardAppName?: boolean | cdktf.IResolvable;
  /**
  * Direct connections to Destinations, and optionally via a Pipeline or a Pack
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#connections PackSource#connections}
  */
  readonly connections?: PackSourceInputSyslogInputSyslogSyslog1Connections[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#description PackSource#description}
  */
  readonly description?: string;
  /**
  * Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#disabled PackSource#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * When enabled, parses PROXY protocol headers during the TLS handshake. Disable if compatibility issues arise.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#enable_enhanced_proxy_header_parsing PackSource#enable_enhanced_proxy_header_parsing}
  */
  readonly enableEnhancedProxyHeaderParsing?: boolean | cdktf.IResolvable;
  /**
  * Load balance traffic across all Worker Processes. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#enable_load_balancing PackSource#enable_load_balancing}
  */
  readonly enableLoadBalancing?: boolean | cdktf.IResolvable;
  /**
  * Enable if the connection is proxied by a device that supports Proxy Protocol V1 or V2. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#enable_proxy_header PackSource#enable_proxy_header}
  */
  readonly enableProxyHeader?: boolean | cdktf.IResolvable;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#environment PackSource#environment}
  */
  readonly environment?: string;
  /**
  * Address to bind on. For IPv4 (all addresses), use the default '0.0.0.0'. For IPv6, enter '::' (all addresses) or specify an IP address. Default: "0.0.0.0"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#host PackSource#host}
  */
  readonly host?: string;
  /**
  * Unique ID for this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#id PackSource#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * Enable if we should infer the syslog framing of the incoming messages. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#infer_framing PackSource#infer_framing}
  */
  readonly inferFraming?: boolean | cdktf.IResolvable;
  /**
  * Regex matching IP addresses that are allowed to send data. Default: "/.* /"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#ip_whitelist_regex PackSource#ip_whitelist_regex}
   *
  * Note: The above comment contained a comment block ending sequence (* followed by /). We have introduced a space between to prevent syntax errors. Please ignore the space.
  */
  readonly ipWhitelistRegex?: string;
  /**
  * Wildcard list of fields to keep from source data; * = ALL (default). Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#keep_fields_list PackSource#keep_fields_list}
  */
  readonly keepFieldsList?: string[];
  /**
  * Maximum number of active connections allowed per Worker Process for TCP connections. Use 0 for unlimited. Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_active_cxn PackSource#max_active_cxn}
  */
  readonly maxActiveCxn?: number;
  /**
  * Maximum number of events to buffer when downstream is blocking. Only applies to UDP. Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_buffer_size PackSource#max_buffer_size}
  */
  readonly maxBufferSize?: number;
  /**
  * Fields to add to events from this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#metadata PackSource#metadata}
  */
  readonly metadata?: PackSourceInputSyslogInputSyslogSyslog1Metadata[] | cdktf.IResolvable;
  /**
  * Enable if incoming messages use octet counting per RFC 6587. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#octet_counting PackSource#octet_counting}
  */
  readonly octetCounting?: boolean | cdktf.IResolvable;
  /**
  * Pipeline to process data from this Source before sending it through the Routes
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pipeline PackSource#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pq PackSource#pq}
  */
  readonly pq?: PackSourceInputSyslogInputSyslogSyslog1Pq;
  /**
  * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers). Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pq_enabled PackSource#pq_enabled}
  */
  readonly pqEnabled?: boolean | cdktf.IResolvable;
  /**
  * Select whether to send data to Routes, or directly to Destinations. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#send_to_routes PackSource#send_to_routes}
  */
  readonly sendToRoutes?: boolean | cdktf.IResolvable;
  /**
  * Treat UDP packet data received as full syslog message. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#single_msg_udp_packets PackSource#single_msg_udp_packets}
  */
  readonly singleMsgUdpPackets?: boolean | cdktf.IResolvable;
  /**
  * How long the server will wait after initiating a closure for a client to close its end of the connection. If the client doesn't close the connection within this time, the server will forcefully terminate the socket to prevent resource leaks and ensure efficient connection cleanup and system stability. Leave at 0 for no inactive socket monitoring. Default: 30
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#socket_ending_max_wait PackSource#socket_ending_max_wait}
  */
  readonly socketEndingMaxWait?: number;
  /**
  * How long @{product} should wait before assuming that an inactive socket has timed out. After this time, the connection will be closed. Leave at 0 for no inactive socket monitoring. Default: 0
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#socket_idle_timeout PackSource#socket_idle_timeout}
  */
  readonly socketIdleTimeout?: number;
  /**
  * The maximum duration a socket can remain open, even if active. This helps manage resources and mitigate issues caused by TCP pinning. Set to 0 to disable. Default: 0
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#socket_max_lifespan PackSource#socket_max_lifespan}
  */
  readonly socketMaxLifespan?: number;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#streamtags PackSource#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Enable if we should infer octet counting only if the messages comply with RFC 5424. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#strictly_infer_octet_counting PackSource#strictly_infer_octet_counting}
  */
  readonly strictlyInferOctetCounting?: boolean | cdktf.IResolvable;
  /**
  * Enter TCP port number to listen on. Not required if listening on UDP.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#tcp_port PackSource#tcp_port}
  */
  readonly tcpPort?: number;
  /**
  * Timezone to assign to timestamps without timezone info. Default: "local"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#timestamp_timezone PackSource#timestamp_timezone}
  */
  readonly timestampTimezone?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#tls PackSource#tls}
  */
  readonly tls?: PackSourceInputSyslogInputSyslogSyslog1Tls;
  /**
  * must be "syslog"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#type PackSource#type}
  */
  readonly type: string;
  /**
  * Enter UDP port number to listen on. Not required if listening on TCP.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#udp_port PackSource#udp_port}
  */
  readonly udpPort: number;
  /**
  * Optionally, set the SO_RCVBUF socket option for the UDP socket. This value tells the operating system how many bytes can be buffered in the kernel before events are dropped. Leave blank to use the OS default. Caution: Increasing this value will affect OS memory utilization.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#udp_socket_rx_buf_size PackSource#udp_socket_rx_buf_size}
  */
  readonly udpSocketRxBufSize?: number;
}

export function packSourceInputSyslogInputSyslogSyslog1ToTerraform(struct?: PackSourceInputSyslogInputSyslogSyslog1 | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    allow_non_standard_app_name: cdktf.booleanToTerraform(struct!.allowNonStandardAppName),
    connections: cdktf.listMapper(packSourceInputSyslogInputSyslogSyslog1ConnectionsToTerraform, false)(struct!.connections),
    description: cdktf.stringToTerraform(struct!.description),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    enable_enhanced_proxy_header_parsing: cdktf.booleanToTerraform(struct!.enableEnhancedProxyHeaderParsing),
    enable_load_balancing: cdktf.booleanToTerraform(struct!.enableLoadBalancing),
    enable_proxy_header: cdktf.booleanToTerraform(struct!.enableProxyHeader),
    environment: cdktf.stringToTerraform(struct!.environment),
    host: cdktf.stringToTerraform(struct!.host),
    id: cdktf.stringToTerraform(struct!.id),
    infer_framing: cdktf.booleanToTerraform(struct!.inferFraming),
    ip_whitelist_regex: cdktf.stringToTerraform(struct!.ipWhitelistRegex),
    keep_fields_list: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.keepFieldsList),
    max_active_cxn: cdktf.numberToTerraform(struct!.maxActiveCxn),
    max_buffer_size: cdktf.numberToTerraform(struct!.maxBufferSize),
    metadata: cdktf.listMapper(packSourceInputSyslogInputSyslogSyslog1MetadataToTerraform, false)(struct!.metadata),
    octet_counting: cdktf.booleanToTerraform(struct!.octetCounting),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    pq: packSourceInputSyslogInputSyslogSyslog1PqToTerraform(struct!.pq),
    pq_enabled: cdktf.booleanToTerraform(struct!.pqEnabled),
    send_to_routes: cdktf.booleanToTerraform(struct!.sendToRoutes),
    single_msg_udp_packets: cdktf.booleanToTerraform(struct!.singleMsgUdpPackets),
    socket_ending_max_wait: cdktf.numberToTerraform(struct!.socketEndingMaxWait),
    socket_idle_timeout: cdktf.numberToTerraform(struct!.socketIdleTimeout),
    socket_max_lifespan: cdktf.numberToTerraform(struct!.socketMaxLifespan),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    strictly_infer_octet_counting: cdktf.booleanToTerraform(struct!.strictlyInferOctetCounting),
    tcp_port: cdktf.numberToTerraform(struct!.tcpPort),
    timestamp_timezone: cdktf.stringToTerraform(struct!.timestampTimezone),
    tls: packSourceInputSyslogInputSyslogSyslog1TlsToTerraform(struct!.tls),
    type: cdktf.stringToTerraform(struct!.type),
    udp_port: cdktf.numberToTerraform(struct!.udpPort),
    udp_socket_rx_buf_size: cdktf.numberToTerraform(struct!.udpSocketRxBufSize),
  }
}


export function packSourceInputSyslogInputSyslogSyslog1ToHclTerraform(struct?: PackSourceInputSyslogInputSyslogSyslog1 | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    allow_non_standard_app_name: {
      value: cdktf.booleanToHclTerraform(struct!.allowNonStandardAppName),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    connections: {
      value: cdktf.listMapperHcl(packSourceInputSyslogInputSyslogSyslog1ConnectionsToHclTerraform, false)(struct!.connections),
      isBlock: true,
      type: "list",
      storageClassType: "PackSourceInputSyslogInputSyslogSyslog1ConnectionsList",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    enable_enhanced_proxy_header_parsing: {
      value: cdktf.booleanToHclTerraform(struct!.enableEnhancedProxyHeaderParsing),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    enable_load_balancing: {
      value: cdktf.booleanToHclTerraform(struct!.enableLoadBalancing),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    enable_proxy_header: {
      value: cdktf.booleanToHclTerraform(struct!.enableProxyHeader),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    host: {
      value: cdktf.stringToHclTerraform(struct!.host),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    infer_framing: {
      value: cdktf.booleanToHclTerraform(struct!.inferFraming),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    ip_whitelist_regex: {
      value: cdktf.stringToHclTerraform(struct!.ipWhitelistRegex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    keep_fields_list: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.keepFieldsList),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    max_active_cxn: {
      value: cdktf.numberToHclTerraform(struct!.maxActiveCxn),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_buffer_size: {
      value: cdktf.numberToHclTerraform(struct!.maxBufferSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    metadata: {
      value: cdktf.listMapperHcl(packSourceInputSyslogInputSyslogSyslog1MetadataToHclTerraform, false)(struct!.metadata),
      isBlock: true,
      type: "list",
      storageClassType: "PackSourceInputSyslogInputSyslogSyslog1MetadataList",
    },
    octet_counting: {
      value: cdktf.booleanToHclTerraform(struct!.octetCounting),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq: {
      value: packSourceInputSyslogInputSyslogSyslog1PqToHclTerraform(struct!.pq),
      isBlock: true,
      type: "struct",
      storageClassType: "PackSourceInputSyslogInputSyslogSyslog1Pq",
    },
    pq_enabled: {
      value: cdktf.booleanToHclTerraform(struct!.pqEnabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    send_to_routes: {
      value: cdktf.booleanToHclTerraform(struct!.sendToRoutes),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    single_msg_udp_packets: {
      value: cdktf.booleanToHclTerraform(struct!.singleMsgUdpPackets),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    socket_ending_max_wait: {
      value: cdktf.numberToHclTerraform(struct!.socketEndingMaxWait),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    socket_idle_timeout: {
      value: cdktf.numberToHclTerraform(struct!.socketIdleTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    socket_max_lifespan: {
      value: cdktf.numberToHclTerraform(struct!.socketMaxLifespan),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    strictly_infer_octet_counting: {
      value: cdktf.booleanToHclTerraform(struct!.strictlyInferOctetCounting),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    tcp_port: {
      value: cdktf.numberToHclTerraform(struct!.tcpPort),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    timestamp_timezone: {
      value: cdktf.stringToHclTerraform(struct!.timestampTimezone),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tls: {
      value: packSourceInputSyslogInputSyslogSyslog1TlsToHclTerraform(struct!.tls),
      isBlock: true,
      type: "struct",
      storageClassType: "PackSourceInputSyslogInputSyslogSyslog1Tls",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    udp_port: {
      value: cdktf.numberToHclTerraform(struct!.udpPort),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    udp_socket_rx_buf_size: {
      value: cdktf.numberToHclTerraform(struct!.udpSocketRxBufSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputSyslogInputSyslogSyslog1OutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputSyslogInputSyslogSyslog1 | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._allowNonStandardAppName !== undefined) {
      hasAnyValues = true;
      internalValueResult.allowNonStandardAppName = this._allowNonStandardAppName;
    }
    if (this._connections?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.connections = this._connections?.internalValue;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._enableEnhancedProxyHeaderParsing !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableEnhancedProxyHeaderParsing = this._enableEnhancedProxyHeaderParsing;
    }
    if (this._enableLoadBalancing !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableLoadBalancing = this._enableLoadBalancing;
    }
    if (this._enableProxyHeader !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableProxyHeader = this._enableProxyHeader;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._host !== undefined) {
      hasAnyValues = true;
      internalValueResult.host = this._host;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._inferFraming !== undefined) {
      hasAnyValues = true;
      internalValueResult.inferFraming = this._inferFraming;
    }
    if (this._ipWhitelistRegex !== undefined) {
      hasAnyValues = true;
      internalValueResult.ipWhitelistRegex = this._ipWhitelistRegex;
    }
    if (this._keepFieldsList !== undefined) {
      hasAnyValues = true;
      internalValueResult.keepFieldsList = this._keepFieldsList;
    }
    if (this._maxActiveCxn !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxActiveCxn = this._maxActiveCxn;
    }
    if (this._maxBufferSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBufferSize = this._maxBufferSize;
    }
    if (this._metadata?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadata = this._metadata?.internalValue;
    }
    if (this._octetCounting !== undefined) {
      hasAnyValues = true;
      internalValueResult.octetCounting = this._octetCounting;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._pq?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pq = this._pq?.internalValue;
    }
    if (this._pqEnabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqEnabled = this._pqEnabled;
    }
    if (this._sendToRoutes !== undefined) {
      hasAnyValues = true;
      internalValueResult.sendToRoutes = this._sendToRoutes;
    }
    if (this._singleMsgUdpPackets !== undefined) {
      hasAnyValues = true;
      internalValueResult.singleMsgUdpPackets = this._singleMsgUdpPackets;
    }
    if (this._socketEndingMaxWait !== undefined) {
      hasAnyValues = true;
      internalValueResult.socketEndingMaxWait = this._socketEndingMaxWait;
    }
    if (this._socketIdleTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.socketIdleTimeout = this._socketIdleTimeout;
    }
    if (this._socketMaxLifespan !== undefined) {
      hasAnyValues = true;
      internalValueResult.socketMaxLifespan = this._socketMaxLifespan;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._strictlyInferOctetCounting !== undefined) {
      hasAnyValues = true;
      internalValueResult.strictlyInferOctetCounting = this._strictlyInferOctetCounting;
    }
    if (this._tcpPort !== undefined) {
      hasAnyValues = true;
      internalValueResult.tcpPort = this._tcpPort;
    }
    if (this._timestampTimezone !== undefined) {
      hasAnyValues = true;
      internalValueResult.timestampTimezone = this._timestampTimezone;
    }
    if (this._tls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tls = this._tls?.internalValue;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._udpPort !== undefined) {
      hasAnyValues = true;
      internalValueResult.udpPort = this._udpPort;
    }
    if (this._udpSocketRxBufSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.udpSocketRxBufSize = this._udpSocketRxBufSize;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputSyslogInputSyslogSyslog1 | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._allowNonStandardAppName = undefined;
      this._connections.internalValue = undefined;
      this._description = undefined;
      this._disabled = undefined;
      this._enableEnhancedProxyHeaderParsing = undefined;
      this._enableLoadBalancing = undefined;
      this._enableProxyHeader = undefined;
      this._environment = undefined;
      this._host = undefined;
      this._id = undefined;
      this._inferFraming = undefined;
      this._ipWhitelistRegex = undefined;
      this._keepFieldsList = undefined;
      this._maxActiveCxn = undefined;
      this._maxBufferSize = undefined;
      this._metadata.internalValue = undefined;
      this._octetCounting = undefined;
      this._pipeline = undefined;
      this._pq.internalValue = undefined;
      this._pqEnabled = undefined;
      this._sendToRoutes = undefined;
      this._singleMsgUdpPackets = undefined;
      this._socketEndingMaxWait = undefined;
      this._socketIdleTimeout = undefined;
      this._socketMaxLifespan = undefined;
      this._streamtags = undefined;
      this._strictlyInferOctetCounting = undefined;
      this._tcpPort = undefined;
      this._timestampTimezone = undefined;
      this._tls.internalValue = undefined;
      this._type = undefined;
      this._udpPort = undefined;
      this._udpSocketRxBufSize = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._allowNonStandardAppName = value.allowNonStandardAppName;
      this._connections.internalValue = value.connections;
      this._description = value.description;
      this._disabled = value.disabled;
      this._enableEnhancedProxyHeaderParsing = value.enableEnhancedProxyHeaderParsing;
      this._enableLoadBalancing = value.enableLoadBalancing;
      this._enableProxyHeader = value.enableProxyHeader;
      this._environment = value.environment;
      this._host = value.host;
      this._id = value.id;
      this._inferFraming = value.inferFraming;
      this._ipWhitelistRegex = value.ipWhitelistRegex;
      this._keepFieldsList = value.keepFieldsList;
      this._maxActiveCxn = value.maxActiveCxn;
      this._maxBufferSize = value.maxBufferSize;
      this._metadata.internalValue = value.metadata;
      this._octetCounting = value.octetCounting;
      this._pipeline = value.pipeline;
      this._pq.internalValue = value.pq;
      this._pqEnabled = value.pqEnabled;
      this._sendToRoutes = value.sendToRoutes;
      this._singleMsgUdpPackets = value.singleMsgUdpPackets;
      this._socketEndingMaxWait = value.socketEndingMaxWait;
      this._socketIdleTimeout = value.socketIdleTimeout;
      this._socketMaxLifespan = value.socketMaxLifespan;
      this._streamtags = value.streamtags;
      this._strictlyInferOctetCounting = value.strictlyInferOctetCounting;
      this._tcpPort = value.tcpPort;
      this._timestampTimezone = value.timestampTimezone;
      this._tls.internalValue = value.tls;
      this._type = value.type;
      this._udpPort = value.udpPort;
      this._udpSocketRxBufSize = value.udpSocketRxBufSize;
    }
  }

  // allow_non_standard_app_name - computed: true, optional: true, required: false
  private _allowNonStandardAppName?: boolean | cdktf.IResolvable; 
  public get allowNonStandardAppName() {
    return this.getBooleanAttribute('allow_non_standard_app_name');
  }
  public set allowNonStandardAppName(value: boolean | cdktf.IResolvable) {
    this._allowNonStandardAppName = value;
  }
  public resetAllowNonStandardAppName() {
    this._allowNonStandardAppName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get allowNonStandardAppNameInput() {
    return this._allowNonStandardAppName;
  }

  // connections - computed: false, optional: true, required: false
  private _connections = new PackSourceInputSyslogInputSyslogSyslog1ConnectionsList(this, "connections", false);
  public get connections() {
    return this._connections;
  }
  public putConnections(value: PackSourceInputSyslogInputSyslogSyslog1Connections[] | cdktf.IResolvable) {
    this._connections.internalValue = value;
  }
  public resetConnections() {
    this._connections.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectionsInput() {
    return this._connections.internalValue;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // enable_enhanced_proxy_header_parsing - computed: false, optional: true, required: false
  private _enableEnhancedProxyHeaderParsing?: boolean | cdktf.IResolvable; 
  public get enableEnhancedProxyHeaderParsing() {
    return this.getBooleanAttribute('enable_enhanced_proxy_header_parsing');
  }
  public set enableEnhancedProxyHeaderParsing(value: boolean | cdktf.IResolvable) {
    this._enableEnhancedProxyHeaderParsing = value;
  }
  public resetEnableEnhancedProxyHeaderParsing() {
    this._enableEnhancedProxyHeaderParsing = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableEnhancedProxyHeaderParsingInput() {
    return this._enableEnhancedProxyHeaderParsing;
  }

  // enable_load_balancing - computed: true, optional: true, required: false
  private _enableLoadBalancing?: boolean | cdktf.IResolvable; 
  public get enableLoadBalancing() {
    return this.getBooleanAttribute('enable_load_balancing');
  }
  public set enableLoadBalancing(value: boolean | cdktf.IResolvable) {
    this._enableLoadBalancing = value;
  }
  public resetEnableLoadBalancing() {
    this._enableLoadBalancing = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableLoadBalancingInput() {
    return this._enableLoadBalancing;
  }

  // enable_proxy_header - computed: true, optional: true, required: false
  private _enableProxyHeader?: boolean | cdktf.IResolvable; 
  public get enableProxyHeader() {
    return this.getBooleanAttribute('enable_proxy_header');
  }
  public set enableProxyHeader(value: boolean | cdktf.IResolvable) {
    this._enableProxyHeader = value;
  }
  public resetEnableProxyHeader() {
    this._enableProxyHeader = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableProxyHeaderInput() {
    return this._enableProxyHeader;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // host - computed: true, optional: true, required: false
  private _host?: string; 
  public get host() {
    return this.getStringAttribute('host');
  }
  public set host(value: string) {
    this._host = value;
  }
  public resetHost() {
    this._host = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostInput() {
    return this._host;
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // infer_framing - computed: true, optional: true, required: false
  private _inferFraming?: boolean | cdktf.IResolvable; 
  public get inferFraming() {
    return this.getBooleanAttribute('infer_framing');
  }
  public set inferFraming(value: boolean | cdktf.IResolvable) {
    this._inferFraming = value;
  }
  public resetInferFraming() {
    this._inferFraming = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get inferFramingInput() {
    return this._inferFraming;
  }

  // ip_whitelist_regex - computed: true, optional: true, required: false
  private _ipWhitelistRegex?: string; 
  public get ipWhitelistRegex() {
    return this.getStringAttribute('ip_whitelist_regex');
  }
  public set ipWhitelistRegex(value: string) {
    this._ipWhitelistRegex = value;
  }
  public resetIpWhitelistRegex() {
    this._ipWhitelistRegex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ipWhitelistRegexInput() {
    return this._ipWhitelistRegex;
  }

  // keep_fields_list - computed: true, optional: true, required: false
  private _keepFieldsList?: string[]; 
  public get keepFieldsList() {
    return this.getListAttribute('keep_fields_list');
  }
  public set keepFieldsList(value: string[]) {
    this._keepFieldsList = value;
  }
  public resetKeepFieldsList() {
    this._keepFieldsList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keepFieldsListInput() {
    return this._keepFieldsList;
  }

  // max_active_cxn - computed: true, optional: true, required: false
  private _maxActiveCxn?: number; 
  public get maxActiveCxn() {
    return this.getNumberAttribute('max_active_cxn');
  }
  public set maxActiveCxn(value: number) {
    this._maxActiveCxn = value;
  }
  public resetMaxActiveCxn() {
    this._maxActiveCxn = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxActiveCxnInput() {
    return this._maxActiveCxn;
  }

  // max_buffer_size - computed: true, optional: true, required: false
  private _maxBufferSize?: number; 
  public get maxBufferSize() {
    return this.getNumberAttribute('max_buffer_size');
  }
  public set maxBufferSize(value: number) {
    this._maxBufferSize = value;
  }
  public resetMaxBufferSize() {
    this._maxBufferSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBufferSizeInput() {
    return this._maxBufferSize;
  }

  // metadata - computed: false, optional: true, required: false
  private _metadata = new PackSourceInputSyslogInputSyslogSyslog1MetadataList(this, "metadata", false);
  public get metadata() {
    return this._metadata;
  }
  public putMetadata(value: PackSourceInputSyslogInputSyslogSyslog1Metadata[] | cdktf.IResolvable) {
    this._metadata.internalValue = value;
  }
  public resetMetadata() {
    this._metadata.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataInput() {
    return this._metadata.internalValue;
  }

  // octet_counting - computed: true, optional: true, required: false
  private _octetCounting?: boolean | cdktf.IResolvable; 
  public get octetCounting() {
    return this.getBooleanAttribute('octet_counting');
  }
  public set octetCounting(value: boolean | cdktf.IResolvable) {
    this._octetCounting = value;
  }
  public resetOctetCounting() {
    this._octetCounting = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get octetCountingInput() {
    return this._octetCounting;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // pq - computed: false, optional: true, required: false
  private _pq = new PackSourceInputSyslogInputSyslogSyslog1PqOutputReference(this, "pq");
  public get pq() {
    return this._pq;
  }
  public putPq(value: PackSourceInputSyslogInputSyslogSyslog1Pq) {
    this._pq.internalValue = value;
  }
  public resetPq() {
    this._pq.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqInput() {
    return this._pq.internalValue;
  }

  // pq_enabled - computed: true, optional: true, required: false
  private _pqEnabled?: boolean | cdktf.IResolvable; 
  public get pqEnabled() {
    return this.getBooleanAttribute('pq_enabled');
  }
  public set pqEnabled(value: boolean | cdktf.IResolvable) {
    this._pqEnabled = value;
  }
  public resetPqEnabled() {
    this._pqEnabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqEnabledInput() {
    return this._pqEnabled;
  }

  // send_to_routes - computed: true, optional: true, required: false
  private _sendToRoutes?: boolean | cdktf.IResolvable; 
  public get sendToRoutes() {
    return this.getBooleanAttribute('send_to_routes');
  }
  public set sendToRoutes(value: boolean | cdktf.IResolvable) {
    this._sendToRoutes = value;
  }
  public resetSendToRoutes() {
    this._sendToRoutes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sendToRoutesInput() {
    return this._sendToRoutes;
  }

  // single_msg_udp_packets - computed: true, optional: true, required: false
  private _singleMsgUdpPackets?: boolean | cdktf.IResolvable; 
  public get singleMsgUdpPackets() {
    return this.getBooleanAttribute('single_msg_udp_packets');
  }
  public set singleMsgUdpPackets(value: boolean | cdktf.IResolvable) {
    this._singleMsgUdpPackets = value;
  }
  public resetSingleMsgUdpPackets() {
    this._singleMsgUdpPackets = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get singleMsgUdpPacketsInput() {
    return this._singleMsgUdpPackets;
  }

  // socket_ending_max_wait - computed: true, optional: true, required: false
  private _socketEndingMaxWait?: number; 
  public get socketEndingMaxWait() {
    return this.getNumberAttribute('socket_ending_max_wait');
  }
  public set socketEndingMaxWait(value: number) {
    this._socketEndingMaxWait = value;
  }
  public resetSocketEndingMaxWait() {
    this._socketEndingMaxWait = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get socketEndingMaxWaitInput() {
    return this._socketEndingMaxWait;
  }

  // socket_idle_timeout - computed: true, optional: true, required: false
  private _socketIdleTimeout?: number; 
  public get socketIdleTimeout() {
    return this.getNumberAttribute('socket_idle_timeout');
  }
  public set socketIdleTimeout(value: number) {
    this._socketIdleTimeout = value;
  }
  public resetSocketIdleTimeout() {
    this._socketIdleTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get socketIdleTimeoutInput() {
    return this._socketIdleTimeout;
  }

  // socket_max_lifespan - computed: true, optional: true, required: false
  private _socketMaxLifespan?: number; 
  public get socketMaxLifespan() {
    return this.getNumberAttribute('socket_max_lifespan');
  }
  public set socketMaxLifespan(value: number) {
    this._socketMaxLifespan = value;
  }
  public resetSocketMaxLifespan() {
    this._socketMaxLifespan = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get socketMaxLifespanInput() {
    return this._socketMaxLifespan;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // strictly_infer_octet_counting - computed: true, optional: true, required: false
  private _strictlyInferOctetCounting?: boolean | cdktf.IResolvable; 
  public get strictlyInferOctetCounting() {
    return this.getBooleanAttribute('strictly_infer_octet_counting');
  }
  public set strictlyInferOctetCounting(value: boolean | cdktf.IResolvable) {
    this._strictlyInferOctetCounting = value;
  }
  public resetStrictlyInferOctetCounting() {
    this._strictlyInferOctetCounting = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get strictlyInferOctetCountingInput() {
    return this._strictlyInferOctetCounting;
  }

  // tcp_port - computed: false, optional: true, required: false
  private _tcpPort?: number; 
  public get tcpPort() {
    return this.getNumberAttribute('tcp_port');
  }
  public set tcpPort(value: number) {
    this._tcpPort = value;
  }
  public resetTcpPort() {
    this._tcpPort = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tcpPortInput() {
    return this._tcpPort;
  }

  // timestamp_timezone - computed: true, optional: true, required: false
  private _timestampTimezone?: string; 
  public get timestampTimezone() {
    return this.getStringAttribute('timestamp_timezone');
  }
  public set timestampTimezone(value: string) {
    this._timestampTimezone = value;
  }
  public resetTimestampTimezone() {
    this._timestampTimezone = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timestampTimezoneInput() {
    return this._timestampTimezone;
  }

  // tls - computed: false, optional: true, required: false
  private _tls = new PackSourceInputSyslogInputSyslogSyslog1TlsOutputReference(this, "tls");
  public get tls() {
    return this._tls;
  }
  public putTls(value: PackSourceInputSyslogInputSyslogSyslog1Tls) {
    this._tls.internalValue = value;
  }
  public resetTls() {
    this._tls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsInput() {
    return this._tls.internalValue;
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // udp_port - computed: false, optional: false, required: true
  private _udpPort?: number; 
  public get udpPort() {
    return this.getNumberAttribute('udp_port');
  }
  public set udpPort(value: number) {
    this._udpPort = value;
  }
  // Temporarily expose input value. Use with caution.
  public get udpPortInput() {
    return this._udpPort;
  }

  // udp_socket_rx_buf_size - computed: false, optional: true, required: false
  private _udpSocketRxBufSize?: number; 
  public get udpSocketRxBufSize() {
    return this.getNumberAttribute('udp_socket_rx_buf_size');
  }
  public set udpSocketRxBufSize(value: number) {
    this._udpSocketRxBufSize = value;
  }
  public resetUdpSocketRxBufSize() {
    this._udpSocketRxBufSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get udpSocketRxBufSizeInput() {
    return this._udpSocketRxBufSize;
  }
}
export interface PackSourceInputSyslogInputSyslogSyslog2Connections {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#output PackSource#output}
  */
  readonly output: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pipeline PackSource#pipeline}
  */
  readonly pipeline?: string;
}

export function packSourceInputSyslogInputSyslogSyslog2ConnectionsToTerraform(struct?: PackSourceInputSyslogInputSyslogSyslog2Connections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    output: cdktf.stringToTerraform(struct!.output),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
  }
}


export function packSourceInputSyslogInputSyslogSyslog2ConnectionsToHclTerraform(struct?: PackSourceInputSyslogInputSyslogSyslog2Connections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    output: {
      value: cdktf.stringToHclTerraform(struct!.output),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputSyslogInputSyslogSyslog2ConnectionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackSourceInputSyslogInputSyslogSyslog2Connections | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._output !== undefined) {
      hasAnyValues = true;
      internalValueResult.output = this._output;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputSyslogInputSyslogSyslog2Connections | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._output = undefined;
      this._pipeline = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._output = value.output;
      this._pipeline = value.pipeline;
    }
  }

  // output - computed: false, optional: false, required: true
  private _output?: string; 
  public get output() {
    return this.getStringAttribute('output');
  }
  public set output(value: string) {
    this._output = value;
  }
  // Temporarily expose input value. Use with caution.
  public get outputInput() {
    return this._output;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }
}

export class PackSourceInputSyslogInputSyslogSyslog2ConnectionsList extends cdktf.ComplexList {
  public internalValue? : PackSourceInputSyslogInputSyslogSyslog2Connections[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackSourceInputSyslogInputSyslogSyslog2ConnectionsOutputReference {
    return new PackSourceInputSyslogInputSyslogSyslog2ConnectionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackSourceInputSyslogInputSyslogSyslog2Metadata {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#name PackSource#name}
  */
  readonly name: string;
  /**
  * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#value PackSource#value}
  */
  readonly value: string;
}

export function packSourceInputSyslogInputSyslogSyslog2MetadataToTerraform(struct?: PackSourceInputSyslogInputSyslogSyslog2Metadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function packSourceInputSyslogInputSyslogSyslog2MetadataToHclTerraform(struct?: PackSourceInputSyslogInputSyslogSyslog2Metadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputSyslogInputSyslogSyslog2MetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackSourceInputSyslogInputSyslogSyslog2Metadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputSyslogInputSyslogSyslog2Metadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class PackSourceInputSyslogInputSyslogSyslog2MetadataList extends cdktf.ComplexList {
  public internalValue? : PackSourceInputSyslogInputSyslogSyslog2Metadata[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackSourceInputSyslogInputSyslogSyslog2MetadataOutputReference {
    return new PackSourceInputSyslogInputSyslogSyslog2MetadataOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackSourceInputSyslogInputSyslogSyslog2Pq {
  /**
  * The number of events to send downstream before committing that Stream has read them. Default: 42
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#commit_frequency PackSource#commit_frequency}
  */
  readonly commitFrequency?: number;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#compress PackSource#compress}
  */
  readonly compress?: string;
  /**
  * The maximum number of events to hold in memory before writing the events to disk. Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_buffer_size PackSource#max_buffer_size}
  */
  readonly maxBufferSize?: number;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc. Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_file_size PackSource#max_file_size}
  */
  readonly maxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_size PackSource#max_size}
  */
  readonly maxSize?: string;
  /**
  * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine. Default: "always"; must be one of ["smart", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#mode PackSource#mode}
  */
  readonly mode?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#path PackSource#path}
  */
  readonly path?: string;
}

export function packSourceInputSyslogInputSyslogSyslog2PqToTerraform(struct?: PackSourceInputSyslogInputSyslogSyslog2Pq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    commit_frequency: cdktf.numberToTerraform(struct!.commitFrequency),
    compress: cdktf.stringToTerraform(struct!.compress),
    max_buffer_size: cdktf.numberToTerraform(struct!.maxBufferSize),
    max_file_size: cdktf.stringToTerraform(struct!.maxFileSize),
    max_size: cdktf.stringToTerraform(struct!.maxSize),
    mode: cdktf.stringToTerraform(struct!.mode),
    path: cdktf.stringToTerraform(struct!.path),
  }
}


export function packSourceInputSyslogInputSyslogSyslog2PqToHclTerraform(struct?: PackSourceInputSyslogInputSyslogSyslog2Pq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    commit_frequency: {
      value: cdktf.numberToHclTerraform(struct!.commitFrequency),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    compress: {
      value: cdktf.stringToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_buffer_size: {
      value: cdktf.numberToHclTerraform(struct!.maxBufferSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.maxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_size: {
      value: cdktf.stringToHclTerraform(struct!.maxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputSyslogInputSyslogSyslog2PqOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputSyslogInputSyslogSyslog2Pq | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._commitFrequency !== undefined) {
      hasAnyValues = true;
      internalValueResult.commitFrequency = this._commitFrequency;
    }
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._maxBufferSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBufferSize = this._maxBufferSize;
    }
    if (this._maxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxFileSize = this._maxFileSize;
    }
    if (this._maxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxSize = this._maxSize;
    }
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputSyslogInputSyslogSyslog2Pq | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._commitFrequency = undefined;
      this._compress = undefined;
      this._maxBufferSize = undefined;
      this._maxFileSize = undefined;
      this._maxSize = undefined;
      this._mode = undefined;
      this._path = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._commitFrequency = value.commitFrequency;
      this._compress = value.compress;
      this._maxBufferSize = value.maxBufferSize;
      this._maxFileSize = value.maxFileSize;
      this._maxSize = value.maxSize;
      this._mode = value.mode;
      this._path = value.path;
    }
  }

  // commit_frequency - computed: true, optional: true, required: false
  private _commitFrequency?: number; 
  public get commitFrequency() {
    return this.getNumberAttribute('commit_frequency');
  }
  public set commitFrequency(value: number) {
    this._commitFrequency = value;
  }
  public resetCommitFrequency() {
    this._commitFrequency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commitFrequencyInput() {
    return this._commitFrequency;
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: string; 
  public get compress() {
    return this.getStringAttribute('compress');
  }
  public set compress(value: string) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // max_buffer_size - computed: true, optional: true, required: false
  private _maxBufferSize?: number; 
  public get maxBufferSize() {
    return this.getNumberAttribute('max_buffer_size');
  }
  public set maxBufferSize(value: number) {
    this._maxBufferSize = value;
  }
  public resetMaxBufferSize() {
    this._maxBufferSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBufferSizeInput() {
    return this._maxBufferSize;
  }

  // max_file_size - computed: true, optional: true, required: false
  private _maxFileSize?: string; 
  public get maxFileSize() {
    return this.getStringAttribute('max_file_size');
  }
  public set maxFileSize(value: string) {
    this._maxFileSize = value;
  }
  public resetMaxFileSize() {
    this._maxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxFileSizeInput() {
    return this._maxFileSize;
  }

  // max_size - computed: true, optional: true, required: false
  private _maxSize?: string; 
  public get maxSize() {
    return this.getStringAttribute('max_size');
  }
  public set maxSize(value: string) {
    this._maxSize = value;
  }
  public resetMaxSize() {
    this._maxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxSizeInput() {
    return this._maxSize;
  }

  // mode - computed: true, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // path - computed: true, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }
}
export interface PackSourceInputSyslogInputSyslogSyslog2Tls {
  /**
  * Path on server containing CA certificates to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#ca_path PackSource#ca_path}
  */
  readonly caPath?: string;
  /**
  * Path on server containing certificates to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#cert_path PackSource#cert_path}
  */
  readonly certPath?: string;
  /**
  * The name of the predefined certificate
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#certificate_name PackSource#certificate_name}
  */
  readonly certificateName?: string;
  /**
  * Parsed as JSON.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#common_name_regex PackSource#common_name_regex}
  */
  readonly commonNameRegex?: string;
  /**
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#disabled PackSource#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_version PackSource#max_version}
  */
  readonly maxVersion?: string;
  /**
  * must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#min_version PackSource#min_version}
  */
  readonly minVersion?: string;
  /**
  * Passphrase to use to decrypt private key
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#passphrase PackSource#passphrase}
  */
  readonly passphrase?: string;
  /**
  * Path on server containing the private key to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#priv_key_path PackSource#priv_key_path}
  */
  readonly privKeyPath?: string;
  /**
  * Parsed as JSON.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#reject_unauthorized PackSource#reject_unauthorized}
  */
  readonly rejectUnauthorized?: string;
  /**
  * Require clients to present their certificates. Used to perform client authentication using SSL certs. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#request_cert PackSource#request_cert}
  */
  readonly requestCert?: boolean | cdktf.IResolvable;
}

export function packSourceInputSyslogInputSyslogSyslog2TlsToTerraform(struct?: PackSourceInputSyslogInputSyslogSyslog2Tls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ca_path: cdktf.stringToTerraform(struct!.caPath),
    cert_path: cdktf.stringToTerraform(struct!.certPath),
    certificate_name: cdktf.stringToTerraform(struct!.certificateName),
    common_name_regex: cdktf.stringToTerraform(struct!.commonNameRegex),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    max_version: cdktf.stringToTerraform(struct!.maxVersion),
    min_version: cdktf.stringToTerraform(struct!.minVersion),
    passphrase: cdktf.stringToTerraform(struct!.passphrase),
    priv_key_path: cdktf.stringToTerraform(struct!.privKeyPath),
    reject_unauthorized: cdktf.stringToTerraform(struct!.rejectUnauthorized),
    request_cert: cdktf.booleanToTerraform(struct!.requestCert),
  }
}


export function packSourceInputSyslogInputSyslogSyslog2TlsToHclTerraform(struct?: PackSourceInputSyslogInputSyslogSyslog2Tls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ca_path: {
      value: cdktf.stringToHclTerraform(struct!.caPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    cert_path: {
      value: cdktf.stringToHclTerraform(struct!.certPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    certificate_name: {
      value: cdktf.stringToHclTerraform(struct!.certificateName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    common_name_regex: {
      value: cdktf.stringToHclTerraform(struct!.commonNameRegex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    max_version: {
      value: cdktf.stringToHclTerraform(struct!.maxVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    min_version: {
      value: cdktf.stringToHclTerraform(struct!.minVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    passphrase: {
      value: cdktf.stringToHclTerraform(struct!.passphrase),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    priv_key_path: {
      value: cdktf.stringToHclTerraform(struct!.privKeyPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reject_unauthorized: {
      value: cdktf.stringToHclTerraform(struct!.rejectUnauthorized),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    request_cert: {
      value: cdktf.booleanToHclTerraform(struct!.requestCert),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputSyslogInputSyslogSyslog2TlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputSyslogInputSyslogSyslog2Tls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._caPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.caPath = this._caPath;
    }
    if (this._certPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.certPath = this._certPath;
    }
    if (this._certificateName !== undefined) {
      hasAnyValues = true;
      internalValueResult.certificateName = this._certificateName;
    }
    if (this._commonNameRegex !== undefined) {
      hasAnyValues = true;
      internalValueResult.commonNameRegex = this._commonNameRegex;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._maxVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxVersion = this._maxVersion;
    }
    if (this._minVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.minVersion = this._minVersion;
    }
    if (this._passphrase !== undefined) {
      hasAnyValues = true;
      internalValueResult.passphrase = this._passphrase;
    }
    if (this._privKeyPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.privKeyPath = this._privKeyPath;
    }
    if (this._rejectUnauthorized !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectUnauthorized = this._rejectUnauthorized;
    }
    if (this._requestCert !== undefined) {
      hasAnyValues = true;
      internalValueResult.requestCert = this._requestCert;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputSyslogInputSyslogSyslog2Tls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._caPath = undefined;
      this._certPath = undefined;
      this._certificateName = undefined;
      this._commonNameRegex = undefined;
      this._disabled = undefined;
      this._maxVersion = undefined;
      this._minVersion = undefined;
      this._passphrase = undefined;
      this._privKeyPath = undefined;
      this._rejectUnauthorized = undefined;
      this._requestCert = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._caPath = value.caPath;
      this._certPath = value.certPath;
      this._certificateName = value.certificateName;
      this._commonNameRegex = value.commonNameRegex;
      this._disabled = value.disabled;
      this._maxVersion = value.maxVersion;
      this._minVersion = value.minVersion;
      this._passphrase = value.passphrase;
      this._privKeyPath = value.privKeyPath;
      this._rejectUnauthorized = value.rejectUnauthorized;
      this._requestCert = value.requestCert;
    }
  }

  // ca_path - computed: false, optional: true, required: false
  private _caPath?: string; 
  public get caPath() {
    return this.getStringAttribute('ca_path');
  }
  public set caPath(value: string) {
    this._caPath = value;
  }
  public resetCaPath() {
    this._caPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get caPathInput() {
    return this._caPath;
  }

  // cert_path - computed: false, optional: true, required: false
  private _certPath?: string; 
  public get certPath() {
    return this.getStringAttribute('cert_path');
  }
  public set certPath(value: string) {
    this._certPath = value;
  }
  public resetCertPath() {
    this._certPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certPathInput() {
    return this._certPath;
  }

  // certificate_name - computed: false, optional: true, required: false
  private _certificateName?: string; 
  public get certificateName() {
    return this.getStringAttribute('certificate_name');
  }
  public set certificateName(value: string) {
    this._certificateName = value;
  }
  public resetCertificateName() {
    this._certificateName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certificateNameInput() {
    return this._certificateName;
  }

  // common_name_regex - computed: false, optional: true, required: false
  private _commonNameRegex?: string; 
  public get commonNameRegex() {
    return this.getStringAttribute('common_name_regex');
  }
  public set commonNameRegex(value: string) {
    this._commonNameRegex = value;
  }
  public resetCommonNameRegex() {
    this._commonNameRegex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commonNameRegexInput() {
    return this._commonNameRegex;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // max_version - computed: false, optional: true, required: false
  private _maxVersion?: string; 
  public get maxVersion() {
    return this.getStringAttribute('max_version');
  }
  public set maxVersion(value: string) {
    this._maxVersion = value;
  }
  public resetMaxVersion() {
    this._maxVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxVersionInput() {
    return this._maxVersion;
  }

  // min_version - computed: false, optional: true, required: false
  private _minVersion?: string; 
  public get minVersion() {
    return this.getStringAttribute('min_version');
  }
  public set minVersion(value: string) {
    this._minVersion = value;
  }
  public resetMinVersion() {
    this._minVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get minVersionInput() {
    return this._minVersion;
  }

  // passphrase - computed: false, optional: true, required: false
  private _passphrase?: string; 
  public get passphrase() {
    return this.getStringAttribute('passphrase');
  }
  public set passphrase(value: string) {
    this._passphrase = value;
  }
  public resetPassphrase() {
    this._passphrase = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passphraseInput() {
    return this._passphrase;
  }

  // priv_key_path - computed: false, optional: true, required: false
  private _privKeyPath?: string; 
  public get privKeyPath() {
    return this.getStringAttribute('priv_key_path');
  }
  public set privKeyPath(value: string) {
    this._privKeyPath = value;
  }
  public resetPrivKeyPath() {
    this._privKeyPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get privKeyPathInput() {
    return this._privKeyPath;
  }

  // reject_unauthorized - computed: false, optional: true, required: false
  private _rejectUnauthorized?: string; 
  public get rejectUnauthorized() {
    return this.getStringAttribute('reject_unauthorized');
  }
  public set rejectUnauthorized(value: string) {
    this._rejectUnauthorized = value;
  }
  public resetRejectUnauthorized() {
    this._rejectUnauthorized = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectUnauthorizedInput() {
    return this._rejectUnauthorized;
  }

  // request_cert - computed: true, optional: true, required: false
  private _requestCert?: boolean | cdktf.IResolvable; 
  public get requestCert() {
    return this.getBooleanAttribute('request_cert');
  }
  public set requestCert(value: boolean | cdktf.IResolvable) {
    this._requestCert = value;
  }
  public resetRequestCert() {
    this._requestCert = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestCertInput() {
    return this._requestCert;
  }
}
export interface PackSourceInputSyslogInputSyslogSyslog2 {
  /**
  * Enable if RFC 3164-formatted messages have hyphens in the app name portion of the TAG section. If disabled, only alphanumeric characters and underscores are allowed. Ignored for RFC 5424-formatted messages. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#allow_non_standard_app_name PackSource#allow_non_standard_app_name}
  */
  readonly allowNonStandardAppName?: boolean | cdktf.IResolvable;
  /**
  * Direct connections to Destinations, and optionally via a Pipeline or a Pack
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#connections PackSource#connections}
  */
  readonly connections?: PackSourceInputSyslogInputSyslogSyslog2Connections[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#description PackSource#description}
  */
  readonly description?: string;
  /**
  * Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#disabled PackSource#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * When enabled, parses PROXY protocol headers during the TLS handshake. Disable if compatibility issues arise.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#enable_enhanced_proxy_header_parsing PackSource#enable_enhanced_proxy_header_parsing}
  */
  readonly enableEnhancedProxyHeaderParsing?: boolean | cdktf.IResolvable;
  /**
  * Load balance traffic across all Worker Processes. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#enable_load_balancing PackSource#enable_load_balancing}
  */
  readonly enableLoadBalancing?: boolean | cdktf.IResolvable;
  /**
  * Enable if the connection is proxied by a device that supports Proxy Protocol V1 or V2. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#enable_proxy_header PackSource#enable_proxy_header}
  */
  readonly enableProxyHeader?: boolean | cdktf.IResolvable;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#environment PackSource#environment}
  */
  readonly environment?: string;
  /**
  * Address to bind on. For IPv4 (all addresses), use the default '0.0.0.0'. For IPv6, enter '::' (all addresses) or specify an IP address. Default: "0.0.0.0"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#host PackSource#host}
  */
  readonly host?: string;
  /**
  * Unique ID for this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#id PackSource#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * Enable if we should infer the syslog framing of the incoming messages. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#infer_framing PackSource#infer_framing}
  */
  readonly inferFraming?: boolean | cdktf.IResolvable;
  /**
  * Regex matching IP addresses that are allowed to send data. Default: "/.* /"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#ip_whitelist_regex PackSource#ip_whitelist_regex}
   *
  * Note: The above comment contained a comment block ending sequence (* followed by /). We have introduced a space between to prevent syntax errors. Please ignore the space.
  */
  readonly ipWhitelistRegex?: string;
  /**
  * Wildcard list of fields to keep from source data; * = ALL (default). Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#keep_fields_list PackSource#keep_fields_list}
  */
  readonly keepFieldsList?: string[];
  /**
  * Maximum number of active connections allowed per Worker Process for TCP connections. Use 0 for unlimited. Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_active_cxn PackSource#max_active_cxn}
  */
  readonly maxActiveCxn?: number;
  /**
  * Maximum number of events to buffer when downstream is blocking. Only applies to UDP. Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_buffer_size PackSource#max_buffer_size}
  */
  readonly maxBufferSize?: number;
  /**
  * Fields to add to events from this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#metadata PackSource#metadata}
  */
  readonly metadata?: PackSourceInputSyslogInputSyslogSyslog2Metadata[] | cdktf.IResolvable;
  /**
  * Enable if incoming messages use octet counting per RFC 6587. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#octet_counting PackSource#octet_counting}
  */
  readonly octetCounting?: boolean | cdktf.IResolvable;
  /**
  * Pipeline to process data from this Source before sending it through the Routes
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pipeline PackSource#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pq PackSource#pq}
  */
  readonly pq?: PackSourceInputSyslogInputSyslogSyslog2Pq;
  /**
  * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers). Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pq_enabled PackSource#pq_enabled}
  */
  readonly pqEnabled?: boolean | cdktf.IResolvable;
  /**
  * Select whether to send data to Routes, or directly to Destinations. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#send_to_routes PackSource#send_to_routes}
  */
  readonly sendToRoutes?: boolean | cdktf.IResolvable;
  /**
  * Treat UDP packet data received as full syslog message. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#single_msg_udp_packets PackSource#single_msg_udp_packets}
  */
  readonly singleMsgUdpPackets?: boolean | cdktf.IResolvable;
  /**
  * How long the server will wait after initiating a closure for a client to close its end of the connection. If the client doesn't close the connection within this time, the server will forcefully terminate the socket to prevent resource leaks and ensure efficient connection cleanup and system stability. Leave at 0 for no inactive socket monitoring. Default: 30
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#socket_ending_max_wait PackSource#socket_ending_max_wait}
  */
  readonly socketEndingMaxWait?: number;
  /**
  * How long @{product} should wait before assuming that an inactive socket has timed out. After this time, the connection will be closed. Leave at 0 for no inactive socket monitoring. Default: 0
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#socket_idle_timeout PackSource#socket_idle_timeout}
  */
  readonly socketIdleTimeout?: number;
  /**
  * The maximum duration a socket can remain open, even if active. This helps manage resources and mitigate issues caused by TCP pinning. Set to 0 to disable. Default: 0
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#socket_max_lifespan PackSource#socket_max_lifespan}
  */
  readonly socketMaxLifespan?: number;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#streamtags PackSource#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Enable if we should infer octet counting only if the messages comply with RFC 5424. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#strictly_infer_octet_counting PackSource#strictly_infer_octet_counting}
  */
  readonly strictlyInferOctetCounting?: boolean | cdktf.IResolvable;
  /**
  * Enter TCP port number to listen on. Not required if listening on UDP.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#tcp_port PackSource#tcp_port}
  */
  readonly tcpPort: number;
  /**
  * Timezone to assign to timestamps without timezone info. Default: "local"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#timestamp_timezone PackSource#timestamp_timezone}
  */
  readonly timestampTimezone?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#tls PackSource#tls}
  */
  readonly tls?: PackSourceInputSyslogInputSyslogSyslog2Tls;
  /**
  * must be "syslog"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#type PackSource#type}
  */
  readonly type: string;
  /**
  * Enter UDP port number to listen on. Not required if listening on TCP.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#udp_port PackSource#udp_port}
  */
  readonly udpPort?: number;
  /**
  * Optionally, set the SO_RCVBUF socket option for the UDP socket. This value tells the operating system how many bytes can be buffered in the kernel before events are dropped. Leave blank to use the OS default. Caution: Increasing this value will affect OS memory utilization.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#udp_socket_rx_buf_size PackSource#udp_socket_rx_buf_size}
  */
  readonly udpSocketRxBufSize?: number;
}

export function packSourceInputSyslogInputSyslogSyslog2ToTerraform(struct?: PackSourceInputSyslogInputSyslogSyslog2 | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    allow_non_standard_app_name: cdktf.booleanToTerraform(struct!.allowNonStandardAppName),
    connections: cdktf.listMapper(packSourceInputSyslogInputSyslogSyslog2ConnectionsToTerraform, false)(struct!.connections),
    description: cdktf.stringToTerraform(struct!.description),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    enable_enhanced_proxy_header_parsing: cdktf.booleanToTerraform(struct!.enableEnhancedProxyHeaderParsing),
    enable_load_balancing: cdktf.booleanToTerraform(struct!.enableLoadBalancing),
    enable_proxy_header: cdktf.booleanToTerraform(struct!.enableProxyHeader),
    environment: cdktf.stringToTerraform(struct!.environment),
    host: cdktf.stringToTerraform(struct!.host),
    id: cdktf.stringToTerraform(struct!.id),
    infer_framing: cdktf.booleanToTerraform(struct!.inferFraming),
    ip_whitelist_regex: cdktf.stringToTerraform(struct!.ipWhitelistRegex),
    keep_fields_list: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.keepFieldsList),
    max_active_cxn: cdktf.numberToTerraform(struct!.maxActiveCxn),
    max_buffer_size: cdktf.numberToTerraform(struct!.maxBufferSize),
    metadata: cdktf.listMapper(packSourceInputSyslogInputSyslogSyslog2MetadataToTerraform, false)(struct!.metadata),
    octet_counting: cdktf.booleanToTerraform(struct!.octetCounting),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    pq: packSourceInputSyslogInputSyslogSyslog2PqToTerraform(struct!.pq),
    pq_enabled: cdktf.booleanToTerraform(struct!.pqEnabled),
    send_to_routes: cdktf.booleanToTerraform(struct!.sendToRoutes),
    single_msg_udp_packets: cdktf.booleanToTerraform(struct!.singleMsgUdpPackets),
    socket_ending_max_wait: cdktf.numberToTerraform(struct!.socketEndingMaxWait),
    socket_idle_timeout: cdktf.numberToTerraform(struct!.socketIdleTimeout),
    socket_max_lifespan: cdktf.numberToTerraform(struct!.socketMaxLifespan),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    strictly_infer_octet_counting: cdktf.booleanToTerraform(struct!.strictlyInferOctetCounting),
    tcp_port: cdktf.numberToTerraform(struct!.tcpPort),
    timestamp_timezone: cdktf.stringToTerraform(struct!.timestampTimezone),
    tls: packSourceInputSyslogInputSyslogSyslog2TlsToTerraform(struct!.tls),
    type: cdktf.stringToTerraform(struct!.type),
    udp_port: cdktf.numberToTerraform(struct!.udpPort),
    udp_socket_rx_buf_size: cdktf.numberToTerraform(struct!.udpSocketRxBufSize),
  }
}


export function packSourceInputSyslogInputSyslogSyslog2ToHclTerraform(struct?: PackSourceInputSyslogInputSyslogSyslog2 | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    allow_non_standard_app_name: {
      value: cdktf.booleanToHclTerraform(struct!.allowNonStandardAppName),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    connections: {
      value: cdktf.listMapperHcl(packSourceInputSyslogInputSyslogSyslog2ConnectionsToHclTerraform, false)(struct!.connections),
      isBlock: true,
      type: "list",
      storageClassType: "PackSourceInputSyslogInputSyslogSyslog2ConnectionsList",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    enable_enhanced_proxy_header_parsing: {
      value: cdktf.booleanToHclTerraform(struct!.enableEnhancedProxyHeaderParsing),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    enable_load_balancing: {
      value: cdktf.booleanToHclTerraform(struct!.enableLoadBalancing),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    enable_proxy_header: {
      value: cdktf.booleanToHclTerraform(struct!.enableProxyHeader),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    host: {
      value: cdktf.stringToHclTerraform(struct!.host),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    infer_framing: {
      value: cdktf.booleanToHclTerraform(struct!.inferFraming),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    ip_whitelist_regex: {
      value: cdktf.stringToHclTerraform(struct!.ipWhitelistRegex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    keep_fields_list: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.keepFieldsList),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    max_active_cxn: {
      value: cdktf.numberToHclTerraform(struct!.maxActiveCxn),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_buffer_size: {
      value: cdktf.numberToHclTerraform(struct!.maxBufferSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    metadata: {
      value: cdktf.listMapperHcl(packSourceInputSyslogInputSyslogSyslog2MetadataToHclTerraform, false)(struct!.metadata),
      isBlock: true,
      type: "list",
      storageClassType: "PackSourceInputSyslogInputSyslogSyslog2MetadataList",
    },
    octet_counting: {
      value: cdktf.booleanToHclTerraform(struct!.octetCounting),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq: {
      value: packSourceInputSyslogInputSyslogSyslog2PqToHclTerraform(struct!.pq),
      isBlock: true,
      type: "struct",
      storageClassType: "PackSourceInputSyslogInputSyslogSyslog2Pq",
    },
    pq_enabled: {
      value: cdktf.booleanToHclTerraform(struct!.pqEnabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    send_to_routes: {
      value: cdktf.booleanToHclTerraform(struct!.sendToRoutes),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    single_msg_udp_packets: {
      value: cdktf.booleanToHclTerraform(struct!.singleMsgUdpPackets),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    socket_ending_max_wait: {
      value: cdktf.numberToHclTerraform(struct!.socketEndingMaxWait),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    socket_idle_timeout: {
      value: cdktf.numberToHclTerraform(struct!.socketIdleTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    socket_max_lifespan: {
      value: cdktf.numberToHclTerraform(struct!.socketMaxLifespan),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    strictly_infer_octet_counting: {
      value: cdktf.booleanToHclTerraform(struct!.strictlyInferOctetCounting),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    tcp_port: {
      value: cdktf.numberToHclTerraform(struct!.tcpPort),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    timestamp_timezone: {
      value: cdktf.stringToHclTerraform(struct!.timestampTimezone),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tls: {
      value: packSourceInputSyslogInputSyslogSyslog2TlsToHclTerraform(struct!.tls),
      isBlock: true,
      type: "struct",
      storageClassType: "PackSourceInputSyslogInputSyslogSyslog2Tls",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    udp_port: {
      value: cdktf.numberToHclTerraform(struct!.udpPort),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    udp_socket_rx_buf_size: {
      value: cdktf.numberToHclTerraform(struct!.udpSocketRxBufSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputSyslogInputSyslogSyslog2OutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputSyslogInputSyslogSyslog2 | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._allowNonStandardAppName !== undefined) {
      hasAnyValues = true;
      internalValueResult.allowNonStandardAppName = this._allowNonStandardAppName;
    }
    if (this._connections?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.connections = this._connections?.internalValue;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._enableEnhancedProxyHeaderParsing !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableEnhancedProxyHeaderParsing = this._enableEnhancedProxyHeaderParsing;
    }
    if (this._enableLoadBalancing !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableLoadBalancing = this._enableLoadBalancing;
    }
    if (this._enableProxyHeader !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableProxyHeader = this._enableProxyHeader;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._host !== undefined) {
      hasAnyValues = true;
      internalValueResult.host = this._host;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._inferFraming !== undefined) {
      hasAnyValues = true;
      internalValueResult.inferFraming = this._inferFraming;
    }
    if (this._ipWhitelistRegex !== undefined) {
      hasAnyValues = true;
      internalValueResult.ipWhitelistRegex = this._ipWhitelistRegex;
    }
    if (this._keepFieldsList !== undefined) {
      hasAnyValues = true;
      internalValueResult.keepFieldsList = this._keepFieldsList;
    }
    if (this._maxActiveCxn !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxActiveCxn = this._maxActiveCxn;
    }
    if (this._maxBufferSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBufferSize = this._maxBufferSize;
    }
    if (this._metadata?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadata = this._metadata?.internalValue;
    }
    if (this._octetCounting !== undefined) {
      hasAnyValues = true;
      internalValueResult.octetCounting = this._octetCounting;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._pq?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pq = this._pq?.internalValue;
    }
    if (this._pqEnabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqEnabled = this._pqEnabled;
    }
    if (this._sendToRoutes !== undefined) {
      hasAnyValues = true;
      internalValueResult.sendToRoutes = this._sendToRoutes;
    }
    if (this._singleMsgUdpPackets !== undefined) {
      hasAnyValues = true;
      internalValueResult.singleMsgUdpPackets = this._singleMsgUdpPackets;
    }
    if (this._socketEndingMaxWait !== undefined) {
      hasAnyValues = true;
      internalValueResult.socketEndingMaxWait = this._socketEndingMaxWait;
    }
    if (this._socketIdleTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.socketIdleTimeout = this._socketIdleTimeout;
    }
    if (this._socketMaxLifespan !== undefined) {
      hasAnyValues = true;
      internalValueResult.socketMaxLifespan = this._socketMaxLifespan;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._strictlyInferOctetCounting !== undefined) {
      hasAnyValues = true;
      internalValueResult.strictlyInferOctetCounting = this._strictlyInferOctetCounting;
    }
    if (this._tcpPort !== undefined) {
      hasAnyValues = true;
      internalValueResult.tcpPort = this._tcpPort;
    }
    if (this._timestampTimezone !== undefined) {
      hasAnyValues = true;
      internalValueResult.timestampTimezone = this._timestampTimezone;
    }
    if (this._tls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tls = this._tls?.internalValue;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._udpPort !== undefined) {
      hasAnyValues = true;
      internalValueResult.udpPort = this._udpPort;
    }
    if (this._udpSocketRxBufSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.udpSocketRxBufSize = this._udpSocketRxBufSize;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputSyslogInputSyslogSyslog2 | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._allowNonStandardAppName = undefined;
      this._connections.internalValue = undefined;
      this._description = undefined;
      this._disabled = undefined;
      this._enableEnhancedProxyHeaderParsing = undefined;
      this._enableLoadBalancing = undefined;
      this._enableProxyHeader = undefined;
      this._environment = undefined;
      this._host = undefined;
      this._id = undefined;
      this._inferFraming = undefined;
      this._ipWhitelistRegex = undefined;
      this._keepFieldsList = undefined;
      this._maxActiveCxn = undefined;
      this._maxBufferSize = undefined;
      this._metadata.internalValue = undefined;
      this._octetCounting = undefined;
      this._pipeline = undefined;
      this._pq.internalValue = undefined;
      this._pqEnabled = undefined;
      this._sendToRoutes = undefined;
      this._singleMsgUdpPackets = undefined;
      this._socketEndingMaxWait = undefined;
      this._socketIdleTimeout = undefined;
      this._socketMaxLifespan = undefined;
      this._streamtags = undefined;
      this._strictlyInferOctetCounting = undefined;
      this._tcpPort = undefined;
      this._timestampTimezone = undefined;
      this._tls.internalValue = undefined;
      this._type = undefined;
      this._udpPort = undefined;
      this._udpSocketRxBufSize = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._allowNonStandardAppName = value.allowNonStandardAppName;
      this._connections.internalValue = value.connections;
      this._description = value.description;
      this._disabled = value.disabled;
      this._enableEnhancedProxyHeaderParsing = value.enableEnhancedProxyHeaderParsing;
      this._enableLoadBalancing = value.enableLoadBalancing;
      this._enableProxyHeader = value.enableProxyHeader;
      this._environment = value.environment;
      this._host = value.host;
      this._id = value.id;
      this._inferFraming = value.inferFraming;
      this._ipWhitelistRegex = value.ipWhitelistRegex;
      this._keepFieldsList = value.keepFieldsList;
      this._maxActiveCxn = value.maxActiveCxn;
      this._maxBufferSize = value.maxBufferSize;
      this._metadata.internalValue = value.metadata;
      this._octetCounting = value.octetCounting;
      this._pipeline = value.pipeline;
      this._pq.internalValue = value.pq;
      this._pqEnabled = value.pqEnabled;
      this._sendToRoutes = value.sendToRoutes;
      this._singleMsgUdpPackets = value.singleMsgUdpPackets;
      this._socketEndingMaxWait = value.socketEndingMaxWait;
      this._socketIdleTimeout = value.socketIdleTimeout;
      this._socketMaxLifespan = value.socketMaxLifespan;
      this._streamtags = value.streamtags;
      this._strictlyInferOctetCounting = value.strictlyInferOctetCounting;
      this._tcpPort = value.tcpPort;
      this._timestampTimezone = value.timestampTimezone;
      this._tls.internalValue = value.tls;
      this._type = value.type;
      this._udpPort = value.udpPort;
      this._udpSocketRxBufSize = value.udpSocketRxBufSize;
    }
  }

  // allow_non_standard_app_name - computed: true, optional: true, required: false
  private _allowNonStandardAppName?: boolean | cdktf.IResolvable; 
  public get allowNonStandardAppName() {
    return this.getBooleanAttribute('allow_non_standard_app_name');
  }
  public set allowNonStandardAppName(value: boolean | cdktf.IResolvable) {
    this._allowNonStandardAppName = value;
  }
  public resetAllowNonStandardAppName() {
    this._allowNonStandardAppName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get allowNonStandardAppNameInput() {
    return this._allowNonStandardAppName;
  }

  // connections - computed: false, optional: true, required: false
  private _connections = new PackSourceInputSyslogInputSyslogSyslog2ConnectionsList(this, "connections", false);
  public get connections() {
    return this._connections;
  }
  public putConnections(value: PackSourceInputSyslogInputSyslogSyslog2Connections[] | cdktf.IResolvable) {
    this._connections.internalValue = value;
  }
  public resetConnections() {
    this._connections.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectionsInput() {
    return this._connections.internalValue;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // enable_enhanced_proxy_header_parsing - computed: false, optional: true, required: false
  private _enableEnhancedProxyHeaderParsing?: boolean | cdktf.IResolvable; 
  public get enableEnhancedProxyHeaderParsing() {
    return this.getBooleanAttribute('enable_enhanced_proxy_header_parsing');
  }
  public set enableEnhancedProxyHeaderParsing(value: boolean | cdktf.IResolvable) {
    this._enableEnhancedProxyHeaderParsing = value;
  }
  public resetEnableEnhancedProxyHeaderParsing() {
    this._enableEnhancedProxyHeaderParsing = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableEnhancedProxyHeaderParsingInput() {
    return this._enableEnhancedProxyHeaderParsing;
  }

  // enable_load_balancing - computed: true, optional: true, required: false
  private _enableLoadBalancing?: boolean | cdktf.IResolvable; 
  public get enableLoadBalancing() {
    return this.getBooleanAttribute('enable_load_balancing');
  }
  public set enableLoadBalancing(value: boolean | cdktf.IResolvable) {
    this._enableLoadBalancing = value;
  }
  public resetEnableLoadBalancing() {
    this._enableLoadBalancing = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableLoadBalancingInput() {
    return this._enableLoadBalancing;
  }

  // enable_proxy_header - computed: true, optional: true, required: false
  private _enableProxyHeader?: boolean | cdktf.IResolvable; 
  public get enableProxyHeader() {
    return this.getBooleanAttribute('enable_proxy_header');
  }
  public set enableProxyHeader(value: boolean | cdktf.IResolvable) {
    this._enableProxyHeader = value;
  }
  public resetEnableProxyHeader() {
    this._enableProxyHeader = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableProxyHeaderInput() {
    return this._enableProxyHeader;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // host - computed: true, optional: true, required: false
  private _host?: string; 
  public get host() {
    return this.getStringAttribute('host');
  }
  public set host(value: string) {
    this._host = value;
  }
  public resetHost() {
    this._host = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostInput() {
    return this._host;
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // infer_framing - computed: true, optional: true, required: false
  private _inferFraming?: boolean | cdktf.IResolvable; 
  public get inferFraming() {
    return this.getBooleanAttribute('infer_framing');
  }
  public set inferFraming(value: boolean | cdktf.IResolvable) {
    this._inferFraming = value;
  }
  public resetInferFraming() {
    this._inferFraming = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get inferFramingInput() {
    return this._inferFraming;
  }

  // ip_whitelist_regex - computed: true, optional: true, required: false
  private _ipWhitelistRegex?: string; 
  public get ipWhitelistRegex() {
    return this.getStringAttribute('ip_whitelist_regex');
  }
  public set ipWhitelistRegex(value: string) {
    this._ipWhitelistRegex = value;
  }
  public resetIpWhitelistRegex() {
    this._ipWhitelistRegex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ipWhitelistRegexInput() {
    return this._ipWhitelistRegex;
  }

  // keep_fields_list - computed: true, optional: true, required: false
  private _keepFieldsList?: string[]; 
  public get keepFieldsList() {
    return this.getListAttribute('keep_fields_list');
  }
  public set keepFieldsList(value: string[]) {
    this._keepFieldsList = value;
  }
  public resetKeepFieldsList() {
    this._keepFieldsList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keepFieldsListInput() {
    return this._keepFieldsList;
  }

  // max_active_cxn - computed: true, optional: true, required: false
  private _maxActiveCxn?: number; 
  public get maxActiveCxn() {
    return this.getNumberAttribute('max_active_cxn');
  }
  public set maxActiveCxn(value: number) {
    this._maxActiveCxn = value;
  }
  public resetMaxActiveCxn() {
    this._maxActiveCxn = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxActiveCxnInput() {
    return this._maxActiveCxn;
  }

  // max_buffer_size - computed: true, optional: true, required: false
  private _maxBufferSize?: number; 
  public get maxBufferSize() {
    return this.getNumberAttribute('max_buffer_size');
  }
  public set maxBufferSize(value: number) {
    this._maxBufferSize = value;
  }
  public resetMaxBufferSize() {
    this._maxBufferSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBufferSizeInput() {
    return this._maxBufferSize;
  }

  // metadata - computed: false, optional: true, required: false
  private _metadata = new PackSourceInputSyslogInputSyslogSyslog2MetadataList(this, "metadata", false);
  public get metadata() {
    return this._metadata;
  }
  public putMetadata(value: PackSourceInputSyslogInputSyslogSyslog2Metadata[] | cdktf.IResolvable) {
    this._metadata.internalValue = value;
  }
  public resetMetadata() {
    this._metadata.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataInput() {
    return this._metadata.internalValue;
  }

  // octet_counting - computed: true, optional: true, required: false
  private _octetCounting?: boolean | cdktf.IResolvable; 
  public get octetCounting() {
    return this.getBooleanAttribute('octet_counting');
  }
  public set octetCounting(value: boolean | cdktf.IResolvable) {
    this._octetCounting = value;
  }
  public resetOctetCounting() {
    this._octetCounting = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get octetCountingInput() {
    return this._octetCounting;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // pq - computed: false, optional: true, required: false
  private _pq = new PackSourceInputSyslogInputSyslogSyslog2PqOutputReference(this, "pq");
  public get pq() {
    return this._pq;
  }
  public putPq(value: PackSourceInputSyslogInputSyslogSyslog2Pq) {
    this._pq.internalValue = value;
  }
  public resetPq() {
    this._pq.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqInput() {
    return this._pq.internalValue;
  }

  // pq_enabled - computed: true, optional: true, required: false
  private _pqEnabled?: boolean | cdktf.IResolvable; 
  public get pqEnabled() {
    return this.getBooleanAttribute('pq_enabled');
  }
  public set pqEnabled(value: boolean | cdktf.IResolvable) {
    this._pqEnabled = value;
  }
  public resetPqEnabled() {
    this._pqEnabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqEnabledInput() {
    return this._pqEnabled;
  }

  // send_to_routes - computed: true, optional: true, required: false
  private _sendToRoutes?: boolean | cdktf.IResolvable; 
  public get sendToRoutes() {
    return this.getBooleanAttribute('send_to_routes');
  }
  public set sendToRoutes(value: boolean | cdktf.IResolvable) {
    this._sendToRoutes = value;
  }
  public resetSendToRoutes() {
    this._sendToRoutes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sendToRoutesInput() {
    return this._sendToRoutes;
  }

  // single_msg_udp_packets - computed: true, optional: true, required: false
  private _singleMsgUdpPackets?: boolean | cdktf.IResolvable; 
  public get singleMsgUdpPackets() {
    return this.getBooleanAttribute('single_msg_udp_packets');
  }
  public set singleMsgUdpPackets(value: boolean | cdktf.IResolvable) {
    this._singleMsgUdpPackets = value;
  }
  public resetSingleMsgUdpPackets() {
    this._singleMsgUdpPackets = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get singleMsgUdpPacketsInput() {
    return this._singleMsgUdpPackets;
  }

  // socket_ending_max_wait - computed: true, optional: true, required: false
  private _socketEndingMaxWait?: number; 
  public get socketEndingMaxWait() {
    return this.getNumberAttribute('socket_ending_max_wait');
  }
  public set socketEndingMaxWait(value: number) {
    this._socketEndingMaxWait = value;
  }
  public resetSocketEndingMaxWait() {
    this._socketEndingMaxWait = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get socketEndingMaxWaitInput() {
    return this._socketEndingMaxWait;
  }

  // socket_idle_timeout - computed: true, optional: true, required: false
  private _socketIdleTimeout?: number; 
  public get socketIdleTimeout() {
    return this.getNumberAttribute('socket_idle_timeout');
  }
  public set socketIdleTimeout(value: number) {
    this._socketIdleTimeout = value;
  }
  public resetSocketIdleTimeout() {
    this._socketIdleTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get socketIdleTimeoutInput() {
    return this._socketIdleTimeout;
  }

  // socket_max_lifespan - computed: true, optional: true, required: false
  private _socketMaxLifespan?: number; 
  public get socketMaxLifespan() {
    return this.getNumberAttribute('socket_max_lifespan');
  }
  public set socketMaxLifespan(value: number) {
    this._socketMaxLifespan = value;
  }
  public resetSocketMaxLifespan() {
    this._socketMaxLifespan = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get socketMaxLifespanInput() {
    return this._socketMaxLifespan;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // strictly_infer_octet_counting - computed: true, optional: true, required: false
  private _strictlyInferOctetCounting?: boolean | cdktf.IResolvable; 
  public get strictlyInferOctetCounting() {
    return this.getBooleanAttribute('strictly_infer_octet_counting');
  }
  public set strictlyInferOctetCounting(value: boolean | cdktf.IResolvable) {
    this._strictlyInferOctetCounting = value;
  }
  public resetStrictlyInferOctetCounting() {
    this._strictlyInferOctetCounting = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get strictlyInferOctetCountingInput() {
    return this._strictlyInferOctetCounting;
  }

  // tcp_port - computed: false, optional: false, required: true
  private _tcpPort?: number; 
  public get tcpPort() {
    return this.getNumberAttribute('tcp_port');
  }
  public set tcpPort(value: number) {
    this._tcpPort = value;
  }
  // Temporarily expose input value. Use with caution.
  public get tcpPortInput() {
    return this._tcpPort;
  }

  // timestamp_timezone - computed: true, optional: true, required: false
  private _timestampTimezone?: string; 
  public get timestampTimezone() {
    return this.getStringAttribute('timestamp_timezone');
  }
  public set timestampTimezone(value: string) {
    this._timestampTimezone = value;
  }
  public resetTimestampTimezone() {
    this._timestampTimezone = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timestampTimezoneInput() {
    return this._timestampTimezone;
  }

  // tls - computed: false, optional: true, required: false
  private _tls = new PackSourceInputSyslogInputSyslogSyslog2TlsOutputReference(this, "tls");
  public get tls() {
    return this._tls;
  }
  public putTls(value: PackSourceInputSyslogInputSyslogSyslog2Tls) {
    this._tls.internalValue = value;
  }
  public resetTls() {
    this._tls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsInput() {
    return this._tls.internalValue;
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // udp_port - computed: false, optional: true, required: false
  private _udpPort?: number; 
  public get udpPort() {
    return this.getNumberAttribute('udp_port');
  }
  public set udpPort(value: number) {
    this._udpPort = value;
  }
  public resetUdpPort() {
    this._udpPort = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get udpPortInput() {
    return this._udpPort;
  }

  // udp_socket_rx_buf_size - computed: false, optional: true, required: false
  private _udpSocketRxBufSize?: number; 
  public get udpSocketRxBufSize() {
    return this.getNumberAttribute('udp_socket_rx_buf_size');
  }
  public set udpSocketRxBufSize(value: number) {
    this._udpSocketRxBufSize = value;
  }
  public resetUdpSocketRxBufSize() {
    this._udpSocketRxBufSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get udpSocketRxBufSizeInput() {
    return this._udpSocketRxBufSize;
  }
}
export interface PackSourceInputSyslog {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#input_syslog_syslog1 PackSource#input_syslog_syslog1}
  */
  readonly inputSyslogSyslog1?: PackSourceInputSyslogInputSyslogSyslog1;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#input_syslog_syslog2 PackSource#input_syslog_syslog2}
  */
  readonly inputSyslogSyslog2?: PackSourceInputSyslogInputSyslogSyslog2;
}

export function packSourceInputSyslogToTerraform(struct?: PackSourceInputSyslog | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    input_syslog_syslog1: packSourceInputSyslogInputSyslogSyslog1ToTerraform(struct!.inputSyslogSyslog1),
    input_syslog_syslog2: packSourceInputSyslogInputSyslogSyslog2ToTerraform(struct!.inputSyslogSyslog2),
  }
}


export function packSourceInputSyslogToHclTerraform(struct?: PackSourceInputSyslog | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    input_syslog_syslog1: {
      value: packSourceInputSyslogInputSyslogSyslog1ToHclTerraform(struct!.inputSyslogSyslog1),
      isBlock: true,
      type: "struct",
      storageClassType: "PackSourceInputSyslogInputSyslogSyslog1",
    },
    input_syslog_syslog2: {
      value: packSourceInputSyslogInputSyslogSyslog2ToHclTerraform(struct!.inputSyslogSyslog2),
      isBlock: true,
      type: "struct",
      storageClassType: "PackSourceInputSyslogInputSyslogSyslog2",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputSyslogOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputSyslog | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._inputSyslogSyslog1?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.inputSyslogSyslog1 = this._inputSyslogSyslog1?.internalValue;
    }
    if (this._inputSyslogSyslog2?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.inputSyslogSyslog2 = this._inputSyslogSyslog2?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputSyslog | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._inputSyslogSyslog1.internalValue = undefined;
      this._inputSyslogSyslog2.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._inputSyslogSyslog1.internalValue = value.inputSyslogSyslog1;
      this._inputSyslogSyslog2.internalValue = value.inputSyslogSyslog2;
    }
  }

  // input_syslog_syslog1 - computed: false, optional: true, required: false
  private _inputSyslogSyslog1 = new PackSourceInputSyslogInputSyslogSyslog1OutputReference(this, "input_syslog_syslog1");
  public get inputSyslogSyslog1() {
    return this._inputSyslogSyslog1;
  }
  public putInputSyslogSyslog1(value: PackSourceInputSyslogInputSyslogSyslog1) {
    this._inputSyslogSyslog1.internalValue = value;
  }
  public resetInputSyslogSyslog1() {
    this._inputSyslogSyslog1.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get inputSyslogSyslog1Input() {
    return this._inputSyslogSyslog1.internalValue;
  }

  // input_syslog_syslog2 - computed: false, optional: true, required: false
  private _inputSyslogSyslog2 = new PackSourceInputSyslogInputSyslogSyslog2OutputReference(this, "input_syslog_syslog2");
  public get inputSyslogSyslog2() {
    return this._inputSyslogSyslog2;
  }
  public putInputSyslogSyslog2(value: PackSourceInputSyslogInputSyslogSyslog2) {
    this._inputSyslogSyslog2.internalValue = value;
  }
  public resetInputSyslogSyslog2() {
    this._inputSyslogSyslog2.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get inputSyslogSyslog2Input() {
    return this._inputSyslogSyslog2.internalValue;
  }
}
export interface PackSourceInputSystemMetricsConnections {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#output PackSource#output}
  */
  readonly output: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pipeline PackSource#pipeline}
  */
  readonly pipeline?: string;
}

export function packSourceInputSystemMetricsConnectionsToTerraform(struct?: PackSourceInputSystemMetricsConnections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    output: cdktf.stringToTerraform(struct!.output),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
  }
}


export function packSourceInputSystemMetricsConnectionsToHclTerraform(struct?: PackSourceInputSystemMetricsConnections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    output: {
      value: cdktf.stringToHclTerraform(struct!.output),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputSystemMetricsConnectionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackSourceInputSystemMetricsConnections | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._output !== undefined) {
      hasAnyValues = true;
      internalValueResult.output = this._output;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputSystemMetricsConnections | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._output = undefined;
      this._pipeline = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._output = value.output;
      this._pipeline = value.pipeline;
    }
  }

  // output - computed: false, optional: false, required: true
  private _output?: string; 
  public get output() {
    return this.getStringAttribute('output');
  }
  public set output(value: string) {
    this._output = value;
  }
  // Temporarily expose input value. Use with caution.
  public get outputInput() {
    return this._output;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }
}

export class PackSourceInputSystemMetricsConnectionsList extends cdktf.ComplexList {
  public internalValue? : PackSourceInputSystemMetricsConnections[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackSourceInputSystemMetricsConnectionsOutputReference {
    return new PackSourceInputSystemMetricsConnectionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackSourceInputSystemMetricsContainerFilters {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#expr PackSource#expr}
  */
  readonly expr: string;
}

export function packSourceInputSystemMetricsContainerFiltersToTerraform(struct?: PackSourceInputSystemMetricsContainerFilters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    expr: cdktf.stringToTerraform(struct!.expr),
  }
}


export function packSourceInputSystemMetricsContainerFiltersToHclTerraform(struct?: PackSourceInputSystemMetricsContainerFilters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    expr: {
      value: cdktf.stringToHclTerraform(struct!.expr),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputSystemMetricsContainerFiltersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackSourceInputSystemMetricsContainerFilters | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._expr !== undefined) {
      hasAnyValues = true;
      internalValueResult.expr = this._expr;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputSystemMetricsContainerFilters | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._expr = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._expr = value.expr;
    }
  }

  // expr - computed: false, optional: false, required: true
  private _expr?: string; 
  public get expr() {
    return this.getStringAttribute('expr');
  }
  public set expr(value: string) {
    this._expr = value;
  }
  // Temporarily expose input value. Use with caution.
  public get exprInput() {
    return this._expr;
  }
}

export class PackSourceInputSystemMetricsContainerFiltersList extends cdktf.ComplexList {
  public internalValue? : PackSourceInputSystemMetricsContainerFilters[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackSourceInputSystemMetricsContainerFiltersOutputReference {
    return new PackSourceInputSystemMetricsContainerFiltersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackSourceInputSystemMetricsContainer {
  /**
  * Include stopped and paused containers. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#all_containers PackSource#all_containers}
  */
  readonly allContainers?: boolean | cdktf.IResolvable;
  /**
  * Generate full container metrics. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#detail PackSource#detail}
  */
  readonly detail?: boolean | cdktf.IResolvable;
  /**
  * Full paths for Docker's UNIX-domain socket. Default: ["/var/run/docker.sock","/run/docker.sock"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#docker_socket PackSource#docker_socket}
  */
  readonly dockerSocket?: string[];
  /**
  * Timeout, in seconds, for the Docker API. Default: 5
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#docker_timeout PackSource#docker_timeout}
  */
  readonly dockerTimeout?: number;
  /**
  * Containers matching any of these will be included. All are included if no filters are added.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#filters PackSource#filters}
  */
  readonly filters?: PackSourceInputSystemMetricsContainerFilters[] | cdktf.IResolvable;
  /**
  * Select the level of detail for container metrics. Default: "basic"; must be one of ["basic", "all", "custom", "disabled"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#mode PackSource#mode}
  */
  readonly mode?: string;
  /**
  * Generate separate metrics for each device. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#per_device PackSource#per_device}
  */
  readonly perDevice?: boolean | cdktf.IResolvable;
}

export function packSourceInputSystemMetricsContainerToTerraform(struct?: PackSourceInputSystemMetricsContainer | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    all_containers: cdktf.booleanToTerraform(struct!.allContainers),
    detail: cdktf.booleanToTerraform(struct!.detail),
    docker_socket: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.dockerSocket),
    docker_timeout: cdktf.numberToTerraform(struct!.dockerTimeout),
    filters: cdktf.listMapper(packSourceInputSystemMetricsContainerFiltersToTerraform, false)(struct!.filters),
    mode: cdktf.stringToTerraform(struct!.mode),
    per_device: cdktf.booleanToTerraform(struct!.perDevice),
  }
}


export function packSourceInputSystemMetricsContainerToHclTerraform(struct?: PackSourceInputSystemMetricsContainer | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    all_containers: {
      value: cdktf.booleanToHclTerraform(struct!.allContainers),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    detail: {
      value: cdktf.booleanToHclTerraform(struct!.detail),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    docker_socket: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.dockerSocket),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    docker_timeout: {
      value: cdktf.numberToHclTerraform(struct!.dockerTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    filters: {
      value: cdktf.listMapperHcl(packSourceInputSystemMetricsContainerFiltersToHclTerraform, false)(struct!.filters),
      isBlock: true,
      type: "list",
      storageClassType: "PackSourceInputSystemMetricsContainerFiltersList",
    },
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    per_device: {
      value: cdktf.booleanToHclTerraform(struct!.perDevice),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputSystemMetricsContainerOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputSystemMetricsContainer | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._allContainers !== undefined) {
      hasAnyValues = true;
      internalValueResult.allContainers = this._allContainers;
    }
    if (this._detail !== undefined) {
      hasAnyValues = true;
      internalValueResult.detail = this._detail;
    }
    if (this._dockerSocket !== undefined) {
      hasAnyValues = true;
      internalValueResult.dockerSocket = this._dockerSocket;
    }
    if (this._dockerTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.dockerTimeout = this._dockerTimeout;
    }
    if (this._filters?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.filters = this._filters?.internalValue;
    }
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._perDevice !== undefined) {
      hasAnyValues = true;
      internalValueResult.perDevice = this._perDevice;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputSystemMetricsContainer | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._allContainers = undefined;
      this._detail = undefined;
      this._dockerSocket = undefined;
      this._dockerTimeout = undefined;
      this._filters.internalValue = undefined;
      this._mode = undefined;
      this._perDevice = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._allContainers = value.allContainers;
      this._detail = value.detail;
      this._dockerSocket = value.dockerSocket;
      this._dockerTimeout = value.dockerTimeout;
      this._filters.internalValue = value.filters;
      this._mode = value.mode;
      this._perDevice = value.perDevice;
    }
  }

  // all_containers - computed: true, optional: true, required: false
  private _allContainers?: boolean | cdktf.IResolvable; 
  public get allContainers() {
    return this.getBooleanAttribute('all_containers');
  }
  public set allContainers(value: boolean | cdktf.IResolvable) {
    this._allContainers = value;
  }
  public resetAllContainers() {
    this._allContainers = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get allContainersInput() {
    return this._allContainers;
  }

  // detail - computed: true, optional: true, required: false
  private _detail?: boolean | cdktf.IResolvable; 
  public get detail() {
    return this.getBooleanAttribute('detail');
  }
  public set detail(value: boolean | cdktf.IResolvable) {
    this._detail = value;
  }
  public resetDetail() {
    this._detail = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get detailInput() {
    return this._detail;
  }

  // docker_socket - computed: true, optional: true, required: false
  private _dockerSocket?: string[]; 
  public get dockerSocket() {
    return this.getListAttribute('docker_socket');
  }
  public set dockerSocket(value: string[]) {
    this._dockerSocket = value;
  }
  public resetDockerSocket() {
    this._dockerSocket = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dockerSocketInput() {
    return this._dockerSocket;
  }

  // docker_timeout - computed: true, optional: true, required: false
  private _dockerTimeout?: number; 
  public get dockerTimeout() {
    return this.getNumberAttribute('docker_timeout');
  }
  public set dockerTimeout(value: number) {
    this._dockerTimeout = value;
  }
  public resetDockerTimeout() {
    this._dockerTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dockerTimeoutInput() {
    return this._dockerTimeout;
  }

  // filters - computed: false, optional: true, required: false
  private _filters = new PackSourceInputSystemMetricsContainerFiltersList(this, "filters", false);
  public get filters() {
    return this._filters;
  }
  public putFilters(value: PackSourceInputSystemMetricsContainerFilters[] | cdktf.IResolvable) {
    this._filters.internalValue = value;
  }
  public resetFilters() {
    this._filters.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get filtersInput() {
    return this._filters.internalValue;
  }

  // mode - computed: true, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // per_device - computed: true, optional: true, required: false
  private _perDevice?: boolean | cdktf.IResolvable; 
  public get perDevice() {
    return this.getBooleanAttribute('per_device');
  }
  public set perDevice(value: boolean | cdktf.IResolvable) {
    this._perDevice = value;
  }
  public resetPerDevice() {
    this._perDevice = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get perDeviceInput() {
    return this._perDevice;
  }
}
export interface PackSourceInputSystemMetricsHostCustomCpu {
  /**
  * Generate metrics for all CPU states. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#detail PackSource#detail}
  */
  readonly detail?: boolean | cdktf.IResolvable;
  /**
  * Select the level of detail for CPU metrics. Default: "basic"; must be one of ["basic", "all", "custom", "disabled"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#mode PackSource#mode}
  */
  readonly mode?: string;
  /**
  * Generate metrics for each CPU. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#per_cpu PackSource#per_cpu}
  */
  readonly perCpu?: boolean | cdktf.IResolvable;
  /**
  * Generate raw, monotonic CPU time counters. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#time PackSource#time}
  */
  readonly time?: boolean | cdktf.IResolvable;
}

export function packSourceInputSystemMetricsHostCustomCpuToTerraform(struct?: PackSourceInputSystemMetricsHostCustomCpu | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    detail: cdktf.booleanToTerraform(struct!.detail),
    mode: cdktf.stringToTerraform(struct!.mode),
    per_cpu: cdktf.booleanToTerraform(struct!.perCpu),
    time: cdktf.booleanToTerraform(struct!.time),
  }
}


export function packSourceInputSystemMetricsHostCustomCpuToHclTerraform(struct?: PackSourceInputSystemMetricsHostCustomCpu | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    detail: {
      value: cdktf.booleanToHclTerraform(struct!.detail),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    per_cpu: {
      value: cdktf.booleanToHclTerraform(struct!.perCpu),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    time: {
      value: cdktf.booleanToHclTerraform(struct!.time),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputSystemMetricsHostCustomCpuOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputSystemMetricsHostCustomCpu | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._detail !== undefined) {
      hasAnyValues = true;
      internalValueResult.detail = this._detail;
    }
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._perCpu !== undefined) {
      hasAnyValues = true;
      internalValueResult.perCpu = this._perCpu;
    }
    if (this._time !== undefined) {
      hasAnyValues = true;
      internalValueResult.time = this._time;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputSystemMetricsHostCustomCpu | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._detail = undefined;
      this._mode = undefined;
      this._perCpu = undefined;
      this._time = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._detail = value.detail;
      this._mode = value.mode;
      this._perCpu = value.perCpu;
      this._time = value.time;
    }
  }

  // detail - computed: true, optional: true, required: false
  private _detail?: boolean | cdktf.IResolvable; 
  public get detail() {
    return this.getBooleanAttribute('detail');
  }
  public set detail(value: boolean | cdktf.IResolvable) {
    this._detail = value;
  }
  public resetDetail() {
    this._detail = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get detailInput() {
    return this._detail;
  }

  // mode - computed: true, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // per_cpu - computed: true, optional: true, required: false
  private _perCpu?: boolean | cdktf.IResolvable; 
  public get perCpu() {
    return this.getBooleanAttribute('per_cpu');
  }
  public set perCpu(value: boolean | cdktf.IResolvable) {
    this._perCpu = value;
  }
  public resetPerCpu() {
    this._perCpu = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get perCpuInput() {
    return this._perCpu;
  }

  // time - computed: true, optional: true, required: false
  private _time?: boolean | cdktf.IResolvable; 
  public get time() {
    return this.getBooleanAttribute('time');
  }
  public set time(value: boolean | cdktf.IResolvable) {
    this._time = value;
  }
  public resetTime() {
    this._time = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeInput() {
    return this._time;
  }
}
export interface PackSourceInputSystemMetricsHostCustomDisk {
  /**
  * Generate full disk metrics. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#detail PackSource#detail}
  */
  readonly detail?: boolean | cdktf.IResolvable;
  /**
  * Block devices to include/exclude. Examples: sda*, !loop*. Wildcards and ! (not) operators are supported. All devices are included if this list is empty. Default: ["!loop*","*"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#devices PackSource#devices}
  */
  readonly devices?: string[];
  /**
  * Filesystem types to include/exclude. Examples: ext4, !*tmpfs, !squashfs. Wildcards and ! (not) operators are supported. All types are included if this list is empty. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#fstypes PackSource#fstypes}
  */
  readonly fstypes?: string[];
  /**
  * Select the level of detail for disk metrics. Default: "basic"; must be one of ["basic", "all", "custom", "disabled"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#mode PackSource#mode}
  */
  readonly mode?: string;
  /**
  * Filesystem mountpoints to include/exclude. Examples: /, /home, !/proc*, !/tmp. Wildcards and ! (not) operators are supported. All mountpoints are included if this list is empty. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#mountpoints PackSource#mountpoints}
  */
  readonly mountpoints?: string[];
  /**
  * Generate separate metrics for each device. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#per_device PackSource#per_device}
  */
  readonly perDevice?: boolean | cdktf.IResolvable;
}

export function packSourceInputSystemMetricsHostCustomDiskToTerraform(struct?: PackSourceInputSystemMetricsHostCustomDisk | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    detail: cdktf.booleanToTerraform(struct!.detail),
    devices: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.devices),
    fstypes: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.fstypes),
    mode: cdktf.stringToTerraform(struct!.mode),
    mountpoints: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.mountpoints),
    per_device: cdktf.booleanToTerraform(struct!.perDevice),
  }
}


export function packSourceInputSystemMetricsHostCustomDiskToHclTerraform(struct?: PackSourceInputSystemMetricsHostCustomDisk | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    detail: {
      value: cdktf.booleanToHclTerraform(struct!.detail),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    devices: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.devices),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    fstypes: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.fstypes),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    mountpoints: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.mountpoints),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    per_device: {
      value: cdktf.booleanToHclTerraform(struct!.perDevice),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputSystemMetricsHostCustomDiskOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputSystemMetricsHostCustomDisk | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._detail !== undefined) {
      hasAnyValues = true;
      internalValueResult.detail = this._detail;
    }
    if (this._devices !== undefined) {
      hasAnyValues = true;
      internalValueResult.devices = this._devices;
    }
    if (this._fstypes !== undefined) {
      hasAnyValues = true;
      internalValueResult.fstypes = this._fstypes;
    }
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._mountpoints !== undefined) {
      hasAnyValues = true;
      internalValueResult.mountpoints = this._mountpoints;
    }
    if (this._perDevice !== undefined) {
      hasAnyValues = true;
      internalValueResult.perDevice = this._perDevice;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputSystemMetricsHostCustomDisk | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._detail = undefined;
      this._devices = undefined;
      this._fstypes = undefined;
      this._mode = undefined;
      this._mountpoints = undefined;
      this._perDevice = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._detail = value.detail;
      this._devices = value.devices;
      this._fstypes = value.fstypes;
      this._mode = value.mode;
      this._mountpoints = value.mountpoints;
      this._perDevice = value.perDevice;
    }
  }

  // detail - computed: true, optional: true, required: false
  private _detail?: boolean | cdktf.IResolvable; 
  public get detail() {
    return this.getBooleanAttribute('detail');
  }
  public set detail(value: boolean | cdktf.IResolvable) {
    this._detail = value;
  }
  public resetDetail() {
    this._detail = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get detailInput() {
    return this._detail;
  }

  // devices - computed: true, optional: true, required: false
  private _devices?: string[]; 
  public get devices() {
    return this.getListAttribute('devices');
  }
  public set devices(value: string[]) {
    this._devices = value;
  }
  public resetDevices() {
    this._devices = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get devicesInput() {
    return this._devices;
  }

  // fstypes - computed: true, optional: true, required: false
  private _fstypes?: string[]; 
  public get fstypes() {
    return this.getListAttribute('fstypes');
  }
  public set fstypes(value: string[]) {
    this._fstypes = value;
  }
  public resetFstypes() {
    this._fstypes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fstypesInput() {
    return this._fstypes;
  }

  // mode - computed: true, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // mountpoints - computed: true, optional: true, required: false
  private _mountpoints?: string[]; 
  public get mountpoints() {
    return this.getListAttribute('mountpoints');
  }
  public set mountpoints(value: string[]) {
    this._mountpoints = value;
  }
  public resetMountpoints() {
    this._mountpoints = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get mountpointsInput() {
    return this._mountpoints;
  }

  // per_device - computed: true, optional: true, required: false
  private _perDevice?: boolean | cdktf.IResolvable; 
  public get perDevice() {
    return this.getBooleanAttribute('per_device');
  }
  public set perDevice(value: boolean | cdktf.IResolvable) {
    this._perDevice = value;
  }
  public resetPerDevice() {
    this._perDevice = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get perDeviceInput() {
    return this._perDevice;
  }
}
export interface PackSourceInputSystemMetricsHostCustomMemory {
  /**
  * Generate metrics for all memory states. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#detail PackSource#detail}
  */
  readonly detail?: boolean | cdktf.IResolvable;
  /**
  * Select the level of detail for memory metrics. Default: "basic"; must be one of ["basic", "all", "custom", "disabled"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#mode PackSource#mode}
  */
  readonly mode?: string;
}

export function packSourceInputSystemMetricsHostCustomMemoryToTerraform(struct?: PackSourceInputSystemMetricsHostCustomMemory | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    detail: cdktf.booleanToTerraform(struct!.detail),
    mode: cdktf.stringToTerraform(struct!.mode),
  }
}


export function packSourceInputSystemMetricsHostCustomMemoryToHclTerraform(struct?: PackSourceInputSystemMetricsHostCustomMemory | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    detail: {
      value: cdktf.booleanToHclTerraform(struct!.detail),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputSystemMetricsHostCustomMemoryOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputSystemMetricsHostCustomMemory | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._detail !== undefined) {
      hasAnyValues = true;
      internalValueResult.detail = this._detail;
    }
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputSystemMetricsHostCustomMemory | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._detail = undefined;
      this._mode = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._detail = value.detail;
      this._mode = value.mode;
    }
  }

  // detail - computed: true, optional: true, required: false
  private _detail?: boolean | cdktf.IResolvable; 
  public get detail() {
    return this.getBooleanAttribute('detail');
  }
  public set detail(value: boolean | cdktf.IResolvable) {
    this._detail = value;
  }
  public resetDetail() {
    this._detail = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get detailInput() {
    return this._detail;
  }

  // mode - computed: true, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }
}
export interface PackSourceInputSystemMetricsHostCustomNetwork {
  /**
  * Generate full network metrics. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#detail PackSource#detail}
  */
  readonly detail?: boolean | cdktf.IResolvable;
  /**
  * Network interfaces to include/exclude. Examples: eth0, !lo. All interfaces are included if this list is empty. Default: ["!lo","*"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#devices PackSource#devices}
  */
  readonly devices?: string[];
  /**
  * Select the level of detail for network metrics. Default: "basic"; must be one of ["basic", "all", "custom", "disabled"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#mode PackSource#mode}
  */
  readonly mode?: string;
  /**
  * Generate separate metrics for each interface. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#per_interface PackSource#per_interface}
  */
  readonly perInterface?: boolean | cdktf.IResolvable;
}

export function packSourceInputSystemMetricsHostCustomNetworkToTerraform(struct?: PackSourceInputSystemMetricsHostCustomNetwork | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    detail: cdktf.booleanToTerraform(struct!.detail),
    devices: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.devices),
    mode: cdktf.stringToTerraform(struct!.mode),
    per_interface: cdktf.booleanToTerraform(struct!.perInterface),
  }
}


export function packSourceInputSystemMetricsHostCustomNetworkToHclTerraform(struct?: PackSourceInputSystemMetricsHostCustomNetwork | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    detail: {
      value: cdktf.booleanToHclTerraform(struct!.detail),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    devices: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.devices),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    per_interface: {
      value: cdktf.booleanToHclTerraform(struct!.perInterface),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputSystemMetricsHostCustomNetworkOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputSystemMetricsHostCustomNetwork | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._detail !== undefined) {
      hasAnyValues = true;
      internalValueResult.detail = this._detail;
    }
    if (this._devices !== undefined) {
      hasAnyValues = true;
      internalValueResult.devices = this._devices;
    }
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._perInterface !== undefined) {
      hasAnyValues = true;
      internalValueResult.perInterface = this._perInterface;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputSystemMetricsHostCustomNetwork | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._detail = undefined;
      this._devices = undefined;
      this._mode = undefined;
      this._perInterface = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._detail = value.detail;
      this._devices = value.devices;
      this._mode = value.mode;
      this._perInterface = value.perInterface;
    }
  }

  // detail - computed: true, optional: true, required: false
  private _detail?: boolean | cdktf.IResolvable; 
  public get detail() {
    return this.getBooleanAttribute('detail');
  }
  public set detail(value: boolean | cdktf.IResolvable) {
    this._detail = value;
  }
  public resetDetail() {
    this._detail = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get detailInput() {
    return this._detail;
  }

  // devices - computed: true, optional: true, required: false
  private _devices?: string[]; 
  public get devices() {
    return this.getListAttribute('devices');
  }
  public set devices(value: string[]) {
    this._devices = value;
  }
  public resetDevices() {
    this._devices = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get devicesInput() {
    return this._devices;
  }

  // mode - computed: true, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // per_interface - computed: true, optional: true, required: false
  private _perInterface?: boolean | cdktf.IResolvable; 
  public get perInterface() {
    return this.getBooleanAttribute('per_interface');
  }
  public set perInterface(value: boolean | cdktf.IResolvable) {
    this._perInterface = value;
  }
  public resetPerInterface() {
    this._perInterface = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get perInterfaceInput() {
    return this._perInterface;
  }
}
export interface PackSourceInputSystemMetricsHostCustomSystem {
  /**
  * Select the level of detail for system metrics. Default: "basic"; must be one of ["basic", "all", "custom", "disabled"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#mode PackSource#mode}
  */
  readonly mode?: string;
  /**
  * Generate metrics for the numbers of processes in various states. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#processes PackSource#processes}
  */
  readonly processes?: boolean | cdktf.IResolvable;
}

export function packSourceInputSystemMetricsHostCustomSystemToTerraform(struct?: PackSourceInputSystemMetricsHostCustomSystem | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    mode: cdktf.stringToTerraform(struct!.mode),
    processes: cdktf.booleanToTerraform(struct!.processes),
  }
}


export function packSourceInputSystemMetricsHostCustomSystemToHclTerraform(struct?: PackSourceInputSystemMetricsHostCustomSystem | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    processes: {
      value: cdktf.booleanToHclTerraform(struct!.processes),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputSystemMetricsHostCustomSystemOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputSystemMetricsHostCustomSystem | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._processes !== undefined) {
      hasAnyValues = true;
      internalValueResult.processes = this._processes;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputSystemMetricsHostCustomSystem | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._mode = undefined;
      this._processes = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._mode = value.mode;
      this._processes = value.processes;
    }
  }

  // mode - computed: true, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // processes - computed: true, optional: true, required: false
  private _processes?: boolean | cdktf.IResolvable; 
  public get processes() {
    return this.getBooleanAttribute('processes');
  }
  public set processes(value: boolean | cdktf.IResolvable) {
    this._processes = value;
  }
  public resetProcesses() {
    this._processes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get processesInput() {
    return this._processes;
  }
}
export interface PackSourceInputSystemMetricsHostCustom {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#cpu PackSource#cpu}
  */
  readonly cpu?: PackSourceInputSystemMetricsHostCustomCpu;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#disk PackSource#disk}
  */
  readonly disk?: PackSourceInputSystemMetricsHostCustomDisk;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#memory PackSource#memory}
  */
  readonly memory?: PackSourceInputSystemMetricsHostCustomMemory;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#network PackSource#network}
  */
  readonly network?: PackSourceInputSystemMetricsHostCustomNetwork;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#system PackSource#system}
  */
  readonly systemAttribute?: PackSourceInputSystemMetricsHostCustomSystem;
}

export function packSourceInputSystemMetricsHostCustomToTerraform(struct?: PackSourceInputSystemMetricsHostCustom | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    cpu: packSourceInputSystemMetricsHostCustomCpuToTerraform(struct!.cpu),
    disk: packSourceInputSystemMetricsHostCustomDiskToTerraform(struct!.disk),
    memory: packSourceInputSystemMetricsHostCustomMemoryToTerraform(struct!.memory),
    network: packSourceInputSystemMetricsHostCustomNetworkToTerraform(struct!.network),
    system: packSourceInputSystemMetricsHostCustomSystemToTerraform(struct!.systemAttribute),
  }
}


export function packSourceInputSystemMetricsHostCustomToHclTerraform(struct?: PackSourceInputSystemMetricsHostCustom | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    cpu: {
      value: packSourceInputSystemMetricsHostCustomCpuToHclTerraform(struct!.cpu),
      isBlock: true,
      type: "struct",
      storageClassType: "PackSourceInputSystemMetricsHostCustomCpu",
    },
    disk: {
      value: packSourceInputSystemMetricsHostCustomDiskToHclTerraform(struct!.disk),
      isBlock: true,
      type: "struct",
      storageClassType: "PackSourceInputSystemMetricsHostCustomDisk",
    },
    memory: {
      value: packSourceInputSystemMetricsHostCustomMemoryToHclTerraform(struct!.memory),
      isBlock: true,
      type: "struct",
      storageClassType: "PackSourceInputSystemMetricsHostCustomMemory",
    },
    network: {
      value: packSourceInputSystemMetricsHostCustomNetworkToHclTerraform(struct!.network),
      isBlock: true,
      type: "struct",
      storageClassType: "PackSourceInputSystemMetricsHostCustomNetwork",
    },
    system: {
      value: packSourceInputSystemMetricsHostCustomSystemToHclTerraform(struct!.systemAttribute),
      isBlock: true,
      type: "struct",
      storageClassType: "PackSourceInputSystemMetricsHostCustomSystem",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputSystemMetricsHostCustomOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputSystemMetricsHostCustom | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._cpu?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.cpu = this._cpu?.internalValue;
    }
    if (this._disk?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.disk = this._disk?.internalValue;
    }
    if (this._memory?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.memory = this._memory?.internalValue;
    }
    if (this._network?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.network = this._network?.internalValue;
    }
    if (this._system?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.systemAttribute = this._system?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputSystemMetricsHostCustom | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._cpu.internalValue = undefined;
      this._disk.internalValue = undefined;
      this._memory.internalValue = undefined;
      this._network.internalValue = undefined;
      this._system.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._cpu.internalValue = value.cpu;
      this._disk.internalValue = value.disk;
      this._memory.internalValue = value.memory;
      this._network.internalValue = value.network;
      this._system.internalValue = value.systemAttribute;
    }
  }

  // cpu - computed: false, optional: true, required: false
  private _cpu = new PackSourceInputSystemMetricsHostCustomCpuOutputReference(this, "cpu");
  public get cpu() {
    return this._cpu;
  }
  public putCpu(value: PackSourceInputSystemMetricsHostCustomCpu) {
    this._cpu.internalValue = value;
  }
  public resetCpu() {
    this._cpu.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cpuInput() {
    return this._cpu.internalValue;
  }

  // disk - computed: false, optional: true, required: false
  private _disk = new PackSourceInputSystemMetricsHostCustomDiskOutputReference(this, "disk");
  public get disk() {
    return this._disk;
  }
  public putDisk(value: PackSourceInputSystemMetricsHostCustomDisk) {
    this._disk.internalValue = value;
  }
  public resetDisk() {
    this._disk.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get diskInput() {
    return this._disk.internalValue;
  }

  // memory - computed: false, optional: true, required: false
  private _memory = new PackSourceInputSystemMetricsHostCustomMemoryOutputReference(this, "memory");
  public get memory() {
    return this._memory;
  }
  public putMemory(value: PackSourceInputSystemMetricsHostCustomMemory) {
    this._memory.internalValue = value;
  }
  public resetMemory() {
    this._memory.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get memoryInput() {
    return this._memory.internalValue;
  }

  // network - computed: false, optional: true, required: false
  private _network = new PackSourceInputSystemMetricsHostCustomNetworkOutputReference(this, "network");
  public get network() {
    return this._network;
  }
  public putNetwork(value: PackSourceInputSystemMetricsHostCustomNetwork) {
    this._network.internalValue = value;
  }
  public resetNetwork() {
    this._network.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get networkInput() {
    return this._network.internalValue;
  }

  // system - computed: false, optional: true, required: false
  private _system = new PackSourceInputSystemMetricsHostCustomSystemOutputReference(this, "system");
  public get systemAttribute() {
    return this._system;
  }
  public putSystemAttribute(value: PackSourceInputSystemMetricsHostCustomSystem) {
    this._system.internalValue = value;
  }
  public resetSystemAttribute() {
    this._system.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get systemAttributeInput() {
    return this._system.internalValue;
  }
}
export interface PackSourceInputSystemMetricsHost {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#custom PackSource#custom}
  */
  readonly custom?: PackSourceInputSystemMetricsHostCustom;
  /**
  * Select level of detail for host metrics. Default: "basic"; must be one of ["basic", "all", "custom", "disabled"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#mode PackSource#mode}
  */
  readonly mode?: string;
}

export function packSourceInputSystemMetricsHostToTerraform(struct?: PackSourceInputSystemMetricsHost | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    custom: packSourceInputSystemMetricsHostCustomToTerraform(struct!.custom),
    mode: cdktf.stringToTerraform(struct!.mode),
  }
}


export function packSourceInputSystemMetricsHostToHclTerraform(struct?: PackSourceInputSystemMetricsHost | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    custom: {
      value: packSourceInputSystemMetricsHostCustomToHclTerraform(struct!.custom),
      isBlock: true,
      type: "struct",
      storageClassType: "PackSourceInputSystemMetricsHostCustom",
    },
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputSystemMetricsHostOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputSystemMetricsHost | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._custom?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.custom = this._custom?.internalValue;
    }
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputSystemMetricsHost | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._custom.internalValue = undefined;
      this._mode = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._custom.internalValue = value.custom;
      this._mode = value.mode;
    }
  }

  // custom - computed: false, optional: true, required: false
  private _custom = new PackSourceInputSystemMetricsHostCustomOutputReference(this, "custom");
  public get custom() {
    return this._custom;
  }
  public putCustom(value: PackSourceInputSystemMetricsHostCustom) {
    this._custom.internalValue = value;
  }
  public resetCustom() {
    this._custom.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get customInput() {
    return this._custom.internalValue;
  }

  // mode - computed: true, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }
}
export interface PackSourceInputSystemMetricsMetadata {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#name PackSource#name}
  */
  readonly name: string;
  /**
  * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#value PackSource#value}
  */
  readonly value: string;
}

export function packSourceInputSystemMetricsMetadataToTerraform(struct?: PackSourceInputSystemMetricsMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function packSourceInputSystemMetricsMetadataToHclTerraform(struct?: PackSourceInputSystemMetricsMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputSystemMetricsMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackSourceInputSystemMetricsMetadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputSystemMetricsMetadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class PackSourceInputSystemMetricsMetadataList extends cdktf.ComplexList {
  public internalValue? : PackSourceInputSystemMetricsMetadata[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackSourceInputSystemMetricsMetadataOutputReference {
    return new PackSourceInputSystemMetricsMetadataOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackSourceInputSystemMetricsPersistence {
  /**
  * Default: "gzip"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#compress PackSource#compress}
  */
  readonly compress?: string;
  /**
  * Path to use to write metrics. Defaults to $CRIBL_HOME/state/system_metrics. Default: "$CRIBL_HOME/state/system_metrics"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#dest_path PackSource#dest_path}
  */
  readonly destPath?: string;
  /**
  * Spool metrics to disk for Cribl Edge and Search. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#enable PackSource#enable}
  */
  readonly enable?: boolean | cdktf.IResolvable;
  /**
  * Maximum disk space allowed to be consumed (examples: 420MB, 4GB). When limit is reached, older data will be deleted. Default: "1GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_data_size PackSource#max_data_size}
  */
  readonly maxDataSize?: string;
  /**
  * Maximum amount of time to retain data (examples: 2h, 4d). When limit is reached, older data will be deleted. Default: "24h"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_data_time PackSource#max_data_time}
  */
  readonly maxDataTime?: string;
  /**
  * Time span for each file bucket. Default: "10m"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#time_window PackSource#time_window}
  */
  readonly timeWindow?: string;
}

export function packSourceInputSystemMetricsPersistenceToTerraform(struct?: PackSourceInputSystemMetricsPersistence | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    compress: cdktf.stringToTerraform(struct!.compress),
    dest_path: cdktf.stringToTerraform(struct!.destPath),
    enable: cdktf.booleanToTerraform(struct!.enable),
    max_data_size: cdktf.stringToTerraform(struct!.maxDataSize),
    max_data_time: cdktf.stringToTerraform(struct!.maxDataTime),
    time_window: cdktf.stringToTerraform(struct!.timeWindow),
  }
}


export function packSourceInputSystemMetricsPersistenceToHclTerraform(struct?: PackSourceInputSystemMetricsPersistence | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    compress: {
      value: cdktf.stringToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    dest_path: {
      value: cdktf.stringToHclTerraform(struct!.destPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    enable: {
      value: cdktf.booleanToHclTerraform(struct!.enable),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    max_data_size: {
      value: cdktf.stringToHclTerraform(struct!.maxDataSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_data_time: {
      value: cdktf.stringToHclTerraform(struct!.maxDataTime),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    time_window: {
      value: cdktf.stringToHclTerraform(struct!.timeWindow),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputSystemMetricsPersistenceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputSystemMetricsPersistence | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._destPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.destPath = this._destPath;
    }
    if (this._enable !== undefined) {
      hasAnyValues = true;
      internalValueResult.enable = this._enable;
    }
    if (this._maxDataSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxDataSize = this._maxDataSize;
    }
    if (this._maxDataTime !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxDataTime = this._maxDataTime;
    }
    if (this._timeWindow !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeWindow = this._timeWindow;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputSystemMetricsPersistence | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._compress = undefined;
      this._destPath = undefined;
      this._enable = undefined;
      this._maxDataSize = undefined;
      this._maxDataTime = undefined;
      this._timeWindow = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._compress = value.compress;
      this._destPath = value.destPath;
      this._enable = value.enable;
      this._maxDataSize = value.maxDataSize;
      this._maxDataTime = value.maxDataTime;
      this._timeWindow = value.timeWindow;
    }
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: string; 
  public get compress() {
    return this.getStringAttribute('compress');
  }
  public set compress(value: string) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // dest_path - computed: true, optional: true, required: false
  private _destPath?: string; 
  public get destPath() {
    return this.getStringAttribute('dest_path');
  }
  public set destPath(value: string) {
    this._destPath = value;
  }
  public resetDestPath() {
    this._destPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get destPathInput() {
    return this._destPath;
  }

  // enable - computed: true, optional: true, required: false
  private _enable?: boolean | cdktf.IResolvable; 
  public get enable() {
    return this.getBooleanAttribute('enable');
  }
  public set enable(value: boolean | cdktf.IResolvable) {
    this._enable = value;
  }
  public resetEnable() {
    this._enable = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableInput() {
    return this._enable;
  }

  // max_data_size - computed: true, optional: true, required: false
  private _maxDataSize?: string; 
  public get maxDataSize() {
    return this.getStringAttribute('max_data_size');
  }
  public set maxDataSize(value: string) {
    this._maxDataSize = value;
  }
  public resetMaxDataSize() {
    this._maxDataSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxDataSizeInput() {
    return this._maxDataSize;
  }

  // max_data_time - computed: true, optional: true, required: false
  private _maxDataTime?: string; 
  public get maxDataTime() {
    return this.getStringAttribute('max_data_time');
  }
  public set maxDataTime(value: string) {
    this._maxDataTime = value;
  }
  public resetMaxDataTime() {
    this._maxDataTime = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxDataTimeInput() {
    return this._maxDataTime;
  }

  // time_window - computed: true, optional: true, required: false
  private _timeWindow?: string; 
  public get timeWindow() {
    return this.getStringAttribute('time_window');
  }
  public set timeWindow(value: string) {
    this._timeWindow = value;
  }
  public resetTimeWindow() {
    this._timeWindow = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeWindowInput() {
    return this._timeWindow;
  }
}
export interface PackSourceInputSystemMetricsPq {
  /**
  * The number of events to send downstream before committing that Stream has read them. Default: 42
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#commit_frequency PackSource#commit_frequency}
  */
  readonly commitFrequency?: number;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#compress PackSource#compress}
  */
  readonly compress?: string;
  /**
  * The maximum number of events to hold in memory before writing the events to disk. Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_buffer_size PackSource#max_buffer_size}
  */
  readonly maxBufferSize?: number;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc. Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_file_size PackSource#max_file_size}
  */
  readonly maxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_size PackSource#max_size}
  */
  readonly maxSize?: string;
  /**
  * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine. Default: "always"; must be one of ["smart", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#mode PackSource#mode}
  */
  readonly mode?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#path PackSource#path}
  */
  readonly path?: string;
}

export function packSourceInputSystemMetricsPqToTerraform(struct?: PackSourceInputSystemMetricsPq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    commit_frequency: cdktf.numberToTerraform(struct!.commitFrequency),
    compress: cdktf.stringToTerraform(struct!.compress),
    max_buffer_size: cdktf.numberToTerraform(struct!.maxBufferSize),
    max_file_size: cdktf.stringToTerraform(struct!.maxFileSize),
    max_size: cdktf.stringToTerraform(struct!.maxSize),
    mode: cdktf.stringToTerraform(struct!.mode),
    path: cdktf.stringToTerraform(struct!.path),
  }
}


export function packSourceInputSystemMetricsPqToHclTerraform(struct?: PackSourceInputSystemMetricsPq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    commit_frequency: {
      value: cdktf.numberToHclTerraform(struct!.commitFrequency),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    compress: {
      value: cdktf.stringToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_buffer_size: {
      value: cdktf.numberToHclTerraform(struct!.maxBufferSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.maxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_size: {
      value: cdktf.stringToHclTerraform(struct!.maxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputSystemMetricsPqOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputSystemMetricsPq | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._commitFrequency !== undefined) {
      hasAnyValues = true;
      internalValueResult.commitFrequency = this._commitFrequency;
    }
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._maxBufferSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBufferSize = this._maxBufferSize;
    }
    if (this._maxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxFileSize = this._maxFileSize;
    }
    if (this._maxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxSize = this._maxSize;
    }
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputSystemMetricsPq | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._commitFrequency = undefined;
      this._compress = undefined;
      this._maxBufferSize = undefined;
      this._maxFileSize = undefined;
      this._maxSize = undefined;
      this._mode = undefined;
      this._path = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._commitFrequency = value.commitFrequency;
      this._compress = value.compress;
      this._maxBufferSize = value.maxBufferSize;
      this._maxFileSize = value.maxFileSize;
      this._maxSize = value.maxSize;
      this._mode = value.mode;
      this._path = value.path;
    }
  }

  // commit_frequency - computed: true, optional: true, required: false
  private _commitFrequency?: number; 
  public get commitFrequency() {
    return this.getNumberAttribute('commit_frequency');
  }
  public set commitFrequency(value: number) {
    this._commitFrequency = value;
  }
  public resetCommitFrequency() {
    this._commitFrequency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commitFrequencyInput() {
    return this._commitFrequency;
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: string; 
  public get compress() {
    return this.getStringAttribute('compress');
  }
  public set compress(value: string) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // max_buffer_size - computed: true, optional: true, required: false
  private _maxBufferSize?: number; 
  public get maxBufferSize() {
    return this.getNumberAttribute('max_buffer_size');
  }
  public set maxBufferSize(value: number) {
    this._maxBufferSize = value;
  }
  public resetMaxBufferSize() {
    this._maxBufferSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBufferSizeInput() {
    return this._maxBufferSize;
  }

  // max_file_size - computed: true, optional: true, required: false
  private _maxFileSize?: string; 
  public get maxFileSize() {
    return this.getStringAttribute('max_file_size');
  }
  public set maxFileSize(value: string) {
    this._maxFileSize = value;
  }
  public resetMaxFileSize() {
    this._maxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxFileSizeInput() {
    return this._maxFileSize;
  }

  // max_size - computed: true, optional: true, required: false
  private _maxSize?: string; 
  public get maxSize() {
    return this.getStringAttribute('max_size');
  }
  public set maxSize(value: string) {
    this._maxSize = value;
  }
  public resetMaxSize() {
    this._maxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxSizeInput() {
    return this._maxSize;
  }

  // mode - computed: true, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // path - computed: true, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }
}
export interface PackSourceInputSystemMetricsProcessSets {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#filter PackSource#filter}
  */
  readonly filter: string;
  /**
  * Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#include_children PackSource#include_children}
  */
  readonly includeChildren?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#name PackSource#name}
  */
  readonly name: string;
}

export function packSourceInputSystemMetricsProcessSetsToTerraform(struct?: PackSourceInputSystemMetricsProcessSets | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    filter: cdktf.stringToTerraform(struct!.filter),
    include_children: cdktf.booleanToTerraform(struct!.includeChildren),
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function packSourceInputSystemMetricsProcessSetsToHclTerraform(struct?: PackSourceInputSystemMetricsProcessSets | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    filter: {
      value: cdktf.stringToHclTerraform(struct!.filter),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    include_children: {
      value: cdktf.booleanToHclTerraform(struct!.includeChildren),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputSystemMetricsProcessSetsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackSourceInputSystemMetricsProcessSets | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._filter !== undefined) {
      hasAnyValues = true;
      internalValueResult.filter = this._filter;
    }
    if (this._includeChildren !== undefined) {
      hasAnyValues = true;
      internalValueResult.includeChildren = this._includeChildren;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputSystemMetricsProcessSets | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._filter = undefined;
      this._includeChildren = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._filter = value.filter;
      this._includeChildren = value.includeChildren;
      this._name = value.name;
    }
  }

  // filter - computed: false, optional: false, required: true
  private _filter?: string; 
  public get filter() {
    return this.getStringAttribute('filter');
  }
  public set filter(value: string) {
    this._filter = value;
  }
  // Temporarily expose input value. Use with caution.
  public get filterInput() {
    return this._filter;
  }

  // include_children - computed: true, optional: true, required: false
  private _includeChildren?: boolean | cdktf.IResolvable; 
  public get includeChildren() {
    return this.getBooleanAttribute('include_children');
  }
  public set includeChildren(value: boolean | cdktf.IResolvable) {
    this._includeChildren = value;
  }
  public resetIncludeChildren() {
    this._includeChildren = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get includeChildrenInput() {
    return this._includeChildren;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}

export class PackSourceInputSystemMetricsProcessSetsList extends cdktf.ComplexList {
  public internalValue? : PackSourceInputSystemMetricsProcessSets[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackSourceInputSystemMetricsProcessSetsOutputReference {
    return new PackSourceInputSystemMetricsProcessSetsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackSourceInputSystemMetricsProcess {
  /**
  * Configure sets to collect process metrics
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#sets PackSource#sets}
  */
  readonly sets?: PackSourceInputSystemMetricsProcessSets[] | cdktf.IResolvable;
}

export function packSourceInputSystemMetricsProcessToTerraform(struct?: PackSourceInputSystemMetricsProcess | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    sets: cdktf.listMapper(packSourceInputSystemMetricsProcessSetsToTerraform, false)(struct!.sets),
  }
}


export function packSourceInputSystemMetricsProcessToHclTerraform(struct?: PackSourceInputSystemMetricsProcess | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    sets: {
      value: cdktf.listMapperHcl(packSourceInputSystemMetricsProcessSetsToHclTerraform, false)(struct!.sets),
      isBlock: true,
      type: "list",
      storageClassType: "PackSourceInputSystemMetricsProcessSetsList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputSystemMetricsProcessOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputSystemMetricsProcess | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._sets?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.sets = this._sets?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputSystemMetricsProcess | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._sets.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._sets.internalValue = value.sets;
    }
  }

  // sets - computed: false, optional: true, required: false
  private _sets = new PackSourceInputSystemMetricsProcessSetsList(this, "sets", false);
  public get sets() {
    return this._sets;
  }
  public putSets(value: PackSourceInputSystemMetricsProcessSets[] | cdktf.IResolvable) {
    this._sets.internalValue = value;
  }
  public resetSets() {
    this._sets.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get setsInput() {
    return this._sets.internalValue;
  }
}
export interface PackSourceInputSystemMetrics {
  /**
  * Direct connections to Destinations, and optionally via a Pipeline or a Pack
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#connections PackSource#connections}
  */
  readonly connections?: PackSourceInputSystemMetricsConnections[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#container PackSource#container}
  */
  readonly container?: PackSourceInputSystemMetricsContainer;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#description PackSource#description}
  */
  readonly description?: string;
  /**
  * Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#disabled PackSource#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#environment PackSource#environment}
  */
  readonly environment?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#host PackSource#host}
  */
  readonly host?: PackSourceInputSystemMetricsHost;
  /**
  * Unique ID for this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#id PackSource#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id: string;
  /**
  * Time, in seconds, between consecutive metric collections. Default is 10 seconds. Default: 10
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#interval PackSource#interval}
  */
  readonly interval?: number;
  /**
  * Fields to add to events from this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#metadata PackSource#metadata}
  */
  readonly metadata?: PackSourceInputSystemMetricsMetadata[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#persistence PackSource#persistence}
  */
  readonly persistence?: PackSourceInputSystemMetricsPersistence;
  /**
  * Pipeline to process data from this Source before sending it through the Routes
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pipeline PackSource#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pq PackSource#pq}
  */
  readonly pq?: PackSourceInputSystemMetricsPq;
  /**
  * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers). Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pq_enabled PackSource#pq_enabled}
  */
  readonly pqEnabled?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#process PackSource#process}
  */
  readonly process?: PackSourceInputSystemMetricsProcess;
  /**
  * Select whether to send data to Routes, or directly to Destinations. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#send_to_routes PackSource#send_to_routes}
  */
  readonly sendToRoutes?: boolean | cdktf.IResolvable;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#streamtags PackSource#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * must be "system_metrics"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#type PackSource#type}
  */
  readonly type: string;
}

export function packSourceInputSystemMetricsToTerraform(struct?: PackSourceInputSystemMetrics | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    connections: cdktf.listMapper(packSourceInputSystemMetricsConnectionsToTerraform, false)(struct!.connections),
    container: packSourceInputSystemMetricsContainerToTerraform(struct!.container),
    description: cdktf.stringToTerraform(struct!.description),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    environment: cdktf.stringToTerraform(struct!.environment),
    host: packSourceInputSystemMetricsHostToTerraform(struct!.host),
    id: cdktf.stringToTerraform(struct!.id),
    interval: cdktf.numberToTerraform(struct!.interval),
    metadata: cdktf.listMapper(packSourceInputSystemMetricsMetadataToTerraform, false)(struct!.metadata),
    persistence: packSourceInputSystemMetricsPersistenceToTerraform(struct!.persistence),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    pq: packSourceInputSystemMetricsPqToTerraform(struct!.pq),
    pq_enabled: cdktf.booleanToTerraform(struct!.pqEnabled),
    process: packSourceInputSystemMetricsProcessToTerraform(struct!.process),
    send_to_routes: cdktf.booleanToTerraform(struct!.sendToRoutes),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function packSourceInputSystemMetricsToHclTerraform(struct?: PackSourceInputSystemMetrics | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    connections: {
      value: cdktf.listMapperHcl(packSourceInputSystemMetricsConnectionsToHclTerraform, false)(struct!.connections),
      isBlock: true,
      type: "list",
      storageClassType: "PackSourceInputSystemMetricsConnectionsList",
    },
    container: {
      value: packSourceInputSystemMetricsContainerToHclTerraform(struct!.container),
      isBlock: true,
      type: "struct",
      storageClassType: "PackSourceInputSystemMetricsContainer",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    host: {
      value: packSourceInputSystemMetricsHostToHclTerraform(struct!.host),
      isBlock: true,
      type: "struct",
      storageClassType: "PackSourceInputSystemMetricsHost",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    interval: {
      value: cdktf.numberToHclTerraform(struct!.interval),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    metadata: {
      value: cdktf.listMapperHcl(packSourceInputSystemMetricsMetadataToHclTerraform, false)(struct!.metadata),
      isBlock: true,
      type: "list",
      storageClassType: "PackSourceInputSystemMetricsMetadataList",
    },
    persistence: {
      value: packSourceInputSystemMetricsPersistenceToHclTerraform(struct!.persistence),
      isBlock: true,
      type: "struct",
      storageClassType: "PackSourceInputSystemMetricsPersistence",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq: {
      value: packSourceInputSystemMetricsPqToHclTerraform(struct!.pq),
      isBlock: true,
      type: "struct",
      storageClassType: "PackSourceInputSystemMetricsPq",
    },
    pq_enabled: {
      value: cdktf.booleanToHclTerraform(struct!.pqEnabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    process: {
      value: packSourceInputSystemMetricsProcessToHclTerraform(struct!.process),
      isBlock: true,
      type: "struct",
      storageClassType: "PackSourceInputSystemMetricsProcess",
    },
    send_to_routes: {
      value: cdktf.booleanToHclTerraform(struct!.sendToRoutes),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputSystemMetricsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputSystemMetrics | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._connections?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.connections = this._connections?.internalValue;
    }
    if (this._container?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.container = this._container?.internalValue;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._host?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.host = this._host?.internalValue;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._interval !== undefined) {
      hasAnyValues = true;
      internalValueResult.interval = this._interval;
    }
    if (this._metadata?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadata = this._metadata?.internalValue;
    }
    if (this._persistence?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.persistence = this._persistence?.internalValue;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._pq?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pq = this._pq?.internalValue;
    }
    if (this._pqEnabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqEnabled = this._pqEnabled;
    }
    if (this._process?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.process = this._process?.internalValue;
    }
    if (this._sendToRoutes !== undefined) {
      hasAnyValues = true;
      internalValueResult.sendToRoutes = this._sendToRoutes;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputSystemMetrics | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._connections.internalValue = undefined;
      this._container.internalValue = undefined;
      this._description = undefined;
      this._disabled = undefined;
      this._environment = undefined;
      this._host.internalValue = undefined;
      this._id = undefined;
      this._interval = undefined;
      this._metadata.internalValue = undefined;
      this._persistence.internalValue = undefined;
      this._pipeline = undefined;
      this._pq.internalValue = undefined;
      this._pqEnabled = undefined;
      this._process.internalValue = undefined;
      this._sendToRoutes = undefined;
      this._streamtags = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._connections.internalValue = value.connections;
      this._container.internalValue = value.container;
      this._description = value.description;
      this._disabled = value.disabled;
      this._environment = value.environment;
      this._host.internalValue = value.host;
      this._id = value.id;
      this._interval = value.interval;
      this._metadata.internalValue = value.metadata;
      this._persistence.internalValue = value.persistence;
      this._pipeline = value.pipeline;
      this._pq.internalValue = value.pq;
      this._pqEnabled = value.pqEnabled;
      this._process.internalValue = value.process;
      this._sendToRoutes = value.sendToRoutes;
      this._streamtags = value.streamtags;
      this._type = value.type;
    }
  }

  // connections - computed: false, optional: true, required: false
  private _connections = new PackSourceInputSystemMetricsConnectionsList(this, "connections", false);
  public get connections() {
    return this._connections;
  }
  public putConnections(value: PackSourceInputSystemMetricsConnections[] | cdktf.IResolvable) {
    this._connections.internalValue = value;
  }
  public resetConnections() {
    this._connections.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectionsInput() {
    return this._connections.internalValue;
  }

  // container - computed: false, optional: true, required: false
  private _container = new PackSourceInputSystemMetricsContainerOutputReference(this, "container");
  public get container() {
    return this._container;
  }
  public putContainer(value: PackSourceInputSystemMetricsContainer) {
    this._container.internalValue = value;
  }
  public resetContainer() {
    this._container.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get containerInput() {
    return this._container.internalValue;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // host - computed: false, optional: true, required: false
  private _host = new PackSourceInputSystemMetricsHostOutputReference(this, "host");
  public get host() {
    return this._host;
  }
  public putHost(value: PackSourceInputSystemMetricsHost) {
    this._host.internalValue = value;
  }
  public resetHost() {
    this._host.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostInput() {
    return this._host.internalValue;
  }

  // id - computed: false, optional: false, required: true
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // interval - computed: true, optional: true, required: false
  private _interval?: number; 
  public get interval() {
    return this.getNumberAttribute('interval');
  }
  public set interval(value: number) {
    this._interval = value;
  }
  public resetInterval() {
    this._interval = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get intervalInput() {
    return this._interval;
  }

  // metadata - computed: false, optional: true, required: false
  private _metadata = new PackSourceInputSystemMetricsMetadataList(this, "metadata", false);
  public get metadata() {
    return this._metadata;
  }
  public putMetadata(value: PackSourceInputSystemMetricsMetadata[] | cdktf.IResolvable) {
    this._metadata.internalValue = value;
  }
  public resetMetadata() {
    this._metadata.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataInput() {
    return this._metadata.internalValue;
  }

  // persistence - computed: false, optional: true, required: false
  private _persistence = new PackSourceInputSystemMetricsPersistenceOutputReference(this, "persistence");
  public get persistence() {
    return this._persistence;
  }
  public putPersistence(value: PackSourceInputSystemMetricsPersistence) {
    this._persistence.internalValue = value;
  }
  public resetPersistence() {
    this._persistence.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get persistenceInput() {
    return this._persistence.internalValue;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // pq - computed: false, optional: true, required: false
  private _pq = new PackSourceInputSystemMetricsPqOutputReference(this, "pq");
  public get pq() {
    return this._pq;
  }
  public putPq(value: PackSourceInputSystemMetricsPq) {
    this._pq.internalValue = value;
  }
  public resetPq() {
    this._pq.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqInput() {
    return this._pq.internalValue;
  }

  // pq_enabled - computed: true, optional: true, required: false
  private _pqEnabled?: boolean | cdktf.IResolvable; 
  public get pqEnabled() {
    return this.getBooleanAttribute('pq_enabled');
  }
  public set pqEnabled(value: boolean | cdktf.IResolvable) {
    this._pqEnabled = value;
  }
  public resetPqEnabled() {
    this._pqEnabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqEnabledInput() {
    return this._pqEnabled;
  }

  // process - computed: false, optional: true, required: false
  private _process = new PackSourceInputSystemMetricsProcessOutputReference(this, "process");
  public get process() {
    return this._process;
  }
  public putProcess(value: PackSourceInputSystemMetricsProcess) {
    this._process.internalValue = value;
  }
  public resetProcess() {
    this._process.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get processInput() {
    return this._process.internalValue;
  }

  // send_to_routes - computed: true, optional: true, required: false
  private _sendToRoutes?: boolean | cdktf.IResolvable; 
  public get sendToRoutes() {
    return this.getBooleanAttribute('send_to_routes');
  }
  public set sendToRoutes(value: boolean | cdktf.IResolvable) {
    this._sendToRoutes = value;
  }
  public resetSendToRoutes() {
    this._sendToRoutes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sendToRoutesInput() {
    return this._sendToRoutes;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface PackSourceInputSystemStateCollectorsDisk {
  /**
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#enable PackSource#enable}
  */
  readonly enable?: boolean | cdktf.IResolvable;
}

export function packSourceInputSystemStateCollectorsDiskToTerraform(struct?: PackSourceInputSystemStateCollectorsDisk | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    enable: cdktf.booleanToTerraform(struct!.enable),
  }
}


export function packSourceInputSystemStateCollectorsDiskToHclTerraform(struct?: PackSourceInputSystemStateCollectorsDisk | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    enable: {
      value: cdktf.booleanToHclTerraform(struct!.enable),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputSystemStateCollectorsDiskOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputSystemStateCollectorsDisk | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._enable !== undefined) {
      hasAnyValues = true;
      internalValueResult.enable = this._enable;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputSystemStateCollectorsDisk | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._enable = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._enable = value.enable;
    }
  }

  // enable - computed: true, optional: true, required: false
  private _enable?: boolean | cdktf.IResolvable; 
  public get enable() {
    return this.getBooleanAttribute('enable');
  }
  public set enable(value: boolean | cdktf.IResolvable) {
    this._enable = value;
  }
  public resetEnable() {
    this._enable = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableInput() {
    return this._enable;
  }
}
export interface PackSourceInputSystemStateCollectorsDns {
  /**
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#enable PackSource#enable}
  */
  readonly enable?: boolean | cdktf.IResolvable;
}

export function packSourceInputSystemStateCollectorsDnsToTerraform(struct?: PackSourceInputSystemStateCollectorsDns | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    enable: cdktf.booleanToTerraform(struct!.enable),
  }
}


export function packSourceInputSystemStateCollectorsDnsToHclTerraform(struct?: PackSourceInputSystemStateCollectorsDns | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    enable: {
      value: cdktf.booleanToHclTerraform(struct!.enable),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputSystemStateCollectorsDnsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputSystemStateCollectorsDns | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._enable !== undefined) {
      hasAnyValues = true;
      internalValueResult.enable = this._enable;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputSystemStateCollectorsDns | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._enable = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._enable = value.enable;
    }
  }

  // enable - computed: true, optional: true, required: false
  private _enable?: boolean | cdktf.IResolvable; 
  public get enable() {
    return this.getBooleanAttribute('enable');
  }
  public set enable(value: boolean | cdktf.IResolvable) {
    this._enable = value;
  }
  public resetEnable() {
    this._enable = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableInput() {
    return this._enable;
  }
}
export interface PackSourceInputSystemStateCollectorsFirewall {
  /**
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#enable PackSource#enable}
  */
  readonly enable?: boolean | cdktf.IResolvable;
}

export function packSourceInputSystemStateCollectorsFirewallToTerraform(struct?: PackSourceInputSystemStateCollectorsFirewall | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    enable: cdktf.booleanToTerraform(struct!.enable),
  }
}


export function packSourceInputSystemStateCollectorsFirewallToHclTerraform(struct?: PackSourceInputSystemStateCollectorsFirewall | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    enable: {
      value: cdktf.booleanToHclTerraform(struct!.enable),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputSystemStateCollectorsFirewallOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputSystemStateCollectorsFirewall | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._enable !== undefined) {
      hasAnyValues = true;
      internalValueResult.enable = this._enable;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputSystemStateCollectorsFirewall | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._enable = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._enable = value.enable;
    }
  }

  // enable - computed: true, optional: true, required: false
  private _enable?: boolean | cdktf.IResolvable; 
  public get enable() {
    return this.getBooleanAttribute('enable');
  }
  public set enable(value: boolean | cdktf.IResolvable) {
    this._enable = value;
  }
  public resetEnable() {
    this._enable = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableInput() {
    return this._enable;
  }
}
export interface PackSourceInputSystemStateCollectorsHostsfile {
  /**
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#enable PackSource#enable}
  */
  readonly enable?: boolean | cdktf.IResolvable;
}

export function packSourceInputSystemStateCollectorsHostsfileToTerraform(struct?: PackSourceInputSystemStateCollectorsHostsfile | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    enable: cdktf.booleanToTerraform(struct!.enable),
  }
}


export function packSourceInputSystemStateCollectorsHostsfileToHclTerraform(struct?: PackSourceInputSystemStateCollectorsHostsfile | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    enable: {
      value: cdktf.booleanToHclTerraform(struct!.enable),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputSystemStateCollectorsHostsfileOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputSystemStateCollectorsHostsfile | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._enable !== undefined) {
      hasAnyValues = true;
      internalValueResult.enable = this._enable;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputSystemStateCollectorsHostsfile | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._enable = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._enable = value.enable;
    }
  }

  // enable - computed: true, optional: true, required: false
  private _enable?: boolean | cdktf.IResolvable; 
  public get enable() {
    return this.getBooleanAttribute('enable');
  }
  public set enable(value: boolean | cdktf.IResolvable) {
    this._enable = value;
  }
  public resetEnable() {
    this._enable = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableInput() {
    return this._enable;
  }
}
export interface PackSourceInputSystemStateCollectorsInterfaces {
  /**
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#enable PackSource#enable}
  */
  readonly enable?: boolean | cdktf.IResolvable;
}

export function packSourceInputSystemStateCollectorsInterfacesToTerraform(struct?: PackSourceInputSystemStateCollectorsInterfaces | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    enable: cdktf.booleanToTerraform(struct!.enable),
  }
}


export function packSourceInputSystemStateCollectorsInterfacesToHclTerraform(struct?: PackSourceInputSystemStateCollectorsInterfaces | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    enable: {
      value: cdktf.booleanToHclTerraform(struct!.enable),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputSystemStateCollectorsInterfacesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputSystemStateCollectorsInterfaces | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._enable !== undefined) {
      hasAnyValues = true;
      internalValueResult.enable = this._enable;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputSystemStateCollectorsInterfaces | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._enable = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._enable = value.enable;
    }
  }

  // enable - computed: true, optional: true, required: false
  private _enable?: boolean | cdktf.IResolvable; 
  public get enable() {
    return this.getBooleanAttribute('enable');
  }
  public set enable(value: boolean | cdktf.IResolvable) {
    this._enable = value;
  }
  public resetEnable() {
    this._enable = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableInput() {
    return this._enable;
  }
}
export interface PackSourceInputSystemStateCollectorsLoginUsers {
  /**
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#enable PackSource#enable}
  */
  readonly enable?: boolean | cdktf.IResolvable;
}

export function packSourceInputSystemStateCollectorsLoginUsersToTerraform(struct?: PackSourceInputSystemStateCollectorsLoginUsers | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    enable: cdktf.booleanToTerraform(struct!.enable),
  }
}


export function packSourceInputSystemStateCollectorsLoginUsersToHclTerraform(struct?: PackSourceInputSystemStateCollectorsLoginUsers | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    enable: {
      value: cdktf.booleanToHclTerraform(struct!.enable),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputSystemStateCollectorsLoginUsersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputSystemStateCollectorsLoginUsers | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._enable !== undefined) {
      hasAnyValues = true;
      internalValueResult.enable = this._enable;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputSystemStateCollectorsLoginUsers | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._enable = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._enable = value.enable;
    }
  }

  // enable - computed: true, optional: true, required: false
  private _enable?: boolean | cdktf.IResolvable; 
  public get enable() {
    return this.getBooleanAttribute('enable');
  }
  public set enable(value: boolean | cdktf.IResolvable) {
    this._enable = value;
  }
  public resetEnable() {
    this._enable = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableInput() {
    return this._enable;
  }
}
export interface PackSourceInputSystemStateCollectorsMetadata {
  /**
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#enable PackSource#enable}
  */
  readonly enable?: boolean | cdktf.IResolvable;
}

export function packSourceInputSystemStateCollectorsMetadataToTerraform(struct?: PackSourceInputSystemStateCollectorsMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    enable: cdktf.booleanToTerraform(struct!.enable),
  }
}


export function packSourceInputSystemStateCollectorsMetadataToHclTerraform(struct?: PackSourceInputSystemStateCollectorsMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    enable: {
      value: cdktf.booleanToHclTerraform(struct!.enable),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputSystemStateCollectorsMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputSystemStateCollectorsMetadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._enable !== undefined) {
      hasAnyValues = true;
      internalValueResult.enable = this._enable;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputSystemStateCollectorsMetadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._enable = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._enable = value.enable;
    }
  }

  // enable - computed: true, optional: true, required: false
  private _enable?: boolean | cdktf.IResolvable; 
  public get enable() {
    return this.getBooleanAttribute('enable');
  }
  public set enable(value: boolean | cdktf.IResolvable) {
    this._enable = value;
  }
  public resetEnable() {
    this._enable = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableInput() {
    return this._enable;
  }
}
export interface PackSourceInputSystemStateCollectorsPorts {
  /**
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#enable PackSource#enable}
  */
  readonly enable?: boolean | cdktf.IResolvable;
}

export function packSourceInputSystemStateCollectorsPortsToTerraform(struct?: PackSourceInputSystemStateCollectorsPorts | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    enable: cdktf.booleanToTerraform(struct!.enable),
  }
}


export function packSourceInputSystemStateCollectorsPortsToHclTerraform(struct?: PackSourceInputSystemStateCollectorsPorts | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    enable: {
      value: cdktf.booleanToHclTerraform(struct!.enable),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputSystemStateCollectorsPortsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputSystemStateCollectorsPorts | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._enable !== undefined) {
      hasAnyValues = true;
      internalValueResult.enable = this._enable;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputSystemStateCollectorsPorts | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._enable = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._enable = value.enable;
    }
  }

  // enable - computed: true, optional: true, required: false
  private _enable?: boolean | cdktf.IResolvable; 
  public get enable() {
    return this.getBooleanAttribute('enable');
  }
  public set enable(value: boolean | cdktf.IResolvable) {
    this._enable = value;
  }
  public resetEnable() {
    this._enable = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableInput() {
    return this._enable;
  }
}
export interface PackSourceInputSystemStateCollectorsRoutes {
  /**
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#enable PackSource#enable}
  */
  readonly enable?: boolean | cdktf.IResolvable;
}

export function packSourceInputSystemStateCollectorsRoutesToTerraform(struct?: PackSourceInputSystemStateCollectorsRoutes | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    enable: cdktf.booleanToTerraform(struct!.enable),
  }
}


export function packSourceInputSystemStateCollectorsRoutesToHclTerraform(struct?: PackSourceInputSystemStateCollectorsRoutes | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    enable: {
      value: cdktf.booleanToHclTerraform(struct!.enable),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputSystemStateCollectorsRoutesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputSystemStateCollectorsRoutes | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._enable !== undefined) {
      hasAnyValues = true;
      internalValueResult.enable = this._enable;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputSystemStateCollectorsRoutes | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._enable = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._enable = value.enable;
    }
  }

  // enable - computed: true, optional: true, required: false
  private _enable?: boolean | cdktf.IResolvable; 
  public get enable() {
    return this.getBooleanAttribute('enable');
  }
  public set enable(value: boolean | cdktf.IResolvable) {
    this._enable = value;
  }
  public resetEnable() {
    this._enable = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableInput() {
    return this._enable;
  }
}
export interface PackSourceInputSystemStateCollectorsServices {
  /**
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#enable PackSource#enable}
  */
  readonly enable?: boolean | cdktf.IResolvable;
}

export function packSourceInputSystemStateCollectorsServicesToTerraform(struct?: PackSourceInputSystemStateCollectorsServices | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    enable: cdktf.booleanToTerraform(struct!.enable),
  }
}


export function packSourceInputSystemStateCollectorsServicesToHclTerraform(struct?: PackSourceInputSystemStateCollectorsServices | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    enable: {
      value: cdktf.booleanToHclTerraform(struct!.enable),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputSystemStateCollectorsServicesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputSystemStateCollectorsServices | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._enable !== undefined) {
      hasAnyValues = true;
      internalValueResult.enable = this._enable;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputSystemStateCollectorsServices | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._enable = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._enable = value.enable;
    }
  }

  // enable - computed: true, optional: true, required: false
  private _enable?: boolean | cdktf.IResolvable; 
  public get enable() {
    return this.getBooleanAttribute('enable');
  }
  public set enable(value: boolean | cdktf.IResolvable) {
    this._enable = value;
  }
  public resetEnable() {
    this._enable = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableInput() {
    return this._enable;
  }
}
export interface PackSourceInputSystemStateCollectorsUser {
  /**
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#enable PackSource#enable}
  */
  readonly enable?: boolean | cdktf.IResolvable;
}

export function packSourceInputSystemStateCollectorsUserToTerraform(struct?: PackSourceInputSystemStateCollectorsUser | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    enable: cdktf.booleanToTerraform(struct!.enable),
  }
}


export function packSourceInputSystemStateCollectorsUserToHclTerraform(struct?: PackSourceInputSystemStateCollectorsUser | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    enable: {
      value: cdktf.booleanToHclTerraform(struct!.enable),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputSystemStateCollectorsUserOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputSystemStateCollectorsUser | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._enable !== undefined) {
      hasAnyValues = true;
      internalValueResult.enable = this._enable;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputSystemStateCollectorsUser | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._enable = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._enable = value.enable;
    }
  }

  // enable - computed: true, optional: true, required: false
  private _enable?: boolean | cdktf.IResolvable; 
  public get enable() {
    return this.getBooleanAttribute('enable');
  }
  public set enable(value: boolean | cdktf.IResolvable) {
    this._enable = value;
  }
  public resetEnable() {
    this._enable = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableInput() {
    return this._enable;
  }
}
export interface PackSourceInputSystemStateCollectors {
  /**
  * Creates events for physical disks, partitions, and file systems
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#disk PackSource#disk}
  */
  readonly disk?: PackSourceInputSystemStateCollectorsDisk;
  /**
  * Creates events for DNS resolvers and search entries
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#dns PackSource#dns}
  */
  readonly dns?: PackSourceInputSystemStateCollectorsDns;
  /**
  * Creates events for Firewall rules entries
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#firewall PackSource#firewall}
  */
  readonly firewall?: PackSourceInputSystemStateCollectorsFirewall;
  /**
  * Creates events based on entries collected from the hosts file
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#hostsfile PackSource#hostsfile}
  */
  readonly hostsfile?: PackSourceInputSystemStateCollectorsHostsfile;
  /**
  * Creates events for each of the host’s network interfaces
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#interfaces PackSource#interfaces}
  */
  readonly interfaces?: PackSourceInputSystemStateCollectorsInterfaces;
  /**
  * Creates events for logged-in users
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#login_users PackSource#login_users}
  */
  readonly loginUsers?: PackSourceInputSystemStateCollectorsLoginUsers;
  /**
  * Creates events based on the host system’s current state
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#metadata PackSource#metadata}
  */
  readonly metadata?: PackSourceInputSystemStateCollectorsMetadata;
  /**
  * Creates events from list of listening ports
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#ports PackSource#ports}
  */
  readonly ports?: PackSourceInputSystemStateCollectorsPorts;
  /**
  * Creates events based on entries collected from the host’s network routes
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#routes PackSource#routes}
  */
  readonly routes?: PackSourceInputSystemStateCollectorsRoutes;
  /**
  * Creates events from the list of services
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#services PackSource#services}
  */
  readonly services?: PackSourceInputSystemStateCollectorsServices;
  /**
  * Creates events for local users and groups
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#user PackSource#user}
  */
  readonly user?: PackSourceInputSystemStateCollectorsUser;
}

export function packSourceInputSystemStateCollectorsToTerraform(struct?: PackSourceInputSystemStateCollectors | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    disk: packSourceInputSystemStateCollectorsDiskToTerraform(struct!.disk),
    dns: packSourceInputSystemStateCollectorsDnsToTerraform(struct!.dns),
    firewall: packSourceInputSystemStateCollectorsFirewallToTerraform(struct!.firewall),
    hostsfile: packSourceInputSystemStateCollectorsHostsfileToTerraform(struct!.hostsfile),
    interfaces: packSourceInputSystemStateCollectorsInterfacesToTerraform(struct!.interfaces),
    login_users: packSourceInputSystemStateCollectorsLoginUsersToTerraform(struct!.loginUsers),
    metadata: packSourceInputSystemStateCollectorsMetadataToTerraform(struct!.metadata),
    ports: packSourceInputSystemStateCollectorsPortsToTerraform(struct!.ports),
    routes: packSourceInputSystemStateCollectorsRoutesToTerraform(struct!.routes),
    services: packSourceInputSystemStateCollectorsServicesToTerraform(struct!.services),
    user: packSourceInputSystemStateCollectorsUserToTerraform(struct!.user),
  }
}


export function packSourceInputSystemStateCollectorsToHclTerraform(struct?: PackSourceInputSystemStateCollectors | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    disk: {
      value: packSourceInputSystemStateCollectorsDiskToHclTerraform(struct!.disk),
      isBlock: true,
      type: "struct",
      storageClassType: "PackSourceInputSystemStateCollectorsDisk",
    },
    dns: {
      value: packSourceInputSystemStateCollectorsDnsToHclTerraform(struct!.dns),
      isBlock: true,
      type: "struct",
      storageClassType: "PackSourceInputSystemStateCollectorsDns",
    },
    firewall: {
      value: packSourceInputSystemStateCollectorsFirewallToHclTerraform(struct!.firewall),
      isBlock: true,
      type: "struct",
      storageClassType: "PackSourceInputSystemStateCollectorsFirewall",
    },
    hostsfile: {
      value: packSourceInputSystemStateCollectorsHostsfileToHclTerraform(struct!.hostsfile),
      isBlock: true,
      type: "struct",
      storageClassType: "PackSourceInputSystemStateCollectorsHostsfile",
    },
    interfaces: {
      value: packSourceInputSystemStateCollectorsInterfacesToHclTerraform(struct!.interfaces),
      isBlock: true,
      type: "struct",
      storageClassType: "PackSourceInputSystemStateCollectorsInterfaces",
    },
    login_users: {
      value: packSourceInputSystemStateCollectorsLoginUsersToHclTerraform(struct!.loginUsers),
      isBlock: true,
      type: "struct",
      storageClassType: "PackSourceInputSystemStateCollectorsLoginUsers",
    },
    metadata: {
      value: packSourceInputSystemStateCollectorsMetadataToHclTerraform(struct!.metadata),
      isBlock: true,
      type: "struct",
      storageClassType: "PackSourceInputSystemStateCollectorsMetadata",
    },
    ports: {
      value: packSourceInputSystemStateCollectorsPortsToHclTerraform(struct!.ports),
      isBlock: true,
      type: "struct",
      storageClassType: "PackSourceInputSystemStateCollectorsPorts",
    },
    routes: {
      value: packSourceInputSystemStateCollectorsRoutesToHclTerraform(struct!.routes),
      isBlock: true,
      type: "struct",
      storageClassType: "PackSourceInputSystemStateCollectorsRoutes",
    },
    services: {
      value: packSourceInputSystemStateCollectorsServicesToHclTerraform(struct!.services),
      isBlock: true,
      type: "struct",
      storageClassType: "PackSourceInputSystemStateCollectorsServices",
    },
    user: {
      value: packSourceInputSystemStateCollectorsUserToHclTerraform(struct!.user),
      isBlock: true,
      type: "struct",
      storageClassType: "PackSourceInputSystemStateCollectorsUser",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputSystemStateCollectorsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputSystemStateCollectors | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._disk?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.disk = this._disk?.internalValue;
    }
    if (this._dns?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.dns = this._dns?.internalValue;
    }
    if (this._firewall?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.firewall = this._firewall?.internalValue;
    }
    if (this._hostsfile?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.hostsfile = this._hostsfile?.internalValue;
    }
    if (this._interfaces?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.interfaces = this._interfaces?.internalValue;
    }
    if (this._loginUsers?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.loginUsers = this._loginUsers?.internalValue;
    }
    if (this._metadata?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadata = this._metadata?.internalValue;
    }
    if (this._ports?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.ports = this._ports?.internalValue;
    }
    if (this._routes?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.routes = this._routes?.internalValue;
    }
    if (this._services?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.services = this._services?.internalValue;
    }
    if (this._user?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.user = this._user?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputSystemStateCollectors | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._disk.internalValue = undefined;
      this._dns.internalValue = undefined;
      this._firewall.internalValue = undefined;
      this._hostsfile.internalValue = undefined;
      this._interfaces.internalValue = undefined;
      this._loginUsers.internalValue = undefined;
      this._metadata.internalValue = undefined;
      this._ports.internalValue = undefined;
      this._routes.internalValue = undefined;
      this._services.internalValue = undefined;
      this._user.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._disk.internalValue = value.disk;
      this._dns.internalValue = value.dns;
      this._firewall.internalValue = value.firewall;
      this._hostsfile.internalValue = value.hostsfile;
      this._interfaces.internalValue = value.interfaces;
      this._loginUsers.internalValue = value.loginUsers;
      this._metadata.internalValue = value.metadata;
      this._ports.internalValue = value.ports;
      this._routes.internalValue = value.routes;
      this._services.internalValue = value.services;
      this._user.internalValue = value.user;
    }
  }

  // disk - computed: false, optional: true, required: false
  private _disk = new PackSourceInputSystemStateCollectorsDiskOutputReference(this, "disk");
  public get disk() {
    return this._disk;
  }
  public putDisk(value: PackSourceInputSystemStateCollectorsDisk) {
    this._disk.internalValue = value;
  }
  public resetDisk() {
    this._disk.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get diskInput() {
    return this._disk.internalValue;
  }

  // dns - computed: false, optional: true, required: false
  private _dns = new PackSourceInputSystemStateCollectorsDnsOutputReference(this, "dns");
  public get dns() {
    return this._dns;
  }
  public putDns(value: PackSourceInputSystemStateCollectorsDns) {
    this._dns.internalValue = value;
  }
  public resetDns() {
    this._dns.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dnsInput() {
    return this._dns.internalValue;
  }

  // firewall - computed: false, optional: true, required: false
  private _firewall = new PackSourceInputSystemStateCollectorsFirewallOutputReference(this, "firewall");
  public get firewall() {
    return this._firewall;
  }
  public putFirewall(value: PackSourceInputSystemStateCollectorsFirewall) {
    this._firewall.internalValue = value;
  }
  public resetFirewall() {
    this._firewall.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get firewallInput() {
    return this._firewall.internalValue;
  }

  // hostsfile - computed: false, optional: true, required: false
  private _hostsfile = new PackSourceInputSystemStateCollectorsHostsfileOutputReference(this, "hostsfile");
  public get hostsfile() {
    return this._hostsfile;
  }
  public putHostsfile(value: PackSourceInputSystemStateCollectorsHostsfile) {
    this._hostsfile.internalValue = value;
  }
  public resetHostsfile() {
    this._hostsfile.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostsfileInput() {
    return this._hostsfile.internalValue;
  }

  // interfaces - computed: false, optional: true, required: false
  private _interfaces = new PackSourceInputSystemStateCollectorsInterfacesOutputReference(this, "interfaces");
  public get interfaces() {
    return this._interfaces;
  }
  public putInterfaces(value: PackSourceInputSystemStateCollectorsInterfaces) {
    this._interfaces.internalValue = value;
  }
  public resetInterfaces() {
    this._interfaces.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get interfacesInput() {
    return this._interfaces.internalValue;
  }

  // login_users - computed: false, optional: true, required: false
  private _loginUsers = new PackSourceInputSystemStateCollectorsLoginUsersOutputReference(this, "login_users");
  public get loginUsers() {
    return this._loginUsers;
  }
  public putLoginUsers(value: PackSourceInputSystemStateCollectorsLoginUsers) {
    this._loginUsers.internalValue = value;
  }
  public resetLoginUsers() {
    this._loginUsers.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get loginUsersInput() {
    return this._loginUsers.internalValue;
  }

  // metadata - computed: false, optional: true, required: false
  private _metadata = new PackSourceInputSystemStateCollectorsMetadataOutputReference(this, "metadata");
  public get metadata() {
    return this._metadata;
  }
  public putMetadata(value: PackSourceInputSystemStateCollectorsMetadata) {
    this._metadata.internalValue = value;
  }
  public resetMetadata() {
    this._metadata.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataInput() {
    return this._metadata.internalValue;
  }

  // ports - computed: false, optional: true, required: false
  private _ports = new PackSourceInputSystemStateCollectorsPortsOutputReference(this, "ports");
  public get ports() {
    return this._ports;
  }
  public putPorts(value: PackSourceInputSystemStateCollectorsPorts) {
    this._ports.internalValue = value;
  }
  public resetPorts() {
    this._ports.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portsInput() {
    return this._ports.internalValue;
  }

  // routes - computed: false, optional: true, required: false
  private _routes = new PackSourceInputSystemStateCollectorsRoutesOutputReference(this, "routes");
  public get routes() {
    return this._routes;
  }
  public putRoutes(value: PackSourceInputSystemStateCollectorsRoutes) {
    this._routes.internalValue = value;
  }
  public resetRoutes() {
    this._routes.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get routesInput() {
    return this._routes.internalValue;
  }

  // services - computed: false, optional: true, required: false
  private _services = new PackSourceInputSystemStateCollectorsServicesOutputReference(this, "services");
  public get services() {
    return this._services;
  }
  public putServices(value: PackSourceInputSystemStateCollectorsServices) {
    this._services.internalValue = value;
  }
  public resetServices() {
    this._services.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get servicesInput() {
    return this._services.internalValue;
  }

  // user - computed: false, optional: true, required: false
  private _user = new PackSourceInputSystemStateCollectorsUserOutputReference(this, "user");
  public get user() {
    return this._user;
  }
  public putUser(value: PackSourceInputSystemStateCollectorsUser) {
    this._user.internalValue = value;
  }
  public resetUser() {
    this._user.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get userInput() {
    return this._user.internalValue;
  }
}
export interface PackSourceInputSystemStateConnections {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#output PackSource#output}
  */
  readonly output: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pipeline PackSource#pipeline}
  */
  readonly pipeline?: string;
}

export function packSourceInputSystemStateConnectionsToTerraform(struct?: PackSourceInputSystemStateConnections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    output: cdktf.stringToTerraform(struct!.output),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
  }
}


export function packSourceInputSystemStateConnectionsToHclTerraform(struct?: PackSourceInputSystemStateConnections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    output: {
      value: cdktf.stringToHclTerraform(struct!.output),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputSystemStateConnectionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackSourceInputSystemStateConnections | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._output !== undefined) {
      hasAnyValues = true;
      internalValueResult.output = this._output;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputSystemStateConnections | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._output = undefined;
      this._pipeline = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._output = value.output;
      this._pipeline = value.pipeline;
    }
  }

  // output - computed: false, optional: false, required: true
  private _output?: string; 
  public get output() {
    return this.getStringAttribute('output');
  }
  public set output(value: string) {
    this._output = value;
  }
  // Temporarily expose input value. Use with caution.
  public get outputInput() {
    return this._output;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }
}

export class PackSourceInputSystemStateConnectionsList extends cdktf.ComplexList {
  public internalValue? : PackSourceInputSystemStateConnections[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackSourceInputSystemStateConnectionsOutputReference {
    return new PackSourceInputSystemStateConnectionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackSourceInputSystemStateMetadata {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#name PackSource#name}
  */
  readonly name: string;
  /**
  * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#value PackSource#value}
  */
  readonly value: string;
}

export function packSourceInputSystemStateMetadataToTerraform(struct?: PackSourceInputSystemStateMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function packSourceInputSystemStateMetadataToHclTerraform(struct?: PackSourceInputSystemStateMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputSystemStateMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackSourceInputSystemStateMetadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputSystemStateMetadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class PackSourceInputSystemStateMetadataList extends cdktf.ComplexList {
  public internalValue? : PackSourceInputSystemStateMetadata[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackSourceInputSystemStateMetadataOutputReference {
    return new PackSourceInputSystemStateMetadataOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackSourceInputSystemStatePersistence {
  /**
  * Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#compress PackSource#compress}
  */
  readonly compress?: string;
  /**
  * Path to use to write metrics. Defaults to $CRIBL_HOME/state/system_state. Default: "$CRIBL_HOME/state/system_state"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#dest_path PackSource#dest_path}
  */
  readonly destPath?: string;
  /**
  * Spool metrics to disk for Cribl Edge and Search. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#enable PackSource#enable}
  */
  readonly enable?: boolean | cdktf.IResolvable;
  /**
  * Maximum disk space allowed to be consumed (examples: 420MB, 4GB). When limit is reached, older data will be deleted. Default: "1GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_data_size PackSource#max_data_size}
  */
  readonly maxDataSize?: string;
  /**
  * Maximum amount of time to retain data (examples: 2h, 4d). When limit is reached, older data will be deleted. Default: "24h"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_data_time PackSource#max_data_time}
  */
  readonly maxDataTime?: string;
  /**
  * Time span for each file bucket. Default: "10m"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#time_window PackSource#time_window}
  */
  readonly timeWindow?: string;
}

export function packSourceInputSystemStatePersistenceToTerraform(struct?: PackSourceInputSystemStatePersistence | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    compress: cdktf.stringToTerraform(struct!.compress),
    dest_path: cdktf.stringToTerraform(struct!.destPath),
    enable: cdktf.booleanToTerraform(struct!.enable),
    max_data_size: cdktf.stringToTerraform(struct!.maxDataSize),
    max_data_time: cdktf.stringToTerraform(struct!.maxDataTime),
    time_window: cdktf.stringToTerraform(struct!.timeWindow),
  }
}


export function packSourceInputSystemStatePersistenceToHclTerraform(struct?: PackSourceInputSystemStatePersistence | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    compress: {
      value: cdktf.stringToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    dest_path: {
      value: cdktf.stringToHclTerraform(struct!.destPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    enable: {
      value: cdktf.booleanToHclTerraform(struct!.enable),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    max_data_size: {
      value: cdktf.stringToHclTerraform(struct!.maxDataSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_data_time: {
      value: cdktf.stringToHclTerraform(struct!.maxDataTime),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    time_window: {
      value: cdktf.stringToHclTerraform(struct!.timeWindow),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputSystemStatePersistenceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputSystemStatePersistence | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._destPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.destPath = this._destPath;
    }
    if (this._enable !== undefined) {
      hasAnyValues = true;
      internalValueResult.enable = this._enable;
    }
    if (this._maxDataSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxDataSize = this._maxDataSize;
    }
    if (this._maxDataTime !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxDataTime = this._maxDataTime;
    }
    if (this._timeWindow !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeWindow = this._timeWindow;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputSystemStatePersistence | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._compress = undefined;
      this._destPath = undefined;
      this._enable = undefined;
      this._maxDataSize = undefined;
      this._maxDataTime = undefined;
      this._timeWindow = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._compress = value.compress;
      this._destPath = value.destPath;
      this._enable = value.enable;
      this._maxDataSize = value.maxDataSize;
      this._maxDataTime = value.maxDataTime;
      this._timeWindow = value.timeWindow;
    }
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: string; 
  public get compress() {
    return this.getStringAttribute('compress');
  }
  public set compress(value: string) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // dest_path - computed: true, optional: true, required: false
  private _destPath?: string; 
  public get destPath() {
    return this.getStringAttribute('dest_path');
  }
  public set destPath(value: string) {
    this._destPath = value;
  }
  public resetDestPath() {
    this._destPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get destPathInput() {
    return this._destPath;
  }

  // enable - computed: true, optional: true, required: false
  private _enable?: boolean | cdktf.IResolvable; 
  public get enable() {
    return this.getBooleanAttribute('enable');
  }
  public set enable(value: boolean | cdktf.IResolvable) {
    this._enable = value;
  }
  public resetEnable() {
    this._enable = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableInput() {
    return this._enable;
  }

  // max_data_size - computed: true, optional: true, required: false
  private _maxDataSize?: string; 
  public get maxDataSize() {
    return this.getStringAttribute('max_data_size');
  }
  public set maxDataSize(value: string) {
    this._maxDataSize = value;
  }
  public resetMaxDataSize() {
    this._maxDataSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxDataSizeInput() {
    return this._maxDataSize;
  }

  // max_data_time - computed: true, optional: true, required: false
  private _maxDataTime?: string; 
  public get maxDataTime() {
    return this.getStringAttribute('max_data_time');
  }
  public set maxDataTime(value: string) {
    this._maxDataTime = value;
  }
  public resetMaxDataTime() {
    this._maxDataTime = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxDataTimeInput() {
    return this._maxDataTime;
  }

  // time_window - computed: true, optional: true, required: false
  private _timeWindow?: string; 
  public get timeWindow() {
    return this.getStringAttribute('time_window');
  }
  public set timeWindow(value: string) {
    this._timeWindow = value;
  }
  public resetTimeWindow() {
    this._timeWindow = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeWindowInput() {
    return this._timeWindow;
  }
}
export interface PackSourceInputSystemStatePq {
  /**
  * The number of events to send downstream before committing that Stream has read them. Default: 42
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#commit_frequency PackSource#commit_frequency}
  */
  readonly commitFrequency?: number;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#compress PackSource#compress}
  */
  readonly compress?: string;
  /**
  * The maximum number of events to hold in memory before writing the events to disk. Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_buffer_size PackSource#max_buffer_size}
  */
  readonly maxBufferSize?: number;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc. Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_file_size PackSource#max_file_size}
  */
  readonly maxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_size PackSource#max_size}
  */
  readonly maxSize?: string;
  /**
  * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine. Default: "always"; must be one of ["smart", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#mode PackSource#mode}
  */
  readonly mode?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#path PackSource#path}
  */
  readonly path?: string;
}

export function packSourceInputSystemStatePqToTerraform(struct?: PackSourceInputSystemStatePq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    commit_frequency: cdktf.numberToTerraform(struct!.commitFrequency),
    compress: cdktf.stringToTerraform(struct!.compress),
    max_buffer_size: cdktf.numberToTerraform(struct!.maxBufferSize),
    max_file_size: cdktf.stringToTerraform(struct!.maxFileSize),
    max_size: cdktf.stringToTerraform(struct!.maxSize),
    mode: cdktf.stringToTerraform(struct!.mode),
    path: cdktf.stringToTerraform(struct!.path),
  }
}


export function packSourceInputSystemStatePqToHclTerraform(struct?: PackSourceInputSystemStatePq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    commit_frequency: {
      value: cdktf.numberToHclTerraform(struct!.commitFrequency),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    compress: {
      value: cdktf.stringToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_buffer_size: {
      value: cdktf.numberToHclTerraform(struct!.maxBufferSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.maxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_size: {
      value: cdktf.stringToHclTerraform(struct!.maxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputSystemStatePqOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputSystemStatePq | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._commitFrequency !== undefined) {
      hasAnyValues = true;
      internalValueResult.commitFrequency = this._commitFrequency;
    }
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._maxBufferSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBufferSize = this._maxBufferSize;
    }
    if (this._maxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxFileSize = this._maxFileSize;
    }
    if (this._maxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxSize = this._maxSize;
    }
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputSystemStatePq | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._commitFrequency = undefined;
      this._compress = undefined;
      this._maxBufferSize = undefined;
      this._maxFileSize = undefined;
      this._maxSize = undefined;
      this._mode = undefined;
      this._path = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._commitFrequency = value.commitFrequency;
      this._compress = value.compress;
      this._maxBufferSize = value.maxBufferSize;
      this._maxFileSize = value.maxFileSize;
      this._maxSize = value.maxSize;
      this._mode = value.mode;
      this._path = value.path;
    }
  }

  // commit_frequency - computed: true, optional: true, required: false
  private _commitFrequency?: number; 
  public get commitFrequency() {
    return this.getNumberAttribute('commit_frequency');
  }
  public set commitFrequency(value: number) {
    this._commitFrequency = value;
  }
  public resetCommitFrequency() {
    this._commitFrequency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commitFrequencyInput() {
    return this._commitFrequency;
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: string; 
  public get compress() {
    return this.getStringAttribute('compress');
  }
  public set compress(value: string) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // max_buffer_size - computed: true, optional: true, required: false
  private _maxBufferSize?: number; 
  public get maxBufferSize() {
    return this.getNumberAttribute('max_buffer_size');
  }
  public set maxBufferSize(value: number) {
    this._maxBufferSize = value;
  }
  public resetMaxBufferSize() {
    this._maxBufferSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBufferSizeInput() {
    return this._maxBufferSize;
  }

  // max_file_size - computed: true, optional: true, required: false
  private _maxFileSize?: string; 
  public get maxFileSize() {
    return this.getStringAttribute('max_file_size');
  }
  public set maxFileSize(value: string) {
    this._maxFileSize = value;
  }
  public resetMaxFileSize() {
    this._maxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxFileSizeInput() {
    return this._maxFileSize;
  }

  // max_size - computed: true, optional: true, required: false
  private _maxSize?: string; 
  public get maxSize() {
    return this.getStringAttribute('max_size');
  }
  public set maxSize(value: string) {
    this._maxSize = value;
  }
  public resetMaxSize() {
    this._maxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxSizeInput() {
    return this._maxSize;
  }

  // mode - computed: true, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // path - computed: true, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }
}
export interface PackSourceInputSystemState {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#collectors PackSource#collectors}
  */
  readonly collectors?: PackSourceInputSystemStateCollectors;
  /**
  * Direct connections to Destinations, and optionally via a Pipeline or a Pack
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#connections PackSource#connections}
  */
  readonly connections?: PackSourceInputSystemStateConnections[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#description PackSource#description}
  */
  readonly description?: string;
  /**
  * Enable to use built-in tools (PowerShell) to collect events instead of native API (default) [Learn more](https://docs.cribl.io/edge/sources-system-state/#advanced-tab). Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#disable_native_module PackSource#disable_native_module}
  */
  readonly disableNativeModule?: boolean | cdktf.IResolvable;
  /**
  * Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#disabled PackSource#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#environment PackSource#environment}
  */
  readonly environment?: string;
  /**
  * Unique ID for this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#id PackSource#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id: string;
  /**
  * Time, in seconds, between consecutive state collections. Default is 300 seconds (5 minutes). Default: 300
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#interval PackSource#interval}
  */
  readonly interval?: number;
  /**
  * Fields to add to events from this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#metadata PackSource#metadata}
  */
  readonly metadata?: PackSourceInputSystemStateMetadata[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#persistence PackSource#persistence}
  */
  readonly persistence?: PackSourceInputSystemStatePersistence;
  /**
  * Pipeline to process data from this Source before sending it through the Routes
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pipeline PackSource#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pq PackSource#pq}
  */
  readonly pq?: PackSourceInputSystemStatePq;
  /**
  * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers). Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pq_enabled PackSource#pq_enabled}
  */
  readonly pqEnabled?: boolean | cdktf.IResolvable;
  /**
  * Select whether to send data to Routes, or directly to Destinations. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#send_to_routes PackSource#send_to_routes}
  */
  readonly sendToRoutes?: boolean | cdktf.IResolvable;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#streamtags PackSource#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * must be "system_state"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#type PackSource#type}
  */
  readonly type: string;
}

export function packSourceInputSystemStateToTerraform(struct?: PackSourceInputSystemState | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    collectors: packSourceInputSystemStateCollectorsToTerraform(struct!.collectors),
    connections: cdktf.listMapper(packSourceInputSystemStateConnectionsToTerraform, false)(struct!.connections),
    description: cdktf.stringToTerraform(struct!.description),
    disable_native_module: cdktf.booleanToTerraform(struct!.disableNativeModule),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    environment: cdktf.stringToTerraform(struct!.environment),
    id: cdktf.stringToTerraform(struct!.id),
    interval: cdktf.numberToTerraform(struct!.interval),
    metadata: cdktf.listMapper(packSourceInputSystemStateMetadataToTerraform, false)(struct!.metadata),
    persistence: packSourceInputSystemStatePersistenceToTerraform(struct!.persistence),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    pq: packSourceInputSystemStatePqToTerraform(struct!.pq),
    pq_enabled: cdktf.booleanToTerraform(struct!.pqEnabled),
    send_to_routes: cdktf.booleanToTerraform(struct!.sendToRoutes),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function packSourceInputSystemStateToHclTerraform(struct?: PackSourceInputSystemState | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    collectors: {
      value: packSourceInputSystemStateCollectorsToHclTerraform(struct!.collectors),
      isBlock: true,
      type: "struct",
      storageClassType: "PackSourceInputSystemStateCollectors",
    },
    connections: {
      value: cdktf.listMapperHcl(packSourceInputSystemStateConnectionsToHclTerraform, false)(struct!.connections),
      isBlock: true,
      type: "list",
      storageClassType: "PackSourceInputSystemStateConnectionsList",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disable_native_module: {
      value: cdktf.booleanToHclTerraform(struct!.disableNativeModule),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    interval: {
      value: cdktf.numberToHclTerraform(struct!.interval),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    metadata: {
      value: cdktf.listMapperHcl(packSourceInputSystemStateMetadataToHclTerraform, false)(struct!.metadata),
      isBlock: true,
      type: "list",
      storageClassType: "PackSourceInputSystemStateMetadataList",
    },
    persistence: {
      value: packSourceInputSystemStatePersistenceToHclTerraform(struct!.persistence),
      isBlock: true,
      type: "struct",
      storageClassType: "PackSourceInputSystemStatePersistence",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq: {
      value: packSourceInputSystemStatePqToHclTerraform(struct!.pq),
      isBlock: true,
      type: "struct",
      storageClassType: "PackSourceInputSystemStatePq",
    },
    pq_enabled: {
      value: cdktf.booleanToHclTerraform(struct!.pqEnabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    send_to_routes: {
      value: cdktf.booleanToHclTerraform(struct!.sendToRoutes),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputSystemStateOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputSystemState | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._collectors?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.collectors = this._collectors?.internalValue;
    }
    if (this._connections?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.connections = this._connections?.internalValue;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._disableNativeModule !== undefined) {
      hasAnyValues = true;
      internalValueResult.disableNativeModule = this._disableNativeModule;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._interval !== undefined) {
      hasAnyValues = true;
      internalValueResult.interval = this._interval;
    }
    if (this._metadata?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadata = this._metadata?.internalValue;
    }
    if (this._persistence?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.persistence = this._persistence?.internalValue;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._pq?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pq = this._pq?.internalValue;
    }
    if (this._pqEnabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqEnabled = this._pqEnabled;
    }
    if (this._sendToRoutes !== undefined) {
      hasAnyValues = true;
      internalValueResult.sendToRoutes = this._sendToRoutes;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputSystemState | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._collectors.internalValue = undefined;
      this._connections.internalValue = undefined;
      this._description = undefined;
      this._disableNativeModule = undefined;
      this._disabled = undefined;
      this._environment = undefined;
      this._id = undefined;
      this._interval = undefined;
      this._metadata.internalValue = undefined;
      this._persistence.internalValue = undefined;
      this._pipeline = undefined;
      this._pq.internalValue = undefined;
      this._pqEnabled = undefined;
      this._sendToRoutes = undefined;
      this._streamtags = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._collectors.internalValue = value.collectors;
      this._connections.internalValue = value.connections;
      this._description = value.description;
      this._disableNativeModule = value.disableNativeModule;
      this._disabled = value.disabled;
      this._environment = value.environment;
      this._id = value.id;
      this._interval = value.interval;
      this._metadata.internalValue = value.metadata;
      this._persistence.internalValue = value.persistence;
      this._pipeline = value.pipeline;
      this._pq.internalValue = value.pq;
      this._pqEnabled = value.pqEnabled;
      this._sendToRoutes = value.sendToRoutes;
      this._streamtags = value.streamtags;
      this._type = value.type;
    }
  }

  // collectors - computed: false, optional: true, required: false
  private _collectors = new PackSourceInputSystemStateCollectorsOutputReference(this, "collectors");
  public get collectors() {
    return this._collectors;
  }
  public putCollectors(value: PackSourceInputSystemStateCollectors) {
    this._collectors.internalValue = value;
  }
  public resetCollectors() {
    this._collectors.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get collectorsInput() {
    return this._collectors.internalValue;
  }

  // connections - computed: false, optional: true, required: false
  private _connections = new PackSourceInputSystemStateConnectionsList(this, "connections", false);
  public get connections() {
    return this._connections;
  }
  public putConnections(value: PackSourceInputSystemStateConnections[] | cdktf.IResolvable) {
    this._connections.internalValue = value;
  }
  public resetConnections() {
    this._connections.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectionsInput() {
    return this._connections.internalValue;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // disable_native_module - computed: true, optional: true, required: false
  private _disableNativeModule?: boolean | cdktf.IResolvable; 
  public get disableNativeModule() {
    return this.getBooleanAttribute('disable_native_module');
  }
  public set disableNativeModule(value: boolean | cdktf.IResolvable) {
    this._disableNativeModule = value;
  }
  public resetDisableNativeModule() {
    this._disableNativeModule = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disableNativeModuleInput() {
    return this._disableNativeModule;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // id - computed: false, optional: false, required: true
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // interval - computed: true, optional: true, required: false
  private _interval?: number; 
  public get interval() {
    return this.getNumberAttribute('interval');
  }
  public set interval(value: number) {
    this._interval = value;
  }
  public resetInterval() {
    this._interval = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get intervalInput() {
    return this._interval;
  }

  // metadata - computed: false, optional: true, required: false
  private _metadata = new PackSourceInputSystemStateMetadataList(this, "metadata", false);
  public get metadata() {
    return this._metadata;
  }
  public putMetadata(value: PackSourceInputSystemStateMetadata[] | cdktf.IResolvable) {
    this._metadata.internalValue = value;
  }
  public resetMetadata() {
    this._metadata.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataInput() {
    return this._metadata.internalValue;
  }

  // persistence - computed: false, optional: true, required: false
  private _persistence = new PackSourceInputSystemStatePersistenceOutputReference(this, "persistence");
  public get persistence() {
    return this._persistence;
  }
  public putPersistence(value: PackSourceInputSystemStatePersistence) {
    this._persistence.internalValue = value;
  }
  public resetPersistence() {
    this._persistence.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get persistenceInput() {
    return this._persistence.internalValue;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // pq - computed: false, optional: true, required: false
  private _pq = new PackSourceInputSystemStatePqOutputReference(this, "pq");
  public get pq() {
    return this._pq;
  }
  public putPq(value: PackSourceInputSystemStatePq) {
    this._pq.internalValue = value;
  }
  public resetPq() {
    this._pq.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqInput() {
    return this._pq.internalValue;
  }

  // pq_enabled - computed: true, optional: true, required: false
  private _pqEnabled?: boolean | cdktf.IResolvable; 
  public get pqEnabled() {
    return this.getBooleanAttribute('pq_enabled');
  }
  public set pqEnabled(value: boolean | cdktf.IResolvable) {
    this._pqEnabled = value;
  }
  public resetPqEnabled() {
    this._pqEnabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqEnabledInput() {
    return this._pqEnabled;
  }

  // send_to_routes - computed: true, optional: true, required: false
  private _sendToRoutes?: boolean | cdktf.IResolvable; 
  public get sendToRoutes() {
    return this.getBooleanAttribute('send_to_routes');
  }
  public set sendToRoutes(value: boolean | cdktf.IResolvable) {
    this._sendToRoutes = value;
  }
  public resetSendToRoutes() {
    this._sendToRoutes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sendToRoutesInput() {
    return this._sendToRoutes;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface PackSourceInputTcpConnections {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#output PackSource#output}
  */
  readonly output: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pipeline PackSource#pipeline}
  */
  readonly pipeline?: string;
}

export function packSourceInputTcpConnectionsToTerraform(struct?: PackSourceInputTcpConnections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    output: cdktf.stringToTerraform(struct!.output),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
  }
}


export function packSourceInputTcpConnectionsToHclTerraform(struct?: PackSourceInputTcpConnections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    output: {
      value: cdktf.stringToHclTerraform(struct!.output),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputTcpConnectionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackSourceInputTcpConnections | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._output !== undefined) {
      hasAnyValues = true;
      internalValueResult.output = this._output;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputTcpConnections | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._output = undefined;
      this._pipeline = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._output = value.output;
      this._pipeline = value.pipeline;
    }
  }

  // output - computed: false, optional: false, required: true
  private _output?: string; 
  public get output() {
    return this.getStringAttribute('output');
  }
  public set output(value: string) {
    this._output = value;
  }
  // Temporarily expose input value. Use with caution.
  public get outputInput() {
    return this._output;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }
}

export class PackSourceInputTcpConnectionsList extends cdktf.ComplexList {
  public internalValue? : PackSourceInputTcpConnections[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackSourceInputTcpConnectionsOutputReference {
    return new PackSourceInputTcpConnectionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackSourceInputTcpMetadata {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#name PackSource#name}
  */
  readonly name: string;
  /**
  * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#value PackSource#value}
  */
  readonly value: string;
}

export function packSourceInputTcpMetadataToTerraform(struct?: PackSourceInputTcpMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function packSourceInputTcpMetadataToHclTerraform(struct?: PackSourceInputTcpMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputTcpMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackSourceInputTcpMetadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputTcpMetadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class PackSourceInputTcpMetadataList extends cdktf.ComplexList {
  public internalValue? : PackSourceInputTcpMetadata[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackSourceInputTcpMetadataOutputReference {
    return new PackSourceInputTcpMetadataOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackSourceInputTcpPq {
  /**
  * The number of events to send downstream before committing that Stream has read them. Default: 42
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#commit_frequency PackSource#commit_frequency}
  */
  readonly commitFrequency?: number;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#compress PackSource#compress}
  */
  readonly compress?: string;
  /**
  * The maximum number of events to hold in memory before writing the events to disk. Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_buffer_size PackSource#max_buffer_size}
  */
  readonly maxBufferSize?: number;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc. Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_file_size PackSource#max_file_size}
  */
  readonly maxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_size PackSource#max_size}
  */
  readonly maxSize?: string;
  /**
  * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine. Default: "always"; must be one of ["smart", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#mode PackSource#mode}
  */
  readonly mode?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#path PackSource#path}
  */
  readonly path?: string;
}

export function packSourceInputTcpPqToTerraform(struct?: PackSourceInputTcpPq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    commit_frequency: cdktf.numberToTerraform(struct!.commitFrequency),
    compress: cdktf.stringToTerraform(struct!.compress),
    max_buffer_size: cdktf.numberToTerraform(struct!.maxBufferSize),
    max_file_size: cdktf.stringToTerraform(struct!.maxFileSize),
    max_size: cdktf.stringToTerraform(struct!.maxSize),
    mode: cdktf.stringToTerraform(struct!.mode),
    path: cdktf.stringToTerraform(struct!.path),
  }
}


export function packSourceInputTcpPqToHclTerraform(struct?: PackSourceInputTcpPq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    commit_frequency: {
      value: cdktf.numberToHclTerraform(struct!.commitFrequency),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    compress: {
      value: cdktf.stringToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_buffer_size: {
      value: cdktf.numberToHclTerraform(struct!.maxBufferSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.maxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_size: {
      value: cdktf.stringToHclTerraform(struct!.maxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputTcpPqOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputTcpPq | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._commitFrequency !== undefined) {
      hasAnyValues = true;
      internalValueResult.commitFrequency = this._commitFrequency;
    }
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._maxBufferSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBufferSize = this._maxBufferSize;
    }
    if (this._maxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxFileSize = this._maxFileSize;
    }
    if (this._maxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxSize = this._maxSize;
    }
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputTcpPq | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._commitFrequency = undefined;
      this._compress = undefined;
      this._maxBufferSize = undefined;
      this._maxFileSize = undefined;
      this._maxSize = undefined;
      this._mode = undefined;
      this._path = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._commitFrequency = value.commitFrequency;
      this._compress = value.compress;
      this._maxBufferSize = value.maxBufferSize;
      this._maxFileSize = value.maxFileSize;
      this._maxSize = value.maxSize;
      this._mode = value.mode;
      this._path = value.path;
    }
  }

  // commit_frequency - computed: true, optional: true, required: false
  private _commitFrequency?: number; 
  public get commitFrequency() {
    return this.getNumberAttribute('commit_frequency');
  }
  public set commitFrequency(value: number) {
    this._commitFrequency = value;
  }
  public resetCommitFrequency() {
    this._commitFrequency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commitFrequencyInput() {
    return this._commitFrequency;
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: string; 
  public get compress() {
    return this.getStringAttribute('compress');
  }
  public set compress(value: string) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // max_buffer_size - computed: true, optional: true, required: false
  private _maxBufferSize?: number; 
  public get maxBufferSize() {
    return this.getNumberAttribute('max_buffer_size');
  }
  public set maxBufferSize(value: number) {
    this._maxBufferSize = value;
  }
  public resetMaxBufferSize() {
    this._maxBufferSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBufferSizeInput() {
    return this._maxBufferSize;
  }

  // max_file_size - computed: true, optional: true, required: false
  private _maxFileSize?: string; 
  public get maxFileSize() {
    return this.getStringAttribute('max_file_size');
  }
  public set maxFileSize(value: string) {
    this._maxFileSize = value;
  }
  public resetMaxFileSize() {
    this._maxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxFileSizeInput() {
    return this._maxFileSize;
  }

  // max_size - computed: true, optional: true, required: false
  private _maxSize?: string; 
  public get maxSize() {
    return this.getStringAttribute('max_size');
  }
  public set maxSize(value: string) {
    this._maxSize = value;
  }
  public resetMaxSize() {
    this._maxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxSizeInput() {
    return this._maxSize;
  }

  // mode - computed: true, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // path - computed: true, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }
}
export interface PackSourceInputTcpPreprocess {
  /**
  * Arguments to be added to the custom command
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#args PackSource#args}
  */
  readonly args?: string[];
  /**
  * Command to feed the data through (via stdin) and process its output (stdout)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#command PackSource#command}
  */
  readonly command?: string;
  /**
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#disabled PackSource#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
}

export function packSourceInputTcpPreprocessToTerraform(struct?: PackSourceInputTcpPreprocess | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    args: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.args),
    command: cdktf.stringToTerraform(struct!.command),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
  }
}


export function packSourceInputTcpPreprocessToHclTerraform(struct?: PackSourceInputTcpPreprocess | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    args: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.args),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    command: {
      value: cdktf.stringToHclTerraform(struct!.command),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputTcpPreprocessOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputTcpPreprocess | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._args !== undefined) {
      hasAnyValues = true;
      internalValueResult.args = this._args;
    }
    if (this._command !== undefined) {
      hasAnyValues = true;
      internalValueResult.command = this._command;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputTcpPreprocess | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._args = undefined;
      this._command = undefined;
      this._disabled = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._args = value.args;
      this._command = value.command;
      this._disabled = value.disabled;
    }
  }

  // args - computed: false, optional: true, required: false
  private _args?: string[]; 
  public get args() {
    return this.getListAttribute('args');
  }
  public set args(value: string[]) {
    this._args = value;
  }
  public resetArgs() {
    this._args = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get argsInput() {
    return this._args;
  }

  // command - computed: false, optional: true, required: false
  private _command?: string; 
  public get command() {
    return this.getStringAttribute('command');
  }
  public set command(value: string) {
    this._command = value;
  }
  public resetCommand() {
    this._command = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commandInput() {
    return this._command;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }
}
export interface PackSourceInputTcpTls {
  /**
  * Path on server containing CA certificates to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#ca_path PackSource#ca_path}
  */
  readonly caPath?: string;
  /**
  * Path on server containing certificates to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#cert_path PackSource#cert_path}
  */
  readonly certPath?: string;
  /**
  * The name of the predefined certificate
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#certificate_name PackSource#certificate_name}
  */
  readonly certificateName?: string;
  /**
  * Parsed as JSON.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#common_name_regex PackSource#common_name_regex}
  */
  readonly commonNameRegex?: string;
  /**
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#disabled PackSource#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_version PackSource#max_version}
  */
  readonly maxVersion?: string;
  /**
  * must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#min_version PackSource#min_version}
  */
  readonly minVersion?: string;
  /**
  * Passphrase to use to decrypt private key
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#passphrase PackSource#passphrase}
  */
  readonly passphrase?: string;
  /**
  * Path on server containing the private key to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#priv_key_path PackSource#priv_key_path}
  */
  readonly privKeyPath?: string;
  /**
  * Parsed as JSON.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#reject_unauthorized PackSource#reject_unauthorized}
  */
  readonly rejectUnauthorized?: string;
  /**
  * Require clients to present their certificates. Used to perform client authentication using SSL certs. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#request_cert PackSource#request_cert}
  */
  readonly requestCert?: boolean | cdktf.IResolvable;
}

export function packSourceInputTcpTlsToTerraform(struct?: PackSourceInputTcpTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ca_path: cdktf.stringToTerraform(struct!.caPath),
    cert_path: cdktf.stringToTerraform(struct!.certPath),
    certificate_name: cdktf.stringToTerraform(struct!.certificateName),
    common_name_regex: cdktf.stringToTerraform(struct!.commonNameRegex),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    max_version: cdktf.stringToTerraform(struct!.maxVersion),
    min_version: cdktf.stringToTerraform(struct!.minVersion),
    passphrase: cdktf.stringToTerraform(struct!.passphrase),
    priv_key_path: cdktf.stringToTerraform(struct!.privKeyPath),
    reject_unauthorized: cdktf.stringToTerraform(struct!.rejectUnauthorized),
    request_cert: cdktf.booleanToTerraform(struct!.requestCert),
  }
}


export function packSourceInputTcpTlsToHclTerraform(struct?: PackSourceInputTcpTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ca_path: {
      value: cdktf.stringToHclTerraform(struct!.caPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    cert_path: {
      value: cdktf.stringToHclTerraform(struct!.certPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    certificate_name: {
      value: cdktf.stringToHclTerraform(struct!.certificateName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    common_name_regex: {
      value: cdktf.stringToHclTerraform(struct!.commonNameRegex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    max_version: {
      value: cdktf.stringToHclTerraform(struct!.maxVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    min_version: {
      value: cdktf.stringToHclTerraform(struct!.minVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    passphrase: {
      value: cdktf.stringToHclTerraform(struct!.passphrase),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    priv_key_path: {
      value: cdktf.stringToHclTerraform(struct!.privKeyPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reject_unauthorized: {
      value: cdktf.stringToHclTerraform(struct!.rejectUnauthorized),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    request_cert: {
      value: cdktf.booleanToHclTerraform(struct!.requestCert),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputTcpTlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputTcpTls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._caPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.caPath = this._caPath;
    }
    if (this._certPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.certPath = this._certPath;
    }
    if (this._certificateName !== undefined) {
      hasAnyValues = true;
      internalValueResult.certificateName = this._certificateName;
    }
    if (this._commonNameRegex !== undefined) {
      hasAnyValues = true;
      internalValueResult.commonNameRegex = this._commonNameRegex;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._maxVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxVersion = this._maxVersion;
    }
    if (this._minVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.minVersion = this._minVersion;
    }
    if (this._passphrase !== undefined) {
      hasAnyValues = true;
      internalValueResult.passphrase = this._passphrase;
    }
    if (this._privKeyPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.privKeyPath = this._privKeyPath;
    }
    if (this._rejectUnauthorized !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectUnauthorized = this._rejectUnauthorized;
    }
    if (this._requestCert !== undefined) {
      hasAnyValues = true;
      internalValueResult.requestCert = this._requestCert;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputTcpTls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._caPath = undefined;
      this._certPath = undefined;
      this._certificateName = undefined;
      this._commonNameRegex = undefined;
      this._disabled = undefined;
      this._maxVersion = undefined;
      this._minVersion = undefined;
      this._passphrase = undefined;
      this._privKeyPath = undefined;
      this._rejectUnauthorized = undefined;
      this._requestCert = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._caPath = value.caPath;
      this._certPath = value.certPath;
      this._certificateName = value.certificateName;
      this._commonNameRegex = value.commonNameRegex;
      this._disabled = value.disabled;
      this._maxVersion = value.maxVersion;
      this._minVersion = value.minVersion;
      this._passphrase = value.passphrase;
      this._privKeyPath = value.privKeyPath;
      this._rejectUnauthorized = value.rejectUnauthorized;
      this._requestCert = value.requestCert;
    }
  }

  // ca_path - computed: false, optional: true, required: false
  private _caPath?: string; 
  public get caPath() {
    return this.getStringAttribute('ca_path');
  }
  public set caPath(value: string) {
    this._caPath = value;
  }
  public resetCaPath() {
    this._caPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get caPathInput() {
    return this._caPath;
  }

  // cert_path - computed: false, optional: true, required: false
  private _certPath?: string; 
  public get certPath() {
    return this.getStringAttribute('cert_path');
  }
  public set certPath(value: string) {
    this._certPath = value;
  }
  public resetCertPath() {
    this._certPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certPathInput() {
    return this._certPath;
  }

  // certificate_name - computed: false, optional: true, required: false
  private _certificateName?: string; 
  public get certificateName() {
    return this.getStringAttribute('certificate_name');
  }
  public set certificateName(value: string) {
    this._certificateName = value;
  }
  public resetCertificateName() {
    this._certificateName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certificateNameInput() {
    return this._certificateName;
  }

  // common_name_regex - computed: false, optional: true, required: false
  private _commonNameRegex?: string; 
  public get commonNameRegex() {
    return this.getStringAttribute('common_name_regex');
  }
  public set commonNameRegex(value: string) {
    this._commonNameRegex = value;
  }
  public resetCommonNameRegex() {
    this._commonNameRegex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commonNameRegexInput() {
    return this._commonNameRegex;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // max_version - computed: false, optional: true, required: false
  private _maxVersion?: string; 
  public get maxVersion() {
    return this.getStringAttribute('max_version');
  }
  public set maxVersion(value: string) {
    this._maxVersion = value;
  }
  public resetMaxVersion() {
    this._maxVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxVersionInput() {
    return this._maxVersion;
  }

  // min_version - computed: false, optional: true, required: false
  private _minVersion?: string; 
  public get minVersion() {
    return this.getStringAttribute('min_version');
  }
  public set minVersion(value: string) {
    this._minVersion = value;
  }
  public resetMinVersion() {
    this._minVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get minVersionInput() {
    return this._minVersion;
  }

  // passphrase - computed: false, optional: true, required: false
  private _passphrase?: string; 
  public get passphrase() {
    return this.getStringAttribute('passphrase');
  }
  public set passphrase(value: string) {
    this._passphrase = value;
  }
  public resetPassphrase() {
    this._passphrase = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passphraseInput() {
    return this._passphrase;
  }

  // priv_key_path - computed: false, optional: true, required: false
  private _privKeyPath?: string; 
  public get privKeyPath() {
    return this.getStringAttribute('priv_key_path');
  }
  public set privKeyPath(value: string) {
    this._privKeyPath = value;
  }
  public resetPrivKeyPath() {
    this._privKeyPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get privKeyPathInput() {
    return this._privKeyPath;
  }

  // reject_unauthorized - computed: false, optional: true, required: false
  private _rejectUnauthorized?: string; 
  public get rejectUnauthorized() {
    return this.getStringAttribute('reject_unauthorized');
  }
  public set rejectUnauthorized(value: string) {
    this._rejectUnauthorized = value;
  }
  public resetRejectUnauthorized() {
    this._rejectUnauthorized = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectUnauthorizedInput() {
    return this._rejectUnauthorized;
  }

  // request_cert - computed: true, optional: true, required: false
  private _requestCert?: boolean | cdktf.IResolvable; 
  public get requestCert() {
    return this.getBooleanAttribute('request_cert');
  }
  public set requestCert(value: boolean | cdktf.IResolvable) {
    this._requestCert = value;
  }
  public resetRequestCert() {
    this._requestCert = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestCertInput() {
    return this._requestCert;
  }
}
export interface PackSourceInputTcp {
  /**
  * Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate. Default: "manual"; must be one of ["manual", "secret"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#auth_type PackSource#auth_type}
  */
  readonly authType?: string;
  /**
  * A list of event-breaking rulesets that will be applied, in order, to the input data stream
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#breaker_rulesets PackSource#breaker_rulesets}
  */
  readonly breakerRulesets?: string[];
  /**
  * Direct connections to Destinations, and optionally via a Pipeline or a Pack
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#connections PackSource#connections}
  */
  readonly connections?: PackSourceInputTcpConnections[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#description PackSource#description}
  */
  readonly description?: string;
  /**
  * Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#disabled PackSource#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * Client will pass the header record with every new connection. The header can contain an authToken, and an object with a list of fields and values to add to every event. These fields can be used to simplify Event Breaker selection, routing, etc. Header has this format, and must be followed by a newline: { "authToken" : "myToken", "fields": { "field1": "value1", "field2": "value2" } }. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#enable_header PackSource#enable_header}
  */
  readonly enableHeader?: boolean | cdktf.IResolvable;
  /**
  * Enable if the connection is proxied by a device that supports Proxy Protocol V1 or V2. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#enable_proxy_header PackSource#enable_proxy_header}
  */
  readonly enableProxyHeader?: boolean | cdktf.IResolvable;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#environment PackSource#environment}
  */
  readonly environment?: string;
  /**
  * Address to bind on. Defaults to 0.0.0.0 (all addresses). Default: "0.0.0.0"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#host PackSource#host}
  */
  readonly host?: string;
  /**
  * Unique ID for this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#id PackSource#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * Regex matching IP addresses that are allowed to establish a connection. Default: "/.* /"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#ip_whitelist_regex PackSource#ip_whitelist_regex}
   *
  * Note: The above comment contained a comment block ending sequence (* followed by /). We have introduced a space between to prevent syntax errors. Please ignore the space.
  */
  readonly ipWhitelistRegex?: string;
  /**
  * Maximum number of active connections allowed per Worker Process. Use 0 for unlimited. Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_active_cxn PackSource#max_active_cxn}
  */
  readonly maxActiveCxn?: number;
  /**
  * Fields to add to events from this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#metadata PackSource#metadata}
  */
  readonly metadata?: PackSourceInputTcpMetadata[] | cdktf.IResolvable;
  /**
  * Pipeline to process data from this Source before sending it through the Routes
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pipeline PackSource#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Port to listen on
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#port PackSource#port}
  */
  readonly port: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pq PackSource#pq}
  */
  readonly pq?: PackSourceInputTcpPq;
  /**
  * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers). Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pq_enabled PackSource#pq_enabled}
  */
  readonly pqEnabled?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#preprocess PackSource#preprocess}
  */
  readonly preprocess?: PackSourceInputTcpPreprocess;
  /**
  * Select whether to send data to Routes, or directly to Destinations. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#send_to_routes PackSource#send_to_routes}
  */
  readonly sendToRoutes?: boolean | cdktf.IResolvable;
  /**
  * How long the server will wait after initiating a closure for a client to close its end of the connection. If the client doesn't close the connection within this time, the server will forcefully terminate the socket to prevent resource leaks and ensure efficient connection cleanup and system stability. Leave at 0 for no inactive socket monitoring. Default: 30
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#socket_ending_max_wait PackSource#socket_ending_max_wait}
  */
  readonly socketEndingMaxWait?: number;
  /**
  * How long @{product} should wait before assuming that an inactive socket has timed out. After this time, the connection will be closed. Leave at 0 for no inactive socket monitoring. Default: 0
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#socket_idle_timeout PackSource#socket_idle_timeout}
  */
  readonly socketIdleTimeout?: number;
  /**
  * The maximum duration a socket can remain open, even if active. This helps manage resources and mitigate issues caused by TCP pinning. Set to 0 to disable. Default: 0
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#socket_max_lifespan PackSource#socket_max_lifespan}
  */
  readonly socketMaxLifespan?: number;
  /**
  * How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines. Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#stale_channel_flush_ms PackSource#stale_channel_flush_ms}
  */
  readonly staleChannelFlushMs?: number;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#streamtags PackSource#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#tls PackSource#tls}
  */
  readonly tls?: PackSourceInputTcpTls;
  /**
  * must be "tcp"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#type PackSource#type}
  */
  readonly type?: string;
}

export function packSourceInputTcpToTerraform(struct?: PackSourceInputTcp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    auth_type: cdktf.stringToTerraform(struct!.authType),
    breaker_rulesets: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.breakerRulesets),
    connections: cdktf.listMapper(packSourceInputTcpConnectionsToTerraform, false)(struct!.connections),
    description: cdktf.stringToTerraform(struct!.description),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    enable_header: cdktf.booleanToTerraform(struct!.enableHeader),
    enable_proxy_header: cdktf.booleanToTerraform(struct!.enableProxyHeader),
    environment: cdktf.stringToTerraform(struct!.environment),
    host: cdktf.stringToTerraform(struct!.host),
    id: cdktf.stringToTerraform(struct!.id),
    ip_whitelist_regex: cdktf.stringToTerraform(struct!.ipWhitelistRegex),
    max_active_cxn: cdktf.numberToTerraform(struct!.maxActiveCxn),
    metadata: cdktf.listMapper(packSourceInputTcpMetadataToTerraform, false)(struct!.metadata),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    port: cdktf.numberToTerraform(struct!.port),
    pq: packSourceInputTcpPqToTerraform(struct!.pq),
    pq_enabled: cdktf.booleanToTerraform(struct!.pqEnabled),
    preprocess: packSourceInputTcpPreprocessToTerraform(struct!.preprocess),
    send_to_routes: cdktf.booleanToTerraform(struct!.sendToRoutes),
    socket_ending_max_wait: cdktf.numberToTerraform(struct!.socketEndingMaxWait),
    socket_idle_timeout: cdktf.numberToTerraform(struct!.socketIdleTimeout),
    socket_max_lifespan: cdktf.numberToTerraform(struct!.socketMaxLifespan),
    stale_channel_flush_ms: cdktf.numberToTerraform(struct!.staleChannelFlushMs),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    tls: packSourceInputTcpTlsToTerraform(struct!.tls),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function packSourceInputTcpToHclTerraform(struct?: PackSourceInputTcp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    auth_type: {
      value: cdktf.stringToHclTerraform(struct!.authType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    breaker_rulesets: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.breakerRulesets),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    connections: {
      value: cdktf.listMapperHcl(packSourceInputTcpConnectionsToHclTerraform, false)(struct!.connections),
      isBlock: true,
      type: "list",
      storageClassType: "PackSourceInputTcpConnectionsList",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    enable_header: {
      value: cdktf.booleanToHclTerraform(struct!.enableHeader),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    enable_proxy_header: {
      value: cdktf.booleanToHclTerraform(struct!.enableProxyHeader),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    host: {
      value: cdktf.stringToHclTerraform(struct!.host),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ip_whitelist_regex: {
      value: cdktf.stringToHclTerraform(struct!.ipWhitelistRegex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_active_cxn: {
      value: cdktf.numberToHclTerraform(struct!.maxActiveCxn),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    metadata: {
      value: cdktf.listMapperHcl(packSourceInputTcpMetadataToHclTerraform, false)(struct!.metadata),
      isBlock: true,
      type: "list",
      storageClassType: "PackSourceInputTcpMetadataList",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    pq: {
      value: packSourceInputTcpPqToHclTerraform(struct!.pq),
      isBlock: true,
      type: "struct",
      storageClassType: "PackSourceInputTcpPq",
    },
    pq_enabled: {
      value: cdktf.booleanToHclTerraform(struct!.pqEnabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    preprocess: {
      value: packSourceInputTcpPreprocessToHclTerraform(struct!.preprocess),
      isBlock: true,
      type: "struct",
      storageClassType: "PackSourceInputTcpPreprocess",
    },
    send_to_routes: {
      value: cdktf.booleanToHclTerraform(struct!.sendToRoutes),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    socket_ending_max_wait: {
      value: cdktf.numberToHclTerraform(struct!.socketEndingMaxWait),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    socket_idle_timeout: {
      value: cdktf.numberToHclTerraform(struct!.socketIdleTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    socket_max_lifespan: {
      value: cdktf.numberToHclTerraform(struct!.socketMaxLifespan),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    stale_channel_flush_ms: {
      value: cdktf.numberToHclTerraform(struct!.staleChannelFlushMs),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    tls: {
      value: packSourceInputTcpTlsToHclTerraform(struct!.tls),
      isBlock: true,
      type: "struct",
      storageClassType: "PackSourceInputTcpTls",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputTcpOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputTcp | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._authType !== undefined) {
      hasAnyValues = true;
      internalValueResult.authType = this._authType;
    }
    if (this._breakerRulesets !== undefined) {
      hasAnyValues = true;
      internalValueResult.breakerRulesets = this._breakerRulesets;
    }
    if (this._connections?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.connections = this._connections?.internalValue;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._enableHeader !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableHeader = this._enableHeader;
    }
    if (this._enableProxyHeader !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableProxyHeader = this._enableProxyHeader;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._host !== undefined) {
      hasAnyValues = true;
      internalValueResult.host = this._host;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._ipWhitelistRegex !== undefined) {
      hasAnyValues = true;
      internalValueResult.ipWhitelistRegex = this._ipWhitelistRegex;
    }
    if (this._maxActiveCxn !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxActiveCxn = this._maxActiveCxn;
    }
    if (this._metadata?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadata = this._metadata?.internalValue;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._pq?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pq = this._pq?.internalValue;
    }
    if (this._pqEnabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqEnabled = this._pqEnabled;
    }
    if (this._preprocess?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.preprocess = this._preprocess?.internalValue;
    }
    if (this._sendToRoutes !== undefined) {
      hasAnyValues = true;
      internalValueResult.sendToRoutes = this._sendToRoutes;
    }
    if (this._socketEndingMaxWait !== undefined) {
      hasAnyValues = true;
      internalValueResult.socketEndingMaxWait = this._socketEndingMaxWait;
    }
    if (this._socketIdleTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.socketIdleTimeout = this._socketIdleTimeout;
    }
    if (this._socketMaxLifespan !== undefined) {
      hasAnyValues = true;
      internalValueResult.socketMaxLifespan = this._socketMaxLifespan;
    }
    if (this._staleChannelFlushMs !== undefined) {
      hasAnyValues = true;
      internalValueResult.staleChannelFlushMs = this._staleChannelFlushMs;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._tls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tls = this._tls?.internalValue;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputTcp | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._authType = undefined;
      this._breakerRulesets = undefined;
      this._connections.internalValue = undefined;
      this._description = undefined;
      this._disabled = undefined;
      this._enableHeader = undefined;
      this._enableProxyHeader = undefined;
      this._environment = undefined;
      this._host = undefined;
      this._id = undefined;
      this._ipWhitelistRegex = undefined;
      this._maxActiveCxn = undefined;
      this._metadata.internalValue = undefined;
      this._pipeline = undefined;
      this._port = undefined;
      this._pq.internalValue = undefined;
      this._pqEnabled = undefined;
      this._preprocess.internalValue = undefined;
      this._sendToRoutes = undefined;
      this._socketEndingMaxWait = undefined;
      this._socketIdleTimeout = undefined;
      this._socketMaxLifespan = undefined;
      this._staleChannelFlushMs = undefined;
      this._streamtags = undefined;
      this._tls.internalValue = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._authType = value.authType;
      this._breakerRulesets = value.breakerRulesets;
      this._connections.internalValue = value.connections;
      this._description = value.description;
      this._disabled = value.disabled;
      this._enableHeader = value.enableHeader;
      this._enableProxyHeader = value.enableProxyHeader;
      this._environment = value.environment;
      this._host = value.host;
      this._id = value.id;
      this._ipWhitelistRegex = value.ipWhitelistRegex;
      this._maxActiveCxn = value.maxActiveCxn;
      this._metadata.internalValue = value.metadata;
      this._pipeline = value.pipeline;
      this._port = value.port;
      this._pq.internalValue = value.pq;
      this._pqEnabled = value.pqEnabled;
      this._preprocess.internalValue = value.preprocess;
      this._sendToRoutes = value.sendToRoutes;
      this._socketEndingMaxWait = value.socketEndingMaxWait;
      this._socketIdleTimeout = value.socketIdleTimeout;
      this._socketMaxLifespan = value.socketMaxLifespan;
      this._staleChannelFlushMs = value.staleChannelFlushMs;
      this._streamtags = value.streamtags;
      this._tls.internalValue = value.tls;
      this._type = value.type;
    }
  }

  // auth_type - computed: true, optional: true, required: false
  private _authType?: string; 
  public get authType() {
    return this.getStringAttribute('auth_type');
  }
  public set authType(value: string) {
    this._authType = value;
  }
  public resetAuthType() {
    this._authType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authTypeInput() {
    return this._authType;
  }

  // breaker_rulesets - computed: false, optional: true, required: false
  private _breakerRulesets?: string[]; 
  public get breakerRulesets() {
    return this.getListAttribute('breaker_rulesets');
  }
  public set breakerRulesets(value: string[]) {
    this._breakerRulesets = value;
  }
  public resetBreakerRulesets() {
    this._breakerRulesets = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get breakerRulesetsInput() {
    return this._breakerRulesets;
  }

  // connections - computed: false, optional: true, required: false
  private _connections = new PackSourceInputTcpConnectionsList(this, "connections", false);
  public get connections() {
    return this._connections;
  }
  public putConnections(value: PackSourceInputTcpConnections[] | cdktf.IResolvable) {
    this._connections.internalValue = value;
  }
  public resetConnections() {
    this._connections.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectionsInput() {
    return this._connections.internalValue;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // enable_header - computed: true, optional: true, required: false
  private _enableHeader?: boolean | cdktf.IResolvable; 
  public get enableHeader() {
    return this.getBooleanAttribute('enable_header');
  }
  public set enableHeader(value: boolean | cdktf.IResolvable) {
    this._enableHeader = value;
  }
  public resetEnableHeader() {
    this._enableHeader = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableHeaderInput() {
    return this._enableHeader;
  }

  // enable_proxy_header - computed: true, optional: true, required: false
  private _enableProxyHeader?: boolean | cdktf.IResolvable; 
  public get enableProxyHeader() {
    return this.getBooleanAttribute('enable_proxy_header');
  }
  public set enableProxyHeader(value: boolean | cdktf.IResolvable) {
    this._enableProxyHeader = value;
  }
  public resetEnableProxyHeader() {
    this._enableProxyHeader = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableProxyHeaderInput() {
    return this._enableProxyHeader;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // host - computed: true, optional: true, required: false
  private _host?: string; 
  public get host() {
    return this.getStringAttribute('host');
  }
  public set host(value: string) {
    this._host = value;
  }
  public resetHost() {
    this._host = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostInput() {
    return this._host;
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // ip_whitelist_regex - computed: true, optional: true, required: false
  private _ipWhitelistRegex?: string; 
  public get ipWhitelistRegex() {
    return this.getStringAttribute('ip_whitelist_regex');
  }
  public set ipWhitelistRegex(value: string) {
    this._ipWhitelistRegex = value;
  }
  public resetIpWhitelistRegex() {
    this._ipWhitelistRegex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ipWhitelistRegexInput() {
    return this._ipWhitelistRegex;
  }

  // max_active_cxn - computed: true, optional: true, required: false
  private _maxActiveCxn?: number; 
  public get maxActiveCxn() {
    return this.getNumberAttribute('max_active_cxn');
  }
  public set maxActiveCxn(value: number) {
    this._maxActiveCxn = value;
  }
  public resetMaxActiveCxn() {
    this._maxActiveCxn = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxActiveCxnInput() {
    return this._maxActiveCxn;
  }

  // metadata - computed: false, optional: true, required: false
  private _metadata = new PackSourceInputTcpMetadataList(this, "metadata", false);
  public get metadata() {
    return this._metadata;
  }
  public putMetadata(value: PackSourceInputTcpMetadata[] | cdktf.IResolvable) {
    this._metadata.internalValue = value;
  }
  public resetMetadata() {
    this._metadata.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataInput() {
    return this._metadata.internalValue;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // port - computed: false, optional: false, required: true
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // pq - computed: false, optional: true, required: false
  private _pq = new PackSourceInputTcpPqOutputReference(this, "pq");
  public get pq() {
    return this._pq;
  }
  public putPq(value: PackSourceInputTcpPq) {
    this._pq.internalValue = value;
  }
  public resetPq() {
    this._pq.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqInput() {
    return this._pq.internalValue;
  }

  // pq_enabled - computed: true, optional: true, required: false
  private _pqEnabled?: boolean | cdktf.IResolvable; 
  public get pqEnabled() {
    return this.getBooleanAttribute('pq_enabled');
  }
  public set pqEnabled(value: boolean | cdktf.IResolvable) {
    this._pqEnabled = value;
  }
  public resetPqEnabled() {
    this._pqEnabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqEnabledInput() {
    return this._pqEnabled;
  }

  // preprocess - computed: false, optional: true, required: false
  private _preprocess = new PackSourceInputTcpPreprocessOutputReference(this, "preprocess");
  public get preprocess() {
    return this._preprocess;
  }
  public putPreprocess(value: PackSourceInputTcpPreprocess) {
    this._preprocess.internalValue = value;
  }
  public resetPreprocess() {
    this._preprocess.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get preprocessInput() {
    return this._preprocess.internalValue;
  }

  // send_to_routes - computed: true, optional: true, required: false
  private _sendToRoutes?: boolean | cdktf.IResolvable; 
  public get sendToRoutes() {
    return this.getBooleanAttribute('send_to_routes');
  }
  public set sendToRoutes(value: boolean | cdktf.IResolvable) {
    this._sendToRoutes = value;
  }
  public resetSendToRoutes() {
    this._sendToRoutes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sendToRoutesInput() {
    return this._sendToRoutes;
  }

  // socket_ending_max_wait - computed: true, optional: true, required: false
  private _socketEndingMaxWait?: number; 
  public get socketEndingMaxWait() {
    return this.getNumberAttribute('socket_ending_max_wait');
  }
  public set socketEndingMaxWait(value: number) {
    this._socketEndingMaxWait = value;
  }
  public resetSocketEndingMaxWait() {
    this._socketEndingMaxWait = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get socketEndingMaxWaitInput() {
    return this._socketEndingMaxWait;
  }

  // socket_idle_timeout - computed: true, optional: true, required: false
  private _socketIdleTimeout?: number; 
  public get socketIdleTimeout() {
    return this.getNumberAttribute('socket_idle_timeout');
  }
  public set socketIdleTimeout(value: number) {
    this._socketIdleTimeout = value;
  }
  public resetSocketIdleTimeout() {
    this._socketIdleTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get socketIdleTimeoutInput() {
    return this._socketIdleTimeout;
  }

  // socket_max_lifespan - computed: true, optional: true, required: false
  private _socketMaxLifespan?: number; 
  public get socketMaxLifespan() {
    return this.getNumberAttribute('socket_max_lifespan');
  }
  public set socketMaxLifespan(value: number) {
    this._socketMaxLifespan = value;
  }
  public resetSocketMaxLifespan() {
    this._socketMaxLifespan = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get socketMaxLifespanInput() {
    return this._socketMaxLifespan;
  }

  // stale_channel_flush_ms - computed: true, optional: true, required: false
  private _staleChannelFlushMs?: number; 
  public get staleChannelFlushMs() {
    return this.getNumberAttribute('stale_channel_flush_ms');
  }
  public set staleChannelFlushMs(value: number) {
    this._staleChannelFlushMs = value;
  }
  public resetStaleChannelFlushMs() {
    this._staleChannelFlushMs = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get staleChannelFlushMsInput() {
    return this._staleChannelFlushMs;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // tls - computed: false, optional: true, required: false
  private _tls = new PackSourceInputTcpTlsOutputReference(this, "tls");
  public get tls() {
    return this._tls;
  }
  public putTls(value: PackSourceInputTcpTls) {
    this._tls.internalValue = value;
  }
  public resetTls() {
    this._tls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsInput() {
    return this._tls.internalValue;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface PackSourceInputTcpjsonConnections {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#output PackSource#output}
  */
  readonly output: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pipeline PackSource#pipeline}
  */
  readonly pipeline?: string;
}

export function packSourceInputTcpjsonConnectionsToTerraform(struct?: PackSourceInputTcpjsonConnections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    output: cdktf.stringToTerraform(struct!.output),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
  }
}


export function packSourceInputTcpjsonConnectionsToHclTerraform(struct?: PackSourceInputTcpjsonConnections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    output: {
      value: cdktf.stringToHclTerraform(struct!.output),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputTcpjsonConnectionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackSourceInputTcpjsonConnections | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._output !== undefined) {
      hasAnyValues = true;
      internalValueResult.output = this._output;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputTcpjsonConnections | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._output = undefined;
      this._pipeline = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._output = value.output;
      this._pipeline = value.pipeline;
    }
  }

  // output - computed: false, optional: false, required: true
  private _output?: string; 
  public get output() {
    return this.getStringAttribute('output');
  }
  public set output(value: string) {
    this._output = value;
  }
  // Temporarily expose input value. Use with caution.
  public get outputInput() {
    return this._output;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }
}

export class PackSourceInputTcpjsonConnectionsList extends cdktf.ComplexList {
  public internalValue? : PackSourceInputTcpjsonConnections[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackSourceInputTcpjsonConnectionsOutputReference {
    return new PackSourceInputTcpjsonConnectionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackSourceInputTcpjsonMetadata {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#name PackSource#name}
  */
  readonly name: string;
  /**
  * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#value PackSource#value}
  */
  readonly value: string;
}

export function packSourceInputTcpjsonMetadataToTerraform(struct?: PackSourceInputTcpjsonMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function packSourceInputTcpjsonMetadataToHclTerraform(struct?: PackSourceInputTcpjsonMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputTcpjsonMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackSourceInputTcpjsonMetadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputTcpjsonMetadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class PackSourceInputTcpjsonMetadataList extends cdktf.ComplexList {
  public internalValue? : PackSourceInputTcpjsonMetadata[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackSourceInputTcpjsonMetadataOutputReference {
    return new PackSourceInputTcpjsonMetadataOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackSourceInputTcpjsonPq {
  /**
  * The number of events to send downstream before committing that Stream has read them. Default: 42
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#commit_frequency PackSource#commit_frequency}
  */
  readonly commitFrequency?: number;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#compress PackSource#compress}
  */
  readonly compress?: string;
  /**
  * The maximum number of events to hold in memory before writing the events to disk. Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_buffer_size PackSource#max_buffer_size}
  */
  readonly maxBufferSize?: number;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc. Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_file_size PackSource#max_file_size}
  */
  readonly maxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_size PackSource#max_size}
  */
  readonly maxSize?: string;
  /**
  * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine. Default: "always"; must be one of ["smart", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#mode PackSource#mode}
  */
  readonly mode?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#path PackSource#path}
  */
  readonly path?: string;
}

export function packSourceInputTcpjsonPqToTerraform(struct?: PackSourceInputTcpjsonPq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    commit_frequency: cdktf.numberToTerraform(struct!.commitFrequency),
    compress: cdktf.stringToTerraform(struct!.compress),
    max_buffer_size: cdktf.numberToTerraform(struct!.maxBufferSize),
    max_file_size: cdktf.stringToTerraform(struct!.maxFileSize),
    max_size: cdktf.stringToTerraform(struct!.maxSize),
    mode: cdktf.stringToTerraform(struct!.mode),
    path: cdktf.stringToTerraform(struct!.path),
  }
}


export function packSourceInputTcpjsonPqToHclTerraform(struct?: PackSourceInputTcpjsonPq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    commit_frequency: {
      value: cdktf.numberToHclTerraform(struct!.commitFrequency),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    compress: {
      value: cdktf.stringToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_buffer_size: {
      value: cdktf.numberToHclTerraform(struct!.maxBufferSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.maxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_size: {
      value: cdktf.stringToHclTerraform(struct!.maxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputTcpjsonPqOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputTcpjsonPq | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._commitFrequency !== undefined) {
      hasAnyValues = true;
      internalValueResult.commitFrequency = this._commitFrequency;
    }
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._maxBufferSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBufferSize = this._maxBufferSize;
    }
    if (this._maxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxFileSize = this._maxFileSize;
    }
    if (this._maxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxSize = this._maxSize;
    }
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputTcpjsonPq | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._commitFrequency = undefined;
      this._compress = undefined;
      this._maxBufferSize = undefined;
      this._maxFileSize = undefined;
      this._maxSize = undefined;
      this._mode = undefined;
      this._path = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._commitFrequency = value.commitFrequency;
      this._compress = value.compress;
      this._maxBufferSize = value.maxBufferSize;
      this._maxFileSize = value.maxFileSize;
      this._maxSize = value.maxSize;
      this._mode = value.mode;
      this._path = value.path;
    }
  }

  // commit_frequency - computed: true, optional: true, required: false
  private _commitFrequency?: number; 
  public get commitFrequency() {
    return this.getNumberAttribute('commit_frequency');
  }
  public set commitFrequency(value: number) {
    this._commitFrequency = value;
  }
  public resetCommitFrequency() {
    this._commitFrequency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commitFrequencyInput() {
    return this._commitFrequency;
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: string; 
  public get compress() {
    return this.getStringAttribute('compress');
  }
  public set compress(value: string) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // max_buffer_size - computed: true, optional: true, required: false
  private _maxBufferSize?: number; 
  public get maxBufferSize() {
    return this.getNumberAttribute('max_buffer_size');
  }
  public set maxBufferSize(value: number) {
    this._maxBufferSize = value;
  }
  public resetMaxBufferSize() {
    this._maxBufferSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBufferSizeInput() {
    return this._maxBufferSize;
  }

  // max_file_size - computed: true, optional: true, required: false
  private _maxFileSize?: string; 
  public get maxFileSize() {
    return this.getStringAttribute('max_file_size');
  }
  public set maxFileSize(value: string) {
    this._maxFileSize = value;
  }
  public resetMaxFileSize() {
    this._maxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxFileSizeInput() {
    return this._maxFileSize;
  }

  // max_size - computed: true, optional: true, required: false
  private _maxSize?: string; 
  public get maxSize() {
    return this.getStringAttribute('max_size');
  }
  public set maxSize(value: string) {
    this._maxSize = value;
  }
  public resetMaxSize() {
    this._maxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxSizeInput() {
    return this._maxSize;
  }

  // mode - computed: true, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // path - computed: true, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }
}
export interface PackSourceInputTcpjsonTls {
  /**
  * Path on server containing CA certificates to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#ca_path PackSource#ca_path}
  */
  readonly caPath?: string;
  /**
  * Path on server containing certificates to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#cert_path PackSource#cert_path}
  */
  readonly certPath?: string;
  /**
  * The name of the predefined certificate
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#certificate_name PackSource#certificate_name}
  */
  readonly certificateName?: string;
  /**
  * Parsed as JSON.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#common_name_regex PackSource#common_name_regex}
  */
  readonly commonNameRegex?: string;
  /**
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#disabled PackSource#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_version PackSource#max_version}
  */
  readonly maxVersion?: string;
  /**
  * must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#min_version PackSource#min_version}
  */
  readonly minVersion?: string;
  /**
  * Passphrase to use to decrypt private key
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#passphrase PackSource#passphrase}
  */
  readonly passphrase?: string;
  /**
  * Path on server containing the private key to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#priv_key_path PackSource#priv_key_path}
  */
  readonly privKeyPath?: string;
  /**
  * Parsed as JSON.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#reject_unauthorized PackSource#reject_unauthorized}
  */
  readonly rejectUnauthorized?: string;
  /**
  * Require clients to present their certificates. Used to perform client authentication using SSL certs. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#request_cert PackSource#request_cert}
  */
  readonly requestCert?: boolean | cdktf.IResolvable;
}

export function packSourceInputTcpjsonTlsToTerraform(struct?: PackSourceInputTcpjsonTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ca_path: cdktf.stringToTerraform(struct!.caPath),
    cert_path: cdktf.stringToTerraform(struct!.certPath),
    certificate_name: cdktf.stringToTerraform(struct!.certificateName),
    common_name_regex: cdktf.stringToTerraform(struct!.commonNameRegex),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    max_version: cdktf.stringToTerraform(struct!.maxVersion),
    min_version: cdktf.stringToTerraform(struct!.minVersion),
    passphrase: cdktf.stringToTerraform(struct!.passphrase),
    priv_key_path: cdktf.stringToTerraform(struct!.privKeyPath),
    reject_unauthorized: cdktf.stringToTerraform(struct!.rejectUnauthorized),
    request_cert: cdktf.booleanToTerraform(struct!.requestCert),
  }
}


export function packSourceInputTcpjsonTlsToHclTerraform(struct?: PackSourceInputTcpjsonTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ca_path: {
      value: cdktf.stringToHclTerraform(struct!.caPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    cert_path: {
      value: cdktf.stringToHclTerraform(struct!.certPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    certificate_name: {
      value: cdktf.stringToHclTerraform(struct!.certificateName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    common_name_regex: {
      value: cdktf.stringToHclTerraform(struct!.commonNameRegex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    max_version: {
      value: cdktf.stringToHclTerraform(struct!.maxVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    min_version: {
      value: cdktf.stringToHclTerraform(struct!.minVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    passphrase: {
      value: cdktf.stringToHclTerraform(struct!.passphrase),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    priv_key_path: {
      value: cdktf.stringToHclTerraform(struct!.privKeyPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reject_unauthorized: {
      value: cdktf.stringToHclTerraform(struct!.rejectUnauthorized),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    request_cert: {
      value: cdktf.booleanToHclTerraform(struct!.requestCert),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputTcpjsonTlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputTcpjsonTls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._caPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.caPath = this._caPath;
    }
    if (this._certPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.certPath = this._certPath;
    }
    if (this._certificateName !== undefined) {
      hasAnyValues = true;
      internalValueResult.certificateName = this._certificateName;
    }
    if (this._commonNameRegex !== undefined) {
      hasAnyValues = true;
      internalValueResult.commonNameRegex = this._commonNameRegex;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._maxVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxVersion = this._maxVersion;
    }
    if (this._minVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.minVersion = this._minVersion;
    }
    if (this._passphrase !== undefined) {
      hasAnyValues = true;
      internalValueResult.passphrase = this._passphrase;
    }
    if (this._privKeyPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.privKeyPath = this._privKeyPath;
    }
    if (this._rejectUnauthorized !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectUnauthorized = this._rejectUnauthorized;
    }
    if (this._requestCert !== undefined) {
      hasAnyValues = true;
      internalValueResult.requestCert = this._requestCert;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputTcpjsonTls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._caPath = undefined;
      this._certPath = undefined;
      this._certificateName = undefined;
      this._commonNameRegex = undefined;
      this._disabled = undefined;
      this._maxVersion = undefined;
      this._minVersion = undefined;
      this._passphrase = undefined;
      this._privKeyPath = undefined;
      this._rejectUnauthorized = undefined;
      this._requestCert = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._caPath = value.caPath;
      this._certPath = value.certPath;
      this._certificateName = value.certificateName;
      this._commonNameRegex = value.commonNameRegex;
      this._disabled = value.disabled;
      this._maxVersion = value.maxVersion;
      this._minVersion = value.minVersion;
      this._passphrase = value.passphrase;
      this._privKeyPath = value.privKeyPath;
      this._rejectUnauthorized = value.rejectUnauthorized;
      this._requestCert = value.requestCert;
    }
  }

  // ca_path - computed: false, optional: true, required: false
  private _caPath?: string; 
  public get caPath() {
    return this.getStringAttribute('ca_path');
  }
  public set caPath(value: string) {
    this._caPath = value;
  }
  public resetCaPath() {
    this._caPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get caPathInput() {
    return this._caPath;
  }

  // cert_path - computed: false, optional: true, required: false
  private _certPath?: string; 
  public get certPath() {
    return this.getStringAttribute('cert_path');
  }
  public set certPath(value: string) {
    this._certPath = value;
  }
  public resetCertPath() {
    this._certPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certPathInput() {
    return this._certPath;
  }

  // certificate_name - computed: false, optional: true, required: false
  private _certificateName?: string; 
  public get certificateName() {
    return this.getStringAttribute('certificate_name');
  }
  public set certificateName(value: string) {
    this._certificateName = value;
  }
  public resetCertificateName() {
    this._certificateName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certificateNameInput() {
    return this._certificateName;
  }

  // common_name_regex - computed: false, optional: true, required: false
  private _commonNameRegex?: string; 
  public get commonNameRegex() {
    return this.getStringAttribute('common_name_regex');
  }
  public set commonNameRegex(value: string) {
    this._commonNameRegex = value;
  }
  public resetCommonNameRegex() {
    this._commonNameRegex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commonNameRegexInput() {
    return this._commonNameRegex;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // max_version - computed: false, optional: true, required: false
  private _maxVersion?: string; 
  public get maxVersion() {
    return this.getStringAttribute('max_version');
  }
  public set maxVersion(value: string) {
    this._maxVersion = value;
  }
  public resetMaxVersion() {
    this._maxVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxVersionInput() {
    return this._maxVersion;
  }

  // min_version - computed: false, optional: true, required: false
  private _minVersion?: string; 
  public get minVersion() {
    return this.getStringAttribute('min_version');
  }
  public set minVersion(value: string) {
    this._minVersion = value;
  }
  public resetMinVersion() {
    this._minVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get minVersionInput() {
    return this._minVersion;
  }

  // passphrase - computed: false, optional: true, required: false
  private _passphrase?: string; 
  public get passphrase() {
    return this.getStringAttribute('passphrase');
  }
  public set passphrase(value: string) {
    this._passphrase = value;
  }
  public resetPassphrase() {
    this._passphrase = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passphraseInput() {
    return this._passphrase;
  }

  // priv_key_path - computed: false, optional: true, required: false
  private _privKeyPath?: string; 
  public get privKeyPath() {
    return this.getStringAttribute('priv_key_path');
  }
  public set privKeyPath(value: string) {
    this._privKeyPath = value;
  }
  public resetPrivKeyPath() {
    this._privKeyPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get privKeyPathInput() {
    return this._privKeyPath;
  }

  // reject_unauthorized - computed: false, optional: true, required: false
  private _rejectUnauthorized?: string; 
  public get rejectUnauthorized() {
    return this.getStringAttribute('reject_unauthorized');
  }
  public set rejectUnauthorized(value: string) {
    this._rejectUnauthorized = value;
  }
  public resetRejectUnauthorized() {
    this._rejectUnauthorized = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectUnauthorizedInput() {
    return this._rejectUnauthorized;
  }

  // request_cert - computed: true, optional: true, required: false
  private _requestCert?: boolean | cdktf.IResolvable; 
  public get requestCert() {
    return this.getBooleanAttribute('request_cert');
  }
  public set requestCert(value: boolean | cdktf.IResolvable) {
    this._requestCert = value;
  }
  public resetRequestCert() {
    this._requestCert = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestCertInput() {
    return this._requestCert;
  }
}
export interface PackSourceInputTcpjson {
  /**
  * Shared secret to be provided by any client (in authToken header field). If empty, unauthorized access is permitted. Default: ""
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#auth_token PackSource#auth_token}
  */
  readonly authToken?: string;
  /**
  * Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate. Default: "manual"; must be one of ["manual", "secret"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#auth_type PackSource#auth_type}
  */
  readonly authType?: string;
  /**
  * Direct connections to Destinations, and optionally via a Pipeline or a Pack
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#connections PackSource#connections}
  */
  readonly connections?: PackSourceInputTcpjsonConnections[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#description PackSource#description}
  */
  readonly description?: string;
  /**
  * Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#disabled PackSource#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * Load balance traffic across all Worker Processes. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#enable_load_balancing PackSource#enable_load_balancing}
  */
  readonly enableLoadBalancing?: boolean | cdktf.IResolvable;
  /**
  * Enable if the connection is proxied by a device that supports proxy protocol v1 or v2. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#enable_proxy_header PackSource#enable_proxy_header}
  */
  readonly enableProxyHeader?: boolean | cdktf.IResolvable;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#environment PackSource#environment}
  */
  readonly environment?: string;
  /**
  * Address to bind on. Defaults to 0.0.0.0 (all addresses). Default: "0.0.0.0"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#host PackSource#host}
  */
  readonly host?: string;
  /**
  * Unique ID for this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#id PackSource#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * Regex matching IP addresses that are allowed to establish a connection. Default: "/.* /"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#ip_whitelist_regex PackSource#ip_whitelist_regex}
   *
  * Note: The above comment contained a comment block ending sequence (* followed by /). We have introduced a space between to prevent syntax errors. Please ignore the space.
  */
  readonly ipWhitelistRegex?: string;
  /**
  * Maximum number of active connections allowed per Worker Process. Use 0 for unlimited. Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_active_cxn PackSource#max_active_cxn}
  */
  readonly maxActiveCxn?: number;
  /**
  * Fields to add to events from this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#metadata PackSource#metadata}
  */
  readonly metadata?: PackSourceInputTcpjsonMetadata[] | cdktf.IResolvable;
  /**
  * Pipeline to process data from this Source before sending it through the Routes
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pipeline PackSource#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Port to listen on
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#port PackSource#port}
  */
  readonly port: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pq PackSource#pq}
  */
  readonly pq?: PackSourceInputTcpjsonPq;
  /**
  * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers). Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pq_enabled PackSource#pq_enabled}
  */
  readonly pqEnabled?: boolean | cdktf.IResolvable;
  /**
  * Select whether to send data to Routes, or directly to Destinations. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#send_to_routes PackSource#send_to_routes}
  */
  readonly sendToRoutes?: boolean | cdktf.IResolvable;
  /**
  * How long the server will wait after initiating a closure for a client to close its end of the connection. If the client doesn't close the connection within this time, the server will forcefully terminate the socket to prevent resource leaks and ensure efficient connection cleanup and system stability. Leave at 0 for no inactive socket monitoring. Default: 30
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#socket_ending_max_wait PackSource#socket_ending_max_wait}
  */
  readonly socketEndingMaxWait?: number;
  /**
  * How long @{product} should wait before assuming that an inactive socket has timed out. After this time, the connection will be closed. Leave at 0 for no inactive socket monitoring. Default: 0
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#socket_idle_timeout PackSource#socket_idle_timeout}
  */
  readonly socketIdleTimeout?: number;
  /**
  * The maximum duration a socket can remain open, even if active. This helps manage resources and mitigate issues caused by TCP pinning. Set to 0 to disable. Default: 0
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#socket_max_lifespan PackSource#socket_max_lifespan}
  */
  readonly socketMaxLifespan?: number;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#streamtags PackSource#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Select or create a stored text secret
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#text_secret PackSource#text_secret}
  */
  readonly textSecret?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#tls PackSource#tls}
  */
  readonly tls?: PackSourceInputTcpjsonTls;
  /**
  * must be "tcpjson"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#type PackSource#type}
  */
  readonly type?: string;
}

export function packSourceInputTcpjsonToTerraform(struct?: PackSourceInputTcpjson | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    auth_token: cdktf.stringToTerraform(struct!.authToken),
    auth_type: cdktf.stringToTerraform(struct!.authType),
    connections: cdktf.listMapper(packSourceInputTcpjsonConnectionsToTerraform, false)(struct!.connections),
    description: cdktf.stringToTerraform(struct!.description),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    enable_load_balancing: cdktf.booleanToTerraform(struct!.enableLoadBalancing),
    enable_proxy_header: cdktf.booleanToTerraform(struct!.enableProxyHeader),
    environment: cdktf.stringToTerraform(struct!.environment),
    host: cdktf.stringToTerraform(struct!.host),
    id: cdktf.stringToTerraform(struct!.id),
    ip_whitelist_regex: cdktf.stringToTerraform(struct!.ipWhitelistRegex),
    max_active_cxn: cdktf.numberToTerraform(struct!.maxActiveCxn),
    metadata: cdktf.listMapper(packSourceInputTcpjsonMetadataToTerraform, false)(struct!.metadata),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    port: cdktf.numberToTerraform(struct!.port),
    pq: packSourceInputTcpjsonPqToTerraform(struct!.pq),
    pq_enabled: cdktf.booleanToTerraform(struct!.pqEnabled),
    send_to_routes: cdktf.booleanToTerraform(struct!.sendToRoutes),
    socket_ending_max_wait: cdktf.numberToTerraform(struct!.socketEndingMaxWait),
    socket_idle_timeout: cdktf.numberToTerraform(struct!.socketIdleTimeout),
    socket_max_lifespan: cdktf.numberToTerraform(struct!.socketMaxLifespan),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    text_secret: cdktf.stringToTerraform(struct!.textSecret),
    tls: packSourceInputTcpjsonTlsToTerraform(struct!.tls),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function packSourceInputTcpjsonToHclTerraform(struct?: PackSourceInputTcpjson | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    auth_token: {
      value: cdktf.stringToHclTerraform(struct!.authToken),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    auth_type: {
      value: cdktf.stringToHclTerraform(struct!.authType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    connections: {
      value: cdktf.listMapperHcl(packSourceInputTcpjsonConnectionsToHclTerraform, false)(struct!.connections),
      isBlock: true,
      type: "list",
      storageClassType: "PackSourceInputTcpjsonConnectionsList",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    enable_load_balancing: {
      value: cdktf.booleanToHclTerraform(struct!.enableLoadBalancing),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    enable_proxy_header: {
      value: cdktf.booleanToHclTerraform(struct!.enableProxyHeader),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    host: {
      value: cdktf.stringToHclTerraform(struct!.host),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ip_whitelist_regex: {
      value: cdktf.stringToHclTerraform(struct!.ipWhitelistRegex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_active_cxn: {
      value: cdktf.numberToHclTerraform(struct!.maxActiveCxn),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    metadata: {
      value: cdktf.listMapperHcl(packSourceInputTcpjsonMetadataToHclTerraform, false)(struct!.metadata),
      isBlock: true,
      type: "list",
      storageClassType: "PackSourceInputTcpjsonMetadataList",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    pq: {
      value: packSourceInputTcpjsonPqToHclTerraform(struct!.pq),
      isBlock: true,
      type: "struct",
      storageClassType: "PackSourceInputTcpjsonPq",
    },
    pq_enabled: {
      value: cdktf.booleanToHclTerraform(struct!.pqEnabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    send_to_routes: {
      value: cdktf.booleanToHclTerraform(struct!.sendToRoutes),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    socket_ending_max_wait: {
      value: cdktf.numberToHclTerraform(struct!.socketEndingMaxWait),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    socket_idle_timeout: {
      value: cdktf.numberToHclTerraform(struct!.socketIdleTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    socket_max_lifespan: {
      value: cdktf.numberToHclTerraform(struct!.socketMaxLifespan),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    text_secret: {
      value: cdktf.stringToHclTerraform(struct!.textSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tls: {
      value: packSourceInputTcpjsonTlsToHclTerraform(struct!.tls),
      isBlock: true,
      type: "struct",
      storageClassType: "PackSourceInputTcpjsonTls",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputTcpjsonOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputTcpjson | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._authToken !== undefined) {
      hasAnyValues = true;
      internalValueResult.authToken = this._authToken;
    }
    if (this._authType !== undefined) {
      hasAnyValues = true;
      internalValueResult.authType = this._authType;
    }
    if (this._connections?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.connections = this._connections?.internalValue;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._enableLoadBalancing !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableLoadBalancing = this._enableLoadBalancing;
    }
    if (this._enableProxyHeader !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableProxyHeader = this._enableProxyHeader;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._host !== undefined) {
      hasAnyValues = true;
      internalValueResult.host = this._host;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._ipWhitelistRegex !== undefined) {
      hasAnyValues = true;
      internalValueResult.ipWhitelistRegex = this._ipWhitelistRegex;
    }
    if (this._maxActiveCxn !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxActiveCxn = this._maxActiveCxn;
    }
    if (this._metadata?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadata = this._metadata?.internalValue;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._pq?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pq = this._pq?.internalValue;
    }
    if (this._pqEnabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqEnabled = this._pqEnabled;
    }
    if (this._sendToRoutes !== undefined) {
      hasAnyValues = true;
      internalValueResult.sendToRoutes = this._sendToRoutes;
    }
    if (this._socketEndingMaxWait !== undefined) {
      hasAnyValues = true;
      internalValueResult.socketEndingMaxWait = this._socketEndingMaxWait;
    }
    if (this._socketIdleTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.socketIdleTimeout = this._socketIdleTimeout;
    }
    if (this._socketMaxLifespan !== undefined) {
      hasAnyValues = true;
      internalValueResult.socketMaxLifespan = this._socketMaxLifespan;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._textSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.textSecret = this._textSecret;
    }
    if (this._tls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tls = this._tls?.internalValue;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputTcpjson | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._authToken = undefined;
      this._authType = undefined;
      this._connections.internalValue = undefined;
      this._description = undefined;
      this._disabled = undefined;
      this._enableLoadBalancing = undefined;
      this._enableProxyHeader = undefined;
      this._environment = undefined;
      this._host = undefined;
      this._id = undefined;
      this._ipWhitelistRegex = undefined;
      this._maxActiveCxn = undefined;
      this._metadata.internalValue = undefined;
      this._pipeline = undefined;
      this._port = undefined;
      this._pq.internalValue = undefined;
      this._pqEnabled = undefined;
      this._sendToRoutes = undefined;
      this._socketEndingMaxWait = undefined;
      this._socketIdleTimeout = undefined;
      this._socketMaxLifespan = undefined;
      this._streamtags = undefined;
      this._textSecret = undefined;
      this._tls.internalValue = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._authToken = value.authToken;
      this._authType = value.authType;
      this._connections.internalValue = value.connections;
      this._description = value.description;
      this._disabled = value.disabled;
      this._enableLoadBalancing = value.enableLoadBalancing;
      this._enableProxyHeader = value.enableProxyHeader;
      this._environment = value.environment;
      this._host = value.host;
      this._id = value.id;
      this._ipWhitelistRegex = value.ipWhitelistRegex;
      this._maxActiveCxn = value.maxActiveCxn;
      this._metadata.internalValue = value.metadata;
      this._pipeline = value.pipeline;
      this._port = value.port;
      this._pq.internalValue = value.pq;
      this._pqEnabled = value.pqEnabled;
      this._sendToRoutes = value.sendToRoutes;
      this._socketEndingMaxWait = value.socketEndingMaxWait;
      this._socketIdleTimeout = value.socketIdleTimeout;
      this._socketMaxLifespan = value.socketMaxLifespan;
      this._streamtags = value.streamtags;
      this._textSecret = value.textSecret;
      this._tls.internalValue = value.tls;
      this._type = value.type;
    }
  }

  // auth_token - computed: true, optional: true, required: false
  private _authToken?: string; 
  public get authToken() {
    return this.getStringAttribute('auth_token');
  }
  public set authToken(value: string) {
    this._authToken = value;
  }
  public resetAuthToken() {
    this._authToken = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authTokenInput() {
    return this._authToken;
  }

  // auth_type - computed: true, optional: true, required: false
  private _authType?: string; 
  public get authType() {
    return this.getStringAttribute('auth_type');
  }
  public set authType(value: string) {
    this._authType = value;
  }
  public resetAuthType() {
    this._authType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authTypeInput() {
    return this._authType;
  }

  // connections - computed: false, optional: true, required: false
  private _connections = new PackSourceInputTcpjsonConnectionsList(this, "connections", false);
  public get connections() {
    return this._connections;
  }
  public putConnections(value: PackSourceInputTcpjsonConnections[] | cdktf.IResolvable) {
    this._connections.internalValue = value;
  }
  public resetConnections() {
    this._connections.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectionsInput() {
    return this._connections.internalValue;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // enable_load_balancing - computed: true, optional: true, required: false
  private _enableLoadBalancing?: boolean | cdktf.IResolvable; 
  public get enableLoadBalancing() {
    return this.getBooleanAttribute('enable_load_balancing');
  }
  public set enableLoadBalancing(value: boolean | cdktf.IResolvable) {
    this._enableLoadBalancing = value;
  }
  public resetEnableLoadBalancing() {
    this._enableLoadBalancing = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableLoadBalancingInput() {
    return this._enableLoadBalancing;
  }

  // enable_proxy_header - computed: true, optional: true, required: false
  private _enableProxyHeader?: boolean | cdktf.IResolvable; 
  public get enableProxyHeader() {
    return this.getBooleanAttribute('enable_proxy_header');
  }
  public set enableProxyHeader(value: boolean | cdktf.IResolvable) {
    this._enableProxyHeader = value;
  }
  public resetEnableProxyHeader() {
    this._enableProxyHeader = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableProxyHeaderInput() {
    return this._enableProxyHeader;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // host - computed: true, optional: true, required: false
  private _host?: string; 
  public get host() {
    return this.getStringAttribute('host');
  }
  public set host(value: string) {
    this._host = value;
  }
  public resetHost() {
    this._host = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostInput() {
    return this._host;
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // ip_whitelist_regex - computed: true, optional: true, required: false
  private _ipWhitelistRegex?: string; 
  public get ipWhitelistRegex() {
    return this.getStringAttribute('ip_whitelist_regex');
  }
  public set ipWhitelistRegex(value: string) {
    this._ipWhitelistRegex = value;
  }
  public resetIpWhitelistRegex() {
    this._ipWhitelistRegex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ipWhitelistRegexInput() {
    return this._ipWhitelistRegex;
  }

  // max_active_cxn - computed: true, optional: true, required: false
  private _maxActiveCxn?: number; 
  public get maxActiveCxn() {
    return this.getNumberAttribute('max_active_cxn');
  }
  public set maxActiveCxn(value: number) {
    this._maxActiveCxn = value;
  }
  public resetMaxActiveCxn() {
    this._maxActiveCxn = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxActiveCxnInput() {
    return this._maxActiveCxn;
  }

  // metadata - computed: false, optional: true, required: false
  private _metadata = new PackSourceInputTcpjsonMetadataList(this, "metadata", false);
  public get metadata() {
    return this._metadata;
  }
  public putMetadata(value: PackSourceInputTcpjsonMetadata[] | cdktf.IResolvable) {
    this._metadata.internalValue = value;
  }
  public resetMetadata() {
    this._metadata.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataInput() {
    return this._metadata.internalValue;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // port - computed: false, optional: false, required: true
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // pq - computed: false, optional: true, required: false
  private _pq = new PackSourceInputTcpjsonPqOutputReference(this, "pq");
  public get pq() {
    return this._pq;
  }
  public putPq(value: PackSourceInputTcpjsonPq) {
    this._pq.internalValue = value;
  }
  public resetPq() {
    this._pq.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqInput() {
    return this._pq.internalValue;
  }

  // pq_enabled - computed: true, optional: true, required: false
  private _pqEnabled?: boolean | cdktf.IResolvable; 
  public get pqEnabled() {
    return this.getBooleanAttribute('pq_enabled');
  }
  public set pqEnabled(value: boolean | cdktf.IResolvable) {
    this._pqEnabled = value;
  }
  public resetPqEnabled() {
    this._pqEnabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqEnabledInput() {
    return this._pqEnabled;
  }

  // send_to_routes - computed: true, optional: true, required: false
  private _sendToRoutes?: boolean | cdktf.IResolvable; 
  public get sendToRoutes() {
    return this.getBooleanAttribute('send_to_routes');
  }
  public set sendToRoutes(value: boolean | cdktf.IResolvable) {
    this._sendToRoutes = value;
  }
  public resetSendToRoutes() {
    this._sendToRoutes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sendToRoutesInput() {
    return this._sendToRoutes;
  }

  // socket_ending_max_wait - computed: true, optional: true, required: false
  private _socketEndingMaxWait?: number; 
  public get socketEndingMaxWait() {
    return this.getNumberAttribute('socket_ending_max_wait');
  }
  public set socketEndingMaxWait(value: number) {
    this._socketEndingMaxWait = value;
  }
  public resetSocketEndingMaxWait() {
    this._socketEndingMaxWait = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get socketEndingMaxWaitInput() {
    return this._socketEndingMaxWait;
  }

  // socket_idle_timeout - computed: true, optional: true, required: false
  private _socketIdleTimeout?: number; 
  public get socketIdleTimeout() {
    return this.getNumberAttribute('socket_idle_timeout');
  }
  public set socketIdleTimeout(value: number) {
    this._socketIdleTimeout = value;
  }
  public resetSocketIdleTimeout() {
    this._socketIdleTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get socketIdleTimeoutInput() {
    return this._socketIdleTimeout;
  }

  // socket_max_lifespan - computed: true, optional: true, required: false
  private _socketMaxLifespan?: number; 
  public get socketMaxLifespan() {
    return this.getNumberAttribute('socket_max_lifespan');
  }
  public set socketMaxLifespan(value: number) {
    this._socketMaxLifespan = value;
  }
  public resetSocketMaxLifespan() {
    this._socketMaxLifespan = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get socketMaxLifespanInput() {
    return this._socketMaxLifespan;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // text_secret - computed: false, optional: true, required: false
  private _textSecret?: string; 
  public get textSecret() {
    return this.getStringAttribute('text_secret');
  }
  public set textSecret(value: string) {
    this._textSecret = value;
  }
  public resetTextSecret() {
    this._textSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get textSecretInput() {
    return this._textSecret;
  }

  // tls - computed: false, optional: true, required: false
  private _tls = new PackSourceInputTcpjsonTlsOutputReference(this, "tls");
  public get tls() {
    return this._tls;
  }
  public putTls(value: PackSourceInputTcpjsonTls) {
    this._tls.internalValue = value;
  }
  public resetTls() {
    this._tls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsInput() {
    return this._tls.internalValue;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface PackSourceInputWefConnections {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#output PackSource#output}
  */
  readonly output: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pipeline PackSource#pipeline}
  */
  readonly pipeline?: string;
}

export function packSourceInputWefConnectionsToTerraform(struct?: PackSourceInputWefConnections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    output: cdktf.stringToTerraform(struct!.output),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
  }
}


export function packSourceInputWefConnectionsToHclTerraform(struct?: PackSourceInputWefConnections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    output: {
      value: cdktf.stringToHclTerraform(struct!.output),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputWefConnectionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackSourceInputWefConnections | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._output !== undefined) {
      hasAnyValues = true;
      internalValueResult.output = this._output;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputWefConnections | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._output = undefined;
      this._pipeline = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._output = value.output;
      this._pipeline = value.pipeline;
    }
  }

  // output - computed: false, optional: false, required: true
  private _output?: string; 
  public get output() {
    return this.getStringAttribute('output');
  }
  public set output(value: string) {
    this._output = value;
  }
  // Temporarily expose input value. Use with caution.
  public get outputInput() {
    return this._output;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }
}

export class PackSourceInputWefConnectionsList extends cdktf.ComplexList {
  public internalValue? : PackSourceInputWefConnections[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackSourceInputWefConnectionsOutputReference {
    return new PackSourceInputWefConnectionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackSourceInputWefMetadata {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#name PackSource#name}
  */
  readonly name: string;
  /**
  * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#value PackSource#value}
  */
  readonly value: string;
}

export function packSourceInputWefMetadataToTerraform(struct?: PackSourceInputWefMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function packSourceInputWefMetadataToHclTerraform(struct?: PackSourceInputWefMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputWefMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackSourceInputWefMetadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputWefMetadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class PackSourceInputWefMetadataList extends cdktf.ComplexList {
  public internalValue? : PackSourceInputWefMetadata[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackSourceInputWefMetadataOutputReference {
    return new PackSourceInputWefMetadataOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackSourceInputWefPq {
  /**
  * The number of events to send downstream before committing that Stream has read them. Default: 42
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#commit_frequency PackSource#commit_frequency}
  */
  readonly commitFrequency?: number;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#compress PackSource#compress}
  */
  readonly compress?: string;
  /**
  * The maximum number of events to hold in memory before writing the events to disk. Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_buffer_size PackSource#max_buffer_size}
  */
  readonly maxBufferSize?: number;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc. Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_file_size PackSource#max_file_size}
  */
  readonly maxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_size PackSource#max_size}
  */
  readonly maxSize?: string;
  /**
  * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine. Default: "always"; must be one of ["smart", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#mode PackSource#mode}
  */
  readonly mode?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#path PackSource#path}
  */
  readonly path?: string;
}

export function packSourceInputWefPqToTerraform(struct?: PackSourceInputWefPq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    commit_frequency: cdktf.numberToTerraform(struct!.commitFrequency),
    compress: cdktf.stringToTerraform(struct!.compress),
    max_buffer_size: cdktf.numberToTerraform(struct!.maxBufferSize),
    max_file_size: cdktf.stringToTerraform(struct!.maxFileSize),
    max_size: cdktf.stringToTerraform(struct!.maxSize),
    mode: cdktf.stringToTerraform(struct!.mode),
    path: cdktf.stringToTerraform(struct!.path),
  }
}


export function packSourceInputWefPqToHclTerraform(struct?: PackSourceInputWefPq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    commit_frequency: {
      value: cdktf.numberToHclTerraform(struct!.commitFrequency),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    compress: {
      value: cdktf.stringToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_buffer_size: {
      value: cdktf.numberToHclTerraform(struct!.maxBufferSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.maxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_size: {
      value: cdktf.stringToHclTerraform(struct!.maxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputWefPqOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputWefPq | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._commitFrequency !== undefined) {
      hasAnyValues = true;
      internalValueResult.commitFrequency = this._commitFrequency;
    }
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._maxBufferSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBufferSize = this._maxBufferSize;
    }
    if (this._maxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxFileSize = this._maxFileSize;
    }
    if (this._maxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxSize = this._maxSize;
    }
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputWefPq | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._commitFrequency = undefined;
      this._compress = undefined;
      this._maxBufferSize = undefined;
      this._maxFileSize = undefined;
      this._maxSize = undefined;
      this._mode = undefined;
      this._path = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._commitFrequency = value.commitFrequency;
      this._compress = value.compress;
      this._maxBufferSize = value.maxBufferSize;
      this._maxFileSize = value.maxFileSize;
      this._maxSize = value.maxSize;
      this._mode = value.mode;
      this._path = value.path;
    }
  }

  // commit_frequency - computed: true, optional: true, required: false
  private _commitFrequency?: number; 
  public get commitFrequency() {
    return this.getNumberAttribute('commit_frequency');
  }
  public set commitFrequency(value: number) {
    this._commitFrequency = value;
  }
  public resetCommitFrequency() {
    this._commitFrequency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commitFrequencyInput() {
    return this._commitFrequency;
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: string; 
  public get compress() {
    return this.getStringAttribute('compress');
  }
  public set compress(value: string) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // max_buffer_size - computed: true, optional: true, required: false
  private _maxBufferSize?: number; 
  public get maxBufferSize() {
    return this.getNumberAttribute('max_buffer_size');
  }
  public set maxBufferSize(value: number) {
    this._maxBufferSize = value;
  }
  public resetMaxBufferSize() {
    this._maxBufferSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBufferSizeInput() {
    return this._maxBufferSize;
  }

  // max_file_size - computed: true, optional: true, required: false
  private _maxFileSize?: string; 
  public get maxFileSize() {
    return this.getStringAttribute('max_file_size');
  }
  public set maxFileSize(value: string) {
    this._maxFileSize = value;
  }
  public resetMaxFileSize() {
    this._maxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxFileSizeInput() {
    return this._maxFileSize;
  }

  // max_size - computed: true, optional: true, required: false
  private _maxSize?: string; 
  public get maxSize() {
    return this.getStringAttribute('max_size');
  }
  public set maxSize(value: string) {
    this._maxSize = value;
  }
  public resetMaxSize() {
    this._maxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxSizeInput() {
    return this._maxSize;
  }

  // mode - computed: true, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // path - computed: true, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }
}
export interface PackSourceInputWefSubscriptionsMetadata {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#name PackSource#name}
  */
  readonly name: string;
  /**
  * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#value PackSource#value}
  */
  readonly value: string;
}

export function packSourceInputWefSubscriptionsMetadataToTerraform(struct?: PackSourceInputWefSubscriptionsMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function packSourceInputWefSubscriptionsMetadataToHclTerraform(struct?: PackSourceInputWefSubscriptionsMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputWefSubscriptionsMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackSourceInputWefSubscriptionsMetadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputWefSubscriptionsMetadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class PackSourceInputWefSubscriptionsMetadataList extends cdktf.ComplexList {
  public internalValue? : PackSourceInputWefSubscriptionsMetadata[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackSourceInputWefSubscriptionsMetadataOutputReference {
    return new PackSourceInputWefSubscriptionsMetadataOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackSourceInputWefSubscriptions {
  /**
  * Interval (in seconds) over which the endpoint should collect events before sending them to Stream. Default: 60
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#batch_timeout PackSource#batch_timeout}
  */
  readonly batchTimeout?: number;
  /**
  * Receive compressed events from the source. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#compress PackSource#compress}
  */
  readonly compress?: boolean | cdktf.IResolvable;
  /**
  * Content format in which the endpoint should deliver events. Default: "Raw"; must be one of ["Raw", "RenderedText"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#content_format PackSource#content_format}
  */
  readonly contentFormat?: string;
  /**
  * Maximum time (in seconds) between endpoint checkins before considering it unavailable. Default: 60
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#heartbeat_interval PackSource#heartbeat_interval}
  */
  readonly heartbeatInterval?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#id PackSource#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id: string;
  /**
  * The RFC-3066 locale the Windows clients should use when sending events. Defaults to "en-US". Default: "en-US"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#locale PackSource#locale}
  */
  readonly locale?: string;
  /**
  * Fields to add to events ingested under this subscription
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#metadata PackSource#metadata}
  */
  readonly metadata?: PackSourceInputWefSubscriptionsMetadata[] | cdktf.IResolvable;
  /**
  * Default: "simple"; must be one of ["simple", "xml"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#query_selector PackSource#query_selector}
  */
  readonly querySelector?: string;
  /**
  * Newly subscribed endpoints will send previously existing events. Disable to receive new events only. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#read_existing_events PackSource#read_existing_events}
  */
  readonly readExistingEvents?: boolean | cdktf.IResolvable;
  /**
  * Keep track of which events have been received, resuming from that point after a re-subscription. This setting takes precedence over 'Read existing events'. See [Cribl Docs](https://docs.cribl.io/stream/sources-wef/#subscriptions) for more details. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#send_bookmarks PackSource#send_bookmarks}
  */
  readonly sendBookmarks?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#subscription_name PackSource#subscription_name}
  */
  readonly subscriptionName: string;
  /**
  * The DNS names of the endpoints that should forward these events. You may use wildcards, such as *.mydomain.com. Default: ["*"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#targets PackSource#targets}
  */
  readonly targets?: string[];
  /**
  * Version UUID for this subscription. If any subscription parameters are modified, this value will change.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#version PackSource#version}
  */
  readonly version?: string;
}

export function packSourceInputWefSubscriptionsToTerraform(struct?: PackSourceInputWefSubscriptions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    batch_timeout: cdktf.numberToTerraform(struct!.batchTimeout),
    compress: cdktf.booleanToTerraform(struct!.compress),
    content_format: cdktf.stringToTerraform(struct!.contentFormat),
    heartbeat_interval: cdktf.numberToTerraform(struct!.heartbeatInterval),
    id: cdktf.stringToTerraform(struct!.id),
    locale: cdktf.stringToTerraform(struct!.locale),
    metadata: cdktf.listMapper(packSourceInputWefSubscriptionsMetadataToTerraform, false)(struct!.metadata),
    query_selector: cdktf.stringToTerraform(struct!.querySelector),
    read_existing_events: cdktf.booleanToTerraform(struct!.readExistingEvents),
    send_bookmarks: cdktf.booleanToTerraform(struct!.sendBookmarks),
    subscription_name: cdktf.stringToTerraform(struct!.subscriptionName),
    targets: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.targets),
    version: cdktf.stringToTerraform(struct!.version),
  }
}


export function packSourceInputWefSubscriptionsToHclTerraform(struct?: PackSourceInputWefSubscriptions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    batch_timeout: {
      value: cdktf.numberToHclTerraform(struct!.batchTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    compress: {
      value: cdktf.booleanToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    content_format: {
      value: cdktf.stringToHclTerraform(struct!.contentFormat),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    heartbeat_interval: {
      value: cdktf.numberToHclTerraform(struct!.heartbeatInterval),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    locale: {
      value: cdktf.stringToHclTerraform(struct!.locale),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    metadata: {
      value: cdktf.listMapperHcl(packSourceInputWefSubscriptionsMetadataToHclTerraform, false)(struct!.metadata),
      isBlock: true,
      type: "list",
      storageClassType: "PackSourceInputWefSubscriptionsMetadataList",
    },
    query_selector: {
      value: cdktf.stringToHclTerraform(struct!.querySelector),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    read_existing_events: {
      value: cdktf.booleanToHclTerraform(struct!.readExistingEvents),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    send_bookmarks: {
      value: cdktf.booleanToHclTerraform(struct!.sendBookmarks),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    subscription_name: {
      value: cdktf.stringToHclTerraform(struct!.subscriptionName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    targets: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.targets),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    version: {
      value: cdktf.stringToHclTerraform(struct!.version),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputWefSubscriptionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackSourceInputWefSubscriptions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._batchTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.batchTimeout = this._batchTimeout;
    }
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._contentFormat !== undefined) {
      hasAnyValues = true;
      internalValueResult.contentFormat = this._contentFormat;
    }
    if (this._heartbeatInterval !== undefined) {
      hasAnyValues = true;
      internalValueResult.heartbeatInterval = this._heartbeatInterval;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._locale !== undefined) {
      hasAnyValues = true;
      internalValueResult.locale = this._locale;
    }
    if (this._metadata?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadata = this._metadata?.internalValue;
    }
    if (this._querySelector !== undefined) {
      hasAnyValues = true;
      internalValueResult.querySelector = this._querySelector;
    }
    if (this._readExistingEvents !== undefined) {
      hasAnyValues = true;
      internalValueResult.readExistingEvents = this._readExistingEvents;
    }
    if (this._sendBookmarks !== undefined) {
      hasAnyValues = true;
      internalValueResult.sendBookmarks = this._sendBookmarks;
    }
    if (this._subscriptionName !== undefined) {
      hasAnyValues = true;
      internalValueResult.subscriptionName = this._subscriptionName;
    }
    if (this._targets !== undefined) {
      hasAnyValues = true;
      internalValueResult.targets = this._targets;
    }
    if (this._version !== undefined) {
      hasAnyValues = true;
      internalValueResult.version = this._version;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputWefSubscriptions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._batchTimeout = undefined;
      this._compress = undefined;
      this._contentFormat = undefined;
      this._heartbeatInterval = undefined;
      this._id = undefined;
      this._locale = undefined;
      this._metadata.internalValue = undefined;
      this._querySelector = undefined;
      this._readExistingEvents = undefined;
      this._sendBookmarks = undefined;
      this._subscriptionName = undefined;
      this._targets = undefined;
      this._version = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._batchTimeout = value.batchTimeout;
      this._compress = value.compress;
      this._contentFormat = value.contentFormat;
      this._heartbeatInterval = value.heartbeatInterval;
      this._id = value.id;
      this._locale = value.locale;
      this._metadata.internalValue = value.metadata;
      this._querySelector = value.querySelector;
      this._readExistingEvents = value.readExistingEvents;
      this._sendBookmarks = value.sendBookmarks;
      this._subscriptionName = value.subscriptionName;
      this._targets = value.targets;
      this._version = value.version;
    }
  }

  // batch_timeout - computed: true, optional: true, required: false
  private _batchTimeout?: number; 
  public get batchTimeout() {
    return this.getNumberAttribute('batch_timeout');
  }
  public set batchTimeout(value: number) {
    this._batchTimeout = value;
  }
  public resetBatchTimeout() {
    this._batchTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get batchTimeoutInput() {
    return this._batchTimeout;
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: boolean | cdktf.IResolvable; 
  public get compress() {
    return this.getBooleanAttribute('compress');
  }
  public set compress(value: boolean | cdktf.IResolvable) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // content_format - computed: true, optional: true, required: false
  private _contentFormat?: string; 
  public get contentFormat() {
    return this.getStringAttribute('content_format');
  }
  public set contentFormat(value: string) {
    this._contentFormat = value;
  }
  public resetContentFormat() {
    this._contentFormat = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get contentFormatInput() {
    return this._contentFormat;
  }

  // heartbeat_interval - computed: true, optional: true, required: false
  private _heartbeatInterval?: number; 
  public get heartbeatInterval() {
    return this.getNumberAttribute('heartbeat_interval');
  }
  public set heartbeatInterval(value: number) {
    this._heartbeatInterval = value;
  }
  public resetHeartbeatInterval() {
    this._heartbeatInterval = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get heartbeatIntervalInput() {
    return this._heartbeatInterval;
  }

  // id - computed: false, optional: false, required: true
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // locale - computed: true, optional: true, required: false
  private _locale?: string; 
  public get locale() {
    return this.getStringAttribute('locale');
  }
  public set locale(value: string) {
    this._locale = value;
  }
  public resetLocale() {
    this._locale = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get localeInput() {
    return this._locale;
  }

  // metadata - computed: false, optional: true, required: false
  private _metadata = new PackSourceInputWefSubscriptionsMetadataList(this, "metadata", false);
  public get metadata() {
    return this._metadata;
  }
  public putMetadata(value: PackSourceInputWefSubscriptionsMetadata[] | cdktf.IResolvable) {
    this._metadata.internalValue = value;
  }
  public resetMetadata() {
    this._metadata.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataInput() {
    return this._metadata.internalValue;
  }

  // query_selector - computed: true, optional: true, required: false
  private _querySelector?: string; 
  public get querySelector() {
    return this.getStringAttribute('query_selector');
  }
  public set querySelector(value: string) {
    this._querySelector = value;
  }
  public resetQuerySelector() {
    this._querySelector = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get querySelectorInput() {
    return this._querySelector;
  }

  // read_existing_events - computed: true, optional: true, required: false
  private _readExistingEvents?: boolean | cdktf.IResolvable; 
  public get readExistingEvents() {
    return this.getBooleanAttribute('read_existing_events');
  }
  public set readExistingEvents(value: boolean | cdktf.IResolvable) {
    this._readExistingEvents = value;
  }
  public resetReadExistingEvents() {
    this._readExistingEvents = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get readExistingEventsInput() {
    return this._readExistingEvents;
  }

  // send_bookmarks - computed: true, optional: true, required: false
  private _sendBookmarks?: boolean | cdktf.IResolvable; 
  public get sendBookmarks() {
    return this.getBooleanAttribute('send_bookmarks');
  }
  public set sendBookmarks(value: boolean | cdktf.IResolvable) {
    this._sendBookmarks = value;
  }
  public resetSendBookmarks() {
    this._sendBookmarks = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sendBookmarksInput() {
    return this._sendBookmarks;
  }

  // subscription_name - computed: false, optional: false, required: true
  private _subscriptionName?: string; 
  public get subscriptionName() {
    return this.getStringAttribute('subscription_name');
  }
  public set subscriptionName(value: string) {
    this._subscriptionName = value;
  }
  // Temporarily expose input value. Use with caution.
  public get subscriptionNameInput() {
    return this._subscriptionName;
  }

  // targets - computed: true, optional: true, required: false
  private _targets?: string[]; 
  public get targets() {
    return this.getListAttribute('targets');
  }
  public set targets(value: string[]) {
    this._targets = value;
  }
  public resetTargets() {
    this._targets = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get targetsInput() {
    return this._targets;
  }

  // version - computed: false, optional: true, required: false
  private _version?: string; 
  public get version() {
    return this.getStringAttribute('version');
  }
  public set version(value: string) {
    this._version = value;
  }
  public resetVersion() {
    this._version = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get versionInput() {
    return this._version;
  }
}

export class PackSourceInputWefSubscriptionsList extends cdktf.ComplexList {
  public internalValue? : PackSourceInputWefSubscriptions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackSourceInputWefSubscriptionsOutputReference {
    return new PackSourceInputWefSubscriptionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackSourceInputWefTls {
  /**
  * Server path containing CA certificates (in PEM format) to use. Can reference $ENV_VARS. If multiple certificates are present in a .pem, each must directly certify the one preceding it.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#ca_path PackSource#ca_path}
  */
  readonly caPath: string;
  /**
  * Path on server containing certificates to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#cert_path PackSource#cert_path}
  */
  readonly certPath: string;
  /**
  * Name of the predefined certificate
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#certificate_name PackSource#certificate_name}
  */
  readonly certificateName?: string;
  /**
  * Regex matching allowable common names in peer certificates' subject attribute. Default: "/.* /"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#common_name_regex PackSource#common_name_regex}
   *
  * Note: The above comment contained a comment block ending sequence (* followed by /). We have introduced a space between to prevent syntax errors. Please ignore the space.
  */
  readonly commonNameRegex?: string;
  /**
  * Enable TLS. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#disabled PackSource#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * Parsed as JSON.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#keytab PackSource#keytab}
  */
  readonly keytab?: string;
  /**
  * must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_version PackSource#max_version}
  */
  readonly maxVersion?: string;
  /**
  * must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#min_version PackSource#min_version}
  */
  readonly minVersion?: string;
  /**
  * Enable OCSP check of certificate. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#ocsp_check PackSource#ocsp_check}
  */
  readonly ocspCheck?: boolean | cdktf.IResolvable;
  /**
  * If enabled, checks will fail on any OCSP error. Otherwise, checks will fail only when a certificate is revoked, ignoring other errors. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#ocsp_check_fail_close PackSource#ocsp_check_fail_close}
  */
  readonly ocspCheckFailClose?: boolean | cdktf.IResolvable;
  /**
  * Passphrase to use to decrypt private key
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#passphrase PackSource#passphrase}
  */
  readonly passphrase?: string;
  /**
  * Parsed as JSON.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#principal PackSource#principal}
  */
  readonly principal?: string;
  /**
  * Path on server containing the private key to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#priv_key_path PackSource#priv_key_path}
  */
  readonly privKeyPath: string;
  /**
  * Required for WEF certificate authentication. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#reject_unauthorized PackSource#reject_unauthorized}
  */
  readonly rejectUnauthorized?: boolean | cdktf.IResolvable;
  /**
  * Required for WEF certificate authentication. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#request_cert PackSource#request_cert}
  */
  readonly requestCert?: boolean | cdktf.IResolvable;
}

export function packSourceInputWefTlsToTerraform(struct?: PackSourceInputWefTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ca_path: cdktf.stringToTerraform(struct!.caPath),
    cert_path: cdktf.stringToTerraform(struct!.certPath),
    certificate_name: cdktf.stringToTerraform(struct!.certificateName),
    common_name_regex: cdktf.stringToTerraform(struct!.commonNameRegex),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    keytab: cdktf.stringToTerraform(struct!.keytab),
    max_version: cdktf.stringToTerraform(struct!.maxVersion),
    min_version: cdktf.stringToTerraform(struct!.minVersion),
    ocsp_check: cdktf.booleanToTerraform(struct!.ocspCheck),
    ocsp_check_fail_close: cdktf.booleanToTerraform(struct!.ocspCheckFailClose),
    passphrase: cdktf.stringToTerraform(struct!.passphrase),
    principal: cdktf.stringToTerraform(struct!.principal),
    priv_key_path: cdktf.stringToTerraform(struct!.privKeyPath),
    reject_unauthorized: cdktf.booleanToTerraform(struct!.rejectUnauthorized),
    request_cert: cdktf.booleanToTerraform(struct!.requestCert),
  }
}


export function packSourceInputWefTlsToHclTerraform(struct?: PackSourceInputWefTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ca_path: {
      value: cdktf.stringToHclTerraform(struct!.caPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    cert_path: {
      value: cdktf.stringToHclTerraform(struct!.certPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    certificate_name: {
      value: cdktf.stringToHclTerraform(struct!.certificateName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    common_name_regex: {
      value: cdktf.stringToHclTerraform(struct!.commonNameRegex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    keytab: {
      value: cdktf.stringToHclTerraform(struct!.keytab),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_version: {
      value: cdktf.stringToHclTerraform(struct!.maxVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    min_version: {
      value: cdktf.stringToHclTerraform(struct!.minVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ocsp_check: {
      value: cdktf.booleanToHclTerraform(struct!.ocspCheck),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    ocsp_check_fail_close: {
      value: cdktf.booleanToHclTerraform(struct!.ocspCheckFailClose),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    passphrase: {
      value: cdktf.stringToHclTerraform(struct!.passphrase),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    principal: {
      value: cdktf.stringToHclTerraform(struct!.principal),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    priv_key_path: {
      value: cdktf.stringToHclTerraform(struct!.privKeyPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reject_unauthorized: {
      value: cdktf.booleanToHclTerraform(struct!.rejectUnauthorized),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    request_cert: {
      value: cdktf.booleanToHclTerraform(struct!.requestCert),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputWefTlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputWefTls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._caPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.caPath = this._caPath;
    }
    if (this._certPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.certPath = this._certPath;
    }
    if (this._certificateName !== undefined) {
      hasAnyValues = true;
      internalValueResult.certificateName = this._certificateName;
    }
    if (this._commonNameRegex !== undefined) {
      hasAnyValues = true;
      internalValueResult.commonNameRegex = this._commonNameRegex;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._keytab !== undefined) {
      hasAnyValues = true;
      internalValueResult.keytab = this._keytab;
    }
    if (this._maxVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxVersion = this._maxVersion;
    }
    if (this._minVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.minVersion = this._minVersion;
    }
    if (this._ocspCheck !== undefined) {
      hasAnyValues = true;
      internalValueResult.ocspCheck = this._ocspCheck;
    }
    if (this._ocspCheckFailClose !== undefined) {
      hasAnyValues = true;
      internalValueResult.ocspCheckFailClose = this._ocspCheckFailClose;
    }
    if (this._passphrase !== undefined) {
      hasAnyValues = true;
      internalValueResult.passphrase = this._passphrase;
    }
    if (this._principal !== undefined) {
      hasAnyValues = true;
      internalValueResult.principal = this._principal;
    }
    if (this._privKeyPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.privKeyPath = this._privKeyPath;
    }
    if (this._rejectUnauthorized !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectUnauthorized = this._rejectUnauthorized;
    }
    if (this._requestCert !== undefined) {
      hasAnyValues = true;
      internalValueResult.requestCert = this._requestCert;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputWefTls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._caPath = undefined;
      this._certPath = undefined;
      this._certificateName = undefined;
      this._commonNameRegex = undefined;
      this._disabled = undefined;
      this._keytab = undefined;
      this._maxVersion = undefined;
      this._minVersion = undefined;
      this._ocspCheck = undefined;
      this._ocspCheckFailClose = undefined;
      this._passphrase = undefined;
      this._principal = undefined;
      this._privKeyPath = undefined;
      this._rejectUnauthorized = undefined;
      this._requestCert = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._caPath = value.caPath;
      this._certPath = value.certPath;
      this._certificateName = value.certificateName;
      this._commonNameRegex = value.commonNameRegex;
      this._disabled = value.disabled;
      this._keytab = value.keytab;
      this._maxVersion = value.maxVersion;
      this._minVersion = value.minVersion;
      this._ocspCheck = value.ocspCheck;
      this._ocspCheckFailClose = value.ocspCheckFailClose;
      this._passphrase = value.passphrase;
      this._principal = value.principal;
      this._privKeyPath = value.privKeyPath;
      this._rejectUnauthorized = value.rejectUnauthorized;
      this._requestCert = value.requestCert;
    }
  }

  // ca_path - computed: false, optional: false, required: true
  private _caPath?: string; 
  public get caPath() {
    return this.getStringAttribute('ca_path');
  }
  public set caPath(value: string) {
    this._caPath = value;
  }
  // Temporarily expose input value. Use with caution.
  public get caPathInput() {
    return this._caPath;
  }

  // cert_path - computed: false, optional: false, required: true
  private _certPath?: string; 
  public get certPath() {
    return this.getStringAttribute('cert_path');
  }
  public set certPath(value: string) {
    this._certPath = value;
  }
  // Temporarily expose input value. Use with caution.
  public get certPathInput() {
    return this._certPath;
  }

  // certificate_name - computed: false, optional: true, required: false
  private _certificateName?: string; 
  public get certificateName() {
    return this.getStringAttribute('certificate_name');
  }
  public set certificateName(value: string) {
    this._certificateName = value;
  }
  public resetCertificateName() {
    this._certificateName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certificateNameInput() {
    return this._certificateName;
  }

  // common_name_regex - computed: true, optional: true, required: false
  private _commonNameRegex?: string; 
  public get commonNameRegex() {
    return this.getStringAttribute('common_name_regex');
  }
  public set commonNameRegex(value: string) {
    this._commonNameRegex = value;
  }
  public resetCommonNameRegex() {
    this._commonNameRegex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commonNameRegexInput() {
    return this._commonNameRegex;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // keytab - computed: false, optional: true, required: false
  private _keytab?: string; 
  public get keytab() {
    return this.getStringAttribute('keytab');
  }
  public set keytab(value: string) {
    this._keytab = value;
  }
  public resetKeytab() {
    this._keytab = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keytabInput() {
    return this._keytab;
  }

  // max_version - computed: false, optional: true, required: false
  private _maxVersion?: string; 
  public get maxVersion() {
    return this.getStringAttribute('max_version');
  }
  public set maxVersion(value: string) {
    this._maxVersion = value;
  }
  public resetMaxVersion() {
    this._maxVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxVersionInput() {
    return this._maxVersion;
  }

  // min_version - computed: false, optional: true, required: false
  private _minVersion?: string; 
  public get minVersion() {
    return this.getStringAttribute('min_version');
  }
  public set minVersion(value: string) {
    this._minVersion = value;
  }
  public resetMinVersion() {
    this._minVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get minVersionInput() {
    return this._minVersion;
  }

  // ocsp_check - computed: true, optional: true, required: false
  private _ocspCheck?: boolean | cdktf.IResolvable; 
  public get ocspCheck() {
    return this.getBooleanAttribute('ocsp_check');
  }
  public set ocspCheck(value: boolean | cdktf.IResolvable) {
    this._ocspCheck = value;
  }
  public resetOcspCheck() {
    this._ocspCheck = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ocspCheckInput() {
    return this._ocspCheck;
  }

  // ocsp_check_fail_close - computed: true, optional: true, required: false
  private _ocspCheckFailClose?: boolean | cdktf.IResolvable; 
  public get ocspCheckFailClose() {
    return this.getBooleanAttribute('ocsp_check_fail_close');
  }
  public set ocspCheckFailClose(value: boolean | cdktf.IResolvable) {
    this._ocspCheckFailClose = value;
  }
  public resetOcspCheckFailClose() {
    this._ocspCheckFailClose = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ocspCheckFailCloseInput() {
    return this._ocspCheckFailClose;
  }

  // passphrase - computed: false, optional: true, required: false
  private _passphrase?: string; 
  public get passphrase() {
    return this.getStringAttribute('passphrase');
  }
  public set passphrase(value: string) {
    this._passphrase = value;
  }
  public resetPassphrase() {
    this._passphrase = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passphraseInput() {
    return this._passphrase;
  }

  // principal - computed: false, optional: true, required: false
  private _principal?: string; 
  public get principal() {
    return this.getStringAttribute('principal');
  }
  public set principal(value: string) {
    this._principal = value;
  }
  public resetPrincipal() {
    this._principal = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get principalInput() {
    return this._principal;
  }

  // priv_key_path - computed: false, optional: false, required: true
  private _privKeyPath?: string; 
  public get privKeyPath() {
    return this.getStringAttribute('priv_key_path');
  }
  public set privKeyPath(value: string) {
    this._privKeyPath = value;
  }
  // Temporarily expose input value. Use with caution.
  public get privKeyPathInput() {
    return this._privKeyPath;
  }

  // reject_unauthorized - computed: true, optional: true, required: false
  private _rejectUnauthorized?: boolean | cdktf.IResolvable; 
  public get rejectUnauthorized() {
    return this.getBooleanAttribute('reject_unauthorized');
  }
  public set rejectUnauthorized(value: boolean | cdktf.IResolvable) {
    this._rejectUnauthorized = value;
  }
  public resetRejectUnauthorized() {
    this._rejectUnauthorized = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectUnauthorizedInput() {
    return this._rejectUnauthorized;
  }

  // request_cert - computed: true, optional: true, required: false
  private _requestCert?: boolean | cdktf.IResolvable; 
  public get requestCert() {
    return this.getBooleanAttribute('request_cert');
  }
  public set requestCert(value: boolean | cdktf.IResolvable) {
    this._requestCert = value;
  }
  public resetRequestCert() {
    this._requestCert = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestCertInput() {
    return this._requestCert;
  }
}
export interface PackSourceInputWef {
  /**
  * Allow events to be ingested even if their MachineID does not match the client certificate CN. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#allow_machine_id_mismatch PackSource#allow_machine_id_mismatch}
  */
  readonly allowMachineIdMismatch?: boolean | cdktf.IResolvable;
  /**
  * How to authenticate incoming client connections. Default: "clientCert"; must be one of ["clientCert", "kerberos"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#auth_method PackSource#auth_method}
  */
  readonly authMethod?: string;
  /**
  * SHA1 fingerprint expected by the client, if it does not match the first certificate in the configured CA chain
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#ca_fingerprint PackSource#ca_fingerprint}
  */
  readonly caFingerprint?: string;
  /**
  * Add request headers to events in the __headers field. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#capture_headers PackSource#capture_headers}
  */
  readonly captureHeaders?: boolean | cdktf.IResolvable;
  /**
  * Direct connections to Destinations, and optionally via a Pipeline or a Pack
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#connections PackSource#connections}
  */
  readonly connections?: PackSourceInputWefConnections[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#description PackSource#description}
  */
  readonly description?: string;
  /**
  * Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#disabled PackSource#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#enable_health_check PackSource#enable_health_check}
  */
  readonly enableHealthCheck?: boolean | cdktf.IResolvable;
  /**
  * Preserve the client’s original IP address in the __srcIpPort field when connecting through an HTTP proxy that supports the X-Forwarded-For header. This does not apply to TCP-layer Proxy Protocol v1/v2. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#enable_proxy_header PackSource#enable_proxy_header}
  */
  readonly enableProxyHeader?: boolean | cdktf.IResolvable;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#environment PackSource#environment}
  */
  readonly environment?: string;
  /**
  * Address to bind on. Defaults to 0.0.0.0 (all addresses). Default: "0.0.0.0"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#host PackSource#host}
  */
  readonly host?: string;
  /**
  * Unique ID for this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#id PackSource#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * Messages from matched IP addresses will be processed, unless also matched by the denylist. Default: "/.* /"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#ip_allowlist_regex PackSource#ip_allowlist_regex}
   *
  * Note: The above comment contained a comment block ending sequence (* followed by /). We have introduced a space between to prevent syntax errors. Please ignore the space.
  */
  readonly ipAllowlistRegex?: string;
  /**
  * Messages from matched IP addresses will be ignored. This takes precedence over the allowlist. Default: "/^$/"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#ip_denylist_regex PackSource#ip_denylist_regex}
  */
  readonly ipDenylistRegex?: string;
  /**
  * After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes). Default: 90
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#keep_alive_timeout PackSource#keep_alive_timeout}
  */
  readonly keepAliveTimeout?: number;
  /**
  * Path to the keytab file containing the service principal credentials. @{product} will use `/etc/krb5.keytab` if not provided.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#keytab PackSource#keytab}
  */
  readonly keytab?: string;
  /**
  * Log a warning if the client certificate authority (CA) fingerprint does not match the expected value. A mismatch prevents Cribl from receiving events from the Windows Event Forwarder. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#log_fingerprint_mismatch PackSource#log_fingerprint_mismatch}
  */
  readonly logFingerprintMismatch?: boolean | cdktf.IResolvable;
  /**
  * Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput. Default: 256
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_active_req PackSource#max_active_req}
  */
  readonly maxActiveReq?: number;
  /**
  * Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited). Default: 0
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_requests_per_socket PackSource#max_requests_per_socket}
  */
  readonly maxRequestsPerSocket?: number;
  /**
  * Fields to add to events from this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#metadata PackSource#metadata}
  */
  readonly metadata?: PackSourceInputWefMetadata[] | cdktf.IResolvable;
  /**
  * Pipeline to process data from this Source before sending it through the Routes
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pipeline PackSource#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Port to listen on. Default: 5986
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#port PackSource#port}
  */
  readonly port?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pq PackSource#pq}
  */
  readonly pq?: PackSourceInputWefPq;
  /**
  * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers). Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pq_enabled PackSource#pq_enabled}
  */
  readonly pqEnabled?: boolean | cdktf.IResolvable;
  /**
  * Kerberos principal used for authentication, typically in the form HTTP/<hostname>@<REALM>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#principal PackSource#principal}
  */
  readonly principal?: string;
  /**
  * Select whether to send data to Routes, or directly to Destinations. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#send_to_routes PackSource#send_to_routes}
  */
  readonly sendToRoutes?: boolean | cdktf.IResolvable;
  /**
  * How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0. Default: 0
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#socket_timeout PackSource#socket_timeout}
  */
  readonly socketTimeout?: number;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#streamtags PackSource#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Subscriptions to events on forwarding endpoints
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#subscriptions PackSource#subscriptions}
  */
  readonly subscriptions: PackSourceInputWefSubscriptions[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#tls PackSource#tls}
  */
  readonly tls?: PackSourceInputWefTls;
  /**
  * must be "wef"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#type PackSource#type}
  */
  readonly type?: string;
}

export function packSourceInputWefToTerraform(struct?: PackSourceInputWef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    allow_machine_id_mismatch: cdktf.booleanToTerraform(struct!.allowMachineIdMismatch),
    auth_method: cdktf.stringToTerraform(struct!.authMethod),
    ca_fingerprint: cdktf.stringToTerraform(struct!.caFingerprint),
    capture_headers: cdktf.booleanToTerraform(struct!.captureHeaders),
    connections: cdktf.listMapper(packSourceInputWefConnectionsToTerraform, false)(struct!.connections),
    description: cdktf.stringToTerraform(struct!.description),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    enable_health_check: cdktf.booleanToTerraform(struct!.enableHealthCheck),
    enable_proxy_header: cdktf.booleanToTerraform(struct!.enableProxyHeader),
    environment: cdktf.stringToTerraform(struct!.environment),
    host: cdktf.stringToTerraform(struct!.host),
    id: cdktf.stringToTerraform(struct!.id),
    ip_allowlist_regex: cdktf.stringToTerraform(struct!.ipAllowlistRegex),
    ip_denylist_regex: cdktf.stringToTerraform(struct!.ipDenylistRegex),
    keep_alive_timeout: cdktf.numberToTerraform(struct!.keepAliveTimeout),
    keytab: cdktf.stringToTerraform(struct!.keytab),
    log_fingerprint_mismatch: cdktf.booleanToTerraform(struct!.logFingerprintMismatch),
    max_active_req: cdktf.numberToTerraform(struct!.maxActiveReq),
    max_requests_per_socket: cdktf.numberToTerraform(struct!.maxRequestsPerSocket),
    metadata: cdktf.listMapper(packSourceInputWefMetadataToTerraform, false)(struct!.metadata),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    port: cdktf.numberToTerraform(struct!.port),
    pq: packSourceInputWefPqToTerraform(struct!.pq),
    pq_enabled: cdktf.booleanToTerraform(struct!.pqEnabled),
    principal: cdktf.stringToTerraform(struct!.principal),
    send_to_routes: cdktf.booleanToTerraform(struct!.sendToRoutes),
    socket_timeout: cdktf.numberToTerraform(struct!.socketTimeout),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    subscriptions: cdktf.listMapper(packSourceInputWefSubscriptionsToTerraform, false)(struct!.subscriptions),
    tls: packSourceInputWefTlsToTerraform(struct!.tls),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function packSourceInputWefToHclTerraform(struct?: PackSourceInputWef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    allow_machine_id_mismatch: {
      value: cdktf.booleanToHclTerraform(struct!.allowMachineIdMismatch),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    auth_method: {
      value: cdktf.stringToHclTerraform(struct!.authMethod),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ca_fingerprint: {
      value: cdktf.stringToHclTerraform(struct!.caFingerprint),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    capture_headers: {
      value: cdktf.booleanToHclTerraform(struct!.captureHeaders),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    connections: {
      value: cdktf.listMapperHcl(packSourceInputWefConnectionsToHclTerraform, false)(struct!.connections),
      isBlock: true,
      type: "list",
      storageClassType: "PackSourceInputWefConnectionsList",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    enable_health_check: {
      value: cdktf.booleanToHclTerraform(struct!.enableHealthCheck),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    enable_proxy_header: {
      value: cdktf.booleanToHclTerraform(struct!.enableProxyHeader),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    host: {
      value: cdktf.stringToHclTerraform(struct!.host),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ip_allowlist_regex: {
      value: cdktf.stringToHclTerraform(struct!.ipAllowlistRegex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ip_denylist_regex: {
      value: cdktf.stringToHclTerraform(struct!.ipDenylistRegex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    keep_alive_timeout: {
      value: cdktf.numberToHclTerraform(struct!.keepAliveTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    keytab: {
      value: cdktf.stringToHclTerraform(struct!.keytab),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    log_fingerprint_mismatch: {
      value: cdktf.booleanToHclTerraform(struct!.logFingerprintMismatch),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    max_active_req: {
      value: cdktf.numberToHclTerraform(struct!.maxActiveReq),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_requests_per_socket: {
      value: cdktf.numberToHclTerraform(struct!.maxRequestsPerSocket),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    metadata: {
      value: cdktf.listMapperHcl(packSourceInputWefMetadataToHclTerraform, false)(struct!.metadata),
      isBlock: true,
      type: "list",
      storageClassType: "PackSourceInputWefMetadataList",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    pq: {
      value: packSourceInputWefPqToHclTerraform(struct!.pq),
      isBlock: true,
      type: "struct",
      storageClassType: "PackSourceInputWefPq",
    },
    pq_enabled: {
      value: cdktf.booleanToHclTerraform(struct!.pqEnabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    principal: {
      value: cdktf.stringToHclTerraform(struct!.principal),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    send_to_routes: {
      value: cdktf.booleanToHclTerraform(struct!.sendToRoutes),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    socket_timeout: {
      value: cdktf.numberToHclTerraform(struct!.socketTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    subscriptions: {
      value: cdktf.listMapperHcl(packSourceInputWefSubscriptionsToHclTerraform, false)(struct!.subscriptions),
      isBlock: true,
      type: "list",
      storageClassType: "PackSourceInputWefSubscriptionsList",
    },
    tls: {
      value: packSourceInputWefTlsToHclTerraform(struct!.tls),
      isBlock: true,
      type: "struct",
      storageClassType: "PackSourceInputWefTls",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputWefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputWef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._allowMachineIdMismatch !== undefined) {
      hasAnyValues = true;
      internalValueResult.allowMachineIdMismatch = this._allowMachineIdMismatch;
    }
    if (this._authMethod !== undefined) {
      hasAnyValues = true;
      internalValueResult.authMethod = this._authMethod;
    }
    if (this._caFingerprint !== undefined) {
      hasAnyValues = true;
      internalValueResult.caFingerprint = this._caFingerprint;
    }
    if (this._captureHeaders !== undefined) {
      hasAnyValues = true;
      internalValueResult.captureHeaders = this._captureHeaders;
    }
    if (this._connections?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.connections = this._connections?.internalValue;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._enableHealthCheck !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableHealthCheck = this._enableHealthCheck;
    }
    if (this._enableProxyHeader !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableProxyHeader = this._enableProxyHeader;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._host !== undefined) {
      hasAnyValues = true;
      internalValueResult.host = this._host;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._ipAllowlistRegex !== undefined) {
      hasAnyValues = true;
      internalValueResult.ipAllowlistRegex = this._ipAllowlistRegex;
    }
    if (this._ipDenylistRegex !== undefined) {
      hasAnyValues = true;
      internalValueResult.ipDenylistRegex = this._ipDenylistRegex;
    }
    if (this._keepAliveTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.keepAliveTimeout = this._keepAliveTimeout;
    }
    if (this._keytab !== undefined) {
      hasAnyValues = true;
      internalValueResult.keytab = this._keytab;
    }
    if (this._logFingerprintMismatch !== undefined) {
      hasAnyValues = true;
      internalValueResult.logFingerprintMismatch = this._logFingerprintMismatch;
    }
    if (this._maxActiveReq !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxActiveReq = this._maxActiveReq;
    }
    if (this._maxRequestsPerSocket !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxRequestsPerSocket = this._maxRequestsPerSocket;
    }
    if (this._metadata?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadata = this._metadata?.internalValue;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._pq?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pq = this._pq?.internalValue;
    }
    if (this._pqEnabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqEnabled = this._pqEnabled;
    }
    if (this._principal !== undefined) {
      hasAnyValues = true;
      internalValueResult.principal = this._principal;
    }
    if (this._sendToRoutes !== undefined) {
      hasAnyValues = true;
      internalValueResult.sendToRoutes = this._sendToRoutes;
    }
    if (this._socketTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.socketTimeout = this._socketTimeout;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._subscriptions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.subscriptions = this._subscriptions?.internalValue;
    }
    if (this._tls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tls = this._tls?.internalValue;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputWef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._allowMachineIdMismatch = undefined;
      this._authMethod = undefined;
      this._caFingerprint = undefined;
      this._captureHeaders = undefined;
      this._connections.internalValue = undefined;
      this._description = undefined;
      this._disabled = undefined;
      this._enableHealthCheck = undefined;
      this._enableProxyHeader = undefined;
      this._environment = undefined;
      this._host = undefined;
      this._id = undefined;
      this._ipAllowlistRegex = undefined;
      this._ipDenylistRegex = undefined;
      this._keepAliveTimeout = undefined;
      this._keytab = undefined;
      this._logFingerprintMismatch = undefined;
      this._maxActiveReq = undefined;
      this._maxRequestsPerSocket = undefined;
      this._metadata.internalValue = undefined;
      this._pipeline = undefined;
      this._port = undefined;
      this._pq.internalValue = undefined;
      this._pqEnabled = undefined;
      this._principal = undefined;
      this._sendToRoutes = undefined;
      this._socketTimeout = undefined;
      this._streamtags = undefined;
      this._subscriptions.internalValue = undefined;
      this._tls.internalValue = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._allowMachineIdMismatch = value.allowMachineIdMismatch;
      this._authMethod = value.authMethod;
      this._caFingerprint = value.caFingerprint;
      this._captureHeaders = value.captureHeaders;
      this._connections.internalValue = value.connections;
      this._description = value.description;
      this._disabled = value.disabled;
      this._enableHealthCheck = value.enableHealthCheck;
      this._enableProxyHeader = value.enableProxyHeader;
      this._environment = value.environment;
      this._host = value.host;
      this._id = value.id;
      this._ipAllowlistRegex = value.ipAllowlistRegex;
      this._ipDenylistRegex = value.ipDenylistRegex;
      this._keepAliveTimeout = value.keepAliveTimeout;
      this._keytab = value.keytab;
      this._logFingerprintMismatch = value.logFingerprintMismatch;
      this._maxActiveReq = value.maxActiveReq;
      this._maxRequestsPerSocket = value.maxRequestsPerSocket;
      this._metadata.internalValue = value.metadata;
      this._pipeline = value.pipeline;
      this._port = value.port;
      this._pq.internalValue = value.pq;
      this._pqEnabled = value.pqEnabled;
      this._principal = value.principal;
      this._sendToRoutes = value.sendToRoutes;
      this._socketTimeout = value.socketTimeout;
      this._streamtags = value.streamtags;
      this._subscriptions.internalValue = value.subscriptions;
      this._tls.internalValue = value.tls;
      this._type = value.type;
    }
  }

  // allow_machine_id_mismatch - computed: true, optional: true, required: false
  private _allowMachineIdMismatch?: boolean | cdktf.IResolvable; 
  public get allowMachineIdMismatch() {
    return this.getBooleanAttribute('allow_machine_id_mismatch');
  }
  public set allowMachineIdMismatch(value: boolean | cdktf.IResolvable) {
    this._allowMachineIdMismatch = value;
  }
  public resetAllowMachineIdMismatch() {
    this._allowMachineIdMismatch = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get allowMachineIdMismatchInput() {
    return this._allowMachineIdMismatch;
  }

  // auth_method - computed: true, optional: true, required: false
  private _authMethod?: string; 
  public get authMethod() {
    return this.getStringAttribute('auth_method');
  }
  public set authMethod(value: string) {
    this._authMethod = value;
  }
  public resetAuthMethod() {
    this._authMethod = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authMethodInput() {
    return this._authMethod;
  }

  // ca_fingerprint - computed: false, optional: true, required: false
  private _caFingerprint?: string; 
  public get caFingerprint() {
    return this.getStringAttribute('ca_fingerprint');
  }
  public set caFingerprint(value: string) {
    this._caFingerprint = value;
  }
  public resetCaFingerprint() {
    this._caFingerprint = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get caFingerprintInput() {
    return this._caFingerprint;
  }

  // capture_headers - computed: true, optional: true, required: false
  private _captureHeaders?: boolean | cdktf.IResolvable; 
  public get captureHeaders() {
    return this.getBooleanAttribute('capture_headers');
  }
  public set captureHeaders(value: boolean | cdktf.IResolvable) {
    this._captureHeaders = value;
  }
  public resetCaptureHeaders() {
    this._captureHeaders = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get captureHeadersInput() {
    return this._captureHeaders;
  }

  // connections - computed: false, optional: true, required: false
  private _connections = new PackSourceInputWefConnectionsList(this, "connections", false);
  public get connections() {
    return this._connections;
  }
  public putConnections(value: PackSourceInputWefConnections[] | cdktf.IResolvable) {
    this._connections.internalValue = value;
  }
  public resetConnections() {
    this._connections.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectionsInput() {
    return this._connections.internalValue;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // enable_health_check - computed: true, optional: true, required: false
  private _enableHealthCheck?: boolean | cdktf.IResolvable; 
  public get enableHealthCheck() {
    return this.getBooleanAttribute('enable_health_check');
  }
  public set enableHealthCheck(value: boolean | cdktf.IResolvable) {
    this._enableHealthCheck = value;
  }
  public resetEnableHealthCheck() {
    this._enableHealthCheck = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableHealthCheckInput() {
    return this._enableHealthCheck;
  }

  // enable_proxy_header - computed: true, optional: true, required: false
  private _enableProxyHeader?: boolean | cdktf.IResolvable; 
  public get enableProxyHeader() {
    return this.getBooleanAttribute('enable_proxy_header');
  }
  public set enableProxyHeader(value: boolean | cdktf.IResolvable) {
    this._enableProxyHeader = value;
  }
  public resetEnableProxyHeader() {
    this._enableProxyHeader = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableProxyHeaderInput() {
    return this._enableProxyHeader;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // host - computed: true, optional: true, required: false
  private _host?: string; 
  public get host() {
    return this.getStringAttribute('host');
  }
  public set host(value: string) {
    this._host = value;
  }
  public resetHost() {
    this._host = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostInput() {
    return this._host;
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // ip_allowlist_regex - computed: true, optional: true, required: false
  private _ipAllowlistRegex?: string; 
  public get ipAllowlistRegex() {
    return this.getStringAttribute('ip_allowlist_regex');
  }
  public set ipAllowlistRegex(value: string) {
    this._ipAllowlistRegex = value;
  }
  public resetIpAllowlistRegex() {
    this._ipAllowlistRegex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ipAllowlistRegexInput() {
    return this._ipAllowlistRegex;
  }

  // ip_denylist_regex - computed: true, optional: true, required: false
  private _ipDenylistRegex?: string; 
  public get ipDenylistRegex() {
    return this.getStringAttribute('ip_denylist_regex');
  }
  public set ipDenylistRegex(value: string) {
    this._ipDenylistRegex = value;
  }
  public resetIpDenylistRegex() {
    this._ipDenylistRegex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ipDenylistRegexInput() {
    return this._ipDenylistRegex;
  }

  // keep_alive_timeout - computed: true, optional: true, required: false
  private _keepAliveTimeout?: number; 
  public get keepAliveTimeout() {
    return this.getNumberAttribute('keep_alive_timeout');
  }
  public set keepAliveTimeout(value: number) {
    this._keepAliveTimeout = value;
  }
  public resetKeepAliveTimeout() {
    this._keepAliveTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keepAliveTimeoutInput() {
    return this._keepAliveTimeout;
  }

  // keytab - computed: false, optional: true, required: false
  private _keytab?: string; 
  public get keytab() {
    return this.getStringAttribute('keytab');
  }
  public set keytab(value: string) {
    this._keytab = value;
  }
  public resetKeytab() {
    this._keytab = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keytabInput() {
    return this._keytab;
  }

  // log_fingerprint_mismatch - computed: true, optional: true, required: false
  private _logFingerprintMismatch?: boolean | cdktf.IResolvable; 
  public get logFingerprintMismatch() {
    return this.getBooleanAttribute('log_fingerprint_mismatch');
  }
  public set logFingerprintMismatch(value: boolean | cdktf.IResolvable) {
    this._logFingerprintMismatch = value;
  }
  public resetLogFingerprintMismatch() {
    this._logFingerprintMismatch = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get logFingerprintMismatchInput() {
    return this._logFingerprintMismatch;
  }

  // max_active_req - computed: true, optional: true, required: false
  private _maxActiveReq?: number; 
  public get maxActiveReq() {
    return this.getNumberAttribute('max_active_req');
  }
  public set maxActiveReq(value: number) {
    this._maxActiveReq = value;
  }
  public resetMaxActiveReq() {
    this._maxActiveReq = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxActiveReqInput() {
    return this._maxActiveReq;
  }

  // max_requests_per_socket - computed: true, optional: true, required: false
  private _maxRequestsPerSocket?: number; 
  public get maxRequestsPerSocket() {
    return this.getNumberAttribute('max_requests_per_socket');
  }
  public set maxRequestsPerSocket(value: number) {
    this._maxRequestsPerSocket = value;
  }
  public resetMaxRequestsPerSocket() {
    this._maxRequestsPerSocket = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxRequestsPerSocketInput() {
    return this._maxRequestsPerSocket;
  }

  // metadata - computed: false, optional: true, required: false
  private _metadata = new PackSourceInputWefMetadataList(this, "metadata", false);
  public get metadata() {
    return this._metadata;
  }
  public putMetadata(value: PackSourceInputWefMetadata[] | cdktf.IResolvable) {
    this._metadata.internalValue = value;
  }
  public resetMetadata() {
    this._metadata.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataInput() {
    return this._metadata.internalValue;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // port - computed: true, optional: true, required: false
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // pq - computed: false, optional: true, required: false
  private _pq = new PackSourceInputWefPqOutputReference(this, "pq");
  public get pq() {
    return this._pq;
  }
  public putPq(value: PackSourceInputWefPq) {
    this._pq.internalValue = value;
  }
  public resetPq() {
    this._pq.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqInput() {
    return this._pq.internalValue;
  }

  // pq_enabled - computed: true, optional: true, required: false
  private _pqEnabled?: boolean | cdktf.IResolvable; 
  public get pqEnabled() {
    return this.getBooleanAttribute('pq_enabled');
  }
  public set pqEnabled(value: boolean | cdktf.IResolvable) {
    this._pqEnabled = value;
  }
  public resetPqEnabled() {
    this._pqEnabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqEnabledInput() {
    return this._pqEnabled;
  }

  // principal - computed: false, optional: true, required: false
  private _principal?: string; 
  public get principal() {
    return this.getStringAttribute('principal');
  }
  public set principal(value: string) {
    this._principal = value;
  }
  public resetPrincipal() {
    this._principal = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get principalInput() {
    return this._principal;
  }

  // send_to_routes - computed: true, optional: true, required: false
  private _sendToRoutes?: boolean | cdktf.IResolvable; 
  public get sendToRoutes() {
    return this.getBooleanAttribute('send_to_routes');
  }
  public set sendToRoutes(value: boolean | cdktf.IResolvable) {
    this._sendToRoutes = value;
  }
  public resetSendToRoutes() {
    this._sendToRoutes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sendToRoutesInput() {
    return this._sendToRoutes;
  }

  // socket_timeout - computed: true, optional: true, required: false
  private _socketTimeout?: number; 
  public get socketTimeout() {
    return this.getNumberAttribute('socket_timeout');
  }
  public set socketTimeout(value: number) {
    this._socketTimeout = value;
  }
  public resetSocketTimeout() {
    this._socketTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get socketTimeoutInput() {
    return this._socketTimeout;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // subscriptions - computed: false, optional: false, required: true
  private _subscriptions = new PackSourceInputWefSubscriptionsList(this, "subscriptions", false);
  public get subscriptions() {
    return this._subscriptions;
  }
  public putSubscriptions(value: PackSourceInputWefSubscriptions[] | cdktf.IResolvable) {
    this._subscriptions.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get subscriptionsInput() {
    return this._subscriptions.internalValue;
  }

  // tls - computed: false, optional: true, required: false
  private _tls = new PackSourceInputWefTlsOutputReference(this, "tls");
  public get tls() {
    return this._tls;
  }
  public putTls(value: PackSourceInputWefTls) {
    this._tls.internalValue = value;
  }
  public resetTls() {
    this._tls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsInput() {
    return this._tls.internalValue;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface PackSourceInputWinEventLogsConnections {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#output PackSource#output}
  */
  readonly output: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pipeline PackSource#pipeline}
  */
  readonly pipeline?: string;
}

export function packSourceInputWinEventLogsConnectionsToTerraform(struct?: PackSourceInputWinEventLogsConnections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    output: cdktf.stringToTerraform(struct!.output),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
  }
}


export function packSourceInputWinEventLogsConnectionsToHclTerraform(struct?: PackSourceInputWinEventLogsConnections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    output: {
      value: cdktf.stringToHclTerraform(struct!.output),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputWinEventLogsConnectionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackSourceInputWinEventLogsConnections | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._output !== undefined) {
      hasAnyValues = true;
      internalValueResult.output = this._output;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputWinEventLogsConnections | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._output = undefined;
      this._pipeline = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._output = value.output;
      this._pipeline = value.pipeline;
    }
  }

  // output - computed: false, optional: false, required: true
  private _output?: string; 
  public get output() {
    return this.getStringAttribute('output');
  }
  public set output(value: string) {
    this._output = value;
  }
  // Temporarily expose input value. Use with caution.
  public get outputInput() {
    return this._output;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }
}

export class PackSourceInputWinEventLogsConnectionsList extends cdktf.ComplexList {
  public internalValue? : PackSourceInputWinEventLogsConnections[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackSourceInputWinEventLogsConnectionsOutputReference {
    return new PackSourceInputWinEventLogsConnectionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackSourceInputWinEventLogsMetadata {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#name PackSource#name}
  */
  readonly name: string;
  /**
  * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#value PackSource#value}
  */
  readonly value: string;
}

export function packSourceInputWinEventLogsMetadataToTerraform(struct?: PackSourceInputWinEventLogsMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function packSourceInputWinEventLogsMetadataToHclTerraform(struct?: PackSourceInputWinEventLogsMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputWinEventLogsMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackSourceInputWinEventLogsMetadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputWinEventLogsMetadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class PackSourceInputWinEventLogsMetadataList extends cdktf.ComplexList {
  public internalValue? : PackSourceInputWinEventLogsMetadata[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackSourceInputWinEventLogsMetadataOutputReference {
    return new PackSourceInputWinEventLogsMetadataOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackSourceInputWinEventLogsPq {
  /**
  * The number of events to send downstream before committing that Stream has read them. Default: 42
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#commit_frequency PackSource#commit_frequency}
  */
  readonly commitFrequency?: number;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#compress PackSource#compress}
  */
  readonly compress?: string;
  /**
  * The maximum number of events to hold in memory before writing the events to disk. Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_buffer_size PackSource#max_buffer_size}
  */
  readonly maxBufferSize?: number;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc. Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_file_size PackSource#max_file_size}
  */
  readonly maxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_size PackSource#max_size}
  */
  readonly maxSize?: string;
  /**
  * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine. Default: "always"; must be one of ["smart", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#mode PackSource#mode}
  */
  readonly mode?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#path PackSource#path}
  */
  readonly path?: string;
}

export function packSourceInputWinEventLogsPqToTerraform(struct?: PackSourceInputWinEventLogsPq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    commit_frequency: cdktf.numberToTerraform(struct!.commitFrequency),
    compress: cdktf.stringToTerraform(struct!.compress),
    max_buffer_size: cdktf.numberToTerraform(struct!.maxBufferSize),
    max_file_size: cdktf.stringToTerraform(struct!.maxFileSize),
    max_size: cdktf.stringToTerraform(struct!.maxSize),
    mode: cdktf.stringToTerraform(struct!.mode),
    path: cdktf.stringToTerraform(struct!.path),
  }
}


export function packSourceInputWinEventLogsPqToHclTerraform(struct?: PackSourceInputWinEventLogsPq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    commit_frequency: {
      value: cdktf.numberToHclTerraform(struct!.commitFrequency),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    compress: {
      value: cdktf.stringToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_buffer_size: {
      value: cdktf.numberToHclTerraform(struct!.maxBufferSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.maxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_size: {
      value: cdktf.stringToHclTerraform(struct!.maxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputWinEventLogsPqOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputWinEventLogsPq | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._commitFrequency !== undefined) {
      hasAnyValues = true;
      internalValueResult.commitFrequency = this._commitFrequency;
    }
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._maxBufferSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBufferSize = this._maxBufferSize;
    }
    if (this._maxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxFileSize = this._maxFileSize;
    }
    if (this._maxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxSize = this._maxSize;
    }
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputWinEventLogsPq | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._commitFrequency = undefined;
      this._compress = undefined;
      this._maxBufferSize = undefined;
      this._maxFileSize = undefined;
      this._maxSize = undefined;
      this._mode = undefined;
      this._path = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._commitFrequency = value.commitFrequency;
      this._compress = value.compress;
      this._maxBufferSize = value.maxBufferSize;
      this._maxFileSize = value.maxFileSize;
      this._maxSize = value.maxSize;
      this._mode = value.mode;
      this._path = value.path;
    }
  }

  // commit_frequency - computed: true, optional: true, required: false
  private _commitFrequency?: number; 
  public get commitFrequency() {
    return this.getNumberAttribute('commit_frequency');
  }
  public set commitFrequency(value: number) {
    this._commitFrequency = value;
  }
  public resetCommitFrequency() {
    this._commitFrequency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commitFrequencyInput() {
    return this._commitFrequency;
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: string; 
  public get compress() {
    return this.getStringAttribute('compress');
  }
  public set compress(value: string) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // max_buffer_size - computed: true, optional: true, required: false
  private _maxBufferSize?: number; 
  public get maxBufferSize() {
    return this.getNumberAttribute('max_buffer_size');
  }
  public set maxBufferSize(value: number) {
    this._maxBufferSize = value;
  }
  public resetMaxBufferSize() {
    this._maxBufferSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBufferSizeInput() {
    return this._maxBufferSize;
  }

  // max_file_size - computed: true, optional: true, required: false
  private _maxFileSize?: string; 
  public get maxFileSize() {
    return this.getStringAttribute('max_file_size');
  }
  public set maxFileSize(value: string) {
    this._maxFileSize = value;
  }
  public resetMaxFileSize() {
    this._maxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxFileSizeInput() {
    return this._maxFileSize;
  }

  // max_size - computed: true, optional: true, required: false
  private _maxSize?: string; 
  public get maxSize() {
    return this.getStringAttribute('max_size');
  }
  public set maxSize(value: string) {
    this._maxSize = value;
  }
  public resetMaxSize() {
    this._maxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxSizeInput() {
    return this._maxSize;
  }

  // mode - computed: true, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // path - computed: true, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }
}
export interface PackSourceInputWinEventLogs {
  /**
  * The maximum number of events to read in one polling interval. A batch size higher than 500 can cause delays when pulling from multiple event logs. (Applicable for pre-4.8.0 nodes that use Windows Tools). Default: 500
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#batch_size PackSource#batch_size}
  */
  readonly batchSize?: number;
  /**
  * Direct connections to Destinations, and optionally via a Pipeline or a Pack
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#connections PackSource#connections}
  */
  readonly connections?: PackSourceInputWinEventLogsConnections[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#description PackSource#description}
  */
  readonly description?: string;
  /**
  * Enable to use built-in tools (PowerShell for JSON, wevtutil for XML) to collect event logs instead of native API (default) [Learn more](https://docs.cribl.io/edge/sources-windows-event-logs/#advanced-settings). Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#disable_native_module PackSource#disable_native_module}
  */
  readonly disableNativeModule?: boolean | cdktf.IResolvable;
  /**
  * Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#disabled PackSource#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#environment PackSource#environment}
  */
  readonly environment?: string;
  /**
  * Format of individual events. Default: "json"; must be one of ["json", "xml"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#event_format PackSource#event_format}
  */
  readonly eventFormat?: string;
  /**
  * Unique ID for this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#id PackSource#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * Time, in seconds, between checking for new entries (Applicable for pre-4.8.0 nodes that use Windows Tools). Default: 10
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#interval PackSource#interval}
  */
  readonly interval?: number;
  /**
  * Enter the event logs to collect. Run "Get-WinEvent -ListLog *" in PowerShell to see the available logs. Default: ["Application","Security","System"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#log_names PackSource#log_names}
  */
  readonly logNames?: string[];
  /**
  * The maximum number of bytes in an event before it is flushed to the pipelines. Default: 51200
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_event_bytes PackSource#max_event_bytes}
  */
  readonly maxEventBytes?: number;
  /**
  * Fields to add to events from this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#metadata PackSource#metadata}
  */
  readonly metadata?: PackSourceInputWinEventLogsMetadata[] | cdktf.IResolvable;
  /**
  * Pipeline to process data from this Source before sending it through the Routes
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pipeline PackSource#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pq PackSource#pq}
  */
  readonly pq?: PackSourceInputWinEventLogsPq;
  /**
  * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers). Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pq_enabled PackSource#pq_enabled}
  */
  readonly pqEnabled?: boolean | cdktf.IResolvable;
  /**
  * Read all stored and future event logs, or only future events. Default: "oldest"; must be one of ["oldest", "newest"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#read_mode PackSource#read_mode}
  */
  readonly readMode?: string;
  /**
  * Select whether to send data to Routes, or directly to Destinations. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#send_to_routes PackSource#send_to_routes}
  */
  readonly sendToRoutes?: boolean | cdktf.IResolvable;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#streamtags PackSource#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * must be "win_event_logs"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#type PackSource#type}
  */
  readonly type: string;
}

export function packSourceInputWinEventLogsToTerraform(struct?: PackSourceInputWinEventLogs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    batch_size: cdktf.numberToTerraform(struct!.batchSize),
    connections: cdktf.listMapper(packSourceInputWinEventLogsConnectionsToTerraform, false)(struct!.connections),
    description: cdktf.stringToTerraform(struct!.description),
    disable_native_module: cdktf.booleanToTerraform(struct!.disableNativeModule),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    environment: cdktf.stringToTerraform(struct!.environment),
    event_format: cdktf.stringToTerraform(struct!.eventFormat),
    id: cdktf.stringToTerraform(struct!.id),
    interval: cdktf.numberToTerraform(struct!.interval),
    log_names: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.logNames),
    max_event_bytes: cdktf.numberToTerraform(struct!.maxEventBytes),
    metadata: cdktf.listMapper(packSourceInputWinEventLogsMetadataToTerraform, false)(struct!.metadata),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    pq: packSourceInputWinEventLogsPqToTerraform(struct!.pq),
    pq_enabled: cdktf.booleanToTerraform(struct!.pqEnabled),
    read_mode: cdktf.stringToTerraform(struct!.readMode),
    send_to_routes: cdktf.booleanToTerraform(struct!.sendToRoutes),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function packSourceInputWinEventLogsToHclTerraform(struct?: PackSourceInputWinEventLogs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    batch_size: {
      value: cdktf.numberToHclTerraform(struct!.batchSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    connections: {
      value: cdktf.listMapperHcl(packSourceInputWinEventLogsConnectionsToHclTerraform, false)(struct!.connections),
      isBlock: true,
      type: "list",
      storageClassType: "PackSourceInputWinEventLogsConnectionsList",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disable_native_module: {
      value: cdktf.booleanToHclTerraform(struct!.disableNativeModule),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    event_format: {
      value: cdktf.stringToHclTerraform(struct!.eventFormat),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    interval: {
      value: cdktf.numberToHclTerraform(struct!.interval),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    log_names: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.logNames),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    max_event_bytes: {
      value: cdktf.numberToHclTerraform(struct!.maxEventBytes),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    metadata: {
      value: cdktf.listMapperHcl(packSourceInputWinEventLogsMetadataToHclTerraform, false)(struct!.metadata),
      isBlock: true,
      type: "list",
      storageClassType: "PackSourceInputWinEventLogsMetadataList",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq: {
      value: packSourceInputWinEventLogsPqToHclTerraform(struct!.pq),
      isBlock: true,
      type: "struct",
      storageClassType: "PackSourceInputWinEventLogsPq",
    },
    pq_enabled: {
      value: cdktf.booleanToHclTerraform(struct!.pqEnabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    read_mode: {
      value: cdktf.stringToHclTerraform(struct!.readMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    send_to_routes: {
      value: cdktf.booleanToHclTerraform(struct!.sendToRoutes),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputWinEventLogsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputWinEventLogs | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._batchSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.batchSize = this._batchSize;
    }
    if (this._connections?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.connections = this._connections?.internalValue;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._disableNativeModule !== undefined) {
      hasAnyValues = true;
      internalValueResult.disableNativeModule = this._disableNativeModule;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._eventFormat !== undefined) {
      hasAnyValues = true;
      internalValueResult.eventFormat = this._eventFormat;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._interval !== undefined) {
      hasAnyValues = true;
      internalValueResult.interval = this._interval;
    }
    if (this._logNames !== undefined) {
      hasAnyValues = true;
      internalValueResult.logNames = this._logNames;
    }
    if (this._maxEventBytes !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxEventBytes = this._maxEventBytes;
    }
    if (this._metadata?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadata = this._metadata?.internalValue;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._pq?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pq = this._pq?.internalValue;
    }
    if (this._pqEnabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqEnabled = this._pqEnabled;
    }
    if (this._readMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.readMode = this._readMode;
    }
    if (this._sendToRoutes !== undefined) {
      hasAnyValues = true;
      internalValueResult.sendToRoutes = this._sendToRoutes;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputWinEventLogs | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._batchSize = undefined;
      this._connections.internalValue = undefined;
      this._description = undefined;
      this._disableNativeModule = undefined;
      this._disabled = undefined;
      this._environment = undefined;
      this._eventFormat = undefined;
      this._id = undefined;
      this._interval = undefined;
      this._logNames = undefined;
      this._maxEventBytes = undefined;
      this._metadata.internalValue = undefined;
      this._pipeline = undefined;
      this._pq.internalValue = undefined;
      this._pqEnabled = undefined;
      this._readMode = undefined;
      this._sendToRoutes = undefined;
      this._streamtags = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._batchSize = value.batchSize;
      this._connections.internalValue = value.connections;
      this._description = value.description;
      this._disableNativeModule = value.disableNativeModule;
      this._disabled = value.disabled;
      this._environment = value.environment;
      this._eventFormat = value.eventFormat;
      this._id = value.id;
      this._interval = value.interval;
      this._logNames = value.logNames;
      this._maxEventBytes = value.maxEventBytes;
      this._metadata.internalValue = value.metadata;
      this._pipeline = value.pipeline;
      this._pq.internalValue = value.pq;
      this._pqEnabled = value.pqEnabled;
      this._readMode = value.readMode;
      this._sendToRoutes = value.sendToRoutes;
      this._streamtags = value.streamtags;
      this._type = value.type;
    }
  }

  // batch_size - computed: true, optional: true, required: false
  private _batchSize?: number; 
  public get batchSize() {
    return this.getNumberAttribute('batch_size');
  }
  public set batchSize(value: number) {
    this._batchSize = value;
  }
  public resetBatchSize() {
    this._batchSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get batchSizeInput() {
    return this._batchSize;
  }

  // connections - computed: false, optional: true, required: false
  private _connections = new PackSourceInputWinEventLogsConnectionsList(this, "connections", false);
  public get connections() {
    return this._connections;
  }
  public putConnections(value: PackSourceInputWinEventLogsConnections[] | cdktf.IResolvable) {
    this._connections.internalValue = value;
  }
  public resetConnections() {
    this._connections.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectionsInput() {
    return this._connections.internalValue;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // disable_native_module - computed: true, optional: true, required: false
  private _disableNativeModule?: boolean | cdktf.IResolvable; 
  public get disableNativeModule() {
    return this.getBooleanAttribute('disable_native_module');
  }
  public set disableNativeModule(value: boolean | cdktf.IResolvable) {
    this._disableNativeModule = value;
  }
  public resetDisableNativeModule() {
    this._disableNativeModule = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disableNativeModuleInput() {
    return this._disableNativeModule;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // event_format - computed: true, optional: true, required: false
  private _eventFormat?: string; 
  public get eventFormat() {
    return this.getStringAttribute('event_format');
  }
  public set eventFormat(value: string) {
    this._eventFormat = value;
  }
  public resetEventFormat() {
    this._eventFormat = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get eventFormatInput() {
    return this._eventFormat;
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // interval - computed: true, optional: true, required: false
  private _interval?: number; 
  public get interval() {
    return this.getNumberAttribute('interval');
  }
  public set interval(value: number) {
    this._interval = value;
  }
  public resetInterval() {
    this._interval = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get intervalInput() {
    return this._interval;
  }

  // log_names - computed: true, optional: true, required: false
  private _logNames?: string[]; 
  public get logNames() {
    return this.getListAttribute('log_names');
  }
  public set logNames(value: string[]) {
    this._logNames = value;
  }
  public resetLogNames() {
    this._logNames = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get logNamesInput() {
    return this._logNames;
  }

  // max_event_bytes - computed: true, optional: true, required: false
  private _maxEventBytes?: number; 
  public get maxEventBytes() {
    return this.getNumberAttribute('max_event_bytes');
  }
  public set maxEventBytes(value: number) {
    this._maxEventBytes = value;
  }
  public resetMaxEventBytes() {
    this._maxEventBytes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxEventBytesInput() {
    return this._maxEventBytes;
  }

  // metadata - computed: false, optional: true, required: false
  private _metadata = new PackSourceInputWinEventLogsMetadataList(this, "metadata", false);
  public get metadata() {
    return this._metadata;
  }
  public putMetadata(value: PackSourceInputWinEventLogsMetadata[] | cdktf.IResolvable) {
    this._metadata.internalValue = value;
  }
  public resetMetadata() {
    this._metadata.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataInput() {
    return this._metadata.internalValue;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // pq - computed: false, optional: true, required: false
  private _pq = new PackSourceInputWinEventLogsPqOutputReference(this, "pq");
  public get pq() {
    return this._pq;
  }
  public putPq(value: PackSourceInputWinEventLogsPq) {
    this._pq.internalValue = value;
  }
  public resetPq() {
    this._pq.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqInput() {
    return this._pq.internalValue;
  }

  // pq_enabled - computed: true, optional: true, required: false
  private _pqEnabled?: boolean | cdktf.IResolvable; 
  public get pqEnabled() {
    return this.getBooleanAttribute('pq_enabled');
  }
  public set pqEnabled(value: boolean | cdktf.IResolvable) {
    this._pqEnabled = value;
  }
  public resetPqEnabled() {
    this._pqEnabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqEnabledInput() {
    return this._pqEnabled;
  }

  // read_mode - computed: true, optional: true, required: false
  private _readMode?: string; 
  public get readMode() {
    return this.getStringAttribute('read_mode');
  }
  public set readMode(value: string) {
    this._readMode = value;
  }
  public resetReadMode() {
    this._readMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get readModeInput() {
    return this._readMode;
  }

  // send_to_routes - computed: true, optional: true, required: false
  private _sendToRoutes?: boolean | cdktf.IResolvable; 
  public get sendToRoutes() {
    return this.getBooleanAttribute('send_to_routes');
  }
  public set sendToRoutes(value: boolean | cdktf.IResolvable) {
    this._sendToRoutes = value;
  }
  public resetSendToRoutes() {
    this._sendToRoutes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sendToRoutesInput() {
    return this._sendToRoutes;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface PackSourceInputWindowsMetricsConnections {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#output PackSource#output}
  */
  readonly output: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pipeline PackSource#pipeline}
  */
  readonly pipeline?: string;
}

export function packSourceInputWindowsMetricsConnectionsToTerraform(struct?: PackSourceInputWindowsMetricsConnections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    output: cdktf.stringToTerraform(struct!.output),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
  }
}


export function packSourceInputWindowsMetricsConnectionsToHclTerraform(struct?: PackSourceInputWindowsMetricsConnections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    output: {
      value: cdktf.stringToHclTerraform(struct!.output),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputWindowsMetricsConnectionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackSourceInputWindowsMetricsConnections | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._output !== undefined) {
      hasAnyValues = true;
      internalValueResult.output = this._output;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputWindowsMetricsConnections | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._output = undefined;
      this._pipeline = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._output = value.output;
      this._pipeline = value.pipeline;
    }
  }

  // output - computed: false, optional: false, required: true
  private _output?: string; 
  public get output() {
    return this.getStringAttribute('output');
  }
  public set output(value: string) {
    this._output = value;
  }
  // Temporarily expose input value. Use with caution.
  public get outputInput() {
    return this._output;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }
}

export class PackSourceInputWindowsMetricsConnectionsList extends cdktf.ComplexList {
  public internalValue? : PackSourceInputWindowsMetricsConnections[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackSourceInputWindowsMetricsConnectionsOutputReference {
    return new PackSourceInputWindowsMetricsConnectionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackSourceInputWindowsMetricsHostCustomCpu {
  /**
  * Generate metrics for all CPU states. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#detail PackSource#detail}
  */
  readonly detail?: boolean | cdktf.IResolvable;
  /**
  * Select the level of details for CPU metrics. Default: "basic"; must be one of ["basic", "all", "custom", "disabled"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#mode PackSource#mode}
  */
  readonly mode?: string;
  /**
  * Generate metrics for each CPU. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#per_cpu PackSource#per_cpu}
  */
  readonly perCpu?: boolean | cdktf.IResolvable;
  /**
  * Generate raw, monotonic CPU time counters. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#time PackSource#time}
  */
  readonly time?: boolean | cdktf.IResolvable;
}

export function packSourceInputWindowsMetricsHostCustomCpuToTerraform(struct?: PackSourceInputWindowsMetricsHostCustomCpu | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    detail: cdktf.booleanToTerraform(struct!.detail),
    mode: cdktf.stringToTerraform(struct!.mode),
    per_cpu: cdktf.booleanToTerraform(struct!.perCpu),
    time: cdktf.booleanToTerraform(struct!.time),
  }
}


export function packSourceInputWindowsMetricsHostCustomCpuToHclTerraform(struct?: PackSourceInputWindowsMetricsHostCustomCpu | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    detail: {
      value: cdktf.booleanToHclTerraform(struct!.detail),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    per_cpu: {
      value: cdktf.booleanToHclTerraform(struct!.perCpu),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    time: {
      value: cdktf.booleanToHclTerraform(struct!.time),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputWindowsMetricsHostCustomCpuOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputWindowsMetricsHostCustomCpu | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._detail !== undefined) {
      hasAnyValues = true;
      internalValueResult.detail = this._detail;
    }
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._perCpu !== undefined) {
      hasAnyValues = true;
      internalValueResult.perCpu = this._perCpu;
    }
    if (this._time !== undefined) {
      hasAnyValues = true;
      internalValueResult.time = this._time;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputWindowsMetricsHostCustomCpu | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._detail = undefined;
      this._mode = undefined;
      this._perCpu = undefined;
      this._time = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._detail = value.detail;
      this._mode = value.mode;
      this._perCpu = value.perCpu;
      this._time = value.time;
    }
  }

  // detail - computed: true, optional: true, required: false
  private _detail?: boolean | cdktf.IResolvable; 
  public get detail() {
    return this.getBooleanAttribute('detail');
  }
  public set detail(value: boolean | cdktf.IResolvable) {
    this._detail = value;
  }
  public resetDetail() {
    this._detail = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get detailInput() {
    return this._detail;
  }

  // mode - computed: true, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // per_cpu - computed: true, optional: true, required: false
  private _perCpu?: boolean | cdktf.IResolvable; 
  public get perCpu() {
    return this.getBooleanAttribute('per_cpu');
  }
  public set perCpu(value: boolean | cdktf.IResolvable) {
    this._perCpu = value;
  }
  public resetPerCpu() {
    this._perCpu = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get perCpuInput() {
    return this._perCpu;
  }

  // time - computed: true, optional: true, required: false
  private _time?: boolean | cdktf.IResolvable; 
  public get time() {
    return this.getBooleanAttribute('time');
  }
  public set time(value: boolean | cdktf.IResolvable) {
    this._time = value;
  }
  public resetTime() {
    this._time = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeInput() {
    return this._time;
  }
}
export interface PackSourceInputWindowsMetricsHostCustomDisk {
  /**
  * Select the level of details for disk metrics. Default: "basic"; must be one of ["basic", "all", "custom", "disabled"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#mode PackSource#mode}
  */
  readonly mode?: string;
  /**
  * Generate separate metrics for each volume. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#per_volume PackSource#per_volume}
  */
  readonly perVolume?: boolean | cdktf.IResolvable;
  /**
  * Windows volumes to include/exclude. E.g.: C:, !E:, etc. Wildcards and ! (not) operators are supported. All volumes are included if this list is empty. Default: ["!HarddiskVolume*","*"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#volumes PackSource#volumes}
  */
  readonly volumes?: string[];
}

export function packSourceInputWindowsMetricsHostCustomDiskToTerraform(struct?: PackSourceInputWindowsMetricsHostCustomDisk | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    mode: cdktf.stringToTerraform(struct!.mode),
    per_volume: cdktf.booleanToTerraform(struct!.perVolume),
    volumes: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.volumes),
  }
}


export function packSourceInputWindowsMetricsHostCustomDiskToHclTerraform(struct?: PackSourceInputWindowsMetricsHostCustomDisk | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    per_volume: {
      value: cdktf.booleanToHclTerraform(struct!.perVolume),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    volumes: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.volumes),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputWindowsMetricsHostCustomDiskOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputWindowsMetricsHostCustomDisk | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._perVolume !== undefined) {
      hasAnyValues = true;
      internalValueResult.perVolume = this._perVolume;
    }
    if (this._volumes !== undefined) {
      hasAnyValues = true;
      internalValueResult.volumes = this._volumes;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputWindowsMetricsHostCustomDisk | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._mode = undefined;
      this._perVolume = undefined;
      this._volumes = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._mode = value.mode;
      this._perVolume = value.perVolume;
      this._volumes = value.volumes;
    }
  }

  // mode - computed: true, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // per_volume - computed: true, optional: true, required: false
  private _perVolume?: boolean | cdktf.IResolvable; 
  public get perVolume() {
    return this.getBooleanAttribute('per_volume');
  }
  public set perVolume(value: boolean | cdktf.IResolvable) {
    this._perVolume = value;
  }
  public resetPerVolume() {
    this._perVolume = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get perVolumeInput() {
    return this._perVolume;
  }

  // volumes - computed: true, optional: true, required: false
  private _volumes?: string[]; 
  public get volumes() {
    return this.getListAttribute('volumes');
  }
  public set volumes(value: string[]) {
    this._volumes = value;
  }
  public resetVolumes() {
    this._volumes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get volumesInput() {
    return this._volumes;
  }
}
export interface PackSourceInputWindowsMetricsHostCustomMemory {
  /**
  * Generate metrics for all memory states. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#detail PackSource#detail}
  */
  readonly detail?: boolean | cdktf.IResolvable;
  /**
  * Select the level of details for memory metrics. Default: "basic"; must be one of ["basic", "all", "custom", "disabled"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#mode PackSource#mode}
  */
  readonly mode?: string;
}

export function packSourceInputWindowsMetricsHostCustomMemoryToTerraform(struct?: PackSourceInputWindowsMetricsHostCustomMemory | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    detail: cdktf.booleanToTerraform(struct!.detail),
    mode: cdktf.stringToTerraform(struct!.mode),
  }
}


export function packSourceInputWindowsMetricsHostCustomMemoryToHclTerraform(struct?: PackSourceInputWindowsMetricsHostCustomMemory | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    detail: {
      value: cdktf.booleanToHclTerraform(struct!.detail),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputWindowsMetricsHostCustomMemoryOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputWindowsMetricsHostCustomMemory | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._detail !== undefined) {
      hasAnyValues = true;
      internalValueResult.detail = this._detail;
    }
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputWindowsMetricsHostCustomMemory | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._detail = undefined;
      this._mode = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._detail = value.detail;
      this._mode = value.mode;
    }
  }

  // detail - computed: true, optional: true, required: false
  private _detail?: boolean | cdktf.IResolvable; 
  public get detail() {
    return this.getBooleanAttribute('detail');
  }
  public set detail(value: boolean | cdktf.IResolvable) {
    this._detail = value;
  }
  public resetDetail() {
    this._detail = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get detailInput() {
    return this._detail;
  }

  // mode - computed: true, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }
}
export interface PackSourceInputWindowsMetricsHostCustomNetwork {
  /**
  * Generate full network metrics. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#detail PackSource#detail}
  */
  readonly detail?: boolean | cdktf.IResolvable;
  /**
  * Network interfaces to include/exclude. All interfaces are included if this list is empty. Default: ["!6to4*","!*Debug*","!*Virtual*","!*Tunneling*","!*IP-HTTPS*","*"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#devices PackSource#devices}
  */
  readonly devices?: string[];
  /**
  * Select the level of details for network metrics. Default: "basic"; must be one of ["basic", "all", "custom", "disabled"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#mode PackSource#mode}
  */
  readonly mode?: string;
  /**
  * Generate separate metrics for each interface. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#per_interface PackSource#per_interface}
  */
  readonly perInterface?: boolean | cdktf.IResolvable;
}

export function packSourceInputWindowsMetricsHostCustomNetworkToTerraform(struct?: PackSourceInputWindowsMetricsHostCustomNetwork | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    detail: cdktf.booleanToTerraform(struct!.detail),
    devices: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.devices),
    mode: cdktf.stringToTerraform(struct!.mode),
    per_interface: cdktf.booleanToTerraform(struct!.perInterface),
  }
}


export function packSourceInputWindowsMetricsHostCustomNetworkToHclTerraform(struct?: PackSourceInputWindowsMetricsHostCustomNetwork | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    detail: {
      value: cdktf.booleanToHclTerraform(struct!.detail),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    devices: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.devices),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    per_interface: {
      value: cdktf.booleanToHclTerraform(struct!.perInterface),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputWindowsMetricsHostCustomNetworkOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputWindowsMetricsHostCustomNetwork | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._detail !== undefined) {
      hasAnyValues = true;
      internalValueResult.detail = this._detail;
    }
    if (this._devices !== undefined) {
      hasAnyValues = true;
      internalValueResult.devices = this._devices;
    }
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._perInterface !== undefined) {
      hasAnyValues = true;
      internalValueResult.perInterface = this._perInterface;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputWindowsMetricsHostCustomNetwork | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._detail = undefined;
      this._devices = undefined;
      this._mode = undefined;
      this._perInterface = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._detail = value.detail;
      this._devices = value.devices;
      this._mode = value.mode;
      this._perInterface = value.perInterface;
    }
  }

  // detail - computed: true, optional: true, required: false
  private _detail?: boolean | cdktf.IResolvable; 
  public get detail() {
    return this.getBooleanAttribute('detail');
  }
  public set detail(value: boolean | cdktf.IResolvable) {
    this._detail = value;
  }
  public resetDetail() {
    this._detail = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get detailInput() {
    return this._detail;
  }

  // devices - computed: true, optional: true, required: false
  private _devices?: string[]; 
  public get devices() {
    return this.getListAttribute('devices');
  }
  public set devices(value: string[]) {
    this._devices = value;
  }
  public resetDevices() {
    this._devices = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get devicesInput() {
    return this._devices;
  }

  // mode - computed: true, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // per_interface - computed: true, optional: true, required: false
  private _perInterface?: boolean | cdktf.IResolvable; 
  public get perInterface() {
    return this.getBooleanAttribute('per_interface');
  }
  public set perInterface(value: boolean | cdktf.IResolvable) {
    this._perInterface = value;
  }
  public resetPerInterface() {
    this._perInterface = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get perInterfaceInput() {
    return this._perInterface;
  }
}
export interface PackSourceInputWindowsMetricsHostCustomSystem {
  /**
  * Generate metrics for all system information. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#detail PackSource#detail}
  */
  readonly detail?: boolean | cdktf.IResolvable;
  /**
  * Select the level of details for system metrics. Default: "basic"; must be one of ["basic", "all", "custom", "disabled"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#mode PackSource#mode}
  */
  readonly mode?: string;
}

export function packSourceInputWindowsMetricsHostCustomSystemToTerraform(struct?: PackSourceInputWindowsMetricsHostCustomSystem | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    detail: cdktf.booleanToTerraform(struct!.detail),
    mode: cdktf.stringToTerraform(struct!.mode),
  }
}


export function packSourceInputWindowsMetricsHostCustomSystemToHclTerraform(struct?: PackSourceInputWindowsMetricsHostCustomSystem | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    detail: {
      value: cdktf.booleanToHclTerraform(struct!.detail),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputWindowsMetricsHostCustomSystemOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputWindowsMetricsHostCustomSystem | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._detail !== undefined) {
      hasAnyValues = true;
      internalValueResult.detail = this._detail;
    }
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputWindowsMetricsHostCustomSystem | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._detail = undefined;
      this._mode = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._detail = value.detail;
      this._mode = value.mode;
    }
  }

  // detail - computed: true, optional: true, required: false
  private _detail?: boolean | cdktf.IResolvable; 
  public get detail() {
    return this.getBooleanAttribute('detail');
  }
  public set detail(value: boolean | cdktf.IResolvable) {
    this._detail = value;
  }
  public resetDetail() {
    this._detail = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get detailInput() {
    return this._detail;
  }

  // mode - computed: true, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }
}
export interface PackSourceInputWindowsMetricsHostCustom {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#cpu PackSource#cpu}
  */
  readonly cpu?: PackSourceInputWindowsMetricsHostCustomCpu;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#disk PackSource#disk}
  */
  readonly disk?: PackSourceInputWindowsMetricsHostCustomDisk;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#memory PackSource#memory}
  */
  readonly memory?: PackSourceInputWindowsMetricsHostCustomMemory;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#network PackSource#network}
  */
  readonly network?: PackSourceInputWindowsMetricsHostCustomNetwork;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#system PackSource#system}
  */
  readonly systemAttribute?: PackSourceInputWindowsMetricsHostCustomSystem;
}

export function packSourceInputWindowsMetricsHostCustomToTerraform(struct?: PackSourceInputWindowsMetricsHostCustom | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    cpu: packSourceInputWindowsMetricsHostCustomCpuToTerraform(struct!.cpu),
    disk: packSourceInputWindowsMetricsHostCustomDiskToTerraform(struct!.disk),
    memory: packSourceInputWindowsMetricsHostCustomMemoryToTerraform(struct!.memory),
    network: packSourceInputWindowsMetricsHostCustomNetworkToTerraform(struct!.network),
    system: packSourceInputWindowsMetricsHostCustomSystemToTerraform(struct!.systemAttribute),
  }
}


export function packSourceInputWindowsMetricsHostCustomToHclTerraform(struct?: PackSourceInputWindowsMetricsHostCustom | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    cpu: {
      value: packSourceInputWindowsMetricsHostCustomCpuToHclTerraform(struct!.cpu),
      isBlock: true,
      type: "struct",
      storageClassType: "PackSourceInputWindowsMetricsHostCustomCpu",
    },
    disk: {
      value: packSourceInputWindowsMetricsHostCustomDiskToHclTerraform(struct!.disk),
      isBlock: true,
      type: "struct",
      storageClassType: "PackSourceInputWindowsMetricsHostCustomDisk",
    },
    memory: {
      value: packSourceInputWindowsMetricsHostCustomMemoryToHclTerraform(struct!.memory),
      isBlock: true,
      type: "struct",
      storageClassType: "PackSourceInputWindowsMetricsHostCustomMemory",
    },
    network: {
      value: packSourceInputWindowsMetricsHostCustomNetworkToHclTerraform(struct!.network),
      isBlock: true,
      type: "struct",
      storageClassType: "PackSourceInputWindowsMetricsHostCustomNetwork",
    },
    system: {
      value: packSourceInputWindowsMetricsHostCustomSystemToHclTerraform(struct!.systemAttribute),
      isBlock: true,
      type: "struct",
      storageClassType: "PackSourceInputWindowsMetricsHostCustomSystem",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputWindowsMetricsHostCustomOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputWindowsMetricsHostCustom | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._cpu?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.cpu = this._cpu?.internalValue;
    }
    if (this._disk?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.disk = this._disk?.internalValue;
    }
    if (this._memory?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.memory = this._memory?.internalValue;
    }
    if (this._network?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.network = this._network?.internalValue;
    }
    if (this._system?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.systemAttribute = this._system?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputWindowsMetricsHostCustom | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._cpu.internalValue = undefined;
      this._disk.internalValue = undefined;
      this._memory.internalValue = undefined;
      this._network.internalValue = undefined;
      this._system.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._cpu.internalValue = value.cpu;
      this._disk.internalValue = value.disk;
      this._memory.internalValue = value.memory;
      this._network.internalValue = value.network;
      this._system.internalValue = value.systemAttribute;
    }
  }

  // cpu - computed: false, optional: true, required: false
  private _cpu = new PackSourceInputWindowsMetricsHostCustomCpuOutputReference(this, "cpu");
  public get cpu() {
    return this._cpu;
  }
  public putCpu(value: PackSourceInputWindowsMetricsHostCustomCpu) {
    this._cpu.internalValue = value;
  }
  public resetCpu() {
    this._cpu.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cpuInput() {
    return this._cpu.internalValue;
  }

  // disk - computed: false, optional: true, required: false
  private _disk = new PackSourceInputWindowsMetricsHostCustomDiskOutputReference(this, "disk");
  public get disk() {
    return this._disk;
  }
  public putDisk(value: PackSourceInputWindowsMetricsHostCustomDisk) {
    this._disk.internalValue = value;
  }
  public resetDisk() {
    this._disk.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get diskInput() {
    return this._disk.internalValue;
  }

  // memory - computed: false, optional: true, required: false
  private _memory = new PackSourceInputWindowsMetricsHostCustomMemoryOutputReference(this, "memory");
  public get memory() {
    return this._memory;
  }
  public putMemory(value: PackSourceInputWindowsMetricsHostCustomMemory) {
    this._memory.internalValue = value;
  }
  public resetMemory() {
    this._memory.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get memoryInput() {
    return this._memory.internalValue;
  }

  // network - computed: false, optional: true, required: false
  private _network = new PackSourceInputWindowsMetricsHostCustomNetworkOutputReference(this, "network");
  public get network() {
    return this._network;
  }
  public putNetwork(value: PackSourceInputWindowsMetricsHostCustomNetwork) {
    this._network.internalValue = value;
  }
  public resetNetwork() {
    this._network.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get networkInput() {
    return this._network.internalValue;
  }

  // system - computed: false, optional: true, required: false
  private _system = new PackSourceInputWindowsMetricsHostCustomSystemOutputReference(this, "system");
  public get systemAttribute() {
    return this._system;
  }
  public putSystemAttribute(value: PackSourceInputWindowsMetricsHostCustomSystem) {
    this._system.internalValue = value;
  }
  public resetSystemAttribute() {
    this._system.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get systemAttributeInput() {
    return this._system.internalValue;
  }
}
export interface PackSourceInputWindowsMetricsHost {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#custom PackSource#custom}
  */
  readonly custom?: PackSourceInputWindowsMetricsHostCustom;
  /**
  * Select level of detail for host metrics. Default: "basic"; must be one of ["basic", "all", "custom", "disabled"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#mode PackSource#mode}
  */
  readonly mode?: string;
}

export function packSourceInputWindowsMetricsHostToTerraform(struct?: PackSourceInputWindowsMetricsHost | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    custom: packSourceInputWindowsMetricsHostCustomToTerraform(struct!.custom),
    mode: cdktf.stringToTerraform(struct!.mode),
  }
}


export function packSourceInputWindowsMetricsHostToHclTerraform(struct?: PackSourceInputWindowsMetricsHost | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    custom: {
      value: packSourceInputWindowsMetricsHostCustomToHclTerraform(struct!.custom),
      isBlock: true,
      type: "struct",
      storageClassType: "PackSourceInputWindowsMetricsHostCustom",
    },
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputWindowsMetricsHostOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputWindowsMetricsHost | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._custom?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.custom = this._custom?.internalValue;
    }
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputWindowsMetricsHost | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._custom.internalValue = undefined;
      this._mode = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._custom.internalValue = value.custom;
      this._mode = value.mode;
    }
  }

  // custom - computed: false, optional: true, required: false
  private _custom = new PackSourceInputWindowsMetricsHostCustomOutputReference(this, "custom");
  public get custom() {
    return this._custom;
  }
  public putCustom(value: PackSourceInputWindowsMetricsHostCustom) {
    this._custom.internalValue = value;
  }
  public resetCustom() {
    this._custom.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get customInput() {
    return this._custom.internalValue;
  }

  // mode - computed: true, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }
}
export interface PackSourceInputWindowsMetricsMetadata {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#name PackSource#name}
  */
  readonly name: string;
  /**
  * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#value PackSource#value}
  */
  readonly value: string;
}

export function packSourceInputWindowsMetricsMetadataToTerraform(struct?: PackSourceInputWindowsMetricsMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function packSourceInputWindowsMetricsMetadataToHclTerraform(struct?: PackSourceInputWindowsMetricsMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputWindowsMetricsMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackSourceInputWindowsMetricsMetadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputWindowsMetricsMetadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class PackSourceInputWindowsMetricsMetadataList extends cdktf.ComplexList {
  public internalValue? : PackSourceInputWindowsMetricsMetadata[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackSourceInputWindowsMetricsMetadataOutputReference {
    return new PackSourceInputWindowsMetricsMetadataOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackSourceInputWindowsMetricsPersistence {
  /**
  * Default: "gzip"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#compress PackSource#compress}
  */
  readonly compress?: string;
  /**
  * Path to use to write metrics. Defaults to $CRIBL_HOME/state/windows_metrics. Default: "$CRIBL_HOME/state/windows_metrics"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#dest_path PackSource#dest_path}
  */
  readonly destPath?: string;
  /**
  * Spool metrics to disk for Cribl Edge and Search. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#enable PackSource#enable}
  */
  readonly enable?: boolean | cdktf.IResolvable;
  /**
  * Maximum disk space allowed to be consumed (examples: 420MB, 4GB). When limit is reached, older data will be deleted. Default: "1GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_data_size PackSource#max_data_size}
  */
  readonly maxDataSize?: string;
  /**
  * Maximum amount of time to retain data (examples: 2h, 4d). When limit is reached, older data will be deleted. Default: "24h"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_data_time PackSource#max_data_time}
  */
  readonly maxDataTime?: string;
  /**
  * Time span for each file bucket. Default: "10m"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#time_window PackSource#time_window}
  */
  readonly timeWindow?: string;
}

export function packSourceInputWindowsMetricsPersistenceToTerraform(struct?: PackSourceInputWindowsMetricsPersistence | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    compress: cdktf.stringToTerraform(struct!.compress),
    dest_path: cdktf.stringToTerraform(struct!.destPath),
    enable: cdktf.booleanToTerraform(struct!.enable),
    max_data_size: cdktf.stringToTerraform(struct!.maxDataSize),
    max_data_time: cdktf.stringToTerraform(struct!.maxDataTime),
    time_window: cdktf.stringToTerraform(struct!.timeWindow),
  }
}


export function packSourceInputWindowsMetricsPersistenceToHclTerraform(struct?: PackSourceInputWindowsMetricsPersistence | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    compress: {
      value: cdktf.stringToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    dest_path: {
      value: cdktf.stringToHclTerraform(struct!.destPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    enable: {
      value: cdktf.booleanToHclTerraform(struct!.enable),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    max_data_size: {
      value: cdktf.stringToHclTerraform(struct!.maxDataSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_data_time: {
      value: cdktf.stringToHclTerraform(struct!.maxDataTime),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    time_window: {
      value: cdktf.stringToHclTerraform(struct!.timeWindow),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputWindowsMetricsPersistenceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputWindowsMetricsPersistence | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._destPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.destPath = this._destPath;
    }
    if (this._enable !== undefined) {
      hasAnyValues = true;
      internalValueResult.enable = this._enable;
    }
    if (this._maxDataSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxDataSize = this._maxDataSize;
    }
    if (this._maxDataTime !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxDataTime = this._maxDataTime;
    }
    if (this._timeWindow !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeWindow = this._timeWindow;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputWindowsMetricsPersistence | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._compress = undefined;
      this._destPath = undefined;
      this._enable = undefined;
      this._maxDataSize = undefined;
      this._maxDataTime = undefined;
      this._timeWindow = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._compress = value.compress;
      this._destPath = value.destPath;
      this._enable = value.enable;
      this._maxDataSize = value.maxDataSize;
      this._maxDataTime = value.maxDataTime;
      this._timeWindow = value.timeWindow;
    }
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: string; 
  public get compress() {
    return this.getStringAttribute('compress');
  }
  public set compress(value: string) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // dest_path - computed: true, optional: true, required: false
  private _destPath?: string; 
  public get destPath() {
    return this.getStringAttribute('dest_path');
  }
  public set destPath(value: string) {
    this._destPath = value;
  }
  public resetDestPath() {
    this._destPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get destPathInput() {
    return this._destPath;
  }

  // enable - computed: true, optional: true, required: false
  private _enable?: boolean | cdktf.IResolvable; 
  public get enable() {
    return this.getBooleanAttribute('enable');
  }
  public set enable(value: boolean | cdktf.IResolvable) {
    this._enable = value;
  }
  public resetEnable() {
    this._enable = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableInput() {
    return this._enable;
  }

  // max_data_size - computed: true, optional: true, required: false
  private _maxDataSize?: string; 
  public get maxDataSize() {
    return this.getStringAttribute('max_data_size');
  }
  public set maxDataSize(value: string) {
    this._maxDataSize = value;
  }
  public resetMaxDataSize() {
    this._maxDataSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxDataSizeInput() {
    return this._maxDataSize;
  }

  // max_data_time - computed: true, optional: true, required: false
  private _maxDataTime?: string; 
  public get maxDataTime() {
    return this.getStringAttribute('max_data_time');
  }
  public set maxDataTime(value: string) {
    this._maxDataTime = value;
  }
  public resetMaxDataTime() {
    this._maxDataTime = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxDataTimeInput() {
    return this._maxDataTime;
  }

  // time_window - computed: true, optional: true, required: false
  private _timeWindow?: string; 
  public get timeWindow() {
    return this.getStringAttribute('time_window');
  }
  public set timeWindow(value: string) {
    this._timeWindow = value;
  }
  public resetTimeWindow() {
    this._timeWindow = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeWindowInput() {
    return this._timeWindow;
  }
}
export interface PackSourceInputWindowsMetricsPq {
  /**
  * The number of events to send downstream before committing that Stream has read them. Default: 42
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#commit_frequency PackSource#commit_frequency}
  */
  readonly commitFrequency?: number;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#compress PackSource#compress}
  */
  readonly compress?: string;
  /**
  * The maximum number of events to hold in memory before writing the events to disk. Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_buffer_size PackSource#max_buffer_size}
  */
  readonly maxBufferSize?: number;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc. Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_file_size PackSource#max_file_size}
  */
  readonly maxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_size PackSource#max_size}
  */
  readonly maxSize?: string;
  /**
  * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine. Default: "always"; must be one of ["smart", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#mode PackSource#mode}
  */
  readonly mode?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#path PackSource#path}
  */
  readonly path?: string;
}

export function packSourceInputWindowsMetricsPqToTerraform(struct?: PackSourceInputWindowsMetricsPq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    commit_frequency: cdktf.numberToTerraform(struct!.commitFrequency),
    compress: cdktf.stringToTerraform(struct!.compress),
    max_buffer_size: cdktf.numberToTerraform(struct!.maxBufferSize),
    max_file_size: cdktf.stringToTerraform(struct!.maxFileSize),
    max_size: cdktf.stringToTerraform(struct!.maxSize),
    mode: cdktf.stringToTerraform(struct!.mode),
    path: cdktf.stringToTerraform(struct!.path),
  }
}


export function packSourceInputWindowsMetricsPqToHclTerraform(struct?: PackSourceInputWindowsMetricsPq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    commit_frequency: {
      value: cdktf.numberToHclTerraform(struct!.commitFrequency),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    compress: {
      value: cdktf.stringToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_buffer_size: {
      value: cdktf.numberToHclTerraform(struct!.maxBufferSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.maxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_size: {
      value: cdktf.stringToHclTerraform(struct!.maxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputWindowsMetricsPqOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputWindowsMetricsPq | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._commitFrequency !== undefined) {
      hasAnyValues = true;
      internalValueResult.commitFrequency = this._commitFrequency;
    }
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._maxBufferSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBufferSize = this._maxBufferSize;
    }
    if (this._maxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxFileSize = this._maxFileSize;
    }
    if (this._maxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxSize = this._maxSize;
    }
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputWindowsMetricsPq | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._commitFrequency = undefined;
      this._compress = undefined;
      this._maxBufferSize = undefined;
      this._maxFileSize = undefined;
      this._maxSize = undefined;
      this._mode = undefined;
      this._path = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._commitFrequency = value.commitFrequency;
      this._compress = value.compress;
      this._maxBufferSize = value.maxBufferSize;
      this._maxFileSize = value.maxFileSize;
      this._maxSize = value.maxSize;
      this._mode = value.mode;
      this._path = value.path;
    }
  }

  // commit_frequency - computed: true, optional: true, required: false
  private _commitFrequency?: number; 
  public get commitFrequency() {
    return this.getNumberAttribute('commit_frequency');
  }
  public set commitFrequency(value: number) {
    this._commitFrequency = value;
  }
  public resetCommitFrequency() {
    this._commitFrequency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commitFrequencyInput() {
    return this._commitFrequency;
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: string; 
  public get compress() {
    return this.getStringAttribute('compress');
  }
  public set compress(value: string) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // max_buffer_size - computed: true, optional: true, required: false
  private _maxBufferSize?: number; 
  public get maxBufferSize() {
    return this.getNumberAttribute('max_buffer_size');
  }
  public set maxBufferSize(value: number) {
    this._maxBufferSize = value;
  }
  public resetMaxBufferSize() {
    this._maxBufferSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBufferSizeInput() {
    return this._maxBufferSize;
  }

  // max_file_size - computed: true, optional: true, required: false
  private _maxFileSize?: string; 
  public get maxFileSize() {
    return this.getStringAttribute('max_file_size');
  }
  public set maxFileSize(value: string) {
    this._maxFileSize = value;
  }
  public resetMaxFileSize() {
    this._maxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxFileSizeInput() {
    return this._maxFileSize;
  }

  // max_size - computed: true, optional: true, required: false
  private _maxSize?: string; 
  public get maxSize() {
    return this.getStringAttribute('max_size');
  }
  public set maxSize(value: string) {
    this._maxSize = value;
  }
  public resetMaxSize() {
    this._maxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxSizeInput() {
    return this._maxSize;
  }

  // mode - computed: true, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // path - computed: true, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }
}
export interface PackSourceInputWindowsMetricsProcessSets {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#filter PackSource#filter}
  */
  readonly filter: string;
  /**
  * Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#include_children PackSource#include_children}
  */
  readonly includeChildren?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#name PackSource#name}
  */
  readonly name: string;
}

export function packSourceInputWindowsMetricsProcessSetsToTerraform(struct?: PackSourceInputWindowsMetricsProcessSets | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    filter: cdktf.stringToTerraform(struct!.filter),
    include_children: cdktf.booleanToTerraform(struct!.includeChildren),
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function packSourceInputWindowsMetricsProcessSetsToHclTerraform(struct?: PackSourceInputWindowsMetricsProcessSets | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    filter: {
      value: cdktf.stringToHclTerraform(struct!.filter),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    include_children: {
      value: cdktf.booleanToHclTerraform(struct!.includeChildren),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputWindowsMetricsProcessSetsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackSourceInputWindowsMetricsProcessSets | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._filter !== undefined) {
      hasAnyValues = true;
      internalValueResult.filter = this._filter;
    }
    if (this._includeChildren !== undefined) {
      hasAnyValues = true;
      internalValueResult.includeChildren = this._includeChildren;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputWindowsMetricsProcessSets | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._filter = undefined;
      this._includeChildren = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._filter = value.filter;
      this._includeChildren = value.includeChildren;
      this._name = value.name;
    }
  }

  // filter - computed: false, optional: false, required: true
  private _filter?: string; 
  public get filter() {
    return this.getStringAttribute('filter');
  }
  public set filter(value: string) {
    this._filter = value;
  }
  // Temporarily expose input value. Use with caution.
  public get filterInput() {
    return this._filter;
  }

  // include_children - computed: true, optional: true, required: false
  private _includeChildren?: boolean | cdktf.IResolvable; 
  public get includeChildren() {
    return this.getBooleanAttribute('include_children');
  }
  public set includeChildren(value: boolean | cdktf.IResolvable) {
    this._includeChildren = value;
  }
  public resetIncludeChildren() {
    this._includeChildren = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get includeChildrenInput() {
    return this._includeChildren;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}

export class PackSourceInputWindowsMetricsProcessSetsList extends cdktf.ComplexList {
  public internalValue? : PackSourceInputWindowsMetricsProcessSets[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackSourceInputWindowsMetricsProcessSetsOutputReference {
    return new PackSourceInputWindowsMetricsProcessSetsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackSourceInputWindowsMetricsProcess {
  /**
  * Configure sets to collect process metrics
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#sets PackSource#sets}
  */
  readonly sets?: PackSourceInputWindowsMetricsProcessSets[] | cdktf.IResolvable;
}

export function packSourceInputWindowsMetricsProcessToTerraform(struct?: PackSourceInputWindowsMetricsProcess | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    sets: cdktf.listMapper(packSourceInputWindowsMetricsProcessSetsToTerraform, false)(struct!.sets),
  }
}


export function packSourceInputWindowsMetricsProcessToHclTerraform(struct?: PackSourceInputWindowsMetricsProcess | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    sets: {
      value: cdktf.listMapperHcl(packSourceInputWindowsMetricsProcessSetsToHclTerraform, false)(struct!.sets),
      isBlock: true,
      type: "list",
      storageClassType: "PackSourceInputWindowsMetricsProcessSetsList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputWindowsMetricsProcessOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputWindowsMetricsProcess | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._sets?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.sets = this._sets?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputWindowsMetricsProcess | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._sets.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._sets.internalValue = value.sets;
    }
  }

  // sets - computed: false, optional: true, required: false
  private _sets = new PackSourceInputWindowsMetricsProcessSetsList(this, "sets", false);
  public get sets() {
    return this._sets;
  }
  public putSets(value: PackSourceInputWindowsMetricsProcessSets[] | cdktf.IResolvable) {
    this._sets.internalValue = value;
  }
  public resetSets() {
    this._sets.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get setsInput() {
    return this._sets.internalValue;
  }
}
export interface PackSourceInputWindowsMetrics {
  /**
  * Direct connections to Destinations, and optionally via a Pipeline or a Pack
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#connections PackSource#connections}
  */
  readonly connections?: PackSourceInputWindowsMetricsConnections[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#description PackSource#description}
  */
  readonly description?: string;
  /**
  * Enable to use built-in tools (PowerShell) to collect metrics instead of native API (default) [Learn more](https://docs.cribl.io/edge/sources-windows-metrics/#advanced-tab). Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#disable_native_module PackSource#disable_native_module}
  */
  readonly disableNativeModule?: boolean | cdktf.IResolvable;
  /**
  * Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#disabled PackSource#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#environment PackSource#environment}
  */
  readonly environment?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#host PackSource#host}
  */
  readonly host?: PackSourceInputWindowsMetricsHost;
  /**
  * Unique ID for this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#id PackSource#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id: string;
  /**
  * Time, in seconds, between consecutive metric collections. Default is 10 seconds. Default: 10
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#interval PackSource#interval}
  */
  readonly interval?: number;
  /**
  * Fields to add to events from this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#metadata PackSource#metadata}
  */
  readonly metadata?: PackSourceInputWindowsMetricsMetadata[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#persistence PackSource#persistence}
  */
  readonly persistence?: PackSourceInputWindowsMetricsPersistence;
  /**
  * Pipeline to process data from this Source before sending it through the Routes
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pipeline PackSource#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pq PackSource#pq}
  */
  readonly pq?: PackSourceInputWindowsMetricsPq;
  /**
  * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers). Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pq_enabled PackSource#pq_enabled}
  */
  readonly pqEnabled?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#process PackSource#process}
  */
  readonly process?: PackSourceInputWindowsMetricsProcess;
  /**
  * Select whether to send data to Routes, or directly to Destinations. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#send_to_routes PackSource#send_to_routes}
  */
  readonly sendToRoutes?: boolean | cdktf.IResolvable;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#streamtags PackSource#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * must be "windows_metrics"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#type PackSource#type}
  */
  readonly type: string;
}

export function packSourceInputWindowsMetricsToTerraform(struct?: PackSourceInputWindowsMetrics | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    connections: cdktf.listMapper(packSourceInputWindowsMetricsConnectionsToTerraform, false)(struct!.connections),
    description: cdktf.stringToTerraform(struct!.description),
    disable_native_module: cdktf.booleanToTerraform(struct!.disableNativeModule),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    environment: cdktf.stringToTerraform(struct!.environment),
    host: packSourceInputWindowsMetricsHostToTerraform(struct!.host),
    id: cdktf.stringToTerraform(struct!.id),
    interval: cdktf.numberToTerraform(struct!.interval),
    metadata: cdktf.listMapper(packSourceInputWindowsMetricsMetadataToTerraform, false)(struct!.metadata),
    persistence: packSourceInputWindowsMetricsPersistenceToTerraform(struct!.persistence),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    pq: packSourceInputWindowsMetricsPqToTerraform(struct!.pq),
    pq_enabled: cdktf.booleanToTerraform(struct!.pqEnabled),
    process: packSourceInputWindowsMetricsProcessToTerraform(struct!.process),
    send_to_routes: cdktf.booleanToTerraform(struct!.sendToRoutes),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function packSourceInputWindowsMetricsToHclTerraform(struct?: PackSourceInputWindowsMetrics | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    connections: {
      value: cdktf.listMapperHcl(packSourceInputWindowsMetricsConnectionsToHclTerraform, false)(struct!.connections),
      isBlock: true,
      type: "list",
      storageClassType: "PackSourceInputWindowsMetricsConnectionsList",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disable_native_module: {
      value: cdktf.booleanToHclTerraform(struct!.disableNativeModule),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    host: {
      value: packSourceInputWindowsMetricsHostToHclTerraform(struct!.host),
      isBlock: true,
      type: "struct",
      storageClassType: "PackSourceInputWindowsMetricsHost",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    interval: {
      value: cdktf.numberToHclTerraform(struct!.interval),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    metadata: {
      value: cdktf.listMapperHcl(packSourceInputWindowsMetricsMetadataToHclTerraform, false)(struct!.metadata),
      isBlock: true,
      type: "list",
      storageClassType: "PackSourceInputWindowsMetricsMetadataList",
    },
    persistence: {
      value: packSourceInputWindowsMetricsPersistenceToHclTerraform(struct!.persistence),
      isBlock: true,
      type: "struct",
      storageClassType: "PackSourceInputWindowsMetricsPersistence",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq: {
      value: packSourceInputWindowsMetricsPqToHclTerraform(struct!.pq),
      isBlock: true,
      type: "struct",
      storageClassType: "PackSourceInputWindowsMetricsPq",
    },
    pq_enabled: {
      value: cdktf.booleanToHclTerraform(struct!.pqEnabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    process: {
      value: packSourceInputWindowsMetricsProcessToHclTerraform(struct!.process),
      isBlock: true,
      type: "struct",
      storageClassType: "PackSourceInputWindowsMetricsProcess",
    },
    send_to_routes: {
      value: cdktf.booleanToHclTerraform(struct!.sendToRoutes),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputWindowsMetricsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputWindowsMetrics | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._connections?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.connections = this._connections?.internalValue;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._disableNativeModule !== undefined) {
      hasAnyValues = true;
      internalValueResult.disableNativeModule = this._disableNativeModule;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._host?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.host = this._host?.internalValue;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._interval !== undefined) {
      hasAnyValues = true;
      internalValueResult.interval = this._interval;
    }
    if (this._metadata?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadata = this._metadata?.internalValue;
    }
    if (this._persistence?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.persistence = this._persistence?.internalValue;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._pq?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pq = this._pq?.internalValue;
    }
    if (this._pqEnabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqEnabled = this._pqEnabled;
    }
    if (this._process?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.process = this._process?.internalValue;
    }
    if (this._sendToRoutes !== undefined) {
      hasAnyValues = true;
      internalValueResult.sendToRoutes = this._sendToRoutes;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputWindowsMetrics | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._connections.internalValue = undefined;
      this._description = undefined;
      this._disableNativeModule = undefined;
      this._disabled = undefined;
      this._environment = undefined;
      this._host.internalValue = undefined;
      this._id = undefined;
      this._interval = undefined;
      this._metadata.internalValue = undefined;
      this._persistence.internalValue = undefined;
      this._pipeline = undefined;
      this._pq.internalValue = undefined;
      this._pqEnabled = undefined;
      this._process.internalValue = undefined;
      this._sendToRoutes = undefined;
      this._streamtags = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._connections.internalValue = value.connections;
      this._description = value.description;
      this._disableNativeModule = value.disableNativeModule;
      this._disabled = value.disabled;
      this._environment = value.environment;
      this._host.internalValue = value.host;
      this._id = value.id;
      this._interval = value.interval;
      this._metadata.internalValue = value.metadata;
      this._persistence.internalValue = value.persistence;
      this._pipeline = value.pipeline;
      this._pq.internalValue = value.pq;
      this._pqEnabled = value.pqEnabled;
      this._process.internalValue = value.process;
      this._sendToRoutes = value.sendToRoutes;
      this._streamtags = value.streamtags;
      this._type = value.type;
    }
  }

  // connections - computed: false, optional: true, required: false
  private _connections = new PackSourceInputWindowsMetricsConnectionsList(this, "connections", false);
  public get connections() {
    return this._connections;
  }
  public putConnections(value: PackSourceInputWindowsMetricsConnections[] | cdktf.IResolvable) {
    this._connections.internalValue = value;
  }
  public resetConnections() {
    this._connections.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectionsInput() {
    return this._connections.internalValue;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // disable_native_module - computed: true, optional: true, required: false
  private _disableNativeModule?: boolean | cdktf.IResolvable; 
  public get disableNativeModule() {
    return this.getBooleanAttribute('disable_native_module');
  }
  public set disableNativeModule(value: boolean | cdktf.IResolvable) {
    this._disableNativeModule = value;
  }
  public resetDisableNativeModule() {
    this._disableNativeModule = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disableNativeModuleInput() {
    return this._disableNativeModule;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // host - computed: false, optional: true, required: false
  private _host = new PackSourceInputWindowsMetricsHostOutputReference(this, "host");
  public get host() {
    return this._host;
  }
  public putHost(value: PackSourceInputWindowsMetricsHost) {
    this._host.internalValue = value;
  }
  public resetHost() {
    this._host.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostInput() {
    return this._host.internalValue;
  }

  // id - computed: false, optional: false, required: true
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // interval - computed: true, optional: true, required: false
  private _interval?: number; 
  public get interval() {
    return this.getNumberAttribute('interval');
  }
  public set interval(value: number) {
    this._interval = value;
  }
  public resetInterval() {
    this._interval = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get intervalInput() {
    return this._interval;
  }

  // metadata - computed: false, optional: true, required: false
  private _metadata = new PackSourceInputWindowsMetricsMetadataList(this, "metadata", false);
  public get metadata() {
    return this._metadata;
  }
  public putMetadata(value: PackSourceInputWindowsMetricsMetadata[] | cdktf.IResolvable) {
    this._metadata.internalValue = value;
  }
  public resetMetadata() {
    this._metadata.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataInput() {
    return this._metadata.internalValue;
  }

  // persistence - computed: false, optional: true, required: false
  private _persistence = new PackSourceInputWindowsMetricsPersistenceOutputReference(this, "persistence");
  public get persistence() {
    return this._persistence;
  }
  public putPersistence(value: PackSourceInputWindowsMetricsPersistence) {
    this._persistence.internalValue = value;
  }
  public resetPersistence() {
    this._persistence.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get persistenceInput() {
    return this._persistence.internalValue;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // pq - computed: false, optional: true, required: false
  private _pq = new PackSourceInputWindowsMetricsPqOutputReference(this, "pq");
  public get pq() {
    return this._pq;
  }
  public putPq(value: PackSourceInputWindowsMetricsPq) {
    this._pq.internalValue = value;
  }
  public resetPq() {
    this._pq.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqInput() {
    return this._pq.internalValue;
  }

  // pq_enabled - computed: true, optional: true, required: false
  private _pqEnabled?: boolean | cdktf.IResolvable; 
  public get pqEnabled() {
    return this.getBooleanAttribute('pq_enabled');
  }
  public set pqEnabled(value: boolean | cdktf.IResolvable) {
    this._pqEnabled = value;
  }
  public resetPqEnabled() {
    this._pqEnabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqEnabledInput() {
    return this._pqEnabled;
  }

  // process - computed: false, optional: true, required: false
  private _process = new PackSourceInputWindowsMetricsProcessOutputReference(this, "process");
  public get process() {
    return this._process;
  }
  public putProcess(value: PackSourceInputWindowsMetricsProcess) {
    this._process.internalValue = value;
  }
  public resetProcess() {
    this._process.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get processInput() {
    return this._process.internalValue;
  }

  // send_to_routes - computed: true, optional: true, required: false
  private _sendToRoutes?: boolean | cdktf.IResolvable; 
  public get sendToRoutes() {
    return this.getBooleanAttribute('send_to_routes');
  }
  public set sendToRoutes(value: boolean | cdktf.IResolvable) {
    this._sendToRoutes = value;
  }
  public resetSendToRoutes() {
    this._sendToRoutes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sendToRoutesInput() {
    return this._sendToRoutes;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface PackSourceInputWizConnections {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#output PackSource#output}
  */
  readonly output: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pipeline PackSource#pipeline}
  */
  readonly pipeline?: string;
}

export function packSourceInputWizConnectionsToTerraform(struct?: PackSourceInputWizConnections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    output: cdktf.stringToTerraform(struct!.output),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
  }
}


export function packSourceInputWizConnectionsToHclTerraform(struct?: PackSourceInputWizConnections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    output: {
      value: cdktf.stringToHclTerraform(struct!.output),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputWizConnectionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackSourceInputWizConnections | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._output !== undefined) {
      hasAnyValues = true;
      internalValueResult.output = this._output;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputWizConnections | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._output = undefined;
      this._pipeline = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._output = value.output;
      this._pipeline = value.pipeline;
    }
  }

  // output - computed: false, optional: false, required: true
  private _output?: string; 
  public get output() {
    return this.getStringAttribute('output');
  }
  public set output(value: string) {
    this._output = value;
  }
  // Temporarily expose input value. Use with caution.
  public get outputInput() {
    return this._output;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }
}

export class PackSourceInputWizConnectionsList extends cdktf.ComplexList {
  public internalValue? : PackSourceInputWizConnections[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackSourceInputWizConnectionsOutputReference {
    return new PackSourceInputWizConnectionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackSourceInputWizContentConfig {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#content_description PackSource#content_description}
  */
  readonly contentDescription?: string;
  /**
  * The name of the Wiz query
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#content_type PackSource#content_type}
  */
  readonly contentType: string;
  /**
  * Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#enabled PackSource#enabled}
  */
  readonly enabled?: boolean | cdktf.IResolvable;
}

export function packSourceInputWizContentConfigToTerraform(struct?: PackSourceInputWizContentConfig | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    content_description: cdktf.stringToTerraform(struct!.contentDescription),
    content_type: cdktf.stringToTerraform(struct!.contentType),
    enabled: cdktf.booleanToTerraform(struct!.enabled),
  }
}


export function packSourceInputWizContentConfigToHclTerraform(struct?: PackSourceInputWizContentConfig | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    content_description: {
      value: cdktf.stringToHclTerraform(struct!.contentDescription),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    content_type: {
      value: cdktf.stringToHclTerraform(struct!.contentType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    enabled: {
      value: cdktf.booleanToHclTerraform(struct!.enabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputWizContentConfigOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackSourceInputWizContentConfig | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._contentDescription !== undefined) {
      hasAnyValues = true;
      internalValueResult.contentDescription = this._contentDescription;
    }
    if (this._contentType !== undefined) {
      hasAnyValues = true;
      internalValueResult.contentType = this._contentType;
    }
    if (this._enabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.enabled = this._enabled;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputWizContentConfig | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._contentDescription = undefined;
      this._contentType = undefined;
      this._enabled = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._contentDescription = value.contentDescription;
      this._contentType = value.contentType;
      this._enabled = value.enabled;
    }
  }

  // content_description - computed: false, optional: true, required: false
  private _contentDescription?: string; 
  public get contentDescription() {
    return this.getStringAttribute('content_description');
  }
  public set contentDescription(value: string) {
    this._contentDescription = value;
  }
  public resetContentDescription() {
    this._contentDescription = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get contentDescriptionInput() {
    return this._contentDescription;
  }

  // content_type - computed: false, optional: false, required: true
  private _contentType?: string; 
  public get contentType() {
    return this.getStringAttribute('content_type');
  }
  public set contentType(value: string) {
    this._contentType = value;
  }
  // Temporarily expose input value. Use with caution.
  public get contentTypeInput() {
    return this._contentType;
  }

  // enabled - computed: true, optional: true, required: false
  private _enabled?: boolean | cdktf.IResolvable; 
  public get enabled() {
    return this.getBooleanAttribute('enabled');
  }
  public set enabled(value: boolean | cdktf.IResolvable) {
    this._enabled = value;
  }
  public resetEnabled() {
    this._enabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enabledInput() {
    return this._enabled;
  }
}

export class PackSourceInputWizContentConfigList extends cdktf.ComplexList {
  public internalValue? : PackSourceInputWizContentConfig[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackSourceInputWizContentConfigOutputReference {
    return new PackSourceInputWizContentConfigOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackSourceInputWizMetadata {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#name PackSource#name}
  */
  readonly name: string;
  /**
  * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#value PackSource#value}
  */
  readonly value: string;
}

export function packSourceInputWizMetadataToTerraform(struct?: PackSourceInputWizMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function packSourceInputWizMetadataToHclTerraform(struct?: PackSourceInputWizMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputWizMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackSourceInputWizMetadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputWizMetadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class PackSourceInputWizMetadataList extends cdktf.ComplexList {
  public internalValue? : PackSourceInputWizMetadata[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackSourceInputWizMetadataOutputReference {
    return new PackSourceInputWizMetadataOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackSourceInputWizPq {
  /**
  * The number of events to send downstream before committing that Stream has read them. Default: 42
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#commit_frequency PackSource#commit_frequency}
  */
  readonly commitFrequency?: number;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#compress PackSource#compress}
  */
  readonly compress?: string;
  /**
  * The maximum number of events to hold in memory before writing the events to disk. Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_buffer_size PackSource#max_buffer_size}
  */
  readonly maxBufferSize?: number;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc. Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_file_size PackSource#max_file_size}
  */
  readonly maxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_size PackSource#max_size}
  */
  readonly maxSize?: string;
  /**
  * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine. Default: "always"; must be one of ["smart", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#mode PackSource#mode}
  */
  readonly mode?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#path PackSource#path}
  */
  readonly path?: string;
}

export function packSourceInputWizPqToTerraform(struct?: PackSourceInputWizPq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    commit_frequency: cdktf.numberToTerraform(struct!.commitFrequency),
    compress: cdktf.stringToTerraform(struct!.compress),
    max_buffer_size: cdktf.numberToTerraform(struct!.maxBufferSize),
    max_file_size: cdktf.stringToTerraform(struct!.maxFileSize),
    max_size: cdktf.stringToTerraform(struct!.maxSize),
    mode: cdktf.stringToTerraform(struct!.mode),
    path: cdktf.stringToTerraform(struct!.path),
  }
}


export function packSourceInputWizPqToHclTerraform(struct?: PackSourceInputWizPq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    commit_frequency: {
      value: cdktf.numberToHclTerraform(struct!.commitFrequency),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    compress: {
      value: cdktf.stringToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_buffer_size: {
      value: cdktf.numberToHclTerraform(struct!.maxBufferSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.maxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_size: {
      value: cdktf.stringToHclTerraform(struct!.maxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputWizPqOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputWizPq | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._commitFrequency !== undefined) {
      hasAnyValues = true;
      internalValueResult.commitFrequency = this._commitFrequency;
    }
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._maxBufferSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBufferSize = this._maxBufferSize;
    }
    if (this._maxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxFileSize = this._maxFileSize;
    }
    if (this._maxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxSize = this._maxSize;
    }
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputWizPq | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._commitFrequency = undefined;
      this._compress = undefined;
      this._maxBufferSize = undefined;
      this._maxFileSize = undefined;
      this._maxSize = undefined;
      this._mode = undefined;
      this._path = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._commitFrequency = value.commitFrequency;
      this._compress = value.compress;
      this._maxBufferSize = value.maxBufferSize;
      this._maxFileSize = value.maxFileSize;
      this._maxSize = value.maxSize;
      this._mode = value.mode;
      this._path = value.path;
    }
  }

  // commit_frequency - computed: true, optional: true, required: false
  private _commitFrequency?: number; 
  public get commitFrequency() {
    return this.getNumberAttribute('commit_frequency');
  }
  public set commitFrequency(value: number) {
    this._commitFrequency = value;
  }
  public resetCommitFrequency() {
    this._commitFrequency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commitFrequencyInput() {
    return this._commitFrequency;
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: string; 
  public get compress() {
    return this.getStringAttribute('compress');
  }
  public set compress(value: string) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // max_buffer_size - computed: true, optional: true, required: false
  private _maxBufferSize?: number; 
  public get maxBufferSize() {
    return this.getNumberAttribute('max_buffer_size');
  }
  public set maxBufferSize(value: number) {
    this._maxBufferSize = value;
  }
  public resetMaxBufferSize() {
    this._maxBufferSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBufferSizeInput() {
    return this._maxBufferSize;
  }

  // max_file_size - computed: true, optional: true, required: false
  private _maxFileSize?: string; 
  public get maxFileSize() {
    return this.getStringAttribute('max_file_size');
  }
  public set maxFileSize(value: string) {
    this._maxFileSize = value;
  }
  public resetMaxFileSize() {
    this._maxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxFileSizeInput() {
    return this._maxFileSize;
  }

  // max_size - computed: true, optional: true, required: false
  private _maxSize?: string; 
  public get maxSize() {
    return this.getStringAttribute('max_size');
  }
  public set maxSize(value: string) {
    this._maxSize = value;
  }
  public resetMaxSize() {
    this._maxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxSizeInput() {
    return this._maxSize;
  }

  // mode - computed: true, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // path - computed: true, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }
}
export interface PackSourceInputWizRetryRules {
  /**
  * List of HTTP codes that trigger a retry. Leave empty to use the default list of 429 and 503. Default: [429,503]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#codes PackSource#codes}
  */
  readonly codes?: number[];
  /**
  * Honor any Retry-After header that specifies a delay (in seconds) or a timestamp after which to retry the request. The delay is limited to 20 seconds, even if the Retry-After header specifies a longer delay. When disabled, all Retry-After headers are ignored. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#enable_header PackSource#enable_header}
  */
  readonly enableHeader?: boolean | cdktf.IResolvable;
  /**
  * Time interval between failed request and first retry (kickoff). Maximum allowed value is 20,000 ms (1/3 minute). Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#interval PackSource#interval}
  */
  readonly interval?: number;
  /**
  * The maximum number of times to retry a failed HTTP request. Default: 5
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#limit PackSource#limit}
  */
  readonly limit?: number;
  /**
  * Base for exponential backoff, e.g., base 2 means that retries will occur after 2, then 4, then 8 seconds, and so on. Default: 2
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#multiplier PackSource#multiplier}
  */
  readonly multiplier?: number;
  /**
  * Retry request when a connection reset (ECONNRESET) error occurs. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#retry_connect_reset PackSource#retry_connect_reset}
  */
  readonly retryConnectReset?: boolean | cdktf.IResolvable;
  /**
  * Make a single retry attempt when a connection timeout (ETIMEDOUT) error occurs. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#retry_connect_timeout PackSource#retry_connect_timeout}
  */
  readonly retryConnectTimeout?: boolean | cdktf.IResolvable;
  /**
  * The algorithm to use when performing HTTP retries. Default: "backoff"; must be one of ["none", "backoff", "static"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#type PackSource#type}
  */
  readonly type?: string;
}

export function packSourceInputWizRetryRulesToTerraform(struct?: PackSourceInputWizRetryRules | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    codes: cdktf.listMapper(cdktf.numberToTerraform, false)(struct!.codes),
    enable_header: cdktf.booleanToTerraform(struct!.enableHeader),
    interval: cdktf.numberToTerraform(struct!.interval),
    limit: cdktf.numberToTerraform(struct!.limit),
    multiplier: cdktf.numberToTerraform(struct!.multiplier),
    retry_connect_reset: cdktf.booleanToTerraform(struct!.retryConnectReset),
    retry_connect_timeout: cdktf.booleanToTerraform(struct!.retryConnectTimeout),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function packSourceInputWizRetryRulesToHclTerraform(struct?: PackSourceInputWizRetryRules | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    codes: {
      value: cdktf.listMapperHcl(cdktf.numberToHclTerraform, false)(struct!.codes),
      isBlock: false,
      type: "list",
      storageClassType: "numberList",
    },
    enable_header: {
      value: cdktf.booleanToHclTerraform(struct!.enableHeader),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    interval: {
      value: cdktf.numberToHclTerraform(struct!.interval),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    limit: {
      value: cdktf.numberToHclTerraform(struct!.limit),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    multiplier: {
      value: cdktf.numberToHclTerraform(struct!.multiplier),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    retry_connect_reset: {
      value: cdktf.booleanToHclTerraform(struct!.retryConnectReset),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    retry_connect_timeout: {
      value: cdktf.booleanToHclTerraform(struct!.retryConnectTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputWizRetryRulesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputWizRetryRules | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._codes !== undefined) {
      hasAnyValues = true;
      internalValueResult.codes = this._codes;
    }
    if (this._enableHeader !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableHeader = this._enableHeader;
    }
    if (this._interval !== undefined) {
      hasAnyValues = true;
      internalValueResult.interval = this._interval;
    }
    if (this._limit !== undefined) {
      hasAnyValues = true;
      internalValueResult.limit = this._limit;
    }
    if (this._multiplier !== undefined) {
      hasAnyValues = true;
      internalValueResult.multiplier = this._multiplier;
    }
    if (this._retryConnectReset !== undefined) {
      hasAnyValues = true;
      internalValueResult.retryConnectReset = this._retryConnectReset;
    }
    if (this._retryConnectTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.retryConnectTimeout = this._retryConnectTimeout;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputWizRetryRules | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._codes = undefined;
      this._enableHeader = undefined;
      this._interval = undefined;
      this._limit = undefined;
      this._multiplier = undefined;
      this._retryConnectReset = undefined;
      this._retryConnectTimeout = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._codes = value.codes;
      this._enableHeader = value.enableHeader;
      this._interval = value.interval;
      this._limit = value.limit;
      this._multiplier = value.multiplier;
      this._retryConnectReset = value.retryConnectReset;
      this._retryConnectTimeout = value.retryConnectTimeout;
      this._type = value.type;
    }
  }

  // codes - computed: true, optional: true, required: false
  private _codes?: number[]; 
  public get codes() {
    return this.getNumberListAttribute('codes');
  }
  public set codes(value: number[]) {
    this._codes = value;
  }
  public resetCodes() {
    this._codes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get codesInput() {
    return this._codes;
  }

  // enable_header - computed: true, optional: true, required: false
  private _enableHeader?: boolean | cdktf.IResolvable; 
  public get enableHeader() {
    return this.getBooleanAttribute('enable_header');
  }
  public set enableHeader(value: boolean | cdktf.IResolvable) {
    this._enableHeader = value;
  }
  public resetEnableHeader() {
    this._enableHeader = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableHeaderInput() {
    return this._enableHeader;
  }

  // interval - computed: true, optional: true, required: false
  private _interval?: number; 
  public get interval() {
    return this.getNumberAttribute('interval');
  }
  public set interval(value: number) {
    this._interval = value;
  }
  public resetInterval() {
    this._interval = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get intervalInput() {
    return this._interval;
  }

  // limit - computed: true, optional: true, required: false
  private _limit?: number; 
  public get limit() {
    return this.getNumberAttribute('limit');
  }
  public set limit(value: number) {
    this._limit = value;
  }
  public resetLimit() {
    this._limit = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get limitInput() {
    return this._limit;
  }

  // multiplier - computed: true, optional: true, required: false
  private _multiplier?: number; 
  public get multiplier() {
    return this.getNumberAttribute('multiplier');
  }
  public set multiplier(value: number) {
    this._multiplier = value;
  }
  public resetMultiplier() {
    this._multiplier = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get multiplierInput() {
    return this._multiplier;
  }

  // retry_connect_reset - computed: true, optional: true, required: false
  private _retryConnectReset?: boolean | cdktf.IResolvable; 
  public get retryConnectReset() {
    return this.getBooleanAttribute('retry_connect_reset');
  }
  public set retryConnectReset(value: boolean | cdktf.IResolvable) {
    this._retryConnectReset = value;
  }
  public resetRetryConnectReset() {
    this._retryConnectReset = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get retryConnectResetInput() {
    return this._retryConnectReset;
  }

  // retry_connect_timeout - computed: true, optional: true, required: false
  private _retryConnectTimeout?: boolean | cdktf.IResolvable; 
  public get retryConnectTimeout() {
    return this.getBooleanAttribute('retry_connect_timeout');
  }
  public set retryConnectTimeout(value: boolean | cdktf.IResolvable) {
    this._retryConnectTimeout = value;
  }
  public resetRetryConnectTimeout() {
    this._retryConnectTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get retryConnectTimeoutInput() {
    return this._retryConnectTimeout;
  }

  // type - computed: true, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface PackSourceInputWiz {
  /**
  * The audience to use when requesting an OAuth token for a custom auth URL. When not specified, `wiz-api` will be used.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#auth_audience_override PackSource#auth_audience_override}
  */
  readonly authAudienceOverride?: string;
  /**
  * Enter client secret directly, or select a stored secret. Default: "manual"; must be one of ["manual", "secret"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#auth_type PackSource#auth_type}
  */
  readonly authType?: string;
  /**
  * The authentication URL to generate an OAuth token
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#auth_url PackSource#auth_url}
  */
  readonly authUrl: string;
  /**
  * The client ID of the Wiz application
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#client_id PackSource#client_id}
  */
  readonly clientId: string;
  /**
  * The client secret of the Wiz application
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#client_secret PackSource#client_secret}
  */
  readonly clientSecret?: string;
  /**
  * Direct connections to Destinations, and optionally via a Pipeline or a Pack
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#connections PackSource#connections}
  */
  readonly connections?: PackSourceInputWizConnections[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#content_config PackSource#content_config}
  */
  readonly contentConfig?: PackSourceInputWizContentConfig[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#description PackSource#description}
  */
  readonly description?: string;
  /**
  * Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#disabled PackSource#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * The Wiz GraphQL API endpoint. Example: https://api.us1.app.wiz.io/graphql. Default: "https://api.<region>.app.wiz.io/graphql"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#endpoint PackSource#endpoint}
  */
  readonly endpoint?: string;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#environment PackSource#environment}
  */
  readonly environment?: string;
  /**
  * Unique ID for this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#id PackSource#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * When enabled, this job's artifacts are not counted toward the Worker Group's finished job artifacts limit. Artifacts will be removed only after the Collector's configured time to live. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#ignore_group_jobs_limit PackSource#ignore_group_jobs_limit}
  */
  readonly ignoreGroupJobsLimit?: boolean | cdktf.IResolvable;
  /**
  * How often workers should check in with the scheduler to keep job subscription alive. Default: 30
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#keep_alive_time PackSource#keep_alive_time}
  */
  readonly keepAliveTime?: number;
  /**
  * The number of Keep Alive Time periods before an inactive worker will have its job subscription revoked. Default: 3
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_missed_keep_alives PackSource#max_missed_keep_alives}
  */
  readonly maxMissedKeepAlives?: number;
  /**
  * Fields to add to events from this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#metadata PackSource#metadata}
  */
  readonly metadata?: PackSourceInputWizMetadata[] | cdktf.IResolvable;
  /**
  * Pipeline to process data from this Source before sending it through the Routes
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pipeline PackSource#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pq PackSource#pq}
  */
  readonly pq?: PackSourceInputWizPq;
  /**
  * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers). Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pq_enabled PackSource#pq_enabled}
  */
  readonly pqEnabled?: boolean | cdktf.IResolvable;
  /**
  * HTTP request inactivity timeout. Use 0 to disable. Default: 300
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#request_timeout PackSource#request_timeout}
  */
  readonly requestTimeout?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#retry_rules PackSource#retry_rules}
  */
  readonly retryRules?: PackSourceInputWizRetryRules;
  /**
  * Select whether to send data to Routes, or directly to Destinations. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#send_to_routes PackSource#send_to_routes}
  */
  readonly sendToRoutes?: boolean | cdktf.IResolvable;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#streamtags PackSource#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Select or create a stored text secret
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#text_secret PackSource#text_secret}
  */
  readonly textSecret?: string;
  /**
  * Time to keep the job's artifacts on disk after job completion. This also affects how long a job is listed in the Job Inspector. Default: "4h"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#ttl PackSource#ttl}
  */
  readonly ttl?: string;
  /**
  * must be "wiz"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#type PackSource#type}
  */
  readonly type?: string;
}

export function packSourceInputWizToTerraform(struct?: PackSourceInputWiz | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    auth_audience_override: cdktf.stringToTerraform(struct!.authAudienceOverride),
    auth_type: cdktf.stringToTerraform(struct!.authType),
    auth_url: cdktf.stringToTerraform(struct!.authUrl),
    client_id: cdktf.stringToTerraform(struct!.clientId),
    client_secret: cdktf.stringToTerraform(struct!.clientSecret),
    connections: cdktf.listMapper(packSourceInputWizConnectionsToTerraform, false)(struct!.connections),
    content_config: cdktf.listMapper(packSourceInputWizContentConfigToTerraform, false)(struct!.contentConfig),
    description: cdktf.stringToTerraform(struct!.description),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    endpoint: cdktf.stringToTerraform(struct!.endpoint),
    environment: cdktf.stringToTerraform(struct!.environment),
    id: cdktf.stringToTerraform(struct!.id),
    ignore_group_jobs_limit: cdktf.booleanToTerraform(struct!.ignoreGroupJobsLimit),
    keep_alive_time: cdktf.numberToTerraform(struct!.keepAliveTime),
    max_missed_keep_alives: cdktf.numberToTerraform(struct!.maxMissedKeepAlives),
    metadata: cdktf.listMapper(packSourceInputWizMetadataToTerraform, false)(struct!.metadata),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    pq: packSourceInputWizPqToTerraform(struct!.pq),
    pq_enabled: cdktf.booleanToTerraform(struct!.pqEnabled),
    request_timeout: cdktf.numberToTerraform(struct!.requestTimeout),
    retry_rules: packSourceInputWizRetryRulesToTerraform(struct!.retryRules),
    send_to_routes: cdktf.booleanToTerraform(struct!.sendToRoutes),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    text_secret: cdktf.stringToTerraform(struct!.textSecret),
    ttl: cdktf.stringToTerraform(struct!.ttl),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function packSourceInputWizToHclTerraform(struct?: PackSourceInputWiz | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    auth_audience_override: {
      value: cdktf.stringToHclTerraform(struct!.authAudienceOverride),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    auth_type: {
      value: cdktf.stringToHclTerraform(struct!.authType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    auth_url: {
      value: cdktf.stringToHclTerraform(struct!.authUrl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    client_id: {
      value: cdktf.stringToHclTerraform(struct!.clientId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    client_secret: {
      value: cdktf.stringToHclTerraform(struct!.clientSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    connections: {
      value: cdktf.listMapperHcl(packSourceInputWizConnectionsToHclTerraform, false)(struct!.connections),
      isBlock: true,
      type: "list",
      storageClassType: "PackSourceInputWizConnectionsList",
    },
    content_config: {
      value: cdktf.listMapperHcl(packSourceInputWizContentConfigToHclTerraform, false)(struct!.contentConfig),
      isBlock: true,
      type: "list",
      storageClassType: "PackSourceInputWizContentConfigList",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    endpoint: {
      value: cdktf.stringToHclTerraform(struct!.endpoint),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ignore_group_jobs_limit: {
      value: cdktf.booleanToHclTerraform(struct!.ignoreGroupJobsLimit),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    keep_alive_time: {
      value: cdktf.numberToHclTerraform(struct!.keepAliveTime),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_missed_keep_alives: {
      value: cdktf.numberToHclTerraform(struct!.maxMissedKeepAlives),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    metadata: {
      value: cdktf.listMapperHcl(packSourceInputWizMetadataToHclTerraform, false)(struct!.metadata),
      isBlock: true,
      type: "list",
      storageClassType: "PackSourceInputWizMetadataList",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq: {
      value: packSourceInputWizPqToHclTerraform(struct!.pq),
      isBlock: true,
      type: "struct",
      storageClassType: "PackSourceInputWizPq",
    },
    pq_enabled: {
      value: cdktf.booleanToHclTerraform(struct!.pqEnabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    request_timeout: {
      value: cdktf.numberToHclTerraform(struct!.requestTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    retry_rules: {
      value: packSourceInputWizRetryRulesToHclTerraform(struct!.retryRules),
      isBlock: true,
      type: "struct",
      storageClassType: "PackSourceInputWizRetryRules",
    },
    send_to_routes: {
      value: cdktf.booleanToHclTerraform(struct!.sendToRoutes),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    text_secret: {
      value: cdktf.stringToHclTerraform(struct!.textSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ttl: {
      value: cdktf.stringToHclTerraform(struct!.ttl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputWizOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputWiz | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._authAudienceOverride !== undefined) {
      hasAnyValues = true;
      internalValueResult.authAudienceOverride = this._authAudienceOverride;
    }
    if (this._authType !== undefined) {
      hasAnyValues = true;
      internalValueResult.authType = this._authType;
    }
    if (this._authUrl !== undefined) {
      hasAnyValues = true;
      internalValueResult.authUrl = this._authUrl;
    }
    if (this._clientId !== undefined) {
      hasAnyValues = true;
      internalValueResult.clientId = this._clientId;
    }
    if (this._clientSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.clientSecret = this._clientSecret;
    }
    if (this._connections?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.connections = this._connections?.internalValue;
    }
    if (this._contentConfig?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.contentConfig = this._contentConfig?.internalValue;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._endpoint !== undefined) {
      hasAnyValues = true;
      internalValueResult.endpoint = this._endpoint;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._ignoreGroupJobsLimit !== undefined) {
      hasAnyValues = true;
      internalValueResult.ignoreGroupJobsLimit = this._ignoreGroupJobsLimit;
    }
    if (this._keepAliveTime !== undefined) {
      hasAnyValues = true;
      internalValueResult.keepAliveTime = this._keepAliveTime;
    }
    if (this._maxMissedKeepAlives !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxMissedKeepAlives = this._maxMissedKeepAlives;
    }
    if (this._metadata?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadata = this._metadata?.internalValue;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._pq?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pq = this._pq?.internalValue;
    }
    if (this._pqEnabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqEnabled = this._pqEnabled;
    }
    if (this._requestTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.requestTimeout = this._requestTimeout;
    }
    if (this._retryRules?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.retryRules = this._retryRules?.internalValue;
    }
    if (this._sendToRoutes !== undefined) {
      hasAnyValues = true;
      internalValueResult.sendToRoutes = this._sendToRoutes;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._textSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.textSecret = this._textSecret;
    }
    if (this._ttl !== undefined) {
      hasAnyValues = true;
      internalValueResult.ttl = this._ttl;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputWiz | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._authAudienceOverride = undefined;
      this._authType = undefined;
      this._authUrl = undefined;
      this._clientId = undefined;
      this._clientSecret = undefined;
      this._connections.internalValue = undefined;
      this._contentConfig.internalValue = undefined;
      this._description = undefined;
      this._disabled = undefined;
      this._endpoint = undefined;
      this._environment = undefined;
      this._id = undefined;
      this._ignoreGroupJobsLimit = undefined;
      this._keepAliveTime = undefined;
      this._maxMissedKeepAlives = undefined;
      this._metadata.internalValue = undefined;
      this._pipeline = undefined;
      this._pq.internalValue = undefined;
      this._pqEnabled = undefined;
      this._requestTimeout = undefined;
      this._retryRules.internalValue = undefined;
      this._sendToRoutes = undefined;
      this._streamtags = undefined;
      this._textSecret = undefined;
      this._ttl = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._authAudienceOverride = value.authAudienceOverride;
      this._authType = value.authType;
      this._authUrl = value.authUrl;
      this._clientId = value.clientId;
      this._clientSecret = value.clientSecret;
      this._connections.internalValue = value.connections;
      this._contentConfig.internalValue = value.contentConfig;
      this._description = value.description;
      this._disabled = value.disabled;
      this._endpoint = value.endpoint;
      this._environment = value.environment;
      this._id = value.id;
      this._ignoreGroupJobsLimit = value.ignoreGroupJobsLimit;
      this._keepAliveTime = value.keepAliveTime;
      this._maxMissedKeepAlives = value.maxMissedKeepAlives;
      this._metadata.internalValue = value.metadata;
      this._pipeline = value.pipeline;
      this._pq.internalValue = value.pq;
      this._pqEnabled = value.pqEnabled;
      this._requestTimeout = value.requestTimeout;
      this._retryRules.internalValue = value.retryRules;
      this._sendToRoutes = value.sendToRoutes;
      this._streamtags = value.streamtags;
      this._textSecret = value.textSecret;
      this._ttl = value.ttl;
      this._type = value.type;
    }
  }

  // auth_audience_override - computed: false, optional: true, required: false
  private _authAudienceOverride?: string; 
  public get authAudienceOverride() {
    return this.getStringAttribute('auth_audience_override');
  }
  public set authAudienceOverride(value: string) {
    this._authAudienceOverride = value;
  }
  public resetAuthAudienceOverride() {
    this._authAudienceOverride = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authAudienceOverrideInput() {
    return this._authAudienceOverride;
  }

  // auth_type - computed: true, optional: true, required: false
  private _authType?: string; 
  public get authType() {
    return this.getStringAttribute('auth_type');
  }
  public set authType(value: string) {
    this._authType = value;
  }
  public resetAuthType() {
    this._authType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authTypeInput() {
    return this._authType;
  }

  // auth_url - computed: false, optional: false, required: true
  private _authUrl?: string; 
  public get authUrl() {
    return this.getStringAttribute('auth_url');
  }
  public set authUrl(value: string) {
    this._authUrl = value;
  }
  // Temporarily expose input value. Use with caution.
  public get authUrlInput() {
    return this._authUrl;
  }

  // client_id - computed: false, optional: false, required: true
  private _clientId?: string; 
  public get clientId() {
    return this.getStringAttribute('client_id');
  }
  public set clientId(value: string) {
    this._clientId = value;
  }
  // Temporarily expose input value. Use with caution.
  public get clientIdInput() {
    return this._clientId;
  }

  // client_secret - computed: false, optional: true, required: false
  private _clientSecret?: string; 
  public get clientSecret() {
    return this.getStringAttribute('client_secret');
  }
  public set clientSecret(value: string) {
    this._clientSecret = value;
  }
  public resetClientSecret() {
    this._clientSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clientSecretInput() {
    return this._clientSecret;
  }

  // connections - computed: false, optional: true, required: false
  private _connections = new PackSourceInputWizConnectionsList(this, "connections", false);
  public get connections() {
    return this._connections;
  }
  public putConnections(value: PackSourceInputWizConnections[] | cdktf.IResolvable) {
    this._connections.internalValue = value;
  }
  public resetConnections() {
    this._connections.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectionsInput() {
    return this._connections.internalValue;
  }

  // content_config - computed: false, optional: true, required: false
  private _contentConfig = new PackSourceInputWizContentConfigList(this, "content_config", false);
  public get contentConfig() {
    return this._contentConfig;
  }
  public putContentConfig(value: PackSourceInputWizContentConfig[] | cdktf.IResolvable) {
    this._contentConfig.internalValue = value;
  }
  public resetContentConfig() {
    this._contentConfig.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get contentConfigInput() {
    return this._contentConfig.internalValue;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // endpoint - computed: true, optional: true, required: false
  private _endpoint?: string; 
  public get endpoint() {
    return this.getStringAttribute('endpoint');
  }
  public set endpoint(value: string) {
    this._endpoint = value;
  }
  public resetEndpoint() {
    this._endpoint = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get endpointInput() {
    return this._endpoint;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // ignore_group_jobs_limit - computed: true, optional: true, required: false
  private _ignoreGroupJobsLimit?: boolean | cdktf.IResolvable; 
  public get ignoreGroupJobsLimit() {
    return this.getBooleanAttribute('ignore_group_jobs_limit');
  }
  public set ignoreGroupJobsLimit(value: boolean | cdktf.IResolvable) {
    this._ignoreGroupJobsLimit = value;
  }
  public resetIgnoreGroupJobsLimit() {
    this._ignoreGroupJobsLimit = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ignoreGroupJobsLimitInput() {
    return this._ignoreGroupJobsLimit;
  }

  // keep_alive_time - computed: true, optional: true, required: false
  private _keepAliveTime?: number; 
  public get keepAliveTime() {
    return this.getNumberAttribute('keep_alive_time');
  }
  public set keepAliveTime(value: number) {
    this._keepAliveTime = value;
  }
  public resetKeepAliveTime() {
    this._keepAliveTime = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keepAliveTimeInput() {
    return this._keepAliveTime;
  }

  // max_missed_keep_alives - computed: true, optional: true, required: false
  private _maxMissedKeepAlives?: number; 
  public get maxMissedKeepAlives() {
    return this.getNumberAttribute('max_missed_keep_alives');
  }
  public set maxMissedKeepAlives(value: number) {
    this._maxMissedKeepAlives = value;
  }
  public resetMaxMissedKeepAlives() {
    this._maxMissedKeepAlives = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxMissedKeepAlivesInput() {
    return this._maxMissedKeepAlives;
  }

  // metadata - computed: false, optional: true, required: false
  private _metadata = new PackSourceInputWizMetadataList(this, "metadata", false);
  public get metadata() {
    return this._metadata;
  }
  public putMetadata(value: PackSourceInputWizMetadata[] | cdktf.IResolvable) {
    this._metadata.internalValue = value;
  }
  public resetMetadata() {
    this._metadata.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataInput() {
    return this._metadata.internalValue;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // pq - computed: false, optional: true, required: false
  private _pq = new PackSourceInputWizPqOutputReference(this, "pq");
  public get pq() {
    return this._pq;
  }
  public putPq(value: PackSourceInputWizPq) {
    this._pq.internalValue = value;
  }
  public resetPq() {
    this._pq.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqInput() {
    return this._pq.internalValue;
  }

  // pq_enabled - computed: true, optional: true, required: false
  private _pqEnabled?: boolean | cdktf.IResolvable; 
  public get pqEnabled() {
    return this.getBooleanAttribute('pq_enabled');
  }
  public set pqEnabled(value: boolean | cdktf.IResolvable) {
    this._pqEnabled = value;
  }
  public resetPqEnabled() {
    this._pqEnabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqEnabledInput() {
    return this._pqEnabled;
  }

  // request_timeout - computed: true, optional: true, required: false
  private _requestTimeout?: number; 
  public get requestTimeout() {
    return this.getNumberAttribute('request_timeout');
  }
  public set requestTimeout(value: number) {
    this._requestTimeout = value;
  }
  public resetRequestTimeout() {
    this._requestTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestTimeoutInput() {
    return this._requestTimeout;
  }

  // retry_rules - computed: false, optional: true, required: false
  private _retryRules = new PackSourceInputWizRetryRulesOutputReference(this, "retry_rules");
  public get retryRules() {
    return this._retryRules;
  }
  public putRetryRules(value: PackSourceInputWizRetryRules) {
    this._retryRules.internalValue = value;
  }
  public resetRetryRules() {
    this._retryRules.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get retryRulesInput() {
    return this._retryRules.internalValue;
  }

  // send_to_routes - computed: true, optional: true, required: false
  private _sendToRoutes?: boolean | cdktf.IResolvable; 
  public get sendToRoutes() {
    return this.getBooleanAttribute('send_to_routes');
  }
  public set sendToRoutes(value: boolean | cdktf.IResolvable) {
    this._sendToRoutes = value;
  }
  public resetSendToRoutes() {
    this._sendToRoutes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sendToRoutesInput() {
    return this._sendToRoutes;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // text_secret - computed: false, optional: true, required: false
  private _textSecret?: string; 
  public get textSecret() {
    return this.getStringAttribute('text_secret');
  }
  public set textSecret(value: string) {
    this._textSecret = value;
  }
  public resetTextSecret() {
    this._textSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get textSecretInput() {
    return this._textSecret;
  }

  // ttl - computed: true, optional: true, required: false
  private _ttl?: string; 
  public get ttl() {
    return this.getStringAttribute('ttl');
  }
  public set ttl(value: string) {
    this._ttl = value;
  }
  public resetTtl() {
    this._ttl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ttlInput() {
    return this._ttl;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface PackSourceInputZscalerHecAuthTokensMetadata {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#name PackSource#name}
  */
  readonly name: string;
  /**
  * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#value PackSource#value}
  */
  readonly value: string;
}

export function packSourceInputZscalerHecAuthTokensMetadataToTerraform(struct?: PackSourceInputZscalerHecAuthTokensMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function packSourceInputZscalerHecAuthTokensMetadataToHclTerraform(struct?: PackSourceInputZscalerHecAuthTokensMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputZscalerHecAuthTokensMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackSourceInputZscalerHecAuthTokensMetadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputZscalerHecAuthTokensMetadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class PackSourceInputZscalerHecAuthTokensMetadataList extends cdktf.ComplexList {
  public internalValue? : PackSourceInputZscalerHecAuthTokensMetadata[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackSourceInputZscalerHecAuthTokensMetadataOutputReference {
    return new PackSourceInputZscalerHecAuthTokensMetadataOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackSourceInputZscalerHecAuthTokens {
  /**
  * Enter the values you want to allow in the HEC event index field at the token level. Supports wildcards. To skip validation, leave blank.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#allowed_indexes_at_token PackSource#allowed_indexes_at_token}
  */
  readonly allowedIndexesAtToken?: string[];
  /**
  * Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate. Default: "manual"; must be one of ["manual", "secret"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#auth_type PackSource#auth_type}
  */
  readonly authType?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#description PackSource#description}
  */
  readonly description?: string;
  /**
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#enabled PackSource#enabled}
  */
  readonly enabled?: boolean | cdktf.IResolvable;
  /**
  * Fields to add to events referencing this token
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#metadata PackSource#metadata}
  */
  readonly metadata?: PackSourceInputZscalerHecAuthTokensMetadata[] | cdktf.IResolvable;
  /**
  * Parsed as JSON.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#token PackSource#token}
  */
  readonly token: string;
  /**
  * Parsed as JSON.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#token_secret PackSource#token_secret}
  */
  readonly tokenSecret?: string;
}

export function packSourceInputZscalerHecAuthTokensToTerraform(struct?: PackSourceInputZscalerHecAuthTokens | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    allowed_indexes_at_token: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.allowedIndexesAtToken),
    auth_type: cdktf.stringToTerraform(struct!.authType),
    description: cdktf.stringToTerraform(struct!.description),
    enabled: cdktf.booleanToTerraform(struct!.enabled),
    metadata: cdktf.listMapper(packSourceInputZscalerHecAuthTokensMetadataToTerraform, false)(struct!.metadata),
    token: cdktf.stringToTerraform(struct!.token),
    token_secret: cdktf.stringToTerraform(struct!.tokenSecret),
  }
}


export function packSourceInputZscalerHecAuthTokensToHclTerraform(struct?: PackSourceInputZscalerHecAuthTokens | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    allowed_indexes_at_token: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.allowedIndexesAtToken),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    auth_type: {
      value: cdktf.stringToHclTerraform(struct!.authType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    enabled: {
      value: cdktf.booleanToHclTerraform(struct!.enabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    metadata: {
      value: cdktf.listMapperHcl(packSourceInputZscalerHecAuthTokensMetadataToHclTerraform, false)(struct!.metadata),
      isBlock: true,
      type: "list",
      storageClassType: "PackSourceInputZscalerHecAuthTokensMetadataList",
    },
    token: {
      value: cdktf.stringToHclTerraform(struct!.token),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    token_secret: {
      value: cdktf.stringToHclTerraform(struct!.tokenSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputZscalerHecAuthTokensOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackSourceInputZscalerHecAuthTokens | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._allowedIndexesAtToken !== undefined) {
      hasAnyValues = true;
      internalValueResult.allowedIndexesAtToken = this._allowedIndexesAtToken;
    }
    if (this._authType !== undefined) {
      hasAnyValues = true;
      internalValueResult.authType = this._authType;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._enabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.enabled = this._enabled;
    }
    if (this._metadata?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadata = this._metadata?.internalValue;
    }
    if (this._token !== undefined) {
      hasAnyValues = true;
      internalValueResult.token = this._token;
    }
    if (this._tokenSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.tokenSecret = this._tokenSecret;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputZscalerHecAuthTokens | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._allowedIndexesAtToken = undefined;
      this._authType = undefined;
      this._description = undefined;
      this._enabled = undefined;
      this._metadata.internalValue = undefined;
      this._token = undefined;
      this._tokenSecret = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._allowedIndexesAtToken = value.allowedIndexesAtToken;
      this._authType = value.authType;
      this._description = value.description;
      this._enabled = value.enabled;
      this._metadata.internalValue = value.metadata;
      this._token = value.token;
      this._tokenSecret = value.tokenSecret;
    }
  }

  // allowed_indexes_at_token - computed: false, optional: true, required: false
  private _allowedIndexesAtToken?: string[]; 
  public get allowedIndexesAtToken() {
    return this.getListAttribute('allowed_indexes_at_token');
  }
  public set allowedIndexesAtToken(value: string[]) {
    this._allowedIndexesAtToken = value;
  }
  public resetAllowedIndexesAtToken() {
    this._allowedIndexesAtToken = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get allowedIndexesAtTokenInput() {
    return this._allowedIndexesAtToken;
  }

  // auth_type - computed: true, optional: true, required: false
  private _authType?: string; 
  public get authType() {
    return this.getStringAttribute('auth_type');
  }
  public set authType(value: string) {
    this._authType = value;
  }
  public resetAuthType() {
    this._authType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authTypeInput() {
    return this._authType;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // enabled - computed: true, optional: true, required: false
  private _enabled?: boolean | cdktf.IResolvable; 
  public get enabled() {
    return this.getBooleanAttribute('enabled');
  }
  public set enabled(value: boolean | cdktf.IResolvable) {
    this._enabled = value;
  }
  public resetEnabled() {
    this._enabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enabledInput() {
    return this._enabled;
  }

  // metadata - computed: false, optional: true, required: false
  private _metadata = new PackSourceInputZscalerHecAuthTokensMetadataList(this, "metadata", false);
  public get metadata() {
    return this._metadata;
  }
  public putMetadata(value: PackSourceInputZscalerHecAuthTokensMetadata[] | cdktf.IResolvable) {
    this._metadata.internalValue = value;
  }
  public resetMetadata() {
    this._metadata.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataInput() {
    return this._metadata.internalValue;
  }

  // token - computed: false, optional: false, required: true
  private _token?: string; 
  public get token() {
    return this.getStringAttribute('token');
  }
  public set token(value: string) {
    this._token = value;
  }
  // Temporarily expose input value. Use with caution.
  public get tokenInput() {
    return this._token;
  }

  // token_secret - computed: false, optional: true, required: false
  private _tokenSecret?: string; 
  public get tokenSecret() {
    return this.getStringAttribute('token_secret');
  }
  public set tokenSecret(value: string) {
    this._tokenSecret = value;
  }
  public resetTokenSecret() {
    this._tokenSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tokenSecretInput() {
    return this._tokenSecret;
  }
}

export class PackSourceInputZscalerHecAuthTokensList extends cdktf.ComplexList {
  public internalValue? : PackSourceInputZscalerHecAuthTokens[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackSourceInputZscalerHecAuthTokensOutputReference {
    return new PackSourceInputZscalerHecAuthTokensOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackSourceInputZscalerHecConnections {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#output PackSource#output}
  */
  readonly output: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pipeline PackSource#pipeline}
  */
  readonly pipeline?: string;
}

export function packSourceInputZscalerHecConnectionsToTerraform(struct?: PackSourceInputZscalerHecConnections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    output: cdktf.stringToTerraform(struct!.output),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
  }
}


export function packSourceInputZscalerHecConnectionsToHclTerraform(struct?: PackSourceInputZscalerHecConnections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    output: {
      value: cdktf.stringToHclTerraform(struct!.output),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputZscalerHecConnectionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackSourceInputZscalerHecConnections | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._output !== undefined) {
      hasAnyValues = true;
      internalValueResult.output = this._output;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputZscalerHecConnections | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._output = undefined;
      this._pipeline = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._output = value.output;
      this._pipeline = value.pipeline;
    }
  }

  // output - computed: false, optional: false, required: true
  private _output?: string; 
  public get output() {
    return this.getStringAttribute('output');
  }
  public set output(value: string) {
    this._output = value;
  }
  // Temporarily expose input value. Use with caution.
  public get outputInput() {
    return this._output;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }
}

export class PackSourceInputZscalerHecConnectionsList extends cdktf.ComplexList {
  public internalValue? : PackSourceInputZscalerHecConnections[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackSourceInputZscalerHecConnectionsOutputReference {
    return new PackSourceInputZscalerHecConnectionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackSourceInputZscalerHecMetadata {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#name PackSource#name}
  */
  readonly name: string;
  /**
  * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#value PackSource#value}
  */
  readonly value: string;
}

export function packSourceInputZscalerHecMetadataToTerraform(struct?: PackSourceInputZscalerHecMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function packSourceInputZscalerHecMetadataToHclTerraform(struct?: PackSourceInputZscalerHecMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputZscalerHecMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackSourceInputZscalerHecMetadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputZscalerHecMetadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class PackSourceInputZscalerHecMetadataList extends cdktf.ComplexList {
  public internalValue? : PackSourceInputZscalerHecMetadata[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackSourceInputZscalerHecMetadataOutputReference {
    return new PackSourceInputZscalerHecMetadataOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackSourceInputZscalerHecPq {
  /**
  * The number of events to send downstream before committing that Stream has read them. Default: 42
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#commit_frequency PackSource#commit_frequency}
  */
  readonly commitFrequency?: number;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#compress PackSource#compress}
  */
  readonly compress?: string;
  /**
  * The maximum number of events to hold in memory before writing the events to disk. Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_buffer_size PackSource#max_buffer_size}
  */
  readonly maxBufferSize?: number;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc. Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_file_size PackSource#max_file_size}
  */
  readonly maxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_size PackSource#max_size}
  */
  readonly maxSize?: string;
  /**
  * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine. Default: "always"; must be one of ["smart", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#mode PackSource#mode}
  */
  readonly mode?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#path PackSource#path}
  */
  readonly path?: string;
}

export function packSourceInputZscalerHecPqToTerraform(struct?: PackSourceInputZscalerHecPq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    commit_frequency: cdktf.numberToTerraform(struct!.commitFrequency),
    compress: cdktf.stringToTerraform(struct!.compress),
    max_buffer_size: cdktf.numberToTerraform(struct!.maxBufferSize),
    max_file_size: cdktf.stringToTerraform(struct!.maxFileSize),
    max_size: cdktf.stringToTerraform(struct!.maxSize),
    mode: cdktf.stringToTerraform(struct!.mode),
    path: cdktf.stringToTerraform(struct!.path),
  }
}


export function packSourceInputZscalerHecPqToHclTerraform(struct?: PackSourceInputZscalerHecPq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    commit_frequency: {
      value: cdktf.numberToHclTerraform(struct!.commitFrequency),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    compress: {
      value: cdktf.stringToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_buffer_size: {
      value: cdktf.numberToHclTerraform(struct!.maxBufferSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.maxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_size: {
      value: cdktf.stringToHclTerraform(struct!.maxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputZscalerHecPqOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputZscalerHecPq | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._commitFrequency !== undefined) {
      hasAnyValues = true;
      internalValueResult.commitFrequency = this._commitFrequency;
    }
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._maxBufferSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBufferSize = this._maxBufferSize;
    }
    if (this._maxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxFileSize = this._maxFileSize;
    }
    if (this._maxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxSize = this._maxSize;
    }
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputZscalerHecPq | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._commitFrequency = undefined;
      this._compress = undefined;
      this._maxBufferSize = undefined;
      this._maxFileSize = undefined;
      this._maxSize = undefined;
      this._mode = undefined;
      this._path = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._commitFrequency = value.commitFrequency;
      this._compress = value.compress;
      this._maxBufferSize = value.maxBufferSize;
      this._maxFileSize = value.maxFileSize;
      this._maxSize = value.maxSize;
      this._mode = value.mode;
      this._path = value.path;
    }
  }

  // commit_frequency - computed: true, optional: true, required: false
  private _commitFrequency?: number; 
  public get commitFrequency() {
    return this.getNumberAttribute('commit_frequency');
  }
  public set commitFrequency(value: number) {
    this._commitFrequency = value;
  }
  public resetCommitFrequency() {
    this._commitFrequency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commitFrequencyInput() {
    return this._commitFrequency;
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: string; 
  public get compress() {
    return this.getStringAttribute('compress');
  }
  public set compress(value: string) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // max_buffer_size - computed: true, optional: true, required: false
  private _maxBufferSize?: number; 
  public get maxBufferSize() {
    return this.getNumberAttribute('max_buffer_size');
  }
  public set maxBufferSize(value: number) {
    this._maxBufferSize = value;
  }
  public resetMaxBufferSize() {
    this._maxBufferSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBufferSizeInput() {
    return this._maxBufferSize;
  }

  // max_file_size - computed: true, optional: true, required: false
  private _maxFileSize?: string; 
  public get maxFileSize() {
    return this.getStringAttribute('max_file_size');
  }
  public set maxFileSize(value: string) {
    this._maxFileSize = value;
  }
  public resetMaxFileSize() {
    this._maxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxFileSizeInput() {
    return this._maxFileSize;
  }

  // max_size - computed: true, optional: true, required: false
  private _maxSize?: string; 
  public get maxSize() {
    return this.getStringAttribute('max_size');
  }
  public set maxSize(value: string) {
    this._maxSize = value;
  }
  public resetMaxSize() {
    this._maxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxSizeInput() {
    return this._maxSize;
  }

  // mode - computed: true, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // path - computed: true, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }
}
export interface PackSourceInputZscalerHecTls {
  /**
  * Path on server containing CA certificates to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#ca_path PackSource#ca_path}
  */
  readonly caPath?: string;
  /**
  * Path on server containing certificates to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#cert_path PackSource#cert_path}
  */
  readonly certPath?: string;
  /**
  * The name of the predefined certificate
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#certificate_name PackSource#certificate_name}
  */
  readonly certificateName?: string;
  /**
  * Parsed as JSON.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#common_name_regex PackSource#common_name_regex}
  */
  readonly commonNameRegex?: string;
  /**
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#disabled PackSource#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_version PackSource#max_version}
  */
  readonly maxVersion?: string;
  /**
  * must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#min_version PackSource#min_version}
  */
  readonly minVersion?: string;
  /**
  * Passphrase to use to decrypt private key
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#passphrase PackSource#passphrase}
  */
  readonly passphrase?: string;
  /**
  * Path on server containing the private key to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#priv_key_path PackSource#priv_key_path}
  */
  readonly privKeyPath?: string;
  /**
  * Parsed as JSON.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#reject_unauthorized PackSource#reject_unauthorized}
  */
  readonly rejectUnauthorized?: string;
  /**
  * Require clients to present their certificates. Used to perform client authentication using SSL certs. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#request_cert PackSource#request_cert}
  */
  readonly requestCert?: boolean | cdktf.IResolvable;
}

export function packSourceInputZscalerHecTlsToTerraform(struct?: PackSourceInputZscalerHecTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ca_path: cdktf.stringToTerraform(struct!.caPath),
    cert_path: cdktf.stringToTerraform(struct!.certPath),
    certificate_name: cdktf.stringToTerraform(struct!.certificateName),
    common_name_regex: cdktf.stringToTerraform(struct!.commonNameRegex),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    max_version: cdktf.stringToTerraform(struct!.maxVersion),
    min_version: cdktf.stringToTerraform(struct!.minVersion),
    passphrase: cdktf.stringToTerraform(struct!.passphrase),
    priv_key_path: cdktf.stringToTerraform(struct!.privKeyPath),
    reject_unauthorized: cdktf.stringToTerraform(struct!.rejectUnauthorized),
    request_cert: cdktf.booleanToTerraform(struct!.requestCert),
  }
}


export function packSourceInputZscalerHecTlsToHclTerraform(struct?: PackSourceInputZscalerHecTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ca_path: {
      value: cdktf.stringToHclTerraform(struct!.caPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    cert_path: {
      value: cdktf.stringToHclTerraform(struct!.certPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    certificate_name: {
      value: cdktf.stringToHclTerraform(struct!.certificateName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    common_name_regex: {
      value: cdktf.stringToHclTerraform(struct!.commonNameRegex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    max_version: {
      value: cdktf.stringToHclTerraform(struct!.maxVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    min_version: {
      value: cdktf.stringToHclTerraform(struct!.minVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    passphrase: {
      value: cdktf.stringToHclTerraform(struct!.passphrase),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    priv_key_path: {
      value: cdktf.stringToHclTerraform(struct!.privKeyPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reject_unauthorized: {
      value: cdktf.stringToHclTerraform(struct!.rejectUnauthorized),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    request_cert: {
      value: cdktf.booleanToHclTerraform(struct!.requestCert),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputZscalerHecTlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputZscalerHecTls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._caPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.caPath = this._caPath;
    }
    if (this._certPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.certPath = this._certPath;
    }
    if (this._certificateName !== undefined) {
      hasAnyValues = true;
      internalValueResult.certificateName = this._certificateName;
    }
    if (this._commonNameRegex !== undefined) {
      hasAnyValues = true;
      internalValueResult.commonNameRegex = this._commonNameRegex;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._maxVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxVersion = this._maxVersion;
    }
    if (this._minVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.minVersion = this._minVersion;
    }
    if (this._passphrase !== undefined) {
      hasAnyValues = true;
      internalValueResult.passphrase = this._passphrase;
    }
    if (this._privKeyPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.privKeyPath = this._privKeyPath;
    }
    if (this._rejectUnauthorized !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectUnauthorized = this._rejectUnauthorized;
    }
    if (this._requestCert !== undefined) {
      hasAnyValues = true;
      internalValueResult.requestCert = this._requestCert;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputZscalerHecTls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._caPath = undefined;
      this._certPath = undefined;
      this._certificateName = undefined;
      this._commonNameRegex = undefined;
      this._disabled = undefined;
      this._maxVersion = undefined;
      this._minVersion = undefined;
      this._passphrase = undefined;
      this._privKeyPath = undefined;
      this._rejectUnauthorized = undefined;
      this._requestCert = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._caPath = value.caPath;
      this._certPath = value.certPath;
      this._certificateName = value.certificateName;
      this._commonNameRegex = value.commonNameRegex;
      this._disabled = value.disabled;
      this._maxVersion = value.maxVersion;
      this._minVersion = value.minVersion;
      this._passphrase = value.passphrase;
      this._privKeyPath = value.privKeyPath;
      this._rejectUnauthorized = value.rejectUnauthorized;
      this._requestCert = value.requestCert;
    }
  }

  // ca_path - computed: false, optional: true, required: false
  private _caPath?: string; 
  public get caPath() {
    return this.getStringAttribute('ca_path');
  }
  public set caPath(value: string) {
    this._caPath = value;
  }
  public resetCaPath() {
    this._caPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get caPathInput() {
    return this._caPath;
  }

  // cert_path - computed: false, optional: true, required: false
  private _certPath?: string; 
  public get certPath() {
    return this.getStringAttribute('cert_path');
  }
  public set certPath(value: string) {
    this._certPath = value;
  }
  public resetCertPath() {
    this._certPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certPathInput() {
    return this._certPath;
  }

  // certificate_name - computed: false, optional: true, required: false
  private _certificateName?: string; 
  public get certificateName() {
    return this.getStringAttribute('certificate_name');
  }
  public set certificateName(value: string) {
    this._certificateName = value;
  }
  public resetCertificateName() {
    this._certificateName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certificateNameInput() {
    return this._certificateName;
  }

  // common_name_regex - computed: false, optional: true, required: false
  private _commonNameRegex?: string; 
  public get commonNameRegex() {
    return this.getStringAttribute('common_name_regex');
  }
  public set commonNameRegex(value: string) {
    this._commonNameRegex = value;
  }
  public resetCommonNameRegex() {
    this._commonNameRegex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commonNameRegexInput() {
    return this._commonNameRegex;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // max_version - computed: false, optional: true, required: false
  private _maxVersion?: string; 
  public get maxVersion() {
    return this.getStringAttribute('max_version');
  }
  public set maxVersion(value: string) {
    this._maxVersion = value;
  }
  public resetMaxVersion() {
    this._maxVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxVersionInput() {
    return this._maxVersion;
  }

  // min_version - computed: false, optional: true, required: false
  private _minVersion?: string; 
  public get minVersion() {
    return this.getStringAttribute('min_version');
  }
  public set minVersion(value: string) {
    this._minVersion = value;
  }
  public resetMinVersion() {
    this._minVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get minVersionInput() {
    return this._minVersion;
  }

  // passphrase - computed: false, optional: true, required: false
  private _passphrase?: string; 
  public get passphrase() {
    return this.getStringAttribute('passphrase');
  }
  public set passphrase(value: string) {
    this._passphrase = value;
  }
  public resetPassphrase() {
    this._passphrase = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passphraseInput() {
    return this._passphrase;
  }

  // priv_key_path - computed: false, optional: true, required: false
  private _privKeyPath?: string; 
  public get privKeyPath() {
    return this.getStringAttribute('priv_key_path');
  }
  public set privKeyPath(value: string) {
    this._privKeyPath = value;
  }
  public resetPrivKeyPath() {
    this._privKeyPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get privKeyPathInput() {
    return this._privKeyPath;
  }

  // reject_unauthorized - computed: false, optional: true, required: false
  private _rejectUnauthorized?: string; 
  public get rejectUnauthorized() {
    return this.getStringAttribute('reject_unauthorized');
  }
  public set rejectUnauthorized(value: string) {
    this._rejectUnauthorized = value;
  }
  public resetRejectUnauthorized() {
    this._rejectUnauthorized = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectUnauthorizedInput() {
    return this._rejectUnauthorized;
  }

  // request_cert - computed: true, optional: true, required: false
  private _requestCert?: boolean | cdktf.IResolvable; 
  public get requestCert() {
    return this.getBooleanAttribute('request_cert');
  }
  public set requestCert(value: boolean | cdktf.IResolvable) {
    this._requestCert = value;
  }
  public resetRequestCert() {
    this._requestCert = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestCertInput() {
    return this._requestCert;
  }
}
export interface PackSourceInputZscalerHec {
  /**
  * Optionally, list HTTP headers that @{product} will send to allowed origins as "Access-Control-Allow-Headers" in a CORS preflight response. Use "*" to allow all headers.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#access_control_allow_headers PackSource#access_control_allow_headers}
  */
  readonly accessControlAllowHeaders?: string[];
  /**
  * Optionally, list HTTP origins to which @{product} should send CORS (cross-origin resource sharing) Access-Control-Allow-* headers. Supports wildcards.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#access_control_allow_origin PackSource#access_control_allow_origin}
  */
  readonly accessControlAllowOrigin?: string[];
  /**
  * How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc. Default: 100
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#activity_log_sample_rate PackSource#activity_log_sample_rate}
  */
  readonly activityLogSampleRate?: number;
  /**
  * List values allowed in HEC event index field. Leave blank to skip validation. Supports wildcards. The values here can expand index validation at the token level.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#allowed_indexes PackSource#allowed_indexes}
  */
  readonly allowedIndexes?: string[];
  /**
  * Shared secrets to be provided by any client (Authorization: <token>). If empty, unauthorized access is permitted.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#auth_tokens PackSource#auth_tokens}
  */
  readonly authTokens?: PackSourceInputZscalerHecAuthTokens[] | cdktf.IResolvable;
  /**
  * Add request headers to events, in the __headers field. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#capture_headers PackSource#capture_headers}
  */
  readonly captureHeaders?: boolean | cdktf.IResolvable;
  /**
  * Direct connections to Destinations, and optionally via a Pipeline or a Pack
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#connections PackSource#connections}
  */
  readonly connections?: PackSourceInputZscalerHecConnections[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#description PackSource#description}
  */
  readonly description?: string;
  /**
  * Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#disabled PackSource#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * Enable to emit per-token (<prefix>.http.perToken) and summary (<prefix>.http.summary) request metrics. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#emit_token_metrics PackSource#emit_token_metrics}
  */
  readonly emitTokenMetrics?: boolean | cdktf.IResolvable;
  /**
  * Parsed as JSON.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#enable_health_check PackSource#enable_health_check}
  */
  readonly enableHealthCheck?: string;
  /**
  * Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#enable_proxy_header PackSource#enable_proxy_header}
  */
  readonly enableProxyHeader?: boolean | cdktf.IResolvable;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#environment PackSource#environment}
  */
  readonly environment?: string;
  /**
  * Whether to enable Zscaler HEC acknowledgements. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#hec_acks PackSource#hec_acks}
  */
  readonly hecAcks?: boolean | cdktf.IResolvable;
  /**
  * Absolute path on which to listen for the Zscaler HTTP Event Collector API requests. This input supports the /event endpoint. Default: "/services/collector"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#hec_api PackSource#hec_api}
  */
  readonly hecApi?: string;
  /**
  * Address to bind on. Defaults to 0.0.0.0 (all addresses). Default: "0.0.0.0"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#host PackSource#host}
  */
  readonly host?: string;
  /**
  * Unique ID for this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#id PackSource#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * Messages from matched IP addresses will be processed, unless also matched by the denylist. Default: "/.* /"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#ip_allowlist_regex PackSource#ip_allowlist_regex}
   *
  * Note: The above comment contained a comment block ending sequence (* followed by /). We have introduced a space between to prevent syntax errors. Please ignore the space.
  */
  readonly ipAllowlistRegex?: string;
  /**
  * Messages from matched IP addresses will be ignored. This takes precedence over the allowlist. Default: "/^$/"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#ip_denylist_regex PackSource#ip_denylist_regex}
  */
  readonly ipDenylistRegex?: string;
  /**
  * After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes). Default: 5
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#keep_alive_timeout PackSource#keep_alive_timeout}
  */
  readonly keepAliveTimeout?: number;
  /**
  * Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput. Default: 256
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_active_req PackSource#max_active_req}
  */
  readonly maxActiveReq?: number;
  /**
  * Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited). Default: 0
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#max_requests_per_socket PackSource#max_requests_per_socket}
  */
  readonly maxRequestsPerSocket?: number;
  /**
  * Fields to add to every event. May be overridden by fields added at the token or request level.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#metadata PackSource#metadata}
  */
  readonly metadata?: PackSourceInputZscalerHecMetadata[] | cdktf.IResolvable;
  /**
  * Pipeline to process data from this Source before sending it through the Routes
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pipeline PackSource#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Port to listen on
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#port PackSource#port}
  */
  readonly port: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pq PackSource#pq}
  */
  readonly pq?: PackSourceInputZscalerHecPq;
  /**
  * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers). Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#pq_enabled PackSource#pq_enabled}
  */
  readonly pqEnabled?: boolean | cdktf.IResolvable;
  /**
  * How long to wait for an incoming request to complete before aborting it. Use 0 to disable. Default: 0
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#request_timeout PackSource#request_timeout}
  */
  readonly requestTimeout?: number;
  /**
  * Select whether to send data to Routes, or directly to Destinations. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#send_to_routes PackSource#send_to_routes}
  */
  readonly sendToRoutes?: boolean | cdktf.IResolvable;
  /**
  * How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0. Default: 0
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#socket_timeout PackSource#socket_timeout}
  */
  readonly socketTimeout?: number;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#streamtags PackSource#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#tls PackSource#tls}
  */
  readonly tls?: PackSourceInputZscalerHecTls;
  /**
  * must be "zscaler_hec"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_source#type PackSource#type}
  */
  readonly type?: string;
}

export function packSourceInputZscalerHecToTerraform(struct?: PackSourceInputZscalerHec | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    access_control_allow_headers: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.accessControlAllowHeaders),
    access_control_allow_origin: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.accessControlAllowOrigin),
    activity_log_sample_rate: cdktf.numberToTerraform(struct!.activityLogSampleRate),
    allowed_indexes: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.allowedIndexes),
    auth_tokens: cdktf.listMapper(packSourceInputZscalerHecAuthTokensToTerraform, false)(struct!.authTokens),
    capture_headers: cdktf.booleanToTerraform(struct!.captureHeaders),
    connections: cdktf.listMapper(packSourceInputZscalerHecConnectionsToTerraform, false)(struct!.connections),
    description: cdktf.stringToTerraform(struct!.description),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    emit_token_metrics: cdktf.booleanToTerraform(struct!.emitTokenMetrics),
    enable_health_check: cdktf.stringToTerraform(struct!.enableHealthCheck),
    enable_proxy_header: cdktf.booleanToTerraform(struct!.enableProxyHeader),
    environment: cdktf.stringToTerraform(struct!.environment),
    hec_acks: cdktf.booleanToTerraform(struct!.hecAcks),
    hec_api: cdktf.stringToTerraform(struct!.hecApi),
    host: cdktf.stringToTerraform(struct!.host),
    id: cdktf.stringToTerraform(struct!.id),
    ip_allowlist_regex: cdktf.stringToTerraform(struct!.ipAllowlistRegex),
    ip_denylist_regex: cdktf.stringToTerraform(struct!.ipDenylistRegex),
    keep_alive_timeout: cdktf.numberToTerraform(struct!.keepAliveTimeout),
    max_active_req: cdktf.numberToTerraform(struct!.maxActiveReq),
    max_requests_per_socket: cdktf.numberToTerraform(struct!.maxRequestsPerSocket),
    metadata: cdktf.listMapper(packSourceInputZscalerHecMetadataToTerraform, false)(struct!.metadata),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    port: cdktf.numberToTerraform(struct!.port),
    pq: packSourceInputZscalerHecPqToTerraform(struct!.pq),
    pq_enabled: cdktf.booleanToTerraform(struct!.pqEnabled),
    request_timeout: cdktf.numberToTerraform(struct!.requestTimeout),
    send_to_routes: cdktf.booleanToTerraform(struct!.sendToRoutes),
    socket_timeout: cdktf.numberToTerraform(struct!.socketTimeout),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    tls: packSourceInputZscalerHecTlsToTerraform(struct!.tls),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function packSourceInputZscalerHecToHclTerraform(struct?: PackSourceInputZscalerHec | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    access_control_allow_headers: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.accessControlAllowHeaders),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    access_control_allow_origin: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.accessControlAllowOrigin),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    activity_log_sample_rate: {
      value: cdktf.numberToHclTerraform(struct!.activityLogSampleRate),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    allowed_indexes: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.allowedIndexes),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    auth_tokens: {
      value: cdktf.listMapperHcl(packSourceInputZscalerHecAuthTokensToHclTerraform, false)(struct!.authTokens),
      isBlock: true,
      type: "list",
      storageClassType: "PackSourceInputZscalerHecAuthTokensList",
    },
    capture_headers: {
      value: cdktf.booleanToHclTerraform(struct!.captureHeaders),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    connections: {
      value: cdktf.listMapperHcl(packSourceInputZscalerHecConnectionsToHclTerraform, false)(struct!.connections),
      isBlock: true,
      type: "list",
      storageClassType: "PackSourceInputZscalerHecConnectionsList",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    emit_token_metrics: {
      value: cdktf.booleanToHclTerraform(struct!.emitTokenMetrics),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    enable_health_check: {
      value: cdktf.stringToHclTerraform(struct!.enableHealthCheck),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    enable_proxy_header: {
      value: cdktf.booleanToHclTerraform(struct!.enableProxyHeader),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    hec_acks: {
      value: cdktf.booleanToHclTerraform(struct!.hecAcks),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    hec_api: {
      value: cdktf.stringToHclTerraform(struct!.hecApi),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    host: {
      value: cdktf.stringToHclTerraform(struct!.host),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ip_allowlist_regex: {
      value: cdktf.stringToHclTerraform(struct!.ipAllowlistRegex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ip_denylist_regex: {
      value: cdktf.stringToHclTerraform(struct!.ipDenylistRegex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    keep_alive_timeout: {
      value: cdktf.numberToHclTerraform(struct!.keepAliveTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_active_req: {
      value: cdktf.numberToHclTerraform(struct!.maxActiveReq),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_requests_per_socket: {
      value: cdktf.numberToHclTerraform(struct!.maxRequestsPerSocket),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    metadata: {
      value: cdktf.listMapperHcl(packSourceInputZscalerHecMetadataToHclTerraform, false)(struct!.metadata),
      isBlock: true,
      type: "list",
      storageClassType: "PackSourceInputZscalerHecMetadataList",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    pq: {
      value: packSourceInputZscalerHecPqToHclTerraform(struct!.pq),
      isBlock: true,
      type: "struct",
      storageClassType: "PackSourceInputZscalerHecPq",
    },
    pq_enabled: {
      value: cdktf.booleanToHclTerraform(struct!.pqEnabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    request_timeout: {
      value: cdktf.numberToHclTerraform(struct!.requestTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    send_to_routes: {
      value: cdktf.booleanToHclTerraform(struct!.sendToRoutes),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    socket_timeout: {
      value: cdktf.numberToHclTerraform(struct!.socketTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    tls: {
      value: packSourceInputZscalerHecTlsToHclTerraform(struct!.tls),
      isBlock: true,
      type: "struct",
      storageClassType: "PackSourceInputZscalerHecTls",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackSourceInputZscalerHecOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceInputZscalerHec | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._accessControlAllowHeaders !== undefined) {
      hasAnyValues = true;
      internalValueResult.accessControlAllowHeaders = this._accessControlAllowHeaders;
    }
    if (this._accessControlAllowOrigin !== undefined) {
      hasAnyValues = true;
      internalValueResult.accessControlAllowOrigin = this._accessControlAllowOrigin;
    }
    if (this._activityLogSampleRate !== undefined) {
      hasAnyValues = true;
      internalValueResult.activityLogSampleRate = this._activityLogSampleRate;
    }
    if (this._allowedIndexes !== undefined) {
      hasAnyValues = true;
      internalValueResult.allowedIndexes = this._allowedIndexes;
    }
    if (this._authTokens?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.authTokens = this._authTokens?.internalValue;
    }
    if (this._captureHeaders !== undefined) {
      hasAnyValues = true;
      internalValueResult.captureHeaders = this._captureHeaders;
    }
    if (this._connections?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.connections = this._connections?.internalValue;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._emitTokenMetrics !== undefined) {
      hasAnyValues = true;
      internalValueResult.emitTokenMetrics = this._emitTokenMetrics;
    }
    if (this._enableHealthCheck !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableHealthCheck = this._enableHealthCheck;
    }
    if (this._enableProxyHeader !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableProxyHeader = this._enableProxyHeader;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._hecAcks !== undefined) {
      hasAnyValues = true;
      internalValueResult.hecAcks = this._hecAcks;
    }
    if (this._hecApi !== undefined) {
      hasAnyValues = true;
      internalValueResult.hecApi = this._hecApi;
    }
    if (this._host !== undefined) {
      hasAnyValues = true;
      internalValueResult.host = this._host;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._ipAllowlistRegex !== undefined) {
      hasAnyValues = true;
      internalValueResult.ipAllowlistRegex = this._ipAllowlistRegex;
    }
    if (this._ipDenylistRegex !== undefined) {
      hasAnyValues = true;
      internalValueResult.ipDenylistRegex = this._ipDenylistRegex;
    }
    if (this._keepAliveTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.keepAliveTimeout = this._keepAliveTimeout;
    }
    if (this._maxActiveReq !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxActiveReq = this._maxActiveReq;
    }
    if (this._maxRequestsPerSocket !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxRequestsPerSocket = this._maxRequestsPerSocket;
    }
    if (this._metadata?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadata = this._metadata?.internalValue;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._pq?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pq = this._pq?.internalValue;
    }
    if (this._pqEnabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqEnabled = this._pqEnabled;
    }
    if (this._requestTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.requestTimeout = this._requestTimeout;
    }
    if (this._sendToRoutes !== undefined) {
      hasAnyValues = true;
      internalValueResult.sendToRoutes = this._sendToRoutes;
    }
    if (this._socketTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.socketTimeout = this._socketTimeout;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._tls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tls = this._tls?.internalValue;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceInputZscalerHec | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._accessControlAllowHeaders = undefined;
      this._accessControlAllowOrigin = undefined;
      this._activityLogSampleRate = undefined;
      this._allowedIndexes = undefined;
      this._authTokens.internalValue = undefined;
      this._captureHeaders = undefined;
      this._connections.internalValue = undefined;
      this._description = undefined;
      this._disabled = undefined;
      this._emitTokenMetrics = undefined;
      this._enableHealthCheck = undefined;
      this._enableProxyHeader = undefined;
      this._environment = undefined;
      this._hecAcks = undefined;
      this._hecApi = undefined;
      this._host = undefined;
      this._id = undefined;
      this._ipAllowlistRegex = undefined;
      this._ipDenylistRegex = undefined;
      this._keepAliveTimeout = undefined;
      this._maxActiveReq = undefined;
      this._maxRequestsPerSocket = undefined;
      this._metadata.internalValue = undefined;
      this._pipeline = undefined;
      this._port = undefined;
      this._pq.internalValue = undefined;
      this._pqEnabled = undefined;
      this._requestTimeout = undefined;
      this._sendToRoutes = undefined;
      this._socketTimeout = undefined;
      this._streamtags = undefined;
      this._tls.internalValue = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._accessControlAllowHeaders = value.accessControlAllowHeaders;
      this._accessControlAllowOrigin = value.accessControlAllowOrigin;
      this._activityLogSampleRate = value.activityLogSampleRate;
      this._allowedIndexes = value.allowedIndexes;
      this._authTokens.internalValue = value.authTokens;
      this._captureHeaders = value.captureHeaders;
      this._connections.internalValue = value.connections;
      this._description = value.description;
      this._disabled = value.disabled;
      this._emitTokenMetrics = value.emitTokenMetrics;
      this._enableHealthCheck = value.enableHealthCheck;
      this._enableProxyHeader = value.enableProxyHeader;
      this._environment = value.environment;
      this._hecAcks = value.hecAcks;
      this._hecApi = value.hecApi;
      this._host = value.host;
      this._id = value.id;
      this._ipAllowlistRegex = value.ipAllowlistRegex;
      this._ipDenylistRegex = value.ipDenylistRegex;
      this._keepAliveTimeout = value.keepAliveTimeout;
      this._maxActiveReq = value.maxActiveReq;
      this._maxRequestsPerSocket = value.maxRequestsPerSocket;
      this._metadata.internalValue = value.metadata;
      this._pipeline = value.pipeline;
      this._port = value.port;
      this._pq.internalValue = value.pq;
      this._pqEnabled = value.pqEnabled;
      this._requestTimeout = value.requestTimeout;
      this._sendToRoutes = value.sendToRoutes;
      this._socketTimeout = value.socketTimeout;
      this._streamtags = value.streamtags;
      this._tls.internalValue = value.tls;
      this._type = value.type;
    }
  }

  // access_control_allow_headers - computed: false, optional: true, required: false
  private _accessControlAllowHeaders?: string[]; 
  public get accessControlAllowHeaders() {
    return this.getListAttribute('access_control_allow_headers');
  }
  public set accessControlAllowHeaders(value: string[]) {
    this._accessControlAllowHeaders = value;
  }
  public resetAccessControlAllowHeaders() {
    this._accessControlAllowHeaders = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get accessControlAllowHeadersInput() {
    return this._accessControlAllowHeaders;
  }

  // access_control_allow_origin - computed: false, optional: true, required: false
  private _accessControlAllowOrigin?: string[]; 
  public get accessControlAllowOrigin() {
    return this.getListAttribute('access_control_allow_origin');
  }
  public set accessControlAllowOrigin(value: string[]) {
    this._accessControlAllowOrigin = value;
  }
  public resetAccessControlAllowOrigin() {
    this._accessControlAllowOrigin = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get accessControlAllowOriginInput() {
    return this._accessControlAllowOrigin;
  }

  // activity_log_sample_rate - computed: true, optional: true, required: false
  private _activityLogSampleRate?: number; 
  public get activityLogSampleRate() {
    return this.getNumberAttribute('activity_log_sample_rate');
  }
  public set activityLogSampleRate(value: number) {
    this._activityLogSampleRate = value;
  }
  public resetActivityLogSampleRate() {
    this._activityLogSampleRate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get activityLogSampleRateInput() {
    return this._activityLogSampleRate;
  }

  // allowed_indexes - computed: false, optional: true, required: false
  private _allowedIndexes?: string[]; 
  public get allowedIndexes() {
    return this.getListAttribute('allowed_indexes');
  }
  public set allowedIndexes(value: string[]) {
    this._allowedIndexes = value;
  }
  public resetAllowedIndexes() {
    this._allowedIndexes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get allowedIndexesInput() {
    return this._allowedIndexes;
  }

  // auth_tokens - computed: false, optional: true, required: false
  private _authTokens = new PackSourceInputZscalerHecAuthTokensList(this, "auth_tokens", false);
  public get authTokens() {
    return this._authTokens;
  }
  public putAuthTokens(value: PackSourceInputZscalerHecAuthTokens[] | cdktf.IResolvable) {
    this._authTokens.internalValue = value;
  }
  public resetAuthTokens() {
    this._authTokens.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authTokensInput() {
    return this._authTokens.internalValue;
  }

  // capture_headers - computed: true, optional: true, required: false
  private _captureHeaders?: boolean | cdktf.IResolvable; 
  public get captureHeaders() {
    return this.getBooleanAttribute('capture_headers');
  }
  public set captureHeaders(value: boolean | cdktf.IResolvable) {
    this._captureHeaders = value;
  }
  public resetCaptureHeaders() {
    this._captureHeaders = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get captureHeadersInput() {
    return this._captureHeaders;
  }

  // connections - computed: false, optional: true, required: false
  private _connections = new PackSourceInputZscalerHecConnectionsList(this, "connections", false);
  public get connections() {
    return this._connections;
  }
  public putConnections(value: PackSourceInputZscalerHecConnections[] | cdktf.IResolvable) {
    this._connections.internalValue = value;
  }
  public resetConnections() {
    this._connections.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectionsInput() {
    return this._connections.internalValue;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // emit_token_metrics - computed: true, optional: true, required: false
  private _emitTokenMetrics?: boolean | cdktf.IResolvable; 
  public get emitTokenMetrics() {
    return this.getBooleanAttribute('emit_token_metrics');
  }
  public set emitTokenMetrics(value: boolean | cdktf.IResolvable) {
    this._emitTokenMetrics = value;
  }
  public resetEmitTokenMetrics() {
    this._emitTokenMetrics = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get emitTokenMetricsInput() {
    return this._emitTokenMetrics;
  }

  // enable_health_check - computed: false, optional: true, required: false
  private _enableHealthCheck?: string; 
  public get enableHealthCheck() {
    return this.getStringAttribute('enable_health_check');
  }
  public set enableHealthCheck(value: string) {
    this._enableHealthCheck = value;
  }
  public resetEnableHealthCheck() {
    this._enableHealthCheck = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableHealthCheckInput() {
    return this._enableHealthCheck;
  }

  // enable_proxy_header - computed: true, optional: true, required: false
  private _enableProxyHeader?: boolean | cdktf.IResolvable; 
  public get enableProxyHeader() {
    return this.getBooleanAttribute('enable_proxy_header');
  }
  public set enableProxyHeader(value: boolean | cdktf.IResolvable) {
    this._enableProxyHeader = value;
  }
  public resetEnableProxyHeader() {
    this._enableProxyHeader = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableProxyHeaderInput() {
    return this._enableProxyHeader;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // hec_acks - computed: true, optional: true, required: false
  private _hecAcks?: boolean | cdktf.IResolvable; 
  public get hecAcks() {
    return this.getBooleanAttribute('hec_acks');
  }
  public set hecAcks(value: boolean | cdktf.IResolvable) {
    this._hecAcks = value;
  }
  public resetHecAcks() {
    this._hecAcks = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hecAcksInput() {
    return this._hecAcks;
  }

  // hec_api - computed: true, optional: true, required: false
  private _hecApi?: string; 
  public get hecApi() {
    return this.getStringAttribute('hec_api');
  }
  public set hecApi(value: string) {
    this._hecApi = value;
  }
  public resetHecApi() {
    this._hecApi = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hecApiInput() {
    return this._hecApi;
  }

  // host - computed: true, optional: true, required: false
  private _host?: string; 
  public get host() {
    return this.getStringAttribute('host');
  }
  public set host(value: string) {
    this._host = value;
  }
  public resetHost() {
    this._host = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostInput() {
    return this._host;
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // ip_allowlist_regex - computed: true, optional: true, required: false
  private _ipAllowlistRegex?: string; 
  public get ipAllowlistRegex() {
    return this.getStringAttribute('ip_allowlist_regex');
  }
  public set ipAllowlistRegex(value: string) {
    this._ipAllowlistRegex = value;
  }
  public resetIpAllowlistRegex() {
    this._ipAllowlistRegex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ipAllowlistRegexInput() {
    return this._ipAllowlistRegex;
  }

  // ip_denylist_regex - computed: true, optional: true, required: false
  private _ipDenylistRegex?: string; 
  public get ipDenylistRegex() {
    return this.getStringAttribute('ip_denylist_regex');
  }
  public set ipDenylistRegex(value: string) {
    this._ipDenylistRegex = value;
  }
  public resetIpDenylistRegex() {
    this._ipDenylistRegex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ipDenylistRegexInput() {
    return this._ipDenylistRegex;
  }

  // keep_alive_timeout - computed: true, optional: true, required: false
  private _keepAliveTimeout?: number; 
  public get keepAliveTimeout() {
    return this.getNumberAttribute('keep_alive_timeout');
  }
  public set keepAliveTimeout(value: number) {
    this._keepAliveTimeout = value;
  }
  public resetKeepAliveTimeout() {
    this._keepAliveTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keepAliveTimeoutInput() {
    return this._keepAliveTimeout;
  }

  // max_active_req - computed: true, optional: true, required: false
  private _maxActiveReq?: number; 
  public get maxActiveReq() {
    return this.getNumberAttribute('max_active_req');
  }
  public set maxActiveReq(value: number) {
    this._maxActiveReq = value;
  }
  public resetMaxActiveReq() {
    this._maxActiveReq = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxActiveReqInput() {
    return this._maxActiveReq;
  }

  // max_requests_per_socket - computed: true, optional: true, required: false
  private _maxRequestsPerSocket?: number; 
  public get maxRequestsPerSocket() {
    return this.getNumberAttribute('max_requests_per_socket');
  }
  public set maxRequestsPerSocket(value: number) {
    this._maxRequestsPerSocket = value;
  }
  public resetMaxRequestsPerSocket() {
    this._maxRequestsPerSocket = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxRequestsPerSocketInput() {
    return this._maxRequestsPerSocket;
  }

  // metadata - computed: false, optional: true, required: false
  private _metadata = new PackSourceInputZscalerHecMetadataList(this, "metadata", false);
  public get metadata() {
    return this._metadata;
  }
  public putMetadata(value: PackSourceInputZscalerHecMetadata[] | cdktf.IResolvable) {
    this._metadata.internalValue = value;
  }
  public resetMetadata() {
    this._metadata.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataInput() {
    return this._metadata.internalValue;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // port - computed: false, optional: false, required: true
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // pq - computed: false, optional: true, required: false
  private _pq = new PackSourceInputZscalerHecPqOutputReference(this, "pq");
  public get pq() {
    return this._pq;
  }
  public putPq(value: PackSourceInputZscalerHecPq) {
    this._pq.internalValue = value;
  }
  public resetPq() {
    this._pq.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqInput() {
    return this._pq.internalValue;
  }

  // pq_enabled - computed: true, optional: true, required: false
  private _pqEnabled?: boolean | cdktf.IResolvable; 
  public get pqEnabled() {
    return this.getBooleanAttribute('pq_enabled');
  }
  public set pqEnabled(value: boolean | cdktf.IResolvable) {
    this._pqEnabled = value;
  }
  public resetPqEnabled() {
    this._pqEnabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqEnabledInput() {
    return this._pqEnabled;
  }

  // request_timeout - computed: true, optional: true, required: false
  private _requestTimeout?: number; 
  public get requestTimeout() {
    return this.getNumberAttribute('request_timeout');
  }
  public set requestTimeout(value: number) {
    this._requestTimeout = value;
  }
  public resetRequestTimeout() {
    this._requestTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestTimeoutInput() {
    return this._requestTimeout;
  }

  // send_to_routes - computed: true, optional: true, required: false
  private _sendToRoutes?: boolean | cdktf.IResolvable; 
  public get sendToRoutes() {
    return this.getBooleanAttribute('send_to_routes');
  }
  public set sendToRoutes(value: boolean | cdktf.IResolvable) {
    this._sendToRoutes = value;
  }
  public resetSendToRoutes() {
    this._sendToRoutes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sendToRoutesInput() {
    return this._sendToRoutes;
  }

  // socket_timeout - computed: true, optional: true, required: false
  private _socketTimeout?: number; 
  public get socketTimeout() {
    return this.getNumberAttribute('socket_timeout');
  }
  public set socketTimeout(value: number) {
    this._socketTimeout = value;
  }
  public resetSocketTimeout() {
    this._socketTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get socketTimeoutInput() {
    return this._socketTimeout;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // tls - computed: false, optional: true, required: false
  private _tls = new PackSourceInputZscalerHecTlsOutputReference(this, "tls");
  public get tls() {
    return this._tls;
  }
  public putTls(value: PackSourceInputZscalerHecTls) {
    this._tls.internalValue = value;
  }
  public resetTls() {
    this._tls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsInput() {
    return this._tls.internalValue;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface PackSourceItemsComments {
}

export function packSourceItemsCommentsToTerraform(struct?: PackSourceItemsComments): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function packSourceItemsCommentsToHclTerraform(struct?: PackSourceItemsComments): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class PackSourceItemsCommentsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackSourceItemsComments | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceItemsComments | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
    }
  }

  // additional_properties - computed: true, optional: false, required: false
  public get additionalProperties() {
    return this.getStringAttribute('additional_properties');
  }

  // comment - computed: true, optional: false, required: false
  public get comment() {
    return this.getStringAttribute('comment');
  }
}

export class PackSourceItemsCommentsList extends cdktf.ComplexList {

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackSourceItemsCommentsOutputReference {
    return new PackSourceItemsCommentsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackSourceItemsConfFunctions {
}

export function packSourceItemsConfFunctionsToTerraform(struct?: PackSourceItemsConfFunctions): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function packSourceItemsConfFunctionsToHclTerraform(struct?: PackSourceItemsConfFunctions): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class PackSourceItemsConfFunctionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackSourceItemsConfFunctions | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceItemsConfFunctions | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
    }
  }

  // conf - computed: true, optional: false, required: false
  private _conf = new cdktf.StringMap(this, "conf");
  public get conf() {
    return this._conf;
  }

  // description - computed: true, optional: false, required: false
  public get description() {
    return this.getStringAttribute('description');
  }

  // disabled - computed: true, optional: false, required: false
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }

  // filter - computed: true, optional: false, required: false
  public get filter() {
    return this.getStringAttribute('filter');
  }

  // final - computed: true, optional: false, required: false
  public get final() {
    return this.getBooleanAttribute('final');
  }

  // group_id - computed: true, optional: false, required: false
  public get groupId() {
    return this.getStringAttribute('group_id');
  }

  // id - computed: true, optional: false, required: false
  public get id() {
    return this.getStringAttribute('id');
  }
}

export class PackSourceItemsConfFunctionsList extends cdktf.ComplexList {

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackSourceItemsConfFunctionsOutputReference {
    return new PackSourceItemsConfFunctionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackSourceItemsConfGroups {
}

export function packSourceItemsConfGroupsToTerraform(struct?: PackSourceItemsConfGroups): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function packSourceItemsConfGroupsToHclTerraform(struct?: PackSourceItemsConfGroups): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class PackSourceItemsConfGroupsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectKey the key of this item in the map
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectKey: string) {
    super(terraformResource, terraformAttribute, false, complexObjectKey);
  }

  public get internalValue(): PackSourceItemsConfGroups | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceItemsConfGroups | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
    }
  }

  // description - computed: true, optional: false, required: false
  public get description() {
    return this.getStringAttribute('description');
  }

  // disabled - computed: true, optional: false, required: false
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }

  // name - computed: true, optional: false, required: false
  public get name() {
    return this.getStringAttribute('name');
  }
}

export class PackSourceItemsConfGroupsMap extends cdktf.ComplexMap {

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string) {
    super(terraformResource, terraformAttribute)
  }

  /**
  * @param key the key of the item to return
  */
  public get(key: string): PackSourceItemsConfGroupsOutputReference {
    return new PackSourceItemsConfGroupsOutputReference(this.terraformResource, this.terraformAttribute, key);
  }
}
export interface PackSourceItemsConf {
}

export function packSourceItemsConfToTerraform(struct?: PackSourceItemsConf): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function packSourceItemsConfToHclTerraform(struct?: PackSourceItemsConf): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class PackSourceItemsConfOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackSourceItemsConf | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceItemsConf | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
    }
  }

  // async_func_timeout - computed: true, optional: false, required: false
  public get asyncFuncTimeout() {
    return this.getNumberAttribute('async_func_timeout');
  }

  // description - computed: true, optional: false, required: false
  public get description() {
    return this.getStringAttribute('description');
  }

  // functions - computed: true, optional: false, required: false
  private _functions = new PackSourceItemsConfFunctionsList(this, "functions", false);
  public get functions() {
    return this._functions;
  }

  // groups - computed: true, optional: false, required: false
  private _groups = new PackSourceItemsConfGroupsMap(this, "groups");
  public get groups() {
    return this._groups;
  }

  // output - computed: true, optional: false, required: false
  public get output() {
    return this.getStringAttribute('output');
  }

  // streamtags - computed: true, optional: false, required: false
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
}
export interface PackSourceItemsGroups {
}

export function packSourceItemsGroupsToTerraform(struct?: PackSourceItemsGroups): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function packSourceItemsGroupsToHclTerraform(struct?: PackSourceItemsGroups): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class PackSourceItemsGroupsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectKey the key of this item in the map
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectKey: string) {
    super(terraformResource, terraformAttribute, false, complexObjectKey);
  }

  public get internalValue(): PackSourceItemsGroups | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceItemsGroups | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
    }
  }

  // description - computed: true, optional: false, required: false
  public get description() {
    return this.getStringAttribute('description');
  }

  // disabled - computed: true, optional: false, required: false
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }

  // name - computed: true, optional: false, required: false
  public get name() {
    return this.getStringAttribute('name');
  }
}

export class PackSourceItemsGroupsMap extends cdktf.ComplexMap {

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string) {
    super(terraformResource, terraformAttribute)
  }

  /**
  * @param key the key of the item to return
  */
  public get(key: string): PackSourceItemsGroupsOutputReference {
    return new PackSourceItemsGroupsOutputReference(this.terraformResource, this.terraformAttribute, key);
  }
}
export interface PackSourceItemsRoutes {
}

export function packSourceItemsRoutesToTerraform(struct?: PackSourceItemsRoutes): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function packSourceItemsRoutesToHclTerraform(struct?: PackSourceItemsRoutes): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class PackSourceItemsRoutesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackSourceItemsRoutes | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceItemsRoutes | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
    }
  }

  // additional_properties - computed: true, optional: false, required: false
  public get additionalProperties() {
    return this.getStringAttribute('additional_properties');
  }

  // description - computed: true, optional: false, required: false
  public get description() {
    return this.getStringAttribute('description');
  }

  // disabled - computed: true, optional: false, required: false
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }

  // enable_output_expression - computed: true, optional: false, required: false
  public get enableOutputExpression() {
    return this.getBooleanAttribute('enable_output_expression');
  }

  // filter - computed: true, optional: false, required: false
  public get filter() {
    return this.getStringAttribute('filter');
  }

  // final - computed: true, optional: false, required: false
  public get final() {
    return this.getBooleanAttribute('final');
  }

  // id - computed: true, optional: false, required: false
  public get id() {
    return this.getStringAttribute('id');
  }

  // name - computed: true, optional: false, required: false
  public get name() {
    return this.getStringAttribute('name');
  }

  // output - computed: true, optional: false, required: false
  public get output() {
    return this.getStringAttribute('output');
  }

  // output_expression - computed: true, optional: false, required: false
  public get outputExpression() {
    return this.getStringAttribute('output_expression');
  }

  // pipeline - computed: true, optional: false, required: false
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
}

export class PackSourceItemsRoutesList extends cdktf.ComplexList {

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackSourceItemsRoutesOutputReference {
    return new PackSourceItemsRoutesOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackSourceItems {
}

export function packSourceItemsToTerraform(struct?: PackSourceItems): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function packSourceItemsToHclTerraform(struct?: PackSourceItems): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class PackSourceItemsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackSourceItems | undefined {
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackSourceItems | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
    }
  }

  // comments - computed: true, optional: false, required: false
  private _comments = new PackSourceItemsCommentsList(this, "comments", false);
  public get comments() {
    return this._comments;
  }

  // conf - computed: true, optional: false, required: false
  private _conf = new PackSourceItemsConfOutputReference(this, "conf");
  public get conf() {
    return this._conf;
  }

  // groups - computed: true, optional: false, required: false
  private _groups = new PackSourceItemsGroupsMap(this, "groups");
  public get groups() {
    return this._groups;
  }

  // id - computed: true, optional: false, required: false
  public get id() {
    return this.getStringAttribute('id');
  }

  // routes - computed: true, optional: false, required: false
  private _routes = new PackSourceItemsRoutesList(this, "routes", false);
  public get routes() {
    return this._routes;
  }
}

export class PackSourceItemsList extends cdktf.ComplexList {

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackSourceItemsOutputReference {
    return new PackSourceItemsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
