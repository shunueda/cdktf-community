import * as cdktf from 'cdktf';
import { PackDestinationOutputInfluxdbExtraHttpHeaders,
packDestinationOutputInfluxdbExtraHttpHeadersToTerraform,
packDestinationOutputInfluxdbExtraHttpHeadersToHclTerraform,
PackDestinationOutputInfluxdbExtraHttpHeadersList,
PackDestinationOutputInfluxdbOauthHeaders,
packDestinationOutputInfluxdbOauthHeadersToTerraform,
packDestinationOutputInfluxdbOauthHeadersToHclTerraform,
PackDestinationOutputInfluxdbOauthHeadersList } from './structs0'
export interface PackDestinationOutputInfluxdbOauthParams {
  /**
  * OAuth parameter name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#name PackDestination#name}
  */
  readonly name: string;
  /**
  * OAuth parameter value
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#value PackDestination#value}
  */
  readonly value: string;
}

export function packDestinationOutputInfluxdbOauthParamsToTerraform(struct?: PackDestinationOutputInfluxdbOauthParams | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function packDestinationOutputInfluxdbOauthParamsToHclTerraform(struct?: PackDestinationOutputInfluxdbOauthParams | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputInfluxdbOauthParamsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackDestinationOutputInfluxdbOauthParams | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputInfluxdbOauthParams | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class PackDestinationOutputInfluxdbOauthParamsList extends cdktf.ComplexList {
  public internalValue? : PackDestinationOutputInfluxdbOauthParams[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackDestinationOutputInfluxdbOauthParamsOutputReference {
    return new PackDestinationOutputInfluxdbOauthParamsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackDestinationOutputInfluxdbPqControls {
}

export function packDestinationOutputInfluxdbPqControlsToTerraform(struct?: PackDestinationOutputInfluxdbPqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function packDestinationOutputInfluxdbPqControlsToHclTerraform(struct?: PackDestinationOutputInfluxdbPqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class PackDestinationOutputInfluxdbPqControlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackDestinationOutputInfluxdbPqControls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputInfluxdbPqControls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface PackDestinationOutputInfluxdbResponseRetrySettings {
  /**
  * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc. Default: 2
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#backoff_rate PackDestination#backoff_rate}
  */
  readonly backoffRate?: number;
  /**
  * The HTTP response status code that will trigger retries
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#http_status PackDestination#http_status}
  */
  readonly httpStatus: number;
  /**
  * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes). Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#initial_backoff PackDestination#initial_backoff}
  */
  readonly initialBackoff?: number;
  /**
  * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds). Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_backoff PackDestination#max_backoff}
  */
  readonly maxBackoff?: number;
}

export function packDestinationOutputInfluxdbResponseRetrySettingsToTerraform(struct?: PackDestinationOutputInfluxdbResponseRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    backoff_rate: cdktf.numberToTerraform(struct!.backoffRate),
    http_status: cdktf.numberToTerraform(struct!.httpStatus),
    initial_backoff: cdktf.numberToTerraform(struct!.initialBackoff),
    max_backoff: cdktf.numberToTerraform(struct!.maxBackoff),
  }
}


export function packDestinationOutputInfluxdbResponseRetrySettingsToHclTerraform(struct?: PackDestinationOutputInfluxdbResponseRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    backoff_rate: {
      value: cdktf.numberToHclTerraform(struct!.backoffRate),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    http_status: {
      value: cdktf.numberToHclTerraform(struct!.httpStatus),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    initial_backoff: {
      value: cdktf.numberToHclTerraform(struct!.initialBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_backoff: {
      value: cdktf.numberToHclTerraform(struct!.maxBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputInfluxdbResponseRetrySettingsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackDestinationOutputInfluxdbResponseRetrySettings | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._backoffRate !== undefined) {
      hasAnyValues = true;
      internalValueResult.backoffRate = this._backoffRate;
    }
    if (this._httpStatus !== undefined) {
      hasAnyValues = true;
      internalValueResult.httpStatus = this._httpStatus;
    }
    if (this._initialBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.initialBackoff = this._initialBackoff;
    }
    if (this._maxBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBackoff = this._maxBackoff;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputInfluxdbResponseRetrySettings | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._backoffRate = undefined;
      this._httpStatus = undefined;
      this._initialBackoff = undefined;
      this._maxBackoff = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._backoffRate = value.backoffRate;
      this._httpStatus = value.httpStatus;
      this._initialBackoff = value.initialBackoff;
      this._maxBackoff = value.maxBackoff;
    }
  }

  // backoff_rate - computed: true, optional: true, required: false
  private _backoffRate?: number; 
  public get backoffRate() {
    return this.getNumberAttribute('backoff_rate');
  }
  public set backoffRate(value: number) {
    this._backoffRate = value;
  }
  public resetBackoffRate() {
    this._backoffRate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get backoffRateInput() {
    return this._backoffRate;
  }

  // http_status - computed: false, optional: false, required: true
  private _httpStatus?: number; 
  public get httpStatus() {
    return this.getNumberAttribute('http_status');
  }
  public set httpStatus(value: number) {
    this._httpStatus = value;
  }
  // Temporarily expose input value. Use with caution.
  public get httpStatusInput() {
    return this._httpStatus;
  }

  // initial_backoff - computed: true, optional: true, required: false
  private _initialBackoff?: number; 
  public get initialBackoff() {
    return this.getNumberAttribute('initial_backoff');
  }
  public set initialBackoff(value: number) {
    this._initialBackoff = value;
  }
  public resetInitialBackoff() {
    this._initialBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get initialBackoffInput() {
    return this._initialBackoff;
  }

  // max_backoff - computed: true, optional: true, required: false
  private _maxBackoff?: number; 
  public get maxBackoff() {
    return this.getNumberAttribute('max_backoff');
  }
  public set maxBackoff(value: number) {
    this._maxBackoff = value;
  }
  public resetMaxBackoff() {
    this._maxBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBackoffInput() {
    return this._maxBackoff;
  }
}

export class PackDestinationOutputInfluxdbResponseRetrySettingsList extends cdktf.ComplexList {
  public internalValue? : PackDestinationOutputInfluxdbResponseRetrySettings[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackDestinationOutputInfluxdbResponseRetrySettingsOutputReference {
    return new PackDestinationOutputInfluxdbResponseRetrySettingsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackDestinationOutputInfluxdbTimeoutRetrySettings {
  /**
  * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc. Default: 2
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#backoff_rate PackDestination#backoff_rate}
  */
  readonly backoffRate?: number;
  /**
  * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes). Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#initial_backoff PackDestination#initial_backoff}
  */
  readonly initialBackoff?: number;
  /**
  * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds). Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_backoff PackDestination#max_backoff}
  */
  readonly maxBackoff?: number;
  /**
  * Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#timeout_retry PackDestination#timeout_retry}
  */
  readonly timeoutRetry?: boolean | cdktf.IResolvable;
}

export function packDestinationOutputInfluxdbTimeoutRetrySettingsToTerraform(struct?: PackDestinationOutputInfluxdbTimeoutRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    backoff_rate: cdktf.numberToTerraform(struct!.backoffRate),
    initial_backoff: cdktf.numberToTerraform(struct!.initialBackoff),
    max_backoff: cdktf.numberToTerraform(struct!.maxBackoff),
    timeout_retry: cdktf.booleanToTerraform(struct!.timeoutRetry),
  }
}


export function packDestinationOutputInfluxdbTimeoutRetrySettingsToHclTerraform(struct?: PackDestinationOutputInfluxdbTimeoutRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    backoff_rate: {
      value: cdktf.numberToHclTerraform(struct!.backoffRate),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    initial_backoff: {
      value: cdktf.numberToHclTerraform(struct!.initialBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_backoff: {
      value: cdktf.numberToHclTerraform(struct!.maxBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    timeout_retry: {
      value: cdktf.booleanToHclTerraform(struct!.timeoutRetry),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputInfluxdbTimeoutRetrySettingsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackDestinationOutputInfluxdbTimeoutRetrySettings | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._backoffRate !== undefined) {
      hasAnyValues = true;
      internalValueResult.backoffRate = this._backoffRate;
    }
    if (this._initialBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.initialBackoff = this._initialBackoff;
    }
    if (this._maxBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBackoff = this._maxBackoff;
    }
    if (this._timeoutRetry !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutRetry = this._timeoutRetry;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputInfluxdbTimeoutRetrySettings | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._backoffRate = undefined;
      this._initialBackoff = undefined;
      this._maxBackoff = undefined;
      this._timeoutRetry = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._backoffRate = value.backoffRate;
      this._initialBackoff = value.initialBackoff;
      this._maxBackoff = value.maxBackoff;
      this._timeoutRetry = value.timeoutRetry;
    }
  }

  // backoff_rate - computed: true, optional: true, required: false
  private _backoffRate?: number; 
  public get backoffRate() {
    return this.getNumberAttribute('backoff_rate');
  }
  public set backoffRate(value: number) {
    this._backoffRate = value;
  }
  public resetBackoffRate() {
    this._backoffRate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get backoffRateInput() {
    return this._backoffRate;
  }

  // initial_backoff - computed: true, optional: true, required: false
  private _initialBackoff?: number; 
  public get initialBackoff() {
    return this.getNumberAttribute('initial_backoff');
  }
  public set initialBackoff(value: number) {
    this._initialBackoff = value;
  }
  public resetInitialBackoff() {
    this._initialBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get initialBackoffInput() {
    return this._initialBackoff;
  }

  // max_backoff - computed: true, optional: true, required: false
  private _maxBackoff?: number; 
  public get maxBackoff() {
    return this.getNumberAttribute('max_backoff');
  }
  public set maxBackoff(value: number) {
    this._maxBackoff = value;
  }
  public resetMaxBackoff() {
    this._maxBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBackoffInput() {
    return this._maxBackoff;
  }

  // timeout_retry - computed: true, optional: true, required: false
  private _timeoutRetry?: boolean | cdktf.IResolvable; 
  public get timeoutRetry() {
    return this.getBooleanAttribute('timeout_retry');
  }
  public set timeoutRetry(value: boolean | cdktf.IResolvable) {
    this._timeoutRetry = value;
  }
  public resetTimeoutRetry() {
    this._timeoutRetry = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutRetryInput() {
    return this._timeoutRetry;
  }
}
export interface PackDestinationOutputInfluxdb {
  /**
  * JavaScript expression to compute the Authorization header value to pass in requests. The value `${token}` is used to reference the token obtained from authentication, e.g.: `Bearer ${token}`. Default: "`Bearer ${token}`"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#auth_header_expr PackDestination#auth_header_expr}
  */
  readonly authHeaderExpr?: string;
  /**
  * InfluxDB authentication type. Default: "none"; must be one of ["none", "basic", "credentialsSecret", "token", "textSecret", "oauth"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#auth_type PackDestination#auth_type}
  */
  readonly authType?: string;
  /**
  * Bucket to write to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#bucket PackDestination#bucket}
  */
  readonly bucket?: string;
  /**
  * Compress the payload body before sending. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#compress PackDestination#compress}
  */
  readonly compress?: boolean | cdktf.IResolvable;
  /**
  * Maximum number of ongoing requests before blocking. Default: 5
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#concurrency PackDestination#concurrency}
  */
  readonly concurrency?: number;
  /**
  * Select or create a secret that references your credentials
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#credentials_secret PackDestination#credentials_secret}
  */
  readonly credentialsSecret?: string;
  /**
  * Database to write to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#database PackDestination#database}
  */
  readonly database?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#description PackDestination#description}
  */
  readonly description?: string;
  /**
  * Enabling this will pull the value field from the metric name. E,g, 'db.query.user' will use 'db.query' as the measurement and 'user' as the value field. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#dynamic_value_field_name PackDestination#dynamic_value_field_name}
  */
  readonly dynamicValueFieldName?: boolean | cdktf.IResolvable;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#environment PackDestination#environment}
  */
  readonly environment?: string;
  /**
  * Headers to add to all events
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#extra_http_headers PackDestination#extra_http_headers}
  */
  readonly extraHttpHeaders?: PackDestinationOutputInfluxdbExtraHttpHeaders[] | cdktf.IResolvable;
  /**
  * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below. Default: "none"; must be one of ["payload", "payloadAndHeaders", "none"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#failed_request_logging_mode PackDestination#failed_request_logging_mode}
  */
  readonly failedRequestLoggingMode?: string;
  /**
  * Maximum time between requests. Small values could cause the payload size to be smaller than the configured Body size limit. Default: 1
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#flush_period_sec PackDestination#flush_period_sec}
  */
  readonly flushPeriodSec?: number;
  /**
  * Unique ID for this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#id PackDestination#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * URL for OAuth
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#login_url PackDestination#login_url}
  */
  readonly loginUrl?: string;
  /**
  * Maximum number of events to include in the request body. Default is 0 (unlimited). Default: 0
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_payload_events PackDestination#max_payload_events}
  */
  readonly maxPayloadEvents?: number;
  /**
  * Maximum size, in KB, of the request body. Default: 4096
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_payload_size_kb PackDestination#max_payload_size_kb}
  */
  readonly maxPayloadSizeKb?: number;
  /**
  * Additional headers to send in the OAuth login request. @{product} will automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#oauth_headers PackDestination#oauth_headers}
  */
  readonly oauthHeaders?: PackDestinationOutputInfluxdbOauthHeaders[] | cdktf.IResolvable;
  /**
  * Additional parameters to send in the OAuth login request. @{product} will combine the secret with these parameters, and will send the URL-encoded result in a POST request to the endpoint specified in the 'Login URL'. We'll automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#oauth_params PackDestination#oauth_params}
  */
  readonly oauthParams?: PackDestinationOutputInfluxdbOauthParams[] | cdktf.IResolvable;
  /**
  * How to handle events when all receivers are exerting backpressure. Default: "block"; must be one of ["block", "drop", "queue"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#on_backpressure PackDestination#on_backpressure}
  */
  readonly onBackpressure?: string;
  /**
  * Organization ID for this bucket.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#org PackDestination#org}
  */
  readonly org?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#password PackDestination#password}
  */
  readonly password?: string;
  /**
  * Pipeline to process data before sending out to this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pipeline PackDestination#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_compress PackDestination#pq_compress}
  */
  readonly pqCompress?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_controls PackDestination#pq_controls}
  */
  readonly pqControls?: PackDestinationOutputInfluxdbPqControls;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.). Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_max_file_size PackDestination#pq_max_file_size}
  */
  readonly pqMaxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_max_size PackDestination#pq_max_size}
  */
  readonly pqMaxSize?: string;
  /**
  * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem. Default: "error"; must be one of ["error", "backpressure", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_mode PackDestination#pq_mode}
  */
  readonly pqMode?: string;
  /**
  * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged. Default: "block"; must be one of ["block", "drop"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_on_backpressure PackDestination#pq_on_backpressure}
  */
  readonly pqOnBackpressure?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_path PackDestination#pq_path}
  */
  readonly pqPath?: string;
  /**
  * Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's). 
  *         Enabled by default. When this setting is also present in TLS Settings (Client Side), 
  *         that value will take precedence.
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#reject_unauthorized PackDestination#reject_unauthorized}
  */
  readonly rejectUnauthorized?: boolean | cdktf.IResolvable;
  /**
  * Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#response_honor_retry_after_header PackDestination#response_honor_retry_after_header}
  */
  readonly responseHonorRetryAfterHeader?: boolean | cdktf.IResolvable;
  /**
  * Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#response_retry_settings PackDestination#response_retry_settings}
  */
  readonly responseRetrySettings?: PackDestinationOutputInfluxdbResponseRetrySettings[] | cdktf.IResolvable;
  /**
  * List of headers that are safe to log in plain text. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#safe_headers PackDestination#safe_headers}
  */
  readonly safeHeaders?: string[];
  /**
  * Secret parameter value to pass in request body
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#secret PackDestination#secret}
  */
  readonly secret?: string;
  /**
  * Secret parameter name to pass in request body
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#secret_param_name PackDestination#secret_param_name}
  */
  readonly secretParamName?: string;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#streamtags PackDestination#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Fields to automatically add to events, such as cribl_pipe. Supports wildcards. Default: ["cribl_pipe"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#system_fields PackDestination#system_fields}
  */
  readonly systemFields?: string[];
  /**
  * Select or create a stored text secret
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#text_secret PackDestination#text_secret}
  */
  readonly textSecret?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#timeout_retry_settings PackDestination#timeout_retry_settings}
  */
  readonly timeoutRetrySettings?: PackDestinationOutputInfluxdbTimeoutRetrySettings;
  /**
  * Amount of time, in seconds, to wait for a request to complete before canceling it. Default: 30
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#timeout_sec PackDestination#timeout_sec}
  */
  readonly timeoutSec?: number;
  /**
  * Sets the precision for the supplied Unix time values. Defaults to milliseconds. Default: "ms"; must be one of ["ns", "u", "ms", "s", "m", "h"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#timestamp_precision PackDestination#timestamp_precision}
  */
  readonly timestampPrecision?: string;
  /**
  * Bearer token to include in the authorization header
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#token PackDestination#token}
  */
  readonly token?: string;
  /**
  * Name of the auth token attribute in the OAuth response. Can be top-level (e.g., 'token'); or nested, using a period (e.g., 'data.token').
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#token_attribute_name PackDestination#token_attribute_name}
  */
  readonly tokenAttributeName?: string;
  /**
  * How often the OAuth token should be refreshed. Default: 3600
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#token_timeout_secs PackDestination#token_timeout_secs}
  */
  readonly tokenTimeoutSecs?: number;
  /**
  * must be "influxdb"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#type PackDestination#type}
  */
  readonly type: string;
  /**
  * URL of an InfluxDB cluster to send events to, e.g., http://localhost:8086/write
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#url PackDestination#url}
  */
  readonly url: string;
  /**
  * Enable round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. For optimal performance, consider enabling this setting for non-load balanced destinations. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#use_round_robin_dns PackDestination#use_round_robin_dns}
  */
  readonly useRoundRobinDns?: boolean | cdktf.IResolvable;
  /**
  * The v2 API can be enabled with InfluxDB versions 1.8 and later. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#use_v2_api PackDestination#use_v2_api}
  */
  readonly useV2Api?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#username PackDestination#username}
  */
  readonly username?: string;
  /**
  * Name of the field in which to store the metric when sending to InfluxDB. If dynamic generation is enabled and fails, this will be used as a fallback. Default: "value"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#value_field_name PackDestination#value_field_name}
  */
  readonly valueFieldName?: string;
}

export function packDestinationOutputInfluxdbToTerraform(struct?: PackDestinationOutputInfluxdb | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    auth_header_expr: cdktf.stringToTerraform(struct!.authHeaderExpr),
    auth_type: cdktf.stringToTerraform(struct!.authType),
    bucket: cdktf.stringToTerraform(struct!.bucket),
    compress: cdktf.booleanToTerraform(struct!.compress),
    concurrency: cdktf.numberToTerraform(struct!.concurrency),
    credentials_secret: cdktf.stringToTerraform(struct!.credentialsSecret),
    database: cdktf.stringToTerraform(struct!.database),
    description: cdktf.stringToTerraform(struct!.description),
    dynamic_value_field_name: cdktf.booleanToTerraform(struct!.dynamicValueFieldName),
    environment: cdktf.stringToTerraform(struct!.environment),
    extra_http_headers: cdktf.listMapper(packDestinationOutputInfluxdbExtraHttpHeadersToTerraform, false)(struct!.extraHttpHeaders),
    failed_request_logging_mode: cdktf.stringToTerraform(struct!.failedRequestLoggingMode),
    flush_period_sec: cdktf.numberToTerraform(struct!.flushPeriodSec),
    id: cdktf.stringToTerraform(struct!.id),
    login_url: cdktf.stringToTerraform(struct!.loginUrl),
    max_payload_events: cdktf.numberToTerraform(struct!.maxPayloadEvents),
    max_payload_size_kb: cdktf.numberToTerraform(struct!.maxPayloadSizeKb),
    oauth_headers: cdktf.listMapper(packDestinationOutputInfluxdbOauthHeadersToTerraform, false)(struct!.oauthHeaders),
    oauth_params: cdktf.listMapper(packDestinationOutputInfluxdbOauthParamsToTerraform, false)(struct!.oauthParams),
    on_backpressure: cdktf.stringToTerraform(struct!.onBackpressure),
    org: cdktf.stringToTerraform(struct!.org),
    password: cdktf.stringToTerraform(struct!.password),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    pq_compress: cdktf.stringToTerraform(struct!.pqCompress),
    pq_controls: packDestinationOutputInfluxdbPqControlsToTerraform(struct!.pqControls),
    pq_max_file_size: cdktf.stringToTerraform(struct!.pqMaxFileSize),
    pq_max_size: cdktf.stringToTerraform(struct!.pqMaxSize),
    pq_mode: cdktf.stringToTerraform(struct!.pqMode),
    pq_on_backpressure: cdktf.stringToTerraform(struct!.pqOnBackpressure),
    pq_path: cdktf.stringToTerraform(struct!.pqPath),
    reject_unauthorized: cdktf.booleanToTerraform(struct!.rejectUnauthorized),
    response_honor_retry_after_header: cdktf.booleanToTerraform(struct!.responseHonorRetryAfterHeader),
    response_retry_settings: cdktf.listMapper(packDestinationOutputInfluxdbResponseRetrySettingsToTerraform, false)(struct!.responseRetrySettings),
    safe_headers: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.safeHeaders),
    secret: cdktf.stringToTerraform(struct!.secret),
    secret_param_name: cdktf.stringToTerraform(struct!.secretParamName),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    system_fields: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.systemFields),
    text_secret: cdktf.stringToTerraform(struct!.textSecret),
    timeout_retry_settings: packDestinationOutputInfluxdbTimeoutRetrySettingsToTerraform(struct!.timeoutRetrySettings),
    timeout_sec: cdktf.numberToTerraform(struct!.timeoutSec),
    timestamp_precision: cdktf.stringToTerraform(struct!.timestampPrecision),
    token: cdktf.stringToTerraform(struct!.token),
    token_attribute_name: cdktf.stringToTerraform(struct!.tokenAttributeName),
    token_timeout_secs: cdktf.numberToTerraform(struct!.tokenTimeoutSecs),
    type: cdktf.stringToTerraform(struct!.type),
    url: cdktf.stringToTerraform(struct!.url),
    use_round_robin_dns: cdktf.booleanToTerraform(struct!.useRoundRobinDns),
    use_v2_api: cdktf.booleanToTerraform(struct!.useV2Api),
    username: cdktf.stringToTerraform(struct!.username),
    value_field_name: cdktf.stringToTerraform(struct!.valueFieldName),
  }
}


export function packDestinationOutputInfluxdbToHclTerraform(struct?: PackDestinationOutputInfluxdb | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    auth_header_expr: {
      value: cdktf.stringToHclTerraform(struct!.authHeaderExpr),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    auth_type: {
      value: cdktf.stringToHclTerraform(struct!.authType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    bucket: {
      value: cdktf.stringToHclTerraform(struct!.bucket),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    compress: {
      value: cdktf.booleanToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    concurrency: {
      value: cdktf.numberToHclTerraform(struct!.concurrency),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    credentials_secret: {
      value: cdktf.stringToHclTerraform(struct!.credentialsSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    database: {
      value: cdktf.stringToHclTerraform(struct!.database),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    dynamic_value_field_name: {
      value: cdktf.booleanToHclTerraform(struct!.dynamicValueFieldName),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    extra_http_headers: {
      value: cdktf.listMapperHcl(packDestinationOutputInfluxdbExtraHttpHeadersToHclTerraform, false)(struct!.extraHttpHeaders),
      isBlock: true,
      type: "list",
      storageClassType: "PackDestinationOutputInfluxdbExtraHttpHeadersList",
    },
    failed_request_logging_mode: {
      value: cdktf.stringToHclTerraform(struct!.failedRequestLoggingMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    flush_period_sec: {
      value: cdktf.numberToHclTerraform(struct!.flushPeriodSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    login_url: {
      value: cdktf.stringToHclTerraform(struct!.loginUrl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_payload_events: {
      value: cdktf.numberToHclTerraform(struct!.maxPayloadEvents),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_payload_size_kb: {
      value: cdktf.numberToHclTerraform(struct!.maxPayloadSizeKb),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    oauth_headers: {
      value: cdktf.listMapperHcl(packDestinationOutputInfluxdbOauthHeadersToHclTerraform, false)(struct!.oauthHeaders),
      isBlock: true,
      type: "list",
      storageClassType: "PackDestinationOutputInfluxdbOauthHeadersList",
    },
    oauth_params: {
      value: cdktf.listMapperHcl(packDestinationOutputInfluxdbOauthParamsToHclTerraform, false)(struct!.oauthParams),
      isBlock: true,
      type: "list",
      storageClassType: "PackDestinationOutputInfluxdbOauthParamsList",
    },
    on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.onBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    org: {
      value: cdktf.stringToHclTerraform(struct!.org),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    password: {
      value: cdktf.stringToHclTerraform(struct!.password),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_compress: {
      value: cdktf.stringToHclTerraform(struct!.pqCompress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_controls: {
      value: packDestinationOutputInfluxdbPqControlsToHclTerraform(struct!.pqControls),
      isBlock: true,
      type: "struct",
      storageClassType: "PackDestinationOutputInfluxdbPqControls",
    },
    pq_max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_max_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_mode: {
      value: cdktf.stringToHclTerraform(struct!.pqMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.pqOnBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_path: {
      value: cdktf.stringToHclTerraform(struct!.pqPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reject_unauthorized: {
      value: cdktf.booleanToHclTerraform(struct!.rejectUnauthorized),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    response_honor_retry_after_header: {
      value: cdktf.booleanToHclTerraform(struct!.responseHonorRetryAfterHeader),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    response_retry_settings: {
      value: cdktf.listMapperHcl(packDestinationOutputInfluxdbResponseRetrySettingsToHclTerraform, false)(struct!.responseRetrySettings),
      isBlock: true,
      type: "list",
      storageClassType: "PackDestinationOutputInfluxdbResponseRetrySettingsList",
    },
    safe_headers: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.safeHeaders),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    secret: {
      value: cdktf.stringToHclTerraform(struct!.secret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_param_name: {
      value: cdktf.stringToHclTerraform(struct!.secretParamName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    system_fields: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.systemFields),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    text_secret: {
      value: cdktf.stringToHclTerraform(struct!.textSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    timeout_retry_settings: {
      value: packDestinationOutputInfluxdbTimeoutRetrySettingsToHclTerraform(struct!.timeoutRetrySettings),
      isBlock: true,
      type: "struct",
      storageClassType: "PackDestinationOutputInfluxdbTimeoutRetrySettings",
    },
    timeout_sec: {
      value: cdktf.numberToHclTerraform(struct!.timeoutSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    timestamp_precision: {
      value: cdktf.stringToHclTerraform(struct!.timestampPrecision),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    token: {
      value: cdktf.stringToHclTerraform(struct!.token),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    token_attribute_name: {
      value: cdktf.stringToHclTerraform(struct!.tokenAttributeName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    token_timeout_secs: {
      value: cdktf.numberToHclTerraform(struct!.tokenTimeoutSecs),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    url: {
      value: cdktf.stringToHclTerraform(struct!.url),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    use_round_robin_dns: {
      value: cdktf.booleanToHclTerraform(struct!.useRoundRobinDns),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    use_v2_api: {
      value: cdktf.booleanToHclTerraform(struct!.useV2Api),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    username: {
      value: cdktf.stringToHclTerraform(struct!.username),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value_field_name: {
      value: cdktf.stringToHclTerraform(struct!.valueFieldName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputInfluxdbOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackDestinationOutputInfluxdb | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._authHeaderExpr !== undefined) {
      hasAnyValues = true;
      internalValueResult.authHeaderExpr = this._authHeaderExpr;
    }
    if (this._authType !== undefined) {
      hasAnyValues = true;
      internalValueResult.authType = this._authType;
    }
    if (this._bucket !== undefined) {
      hasAnyValues = true;
      internalValueResult.bucket = this._bucket;
    }
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._concurrency !== undefined) {
      hasAnyValues = true;
      internalValueResult.concurrency = this._concurrency;
    }
    if (this._credentialsSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.credentialsSecret = this._credentialsSecret;
    }
    if (this._database !== undefined) {
      hasAnyValues = true;
      internalValueResult.database = this._database;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._dynamicValueFieldName !== undefined) {
      hasAnyValues = true;
      internalValueResult.dynamicValueFieldName = this._dynamicValueFieldName;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._extraHttpHeaders?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.extraHttpHeaders = this._extraHttpHeaders?.internalValue;
    }
    if (this._failedRequestLoggingMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.failedRequestLoggingMode = this._failedRequestLoggingMode;
    }
    if (this._flushPeriodSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.flushPeriodSec = this._flushPeriodSec;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._loginUrl !== undefined) {
      hasAnyValues = true;
      internalValueResult.loginUrl = this._loginUrl;
    }
    if (this._maxPayloadEvents !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxPayloadEvents = this._maxPayloadEvents;
    }
    if (this._maxPayloadSizeKb !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxPayloadSizeKb = this._maxPayloadSizeKb;
    }
    if (this._oauthHeaders?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.oauthHeaders = this._oauthHeaders?.internalValue;
    }
    if (this._oauthParams?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.oauthParams = this._oauthParams?.internalValue;
    }
    if (this._onBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.onBackpressure = this._onBackpressure;
    }
    if (this._org !== undefined) {
      hasAnyValues = true;
      internalValueResult.org = this._org;
    }
    if (this._password !== undefined) {
      hasAnyValues = true;
      internalValueResult.password = this._password;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._pqCompress !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqCompress = this._pqCompress;
    }
    if (this._pqControls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqControls = this._pqControls?.internalValue;
    }
    if (this._pqMaxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxFileSize = this._pqMaxFileSize;
    }
    if (this._pqMaxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxSize = this._pqMaxSize;
    }
    if (this._pqMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMode = this._pqMode;
    }
    if (this._pqOnBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqOnBackpressure = this._pqOnBackpressure;
    }
    if (this._pqPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqPath = this._pqPath;
    }
    if (this._rejectUnauthorized !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectUnauthorized = this._rejectUnauthorized;
    }
    if (this._responseHonorRetryAfterHeader !== undefined) {
      hasAnyValues = true;
      internalValueResult.responseHonorRetryAfterHeader = this._responseHonorRetryAfterHeader;
    }
    if (this._responseRetrySettings?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.responseRetrySettings = this._responseRetrySettings?.internalValue;
    }
    if (this._safeHeaders !== undefined) {
      hasAnyValues = true;
      internalValueResult.safeHeaders = this._safeHeaders;
    }
    if (this._secret !== undefined) {
      hasAnyValues = true;
      internalValueResult.secret = this._secret;
    }
    if (this._secretParamName !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretParamName = this._secretParamName;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._systemFields !== undefined) {
      hasAnyValues = true;
      internalValueResult.systemFields = this._systemFields;
    }
    if (this._textSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.textSecret = this._textSecret;
    }
    if (this._timeoutRetrySettings?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutRetrySettings = this._timeoutRetrySettings?.internalValue;
    }
    if (this._timeoutSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutSec = this._timeoutSec;
    }
    if (this._timestampPrecision !== undefined) {
      hasAnyValues = true;
      internalValueResult.timestampPrecision = this._timestampPrecision;
    }
    if (this._token !== undefined) {
      hasAnyValues = true;
      internalValueResult.token = this._token;
    }
    if (this._tokenAttributeName !== undefined) {
      hasAnyValues = true;
      internalValueResult.tokenAttributeName = this._tokenAttributeName;
    }
    if (this._tokenTimeoutSecs !== undefined) {
      hasAnyValues = true;
      internalValueResult.tokenTimeoutSecs = this._tokenTimeoutSecs;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._url !== undefined) {
      hasAnyValues = true;
      internalValueResult.url = this._url;
    }
    if (this._useRoundRobinDns !== undefined) {
      hasAnyValues = true;
      internalValueResult.useRoundRobinDns = this._useRoundRobinDns;
    }
    if (this._useV2Api !== undefined) {
      hasAnyValues = true;
      internalValueResult.useV2Api = this._useV2Api;
    }
    if (this._username !== undefined) {
      hasAnyValues = true;
      internalValueResult.username = this._username;
    }
    if (this._valueFieldName !== undefined) {
      hasAnyValues = true;
      internalValueResult.valueFieldName = this._valueFieldName;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputInfluxdb | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._authHeaderExpr = undefined;
      this._authType = undefined;
      this._bucket = undefined;
      this._compress = undefined;
      this._concurrency = undefined;
      this._credentialsSecret = undefined;
      this._database = undefined;
      this._description = undefined;
      this._dynamicValueFieldName = undefined;
      this._environment = undefined;
      this._extraHttpHeaders.internalValue = undefined;
      this._failedRequestLoggingMode = undefined;
      this._flushPeriodSec = undefined;
      this._id = undefined;
      this._loginUrl = undefined;
      this._maxPayloadEvents = undefined;
      this._maxPayloadSizeKb = undefined;
      this._oauthHeaders.internalValue = undefined;
      this._oauthParams.internalValue = undefined;
      this._onBackpressure = undefined;
      this._org = undefined;
      this._password = undefined;
      this._pipeline = undefined;
      this._pqCompress = undefined;
      this._pqControls.internalValue = undefined;
      this._pqMaxFileSize = undefined;
      this._pqMaxSize = undefined;
      this._pqMode = undefined;
      this._pqOnBackpressure = undefined;
      this._pqPath = undefined;
      this._rejectUnauthorized = undefined;
      this._responseHonorRetryAfterHeader = undefined;
      this._responseRetrySettings.internalValue = undefined;
      this._safeHeaders = undefined;
      this._secret = undefined;
      this._secretParamName = undefined;
      this._streamtags = undefined;
      this._systemFields = undefined;
      this._textSecret = undefined;
      this._timeoutRetrySettings.internalValue = undefined;
      this._timeoutSec = undefined;
      this._timestampPrecision = undefined;
      this._token = undefined;
      this._tokenAttributeName = undefined;
      this._tokenTimeoutSecs = undefined;
      this._type = undefined;
      this._url = undefined;
      this._useRoundRobinDns = undefined;
      this._useV2Api = undefined;
      this._username = undefined;
      this._valueFieldName = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._authHeaderExpr = value.authHeaderExpr;
      this._authType = value.authType;
      this._bucket = value.bucket;
      this._compress = value.compress;
      this._concurrency = value.concurrency;
      this._credentialsSecret = value.credentialsSecret;
      this._database = value.database;
      this._description = value.description;
      this._dynamicValueFieldName = value.dynamicValueFieldName;
      this._environment = value.environment;
      this._extraHttpHeaders.internalValue = value.extraHttpHeaders;
      this._failedRequestLoggingMode = value.failedRequestLoggingMode;
      this._flushPeriodSec = value.flushPeriodSec;
      this._id = value.id;
      this._loginUrl = value.loginUrl;
      this._maxPayloadEvents = value.maxPayloadEvents;
      this._maxPayloadSizeKb = value.maxPayloadSizeKb;
      this._oauthHeaders.internalValue = value.oauthHeaders;
      this._oauthParams.internalValue = value.oauthParams;
      this._onBackpressure = value.onBackpressure;
      this._org = value.org;
      this._password = value.password;
      this._pipeline = value.pipeline;
      this._pqCompress = value.pqCompress;
      this._pqControls.internalValue = value.pqControls;
      this._pqMaxFileSize = value.pqMaxFileSize;
      this._pqMaxSize = value.pqMaxSize;
      this._pqMode = value.pqMode;
      this._pqOnBackpressure = value.pqOnBackpressure;
      this._pqPath = value.pqPath;
      this._rejectUnauthorized = value.rejectUnauthorized;
      this._responseHonorRetryAfterHeader = value.responseHonorRetryAfterHeader;
      this._responseRetrySettings.internalValue = value.responseRetrySettings;
      this._safeHeaders = value.safeHeaders;
      this._secret = value.secret;
      this._secretParamName = value.secretParamName;
      this._streamtags = value.streamtags;
      this._systemFields = value.systemFields;
      this._textSecret = value.textSecret;
      this._timeoutRetrySettings.internalValue = value.timeoutRetrySettings;
      this._timeoutSec = value.timeoutSec;
      this._timestampPrecision = value.timestampPrecision;
      this._token = value.token;
      this._tokenAttributeName = value.tokenAttributeName;
      this._tokenTimeoutSecs = value.tokenTimeoutSecs;
      this._type = value.type;
      this._url = value.url;
      this._useRoundRobinDns = value.useRoundRobinDns;
      this._useV2Api = value.useV2Api;
      this._username = value.username;
      this._valueFieldName = value.valueFieldName;
    }
  }

  // auth_header_expr - computed: true, optional: true, required: false
  private _authHeaderExpr?: string; 
  public get authHeaderExpr() {
    return this.getStringAttribute('auth_header_expr');
  }
  public set authHeaderExpr(value: string) {
    this._authHeaderExpr = value;
  }
  public resetAuthHeaderExpr() {
    this._authHeaderExpr = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authHeaderExprInput() {
    return this._authHeaderExpr;
  }

  // auth_type - computed: true, optional: true, required: false
  private _authType?: string; 
  public get authType() {
    return this.getStringAttribute('auth_type');
  }
  public set authType(value: string) {
    this._authType = value;
  }
  public resetAuthType() {
    this._authType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authTypeInput() {
    return this._authType;
  }

  // bucket - computed: false, optional: true, required: false
  private _bucket?: string; 
  public get bucket() {
    return this.getStringAttribute('bucket');
  }
  public set bucket(value: string) {
    this._bucket = value;
  }
  public resetBucket() {
    this._bucket = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get bucketInput() {
    return this._bucket;
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: boolean | cdktf.IResolvable; 
  public get compress() {
    return this.getBooleanAttribute('compress');
  }
  public set compress(value: boolean | cdktf.IResolvable) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // concurrency - computed: true, optional: true, required: false
  private _concurrency?: number; 
  public get concurrency() {
    return this.getNumberAttribute('concurrency');
  }
  public set concurrency(value: number) {
    this._concurrency = value;
  }
  public resetConcurrency() {
    this._concurrency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get concurrencyInput() {
    return this._concurrency;
  }

  // credentials_secret - computed: false, optional: true, required: false
  private _credentialsSecret?: string; 
  public get credentialsSecret() {
    return this.getStringAttribute('credentials_secret');
  }
  public set credentialsSecret(value: string) {
    this._credentialsSecret = value;
  }
  public resetCredentialsSecret() {
    this._credentialsSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get credentialsSecretInput() {
    return this._credentialsSecret;
  }

  // database - computed: false, optional: true, required: false
  private _database?: string; 
  public get database() {
    return this.getStringAttribute('database');
  }
  public set database(value: string) {
    this._database = value;
  }
  public resetDatabase() {
    this._database = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get databaseInput() {
    return this._database;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // dynamic_value_field_name - computed: true, optional: true, required: false
  private _dynamicValueFieldName?: boolean | cdktf.IResolvable; 
  public get dynamicValueFieldName() {
    return this.getBooleanAttribute('dynamic_value_field_name');
  }
  public set dynamicValueFieldName(value: boolean | cdktf.IResolvable) {
    this._dynamicValueFieldName = value;
  }
  public resetDynamicValueFieldName() {
    this._dynamicValueFieldName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dynamicValueFieldNameInput() {
    return this._dynamicValueFieldName;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // extra_http_headers - computed: false, optional: true, required: false
  private _extraHttpHeaders = new PackDestinationOutputInfluxdbExtraHttpHeadersList(this, "extra_http_headers", false);
  public get extraHttpHeaders() {
    return this._extraHttpHeaders;
  }
  public putExtraHttpHeaders(value: PackDestinationOutputInfluxdbExtraHttpHeaders[] | cdktf.IResolvable) {
    this._extraHttpHeaders.internalValue = value;
  }
  public resetExtraHttpHeaders() {
    this._extraHttpHeaders.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get extraHttpHeadersInput() {
    return this._extraHttpHeaders.internalValue;
  }

  // failed_request_logging_mode - computed: true, optional: true, required: false
  private _failedRequestLoggingMode?: string; 
  public get failedRequestLoggingMode() {
    return this.getStringAttribute('failed_request_logging_mode');
  }
  public set failedRequestLoggingMode(value: string) {
    this._failedRequestLoggingMode = value;
  }
  public resetFailedRequestLoggingMode() {
    this._failedRequestLoggingMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get failedRequestLoggingModeInput() {
    return this._failedRequestLoggingMode;
  }

  // flush_period_sec - computed: true, optional: true, required: false
  private _flushPeriodSec?: number; 
  public get flushPeriodSec() {
    return this.getNumberAttribute('flush_period_sec');
  }
  public set flushPeriodSec(value: number) {
    this._flushPeriodSec = value;
  }
  public resetFlushPeriodSec() {
    this._flushPeriodSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get flushPeriodSecInput() {
    return this._flushPeriodSec;
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // login_url - computed: false, optional: true, required: false
  private _loginUrl?: string; 
  public get loginUrl() {
    return this.getStringAttribute('login_url');
  }
  public set loginUrl(value: string) {
    this._loginUrl = value;
  }
  public resetLoginUrl() {
    this._loginUrl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get loginUrlInput() {
    return this._loginUrl;
  }

  // max_payload_events - computed: true, optional: true, required: false
  private _maxPayloadEvents?: number; 
  public get maxPayloadEvents() {
    return this.getNumberAttribute('max_payload_events');
  }
  public set maxPayloadEvents(value: number) {
    this._maxPayloadEvents = value;
  }
  public resetMaxPayloadEvents() {
    this._maxPayloadEvents = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxPayloadEventsInput() {
    return this._maxPayloadEvents;
  }

  // max_payload_size_kb - computed: true, optional: true, required: false
  private _maxPayloadSizeKb?: number; 
  public get maxPayloadSizeKb() {
    return this.getNumberAttribute('max_payload_size_kb');
  }
  public set maxPayloadSizeKb(value: number) {
    this._maxPayloadSizeKb = value;
  }
  public resetMaxPayloadSizeKb() {
    this._maxPayloadSizeKb = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxPayloadSizeKbInput() {
    return this._maxPayloadSizeKb;
  }

  // oauth_headers - computed: false, optional: true, required: false
  private _oauthHeaders = new PackDestinationOutputInfluxdbOauthHeadersList(this, "oauth_headers", false);
  public get oauthHeaders() {
    return this._oauthHeaders;
  }
  public putOauthHeaders(value: PackDestinationOutputInfluxdbOauthHeaders[] | cdktf.IResolvable) {
    this._oauthHeaders.internalValue = value;
  }
  public resetOauthHeaders() {
    this._oauthHeaders.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get oauthHeadersInput() {
    return this._oauthHeaders.internalValue;
  }

  // oauth_params - computed: false, optional: true, required: false
  private _oauthParams = new PackDestinationOutputInfluxdbOauthParamsList(this, "oauth_params", false);
  public get oauthParams() {
    return this._oauthParams;
  }
  public putOauthParams(value: PackDestinationOutputInfluxdbOauthParams[] | cdktf.IResolvable) {
    this._oauthParams.internalValue = value;
  }
  public resetOauthParams() {
    this._oauthParams.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get oauthParamsInput() {
    return this._oauthParams.internalValue;
  }

  // on_backpressure - computed: true, optional: true, required: false
  private _onBackpressure?: string; 
  public get onBackpressure() {
    return this.getStringAttribute('on_backpressure');
  }
  public set onBackpressure(value: string) {
    this._onBackpressure = value;
  }
  public resetOnBackpressure() {
    this._onBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get onBackpressureInput() {
    return this._onBackpressure;
  }

  // org - computed: false, optional: true, required: false
  private _org?: string; 
  public get org() {
    return this.getStringAttribute('org');
  }
  public set org(value: string) {
    this._org = value;
  }
  public resetOrg() {
    this._org = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get orgInput() {
    return this._org;
  }

  // password - computed: false, optional: true, required: false
  private _password?: string; 
  public get password() {
    return this.getStringAttribute('password');
  }
  public set password(value: string) {
    this._password = value;
  }
  public resetPassword() {
    this._password = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passwordInput() {
    return this._password;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // pq_compress - computed: true, optional: true, required: false
  private _pqCompress?: string; 
  public get pqCompress() {
    return this.getStringAttribute('pq_compress');
  }
  public set pqCompress(value: string) {
    this._pqCompress = value;
  }
  public resetPqCompress() {
    this._pqCompress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqCompressInput() {
    return this._pqCompress;
  }

  // pq_controls - computed: false, optional: true, required: false
  private _pqControls = new PackDestinationOutputInfluxdbPqControlsOutputReference(this, "pq_controls");
  public get pqControls() {
    return this._pqControls;
  }
  public putPqControls(value: PackDestinationOutputInfluxdbPqControls) {
    this._pqControls.internalValue = value;
  }
  public resetPqControls() {
    this._pqControls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqControlsInput() {
    return this._pqControls.internalValue;
  }

  // pq_max_file_size - computed: true, optional: true, required: false
  private _pqMaxFileSize?: string; 
  public get pqMaxFileSize() {
    return this.getStringAttribute('pq_max_file_size');
  }
  public set pqMaxFileSize(value: string) {
    this._pqMaxFileSize = value;
  }
  public resetPqMaxFileSize() {
    this._pqMaxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxFileSizeInput() {
    return this._pqMaxFileSize;
  }

  // pq_max_size - computed: true, optional: true, required: false
  private _pqMaxSize?: string; 
  public get pqMaxSize() {
    return this.getStringAttribute('pq_max_size');
  }
  public set pqMaxSize(value: string) {
    this._pqMaxSize = value;
  }
  public resetPqMaxSize() {
    this._pqMaxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxSizeInput() {
    return this._pqMaxSize;
  }

  // pq_mode - computed: true, optional: true, required: false
  private _pqMode?: string; 
  public get pqMode() {
    return this.getStringAttribute('pq_mode');
  }
  public set pqMode(value: string) {
    this._pqMode = value;
  }
  public resetPqMode() {
    this._pqMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqModeInput() {
    return this._pqMode;
  }

  // pq_on_backpressure - computed: true, optional: true, required: false
  private _pqOnBackpressure?: string; 
  public get pqOnBackpressure() {
    return this.getStringAttribute('pq_on_backpressure');
  }
  public set pqOnBackpressure(value: string) {
    this._pqOnBackpressure = value;
  }
  public resetPqOnBackpressure() {
    this._pqOnBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqOnBackpressureInput() {
    return this._pqOnBackpressure;
  }

  // pq_path - computed: true, optional: true, required: false
  private _pqPath?: string; 
  public get pqPath() {
    return this.getStringAttribute('pq_path');
  }
  public set pqPath(value: string) {
    this._pqPath = value;
  }
  public resetPqPath() {
    this._pqPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqPathInput() {
    return this._pqPath;
  }

  // reject_unauthorized - computed: true, optional: true, required: false
  private _rejectUnauthorized?: boolean | cdktf.IResolvable; 
  public get rejectUnauthorized() {
    return this.getBooleanAttribute('reject_unauthorized');
  }
  public set rejectUnauthorized(value: boolean | cdktf.IResolvable) {
    this._rejectUnauthorized = value;
  }
  public resetRejectUnauthorized() {
    this._rejectUnauthorized = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectUnauthorizedInput() {
    return this._rejectUnauthorized;
  }

  // response_honor_retry_after_header - computed: true, optional: true, required: false
  private _responseHonorRetryAfterHeader?: boolean | cdktf.IResolvable; 
  public get responseHonorRetryAfterHeader() {
    return this.getBooleanAttribute('response_honor_retry_after_header');
  }
  public set responseHonorRetryAfterHeader(value: boolean | cdktf.IResolvable) {
    this._responseHonorRetryAfterHeader = value;
  }
  public resetResponseHonorRetryAfterHeader() {
    this._responseHonorRetryAfterHeader = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get responseHonorRetryAfterHeaderInput() {
    return this._responseHonorRetryAfterHeader;
  }

  // response_retry_settings - computed: false, optional: true, required: false
  private _responseRetrySettings = new PackDestinationOutputInfluxdbResponseRetrySettingsList(this, "response_retry_settings", false);
  public get responseRetrySettings() {
    return this._responseRetrySettings;
  }
  public putResponseRetrySettings(value: PackDestinationOutputInfluxdbResponseRetrySettings[] | cdktf.IResolvable) {
    this._responseRetrySettings.internalValue = value;
  }
  public resetResponseRetrySettings() {
    this._responseRetrySettings.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get responseRetrySettingsInput() {
    return this._responseRetrySettings.internalValue;
  }

  // safe_headers - computed: true, optional: true, required: false
  private _safeHeaders?: string[]; 
  public get safeHeaders() {
    return this.getListAttribute('safe_headers');
  }
  public set safeHeaders(value: string[]) {
    this._safeHeaders = value;
  }
  public resetSafeHeaders() {
    this._safeHeaders = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get safeHeadersInput() {
    return this._safeHeaders;
  }

  // secret - computed: false, optional: true, required: false
  private _secret?: string; 
  public get secret() {
    return this.getStringAttribute('secret');
  }
  public set secret(value: string) {
    this._secret = value;
  }
  public resetSecret() {
    this._secret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretInput() {
    return this._secret;
  }

  // secret_param_name - computed: false, optional: true, required: false
  private _secretParamName?: string; 
  public get secretParamName() {
    return this.getStringAttribute('secret_param_name');
  }
  public set secretParamName(value: string) {
    this._secretParamName = value;
  }
  public resetSecretParamName() {
    this._secretParamName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretParamNameInput() {
    return this._secretParamName;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // system_fields - computed: true, optional: true, required: false
  private _systemFields?: string[]; 
  public get systemFields() {
    return this.getListAttribute('system_fields');
  }
  public set systemFields(value: string[]) {
    this._systemFields = value;
  }
  public resetSystemFields() {
    this._systemFields = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get systemFieldsInput() {
    return this._systemFields;
  }

  // text_secret - computed: false, optional: true, required: false
  private _textSecret?: string; 
  public get textSecret() {
    return this.getStringAttribute('text_secret');
  }
  public set textSecret(value: string) {
    this._textSecret = value;
  }
  public resetTextSecret() {
    this._textSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get textSecretInput() {
    return this._textSecret;
  }

  // timeout_retry_settings - computed: false, optional: true, required: false
  private _timeoutRetrySettings = new PackDestinationOutputInfluxdbTimeoutRetrySettingsOutputReference(this, "timeout_retry_settings");
  public get timeoutRetrySettings() {
    return this._timeoutRetrySettings;
  }
  public putTimeoutRetrySettings(value: PackDestinationOutputInfluxdbTimeoutRetrySettings) {
    this._timeoutRetrySettings.internalValue = value;
  }
  public resetTimeoutRetrySettings() {
    this._timeoutRetrySettings.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutRetrySettingsInput() {
    return this._timeoutRetrySettings.internalValue;
  }

  // timeout_sec - computed: true, optional: true, required: false
  private _timeoutSec?: number; 
  public get timeoutSec() {
    return this.getNumberAttribute('timeout_sec');
  }
  public set timeoutSec(value: number) {
    this._timeoutSec = value;
  }
  public resetTimeoutSec() {
    this._timeoutSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutSecInput() {
    return this._timeoutSec;
  }

  // timestamp_precision - computed: true, optional: true, required: false
  private _timestampPrecision?: string; 
  public get timestampPrecision() {
    return this.getStringAttribute('timestamp_precision');
  }
  public set timestampPrecision(value: string) {
    this._timestampPrecision = value;
  }
  public resetTimestampPrecision() {
    this._timestampPrecision = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timestampPrecisionInput() {
    return this._timestampPrecision;
  }

  // token - computed: false, optional: true, required: false
  private _token?: string; 
  public get token() {
    return this.getStringAttribute('token');
  }
  public set token(value: string) {
    this._token = value;
  }
  public resetToken() {
    this._token = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tokenInput() {
    return this._token;
  }

  // token_attribute_name - computed: false, optional: true, required: false
  private _tokenAttributeName?: string; 
  public get tokenAttributeName() {
    return this.getStringAttribute('token_attribute_name');
  }
  public set tokenAttributeName(value: string) {
    this._tokenAttributeName = value;
  }
  public resetTokenAttributeName() {
    this._tokenAttributeName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tokenAttributeNameInput() {
    return this._tokenAttributeName;
  }

  // token_timeout_secs - computed: true, optional: true, required: false
  private _tokenTimeoutSecs?: number; 
  public get tokenTimeoutSecs() {
    return this.getNumberAttribute('token_timeout_secs');
  }
  public set tokenTimeoutSecs(value: number) {
    this._tokenTimeoutSecs = value;
  }
  public resetTokenTimeoutSecs() {
    this._tokenTimeoutSecs = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tokenTimeoutSecsInput() {
    return this._tokenTimeoutSecs;
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // url - computed: false, optional: false, required: true
  private _url?: string; 
  public get url() {
    return this.getStringAttribute('url');
  }
  public set url(value: string) {
    this._url = value;
  }
  // Temporarily expose input value. Use with caution.
  public get urlInput() {
    return this._url;
  }

  // use_round_robin_dns - computed: true, optional: true, required: false
  private _useRoundRobinDns?: boolean | cdktf.IResolvable; 
  public get useRoundRobinDns() {
    return this.getBooleanAttribute('use_round_robin_dns');
  }
  public set useRoundRobinDns(value: boolean | cdktf.IResolvable) {
    this._useRoundRobinDns = value;
  }
  public resetUseRoundRobinDns() {
    this._useRoundRobinDns = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get useRoundRobinDnsInput() {
    return this._useRoundRobinDns;
  }

  // use_v2_api - computed: true, optional: true, required: false
  private _useV2Api?: boolean | cdktf.IResolvable; 
  public get useV2Api() {
    return this.getBooleanAttribute('use_v2_api');
  }
  public set useV2Api(value: boolean | cdktf.IResolvable) {
    this._useV2Api = value;
  }
  public resetUseV2Api() {
    this._useV2Api = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get useV2ApiInput() {
    return this._useV2Api;
  }

  // username - computed: false, optional: true, required: false
  private _username?: string; 
  public get username() {
    return this.getStringAttribute('username');
  }
  public set username(value: string) {
    this._username = value;
  }
  public resetUsername() {
    this._username = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usernameInput() {
    return this._username;
  }

  // value_field_name - computed: true, optional: true, required: false
  private _valueFieldName?: string; 
  public get valueFieldName() {
    return this.getStringAttribute('value_field_name');
  }
  public set valueFieldName(value: string) {
    this._valueFieldName = value;
  }
  public resetValueFieldName() {
    this._valueFieldName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get valueFieldNameInput() {
    return this._valueFieldName;
  }
}
export interface PackDestinationOutputKafkaKafkaSchemaRegistryAuth {
  /**
  * Select or create a secret that references your credentials
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#credentials_secret PackDestination#credentials_secret}
  */
  readonly credentialsSecret?: string;
  /**
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#disabled PackDestination#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
}

export function packDestinationOutputKafkaKafkaSchemaRegistryAuthToTerraform(struct?: PackDestinationOutputKafkaKafkaSchemaRegistryAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    credentials_secret: cdktf.stringToTerraform(struct!.credentialsSecret),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
  }
}


export function packDestinationOutputKafkaKafkaSchemaRegistryAuthToHclTerraform(struct?: PackDestinationOutputKafkaKafkaSchemaRegistryAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    credentials_secret: {
      value: cdktf.stringToHclTerraform(struct!.credentialsSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputKafkaKafkaSchemaRegistryAuthOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackDestinationOutputKafkaKafkaSchemaRegistryAuth | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._credentialsSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.credentialsSecret = this._credentialsSecret;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputKafkaKafkaSchemaRegistryAuth | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._credentialsSecret = undefined;
      this._disabled = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._credentialsSecret = value.credentialsSecret;
      this._disabled = value.disabled;
    }
  }

  // credentials_secret - computed: false, optional: true, required: false
  private _credentialsSecret?: string; 
  public get credentialsSecret() {
    return this.getStringAttribute('credentials_secret');
  }
  public set credentialsSecret(value: string) {
    this._credentialsSecret = value;
  }
  public resetCredentialsSecret() {
    this._credentialsSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get credentialsSecretInput() {
    return this._credentialsSecret;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }
}
export interface PackDestinationOutputKafkaKafkaSchemaRegistryTls {
  /**
  * Path on client in which to find CA certificates to verify the server's cert. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#ca_path PackDestination#ca_path}
  */
  readonly caPath?: string;
  /**
  * Path on client in which to find certificates to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#cert_path PackDestination#cert_path}
  */
  readonly certPath?: string;
  /**
  * The name of the predefined certificate
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#certificate_name PackDestination#certificate_name}
  */
  readonly certificateName?: string;
  /**
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#disabled PackDestination#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_version PackDestination#max_version}
  */
  readonly maxVersion?: string;
  /**
  * must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#min_version PackDestination#min_version}
  */
  readonly minVersion?: string;
  /**
  * Passphrase to use to decrypt private key
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#passphrase PackDestination#passphrase}
  */
  readonly passphrase?: string;
  /**
  * Path on client in which to find the private key to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#priv_key_path PackDestination#priv_key_path}
  */
  readonly privKeyPath?: string;
  /**
  * Reject certificates that are not authorized by a CA in the CA certificate path, or by another 
  *                     trusted CA (such as the system's). Defaults to Enabled. Overrides the toggle from Advanced Settings, when also present.
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#reject_unauthorized PackDestination#reject_unauthorized}
  */
  readonly rejectUnauthorized?: boolean | cdktf.IResolvable;
  /**
  * Server name for the SNI (Server Name Indication) TLS extension. It must be a host name, and not an IP address.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#servername PackDestination#servername}
  */
  readonly servername?: string;
}

export function packDestinationOutputKafkaKafkaSchemaRegistryTlsToTerraform(struct?: PackDestinationOutputKafkaKafkaSchemaRegistryTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ca_path: cdktf.stringToTerraform(struct!.caPath),
    cert_path: cdktf.stringToTerraform(struct!.certPath),
    certificate_name: cdktf.stringToTerraform(struct!.certificateName),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    max_version: cdktf.stringToTerraform(struct!.maxVersion),
    min_version: cdktf.stringToTerraform(struct!.minVersion),
    passphrase: cdktf.stringToTerraform(struct!.passphrase),
    priv_key_path: cdktf.stringToTerraform(struct!.privKeyPath),
    reject_unauthorized: cdktf.booleanToTerraform(struct!.rejectUnauthorized),
    servername: cdktf.stringToTerraform(struct!.servername),
  }
}


export function packDestinationOutputKafkaKafkaSchemaRegistryTlsToHclTerraform(struct?: PackDestinationOutputKafkaKafkaSchemaRegistryTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ca_path: {
      value: cdktf.stringToHclTerraform(struct!.caPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    cert_path: {
      value: cdktf.stringToHclTerraform(struct!.certPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    certificate_name: {
      value: cdktf.stringToHclTerraform(struct!.certificateName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    max_version: {
      value: cdktf.stringToHclTerraform(struct!.maxVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    min_version: {
      value: cdktf.stringToHclTerraform(struct!.minVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    passphrase: {
      value: cdktf.stringToHclTerraform(struct!.passphrase),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    priv_key_path: {
      value: cdktf.stringToHclTerraform(struct!.privKeyPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reject_unauthorized: {
      value: cdktf.booleanToHclTerraform(struct!.rejectUnauthorized),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    servername: {
      value: cdktf.stringToHclTerraform(struct!.servername),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputKafkaKafkaSchemaRegistryTlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackDestinationOutputKafkaKafkaSchemaRegistryTls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._caPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.caPath = this._caPath;
    }
    if (this._certPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.certPath = this._certPath;
    }
    if (this._certificateName !== undefined) {
      hasAnyValues = true;
      internalValueResult.certificateName = this._certificateName;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._maxVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxVersion = this._maxVersion;
    }
    if (this._minVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.minVersion = this._minVersion;
    }
    if (this._passphrase !== undefined) {
      hasAnyValues = true;
      internalValueResult.passphrase = this._passphrase;
    }
    if (this._privKeyPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.privKeyPath = this._privKeyPath;
    }
    if (this._rejectUnauthorized !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectUnauthorized = this._rejectUnauthorized;
    }
    if (this._servername !== undefined) {
      hasAnyValues = true;
      internalValueResult.servername = this._servername;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputKafkaKafkaSchemaRegistryTls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._caPath = undefined;
      this._certPath = undefined;
      this._certificateName = undefined;
      this._disabled = undefined;
      this._maxVersion = undefined;
      this._minVersion = undefined;
      this._passphrase = undefined;
      this._privKeyPath = undefined;
      this._rejectUnauthorized = undefined;
      this._servername = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._caPath = value.caPath;
      this._certPath = value.certPath;
      this._certificateName = value.certificateName;
      this._disabled = value.disabled;
      this._maxVersion = value.maxVersion;
      this._minVersion = value.minVersion;
      this._passphrase = value.passphrase;
      this._privKeyPath = value.privKeyPath;
      this._rejectUnauthorized = value.rejectUnauthorized;
      this._servername = value.servername;
    }
  }

  // ca_path - computed: false, optional: true, required: false
  private _caPath?: string; 
  public get caPath() {
    return this.getStringAttribute('ca_path');
  }
  public set caPath(value: string) {
    this._caPath = value;
  }
  public resetCaPath() {
    this._caPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get caPathInput() {
    return this._caPath;
  }

  // cert_path - computed: false, optional: true, required: false
  private _certPath?: string; 
  public get certPath() {
    return this.getStringAttribute('cert_path');
  }
  public set certPath(value: string) {
    this._certPath = value;
  }
  public resetCertPath() {
    this._certPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certPathInput() {
    return this._certPath;
  }

  // certificate_name - computed: false, optional: true, required: false
  private _certificateName?: string; 
  public get certificateName() {
    return this.getStringAttribute('certificate_name');
  }
  public set certificateName(value: string) {
    this._certificateName = value;
  }
  public resetCertificateName() {
    this._certificateName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certificateNameInput() {
    return this._certificateName;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // max_version - computed: false, optional: true, required: false
  private _maxVersion?: string; 
  public get maxVersion() {
    return this.getStringAttribute('max_version');
  }
  public set maxVersion(value: string) {
    this._maxVersion = value;
  }
  public resetMaxVersion() {
    this._maxVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxVersionInput() {
    return this._maxVersion;
  }

  // min_version - computed: false, optional: true, required: false
  private _minVersion?: string; 
  public get minVersion() {
    return this.getStringAttribute('min_version');
  }
  public set minVersion(value: string) {
    this._minVersion = value;
  }
  public resetMinVersion() {
    this._minVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get minVersionInput() {
    return this._minVersion;
  }

  // passphrase - computed: false, optional: true, required: false
  private _passphrase?: string; 
  public get passphrase() {
    return this.getStringAttribute('passphrase');
  }
  public set passphrase(value: string) {
    this._passphrase = value;
  }
  public resetPassphrase() {
    this._passphrase = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passphraseInput() {
    return this._passphrase;
  }

  // priv_key_path - computed: false, optional: true, required: false
  private _privKeyPath?: string; 
  public get privKeyPath() {
    return this.getStringAttribute('priv_key_path');
  }
  public set privKeyPath(value: string) {
    this._privKeyPath = value;
  }
  public resetPrivKeyPath() {
    this._privKeyPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get privKeyPathInput() {
    return this._privKeyPath;
  }

  // reject_unauthorized - computed: true, optional: true, required: false
  private _rejectUnauthorized?: boolean | cdktf.IResolvable; 
  public get rejectUnauthorized() {
    return this.getBooleanAttribute('reject_unauthorized');
  }
  public set rejectUnauthorized(value: boolean | cdktf.IResolvable) {
    this._rejectUnauthorized = value;
  }
  public resetRejectUnauthorized() {
    this._rejectUnauthorized = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectUnauthorizedInput() {
    return this._rejectUnauthorized;
  }

  // servername - computed: false, optional: true, required: false
  private _servername?: string; 
  public get servername() {
    return this.getStringAttribute('servername');
  }
  public set servername(value: string) {
    this._servername = value;
  }
  public resetServername() {
    this._servername = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get servernameInput() {
    return this._servername;
  }
}
export interface PackDestinationOutputKafkaKafkaSchemaRegistry {
  /**
  * Credentials to use when authenticating with the schema registry using basic HTTP authentication
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#auth PackDestination#auth}
  */
  readonly auth?: PackDestinationOutputKafkaKafkaSchemaRegistryAuth;
  /**
  * Maximum time to wait for a Schema Registry connection to complete successfully. Default: 30000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#connection_timeout PackDestination#connection_timeout}
  */
  readonly connectionTimeout?: number;
  /**
  * Used when __keySchemaIdOut is not present, to transform key values, leave blank if key transformation is not required by default.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#default_key_schema_id PackDestination#default_key_schema_id}
  */
  readonly defaultKeySchemaId?: number;
  /**
  * Used when __valueSchemaIdOut is not present, to transform _raw, leave blank if value transformation is not required by default.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#default_value_schema_id PackDestination#default_value_schema_id}
  */
  readonly defaultValueSchemaId?: number;
  /**
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#disabled PackDestination#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * Maximum number of times to try fetching schemas from the Schema Registry. Default: 1
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_retries PackDestination#max_retries}
  */
  readonly maxRetries?: number;
  /**
  * Maximum time to wait for the Schema Registry to respond to a request. Default: 30000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#request_timeout PackDestination#request_timeout}
  */
  readonly requestTimeout?: number;
  /**
  * URL for accessing the Confluent Schema Registry. Example: http://localhost:8081. To connect over TLS, use https instead of http. Default: "http://localhost:8081"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#schema_registry_url PackDestination#schema_registry_url}
  */
  readonly schemaRegistryUrl?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#tls PackDestination#tls}
  */
  readonly tls?: PackDestinationOutputKafkaKafkaSchemaRegistryTls;
}

export function packDestinationOutputKafkaKafkaSchemaRegistryToTerraform(struct?: PackDestinationOutputKafkaKafkaSchemaRegistry | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    auth: packDestinationOutputKafkaKafkaSchemaRegistryAuthToTerraform(struct!.auth),
    connection_timeout: cdktf.numberToTerraform(struct!.connectionTimeout),
    default_key_schema_id: cdktf.numberToTerraform(struct!.defaultKeySchemaId),
    default_value_schema_id: cdktf.numberToTerraform(struct!.defaultValueSchemaId),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    max_retries: cdktf.numberToTerraform(struct!.maxRetries),
    request_timeout: cdktf.numberToTerraform(struct!.requestTimeout),
    schema_registry_url: cdktf.stringToTerraform(struct!.schemaRegistryUrl),
    tls: packDestinationOutputKafkaKafkaSchemaRegistryTlsToTerraform(struct!.tls),
  }
}


export function packDestinationOutputKafkaKafkaSchemaRegistryToHclTerraform(struct?: PackDestinationOutputKafkaKafkaSchemaRegistry | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    auth: {
      value: packDestinationOutputKafkaKafkaSchemaRegistryAuthToHclTerraform(struct!.auth),
      isBlock: true,
      type: "struct",
      storageClassType: "PackDestinationOutputKafkaKafkaSchemaRegistryAuth",
    },
    connection_timeout: {
      value: cdktf.numberToHclTerraform(struct!.connectionTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    default_key_schema_id: {
      value: cdktf.numberToHclTerraform(struct!.defaultKeySchemaId),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    default_value_schema_id: {
      value: cdktf.numberToHclTerraform(struct!.defaultValueSchemaId),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    max_retries: {
      value: cdktf.numberToHclTerraform(struct!.maxRetries),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    request_timeout: {
      value: cdktf.numberToHclTerraform(struct!.requestTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    schema_registry_url: {
      value: cdktf.stringToHclTerraform(struct!.schemaRegistryUrl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tls: {
      value: packDestinationOutputKafkaKafkaSchemaRegistryTlsToHclTerraform(struct!.tls),
      isBlock: true,
      type: "struct",
      storageClassType: "PackDestinationOutputKafkaKafkaSchemaRegistryTls",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputKafkaKafkaSchemaRegistryOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackDestinationOutputKafkaKafkaSchemaRegistry | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._auth?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.auth = this._auth?.internalValue;
    }
    if (this._connectionTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.connectionTimeout = this._connectionTimeout;
    }
    if (this._defaultKeySchemaId !== undefined) {
      hasAnyValues = true;
      internalValueResult.defaultKeySchemaId = this._defaultKeySchemaId;
    }
    if (this._defaultValueSchemaId !== undefined) {
      hasAnyValues = true;
      internalValueResult.defaultValueSchemaId = this._defaultValueSchemaId;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._maxRetries !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxRetries = this._maxRetries;
    }
    if (this._requestTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.requestTimeout = this._requestTimeout;
    }
    if (this._schemaRegistryUrl !== undefined) {
      hasAnyValues = true;
      internalValueResult.schemaRegistryUrl = this._schemaRegistryUrl;
    }
    if (this._tls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tls = this._tls?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputKafkaKafkaSchemaRegistry | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._auth.internalValue = undefined;
      this._connectionTimeout = undefined;
      this._defaultKeySchemaId = undefined;
      this._defaultValueSchemaId = undefined;
      this._disabled = undefined;
      this._maxRetries = undefined;
      this._requestTimeout = undefined;
      this._schemaRegistryUrl = undefined;
      this._tls.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._auth.internalValue = value.auth;
      this._connectionTimeout = value.connectionTimeout;
      this._defaultKeySchemaId = value.defaultKeySchemaId;
      this._defaultValueSchemaId = value.defaultValueSchemaId;
      this._disabled = value.disabled;
      this._maxRetries = value.maxRetries;
      this._requestTimeout = value.requestTimeout;
      this._schemaRegistryUrl = value.schemaRegistryUrl;
      this._tls.internalValue = value.tls;
    }
  }

  // auth - computed: false, optional: true, required: false
  private _auth = new PackDestinationOutputKafkaKafkaSchemaRegistryAuthOutputReference(this, "auth");
  public get auth() {
    return this._auth;
  }
  public putAuth(value: PackDestinationOutputKafkaKafkaSchemaRegistryAuth) {
    this._auth.internalValue = value;
  }
  public resetAuth() {
    this._auth.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authInput() {
    return this._auth.internalValue;
  }

  // connection_timeout - computed: true, optional: true, required: false
  private _connectionTimeout?: number; 
  public get connectionTimeout() {
    return this.getNumberAttribute('connection_timeout');
  }
  public set connectionTimeout(value: number) {
    this._connectionTimeout = value;
  }
  public resetConnectionTimeout() {
    this._connectionTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectionTimeoutInput() {
    return this._connectionTimeout;
  }

  // default_key_schema_id - computed: false, optional: true, required: false
  private _defaultKeySchemaId?: number; 
  public get defaultKeySchemaId() {
    return this.getNumberAttribute('default_key_schema_id');
  }
  public set defaultKeySchemaId(value: number) {
    this._defaultKeySchemaId = value;
  }
  public resetDefaultKeySchemaId() {
    this._defaultKeySchemaId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get defaultKeySchemaIdInput() {
    return this._defaultKeySchemaId;
  }

  // default_value_schema_id - computed: false, optional: true, required: false
  private _defaultValueSchemaId?: number; 
  public get defaultValueSchemaId() {
    return this.getNumberAttribute('default_value_schema_id');
  }
  public set defaultValueSchemaId(value: number) {
    this._defaultValueSchemaId = value;
  }
  public resetDefaultValueSchemaId() {
    this._defaultValueSchemaId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get defaultValueSchemaIdInput() {
    return this._defaultValueSchemaId;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // max_retries - computed: true, optional: true, required: false
  private _maxRetries?: number; 
  public get maxRetries() {
    return this.getNumberAttribute('max_retries');
  }
  public set maxRetries(value: number) {
    this._maxRetries = value;
  }
  public resetMaxRetries() {
    this._maxRetries = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxRetriesInput() {
    return this._maxRetries;
  }

  // request_timeout - computed: true, optional: true, required: false
  private _requestTimeout?: number; 
  public get requestTimeout() {
    return this.getNumberAttribute('request_timeout');
  }
  public set requestTimeout(value: number) {
    this._requestTimeout = value;
  }
  public resetRequestTimeout() {
    this._requestTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestTimeoutInput() {
    return this._requestTimeout;
  }

  // schema_registry_url - computed: true, optional: true, required: false
  private _schemaRegistryUrl?: string; 
  public get schemaRegistryUrl() {
    return this.getStringAttribute('schema_registry_url');
  }
  public set schemaRegistryUrl(value: string) {
    this._schemaRegistryUrl = value;
  }
  public resetSchemaRegistryUrl() {
    this._schemaRegistryUrl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get schemaRegistryUrlInput() {
    return this._schemaRegistryUrl;
  }

  // tls - computed: false, optional: true, required: false
  private _tls = new PackDestinationOutputKafkaKafkaSchemaRegistryTlsOutputReference(this, "tls");
  public get tls() {
    return this._tls;
  }
  public putTls(value: PackDestinationOutputKafkaKafkaSchemaRegistryTls) {
    this._tls.internalValue = value;
  }
  public resetTls() {
    this._tls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsInput() {
    return this._tls.internalValue;
  }
}
export interface PackDestinationOutputKafkaPqControls {
}

export function packDestinationOutputKafkaPqControlsToTerraform(struct?: PackDestinationOutputKafkaPqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function packDestinationOutputKafkaPqControlsToHclTerraform(struct?: PackDestinationOutputKafkaPqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class PackDestinationOutputKafkaPqControlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackDestinationOutputKafkaPqControls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputKafkaPqControls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface PackDestinationOutputKafkaSasl {
  /**
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#disabled PackDestination#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * Default: "plain"; must be one of ["plain", "scram-sha-256", "scram-sha-512", "kerberos"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#mechanism PackDestination#mechanism}
  */
  readonly mechanism?: string;
}

export function packDestinationOutputKafkaSaslToTerraform(struct?: PackDestinationOutputKafkaSasl | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    mechanism: cdktf.stringToTerraform(struct!.mechanism),
  }
}


export function packDestinationOutputKafkaSaslToHclTerraform(struct?: PackDestinationOutputKafkaSasl | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    mechanism: {
      value: cdktf.stringToHclTerraform(struct!.mechanism),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputKafkaSaslOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackDestinationOutputKafkaSasl | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._mechanism !== undefined) {
      hasAnyValues = true;
      internalValueResult.mechanism = this._mechanism;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputKafkaSasl | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._disabled = undefined;
      this._mechanism = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._disabled = value.disabled;
      this._mechanism = value.mechanism;
    }
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // mechanism - computed: true, optional: true, required: false
  private _mechanism?: string; 
  public get mechanism() {
    return this.getStringAttribute('mechanism');
  }
  public set mechanism(value: string) {
    this._mechanism = value;
  }
  public resetMechanism() {
    this._mechanism = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get mechanismInput() {
    return this._mechanism;
  }
}
export interface PackDestinationOutputKafkaTls {
  /**
  * Path on client in which to find CA certificates to verify the server's cert. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#ca_path PackDestination#ca_path}
  */
  readonly caPath?: string;
  /**
  * Path on client in which to find certificates to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#cert_path PackDestination#cert_path}
  */
  readonly certPath?: string;
  /**
  * The name of the predefined certificate
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#certificate_name PackDestination#certificate_name}
  */
  readonly certificateName?: string;
  /**
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#disabled PackDestination#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_version PackDestination#max_version}
  */
  readonly maxVersion?: string;
  /**
  * must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#min_version PackDestination#min_version}
  */
  readonly minVersion?: string;
  /**
  * Passphrase to use to decrypt private key
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#passphrase PackDestination#passphrase}
  */
  readonly passphrase?: string;
  /**
  * Path on client in which to find the private key to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#priv_key_path PackDestination#priv_key_path}
  */
  readonly privKeyPath?: string;
  /**
  * Reject certificates that are not authorized by a CA in the CA certificate path, or by another
  * 
  * 
  *                     trusted CA (such as the system's). Defaults to Enabled. Overrides the toggle from Advanced Settings, when also present.
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#reject_unauthorized PackDestination#reject_unauthorized}
  */
  readonly rejectUnauthorized?: boolean | cdktf.IResolvable;
  /**
  * Server name for the SNI (Server Name Indication) TLS extension. It must be a host name, and not an IP address.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#servername PackDestination#servername}
  */
  readonly servername?: string;
}

export function packDestinationOutputKafkaTlsToTerraform(struct?: PackDestinationOutputKafkaTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ca_path: cdktf.stringToTerraform(struct!.caPath),
    cert_path: cdktf.stringToTerraform(struct!.certPath),
    certificate_name: cdktf.stringToTerraform(struct!.certificateName),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    max_version: cdktf.stringToTerraform(struct!.maxVersion),
    min_version: cdktf.stringToTerraform(struct!.minVersion),
    passphrase: cdktf.stringToTerraform(struct!.passphrase),
    priv_key_path: cdktf.stringToTerraform(struct!.privKeyPath),
    reject_unauthorized: cdktf.booleanToTerraform(struct!.rejectUnauthorized),
    servername: cdktf.stringToTerraform(struct!.servername),
  }
}


export function packDestinationOutputKafkaTlsToHclTerraform(struct?: PackDestinationOutputKafkaTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ca_path: {
      value: cdktf.stringToHclTerraform(struct!.caPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    cert_path: {
      value: cdktf.stringToHclTerraform(struct!.certPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    certificate_name: {
      value: cdktf.stringToHclTerraform(struct!.certificateName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    max_version: {
      value: cdktf.stringToHclTerraform(struct!.maxVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    min_version: {
      value: cdktf.stringToHclTerraform(struct!.minVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    passphrase: {
      value: cdktf.stringToHclTerraform(struct!.passphrase),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    priv_key_path: {
      value: cdktf.stringToHclTerraform(struct!.privKeyPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reject_unauthorized: {
      value: cdktf.booleanToHclTerraform(struct!.rejectUnauthorized),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    servername: {
      value: cdktf.stringToHclTerraform(struct!.servername),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputKafkaTlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackDestinationOutputKafkaTls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._caPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.caPath = this._caPath;
    }
    if (this._certPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.certPath = this._certPath;
    }
    if (this._certificateName !== undefined) {
      hasAnyValues = true;
      internalValueResult.certificateName = this._certificateName;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._maxVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxVersion = this._maxVersion;
    }
    if (this._minVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.minVersion = this._minVersion;
    }
    if (this._passphrase !== undefined) {
      hasAnyValues = true;
      internalValueResult.passphrase = this._passphrase;
    }
    if (this._privKeyPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.privKeyPath = this._privKeyPath;
    }
    if (this._rejectUnauthorized !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectUnauthorized = this._rejectUnauthorized;
    }
    if (this._servername !== undefined) {
      hasAnyValues = true;
      internalValueResult.servername = this._servername;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputKafkaTls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._caPath = undefined;
      this._certPath = undefined;
      this._certificateName = undefined;
      this._disabled = undefined;
      this._maxVersion = undefined;
      this._minVersion = undefined;
      this._passphrase = undefined;
      this._privKeyPath = undefined;
      this._rejectUnauthorized = undefined;
      this._servername = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._caPath = value.caPath;
      this._certPath = value.certPath;
      this._certificateName = value.certificateName;
      this._disabled = value.disabled;
      this._maxVersion = value.maxVersion;
      this._minVersion = value.minVersion;
      this._passphrase = value.passphrase;
      this._privKeyPath = value.privKeyPath;
      this._rejectUnauthorized = value.rejectUnauthorized;
      this._servername = value.servername;
    }
  }

  // ca_path - computed: false, optional: true, required: false
  private _caPath?: string; 
  public get caPath() {
    return this.getStringAttribute('ca_path');
  }
  public set caPath(value: string) {
    this._caPath = value;
  }
  public resetCaPath() {
    this._caPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get caPathInput() {
    return this._caPath;
  }

  // cert_path - computed: false, optional: true, required: false
  private _certPath?: string; 
  public get certPath() {
    return this.getStringAttribute('cert_path');
  }
  public set certPath(value: string) {
    this._certPath = value;
  }
  public resetCertPath() {
    this._certPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certPathInput() {
    return this._certPath;
  }

  // certificate_name - computed: false, optional: true, required: false
  private _certificateName?: string; 
  public get certificateName() {
    return this.getStringAttribute('certificate_name');
  }
  public set certificateName(value: string) {
    this._certificateName = value;
  }
  public resetCertificateName() {
    this._certificateName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certificateNameInput() {
    return this._certificateName;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // max_version - computed: false, optional: true, required: false
  private _maxVersion?: string; 
  public get maxVersion() {
    return this.getStringAttribute('max_version');
  }
  public set maxVersion(value: string) {
    this._maxVersion = value;
  }
  public resetMaxVersion() {
    this._maxVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxVersionInput() {
    return this._maxVersion;
  }

  // min_version - computed: false, optional: true, required: false
  private _minVersion?: string; 
  public get minVersion() {
    return this.getStringAttribute('min_version');
  }
  public set minVersion(value: string) {
    this._minVersion = value;
  }
  public resetMinVersion() {
    this._minVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get minVersionInput() {
    return this._minVersion;
  }

  // passphrase - computed: false, optional: true, required: false
  private _passphrase?: string; 
  public get passphrase() {
    return this.getStringAttribute('passphrase');
  }
  public set passphrase(value: string) {
    this._passphrase = value;
  }
  public resetPassphrase() {
    this._passphrase = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passphraseInput() {
    return this._passphrase;
  }

  // priv_key_path - computed: false, optional: true, required: false
  private _privKeyPath?: string; 
  public get privKeyPath() {
    return this.getStringAttribute('priv_key_path');
  }
  public set privKeyPath(value: string) {
    this._privKeyPath = value;
  }
  public resetPrivKeyPath() {
    this._privKeyPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get privKeyPathInput() {
    return this._privKeyPath;
  }

  // reject_unauthorized - computed: true, optional: true, required: false
  private _rejectUnauthorized?: boolean | cdktf.IResolvable; 
  public get rejectUnauthorized() {
    return this.getBooleanAttribute('reject_unauthorized');
  }
  public set rejectUnauthorized(value: boolean | cdktf.IResolvable) {
    this._rejectUnauthorized = value;
  }
  public resetRejectUnauthorized() {
    this._rejectUnauthorized = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectUnauthorizedInput() {
    return this._rejectUnauthorized;
  }

  // servername - computed: false, optional: true, required: false
  private _servername?: string; 
  public get servername() {
    return this.getStringAttribute('servername');
  }
  public set servername(value: string) {
    this._servername = value;
  }
  public resetServername() {
    this._servername = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get servernameInput() {
    return this._servername;
  }
}
export interface PackDestinationOutputKafka {
  /**
  * Control the number of required acknowledgments. Default: 1; must be one of ["1", "0", "-1"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#ack PackDestination#ack}
  */
  readonly ack?: number;
  /**
  * Maximum time to wait for Kafka to respond to an authentication request. Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#authentication_timeout PackDestination#authentication_timeout}
  */
  readonly authenticationTimeout?: number;
  /**
  * Set the backoff multiplier (2-20) to control the retry frequency for failed messages. For faster retries, use a lower multiplier. For slower retries with more delay between attempts, use a higher multiplier. The multiplier is used in an exponential backoff formula; see the Kafka [documentation](https://kafka.js.org/docs/retry-detailed) for details. Default: 2
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#backoff_rate PackDestination#backoff_rate}
  */
  readonly backoffRate?: number;
  /**
  * Enter each Kafka bootstrap server you want to use. Specify hostname and port, e.g., mykafkabroker:9092, or just hostname, in which case @{product} will assign port 9092.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#brokers PackDestination#brokers}
  */
  readonly brokers: string[];
  /**
  * Codec to use to compress the data before sending to Kafka. Default: "gzip"; must be one of ["none", "gzip", "snappy", "lz4"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#compression PackDestination#compression}
  */
  readonly compression?: string;
  /**
  * Maximum time to wait for a connection to complete successfully. Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#connection_timeout PackDestination#connection_timeout}
  */
  readonly connectionTimeout?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#description PackDestination#description}
  */
  readonly description?: string;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#environment PackDestination#environment}
  */
  readonly environment?: string;
  /**
  * The maximum number of events you want the Destination to allow in a batch before forcing a flush. Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#flush_event_count PackDestination#flush_event_count}
  */
  readonly flushEventCount?: number;
  /**
  * The maximum amount of time you want the Destination to wait before forcing a flush. Shorter intervals tend to result in smaller batches being sent. Default: 1
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#flush_period_sec PackDestination#flush_period_sec}
  */
  readonly flushPeriodSec?: number;
  /**
  * Format to use to serialize events before writing to Kafka. Default: "json"; must be one of ["json", "raw", "protobuf"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#format PackDestination#format}
  */
  readonly format?: string;
  /**
  * Unique ID for this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#id PackDestination#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * Initial value used to calculate the retry, in milliseconds. Maximum is 600,000 ms (10 minutes). Default: 300
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#initial_backoff PackDestination#initial_backoff}
  */
  readonly initialBackoff?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#kafka_schema_registry PackDestination#kafka_schema_registry}
  */
  readonly kafkaSchemaRegistry?: PackDestinationOutputKafkaKafkaSchemaRegistry;
  /**
  * The maximum wait time for a retry, in milliseconds. Default (and minimum) is 30,000 ms (30 seconds); maximum is 180,000 ms (180 seconds). Default: 30000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_back_off PackDestination#max_back_off}
  */
  readonly maxBackOff?: number;
  /**
  * Maximum size of each record batch before compression. The value must not exceed the Kafka brokers' message.max.bytes setting. Default: 768
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_record_size_kb PackDestination#max_record_size_kb}
  */
  readonly maxRecordSizeKb?: number;
  /**
  * If messages are failing, you can set the maximum number of retries as high as 100 to prevent loss of data. Default: 5
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_retries PackDestination#max_retries}
  */
  readonly maxRetries?: number;
  /**
  * How to handle events when all receivers are exerting backpressure. Default: "block"; must be one of ["block", "drop", "queue"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#on_backpressure PackDestination#on_backpressure}
  */
  readonly onBackpressure?: string;
  /**
  * Pipeline to process data before sending out to this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pipeline PackDestination#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_compress PackDestination#pq_compress}
  */
  readonly pqCompress?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_controls PackDestination#pq_controls}
  */
  readonly pqControls?: PackDestinationOutputKafkaPqControls;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.). Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_max_file_size PackDestination#pq_max_file_size}
  */
  readonly pqMaxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_max_size PackDestination#pq_max_size}
  */
  readonly pqMaxSize?: string;
  /**
  * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem. Default: "error"; must be one of ["error", "backpressure", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_mode PackDestination#pq_mode}
  */
  readonly pqMode?: string;
  /**
  * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged. Default: "block"; must be one of ["block", "drop"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_on_backpressure PackDestination#pq_on_backpressure}
  */
  readonly pqOnBackpressure?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_path PackDestination#pq_path}
  */
  readonly pqPath?: string;
  /**
  * Select a set of Protobuf definitions for the events you want to send
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#protobuf_library_id PackDestination#protobuf_library_id}
  */
  readonly protobufLibraryId?: string;
  /**
  * Specifies a time window during which @{product} can reauthenticate if needed. Creates the window measuring backward from the moment when credentials are set to expire. Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#reauthentication_threshold PackDestination#reauthentication_threshold}
  */
  readonly reauthenticationThreshold?: number;
  /**
  * Maximum time to wait for Kafka to respond to a request. Default: 60000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#request_timeout PackDestination#request_timeout}
  */
  readonly requestTimeout?: number;
  /**
  * Authentication parameters to use when connecting to brokers. Using TLS is highly recommended.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#sasl PackDestination#sasl}
  */
  readonly sasl?: PackDestinationOutputKafkaSasl;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#streamtags PackDestination#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Fields to automatically add to events, such as cribl_pipe. Supports wildcards. Default: ["cribl_pipe"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#system_fields PackDestination#system_fields}
  */
  readonly systemFields?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#tls PackDestination#tls}
  */
  readonly tls?: PackDestinationOutputKafkaTls;
  /**
  * The topic to publish events to. Can be overridden using the __topicOut field.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#topic PackDestination#topic}
  */
  readonly topic: string;
  /**
  * must be "kafka"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#type PackDestination#type}
  */
  readonly type?: string;
}

export function packDestinationOutputKafkaToTerraform(struct?: PackDestinationOutputKafka | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ack: cdktf.numberToTerraform(struct!.ack),
    authentication_timeout: cdktf.numberToTerraform(struct!.authenticationTimeout),
    backoff_rate: cdktf.numberToTerraform(struct!.backoffRate),
    brokers: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.brokers),
    compression: cdktf.stringToTerraform(struct!.compression),
    connection_timeout: cdktf.numberToTerraform(struct!.connectionTimeout),
    description: cdktf.stringToTerraform(struct!.description),
    environment: cdktf.stringToTerraform(struct!.environment),
    flush_event_count: cdktf.numberToTerraform(struct!.flushEventCount),
    flush_period_sec: cdktf.numberToTerraform(struct!.flushPeriodSec),
    format: cdktf.stringToTerraform(struct!.format),
    id: cdktf.stringToTerraform(struct!.id),
    initial_backoff: cdktf.numberToTerraform(struct!.initialBackoff),
    kafka_schema_registry: packDestinationOutputKafkaKafkaSchemaRegistryToTerraform(struct!.kafkaSchemaRegistry),
    max_back_off: cdktf.numberToTerraform(struct!.maxBackOff),
    max_record_size_kb: cdktf.numberToTerraform(struct!.maxRecordSizeKb),
    max_retries: cdktf.numberToTerraform(struct!.maxRetries),
    on_backpressure: cdktf.stringToTerraform(struct!.onBackpressure),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    pq_compress: cdktf.stringToTerraform(struct!.pqCompress),
    pq_controls: packDestinationOutputKafkaPqControlsToTerraform(struct!.pqControls),
    pq_max_file_size: cdktf.stringToTerraform(struct!.pqMaxFileSize),
    pq_max_size: cdktf.stringToTerraform(struct!.pqMaxSize),
    pq_mode: cdktf.stringToTerraform(struct!.pqMode),
    pq_on_backpressure: cdktf.stringToTerraform(struct!.pqOnBackpressure),
    pq_path: cdktf.stringToTerraform(struct!.pqPath),
    protobuf_library_id: cdktf.stringToTerraform(struct!.protobufLibraryId),
    reauthentication_threshold: cdktf.numberToTerraform(struct!.reauthenticationThreshold),
    request_timeout: cdktf.numberToTerraform(struct!.requestTimeout),
    sasl: packDestinationOutputKafkaSaslToTerraform(struct!.sasl),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    system_fields: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.systemFields),
    tls: packDestinationOutputKafkaTlsToTerraform(struct!.tls),
    topic: cdktf.stringToTerraform(struct!.topic),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function packDestinationOutputKafkaToHclTerraform(struct?: PackDestinationOutputKafka | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ack: {
      value: cdktf.numberToHclTerraform(struct!.ack),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    authentication_timeout: {
      value: cdktf.numberToHclTerraform(struct!.authenticationTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    backoff_rate: {
      value: cdktf.numberToHclTerraform(struct!.backoffRate),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    brokers: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.brokers),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    compression: {
      value: cdktf.stringToHclTerraform(struct!.compression),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    connection_timeout: {
      value: cdktf.numberToHclTerraform(struct!.connectionTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    flush_event_count: {
      value: cdktf.numberToHclTerraform(struct!.flushEventCount),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    flush_period_sec: {
      value: cdktf.numberToHclTerraform(struct!.flushPeriodSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    format: {
      value: cdktf.stringToHclTerraform(struct!.format),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    initial_backoff: {
      value: cdktf.numberToHclTerraform(struct!.initialBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    kafka_schema_registry: {
      value: packDestinationOutputKafkaKafkaSchemaRegistryToHclTerraform(struct!.kafkaSchemaRegistry),
      isBlock: true,
      type: "struct",
      storageClassType: "PackDestinationOutputKafkaKafkaSchemaRegistry",
    },
    max_back_off: {
      value: cdktf.numberToHclTerraform(struct!.maxBackOff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_record_size_kb: {
      value: cdktf.numberToHclTerraform(struct!.maxRecordSizeKb),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_retries: {
      value: cdktf.numberToHclTerraform(struct!.maxRetries),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.onBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_compress: {
      value: cdktf.stringToHclTerraform(struct!.pqCompress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_controls: {
      value: packDestinationOutputKafkaPqControlsToHclTerraform(struct!.pqControls),
      isBlock: true,
      type: "struct",
      storageClassType: "PackDestinationOutputKafkaPqControls",
    },
    pq_max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_max_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_mode: {
      value: cdktf.stringToHclTerraform(struct!.pqMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.pqOnBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_path: {
      value: cdktf.stringToHclTerraform(struct!.pqPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    protobuf_library_id: {
      value: cdktf.stringToHclTerraform(struct!.protobufLibraryId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reauthentication_threshold: {
      value: cdktf.numberToHclTerraform(struct!.reauthenticationThreshold),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    request_timeout: {
      value: cdktf.numberToHclTerraform(struct!.requestTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    sasl: {
      value: packDestinationOutputKafkaSaslToHclTerraform(struct!.sasl),
      isBlock: true,
      type: "struct",
      storageClassType: "PackDestinationOutputKafkaSasl",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    system_fields: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.systemFields),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    tls: {
      value: packDestinationOutputKafkaTlsToHclTerraform(struct!.tls),
      isBlock: true,
      type: "struct",
      storageClassType: "PackDestinationOutputKafkaTls",
    },
    topic: {
      value: cdktf.stringToHclTerraform(struct!.topic),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputKafkaOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackDestinationOutputKafka | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._ack !== undefined) {
      hasAnyValues = true;
      internalValueResult.ack = this._ack;
    }
    if (this._authenticationTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.authenticationTimeout = this._authenticationTimeout;
    }
    if (this._backoffRate !== undefined) {
      hasAnyValues = true;
      internalValueResult.backoffRate = this._backoffRate;
    }
    if (this._brokers !== undefined) {
      hasAnyValues = true;
      internalValueResult.brokers = this._brokers;
    }
    if (this._compression !== undefined) {
      hasAnyValues = true;
      internalValueResult.compression = this._compression;
    }
    if (this._connectionTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.connectionTimeout = this._connectionTimeout;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._flushEventCount !== undefined) {
      hasAnyValues = true;
      internalValueResult.flushEventCount = this._flushEventCount;
    }
    if (this._flushPeriodSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.flushPeriodSec = this._flushPeriodSec;
    }
    if (this._format !== undefined) {
      hasAnyValues = true;
      internalValueResult.format = this._format;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._initialBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.initialBackoff = this._initialBackoff;
    }
    if (this._kafkaSchemaRegistry?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.kafkaSchemaRegistry = this._kafkaSchemaRegistry?.internalValue;
    }
    if (this._maxBackOff !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBackOff = this._maxBackOff;
    }
    if (this._maxRecordSizeKb !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxRecordSizeKb = this._maxRecordSizeKb;
    }
    if (this._maxRetries !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxRetries = this._maxRetries;
    }
    if (this._onBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.onBackpressure = this._onBackpressure;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._pqCompress !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqCompress = this._pqCompress;
    }
    if (this._pqControls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqControls = this._pqControls?.internalValue;
    }
    if (this._pqMaxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxFileSize = this._pqMaxFileSize;
    }
    if (this._pqMaxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxSize = this._pqMaxSize;
    }
    if (this._pqMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMode = this._pqMode;
    }
    if (this._pqOnBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqOnBackpressure = this._pqOnBackpressure;
    }
    if (this._pqPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqPath = this._pqPath;
    }
    if (this._protobufLibraryId !== undefined) {
      hasAnyValues = true;
      internalValueResult.protobufLibraryId = this._protobufLibraryId;
    }
    if (this._reauthenticationThreshold !== undefined) {
      hasAnyValues = true;
      internalValueResult.reauthenticationThreshold = this._reauthenticationThreshold;
    }
    if (this._requestTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.requestTimeout = this._requestTimeout;
    }
    if (this._sasl?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.sasl = this._sasl?.internalValue;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._systemFields !== undefined) {
      hasAnyValues = true;
      internalValueResult.systemFields = this._systemFields;
    }
    if (this._tls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tls = this._tls?.internalValue;
    }
    if (this._topic !== undefined) {
      hasAnyValues = true;
      internalValueResult.topic = this._topic;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputKafka | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._ack = undefined;
      this._authenticationTimeout = undefined;
      this._backoffRate = undefined;
      this._brokers = undefined;
      this._compression = undefined;
      this._connectionTimeout = undefined;
      this._description = undefined;
      this._environment = undefined;
      this._flushEventCount = undefined;
      this._flushPeriodSec = undefined;
      this._format = undefined;
      this._id = undefined;
      this._initialBackoff = undefined;
      this._kafkaSchemaRegistry.internalValue = undefined;
      this._maxBackOff = undefined;
      this._maxRecordSizeKb = undefined;
      this._maxRetries = undefined;
      this._onBackpressure = undefined;
      this._pipeline = undefined;
      this._pqCompress = undefined;
      this._pqControls.internalValue = undefined;
      this._pqMaxFileSize = undefined;
      this._pqMaxSize = undefined;
      this._pqMode = undefined;
      this._pqOnBackpressure = undefined;
      this._pqPath = undefined;
      this._protobufLibraryId = undefined;
      this._reauthenticationThreshold = undefined;
      this._requestTimeout = undefined;
      this._sasl.internalValue = undefined;
      this._streamtags = undefined;
      this._systemFields = undefined;
      this._tls.internalValue = undefined;
      this._topic = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._ack = value.ack;
      this._authenticationTimeout = value.authenticationTimeout;
      this._backoffRate = value.backoffRate;
      this._brokers = value.brokers;
      this._compression = value.compression;
      this._connectionTimeout = value.connectionTimeout;
      this._description = value.description;
      this._environment = value.environment;
      this._flushEventCount = value.flushEventCount;
      this._flushPeriodSec = value.flushPeriodSec;
      this._format = value.format;
      this._id = value.id;
      this._initialBackoff = value.initialBackoff;
      this._kafkaSchemaRegistry.internalValue = value.kafkaSchemaRegistry;
      this._maxBackOff = value.maxBackOff;
      this._maxRecordSizeKb = value.maxRecordSizeKb;
      this._maxRetries = value.maxRetries;
      this._onBackpressure = value.onBackpressure;
      this._pipeline = value.pipeline;
      this._pqCompress = value.pqCompress;
      this._pqControls.internalValue = value.pqControls;
      this._pqMaxFileSize = value.pqMaxFileSize;
      this._pqMaxSize = value.pqMaxSize;
      this._pqMode = value.pqMode;
      this._pqOnBackpressure = value.pqOnBackpressure;
      this._pqPath = value.pqPath;
      this._protobufLibraryId = value.protobufLibraryId;
      this._reauthenticationThreshold = value.reauthenticationThreshold;
      this._requestTimeout = value.requestTimeout;
      this._sasl.internalValue = value.sasl;
      this._streamtags = value.streamtags;
      this._systemFields = value.systemFields;
      this._tls.internalValue = value.tls;
      this._topic = value.topic;
      this._type = value.type;
    }
  }

  // ack - computed: true, optional: true, required: false
  private _ack?: number; 
  public get ack() {
    return this.getNumberAttribute('ack');
  }
  public set ack(value: number) {
    this._ack = value;
  }
  public resetAck() {
    this._ack = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ackInput() {
    return this._ack;
  }

  // authentication_timeout - computed: true, optional: true, required: false
  private _authenticationTimeout?: number; 
  public get authenticationTimeout() {
    return this.getNumberAttribute('authentication_timeout');
  }
  public set authenticationTimeout(value: number) {
    this._authenticationTimeout = value;
  }
  public resetAuthenticationTimeout() {
    this._authenticationTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authenticationTimeoutInput() {
    return this._authenticationTimeout;
  }

  // backoff_rate - computed: true, optional: true, required: false
  private _backoffRate?: number; 
  public get backoffRate() {
    return this.getNumberAttribute('backoff_rate');
  }
  public set backoffRate(value: number) {
    this._backoffRate = value;
  }
  public resetBackoffRate() {
    this._backoffRate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get backoffRateInput() {
    return this._backoffRate;
  }

  // brokers - computed: false, optional: false, required: true
  private _brokers?: string[]; 
  public get brokers() {
    return this.getListAttribute('brokers');
  }
  public set brokers(value: string[]) {
    this._brokers = value;
  }
  // Temporarily expose input value. Use with caution.
  public get brokersInput() {
    return this._brokers;
  }

  // compression - computed: true, optional: true, required: false
  private _compression?: string; 
  public get compression() {
    return this.getStringAttribute('compression');
  }
  public set compression(value: string) {
    this._compression = value;
  }
  public resetCompression() {
    this._compression = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressionInput() {
    return this._compression;
  }

  // connection_timeout - computed: true, optional: true, required: false
  private _connectionTimeout?: number; 
  public get connectionTimeout() {
    return this.getNumberAttribute('connection_timeout');
  }
  public set connectionTimeout(value: number) {
    this._connectionTimeout = value;
  }
  public resetConnectionTimeout() {
    this._connectionTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectionTimeoutInput() {
    return this._connectionTimeout;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // flush_event_count - computed: true, optional: true, required: false
  private _flushEventCount?: number; 
  public get flushEventCount() {
    return this.getNumberAttribute('flush_event_count');
  }
  public set flushEventCount(value: number) {
    this._flushEventCount = value;
  }
  public resetFlushEventCount() {
    this._flushEventCount = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get flushEventCountInput() {
    return this._flushEventCount;
  }

  // flush_period_sec - computed: true, optional: true, required: false
  private _flushPeriodSec?: number; 
  public get flushPeriodSec() {
    return this.getNumberAttribute('flush_period_sec');
  }
  public set flushPeriodSec(value: number) {
    this._flushPeriodSec = value;
  }
  public resetFlushPeriodSec() {
    this._flushPeriodSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get flushPeriodSecInput() {
    return this._flushPeriodSec;
  }

  // format - computed: true, optional: true, required: false
  private _format?: string; 
  public get format() {
    return this.getStringAttribute('format');
  }
  public set format(value: string) {
    this._format = value;
  }
  public resetFormat() {
    this._format = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get formatInput() {
    return this._format;
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // initial_backoff - computed: true, optional: true, required: false
  private _initialBackoff?: number; 
  public get initialBackoff() {
    return this.getNumberAttribute('initial_backoff');
  }
  public set initialBackoff(value: number) {
    this._initialBackoff = value;
  }
  public resetInitialBackoff() {
    this._initialBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get initialBackoffInput() {
    return this._initialBackoff;
  }

  // kafka_schema_registry - computed: false, optional: true, required: false
  private _kafkaSchemaRegistry = new PackDestinationOutputKafkaKafkaSchemaRegistryOutputReference(this, "kafka_schema_registry");
  public get kafkaSchemaRegistry() {
    return this._kafkaSchemaRegistry;
  }
  public putKafkaSchemaRegistry(value: PackDestinationOutputKafkaKafkaSchemaRegistry) {
    this._kafkaSchemaRegistry.internalValue = value;
  }
  public resetKafkaSchemaRegistry() {
    this._kafkaSchemaRegistry.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get kafkaSchemaRegistryInput() {
    return this._kafkaSchemaRegistry.internalValue;
  }

  // max_back_off - computed: true, optional: true, required: false
  private _maxBackOff?: number; 
  public get maxBackOff() {
    return this.getNumberAttribute('max_back_off');
  }
  public set maxBackOff(value: number) {
    this._maxBackOff = value;
  }
  public resetMaxBackOff() {
    this._maxBackOff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBackOffInput() {
    return this._maxBackOff;
  }

  // max_record_size_kb - computed: true, optional: true, required: false
  private _maxRecordSizeKb?: number; 
  public get maxRecordSizeKb() {
    return this.getNumberAttribute('max_record_size_kb');
  }
  public set maxRecordSizeKb(value: number) {
    this._maxRecordSizeKb = value;
  }
  public resetMaxRecordSizeKb() {
    this._maxRecordSizeKb = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxRecordSizeKbInput() {
    return this._maxRecordSizeKb;
  }

  // max_retries - computed: true, optional: true, required: false
  private _maxRetries?: number; 
  public get maxRetries() {
    return this.getNumberAttribute('max_retries');
  }
  public set maxRetries(value: number) {
    this._maxRetries = value;
  }
  public resetMaxRetries() {
    this._maxRetries = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxRetriesInput() {
    return this._maxRetries;
  }

  // on_backpressure - computed: true, optional: true, required: false
  private _onBackpressure?: string; 
  public get onBackpressure() {
    return this.getStringAttribute('on_backpressure');
  }
  public set onBackpressure(value: string) {
    this._onBackpressure = value;
  }
  public resetOnBackpressure() {
    this._onBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get onBackpressureInput() {
    return this._onBackpressure;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // pq_compress - computed: true, optional: true, required: false
  private _pqCompress?: string; 
  public get pqCompress() {
    return this.getStringAttribute('pq_compress');
  }
  public set pqCompress(value: string) {
    this._pqCompress = value;
  }
  public resetPqCompress() {
    this._pqCompress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqCompressInput() {
    return this._pqCompress;
  }

  // pq_controls - computed: false, optional: true, required: false
  private _pqControls = new PackDestinationOutputKafkaPqControlsOutputReference(this, "pq_controls");
  public get pqControls() {
    return this._pqControls;
  }
  public putPqControls(value: PackDestinationOutputKafkaPqControls) {
    this._pqControls.internalValue = value;
  }
  public resetPqControls() {
    this._pqControls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqControlsInput() {
    return this._pqControls.internalValue;
  }

  // pq_max_file_size - computed: true, optional: true, required: false
  private _pqMaxFileSize?: string; 
  public get pqMaxFileSize() {
    return this.getStringAttribute('pq_max_file_size');
  }
  public set pqMaxFileSize(value: string) {
    this._pqMaxFileSize = value;
  }
  public resetPqMaxFileSize() {
    this._pqMaxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxFileSizeInput() {
    return this._pqMaxFileSize;
  }

  // pq_max_size - computed: true, optional: true, required: false
  private _pqMaxSize?: string; 
  public get pqMaxSize() {
    return this.getStringAttribute('pq_max_size');
  }
  public set pqMaxSize(value: string) {
    this._pqMaxSize = value;
  }
  public resetPqMaxSize() {
    this._pqMaxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxSizeInput() {
    return this._pqMaxSize;
  }

  // pq_mode - computed: true, optional: true, required: false
  private _pqMode?: string; 
  public get pqMode() {
    return this.getStringAttribute('pq_mode');
  }
  public set pqMode(value: string) {
    this._pqMode = value;
  }
  public resetPqMode() {
    this._pqMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqModeInput() {
    return this._pqMode;
  }

  // pq_on_backpressure - computed: true, optional: true, required: false
  private _pqOnBackpressure?: string; 
  public get pqOnBackpressure() {
    return this.getStringAttribute('pq_on_backpressure');
  }
  public set pqOnBackpressure(value: string) {
    this._pqOnBackpressure = value;
  }
  public resetPqOnBackpressure() {
    this._pqOnBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqOnBackpressureInput() {
    return this._pqOnBackpressure;
  }

  // pq_path - computed: true, optional: true, required: false
  private _pqPath?: string; 
  public get pqPath() {
    return this.getStringAttribute('pq_path');
  }
  public set pqPath(value: string) {
    this._pqPath = value;
  }
  public resetPqPath() {
    this._pqPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqPathInput() {
    return this._pqPath;
  }

  // protobuf_library_id - computed: false, optional: true, required: false
  private _protobufLibraryId?: string; 
  public get protobufLibraryId() {
    return this.getStringAttribute('protobuf_library_id');
  }
  public set protobufLibraryId(value: string) {
    this._protobufLibraryId = value;
  }
  public resetProtobufLibraryId() {
    this._protobufLibraryId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get protobufLibraryIdInput() {
    return this._protobufLibraryId;
  }

  // reauthentication_threshold - computed: true, optional: true, required: false
  private _reauthenticationThreshold?: number; 
  public get reauthenticationThreshold() {
    return this.getNumberAttribute('reauthentication_threshold');
  }
  public set reauthenticationThreshold(value: number) {
    this._reauthenticationThreshold = value;
  }
  public resetReauthenticationThreshold() {
    this._reauthenticationThreshold = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get reauthenticationThresholdInput() {
    return this._reauthenticationThreshold;
  }

  // request_timeout - computed: true, optional: true, required: false
  private _requestTimeout?: number; 
  public get requestTimeout() {
    return this.getNumberAttribute('request_timeout');
  }
  public set requestTimeout(value: number) {
    this._requestTimeout = value;
  }
  public resetRequestTimeout() {
    this._requestTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestTimeoutInput() {
    return this._requestTimeout;
  }

  // sasl - computed: false, optional: true, required: false
  private _sasl = new PackDestinationOutputKafkaSaslOutputReference(this, "sasl");
  public get sasl() {
    return this._sasl;
  }
  public putSasl(value: PackDestinationOutputKafkaSasl) {
    this._sasl.internalValue = value;
  }
  public resetSasl() {
    this._sasl.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get saslInput() {
    return this._sasl.internalValue;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // system_fields - computed: true, optional: true, required: false
  private _systemFields?: string[]; 
  public get systemFields() {
    return this.getListAttribute('system_fields');
  }
  public set systemFields(value: string[]) {
    this._systemFields = value;
  }
  public resetSystemFields() {
    this._systemFields = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get systemFieldsInput() {
    return this._systemFields;
  }

  // tls - computed: false, optional: true, required: false
  private _tls = new PackDestinationOutputKafkaTlsOutputReference(this, "tls");
  public get tls() {
    return this._tls;
  }
  public putTls(value: PackDestinationOutputKafkaTls) {
    this._tls.internalValue = value;
  }
  public resetTls() {
    this._tls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsInput() {
    return this._tls.internalValue;
  }

  // topic - computed: false, optional: false, required: true
  private _topic?: string; 
  public get topic() {
    return this.getStringAttribute('topic');
  }
  public set topic(value: string) {
    this._topic = value;
  }
  // Temporarily expose input value. Use with caution.
  public get topicInput() {
    return this._topic;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface PackDestinationOutputKinesisPqControls {
}

export function packDestinationOutputKinesisPqControlsToTerraform(struct?: PackDestinationOutputKinesisPqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function packDestinationOutputKinesisPqControlsToHclTerraform(struct?: PackDestinationOutputKinesisPqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class PackDestinationOutputKinesisPqControlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackDestinationOutputKinesisPqControls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputKinesisPqControls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface PackDestinationOutputKinesis {
  /**
  * Batch events into a single record as NDJSON. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#as_ndjson PackDestination#as_ndjson}
  */
  readonly asNdjson?: boolean | cdktf.IResolvable;
  /**
  * Amazon Resource Name (ARN) of the role to assume
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#assume_role_arn PackDestination#assume_role_arn}
  */
  readonly assumeRoleArn?: string;
  /**
  * External ID to use when assuming role
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#assume_role_external_id PackDestination#assume_role_external_id}
  */
  readonly assumeRoleExternalId?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#aws_api_key PackDestination#aws_api_key}
  */
  readonly awsApiKey?: string;
  /**
  * AWS authentication method. Choose Auto to use IAM roles. Default: "auto"; must be one of ["auto", "manual", "secret"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#aws_authentication_method PackDestination#aws_authentication_method}
  */
  readonly awsAuthenticationMethod?: string;
  /**
  * Select or create a stored secret that references your access key and secret key
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#aws_secret PackDestination#aws_secret}
  */
  readonly awsSecret?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#aws_secret_key PackDestination#aws_secret_key}
  */
  readonly awsSecretKey?: string;
  /**
  * Compression type to use for records. Default: "gzip"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#compression PackDestination#compression}
  */
  readonly compression?: string;
  /**
  * Maximum number of ongoing put requests before blocking. Default: 5
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#concurrency PackDestination#concurrency}
  */
  readonly concurrency?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#description PackDestination#description}
  */
  readonly description?: string;
  /**
  * Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours). Default: 3600
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#duration_seconds PackDestination#duration_seconds}
  */
  readonly durationSeconds?: number;
  /**
  * Use Assume Role credentials to access Kinesis stream. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#enable_assume_role PackDestination#enable_assume_role}
  */
  readonly enableAssumeRole?: boolean | cdktf.IResolvable;
  /**
  * Kinesis stream service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to Kinesis stream-compatible endpoint.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#endpoint PackDestination#endpoint}
  */
  readonly endpoint?: string;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#environment PackDestination#environment}
  */
  readonly environment?: string;
  /**
  * Maximum time between requests. Small values could cause the payload size to be smaller than the configured Max record size. Default: 1
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#flush_period_sec PackDestination#flush_period_sec}
  */
  readonly flushPeriodSec?: number;
  /**
  * Unique ID for this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#id PackDestination#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * Maximum size (KB) of each individual record before compression. For uncompressed or non-compressible data 1MB is the max recommended size. Default: 1024
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_record_size_kb PackDestination#max_record_size_kb}
  */
  readonly maxRecordSizeKb?: number;
  /**
  * How to handle events when all receivers are exerting backpressure. Default: "block"; must be one of ["block", "drop", "queue"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#on_backpressure PackDestination#on_backpressure}
  */
  readonly onBackpressure?: string;
  /**
  * Pipeline to process data before sending out to this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pipeline PackDestination#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_compress PackDestination#pq_compress}
  */
  readonly pqCompress?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_controls PackDestination#pq_controls}
  */
  readonly pqControls?: PackDestinationOutputKinesisPqControls;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.). Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_max_file_size PackDestination#pq_max_file_size}
  */
  readonly pqMaxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_max_size PackDestination#pq_max_size}
  */
  readonly pqMaxSize?: string;
  /**
  * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem. Default: "error"; must be one of ["error", "backpressure", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_mode PackDestination#pq_mode}
  */
  readonly pqMode?: string;
  /**
  * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged. Default: "block"; must be one of ["block", "drop"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_on_backpressure PackDestination#pq_on_backpressure}
  */
  readonly pqOnBackpressure?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_path PackDestination#pq_path}
  */
  readonly pqPath?: string;
  /**
  * Region where the Kinesis stream is located
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#region PackDestination#region}
  */
  readonly region: string;
  /**
  * Reject certificates that cannot be verified against a valid CA, such as self-signed certificates. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#reject_unauthorized PackDestination#reject_unauthorized}
  */
  readonly rejectUnauthorized?: boolean | cdktf.IResolvable;
  /**
  * Reuse connections between requests, which can improve performance. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#reuse_connections PackDestination#reuse_connections}
  */
  readonly reuseConnections?: boolean | cdktf.IResolvable;
  /**
  * Signature version to use for signing Kinesis stream requests. Default: "v4"; must be one of ["v2", "v4"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#signature_version PackDestination#signature_version}
  */
  readonly signatureVersion?: string;
  /**
  * Kinesis stream name to send events to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#stream_name PackDestination#stream_name}
  */
  readonly streamName: string;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#streamtags PackDestination#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Fields to automatically add to events, such as cribl_pipe. Supports wildcards. Default: ["cribl_pipe"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#system_fields PackDestination#system_fields}
  */
  readonly systemFields?: string[];
  /**
  * must be "kinesis"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#type PackDestination#type}
  */
  readonly type?: string;
  /**
  * Provides higher stream rate limits, improving delivery speed and reliability by minimizing throttling. See the [ListShards API](https://docs.aws.amazon.com/kinesis/latest/APIReference/API_ListShards.html) documentation for details. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#use_list_shards PackDestination#use_list_shards}
  */
  readonly useListShards?: boolean | cdktf.IResolvable;
}

export function packDestinationOutputKinesisToTerraform(struct?: PackDestinationOutputKinesis | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    as_ndjson: cdktf.booleanToTerraform(struct!.asNdjson),
    assume_role_arn: cdktf.stringToTerraform(struct!.assumeRoleArn),
    assume_role_external_id: cdktf.stringToTerraform(struct!.assumeRoleExternalId),
    aws_api_key: cdktf.stringToTerraform(struct!.awsApiKey),
    aws_authentication_method: cdktf.stringToTerraform(struct!.awsAuthenticationMethod),
    aws_secret: cdktf.stringToTerraform(struct!.awsSecret),
    aws_secret_key: cdktf.stringToTerraform(struct!.awsSecretKey),
    compression: cdktf.stringToTerraform(struct!.compression),
    concurrency: cdktf.numberToTerraform(struct!.concurrency),
    description: cdktf.stringToTerraform(struct!.description),
    duration_seconds: cdktf.numberToTerraform(struct!.durationSeconds),
    enable_assume_role: cdktf.booleanToTerraform(struct!.enableAssumeRole),
    endpoint: cdktf.stringToTerraform(struct!.endpoint),
    environment: cdktf.stringToTerraform(struct!.environment),
    flush_period_sec: cdktf.numberToTerraform(struct!.flushPeriodSec),
    id: cdktf.stringToTerraform(struct!.id),
    max_record_size_kb: cdktf.numberToTerraform(struct!.maxRecordSizeKb),
    on_backpressure: cdktf.stringToTerraform(struct!.onBackpressure),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    pq_compress: cdktf.stringToTerraform(struct!.pqCompress),
    pq_controls: packDestinationOutputKinesisPqControlsToTerraform(struct!.pqControls),
    pq_max_file_size: cdktf.stringToTerraform(struct!.pqMaxFileSize),
    pq_max_size: cdktf.stringToTerraform(struct!.pqMaxSize),
    pq_mode: cdktf.stringToTerraform(struct!.pqMode),
    pq_on_backpressure: cdktf.stringToTerraform(struct!.pqOnBackpressure),
    pq_path: cdktf.stringToTerraform(struct!.pqPath),
    region: cdktf.stringToTerraform(struct!.region),
    reject_unauthorized: cdktf.booleanToTerraform(struct!.rejectUnauthorized),
    reuse_connections: cdktf.booleanToTerraform(struct!.reuseConnections),
    signature_version: cdktf.stringToTerraform(struct!.signatureVersion),
    stream_name: cdktf.stringToTerraform(struct!.streamName),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    system_fields: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.systemFields),
    type: cdktf.stringToTerraform(struct!.type),
    use_list_shards: cdktf.booleanToTerraform(struct!.useListShards),
  }
}


export function packDestinationOutputKinesisToHclTerraform(struct?: PackDestinationOutputKinesis | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    as_ndjson: {
      value: cdktf.booleanToHclTerraform(struct!.asNdjson),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    assume_role_arn: {
      value: cdktf.stringToHclTerraform(struct!.assumeRoleArn),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    assume_role_external_id: {
      value: cdktf.stringToHclTerraform(struct!.assumeRoleExternalId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    aws_api_key: {
      value: cdktf.stringToHclTerraform(struct!.awsApiKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    aws_authentication_method: {
      value: cdktf.stringToHclTerraform(struct!.awsAuthenticationMethod),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    aws_secret: {
      value: cdktf.stringToHclTerraform(struct!.awsSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    aws_secret_key: {
      value: cdktf.stringToHclTerraform(struct!.awsSecretKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    compression: {
      value: cdktf.stringToHclTerraform(struct!.compression),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    concurrency: {
      value: cdktf.numberToHclTerraform(struct!.concurrency),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    duration_seconds: {
      value: cdktf.numberToHclTerraform(struct!.durationSeconds),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    enable_assume_role: {
      value: cdktf.booleanToHclTerraform(struct!.enableAssumeRole),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    endpoint: {
      value: cdktf.stringToHclTerraform(struct!.endpoint),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    flush_period_sec: {
      value: cdktf.numberToHclTerraform(struct!.flushPeriodSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_record_size_kb: {
      value: cdktf.numberToHclTerraform(struct!.maxRecordSizeKb),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.onBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_compress: {
      value: cdktf.stringToHclTerraform(struct!.pqCompress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_controls: {
      value: packDestinationOutputKinesisPqControlsToHclTerraform(struct!.pqControls),
      isBlock: true,
      type: "struct",
      storageClassType: "PackDestinationOutputKinesisPqControls",
    },
    pq_max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_max_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_mode: {
      value: cdktf.stringToHclTerraform(struct!.pqMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.pqOnBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_path: {
      value: cdktf.stringToHclTerraform(struct!.pqPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    region: {
      value: cdktf.stringToHclTerraform(struct!.region),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reject_unauthorized: {
      value: cdktf.booleanToHclTerraform(struct!.rejectUnauthorized),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    reuse_connections: {
      value: cdktf.booleanToHclTerraform(struct!.reuseConnections),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    signature_version: {
      value: cdktf.stringToHclTerraform(struct!.signatureVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    stream_name: {
      value: cdktf.stringToHclTerraform(struct!.streamName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    system_fields: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.systemFields),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    use_list_shards: {
      value: cdktf.booleanToHclTerraform(struct!.useListShards),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputKinesisOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackDestinationOutputKinesis | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._asNdjson !== undefined) {
      hasAnyValues = true;
      internalValueResult.asNdjson = this._asNdjson;
    }
    if (this._assumeRoleArn !== undefined) {
      hasAnyValues = true;
      internalValueResult.assumeRoleArn = this._assumeRoleArn;
    }
    if (this._assumeRoleExternalId !== undefined) {
      hasAnyValues = true;
      internalValueResult.assumeRoleExternalId = this._assumeRoleExternalId;
    }
    if (this._awsApiKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.awsApiKey = this._awsApiKey;
    }
    if (this._awsAuthenticationMethod !== undefined) {
      hasAnyValues = true;
      internalValueResult.awsAuthenticationMethod = this._awsAuthenticationMethod;
    }
    if (this._awsSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.awsSecret = this._awsSecret;
    }
    if (this._awsSecretKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.awsSecretKey = this._awsSecretKey;
    }
    if (this._compression !== undefined) {
      hasAnyValues = true;
      internalValueResult.compression = this._compression;
    }
    if (this._concurrency !== undefined) {
      hasAnyValues = true;
      internalValueResult.concurrency = this._concurrency;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._durationSeconds !== undefined) {
      hasAnyValues = true;
      internalValueResult.durationSeconds = this._durationSeconds;
    }
    if (this._enableAssumeRole !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableAssumeRole = this._enableAssumeRole;
    }
    if (this._endpoint !== undefined) {
      hasAnyValues = true;
      internalValueResult.endpoint = this._endpoint;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._flushPeriodSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.flushPeriodSec = this._flushPeriodSec;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._maxRecordSizeKb !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxRecordSizeKb = this._maxRecordSizeKb;
    }
    if (this._onBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.onBackpressure = this._onBackpressure;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._pqCompress !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqCompress = this._pqCompress;
    }
    if (this._pqControls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqControls = this._pqControls?.internalValue;
    }
    if (this._pqMaxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxFileSize = this._pqMaxFileSize;
    }
    if (this._pqMaxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxSize = this._pqMaxSize;
    }
    if (this._pqMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMode = this._pqMode;
    }
    if (this._pqOnBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqOnBackpressure = this._pqOnBackpressure;
    }
    if (this._pqPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqPath = this._pqPath;
    }
    if (this._region !== undefined) {
      hasAnyValues = true;
      internalValueResult.region = this._region;
    }
    if (this._rejectUnauthorized !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectUnauthorized = this._rejectUnauthorized;
    }
    if (this._reuseConnections !== undefined) {
      hasAnyValues = true;
      internalValueResult.reuseConnections = this._reuseConnections;
    }
    if (this._signatureVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.signatureVersion = this._signatureVersion;
    }
    if (this._streamName !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamName = this._streamName;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._systemFields !== undefined) {
      hasAnyValues = true;
      internalValueResult.systemFields = this._systemFields;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._useListShards !== undefined) {
      hasAnyValues = true;
      internalValueResult.useListShards = this._useListShards;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputKinesis | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._asNdjson = undefined;
      this._assumeRoleArn = undefined;
      this._assumeRoleExternalId = undefined;
      this._awsApiKey = undefined;
      this._awsAuthenticationMethod = undefined;
      this._awsSecret = undefined;
      this._awsSecretKey = undefined;
      this._compression = undefined;
      this._concurrency = undefined;
      this._description = undefined;
      this._durationSeconds = undefined;
      this._enableAssumeRole = undefined;
      this._endpoint = undefined;
      this._environment = undefined;
      this._flushPeriodSec = undefined;
      this._id = undefined;
      this._maxRecordSizeKb = undefined;
      this._onBackpressure = undefined;
      this._pipeline = undefined;
      this._pqCompress = undefined;
      this._pqControls.internalValue = undefined;
      this._pqMaxFileSize = undefined;
      this._pqMaxSize = undefined;
      this._pqMode = undefined;
      this._pqOnBackpressure = undefined;
      this._pqPath = undefined;
      this._region = undefined;
      this._rejectUnauthorized = undefined;
      this._reuseConnections = undefined;
      this._signatureVersion = undefined;
      this._streamName = undefined;
      this._streamtags = undefined;
      this._systemFields = undefined;
      this._type = undefined;
      this._useListShards = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._asNdjson = value.asNdjson;
      this._assumeRoleArn = value.assumeRoleArn;
      this._assumeRoleExternalId = value.assumeRoleExternalId;
      this._awsApiKey = value.awsApiKey;
      this._awsAuthenticationMethod = value.awsAuthenticationMethod;
      this._awsSecret = value.awsSecret;
      this._awsSecretKey = value.awsSecretKey;
      this._compression = value.compression;
      this._concurrency = value.concurrency;
      this._description = value.description;
      this._durationSeconds = value.durationSeconds;
      this._enableAssumeRole = value.enableAssumeRole;
      this._endpoint = value.endpoint;
      this._environment = value.environment;
      this._flushPeriodSec = value.flushPeriodSec;
      this._id = value.id;
      this._maxRecordSizeKb = value.maxRecordSizeKb;
      this._onBackpressure = value.onBackpressure;
      this._pipeline = value.pipeline;
      this._pqCompress = value.pqCompress;
      this._pqControls.internalValue = value.pqControls;
      this._pqMaxFileSize = value.pqMaxFileSize;
      this._pqMaxSize = value.pqMaxSize;
      this._pqMode = value.pqMode;
      this._pqOnBackpressure = value.pqOnBackpressure;
      this._pqPath = value.pqPath;
      this._region = value.region;
      this._rejectUnauthorized = value.rejectUnauthorized;
      this._reuseConnections = value.reuseConnections;
      this._signatureVersion = value.signatureVersion;
      this._streamName = value.streamName;
      this._streamtags = value.streamtags;
      this._systemFields = value.systemFields;
      this._type = value.type;
      this._useListShards = value.useListShards;
    }
  }

  // as_ndjson - computed: true, optional: true, required: false
  private _asNdjson?: boolean | cdktf.IResolvable; 
  public get asNdjson() {
    return this.getBooleanAttribute('as_ndjson');
  }
  public set asNdjson(value: boolean | cdktf.IResolvable) {
    this._asNdjson = value;
  }
  public resetAsNdjson() {
    this._asNdjson = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get asNdjsonInput() {
    return this._asNdjson;
  }

  // assume_role_arn - computed: false, optional: true, required: false
  private _assumeRoleArn?: string; 
  public get assumeRoleArn() {
    return this.getStringAttribute('assume_role_arn');
  }
  public set assumeRoleArn(value: string) {
    this._assumeRoleArn = value;
  }
  public resetAssumeRoleArn() {
    this._assumeRoleArn = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get assumeRoleArnInput() {
    return this._assumeRoleArn;
  }

  // assume_role_external_id - computed: false, optional: true, required: false
  private _assumeRoleExternalId?: string; 
  public get assumeRoleExternalId() {
    return this.getStringAttribute('assume_role_external_id');
  }
  public set assumeRoleExternalId(value: string) {
    this._assumeRoleExternalId = value;
  }
  public resetAssumeRoleExternalId() {
    this._assumeRoleExternalId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get assumeRoleExternalIdInput() {
    return this._assumeRoleExternalId;
  }

  // aws_api_key - computed: false, optional: true, required: false
  private _awsApiKey?: string; 
  public get awsApiKey() {
    return this.getStringAttribute('aws_api_key');
  }
  public set awsApiKey(value: string) {
    this._awsApiKey = value;
  }
  public resetAwsApiKey() {
    this._awsApiKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsApiKeyInput() {
    return this._awsApiKey;
  }

  // aws_authentication_method - computed: true, optional: true, required: false
  private _awsAuthenticationMethod?: string; 
  public get awsAuthenticationMethod() {
    return this.getStringAttribute('aws_authentication_method');
  }
  public set awsAuthenticationMethod(value: string) {
    this._awsAuthenticationMethod = value;
  }
  public resetAwsAuthenticationMethod() {
    this._awsAuthenticationMethod = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsAuthenticationMethodInput() {
    return this._awsAuthenticationMethod;
  }

  // aws_secret - computed: false, optional: true, required: false
  private _awsSecret?: string; 
  public get awsSecret() {
    return this.getStringAttribute('aws_secret');
  }
  public set awsSecret(value: string) {
    this._awsSecret = value;
  }
  public resetAwsSecret() {
    this._awsSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsSecretInput() {
    return this._awsSecret;
  }

  // aws_secret_key - computed: false, optional: true, required: false
  private _awsSecretKey?: string; 
  public get awsSecretKey() {
    return this.getStringAttribute('aws_secret_key');
  }
  public set awsSecretKey(value: string) {
    this._awsSecretKey = value;
  }
  public resetAwsSecretKey() {
    this._awsSecretKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsSecretKeyInput() {
    return this._awsSecretKey;
  }

  // compression - computed: true, optional: true, required: false
  private _compression?: string; 
  public get compression() {
    return this.getStringAttribute('compression');
  }
  public set compression(value: string) {
    this._compression = value;
  }
  public resetCompression() {
    this._compression = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressionInput() {
    return this._compression;
  }

  // concurrency - computed: true, optional: true, required: false
  private _concurrency?: number; 
  public get concurrency() {
    return this.getNumberAttribute('concurrency');
  }
  public set concurrency(value: number) {
    this._concurrency = value;
  }
  public resetConcurrency() {
    this._concurrency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get concurrencyInput() {
    return this._concurrency;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // duration_seconds - computed: true, optional: true, required: false
  private _durationSeconds?: number; 
  public get durationSeconds() {
    return this.getNumberAttribute('duration_seconds');
  }
  public set durationSeconds(value: number) {
    this._durationSeconds = value;
  }
  public resetDurationSeconds() {
    this._durationSeconds = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get durationSecondsInput() {
    return this._durationSeconds;
  }

  // enable_assume_role - computed: true, optional: true, required: false
  private _enableAssumeRole?: boolean | cdktf.IResolvable; 
  public get enableAssumeRole() {
    return this.getBooleanAttribute('enable_assume_role');
  }
  public set enableAssumeRole(value: boolean | cdktf.IResolvable) {
    this._enableAssumeRole = value;
  }
  public resetEnableAssumeRole() {
    this._enableAssumeRole = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableAssumeRoleInput() {
    return this._enableAssumeRole;
  }

  // endpoint - computed: false, optional: true, required: false
  private _endpoint?: string; 
  public get endpoint() {
    return this.getStringAttribute('endpoint');
  }
  public set endpoint(value: string) {
    this._endpoint = value;
  }
  public resetEndpoint() {
    this._endpoint = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get endpointInput() {
    return this._endpoint;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // flush_period_sec - computed: true, optional: true, required: false
  private _flushPeriodSec?: number; 
  public get flushPeriodSec() {
    return this.getNumberAttribute('flush_period_sec');
  }
  public set flushPeriodSec(value: number) {
    this._flushPeriodSec = value;
  }
  public resetFlushPeriodSec() {
    this._flushPeriodSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get flushPeriodSecInput() {
    return this._flushPeriodSec;
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // max_record_size_kb - computed: true, optional: true, required: false
  private _maxRecordSizeKb?: number; 
  public get maxRecordSizeKb() {
    return this.getNumberAttribute('max_record_size_kb');
  }
  public set maxRecordSizeKb(value: number) {
    this._maxRecordSizeKb = value;
  }
  public resetMaxRecordSizeKb() {
    this._maxRecordSizeKb = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxRecordSizeKbInput() {
    return this._maxRecordSizeKb;
  }

  // on_backpressure - computed: true, optional: true, required: false
  private _onBackpressure?: string; 
  public get onBackpressure() {
    return this.getStringAttribute('on_backpressure');
  }
  public set onBackpressure(value: string) {
    this._onBackpressure = value;
  }
  public resetOnBackpressure() {
    this._onBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get onBackpressureInput() {
    return this._onBackpressure;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // pq_compress - computed: true, optional: true, required: false
  private _pqCompress?: string; 
  public get pqCompress() {
    return this.getStringAttribute('pq_compress');
  }
  public set pqCompress(value: string) {
    this._pqCompress = value;
  }
  public resetPqCompress() {
    this._pqCompress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqCompressInput() {
    return this._pqCompress;
  }

  // pq_controls - computed: false, optional: true, required: false
  private _pqControls = new PackDestinationOutputKinesisPqControlsOutputReference(this, "pq_controls");
  public get pqControls() {
    return this._pqControls;
  }
  public putPqControls(value: PackDestinationOutputKinesisPqControls) {
    this._pqControls.internalValue = value;
  }
  public resetPqControls() {
    this._pqControls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqControlsInput() {
    return this._pqControls.internalValue;
  }

  // pq_max_file_size - computed: true, optional: true, required: false
  private _pqMaxFileSize?: string; 
  public get pqMaxFileSize() {
    return this.getStringAttribute('pq_max_file_size');
  }
  public set pqMaxFileSize(value: string) {
    this._pqMaxFileSize = value;
  }
  public resetPqMaxFileSize() {
    this._pqMaxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxFileSizeInput() {
    return this._pqMaxFileSize;
  }

  // pq_max_size - computed: true, optional: true, required: false
  private _pqMaxSize?: string; 
  public get pqMaxSize() {
    return this.getStringAttribute('pq_max_size');
  }
  public set pqMaxSize(value: string) {
    this._pqMaxSize = value;
  }
  public resetPqMaxSize() {
    this._pqMaxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxSizeInput() {
    return this._pqMaxSize;
  }

  // pq_mode - computed: true, optional: true, required: false
  private _pqMode?: string; 
  public get pqMode() {
    return this.getStringAttribute('pq_mode');
  }
  public set pqMode(value: string) {
    this._pqMode = value;
  }
  public resetPqMode() {
    this._pqMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqModeInput() {
    return this._pqMode;
  }

  // pq_on_backpressure - computed: true, optional: true, required: false
  private _pqOnBackpressure?: string; 
  public get pqOnBackpressure() {
    return this.getStringAttribute('pq_on_backpressure');
  }
  public set pqOnBackpressure(value: string) {
    this._pqOnBackpressure = value;
  }
  public resetPqOnBackpressure() {
    this._pqOnBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqOnBackpressureInput() {
    return this._pqOnBackpressure;
  }

  // pq_path - computed: true, optional: true, required: false
  private _pqPath?: string; 
  public get pqPath() {
    return this.getStringAttribute('pq_path');
  }
  public set pqPath(value: string) {
    this._pqPath = value;
  }
  public resetPqPath() {
    this._pqPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqPathInput() {
    return this._pqPath;
  }

  // region - computed: false, optional: false, required: true
  private _region?: string; 
  public get region() {
    return this.getStringAttribute('region');
  }
  public set region(value: string) {
    this._region = value;
  }
  // Temporarily expose input value. Use with caution.
  public get regionInput() {
    return this._region;
  }

  // reject_unauthorized - computed: true, optional: true, required: false
  private _rejectUnauthorized?: boolean | cdktf.IResolvable; 
  public get rejectUnauthorized() {
    return this.getBooleanAttribute('reject_unauthorized');
  }
  public set rejectUnauthorized(value: boolean | cdktf.IResolvable) {
    this._rejectUnauthorized = value;
  }
  public resetRejectUnauthorized() {
    this._rejectUnauthorized = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectUnauthorizedInput() {
    return this._rejectUnauthorized;
  }

  // reuse_connections - computed: true, optional: true, required: false
  private _reuseConnections?: boolean | cdktf.IResolvable; 
  public get reuseConnections() {
    return this.getBooleanAttribute('reuse_connections');
  }
  public set reuseConnections(value: boolean | cdktf.IResolvable) {
    this._reuseConnections = value;
  }
  public resetReuseConnections() {
    this._reuseConnections = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get reuseConnectionsInput() {
    return this._reuseConnections;
  }

  // signature_version - computed: true, optional: true, required: false
  private _signatureVersion?: string; 
  public get signatureVersion() {
    return this.getStringAttribute('signature_version');
  }
  public set signatureVersion(value: string) {
    this._signatureVersion = value;
  }
  public resetSignatureVersion() {
    this._signatureVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get signatureVersionInput() {
    return this._signatureVersion;
  }

  // stream_name - computed: false, optional: false, required: true
  private _streamName?: string; 
  public get streamName() {
    return this.getStringAttribute('stream_name');
  }
  public set streamName(value: string) {
    this._streamName = value;
  }
  // Temporarily expose input value. Use with caution.
  public get streamNameInput() {
    return this._streamName;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // system_fields - computed: true, optional: true, required: false
  private _systemFields?: string[]; 
  public get systemFields() {
    return this.getListAttribute('system_fields');
  }
  public set systemFields(value: string[]) {
    this._systemFields = value;
  }
  public resetSystemFields() {
    this._systemFields = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get systemFieldsInput() {
    return this._systemFields;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // use_list_shards - computed: true, optional: true, required: false
  private _useListShards?: boolean | cdktf.IResolvable; 
  public get useListShards() {
    return this.getBooleanAttribute('use_list_shards');
  }
  public set useListShards(value: boolean | cdktf.IResolvable) {
    this._useListShards = value;
  }
  public resetUseListShards() {
    this._useListShards = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get useListShardsInput() {
    return this._useListShards;
  }
}
export interface PackDestinationOutputLokiExtraHttpHeaders {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#name PackDestination#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#value PackDestination#value}
  */
  readonly value: string;
}

export function packDestinationOutputLokiExtraHttpHeadersToTerraform(struct?: PackDestinationOutputLokiExtraHttpHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function packDestinationOutputLokiExtraHttpHeadersToHclTerraform(struct?: PackDestinationOutputLokiExtraHttpHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputLokiExtraHttpHeadersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackDestinationOutputLokiExtraHttpHeaders | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputLokiExtraHttpHeaders | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class PackDestinationOutputLokiExtraHttpHeadersList extends cdktf.ComplexList {
  public internalValue? : PackDestinationOutputLokiExtraHttpHeaders[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackDestinationOutputLokiExtraHttpHeadersOutputReference {
    return new PackDestinationOutputLokiExtraHttpHeadersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackDestinationOutputLokiLabels {
  /**
  * Default: ""
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#name PackDestination#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#value PackDestination#value}
  */
  readonly value: string;
}

export function packDestinationOutputLokiLabelsToTerraform(struct?: PackDestinationOutputLokiLabels | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function packDestinationOutputLokiLabelsToHclTerraform(struct?: PackDestinationOutputLokiLabels | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputLokiLabelsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackDestinationOutputLokiLabels | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputLokiLabels | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: true, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class PackDestinationOutputLokiLabelsList extends cdktf.ComplexList {
  public internalValue? : PackDestinationOutputLokiLabels[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackDestinationOutputLokiLabelsOutputReference {
    return new PackDestinationOutputLokiLabelsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackDestinationOutputLokiPqControls {
}

export function packDestinationOutputLokiPqControlsToTerraform(struct?: PackDestinationOutputLokiPqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function packDestinationOutputLokiPqControlsToHclTerraform(struct?: PackDestinationOutputLokiPqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class PackDestinationOutputLokiPqControlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackDestinationOutputLokiPqControls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputLokiPqControls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface PackDestinationOutputLokiResponseRetrySettings {
  /**
  * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc. Default: 2
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#backoff_rate PackDestination#backoff_rate}
  */
  readonly backoffRate?: number;
  /**
  * The HTTP response status code that will trigger retries
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#http_status PackDestination#http_status}
  */
  readonly httpStatus: number;
  /**
  * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes). Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#initial_backoff PackDestination#initial_backoff}
  */
  readonly initialBackoff?: number;
  /**
  * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds). Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_backoff PackDestination#max_backoff}
  */
  readonly maxBackoff?: number;
}

export function packDestinationOutputLokiResponseRetrySettingsToTerraform(struct?: PackDestinationOutputLokiResponseRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    backoff_rate: cdktf.numberToTerraform(struct!.backoffRate),
    http_status: cdktf.numberToTerraform(struct!.httpStatus),
    initial_backoff: cdktf.numberToTerraform(struct!.initialBackoff),
    max_backoff: cdktf.numberToTerraform(struct!.maxBackoff),
  }
}


export function packDestinationOutputLokiResponseRetrySettingsToHclTerraform(struct?: PackDestinationOutputLokiResponseRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    backoff_rate: {
      value: cdktf.numberToHclTerraform(struct!.backoffRate),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    http_status: {
      value: cdktf.numberToHclTerraform(struct!.httpStatus),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    initial_backoff: {
      value: cdktf.numberToHclTerraform(struct!.initialBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_backoff: {
      value: cdktf.numberToHclTerraform(struct!.maxBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputLokiResponseRetrySettingsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackDestinationOutputLokiResponseRetrySettings | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._backoffRate !== undefined) {
      hasAnyValues = true;
      internalValueResult.backoffRate = this._backoffRate;
    }
    if (this._httpStatus !== undefined) {
      hasAnyValues = true;
      internalValueResult.httpStatus = this._httpStatus;
    }
    if (this._initialBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.initialBackoff = this._initialBackoff;
    }
    if (this._maxBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBackoff = this._maxBackoff;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputLokiResponseRetrySettings | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._backoffRate = undefined;
      this._httpStatus = undefined;
      this._initialBackoff = undefined;
      this._maxBackoff = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._backoffRate = value.backoffRate;
      this._httpStatus = value.httpStatus;
      this._initialBackoff = value.initialBackoff;
      this._maxBackoff = value.maxBackoff;
    }
  }

  // backoff_rate - computed: true, optional: true, required: false
  private _backoffRate?: number; 
  public get backoffRate() {
    return this.getNumberAttribute('backoff_rate');
  }
  public set backoffRate(value: number) {
    this._backoffRate = value;
  }
  public resetBackoffRate() {
    this._backoffRate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get backoffRateInput() {
    return this._backoffRate;
  }

  // http_status - computed: false, optional: false, required: true
  private _httpStatus?: number; 
  public get httpStatus() {
    return this.getNumberAttribute('http_status');
  }
  public set httpStatus(value: number) {
    this._httpStatus = value;
  }
  // Temporarily expose input value. Use with caution.
  public get httpStatusInput() {
    return this._httpStatus;
  }

  // initial_backoff - computed: true, optional: true, required: false
  private _initialBackoff?: number; 
  public get initialBackoff() {
    return this.getNumberAttribute('initial_backoff');
  }
  public set initialBackoff(value: number) {
    this._initialBackoff = value;
  }
  public resetInitialBackoff() {
    this._initialBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get initialBackoffInput() {
    return this._initialBackoff;
  }

  // max_backoff - computed: true, optional: true, required: false
  private _maxBackoff?: number; 
  public get maxBackoff() {
    return this.getNumberAttribute('max_backoff');
  }
  public set maxBackoff(value: number) {
    this._maxBackoff = value;
  }
  public resetMaxBackoff() {
    this._maxBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBackoffInput() {
    return this._maxBackoff;
  }
}

export class PackDestinationOutputLokiResponseRetrySettingsList extends cdktf.ComplexList {
  public internalValue? : PackDestinationOutputLokiResponseRetrySettings[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackDestinationOutputLokiResponseRetrySettingsOutputReference {
    return new PackDestinationOutputLokiResponseRetrySettingsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackDestinationOutputLokiTimeoutRetrySettings {
  /**
  * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc. Default: 2
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#backoff_rate PackDestination#backoff_rate}
  */
  readonly backoffRate?: number;
  /**
  * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes). Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#initial_backoff PackDestination#initial_backoff}
  */
  readonly initialBackoff?: number;
  /**
  * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds). Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_backoff PackDestination#max_backoff}
  */
  readonly maxBackoff?: number;
  /**
  * Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#timeout_retry PackDestination#timeout_retry}
  */
  readonly timeoutRetry?: boolean | cdktf.IResolvable;
}

export function packDestinationOutputLokiTimeoutRetrySettingsToTerraform(struct?: PackDestinationOutputLokiTimeoutRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    backoff_rate: cdktf.numberToTerraform(struct!.backoffRate),
    initial_backoff: cdktf.numberToTerraform(struct!.initialBackoff),
    max_backoff: cdktf.numberToTerraform(struct!.maxBackoff),
    timeout_retry: cdktf.booleanToTerraform(struct!.timeoutRetry),
  }
}


export function packDestinationOutputLokiTimeoutRetrySettingsToHclTerraform(struct?: PackDestinationOutputLokiTimeoutRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    backoff_rate: {
      value: cdktf.numberToHclTerraform(struct!.backoffRate),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    initial_backoff: {
      value: cdktf.numberToHclTerraform(struct!.initialBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_backoff: {
      value: cdktf.numberToHclTerraform(struct!.maxBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    timeout_retry: {
      value: cdktf.booleanToHclTerraform(struct!.timeoutRetry),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputLokiTimeoutRetrySettingsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackDestinationOutputLokiTimeoutRetrySettings | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._backoffRate !== undefined) {
      hasAnyValues = true;
      internalValueResult.backoffRate = this._backoffRate;
    }
    if (this._initialBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.initialBackoff = this._initialBackoff;
    }
    if (this._maxBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBackoff = this._maxBackoff;
    }
    if (this._timeoutRetry !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutRetry = this._timeoutRetry;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputLokiTimeoutRetrySettings | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._backoffRate = undefined;
      this._initialBackoff = undefined;
      this._maxBackoff = undefined;
      this._timeoutRetry = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._backoffRate = value.backoffRate;
      this._initialBackoff = value.initialBackoff;
      this._maxBackoff = value.maxBackoff;
      this._timeoutRetry = value.timeoutRetry;
    }
  }

  // backoff_rate - computed: true, optional: true, required: false
  private _backoffRate?: number; 
  public get backoffRate() {
    return this.getNumberAttribute('backoff_rate');
  }
  public set backoffRate(value: number) {
    this._backoffRate = value;
  }
  public resetBackoffRate() {
    this._backoffRate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get backoffRateInput() {
    return this._backoffRate;
  }

  // initial_backoff - computed: true, optional: true, required: false
  private _initialBackoff?: number; 
  public get initialBackoff() {
    return this.getNumberAttribute('initial_backoff');
  }
  public set initialBackoff(value: number) {
    this._initialBackoff = value;
  }
  public resetInitialBackoff() {
    this._initialBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get initialBackoffInput() {
    return this._initialBackoff;
  }

  // max_backoff - computed: true, optional: true, required: false
  private _maxBackoff?: number; 
  public get maxBackoff() {
    return this.getNumberAttribute('max_backoff');
  }
  public set maxBackoff(value: number) {
    this._maxBackoff = value;
  }
  public resetMaxBackoff() {
    this._maxBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBackoffInput() {
    return this._maxBackoff;
  }

  // timeout_retry - computed: true, optional: true, required: false
  private _timeoutRetry?: boolean | cdktf.IResolvable; 
  public get timeoutRetry() {
    return this.getBooleanAttribute('timeout_retry');
  }
  public set timeoutRetry(value: boolean | cdktf.IResolvable) {
    this._timeoutRetry = value;
  }
  public resetTimeoutRetry() {
    this._timeoutRetry = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutRetryInput() {
    return this._timeoutRetry;
  }
}
export interface PackDestinationOutputLoki {
  /**
  * Default: "none"; must be one of ["none", "token", "textSecret", "basic", "credentialsSecret"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#auth_type PackDestination#auth_type}
  */
  readonly authType?: string;
  /**
  * Compress the payload body before sending. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#compress PackDestination#compress}
  */
  readonly compress?: boolean | cdktf.IResolvable;
  /**
  * Maximum number of ongoing requests before blocking. Warning: Setting this value > 1 can cause Loki to complain about entries being delivered out of order. Default: 1
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#concurrency PackDestination#concurrency}
  */
  readonly concurrency?: number;
  /**
  * Select or create a secret that references your credentials
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#credentials_secret PackDestination#credentials_secret}
  */
  readonly credentialsSecret?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#description PackDestination#description}
  */
  readonly description?: string;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#environment PackDestination#environment}
  */
  readonly environment?: string;
  /**
  * Headers to add to all events
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#extra_http_headers PackDestination#extra_http_headers}
  */
  readonly extraHttpHeaders?: PackDestinationOutputLokiExtraHttpHeaders[] | cdktf.IResolvable;
  /**
  * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below. Default: "none"; must be one of ["payload", "payloadAndHeaders", "none"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#failed_request_logging_mode PackDestination#failed_request_logging_mode}
  */
  readonly failedRequestLoggingMode?: string;
  /**
  * Maximum time between requests. Small values could cause the payload size to be smaller than the configured Maximum time between requests. Small values can reduce the payload size below the configured 'Max record size' and 'Max events per request'. Warning: Setting this too low can increase the number of ongoing requests (depending on the value of 'Request concurrency'); this can cause Loki to complain about entries being delivered out of order. Default: 15
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#flush_period_sec PackDestination#flush_period_sec}
  */
  readonly flushPeriodSec?: number;
  /**
  * Unique ID for this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#id PackDestination#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * List of labels to send with logs. Labels define Loki streams, so use static labels to avoid proliferating label value combinations and streams. Can be merged and/or overridden by the events __labels field. Example: "__labels: {host: "cribl.io", level: "error"}"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#labels PackDestination#labels}
  */
  readonly labels?: PackDestinationOutputLokiLabels[] | cdktf.IResolvable;
  /**
  * Maximum number of events to include in the request body. Defaults to 0 (unlimited). Warning: Setting this too low can increase the number of ongoing requests (depending on the value of 'Request concurrency'); this can cause Loki to complain about entries being delivered out of order. Default: 0
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_payload_events PackDestination#max_payload_events}
  */
  readonly maxPayloadEvents?: number;
  /**
  * Maximum size, in KB, of the request body. Warning: Setting this too low can increase the number of ongoing requests (depending on the value of 'Request concurrency'); this can cause Loki to complain about entries being delivered out of order. Default: 4096
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_payload_size_kb PackDestination#max_payload_size_kb}
  */
  readonly maxPayloadSizeKb?: number;
  /**
  * Name of the event field that contains the message to send. If not specified, Stream sends a JSON representation of the whole event.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#message PackDestination#message}
  */
  readonly message?: string;
  /**
  * Format to use when sending logs to Loki (Protobuf or JSON). Default: "protobuf"; must be one of ["protobuf", "json"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#message_format PackDestination#message_format}
  */
  readonly messageFormat?: string;
  /**
  * How to handle events when all receivers are exerting backpressure. Default: "block"; must be one of ["block", "drop", "queue"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#on_backpressure PackDestination#on_backpressure}
  */
  readonly onBackpressure?: string;
  /**
  * Password (API key in Grafana Cloud domain) for authentication
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#password PackDestination#password}
  */
  readonly password?: string;
  /**
  * Pipeline to process data before sending out to this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pipeline PackDestination#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_compress PackDestination#pq_compress}
  */
  readonly pqCompress?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_controls PackDestination#pq_controls}
  */
  readonly pqControls?: PackDestinationOutputLokiPqControls;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.). Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_max_file_size PackDestination#pq_max_file_size}
  */
  readonly pqMaxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_max_size PackDestination#pq_max_size}
  */
  readonly pqMaxSize?: string;
  /**
  * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem. Default: "error"; must be one of ["error", "backpressure", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_mode PackDestination#pq_mode}
  */
  readonly pqMode?: string;
  /**
  * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged. Default: "block"; must be one of ["block", "drop"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_on_backpressure PackDestination#pq_on_backpressure}
  */
  readonly pqOnBackpressure?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_path PackDestination#pq_path}
  */
  readonly pqPath?: string;
  /**
  * Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's). 
  *         Enabled by default. When this setting is also present in TLS Settings (Client Side), 
  *         that value will take precedence.
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#reject_unauthorized PackDestination#reject_unauthorized}
  */
  readonly rejectUnauthorized?: boolean | cdktf.IResolvable;
  /**
  * Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#response_honor_retry_after_header PackDestination#response_honor_retry_after_header}
  */
  readonly responseHonorRetryAfterHeader?: boolean | cdktf.IResolvable;
  /**
  * Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#response_retry_settings PackDestination#response_retry_settings}
  */
  readonly responseRetrySettings?: PackDestinationOutputLokiResponseRetrySettings[] | cdktf.IResolvable;
  /**
  * List of headers that are safe to log in plain text. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#safe_headers PackDestination#safe_headers}
  */
  readonly safeHeaders?: string[];
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#streamtags PackDestination#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Fields to automatically add to events, such as cribl_pipe. Supports wildcards. These fields are added as labels to generated logs. Default: ["cribl_host","cribl_wp"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#system_fields PackDestination#system_fields}
  */
  readonly systemFields?: string[];
  /**
  * Select or create a stored text secret
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#text_secret PackDestination#text_secret}
  */
  readonly textSecret?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#timeout_retry_settings PackDestination#timeout_retry_settings}
  */
  readonly timeoutRetrySettings?: PackDestinationOutputLokiTimeoutRetrySettings;
  /**
  * Amount of time, in seconds, to wait for a request to complete before canceling it. Default: 30
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#timeout_sec PackDestination#timeout_sec}
  */
  readonly timeoutSec?: number;
  /**
  * Bearer token to include in the authorization header. In Grafana Cloud, this is generally built by concatenating the username and the API key, separated by a colon. Example: <your-username>:<your-api-key>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#token PackDestination#token}
  */
  readonly token?: string;
  /**
  * Maximum total size of the batches waiting to be sent. If left blank, defaults to 5 times the max body size (if set). If 0, no limit is enforced.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#total_memory_limit_kb PackDestination#total_memory_limit_kb}
  */
  readonly totalMemoryLimitKb?: number;
  /**
  * must be "loki"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#type PackDestination#type}
  */
  readonly type: string;
  /**
  * The endpoint to send logs to
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#url PackDestination#url}
  */
  readonly url: string;
  /**
  * Enable round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. For optimal performance, consider enabling this setting for non-load balanced destinations. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#use_round_robin_dns PackDestination#use_round_robin_dns}
  */
  readonly useRoundRobinDns?: boolean | cdktf.IResolvable;
  /**
  * Username for authentication
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#username PackDestination#username}
  */
  readonly username?: string;
}

export function packDestinationOutputLokiToTerraform(struct?: PackDestinationOutputLoki | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    auth_type: cdktf.stringToTerraform(struct!.authType),
    compress: cdktf.booleanToTerraform(struct!.compress),
    concurrency: cdktf.numberToTerraform(struct!.concurrency),
    credentials_secret: cdktf.stringToTerraform(struct!.credentialsSecret),
    description: cdktf.stringToTerraform(struct!.description),
    environment: cdktf.stringToTerraform(struct!.environment),
    extra_http_headers: cdktf.listMapper(packDestinationOutputLokiExtraHttpHeadersToTerraform, false)(struct!.extraHttpHeaders),
    failed_request_logging_mode: cdktf.stringToTerraform(struct!.failedRequestLoggingMode),
    flush_period_sec: cdktf.numberToTerraform(struct!.flushPeriodSec),
    id: cdktf.stringToTerraform(struct!.id),
    labels: cdktf.listMapper(packDestinationOutputLokiLabelsToTerraform, false)(struct!.labels),
    max_payload_events: cdktf.numberToTerraform(struct!.maxPayloadEvents),
    max_payload_size_kb: cdktf.numberToTerraform(struct!.maxPayloadSizeKb),
    message: cdktf.stringToTerraform(struct!.message),
    message_format: cdktf.stringToTerraform(struct!.messageFormat),
    on_backpressure: cdktf.stringToTerraform(struct!.onBackpressure),
    password: cdktf.stringToTerraform(struct!.password),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    pq_compress: cdktf.stringToTerraform(struct!.pqCompress),
    pq_controls: packDestinationOutputLokiPqControlsToTerraform(struct!.pqControls),
    pq_max_file_size: cdktf.stringToTerraform(struct!.pqMaxFileSize),
    pq_max_size: cdktf.stringToTerraform(struct!.pqMaxSize),
    pq_mode: cdktf.stringToTerraform(struct!.pqMode),
    pq_on_backpressure: cdktf.stringToTerraform(struct!.pqOnBackpressure),
    pq_path: cdktf.stringToTerraform(struct!.pqPath),
    reject_unauthorized: cdktf.booleanToTerraform(struct!.rejectUnauthorized),
    response_honor_retry_after_header: cdktf.booleanToTerraform(struct!.responseHonorRetryAfterHeader),
    response_retry_settings: cdktf.listMapper(packDestinationOutputLokiResponseRetrySettingsToTerraform, false)(struct!.responseRetrySettings),
    safe_headers: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.safeHeaders),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    system_fields: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.systemFields),
    text_secret: cdktf.stringToTerraform(struct!.textSecret),
    timeout_retry_settings: packDestinationOutputLokiTimeoutRetrySettingsToTerraform(struct!.timeoutRetrySettings),
    timeout_sec: cdktf.numberToTerraform(struct!.timeoutSec),
    token: cdktf.stringToTerraform(struct!.token),
    total_memory_limit_kb: cdktf.numberToTerraform(struct!.totalMemoryLimitKb),
    type: cdktf.stringToTerraform(struct!.type),
    url: cdktf.stringToTerraform(struct!.url),
    use_round_robin_dns: cdktf.booleanToTerraform(struct!.useRoundRobinDns),
    username: cdktf.stringToTerraform(struct!.username),
  }
}


export function packDestinationOutputLokiToHclTerraform(struct?: PackDestinationOutputLoki | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    auth_type: {
      value: cdktf.stringToHclTerraform(struct!.authType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    compress: {
      value: cdktf.booleanToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    concurrency: {
      value: cdktf.numberToHclTerraform(struct!.concurrency),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    credentials_secret: {
      value: cdktf.stringToHclTerraform(struct!.credentialsSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    extra_http_headers: {
      value: cdktf.listMapperHcl(packDestinationOutputLokiExtraHttpHeadersToHclTerraform, false)(struct!.extraHttpHeaders),
      isBlock: true,
      type: "list",
      storageClassType: "PackDestinationOutputLokiExtraHttpHeadersList",
    },
    failed_request_logging_mode: {
      value: cdktf.stringToHclTerraform(struct!.failedRequestLoggingMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    flush_period_sec: {
      value: cdktf.numberToHclTerraform(struct!.flushPeriodSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    labels: {
      value: cdktf.listMapperHcl(packDestinationOutputLokiLabelsToHclTerraform, false)(struct!.labels),
      isBlock: true,
      type: "list",
      storageClassType: "PackDestinationOutputLokiLabelsList",
    },
    max_payload_events: {
      value: cdktf.numberToHclTerraform(struct!.maxPayloadEvents),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_payload_size_kb: {
      value: cdktf.numberToHclTerraform(struct!.maxPayloadSizeKb),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    message: {
      value: cdktf.stringToHclTerraform(struct!.message),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    message_format: {
      value: cdktf.stringToHclTerraform(struct!.messageFormat),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.onBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    password: {
      value: cdktf.stringToHclTerraform(struct!.password),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_compress: {
      value: cdktf.stringToHclTerraform(struct!.pqCompress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_controls: {
      value: packDestinationOutputLokiPqControlsToHclTerraform(struct!.pqControls),
      isBlock: true,
      type: "struct",
      storageClassType: "PackDestinationOutputLokiPqControls",
    },
    pq_max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_max_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_mode: {
      value: cdktf.stringToHclTerraform(struct!.pqMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.pqOnBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_path: {
      value: cdktf.stringToHclTerraform(struct!.pqPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reject_unauthorized: {
      value: cdktf.booleanToHclTerraform(struct!.rejectUnauthorized),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    response_honor_retry_after_header: {
      value: cdktf.booleanToHclTerraform(struct!.responseHonorRetryAfterHeader),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    response_retry_settings: {
      value: cdktf.listMapperHcl(packDestinationOutputLokiResponseRetrySettingsToHclTerraform, false)(struct!.responseRetrySettings),
      isBlock: true,
      type: "list",
      storageClassType: "PackDestinationOutputLokiResponseRetrySettingsList",
    },
    safe_headers: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.safeHeaders),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    system_fields: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.systemFields),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    text_secret: {
      value: cdktf.stringToHclTerraform(struct!.textSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    timeout_retry_settings: {
      value: packDestinationOutputLokiTimeoutRetrySettingsToHclTerraform(struct!.timeoutRetrySettings),
      isBlock: true,
      type: "struct",
      storageClassType: "PackDestinationOutputLokiTimeoutRetrySettings",
    },
    timeout_sec: {
      value: cdktf.numberToHclTerraform(struct!.timeoutSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    token: {
      value: cdktf.stringToHclTerraform(struct!.token),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    total_memory_limit_kb: {
      value: cdktf.numberToHclTerraform(struct!.totalMemoryLimitKb),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    url: {
      value: cdktf.stringToHclTerraform(struct!.url),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    use_round_robin_dns: {
      value: cdktf.booleanToHclTerraform(struct!.useRoundRobinDns),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    username: {
      value: cdktf.stringToHclTerraform(struct!.username),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputLokiOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackDestinationOutputLoki | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._authType !== undefined) {
      hasAnyValues = true;
      internalValueResult.authType = this._authType;
    }
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._concurrency !== undefined) {
      hasAnyValues = true;
      internalValueResult.concurrency = this._concurrency;
    }
    if (this._credentialsSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.credentialsSecret = this._credentialsSecret;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._extraHttpHeaders?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.extraHttpHeaders = this._extraHttpHeaders?.internalValue;
    }
    if (this._failedRequestLoggingMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.failedRequestLoggingMode = this._failedRequestLoggingMode;
    }
    if (this._flushPeriodSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.flushPeriodSec = this._flushPeriodSec;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._labels?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.labels = this._labels?.internalValue;
    }
    if (this._maxPayloadEvents !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxPayloadEvents = this._maxPayloadEvents;
    }
    if (this._maxPayloadSizeKb !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxPayloadSizeKb = this._maxPayloadSizeKb;
    }
    if (this._message !== undefined) {
      hasAnyValues = true;
      internalValueResult.message = this._message;
    }
    if (this._messageFormat !== undefined) {
      hasAnyValues = true;
      internalValueResult.messageFormat = this._messageFormat;
    }
    if (this._onBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.onBackpressure = this._onBackpressure;
    }
    if (this._password !== undefined) {
      hasAnyValues = true;
      internalValueResult.password = this._password;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._pqCompress !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqCompress = this._pqCompress;
    }
    if (this._pqControls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqControls = this._pqControls?.internalValue;
    }
    if (this._pqMaxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxFileSize = this._pqMaxFileSize;
    }
    if (this._pqMaxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxSize = this._pqMaxSize;
    }
    if (this._pqMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMode = this._pqMode;
    }
    if (this._pqOnBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqOnBackpressure = this._pqOnBackpressure;
    }
    if (this._pqPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqPath = this._pqPath;
    }
    if (this._rejectUnauthorized !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectUnauthorized = this._rejectUnauthorized;
    }
    if (this._responseHonorRetryAfterHeader !== undefined) {
      hasAnyValues = true;
      internalValueResult.responseHonorRetryAfterHeader = this._responseHonorRetryAfterHeader;
    }
    if (this._responseRetrySettings?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.responseRetrySettings = this._responseRetrySettings?.internalValue;
    }
    if (this._safeHeaders !== undefined) {
      hasAnyValues = true;
      internalValueResult.safeHeaders = this._safeHeaders;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._systemFields !== undefined) {
      hasAnyValues = true;
      internalValueResult.systemFields = this._systemFields;
    }
    if (this._textSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.textSecret = this._textSecret;
    }
    if (this._timeoutRetrySettings?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutRetrySettings = this._timeoutRetrySettings?.internalValue;
    }
    if (this._timeoutSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutSec = this._timeoutSec;
    }
    if (this._token !== undefined) {
      hasAnyValues = true;
      internalValueResult.token = this._token;
    }
    if (this._totalMemoryLimitKb !== undefined) {
      hasAnyValues = true;
      internalValueResult.totalMemoryLimitKb = this._totalMemoryLimitKb;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._url !== undefined) {
      hasAnyValues = true;
      internalValueResult.url = this._url;
    }
    if (this._useRoundRobinDns !== undefined) {
      hasAnyValues = true;
      internalValueResult.useRoundRobinDns = this._useRoundRobinDns;
    }
    if (this._username !== undefined) {
      hasAnyValues = true;
      internalValueResult.username = this._username;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputLoki | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._authType = undefined;
      this._compress = undefined;
      this._concurrency = undefined;
      this._credentialsSecret = undefined;
      this._description = undefined;
      this._environment = undefined;
      this._extraHttpHeaders.internalValue = undefined;
      this._failedRequestLoggingMode = undefined;
      this._flushPeriodSec = undefined;
      this._id = undefined;
      this._labels.internalValue = undefined;
      this._maxPayloadEvents = undefined;
      this._maxPayloadSizeKb = undefined;
      this._message = undefined;
      this._messageFormat = undefined;
      this._onBackpressure = undefined;
      this._password = undefined;
      this._pipeline = undefined;
      this._pqCompress = undefined;
      this._pqControls.internalValue = undefined;
      this._pqMaxFileSize = undefined;
      this._pqMaxSize = undefined;
      this._pqMode = undefined;
      this._pqOnBackpressure = undefined;
      this._pqPath = undefined;
      this._rejectUnauthorized = undefined;
      this._responseHonorRetryAfterHeader = undefined;
      this._responseRetrySettings.internalValue = undefined;
      this._safeHeaders = undefined;
      this._streamtags = undefined;
      this._systemFields = undefined;
      this._textSecret = undefined;
      this._timeoutRetrySettings.internalValue = undefined;
      this._timeoutSec = undefined;
      this._token = undefined;
      this._totalMemoryLimitKb = undefined;
      this._type = undefined;
      this._url = undefined;
      this._useRoundRobinDns = undefined;
      this._username = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._authType = value.authType;
      this._compress = value.compress;
      this._concurrency = value.concurrency;
      this._credentialsSecret = value.credentialsSecret;
      this._description = value.description;
      this._environment = value.environment;
      this._extraHttpHeaders.internalValue = value.extraHttpHeaders;
      this._failedRequestLoggingMode = value.failedRequestLoggingMode;
      this._flushPeriodSec = value.flushPeriodSec;
      this._id = value.id;
      this._labels.internalValue = value.labels;
      this._maxPayloadEvents = value.maxPayloadEvents;
      this._maxPayloadSizeKb = value.maxPayloadSizeKb;
      this._message = value.message;
      this._messageFormat = value.messageFormat;
      this._onBackpressure = value.onBackpressure;
      this._password = value.password;
      this._pipeline = value.pipeline;
      this._pqCompress = value.pqCompress;
      this._pqControls.internalValue = value.pqControls;
      this._pqMaxFileSize = value.pqMaxFileSize;
      this._pqMaxSize = value.pqMaxSize;
      this._pqMode = value.pqMode;
      this._pqOnBackpressure = value.pqOnBackpressure;
      this._pqPath = value.pqPath;
      this._rejectUnauthorized = value.rejectUnauthorized;
      this._responseHonorRetryAfterHeader = value.responseHonorRetryAfterHeader;
      this._responseRetrySettings.internalValue = value.responseRetrySettings;
      this._safeHeaders = value.safeHeaders;
      this._streamtags = value.streamtags;
      this._systemFields = value.systemFields;
      this._textSecret = value.textSecret;
      this._timeoutRetrySettings.internalValue = value.timeoutRetrySettings;
      this._timeoutSec = value.timeoutSec;
      this._token = value.token;
      this._totalMemoryLimitKb = value.totalMemoryLimitKb;
      this._type = value.type;
      this._url = value.url;
      this._useRoundRobinDns = value.useRoundRobinDns;
      this._username = value.username;
    }
  }

  // auth_type - computed: true, optional: true, required: false
  private _authType?: string; 
  public get authType() {
    return this.getStringAttribute('auth_type');
  }
  public set authType(value: string) {
    this._authType = value;
  }
  public resetAuthType() {
    this._authType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authTypeInput() {
    return this._authType;
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: boolean | cdktf.IResolvable; 
  public get compress() {
    return this.getBooleanAttribute('compress');
  }
  public set compress(value: boolean | cdktf.IResolvable) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // concurrency - computed: true, optional: true, required: false
  private _concurrency?: number; 
  public get concurrency() {
    return this.getNumberAttribute('concurrency');
  }
  public set concurrency(value: number) {
    this._concurrency = value;
  }
  public resetConcurrency() {
    this._concurrency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get concurrencyInput() {
    return this._concurrency;
  }

  // credentials_secret - computed: false, optional: true, required: false
  private _credentialsSecret?: string; 
  public get credentialsSecret() {
    return this.getStringAttribute('credentials_secret');
  }
  public set credentialsSecret(value: string) {
    this._credentialsSecret = value;
  }
  public resetCredentialsSecret() {
    this._credentialsSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get credentialsSecretInput() {
    return this._credentialsSecret;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // extra_http_headers - computed: false, optional: true, required: false
  private _extraHttpHeaders = new PackDestinationOutputLokiExtraHttpHeadersList(this, "extra_http_headers", false);
  public get extraHttpHeaders() {
    return this._extraHttpHeaders;
  }
  public putExtraHttpHeaders(value: PackDestinationOutputLokiExtraHttpHeaders[] | cdktf.IResolvable) {
    this._extraHttpHeaders.internalValue = value;
  }
  public resetExtraHttpHeaders() {
    this._extraHttpHeaders.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get extraHttpHeadersInput() {
    return this._extraHttpHeaders.internalValue;
  }

  // failed_request_logging_mode - computed: true, optional: true, required: false
  private _failedRequestLoggingMode?: string; 
  public get failedRequestLoggingMode() {
    return this.getStringAttribute('failed_request_logging_mode');
  }
  public set failedRequestLoggingMode(value: string) {
    this._failedRequestLoggingMode = value;
  }
  public resetFailedRequestLoggingMode() {
    this._failedRequestLoggingMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get failedRequestLoggingModeInput() {
    return this._failedRequestLoggingMode;
  }

  // flush_period_sec - computed: true, optional: true, required: false
  private _flushPeriodSec?: number; 
  public get flushPeriodSec() {
    return this.getNumberAttribute('flush_period_sec');
  }
  public set flushPeriodSec(value: number) {
    this._flushPeriodSec = value;
  }
  public resetFlushPeriodSec() {
    this._flushPeriodSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get flushPeriodSecInput() {
    return this._flushPeriodSec;
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // labels - computed: false, optional: true, required: false
  private _labels = new PackDestinationOutputLokiLabelsList(this, "labels", false);
  public get labels() {
    return this._labels;
  }
  public putLabels(value: PackDestinationOutputLokiLabels[] | cdktf.IResolvable) {
    this._labels.internalValue = value;
  }
  public resetLabels() {
    this._labels.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelsInput() {
    return this._labels.internalValue;
  }

  // max_payload_events - computed: true, optional: true, required: false
  private _maxPayloadEvents?: number; 
  public get maxPayloadEvents() {
    return this.getNumberAttribute('max_payload_events');
  }
  public set maxPayloadEvents(value: number) {
    this._maxPayloadEvents = value;
  }
  public resetMaxPayloadEvents() {
    this._maxPayloadEvents = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxPayloadEventsInput() {
    return this._maxPayloadEvents;
  }

  // max_payload_size_kb - computed: true, optional: true, required: false
  private _maxPayloadSizeKb?: number; 
  public get maxPayloadSizeKb() {
    return this.getNumberAttribute('max_payload_size_kb');
  }
  public set maxPayloadSizeKb(value: number) {
    this._maxPayloadSizeKb = value;
  }
  public resetMaxPayloadSizeKb() {
    this._maxPayloadSizeKb = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxPayloadSizeKbInput() {
    return this._maxPayloadSizeKb;
  }

  // message - computed: false, optional: true, required: false
  private _message?: string; 
  public get message() {
    return this.getStringAttribute('message');
  }
  public set message(value: string) {
    this._message = value;
  }
  public resetMessage() {
    this._message = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get messageInput() {
    return this._message;
  }

  // message_format - computed: true, optional: true, required: false
  private _messageFormat?: string; 
  public get messageFormat() {
    return this.getStringAttribute('message_format');
  }
  public set messageFormat(value: string) {
    this._messageFormat = value;
  }
  public resetMessageFormat() {
    this._messageFormat = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get messageFormatInput() {
    return this._messageFormat;
  }

  // on_backpressure - computed: true, optional: true, required: false
  private _onBackpressure?: string; 
  public get onBackpressure() {
    return this.getStringAttribute('on_backpressure');
  }
  public set onBackpressure(value: string) {
    this._onBackpressure = value;
  }
  public resetOnBackpressure() {
    this._onBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get onBackpressureInput() {
    return this._onBackpressure;
  }

  // password - computed: false, optional: true, required: false
  private _password?: string; 
  public get password() {
    return this.getStringAttribute('password');
  }
  public set password(value: string) {
    this._password = value;
  }
  public resetPassword() {
    this._password = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passwordInput() {
    return this._password;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // pq_compress - computed: true, optional: true, required: false
  private _pqCompress?: string; 
  public get pqCompress() {
    return this.getStringAttribute('pq_compress');
  }
  public set pqCompress(value: string) {
    this._pqCompress = value;
  }
  public resetPqCompress() {
    this._pqCompress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqCompressInput() {
    return this._pqCompress;
  }

  // pq_controls - computed: false, optional: true, required: false
  private _pqControls = new PackDestinationOutputLokiPqControlsOutputReference(this, "pq_controls");
  public get pqControls() {
    return this._pqControls;
  }
  public putPqControls(value: PackDestinationOutputLokiPqControls) {
    this._pqControls.internalValue = value;
  }
  public resetPqControls() {
    this._pqControls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqControlsInput() {
    return this._pqControls.internalValue;
  }

  // pq_max_file_size - computed: true, optional: true, required: false
  private _pqMaxFileSize?: string; 
  public get pqMaxFileSize() {
    return this.getStringAttribute('pq_max_file_size');
  }
  public set pqMaxFileSize(value: string) {
    this._pqMaxFileSize = value;
  }
  public resetPqMaxFileSize() {
    this._pqMaxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxFileSizeInput() {
    return this._pqMaxFileSize;
  }

  // pq_max_size - computed: true, optional: true, required: false
  private _pqMaxSize?: string; 
  public get pqMaxSize() {
    return this.getStringAttribute('pq_max_size');
  }
  public set pqMaxSize(value: string) {
    this._pqMaxSize = value;
  }
  public resetPqMaxSize() {
    this._pqMaxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxSizeInput() {
    return this._pqMaxSize;
  }

  // pq_mode - computed: true, optional: true, required: false
  private _pqMode?: string; 
  public get pqMode() {
    return this.getStringAttribute('pq_mode');
  }
  public set pqMode(value: string) {
    this._pqMode = value;
  }
  public resetPqMode() {
    this._pqMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqModeInput() {
    return this._pqMode;
  }

  // pq_on_backpressure - computed: true, optional: true, required: false
  private _pqOnBackpressure?: string; 
  public get pqOnBackpressure() {
    return this.getStringAttribute('pq_on_backpressure');
  }
  public set pqOnBackpressure(value: string) {
    this._pqOnBackpressure = value;
  }
  public resetPqOnBackpressure() {
    this._pqOnBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqOnBackpressureInput() {
    return this._pqOnBackpressure;
  }

  // pq_path - computed: true, optional: true, required: false
  private _pqPath?: string; 
  public get pqPath() {
    return this.getStringAttribute('pq_path');
  }
  public set pqPath(value: string) {
    this._pqPath = value;
  }
  public resetPqPath() {
    this._pqPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqPathInput() {
    return this._pqPath;
  }

  // reject_unauthorized - computed: true, optional: true, required: false
  private _rejectUnauthorized?: boolean | cdktf.IResolvable; 
  public get rejectUnauthorized() {
    return this.getBooleanAttribute('reject_unauthorized');
  }
  public set rejectUnauthorized(value: boolean | cdktf.IResolvable) {
    this._rejectUnauthorized = value;
  }
  public resetRejectUnauthorized() {
    this._rejectUnauthorized = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectUnauthorizedInput() {
    return this._rejectUnauthorized;
  }

  // response_honor_retry_after_header - computed: true, optional: true, required: false
  private _responseHonorRetryAfterHeader?: boolean | cdktf.IResolvable; 
  public get responseHonorRetryAfterHeader() {
    return this.getBooleanAttribute('response_honor_retry_after_header');
  }
  public set responseHonorRetryAfterHeader(value: boolean | cdktf.IResolvable) {
    this._responseHonorRetryAfterHeader = value;
  }
  public resetResponseHonorRetryAfterHeader() {
    this._responseHonorRetryAfterHeader = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get responseHonorRetryAfterHeaderInput() {
    return this._responseHonorRetryAfterHeader;
  }

  // response_retry_settings - computed: false, optional: true, required: false
  private _responseRetrySettings = new PackDestinationOutputLokiResponseRetrySettingsList(this, "response_retry_settings", false);
  public get responseRetrySettings() {
    return this._responseRetrySettings;
  }
  public putResponseRetrySettings(value: PackDestinationOutputLokiResponseRetrySettings[] | cdktf.IResolvable) {
    this._responseRetrySettings.internalValue = value;
  }
  public resetResponseRetrySettings() {
    this._responseRetrySettings.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get responseRetrySettingsInput() {
    return this._responseRetrySettings.internalValue;
  }

  // safe_headers - computed: true, optional: true, required: false
  private _safeHeaders?: string[]; 
  public get safeHeaders() {
    return this.getListAttribute('safe_headers');
  }
  public set safeHeaders(value: string[]) {
    this._safeHeaders = value;
  }
  public resetSafeHeaders() {
    this._safeHeaders = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get safeHeadersInput() {
    return this._safeHeaders;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // system_fields - computed: true, optional: true, required: false
  private _systemFields?: string[]; 
  public get systemFields() {
    return this.getListAttribute('system_fields');
  }
  public set systemFields(value: string[]) {
    this._systemFields = value;
  }
  public resetSystemFields() {
    this._systemFields = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get systemFieldsInput() {
    return this._systemFields;
  }

  // text_secret - computed: false, optional: true, required: false
  private _textSecret?: string; 
  public get textSecret() {
    return this.getStringAttribute('text_secret');
  }
  public set textSecret(value: string) {
    this._textSecret = value;
  }
  public resetTextSecret() {
    this._textSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get textSecretInput() {
    return this._textSecret;
  }

  // timeout_retry_settings - computed: false, optional: true, required: false
  private _timeoutRetrySettings = new PackDestinationOutputLokiTimeoutRetrySettingsOutputReference(this, "timeout_retry_settings");
  public get timeoutRetrySettings() {
    return this._timeoutRetrySettings;
  }
  public putTimeoutRetrySettings(value: PackDestinationOutputLokiTimeoutRetrySettings) {
    this._timeoutRetrySettings.internalValue = value;
  }
  public resetTimeoutRetrySettings() {
    this._timeoutRetrySettings.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutRetrySettingsInput() {
    return this._timeoutRetrySettings.internalValue;
  }

  // timeout_sec - computed: true, optional: true, required: false
  private _timeoutSec?: number; 
  public get timeoutSec() {
    return this.getNumberAttribute('timeout_sec');
  }
  public set timeoutSec(value: number) {
    this._timeoutSec = value;
  }
  public resetTimeoutSec() {
    this._timeoutSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutSecInput() {
    return this._timeoutSec;
  }

  // token - computed: false, optional: true, required: false
  private _token?: string; 
  public get token() {
    return this.getStringAttribute('token');
  }
  public set token(value: string) {
    this._token = value;
  }
  public resetToken() {
    this._token = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tokenInput() {
    return this._token;
  }

  // total_memory_limit_kb - computed: false, optional: true, required: false
  private _totalMemoryLimitKb?: number; 
  public get totalMemoryLimitKb() {
    return this.getNumberAttribute('total_memory_limit_kb');
  }
  public set totalMemoryLimitKb(value: number) {
    this._totalMemoryLimitKb = value;
  }
  public resetTotalMemoryLimitKb() {
    this._totalMemoryLimitKb = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get totalMemoryLimitKbInput() {
    return this._totalMemoryLimitKb;
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // url - computed: false, optional: false, required: true
  private _url?: string; 
  public get url() {
    return this.getStringAttribute('url');
  }
  public set url(value: string) {
    this._url = value;
  }
  // Temporarily expose input value. Use with caution.
  public get urlInput() {
    return this._url;
  }

  // use_round_robin_dns - computed: true, optional: true, required: false
  private _useRoundRobinDns?: boolean | cdktf.IResolvable; 
  public get useRoundRobinDns() {
    return this.getBooleanAttribute('use_round_robin_dns');
  }
  public set useRoundRobinDns(value: boolean | cdktf.IResolvable) {
    this._useRoundRobinDns = value;
  }
  public resetUseRoundRobinDns() {
    this._useRoundRobinDns = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get useRoundRobinDnsInput() {
    return this._useRoundRobinDns;
  }

  // username - computed: false, optional: true, required: false
  private _username?: string; 
  public get username() {
    return this.getStringAttribute('username');
  }
  public set username(value: string) {
    this._username = value;
  }
  public resetUsername() {
    this._username = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usernameInput() {
    return this._username;
  }
}
export interface PackDestinationOutputMinioKeyValueMetadata {
  /**
  * Default: ""
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#key PackDestination#key}
  */
  readonly key?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#value PackDestination#value}
  */
  readonly value: string;
}

export function packDestinationOutputMinioKeyValueMetadataToTerraform(struct?: PackDestinationOutputMinioKeyValueMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function packDestinationOutputMinioKeyValueMetadataToHclTerraform(struct?: PackDestinationOutputMinioKeyValueMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputMinioKeyValueMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackDestinationOutputMinioKeyValueMetadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputMinioKeyValueMetadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._value = value.value;
    }
  }

  // key - computed: true, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class PackDestinationOutputMinioKeyValueMetadataList extends cdktf.ComplexList {
  public internalValue? : PackDestinationOutputMinioKeyValueMetadata[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackDestinationOutputMinioKeyValueMetadataOutputReference {
    return new PackDestinationOutputMinioKeyValueMetadataOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackDestinationOutputMinio {
  /**
  * Add the Output ID value to staging location. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#add_id_to_stage_path PackDestination#add_id_to_stage_path}
  */
  readonly addIdToStagePath?: boolean | cdktf.IResolvable;
  /**
  * Automatically calculate the schema based on the events of each Parquet file generated. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#automatic_schema PackDestination#automatic_schema}
  */
  readonly automaticSchema?: boolean | cdktf.IResolvable;
  /**
  * This value can be a constant or a JavaScript expression (`${C.env.SOME_ACCESS_KEY}`)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#aws_api_key PackDestination#aws_api_key}
  */
  readonly awsApiKey?: string;
  /**
  * AWS authentication method. Choose Auto to use IAM roles. Default: "auto"; must be one of ["auto", "manual", "secret"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#aws_authentication_method PackDestination#aws_authentication_method}
  */
  readonly awsAuthenticationMethod?: string;
  /**
  * Select or create a stored secret that references your access key and secret key
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#aws_secret PackDestination#aws_secret}
  */
  readonly awsSecret?: string;
  /**
  * Secret key. This value can be a constant or a JavaScript expression, such as `${C.env.SOME_SECRET}`).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#aws_secret_key PackDestination#aws_secret_key}
  */
  readonly awsSecretKey?: string;
  /**
  * JavaScript expression to define the output filename prefix (can be constant). Default: "`CriblOut`"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#base_file_name PackDestination#base_file_name}
  */
  readonly baseFileName?: string;
  /**
  * Name of the destination MinIO bucket. This value can be a constant or a JavaScript expression that can only be evaluated at init time. Example referencing a Global Variable: `myBucket-${C.vars.myVar}`
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#bucket PackDestination#bucket}
  */
  readonly bucket: string;
  /**
  * Data compression format to apply to HTTP content before it is delivered. Default: "gzip"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#compress PackDestination#compress}
  */
  readonly compress?: string;
  /**
  * Compression level to apply before moving files to final destination. Default: "best_speed"; must be one of ["best_speed", "normal", "best_compression"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#compression_level PackDestination#compression_level}
  */
  readonly compressionLevel?: string;
  /**
  * If a file fails to move to its final destination after the maximum number of retries, move it to a designated directory to prevent further errors. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#deadletter_enabled PackDestination#deadletter_enabled}
  */
  readonly deadletterEnabled?: boolean | cdktf.IResolvable;
  /**
  * Storage location for files that fail to reach their final destination after maximum retries are exceeded. Default: "$CRIBL_HOME/state/outputs/dead-letter"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#deadletter_path PackDestination#deadletter_path}
  */
  readonly deadletterPath?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#description PackDestination#description}
  */
  readonly description?: string;
  /**
  * Root directory to prepend to path before uploading. Enter a constant, or a JavaScript expression enclosed in quotes or backticks.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#dest_path PackDestination#dest_path}
  */
  readonly destPath?: string;
  /**
  * How frequently, in seconds, to clean up empty directories. Default: 300
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#empty_dir_cleanup_sec PackDestination#empty_dir_cleanup_sec}
  */
  readonly emptyDirCleanupSec?: number;
  /**
  * Parquet tools can use the checksum of a Parquet page to verify data integrity. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#enable_page_checksum PackDestination#enable_page_checksum}
  */
  readonly enablePageChecksum?: boolean | cdktf.IResolvable;
  /**
  * Statistics profile an entire file in terms of minimum/maximum values within data, numbers of nulls, etc. You can use Parquet tools to view statistics. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#enable_statistics PackDestination#enable_statistics}
  */
  readonly enableStatistics?: boolean | cdktf.IResolvable;
  /**
  * One page index contains statistics for one data page. Parquet readers use statistics to enable page skipping. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#enable_write_page_index PackDestination#enable_write_page_index}
  */
  readonly enableWritePageIndex?: boolean | cdktf.IResolvable;
  /**
  * MinIO service url (e.g. http://minioHost:9000)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#endpoint PackDestination#endpoint}
  */
  readonly endpoint: string;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#environment PackDestination#environment}
  */
  readonly environment?: string;
  /**
  * JavaScript expression to define the output filename suffix (can be constant).  The `__format` variable refers to the value of the `Data format` field (`json` or `raw`).  The `__compression` field refers to the kind of compression being used (`none` or `gzip`). Default: "`.${C.env[\"CRIBL_WORKER_ID\"]}.${__format}${__compression === \"gzip\" ? \".gz\" : \"\"}`"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#file_name_suffix PackDestination#file_name_suffix}
  */
  readonly fileNameSuffix?: string;
  /**
  * Format of the output data. Default: "json"; must be one of ["json", "raw", "parquet"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#format PackDestination#format}
  */
  readonly format?: string;
  /**
  * If set, this line will be written to the beginning of each output file. Default: ""
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#header_line PackDestination#header_line}
  */
  readonly headerLine?: string;
  /**
  * Unique ID for this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#id PackDestination#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * The metadata of files the Destination writes will include the properties you add here as key-value pairs. Useful for tagging. Examples: "key":"OCSF Event Class", "value":"9001"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#key_value_metadata PackDestination#key_value_metadata}
  */
  readonly keyValueMetadata?: PackDestinationOutputMinioKeyValueMetadata[] | cdktf.IResolvable;
  /**
  * Maximum number of parts to upload in parallel per file. Minimum part size is 5MB. Default: 4
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_concurrent_file_parts PackDestination#max_concurrent_file_parts}
  */
  readonly maxConcurrentFileParts?: number;
  /**
  * Maximum amount of time to keep inactive files open. Files open for longer than this will be closed and moved to final output location. Default: 30
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_file_idle_time_sec PackDestination#max_file_idle_time_sec}
  */
  readonly maxFileIdleTimeSec?: number;
  /**
  * Maximum amount of time to write to a file. Files open for longer than this will be closed and moved to final output location. Default: 300
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_file_open_time_sec PackDestination#max_file_open_time_sec}
  */
  readonly maxFileOpenTimeSec?: number;
  /**
  * Maximum uncompressed output file size. Files of this size will be closed and moved to final output location. Default: 32
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_file_size_mb PackDestination#max_file_size_mb}
  */
  readonly maxFileSizeMb?: number;
  /**
  * Maximum number of files to keep open concurrently. When exceeded, @{product} will close the oldest open files and move them to the final output location. Default: 100
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_open_files PackDestination#max_open_files}
  */
  readonly maxOpenFiles?: number;
  /**
  * The maximum number of times a file will attempt to move to its final destination before being dead-lettered. Default: 20
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_retry_num PackDestination#max_retry_num}
  */
  readonly maxRetryNum?: number;
  /**
  * Object ACL to assign to uploaded objects. Default: "private"; must be one of ["private", "public-read", "public-read-write", "authenticated-read", "aws-exec-read", "bucket-owner-read", "bucket-owner-full-control"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#object_acl PackDestination#object_acl}
  */
  readonly objectAcl?: string;
  /**
  * How to handle events when all receivers are exerting backpressure. Default: "block"; must be one of ["block", "drop"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#on_backpressure PackDestination#on_backpressure}
  */
  readonly onBackpressure?: string;
  /**
  * How to handle events when disk space is below the global 'Min free disk space' limit. Default: "block"; must be one of ["block", "drop"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#on_disk_full_backpressure PackDestination#on_disk_full_backpressure}
  */
  readonly onDiskFullBackpressure?: string;
  /**
  * Serialization format of data pages. Note that some reader implementations use Data page V2's attributes to work more efficiently, while others ignore it. Default: "DATA_PAGE_V2"; must be one of ["DATA_PAGE_V1", "DATA_PAGE_V2"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#parquet_data_page_version PackDestination#parquet_data_page_version}
  */
  readonly parquetDataPageVersion?: string;
  /**
  * Target memory size for page segments, such as 1MB or 128MB. Generally, lower values improve reading speed, while higher values improve compression. Default: "1MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#parquet_page_size PackDestination#parquet_page_size}
  */
  readonly parquetPageSize?: string;
  /**
  * The number of rows that every group will contain. The final group can contain a smaller number of rows. Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#parquet_row_group_length PackDestination#parquet_row_group_length}
  */
  readonly parquetRowGroupLength?: number;
  /**
  * Determines which data types are supported and how they are represented. Default: "PARQUET_2_6"; must be one of ["PARQUET_1_0", "PARQUET_2_4", "PARQUET_2_6"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#parquet_version PackDestination#parquet_version}
  */
  readonly parquetVersion?: string;
  /**
  * JavaScript expression defining how files are partitioned and organized. Default is date-based. If blank, Stream will fall back to the event's __partition field value – if present – otherwise to each location's root directory. Default: "C.Time.strftime(_time ? _time : Date.now()/1000, '%Y/%m/%d')"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#partition_expr PackDestination#partition_expr}
  */
  readonly partitionExpr?: string;
  /**
  * Pipeline to process data before sending out to this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pipeline PackDestination#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Region where the MinIO service/cluster is located
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#region PackDestination#region}
  */
  readonly region?: string;
  /**
  * Reject certificates that cannot be verified against a valid CA, such as self-signed certificates). Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#reject_unauthorized PackDestination#reject_unauthorized}
  */
  readonly rejectUnauthorized?: boolean | cdktf.IResolvable;
  /**
  * Remove empty staging directories after moving files. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#remove_empty_dirs PackDestination#remove_empty_dirs}
  */
  readonly removeEmptyDirs?: boolean | cdktf.IResolvable;
  /**
  * Reuse connections between requests, which can improve performance. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#reuse_connections PackDestination#reuse_connections}
  */
  readonly reuseConnections?: boolean | cdktf.IResolvable;
  /**
  * Server-side encryption for uploaded objects. must be "AES256"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#server_side_encryption PackDestination#server_side_encryption}
  */
  readonly serverSideEncryption?: string;
  /**
  * Log up to 3 rows that @{product} skips due to data mismatch
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#should_log_invalid_rows PackDestination#should_log_invalid_rows}
  */
  readonly shouldLogInvalidRows?: boolean | cdktf.IResolvable;
  /**
  * Signature version to use for signing MinIO requests. Default: "v4"; must be one of ["v2", "v4"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#signature_version PackDestination#signature_version}
  */
  readonly signatureVersion?: string;
  /**
  * Filesystem location in which to buffer files, before compressing and moving to final destination. Use performant stable storage. Default: "$CRIBL_HOME/state/outputs/staging"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#stage_path PackDestination#stage_path}
  */
  readonly stagePath?: string;
  /**
  * Storage class to select for uploaded objects. must be one of ["STANDARD", "REDUCED_REDUNDANCY"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#storage_class PackDestination#storage_class}
  */
  readonly storageClass?: string;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#streamtags PackDestination#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Fields to automatically add to events, such as cribl_pipe. Supports wildcards. Default: ["cribl_pipe"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#system_fields PackDestination#system_fields}
  */
  readonly systemFields?: string[];
  /**
  * must be "minio"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#type PackDestination#type}
  */
  readonly type?: string;
  /**
  * Disable if you can access files within the bucket but not the bucket itself. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#verify_permissions PackDestination#verify_permissions}
  */
  readonly verifyPermissions?: boolean | cdktf.IResolvable;
  /**
  * Buffer size used to write to a file. Default: 64
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#write_high_water_mark PackDestination#write_high_water_mark}
  */
  readonly writeHighWaterMark?: number;
}

export function packDestinationOutputMinioToTerraform(struct?: PackDestinationOutputMinio | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    add_id_to_stage_path: cdktf.booleanToTerraform(struct!.addIdToStagePath),
    automatic_schema: cdktf.booleanToTerraform(struct!.automaticSchema),
    aws_api_key: cdktf.stringToTerraform(struct!.awsApiKey),
    aws_authentication_method: cdktf.stringToTerraform(struct!.awsAuthenticationMethod),
    aws_secret: cdktf.stringToTerraform(struct!.awsSecret),
    aws_secret_key: cdktf.stringToTerraform(struct!.awsSecretKey),
    base_file_name: cdktf.stringToTerraform(struct!.baseFileName),
    bucket: cdktf.stringToTerraform(struct!.bucket),
    compress: cdktf.stringToTerraform(struct!.compress),
    compression_level: cdktf.stringToTerraform(struct!.compressionLevel),
    deadletter_enabled: cdktf.booleanToTerraform(struct!.deadletterEnabled),
    deadletter_path: cdktf.stringToTerraform(struct!.deadletterPath),
    description: cdktf.stringToTerraform(struct!.description),
    dest_path: cdktf.stringToTerraform(struct!.destPath),
    empty_dir_cleanup_sec: cdktf.numberToTerraform(struct!.emptyDirCleanupSec),
    enable_page_checksum: cdktf.booleanToTerraform(struct!.enablePageChecksum),
    enable_statistics: cdktf.booleanToTerraform(struct!.enableStatistics),
    enable_write_page_index: cdktf.booleanToTerraform(struct!.enableWritePageIndex),
    endpoint: cdktf.stringToTerraform(struct!.endpoint),
    environment: cdktf.stringToTerraform(struct!.environment),
    file_name_suffix: cdktf.stringToTerraform(struct!.fileNameSuffix),
    format: cdktf.stringToTerraform(struct!.format),
    header_line: cdktf.stringToTerraform(struct!.headerLine),
    id: cdktf.stringToTerraform(struct!.id),
    key_value_metadata: cdktf.listMapper(packDestinationOutputMinioKeyValueMetadataToTerraform, false)(struct!.keyValueMetadata),
    max_concurrent_file_parts: cdktf.numberToTerraform(struct!.maxConcurrentFileParts),
    max_file_idle_time_sec: cdktf.numberToTerraform(struct!.maxFileIdleTimeSec),
    max_file_open_time_sec: cdktf.numberToTerraform(struct!.maxFileOpenTimeSec),
    max_file_size_mb: cdktf.numberToTerraform(struct!.maxFileSizeMb),
    max_open_files: cdktf.numberToTerraform(struct!.maxOpenFiles),
    max_retry_num: cdktf.numberToTerraform(struct!.maxRetryNum),
    object_acl: cdktf.stringToTerraform(struct!.objectAcl),
    on_backpressure: cdktf.stringToTerraform(struct!.onBackpressure),
    on_disk_full_backpressure: cdktf.stringToTerraform(struct!.onDiskFullBackpressure),
    parquet_data_page_version: cdktf.stringToTerraform(struct!.parquetDataPageVersion),
    parquet_page_size: cdktf.stringToTerraform(struct!.parquetPageSize),
    parquet_row_group_length: cdktf.numberToTerraform(struct!.parquetRowGroupLength),
    parquet_version: cdktf.stringToTerraform(struct!.parquetVersion),
    partition_expr: cdktf.stringToTerraform(struct!.partitionExpr),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    region: cdktf.stringToTerraform(struct!.region),
    reject_unauthorized: cdktf.booleanToTerraform(struct!.rejectUnauthorized),
    remove_empty_dirs: cdktf.booleanToTerraform(struct!.removeEmptyDirs),
    reuse_connections: cdktf.booleanToTerraform(struct!.reuseConnections),
    server_side_encryption: cdktf.stringToTerraform(struct!.serverSideEncryption),
    should_log_invalid_rows: cdktf.booleanToTerraform(struct!.shouldLogInvalidRows),
    signature_version: cdktf.stringToTerraform(struct!.signatureVersion),
    stage_path: cdktf.stringToTerraform(struct!.stagePath),
    storage_class: cdktf.stringToTerraform(struct!.storageClass),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    system_fields: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.systemFields),
    type: cdktf.stringToTerraform(struct!.type),
    verify_permissions: cdktf.booleanToTerraform(struct!.verifyPermissions),
    write_high_water_mark: cdktf.numberToTerraform(struct!.writeHighWaterMark),
  }
}


export function packDestinationOutputMinioToHclTerraform(struct?: PackDestinationOutputMinio | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    add_id_to_stage_path: {
      value: cdktf.booleanToHclTerraform(struct!.addIdToStagePath),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    automatic_schema: {
      value: cdktf.booleanToHclTerraform(struct!.automaticSchema),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    aws_api_key: {
      value: cdktf.stringToHclTerraform(struct!.awsApiKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    aws_authentication_method: {
      value: cdktf.stringToHclTerraform(struct!.awsAuthenticationMethod),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    aws_secret: {
      value: cdktf.stringToHclTerraform(struct!.awsSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    aws_secret_key: {
      value: cdktf.stringToHclTerraform(struct!.awsSecretKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    base_file_name: {
      value: cdktf.stringToHclTerraform(struct!.baseFileName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    bucket: {
      value: cdktf.stringToHclTerraform(struct!.bucket),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    compress: {
      value: cdktf.stringToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    compression_level: {
      value: cdktf.stringToHclTerraform(struct!.compressionLevel),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    deadletter_enabled: {
      value: cdktf.booleanToHclTerraform(struct!.deadletterEnabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    deadletter_path: {
      value: cdktf.stringToHclTerraform(struct!.deadletterPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    dest_path: {
      value: cdktf.stringToHclTerraform(struct!.destPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    empty_dir_cleanup_sec: {
      value: cdktf.numberToHclTerraform(struct!.emptyDirCleanupSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    enable_page_checksum: {
      value: cdktf.booleanToHclTerraform(struct!.enablePageChecksum),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    enable_statistics: {
      value: cdktf.booleanToHclTerraform(struct!.enableStatistics),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    enable_write_page_index: {
      value: cdktf.booleanToHclTerraform(struct!.enableWritePageIndex),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    endpoint: {
      value: cdktf.stringToHclTerraform(struct!.endpoint),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    file_name_suffix: {
      value: cdktf.stringToHclTerraform(struct!.fileNameSuffix),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    format: {
      value: cdktf.stringToHclTerraform(struct!.format),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    header_line: {
      value: cdktf.stringToHclTerraform(struct!.headerLine),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    key_value_metadata: {
      value: cdktf.listMapperHcl(packDestinationOutputMinioKeyValueMetadataToHclTerraform, false)(struct!.keyValueMetadata),
      isBlock: true,
      type: "list",
      storageClassType: "PackDestinationOutputMinioKeyValueMetadataList",
    },
    max_concurrent_file_parts: {
      value: cdktf.numberToHclTerraform(struct!.maxConcurrentFileParts),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_file_idle_time_sec: {
      value: cdktf.numberToHclTerraform(struct!.maxFileIdleTimeSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_file_open_time_sec: {
      value: cdktf.numberToHclTerraform(struct!.maxFileOpenTimeSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_file_size_mb: {
      value: cdktf.numberToHclTerraform(struct!.maxFileSizeMb),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_open_files: {
      value: cdktf.numberToHclTerraform(struct!.maxOpenFiles),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_retry_num: {
      value: cdktf.numberToHclTerraform(struct!.maxRetryNum),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    object_acl: {
      value: cdktf.stringToHclTerraform(struct!.objectAcl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.onBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    on_disk_full_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.onDiskFullBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    parquet_data_page_version: {
      value: cdktf.stringToHclTerraform(struct!.parquetDataPageVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    parquet_page_size: {
      value: cdktf.stringToHclTerraform(struct!.parquetPageSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    parquet_row_group_length: {
      value: cdktf.numberToHclTerraform(struct!.parquetRowGroupLength),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    parquet_version: {
      value: cdktf.stringToHclTerraform(struct!.parquetVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    partition_expr: {
      value: cdktf.stringToHclTerraform(struct!.partitionExpr),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    region: {
      value: cdktf.stringToHclTerraform(struct!.region),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reject_unauthorized: {
      value: cdktf.booleanToHclTerraform(struct!.rejectUnauthorized),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    remove_empty_dirs: {
      value: cdktf.booleanToHclTerraform(struct!.removeEmptyDirs),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    reuse_connections: {
      value: cdktf.booleanToHclTerraform(struct!.reuseConnections),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    server_side_encryption: {
      value: cdktf.stringToHclTerraform(struct!.serverSideEncryption),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    should_log_invalid_rows: {
      value: cdktf.booleanToHclTerraform(struct!.shouldLogInvalidRows),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    signature_version: {
      value: cdktf.stringToHclTerraform(struct!.signatureVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    stage_path: {
      value: cdktf.stringToHclTerraform(struct!.stagePath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    storage_class: {
      value: cdktf.stringToHclTerraform(struct!.storageClass),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    system_fields: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.systemFields),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    verify_permissions: {
      value: cdktf.booleanToHclTerraform(struct!.verifyPermissions),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    write_high_water_mark: {
      value: cdktf.numberToHclTerraform(struct!.writeHighWaterMark),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputMinioOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackDestinationOutputMinio | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._addIdToStagePath !== undefined) {
      hasAnyValues = true;
      internalValueResult.addIdToStagePath = this._addIdToStagePath;
    }
    if (this._automaticSchema !== undefined) {
      hasAnyValues = true;
      internalValueResult.automaticSchema = this._automaticSchema;
    }
    if (this._awsApiKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.awsApiKey = this._awsApiKey;
    }
    if (this._awsAuthenticationMethod !== undefined) {
      hasAnyValues = true;
      internalValueResult.awsAuthenticationMethod = this._awsAuthenticationMethod;
    }
    if (this._awsSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.awsSecret = this._awsSecret;
    }
    if (this._awsSecretKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.awsSecretKey = this._awsSecretKey;
    }
    if (this._baseFileName !== undefined) {
      hasAnyValues = true;
      internalValueResult.baseFileName = this._baseFileName;
    }
    if (this._bucket !== undefined) {
      hasAnyValues = true;
      internalValueResult.bucket = this._bucket;
    }
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._compressionLevel !== undefined) {
      hasAnyValues = true;
      internalValueResult.compressionLevel = this._compressionLevel;
    }
    if (this._deadletterEnabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.deadletterEnabled = this._deadletterEnabled;
    }
    if (this._deadletterPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.deadletterPath = this._deadletterPath;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._destPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.destPath = this._destPath;
    }
    if (this._emptyDirCleanupSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.emptyDirCleanupSec = this._emptyDirCleanupSec;
    }
    if (this._enablePageChecksum !== undefined) {
      hasAnyValues = true;
      internalValueResult.enablePageChecksum = this._enablePageChecksum;
    }
    if (this._enableStatistics !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableStatistics = this._enableStatistics;
    }
    if (this._enableWritePageIndex !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableWritePageIndex = this._enableWritePageIndex;
    }
    if (this._endpoint !== undefined) {
      hasAnyValues = true;
      internalValueResult.endpoint = this._endpoint;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._fileNameSuffix !== undefined) {
      hasAnyValues = true;
      internalValueResult.fileNameSuffix = this._fileNameSuffix;
    }
    if (this._format !== undefined) {
      hasAnyValues = true;
      internalValueResult.format = this._format;
    }
    if (this._headerLine !== undefined) {
      hasAnyValues = true;
      internalValueResult.headerLine = this._headerLine;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._keyValueMetadata?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.keyValueMetadata = this._keyValueMetadata?.internalValue;
    }
    if (this._maxConcurrentFileParts !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxConcurrentFileParts = this._maxConcurrentFileParts;
    }
    if (this._maxFileIdleTimeSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxFileIdleTimeSec = this._maxFileIdleTimeSec;
    }
    if (this._maxFileOpenTimeSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxFileOpenTimeSec = this._maxFileOpenTimeSec;
    }
    if (this._maxFileSizeMb !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxFileSizeMb = this._maxFileSizeMb;
    }
    if (this._maxOpenFiles !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxOpenFiles = this._maxOpenFiles;
    }
    if (this._maxRetryNum !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxRetryNum = this._maxRetryNum;
    }
    if (this._objectAcl !== undefined) {
      hasAnyValues = true;
      internalValueResult.objectAcl = this._objectAcl;
    }
    if (this._onBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.onBackpressure = this._onBackpressure;
    }
    if (this._onDiskFullBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.onDiskFullBackpressure = this._onDiskFullBackpressure;
    }
    if (this._parquetDataPageVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.parquetDataPageVersion = this._parquetDataPageVersion;
    }
    if (this._parquetPageSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.parquetPageSize = this._parquetPageSize;
    }
    if (this._parquetRowGroupLength !== undefined) {
      hasAnyValues = true;
      internalValueResult.parquetRowGroupLength = this._parquetRowGroupLength;
    }
    if (this._parquetVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.parquetVersion = this._parquetVersion;
    }
    if (this._partitionExpr !== undefined) {
      hasAnyValues = true;
      internalValueResult.partitionExpr = this._partitionExpr;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._region !== undefined) {
      hasAnyValues = true;
      internalValueResult.region = this._region;
    }
    if (this._rejectUnauthorized !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectUnauthorized = this._rejectUnauthorized;
    }
    if (this._removeEmptyDirs !== undefined) {
      hasAnyValues = true;
      internalValueResult.removeEmptyDirs = this._removeEmptyDirs;
    }
    if (this._reuseConnections !== undefined) {
      hasAnyValues = true;
      internalValueResult.reuseConnections = this._reuseConnections;
    }
    if (this._serverSideEncryption !== undefined) {
      hasAnyValues = true;
      internalValueResult.serverSideEncryption = this._serverSideEncryption;
    }
    if (this._shouldLogInvalidRows !== undefined) {
      hasAnyValues = true;
      internalValueResult.shouldLogInvalidRows = this._shouldLogInvalidRows;
    }
    if (this._signatureVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.signatureVersion = this._signatureVersion;
    }
    if (this._stagePath !== undefined) {
      hasAnyValues = true;
      internalValueResult.stagePath = this._stagePath;
    }
    if (this._storageClass !== undefined) {
      hasAnyValues = true;
      internalValueResult.storageClass = this._storageClass;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._systemFields !== undefined) {
      hasAnyValues = true;
      internalValueResult.systemFields = this._systemFields;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._verifyPermissions !== undefined) {
      hasAnyValues = true;
      internalValueResult.verifyPermissions = this._verifyPermissions;
    }
    if (this._writeHighWaterMark !== undefined) {
      hasAnyValues = true;
      internalValueResult.writeHighWaterMark = this._writeHighWaterMark;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputMinio | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._addIdToStagePath = undefined;
      this._automaticSchema = undefined;
      this._awsApiKey = undefined;
      this._awsAuthenticationMethod = undefined;
      this._awsSecret = undefined;
      this._awsSecretKey = undefined;
      this._baseFileName = undefined;
      this._bucket = undefined;
      this._compress = undefined;
      this._compressionLevel = undefined;
      this._deadletterEnabled = undefined;
      this._deadletterPath = undefined;
      this._description = undefined;
      this._destPath = undefined;
      this._emptyDirCleanupSec = undefined;
      this._enablePageChecksum = undefined;
      this._enableStatistics = undefined;
      this._enableWritePageIndex = undefined;
      this._endpoint = undefined;
      this._environment = undefined;
      this._fileNameSuffix = undefined;
      this._format = undefined;
      this._headerLine = undefined;
      this._id = undefined;
      this._keyValueMetadata.internalValue = undefined;
      this._maxConcurrentFileParts = undefined;
      this._maxFileIdleTimeSec = undefined;
      this._maxFileOpenTimeSec = undefined;
      this._maxFileSizeMb = undefined;
      this._maxOpenFiles = undefined;
      this._maxRetryNum = undefined;
      this._objectAcl = undefined;
      this._onBackpressure = undefined;
      this._onDiskFullBackpressure = undefined;
      this._parquetDataPageVersion = undefined;
      this._parquetPageSize = undefined;
      this._parquetRowGroupLength = undefined;
      this._parquetVersion = undefined;
      this._partitionExpr = undefined;
      this._pipeline = undefined;
      this._region = undefined;
      this._rejectUnauthorized = undefined;
      this._removeEmptyDirs = undefined;
      this._reuseConnections = undefined;
      this._serverSideEncryption = undefined;
      this._shouldLogInvalidRows = undefined;
      this._signatureVersion = undefined;
      this._stagePath = undefined;
      this._storageClass = undefined;
      this._streamtags = undefined;
      this._systemFields = undefined;
      this._type = undefined;
      this._verifyPermissions = undefined;
      this._writeHighWaterMark = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._addIdToStagePath = value.addIdToStagePath;
      this._automaticSchema = value.automaticSchema;
      this._awsApiKey = value.awsApiKey;
      this._awsAuthenticationMethod = value.awsAuthenticationMethod;
      this._awsSecret = value.awsSecret;
      this._awsSecretKey = value.awsSecretKey;
      this._baseFileName = value.baseFileName;
      this._bucket = value.bucket;
      this._compress = value.compress;
      this._compressionLevel = value.compressionLevel;
      this._deadletterEnabled = value.deadletterEnabled;
      this._deadletterPath = value.deadletterPath;
      this._description = value.description;
      this._destPath = value.destPath;
      this._emptyDirCleanupSec = value.emptyDirCleanupSec;
      this._enablePageChecksum = value.enablePageChecksum;
      this._enableStatistics = value.enableStatistics;
      this._enableWritePageIndex = value.enableWritePageIndex;
      this._endpoint = value.endpoint;
      this._environment = value.environment;
      this._fileNameSuffix = value.fileNameSuffix;
      this._format = value.format;
      this._headerLine = value.headerLine;
      this._id = value.id;
      this._keyValueMetadata.internalValue = value.keyValueMetadata;
      this._maxConcurrentFileParts = value.maxConcurrentFileParts;
      this._maxFileIdleTimeSec = value.maxFileIdleTimeSec;
      this._maxFileOpenTimeSec = value.maxFileOpenTimeSec;
      this._maxFileSizeMb = value.maxFileSizeMb;
      this._maxOpenFiles = value.maxOpenFiles;
      this._maxRetryNum = value.maxRetryNum;
      this._objectAcl = value.objectAcl;
      this._onBackpressure = value.onBackpressure;
      this._onDiskFullBackpressure = value.onDiskFullBackpressure;
      this._parquetDataPageVersion = value.parquetDataPageVersion;
      this._parquetPageSize = value.parquetPageSize;
      this._parquetRowGroupLength = value.parquetRowGroupLength;
      this._parquetVersion = value.parquetVersion;
      this._partitionExpr = value.partitionExpr;
      this._pipeline = value.pipeline;
      this._region = value.region;
      this._rejectUnauthorized = value.rejectUnauthorized;
      this._removeEmptyDirs = value.removeEmptyDirs;
      this._reuseConnections = value.reuseConnections;
      this._serverSideEncryption = value.serverSideEncryption;
      this._shouldLogInvalidRows = value.shouldLogInvalidRows;
      this._signatureVersion = value.signatureVersion;
      this._stagePath = value.stagePath;
      this._storageClass = value.storageClass;
      this._streamtags = value.streamtags;
      this._systemFields = value.systemFields;
      this._type = value.type;
      this._verifyPermissions = value.verifyPermissions;
      this._writeHighWaterMark = value.writeHighWaterMark;
    }
  }

  // add_id_to_stage_path - computed: true, optional: true, required: false
  private _addIdToStagePath?: boolean | cdktf.IResolvable; 
  public get addIdToStagePath() {
    return this.getBooleanAttribute('add_id_to_stage_path');
  }
  public set addIdToStagePath(value: boolean | cdktf.IResolvable) {
    this._addIdToStagePath = value;
  }
  public resetAddIdToStagePath() {
    this._addIdToStagePath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addIdToStagePathInput() {
    return this._addIdToStagePath;
  }

  // automatic_schema - computed: true, optional: true, required: false
  private _automaticSchema?: boolean | cdktf.IResolvable; 
  public get automaticSchema() {
    return this.getBooleanAttribute('automatic_schema');
  }
  public set automaticSchema(value: boolean | cdktf.IResolvable) {
    this._automaticSchema = value;
  }
  public resetAutomaticSchema() {
    this._automaticSchema = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get automaticSchemaInput() {
    return this._automaticSchema;
  }

  // aws_api_key - computed: false, optional: true, required: false
  private _awsApiKey?: string; 
  public get awsApiKey() {
    return this.getStringAttribute('aws_api_key');
  }
  public set awsApiKey(value: string) {
    this._awsApiKey = value;
  }
  public resetAwsApiKey() {
    this._awsApiKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsApiKeyInput() {
    return this._awsApiKey;
  }

  // aws_authentication_method - computed: true, optional: true, required: false
  private _awsAuthenticationMethod?: string; 
  public get awsAuthenticationMethod() {
    return this.getStringAttribute('aws_authentication_method');
  }
  public set awsAuthenticationMethod(value: string) {
    this._awsAuthenticationMethod = value;
  }
  public resetAwsAuthenticationMethod() {
    this._awsAuthenticationMethod = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsAuthenticationMethodInput() {
    return this._awsAuthenticationMethod;
  }

  // aws_secret - computed: false, optional: true, required: false
  private _awsSecret?: string; 
  public get awsSecret() {
    return this.getStringAttribute('aws_secret');
  }
  public set awsSecret(value: string) {
    this._awsSecret = value;
  }
  public resetAwsSecret() {
    this._awsSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsSecretInput() {
    return this._awsSecret;
  }

  // aws_secret_key - computed: false, optional: true, required: false
  private _awsSecretKey?: string; 
  public get awsSecretKey() {
    return this.getStringAttribute('aws_secret_key');
  }
  public set awsSecretKey(value: string) {
    this._awsSecretKey = value;
  }
  public resetAwsSecretKey() {
    this._awsSecretKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsSecretKeyInput() {
    return this._awsSecretKey;
  }

  // base_file_name - computed: true, optional: true, required: false
  private _baseFileName?: string; 
  public get baseFileName() {
    return this.getStringAttribute('base_file_name');
  }
  public set baseFileName(value: string) {
    this._baseFileName = value;
  }
  public resetBaseFileName() {
    this._baseFileName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get baseFileNameInput() {
    return this._baseFileName;
  }

  // bucket - computed: false, optional: false, required: true
  private _bucket?: string; 
  public get bucket() {
    return this.getStringAttribute('bucket');
  }
  public set bucket(value: string) {
    this._bucket = value;
  }
  // Temporarily expose input value. Use with caution.
  public get bucketInput() {
    return this._bucket;
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: string; 
  public get compress() {
    return this.getStringAttribute('compress');
  }
  public set compress(value: string) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // compression_level - computed: true, optional: true, required: false
  private _compressionLevel?: string; 
  public get compressionLevel() {
    return this.getStringAttribute('compression_level');
  }
  public set compressionLevel(value: string) {
    this._compressionLevel = value;
  }
  public resetCompressionLevel() {
    this._compressionLevel = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressionLevelInput() {
    return this._compressionLevel;
  }

  // deadletter_enabled - computed: true, optional: true, required: false
  private _deadletterEnabled?: boolean | cdktf.IResolvable; 
  public get deadletterEnabled() {
    return this.getBooleanAttribute('deadletter_enabled');
  }
  public set deadletterEnabled(value: boolean | cdktf.IResolvable) {
    this._deadletterEnabled = value;
  }
  public resetDeadletterEnabled() {
    this._deadletterEnabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get deadletterEnabledInput() {
    return this._deadletterEnabled;
  }

  // deadletter_path - computed: true, optional: true, required: false
  private _deadletterPath?: string; 
  public get deadletterPath() {
    return this.getStringAttribute('deadletter_path');
  }
  public set deadletterPath(value: string) {
    this._deadletterPath = value;
  }
  public resetDeadletterPath() {
    this._deadletterPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get deadletterPathInput() {
    return this._deadletterPath;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // dest_path - computed: false, optional: true, required: false
  private _destPath?: string; 
  public get destPath() {
    return this.getStringAttribute('dest_path');
  }
  public set destPath(value: string) {
    this._destPath = value;
  }
  public resetDestPath() {
    this._destPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get destPathInput() {
    return this._destPath;
  }

  // empty_dir_cleanup_sec - computed: true, optional: true, required: false
  private _emptyDirCleanupSec?: number; 
  public get emptyDirCleanupSec() {
    return this.getNumberAttribute('empty_dir_cleanup_sec');
  }
  public set emptyDirCleanupSec(value: number) {
    this._emptyDirCleanupSec = value;
  }
  public resetEmptyDirCleanupSec() {
    this._emptyDirCleanupSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get emptyDirCleanupSecInput() {
    return this._emptyDirCleanupSec;
  }

  // enable_page_checksum - computed: true, optional: true, required: false
  private _enablePageChecksum?: boolean | cdktf.IResolvable; 
  public get enablePageChecksum() {
    return this.getBooleanAttribute('enable_page_checksum');
  }
  public set enablePageChecksum(value: boolean | cdktf.IResolvable) {
    this._enablePageChecksum = value;
  }
  public resetEnablePageChecksum() {
    this._enablePageChecksum = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enablePageChecksumInput() {
    return this._enablePageChecksum;
  }

  // enable_statistics - computed: true, optional: true, required: false
  private _enableStatistics?: boolean | cdktf.IResolvable; 
  public get enableStatistics() {
    return this.getBooleanAttribute('enable_statistics');
  }
  public set enableStatistics(value: boolean | cdktf.IResolvable) {
    this._enableStatistics = value;
  }
  public resetEnableStatistics() {
    this._enableStatistics = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableStatisticsInput() {
    return this._enableStatistics;
  }

  // enable_write_page_index - computed: true, optional: true, required: false
  private _enableWritePageIndex?: boolean | cdktf.IResolvable; 
  public get enableWritePageIndex() {
    return this.getBooleanAttribute('enable_write_page_index');
  }
  public set enableWritePageIndex(value: boolean | cdktf.IResolvable) {
    this._enableWritePageIndex = value;
  }
  public resetEnableWritePageIndex() {
    this._enableWritePageIndex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableWritePageIndexInput() {
    return this._enableWritePageIndex;
  }

  // endpoint - computed: false, optional: false, required: true
  private _endpoint?: string; 
  public get endpoint() {
    return this.getStringAttribute('endpoint');
  }
  public set endpoint(value: string) {
    this._endpoint = value;
  }
  // Temporarily expose input value. Use with caution.
  public get endpointInput() {
    return this._endpoint;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // file_name_suffix - computed: true, optional: true, required: false
  private _fileNameSuffix?: string; 
  public get fileNameSuffix() {
    return this.getStringAttribute('file_name_suffix');
  }
  public set fileNameSuffix(value: string) {
    this._fileNameSuffix = value;
  }
  public resetFileNameSuffix() {
    this._fileNameSuffix = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fileNameSuffixInput() {
    return this._fileNameSuffix;
  }

  // format - computed: true, optional: true, required: false
  private _format?: string; 
  public get format() {
    return this.getStringAttribute('format');
  }
  public set format(value: string) {
    this._format = value;
  }
  public resetFormat() {
    this._format = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get formatInput() {
    return this._format;
  }

  // header_line - computed: true, optional: true, required: false
  private _headerLine?: string; 
  public get headerLine() {
    return this.getStringAttribute('header_line');
  }
  public set headerLine(value: string) {
    this._headerLine = value;
  }
  public resetHeaderLine() {
    this._headerLine = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get headerLineInput() {
    return this._headerLine;
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // key_value_metadata - computed: false, optional: true, required: false
  private _keyValueMetadata = new PackDestinationOutputMinioKeyValueMetadataList(this, "key_value_metadata", false);
  public get keyValueMetadata() {
    return this._keyValueMetadata;
  }
  public putKeyValueMetadata(value: PackDestinationOutputMinioKeyValueMetadata[] | cdktf.IResolvable) {
    this._keyValueMetadata.internalValue = value;
  }
  public resetKeyValueMetadata() {
    this._keyValueMetadata.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyValueMetadataInput() {
    return this._keyValueMetadata.internalValue;
  }

  // max_concurrent_file_parts - computed: true, optional: true, required: false
  private _maxConcurrentFileParts?: number; 
  public get maxConcurrentFileParts() {
    return this.getNumberAttribute('max_concurrent_file_parts');
  }
  public set maxConcurrentFileParts(value: number) {
    this._maxConcurrentFileParts = value;
  }
  public resetMaxConcurrentFileParts() {
    this._maxConcurrentFileParts = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxConcurrentFilePartsInput() {
    return this._maxConcurrentFileParts;
  }

  // max_file_idle_time_sec - computed: true, optional: true, required: false
  private _maxFileIdleTimeSec?: number; 
  public get maxFileIdleTimeSec() {
    return this.getNumberAttribute('max_file_idle_time_sec');
  }
  public set maxFileIdleTimeSec(value: number) {
    this._maxFileIdleTimeSec = value;
  }
  public resetMaxFileIdleTimeSec() {
    this._maxFileIdleTimeSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxFileIdleTimeSecInput() {
    return this._maxFileIdleTimeSec;
  }

  // max_file_open_time_sec - computed: true, optional: true, required: false
  private _maxFileOpenTimeSec?: number; 
  public get maxFileOpenTimeSec() {
    return this.getNumberAttribute('max_file_open_time_sec');
  }
  public set maxFileOpenTimeSec(value: number) {
    this._maxFileOpenTimeSec = value;
  }
  public resetMaxFileOpenTimeSec() {
    this._maxFileOpenTimeSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxFileOpenTimeSecInput() {
    return this._maxFileOpenTimeSec;
  }

  // max_file_size_mb - computed: true, optional: true, required: false
  private _maxFileSizeMb?: number; 
  public get maxFileSizeMb() {
    return this.getNumberAttribute('max_file_size_mb');
  }
  public set maxFileSizeMb(value: number) {
    this._maxFileSizeMb = value;
  }
  public resetMaxFileSizeMb() {
    this._maxFileSizeMb = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxFileSizeMbInput() {
    return this._maxFileSizeMb;
  }

  // max_open_files - computed: true, optional: true, required: false
  private _maxOpenFiles?: number; 
  public get maxOpenFiles() {
    return this.getNumberAttribute('max_open_files');
  }
  public set maxOpenFiles(value: number) {
    this._maxOpenFiles = value;
  }
  public resetMaxOpenFiles() {
    this._maxOpenFiles = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxOpenFilesInput() {
    return this._maxOpenFiles;
  }

  // max_retry_num - computed: true, optional: true, required: false
  private _maxRetryNum?: number; 
  public get maxRetryNum() {
    return this.getNumberAttribute('max_retry_num');
  }
  public set maxRetryNum(value: number) {
    this._maxRetryNum = value;
  }
  public resetMaxRetryNum() {
    this._maxRetryNum = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxRetryNumInput() {
    return this._maxRetryNum;
  }

  // object_acl - computed: true, optional: true, required: false
  private _objectAcl?: string; 
  public get objectAcl() {
    return this.getStringAttribute('object_acl');
  }
  public set objectAcl(value: string) {
    this._objectAcl = value;
  }
  public resetObjectAcl() {
    this._objectAcl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get objectAclInput() {
    return this._objectAcl;
  }

  // on_backpressure - computed: true, optional: true, required: false
  private _onBackpressure?: string; 
  public get onBackpressure() {
    return this.getStringAttribute('on_backpressure');
  }
  public set onBackpressure(value: string) {
    this._onBackpressure = value;
  }
  public resetOnBackpressure() {
    this._onBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get onBackpressureInput() {
    return this._onBackpressure;
  }

  // on_disk_full_backpressure - computed: true, optional: true, required: false
  private _onDiskFullBackpressure?: string; 
  public get onDiskFullBackpressure() {
    return this.getStringAttribute('on_disk_full_backpressure');
  }
  public set onDiskFullBackpressure(value: string) {
    this._onDiskFullBackpressure = value;
  }
  public resetOnDiskFullBackpressure() {
    this._onDiskFullBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get onDiskFullBackpressureInput() {
    return this._onDiskFullBackpressure;
  }

  // parquet_data_page_version - computed: true, optional: true, required: false
  private _parquetDataPageVersion?: string; 
  public get parquetDataPageVersion() {
    return this.getStringAttribute('parquet_data_page_version');
  }
  public set parquetDataPageVersion(value: string) {
    this._parquetDataPageVersion = value;
  }
  public resetParquetDataPageVersion() {
    this._parquetDataPageVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get parquetDataPageVersionInput() {
    return this._parquetDataPageVersion;
  }

  // parquet_page_size - computed: true, optional: true, required: false
  private _parquetPageSize?: string; 
  public get parquetPageSize() {
    return this.getStringAttribute('parquet_page_size');
  }
  public set parquetPageSize(value: string) {
    this._parquetPageSize = value;
  }
  public resetParquetPageSize() {
    this._parquetPageSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get parquetPageSizeInput() {
    return this._parquetPageSize;
  }

  // parquet_row_group_length - computed: true, optional: true, required: false
  private _parquetRowGroupLength?: number; 
  public get parquetRowGroupLength() {
    return this.getNumberAttribute('parquet_row_group_length');
  }
  public set parquetRowGroupLength(value: number) {
    this._parquetRowGroupLength = value;
  }
  public resetParquetRowGroupLength() {
    this._parquetRowGroupLength = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get parquetRowGroupLengthInput() {
    return this._parquetRowGroupLength;
  }

  // parquet_version - computed: true, optional: true, required: false
  private _parquetVersion?: string; 
  public get parquetVersion() {
    return this.getStringAttribute('parquet_version');
  }
  public set parquetVersion(value: string) {
    this._parquetVersion = value;
  }
  public resetParquetVersion() {
    this._parquetVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get parquetVersionInput() {
    return this._parquetVersion;
  }

  // partition_expr - computed: true, optional: true, required: false
  private _partitionExpr?: string; 
  public get partitionExpr() {
    return this.getStringAttribute('partition_expr');
  }
  public set partitionExpr(value: string) {
    this._partitionExpr = value;
  }
  public resetPartitionExpr() {
    this._partitionExpr = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get partitionExprInput() {
    return this._partitionExpr;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // region - computed: false, optional: true, required: false
  private _region?: string; 
  public get region() {
    return this.getStringAttribute('region');
  }
  public set region(value: string) {
    this._region = value;
  }
  public resetRegion() {
    this._region = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get regionInput() {
    return this._region;
  }

  // reject_unauthorized - computed: true, optional: true, required: false
  private _rejectUnauthorized?: boolean | cdktf.IResolvable; 
  public get rejectUnauthorized() {
    return this.getBooleanAttribute('reject_unauthorized');
  }
  public set rejectUnauthorized(value: boolean | cdktf.IResolvable) {
    this._rejectUnauthorized = value;
  }
  public resetRejectUnauthorized() {
    this._rejectUnauthorized = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectUnauthorizedInput() {
    return this._rejectUnauthorized;
  }

  // remove_empty_dirs - computed: true, optional: true, required: false
  private _removeEmptyDirs?: boolean | cdktf.IResolvable; 
  public get removeEmptyDirs() {
    return this.getBooleanAttribute('remove_empty_dirs');
  }
  public set removeEmptyDirs(value: boolean | cdktf.IResolvable) {
    this._removeEmptyDirs = value;
  }
  public resetRemoveEmptyDirs() {
    this._removeEmptyDirs = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get removeEmptyDirsInput() {
    return this._removeEmptyDirs;
  }

  // reuse_connections - computed: true, optional: true, required: false
  private _reuseConnections?: boolean | cdktf.IResolvable; 
  public get reuseConnections() {
    return this.getBooleanAttribute('reuse_connections');
  }
  public set reuseConnections(value: boolean | cdktf.IResolvable) {
    this._reuseConnections = value;
  }
  public resetReuseConnections() {
    this._reuseConnections = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get reuseConnectionsInput() {
    return this._reuseConnections;
  }

  // server_side_encryption - computed: false, optional: true, required: false
  private _serverSideEncryption?: string; 
  public get serverSideEncryption() {
    return this.getStringAttribute('server_side_encryption');
  }
  public set serverSideEncryption(value: string) {
    this._serverSideEncryption = value;
  }
  public resetServerSideEncryption() {
    this._serverSideEncryption = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serverSideEncryptionInput() {
    return this._serverSideEncryption;
  }

  // should_log_invalid_rows - computed: false, optional: true, required: false
  private _shouldLogInvalidRows?: boolean | cdktf.IResolvable; 
  public get shouldLogInvalidRows() {
    return this.getBooleanAttribute('should_log_invalid_rows');
  }
  public set shouldLogInvalidRows(value: boolean | cdktf.IResolvable) {
    this._shouldLogInvalidRows = value;
  }
  public resetShouldLogInvalidRows() {
    this._shouldLogInvalidRows = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get shouldLogInvalidRowsInput() {
    return this._shouldLogInvalidRows;
  }

  // signature_version - computed: true, optional: true, required: false
  private _signatureVersion?: string; 
  public get signatureVersion() {
    return this.getStringAttribute('signature_version');
  }
  public set signatureVersion(value: string) {
    this._signatureVersion = value;
  }
  public resetSignatureVersion() {
    this._signatureVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get signatureVersionInput() {
    return this._signatureVersion;
  }

  // stage_path - computed: true, optional: true, required: false
  private _stagePath?: string; 
  public get stagePath() {
    return this.getStringAttribute('stage_path');
  }
  public set stagePath(value: string) {
    this._stagePath = value;
  }
  public resetStagePath() {
    this._stagePath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get stagePathInput() {
    return this._stagePath;
  }

  // storage_class - computed: false, optional: true, required: false
  private _storageClass?: string; 
  public get storageClass() {
    return this.getStringAttribute('storage_class');
  }
  public set storageClass(value: string) {
    this._storageClass = value;
  }
  public resetStorageClass() {
    this._storageClass = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get storageClassInput() {
    return this._storageClass;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // system_fields - computed: true, optional: true, required: false
  private _systemFields?: string[]; 
  public get systemFields() {
    return this.getListAttribute('system_fields');
  }
  public set systemFields(value: string[]) {
    this._systemFields = value;
  }
  public resetSystemFields() {
    this._systemFields = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get systemFieldsInput() {
    return this._systemFields;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // verify_permissions - computed: true, optional: true, required: false
  private _verifyPermissions?: boolean | cdktf.IResolvable; 
  public get verifyPermissions() {
    return this.getBooleanAttribute('verify_permissions');
  }
  public set verifyPermissions(value: boolean | cdktf.IResolvable) {
    this._verifyPermissions = value;
  }
  public resetVerifyPermissions() {
    this._verifyPermissions = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get verifyPermissionsInput() {
    return this._verifyPermissions;
  }

  // write_high_water_mark - computed: true, optional: true, required: false
  private _writeHighWaterMark?: number; 
  public get writeHighWaterMark() {
    return this.getNumberAttribute('write_high_water_mark');
  }
  public set writeHighWaterMark(value: number) {
    this._writeHighWaterMark = value;
  }
  public resetWriteHighWaterMark() {
    this._writeHighWaterMark = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get writeHighWaterMarkInput() {
    return this._writeHighWaterMark;
  }
}
export interface PackDestinationOutputMskKafkaSchemaRegistryAuth {
  /**
  * Select or create a secret that references your credentials
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#credentials_secret PackDestination#credentials_secret}
  */
  readonly credentialsSecret?: string;
  /**
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#disabled PackDestination#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
}

export function packDestinationOutputMskKafkaSchemaRegistryAuthToTerraform(struct?: PackDestinationOutputMskKafkaSchemaRegistryAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    credentials_secret: cdktf.stringToTerraform(struct!.credentialsSecret),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
  }
}


export function packDestinationOutputMskKafkaSchemaRegistryAuthToHclTerraform(struct?: PackDestinationOutputMskKafkaSchemaRegistryAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    credentials_secret: {
      value: cdktf.stringToHclTerraform(struct!.credentialsSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputMskKafkaSchemaRegistryAuthOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackDestinationOutputMskKafkaSchemaRegistryAuth | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._credentialsSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.credentialsSecret = this._credentialsSecret;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputMskKafkaSchemaRegistryAuth | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._credentialsSecret = undefined;
      this._disabled = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._credentialsSecret = value.credentialsSecret;
      this._disabled = value.disabled;
    }
  }

  // credentials_secret - computed: false, optional: true, required: false
  private _credentialsSecret?: string; 
  public get credentialsSecret() {
    return this.getStringAttribute('credentials_secret');
  }
  public set credentialsSecret(value: string) {
    this._credentialsSecret = value;
  }
  public resetCredentialsSecret() {
    this._credentialsSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get credentialsSecretInput() {
    return this._credentialsSecret;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }
}
export interface PackDestinationOutputMskKafkaSchemaRegistryTls {
  /**
  * Path on client in which to find CA certificates to verify the server's cert. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#ca_path PackDestination#ca_path}
  */
  readonly caPath?: string;
  /**
  * Path on client in which to find certificates to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#cert_path PackDestination#cert_path}
  */
  readonly certPath?: string;
  /**
  * The name of the predefined certificate
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#certificate_name PackDestination#certificate_name}
  */
  readonly certificateName?: string;
  /**
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#disabled PackDestination#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_version PackDestination#max_version}
  */
  readonly maxVersion?: string;
  /**
  * must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#min_version PackDestination#min_version}
  */
  readonly minVersion?: string;
  /**
  * Passphrase to use to decrypt private key
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#passphrase PackDestination#passphrase}
  */
  readonly passphrase?: string;
  /**
  * Path on client in which to find the private key to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#priv_key_path PackDestination#priv_key_path}
  */
  readonly privKeyPath?: string;
  /**
  * Reject certificates that are not authorized by a CA in the CA certificate path, or by another 
  *                     trusted CA (such as the system's). Defaults to Enabled. Overrides the toggle from Advanced Settings, when also present.
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#reject_unauthorized PackDestination#reject_unauthorized}
  */
  readonly rejectUnauthorized?: boolean | cdktf.IResolvable;
  /**
  * Server name for the SNI (Server Name Indication) TLS extension. It must be a host name, and not an IP address.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#servername PackDestination#servername}
  */
  readonly servername?: string;
}

export function packDestinationOutputMskKafkaSchemaRegistryTlsToTerraform(struct?: PackDestinationOutputMskKafkaSchemaRegistryTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ca_path: cdktf.stringToTerraform(struct!.caPath),
    cert_path: cdktf.stringToTerraform(struct!.certPath),
    certificate_name: cdktf.stringToTerraform(struct!.certificateName),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    max_version: cdktf.stringToTerraform(struct!.maxVersion),
    min_version: cdktf.stringToTerraform(struct!.minVersion),
    passphrase: cdktf.stringToTerraform(struct!.passphrase),
    priv_key_path: cdktf.stringToTerraform(struct!.privKeyPath),
    reject_unauthorized: cdktf.booleanToTerraform(struct!.rejectUnauthorized),
    servername: cdktf.stringToTerraform(struct!.servername),
  }
}


export function packDestinationOutputMskKafkaSchemaRegistryTlsToHclTerraform(struct?: PackDestinationOutputMskKafkaSchemaRegistryTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ca_path: {
      value: cdktf.stringToHclTerraform(struct!.caPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    cert_path: {
      value: cdktf.stringToHclTerraform(struct!.certPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    certificate_name: {
      value: cdktf.stringToHclTerraform(struct!.certificateName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    max_version: {
      value: cdktf.stringToHclTerraform(struct!.maxVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    min_version: {
      value: cdktf.stringToHclTerraform(struct!.minVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    passphrase: {
      value: cdktf.stringToHclTerraform(struct!.passphrase),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    priv_key_path: {
      value: cdktf.stringToHclTerraform(struct!.privKeyPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reject_unauthorized: {
      value: cdktf.booleanToHclTerraform(struct!.rejectUnauthorized),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    servername: {
      value: cdktf.stringToHclTerraform(struct!.servername),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputMskKafkaSchemaRegistryTlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackDestinationOutputMskKafkaSchemaRegistryTls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._caPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.caPath = this._caPath;
    }
    if (this._certPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.certPath = this._certPath;
    }
    if (this._certificateName !== undefined) {
      hasAnyValues = true;
      internalValueResult.certificateName = this._certificateName;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._maxVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxVersion = this._maxVersion;
    }
    if (this._minVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.minVersion = this._minVersion;
    }
    if (this._passphrase !== undefined) {
      hasAnyValues = true;
      internalValueResult.passphrase = this._passphrase;
    }
    if (this._privKeyPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.privKeyPath = this._privKeyPath;
    }
    if (this._rejectUnauthorized !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectUnauthorized = this._rejectUnauthorized;
    }
    if (this._servername !== undefined) {
      hasAnyValues = true;
      internalValueResult.servername = this._servername;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputMskKafkaSchemaRegistryTls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._caPath = undefined;
      this._certPath = undefined;
      this._certificateName = undefined;
      this._disabled = undefined;
      this._maxVersion = undefined;
      this._minVersion = undefined;
      this._passphrase = undefined;
      this._privKeyPath = undefined;
      this._rejectUnauthorized = undefined;
      this._servername = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._caPath = value.caPath;
      this._certPath = value.certPath;
      this._certificateName = value.certificateName;
      this._disabled = value.disabled;
      this._maxVersion = value.maxVersion;
      this._minVersion = value.minVersion;
      this._passphrase = value.passphrase;
      this._privKeyPath = value.privKeyPath;
      this._rejectUnauthorized = value.rejectUnauthorized;
      this._servername = value.servername;
    }
  }

  // ca_path - computed: false, optional: true, required: false
  private _caPath?: string; 
  public get caPath() {
    return this.getStringAttribute('ca_path');
  }
  public set caPath(value: string) {
    this._caPath = value;
  }
  public resetCaPath() {
    this._caPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get caPathInput() {
    return this._caPath;
  }

  // cert_path - computed: false, optional: true, required: false
  private _certPath?: string; 
  public get certPath() {
    return this.getStringAttribute('cert_path');
  }
  public set certPath(value: string) {
    this._certPath = value;
  }
  public resetCertPath() {
    this._certPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certPathInput() {
    return this._certPath;
  }

  // certificate_name - computed: false, optional: true, required: false
  private _certificateName?: string; 
  public get certificateName() {
    return this.getStringAttribute('certificate_name');
  }
  public set certificateName(value: string) {
    this._certificateName = value;
  }
  public resetCertificateName() {
    this._certificateName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certificateNameInput() {
    return this._certificateName;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // max_version - computed: false, optional: true, required: false
  private _maxVersion?: string; 
  public get maxVersion() {
    return this.getStringAttribute('max_version');
  }
  public set maxVersion(value: string) {
    this._maxVersion = value;
  }
  public resetMaxVersion() {
    this._maxVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxVersionInput() {
    return this._maxVersion;
  }

  // min_version - computed: false, optional: true, required: false
  private _minVersion?: string; 
  public get minVersion() {
    return this.getStringAttribute('min_version');
  }
  public set minVersion(value: string) {
    this._minVersion = value;
  }
  public resetMinVersion() {
    this._minVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get minVersionInput() {
    return this._minVersion;
  }

  // passphrase - computed: false, optional: true, required: false
  private _passphrase?: string; 
  public get passphrase() {
    return this.getStringAttribute('passphrase');
  }
  public set passphrase(value: string) {
    this._passphrase = value;
  }
  public resetPassphrase() {
    this._passphrase = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passphraseInput() {
    return this._passphrase;
  }

  // priv_key_path - computed: false, optional: true, required: false
  private _privKeyPath?: string; 
  public get privKeyPath() {
    return this.getStringAttribute('priv_key_path');
  }
  public set privKeyPath(value: string) {
    this._privKeyPath = value;
  }
  public resetPrivKeyPath() {
    this._privKeyPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get privKeyPathInput() {
    return this._privKeyPath;
  }

  // reject_unauthorized - computed: true, optional: true, required: false
  private _rejectUnauthorized?: boolean | cdktf.IResolvable; 
  public get rejectUnauthorized() {
    return this.getBooleanAttribute('reject_unauthorized');
  }
  public set rejectUnauthorized(value: boolean | cdktf.IResolvable) {
    this._rejectUnauthorized = value;
  }
  public resetRejectUnauthorized() {
    this._rejectUnauthorized = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectUnauthorizedInput() {
    return this._rejectUnauthorized;
  }

  // servername - computed: false, optional: true, required: false
  private _servername?: string; 
  public get servername() {
    return this.getStringAttribute('servername');
  }
  public set servername(value: string) {
    this._servername = value;
  }
  public resetServername() {
    this._servername = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get servernameInput() {
    return this._servername;
  }
}
export interface PackDestinationOutputMskKafkaSchemaRegistry {
  /**
  * Credentials to use when authenticating with the schema registry using basic HTTP authentication
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#auth PackDestination#auth}
  */
  readonly auth?: PackDestinationOutputMskKafkaSchemaRegistryAuth;
  /**
  * Maximum time to wait for a Schema Registry connection to complete successfully. Default: 30000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#connection_timeout PackDestination#connection_timeout}
  */
  readonly connectionTimeout?: number;
  /**
  * Used when __keySchemaIdOut is not present, to transform key values, leave blank if key transformation is not required by default.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#default_key_schema_id PackDestination#default_key_schema_id}
  */
  readonly defaultKeySchemaId?: number;
  /**
  * Used when __valueSchemaIdOut is not present, to transform _raw, leave blank if value transformation is not required by default.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#default_value_schema_id PackDestination#default_value_schema_id}
  */
  readonly defaultValueSchemaId?: number;
  /**
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#disabled PackDestination#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * Maximum number of times to try fetching schemas from the Schema Registry. Default: 1
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_retries PackDestination#max_retries}
  */
  readonly maxRetries?: number;
  /**
  * Maximum time to wait for the Schema Registry to respond to a request. Default: 30000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#request_timeout PackDestination#request_timeout}
  */
  readonly requestTimeout?: number;
  /**
  * URL for accessing the Confluent Schema Registry. Example: http://localhost:8081. To connect over TLS, use https instead of http. Default: "http://localhost:8081"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#schema_registry_url PackDestination#schema_registry_url}
  */
  readonly schemaRegistryUrl?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#tls PackDestination#tls}
  */
  readonly tls?: PackDestinationOutputMskKafkaSchemaRegistryTls;
}

export function packDestinationOutputMskKafkaSchemaRegistryToTerraform(struct?: PackDestinationOutputMskKafkaSchemaRegistry | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    auth: packDestinationOutputMskKafkaSchemaRegistryAuthToTerraform(struct!.auth),
    connection_timeout: cdktf.numberToTerraform(struct!.connectionTimeout),
    default_key_schema_id: cdktf.numberToTerraform(struct!.defaultKeySchemaId),
    default_value_schema_id: cdktf.numberToTerraform(struct!.defaultValueSchemaId),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    max_retries: cdktf.numberToTerraform(struct!.maxRetries),
    request_timeout: cdktf.numberToTerraform(struct!.requestTimeout),
    schema_registry_url: cdktf.stringToTerraform(struct!.schemaRegistryUrl),
    tls: packDestinationOutputMskKafkaSchemaRegistryTlsToTerraform(struct!.tls),
  }
}


export function packDestinationOutputMskKafkaSchemaRegistryToHclTerraform(struct?: PackDestinationOutputMskKafkaSchemaRegistry | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    auth: {
      value: packDestinationOutputMskKafkaSchemaRegistryAuthToHclTerraform(struct!.auth),
      isBlock: true,
      type: "struct",
      storageClassType: "PackDestinationOutputMskKafkaSchemaRegistryAuth",
    },
    connection_timeout: {
      value: cdktf.numberToHclTerraform(struct!.connectionTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    default_key_schema_id: {
      value: cdktf.numberToHclTerraform(struct!.defaultKeySchemaId),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    default_value_schema_id: {
      value: cdktf.numberToHclTerraform(struct!.defaultValueSchemaId),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    max_retries: {
      value: cdktf.numberToHclTerraform(struct!.maxRetries),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    request_timeout: {
      value: cdktf.numberToHclTerraform(struct!.requestTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    schema_registry_url: {
      value: cdktf.stringToHclTerraform(struct!.schemaRegistryUrl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tls: {
      value: packDestinationOutputMskKafkaSchemaRegistryTlsToHclTerraform(struct!.tls),
      isBlock: true,
      type: "struct",
      storageClassType: "PackDestinationOutputMskKafkaSchemaRegistryTls",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputMskKafkaSchemaRegistryOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackDestinationOutputMskKafkaSchemaRegistry | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._auth?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.auth = this._auth?.internalValue;
    }
    if (this._connectionTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.connectionTimeout = this._connectionTimeout;
    }
    if (this._defaultKeySchemaId !== undefined) {
      hasAnyValues = true;
      internalValueResult.defaultKeySchemaId = this._defaultKeySchemaId;
    }
    if (this._defaultValueSchemaId !== undefined) {
      hasAnyValues = true;
      internalValueResult.defaultValueSchemaId = this._defaultValueSchemaId;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._maxRetries !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxRetries = this._maxRetries;
    }
    if (this._requestTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.requestTimeout = this._requestTimeout;
    }
    if (this._schemaRegistryUrl !== undefined) {
      hasAnyValues = true;
      internalValueResult.schemaRegistryUrl = this._schemaRegistryUrl;
    }
    if (this._tls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tls = this._tls?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputMskKafkaSchemaRegistry | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._auth.internalValue = undefined;
      this._connectionTimeout = undefined;
      this._defaultKeySchemaId = undefined;
      this._defaultValueSchemaId = undefined;
      this._disabled = undefined;
      this._maxRetries = undefined;
      this._requestTimeout = undefined;
      this._schemaRegistryUrl = undefined;
      this._tls.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._auth.internalValue = value.auth;
      this._connectionTimeout = value.connectionTimeout;
      this._defaultKeySchemaId = value.defaultKeySchemaId;
      this._defaultValueSchemaId = value.defaultValueSchemaId;
      this._disabled = value.disabled;
      this._maxRetries = value.maxRetries;
      this._requestTimeout = value.requestTimeout;
      this._schemaRegistryUrl = value.schemaRegistryUrl;
      this._tls.internalValue = value.tls;
    }
  }

  // auth - computed: false, optional: true, required: false
  private _auth = new PackDestinationOutputMskKafkaSchemaRegistryAuthOutputReference(this, "auth");
  public get auth() {
    return this._auth;
  }
  public putAuth(value: PackDestinationOutputMskKafkaSchemaRegistryAuth) {
    this._auth.internalValue = value;
  }
  public resetAuth() {
    this._auth.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authInput() {
    return this._auth.internalValue;
  }

  // connection_timeout - computed: true, optional: true, required: false
  private _connectionTimeout?: number; 
  public get connectionTimeout() {
    return this.getNumberAttribute('connection_timeout');
  }
  public set connectionTimeout(value: number) {
    this._connectionTimeout = value;
  }
  public resetConnectionTimeout() {
    this._connectionTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectionTimeoutInput() {
    return this._connectionTimeout;
  }

  // default_key_schema_id - computed: false, optional: true, required: false
  private _defaultKeySchemaId?: number; 
  public get defaultKeySchemaId() {
    return this.getNumberAttribute('default_key_schema_id');
  }
  public set defaultKeySchemaId(value: number) {
    this._defaultKeySchemaId = value;
  }
  public resetDefaultKeySchemaId() {
    this._defaultKeySchemaId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get defaultKeySchemaIdInput() {
    return this._defaultKeySchemaId;
  }

  // default_value_schema_id - computed: false, optional: true, required: false
  private _defaultValueSchemaId?: number; 
  public get defaultValueSchemaId() {
    return this.getNumberAttribute('default_value_schema_id');
  }
  public set defaultValueSchemaId(value: number) {
    this._defaultValueSchemaId = value;
  }
  public resetDefaultValueSchemaId() {
    this._defaultValueSchemaId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get defaultValueSchemaIdInput() {
    return this._defaultValueSchemaId;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // max_retries - computed: true, optional: true, required: false
  private _maxRetries?: number; 
  public get maxRetries() {
    return this.getNumberAttribute('max_retries');
  }
  public set maxRetries(value: number) {
    this._maxRetries = value;
  }
  public resetMaxRetries() {
    this._maxRetries = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxRetriesInput() {
    return this._maxRetries;
  }

  // request_timeout - computed: true, optional: true, required: false
  private _requestTimeout?: number; 
  public get requestTimeout() {
    return this.getNumberAttribute('request_timeout');
  }
  public set requestTimeout(value: number) {
    this._requestTimeout = value;
  }
  public resetRequestTimeout() {
    this._requestTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestTimeoutInput() {
    return this._requestTimeout;
  }

  // schema_registry_url - computed: true, optional: true, required: false
  private _schemaRegistryUrl?: string; 
  public get schemaRegistryUrl() {
    return this.getStringAttribute('schema_registry_url');
  }
  public set schemaRegistryUrl(value: string) {
    this._schemaRegistryUrl = value;
  }
  public resetSchemaRegistryUrl() {
    this._schemaRegistryUrl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get schemaRegistryUrlInput() {
    return this._schemaRegistryUrl;
  }

  // tls - computed: false, optional: true, required: false
  private _tls = new PackDestinationOutputMskKafkaSchemaRegistryTlsOutputReference(this, "tls");
  public get tls() {
    return this._tls;
  }
  public putTls(value: PackDestinationOutputMskKafkaSchemaRegistryTls) {
    this._tls.internalValue = value;
  }
  public resetTls() {
    this._tls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsInput() {
    return this._tls.internalValue;
  }
}
export interface PackDestinationOutputMskPqControls {
}

export function packDestinationOutputMskPqControlsToTerraform(struct?: PackDestinationOutputMskPqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function packDestinationOutputMskPqControlsToHclTerraform(struct?: PackDestinationOutputMskPqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class PackDestinationOutputMskPqControlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackDestinationOutputMskPqControls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputMskPqControls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface PackDestinationOutputMskTls {
  /**
  * Path on client in which to find CA certificates to verify the server's cert. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#ca_path PackDestination#ca_path}
  */
  readonly caPath?: string;
  /**
  * Path on client in which to find certificates to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#cert_path PackDestination#cert_path}
  */
  readonly certPath?: string;
  /**
  * The name of the predefined certificate
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#certificate_name PackDestination#certificate_name}
  */
  readonly certificateName?: string;
  /**
  * Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#disabled PackDestination#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_version PackDestination#max_version}
  */
  readonly maxVersion?: string;
  /**
  * must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#min_version PackDestination#min_version}
  */
  readonly minVersion?: string;
  /**
  * Passphrase to use to decrypt private key
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#passphrase PackDestination#passphrase}
  */
  readonly passphrase?: string;
  /**
  * Path on client in which to find the private key to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#priv_key_path PackDestination#priv_key_path}
  */
  readonly privKeyPath?: string;
  /**
  * Reject certificates that are not authorized by a CA in the CA certificate path, or by another
  * 
  * 
  *                     trusted CA (such as the system's). Defaults to Enabled. Overrides the toggle from Advanced Settings, when also present.
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#reject_unauthorized PackDestination#reject_unauthorized}
  */
  readonly rejectUnauthorized?: boolean | cdktf.IResolvable;
  /**
  * Server name for the SNI (Server Name Indication) TLS extension. It must be a host name, and not an IP address.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#servername PackDestination#servername}
  */
  readonly servername?: string;
}

export function packDestinationOutputMskTlsToTerraform(struct?: PackDestinationOutputMskTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ca_path: cdktf.stringToTerraform(struct!.caPath),
    cert_path: cdktf.stringToTerraform(struct!.certPath),
    certificate_name: cdktf.stringToTerraform(struct!.certificateName),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    max_version: cdktf.stringToTerraform(struct!.maxVersion),
    min_version: cdktf.stringToTerraform(struct!.minVersion),
    passphrase: cdktf.stringToTerraform(struct!.passphrase),
    priv_key_path: cdktf.stringToTerraform(struct!.privKeyPath),
    reject_unauthorized: cdktf.booleanToTerraform(struct!.rejectUnauthorized),
    servername: cdktf.stringToTerraform(struct!.servername),
  }
}


export function packDestinationOutputMskTlsToHclTerraform(struct?: PackDestinationOutputMskTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ca_path: {
      value: cdktf.stringToHclTerraform(struct!.caPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    cert_path: {
      value: cdktf.stringToHclTerraform(struct!.certPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    certificate_name: {
      value: cdktf.stringToHclTerraform(struct!.certificateName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    max_version: {
      value: cdktf.stringToHclTerraform(struct!.maxVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    min_version: {
      value: cdktf.stringToHclTerraform(struct!.minVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    passphrase: {
      value: cdktf.stringToHclTerraform(struct!.passphrase),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    priv_key_path: {
      value: cdktf.stringToHclTerraform(struct!.privKeyPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reject_unauthorized: {
      value: cdktf.booleanToHclTerraform(struct!.rejectUnauthorized),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    servername: {
      value: cdktf.stringToHclTerraform(struct!.servername),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputMskTlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackDestinationOutputMskTls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._caPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.caPath = this._caPath;
    }
    if (this._certPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.certPath = this._certPath;
    }
    if (this._certificateName !== undefined) {
      hasAnyValues = true;
      internalValueResult.certificateName = this._certificateName;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._maxVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxVersion = this._maxVersion;
    }
    if (this._minVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.minVersion = this._minVersion;
    }
    if (this._passphrase !== undefined) {
      hasAnyValues = true;
      internalValueResult.passphrase = this._passphrase;
    }
    if (this._privKeyPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.privKeyPath = this._privKeyPath;
    }
    if (this._rejectUnauthorized !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectUnauthorized = this._rejectUnauthorized;
    }
    if (this._servername !== undefined) {
      hasAnyValues = true;
      internalValueResult.servername = this._servername;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputMskTls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._caPath = undefined;
      this._certPath = undefined;
      this._certificateName = undefined;
      this._disabled = undefined;
      this._maxVersion = undefined;
      this._minVersion = undefined;
      this._passphrase = undefined;
      this._privKeyPath = undefined;
      this._rejectUnauthorized = undefined;
      this._servername = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._caPath = value.caPath;
      this._certPath = value.certPath;
      this._certificateName = value.certificateName;
      this._disabled = value.disabled;
      this._maxVersion = value.maxVersion;
      this._minVersion = value.minVersion;
      this._passphrase = value.passphrase;
      this._privKeyPath = value.privKeyPath;
      this._rejectUnauthorized = value.rejectUnauthorized;
      this._servername = value.servername;
    }
  }

  // ca_path - computed: false, optional: true, required: false
  private _caPath?: string; 
  public get caPath() {
    return this.getStringAttribute('ca_path');
  }
  public set caPath(value: string) {
    this._caPath = value;
  }
  public resetCaPath() {
    this._caPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get caPathInput() {
    return this._caPath;
  }

  // cert_path - computed: false, optional: true, required: false
  private _certPath?: string; 
  public get certPath() {
    return this.getStringAttribute('cert_path');
  }
  public set certPath(value: string) {
    this._certPath = value;
  }
  public resetCertPath() {
    this._certPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certPathInput() {
    return this._certPath;
  }

  // certificate_name - computed: false, optional: true, required: false
  private _certificateName?: string; 
  public get certificateName() {
    return this.getStringAttribute('certificate_name');
  }
  public set certificateName(value: string) {
    this._certificateName = value;
  }
  public resetCertificateName() {
    this._certificateName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certificateNameInput() {
    return this._certificateName;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // max_version - computed: false, optional: true, required: false
  private _maxVersion?: string; 
  public get maxVersion() {
    return this.getStringAttribute('max_version');
  }
  public set maxVersion(value: string) {
    this._maxVersion = value;
  }
  public resetMaxVersion() {
    this._maxVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxVersionInput() {
    return this._maxVersion;
  }

  // min_version - computed: false, optional: true, required: false
  private _minVersion?: string; 
  public get minVersion() {
    return this.getStringAttribute('min_version');
  }
  public set minVersion(value: string) {
    this._minVersion = value;
  }
  public resetMinVersion() {
    this._minVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get minVersionInput() {
    return this._minVersion;
  }

  // passphrase - computed: false, optional: true, required: false
  private _passphrase?: string; 
  public get passphrase() {
    return this.getStringAttribute('passphrase');
  }
  public set passphrase(value: string) {
    this._passphrase = value;
  }
  public resetPassphrase() {
    this._passphrase = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passphraseInput() {
    return this._passphrase;
  }

  // priv_key_path - computed: false, optional: true, required: false
  private _privKeyPath?: string; 
  public get privKeyPath() {
    return this.getStringAttribute('priv_key_path');
  }
  public set privKeyPath(value: string) {
    this._privKeyPath = value;
  }
  public resetPrivKeyPath() {
    this._privKeyPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get privKeyPathInput() {
    return this._privKeyPath;
  }

  // reject_unauthorized - computed: true, optional: true, required: false
  private _rejectUnauthorized?: boolean | cdktf.IResolvable; 
  public get rejectUnauthorized() {
    return this.getBooleanAttribute('reject_unauthorized');
  }
  public set rejectUnauthorized(value: boolean | cdktf.IResolvable) {
    this._rejectUnauthorized = value;
  }
  public resetRejectUnauthorized() {
    this._rejectUnauthorized = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectUnauthorizedInput() {
    return this._rejectUnauthorized;
  }

  // servername - computed: false, optional: true, required: false
  private _servername?: string; 
  public get servername() {
    return this.getStringAttribute('servername');
  }
  public set servername(value: string) {
    this._servername = value;
  }
  public resetServername() {
    this._servername = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get servernameInput() {
    return this._servername;
  }
}
export interface PackDestinationOutputMsk {
  /**
  * Control the number of required acknowledgments. Default: 1; must be one of ["1", "0", "-1"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#ack PackDestination#ack}
  */
  readonly ack?: number;
  /**
  * Amazon Resource Name (ARN) of the role to assume
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#assume_role_arn PackDestination#assume_role_arn}
  */
  readonly assumeRoleArn?: string;
  /**
  * External ID to use when assuming role
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#assume_role_external_id PackDestination#assume_role_external_id}
  */
  readonly assumeRoleExternalId?: string;
  /**
  * Maximum time to wait for Kafka to respond to an authentication request. Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#authentication_timeout PackDestination#authentication_timeout}
  */
  readonly authenticationTimeout?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#aws_api_key PackDestination#aws_api_key}
  */
  readonly awsApiKey?: string;
  /**
  * AWS authentication method. Choose Auto to use IAM roles. Default: "auto"; must be one of ["auto", "manual", "secret"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#aws_authentication_method PackDestination#aws_authentication_method}
  */
  readonly awsAuthenticationMethod?: string;
  /**
  * Select or create a stored secret that references your access key and secret key
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#aws_secret PackDestination#aws_secret}
  */
  readonly awsSecret?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#aws_secret_key PackDestination#aws_secret_key}
  */
  readonly awsSecretKey?: string;
  /**
  * Set the backoff multiplier (2-20) to control the retry frequency for failed messages. For faster retries, use a lower multiplier. For slower retries with more delay between attempts, use a higher multiplier. The multiplier is used in an exponential backoff formula; see the Kafka [documentation](https://kafka.js.org/docs/retry-detailed) for details. Default: 2
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#backoff_rate PackDestination#backoff_rate}
  */
  readonly backoffRate?: number;
  /**
  * Enter each Kafka bootstrap server you want to use. Specify hostname and port, e.g., mykafkabroker:9092, or just hostname, in which case @{product} will assign port 9092.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#brokers PackDestination#brokers}
  */
  readonly brokers: string[];
  /**
  * Codec to use to compress the data before sending to Kafka. Default: "gzip"; must be one of ["none", "gzip", "snappy", "lz4"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#compression PackDestination#compression}
  */
  readonly compression?: string;
  /**
  * Maximum time to wait for a connection to complete successfully. Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#connection_timeout PackDestination#connection_timeout}
  */
  readonly connectionTimeout?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#description PackDestination#description}
  */
  readonly description?: string;
  /**
  * Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours). Default: 3600
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#duration_seconds PackDestination#duration_seconds}
  */
  readonly durationSeconds?: number;
  /**
  * Use Assume Role credentials to access MSK. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#enable_assume_role PackDestination#enable_assume_role}
  */
  readonly enableAssumeRole?: boolean | cdktf.IResolvable;
  /**
  * MSK cluster service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to MSK cluster-compatible endpoint.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#endpoint PackDestination#endpoint}
  */
  readonly endpoint?: string;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#environment PackDestination#environment}
  */
  readonly environment?: string;
  /**
  * The maximum number of events you want the Destination to allow in a batch before forcing a flush. Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#flush_event_count PackDestination#flush_event_count}
  */
  readonly flushEventCount?: number;
  /**
  * The maximum amount of time you want the Destination to wait before forcing a flush. Shorter intervals tend to result in smaller batches being sent. Default: 1
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#flush_period_sec PackDestination#flush_period_sec}
  */
  readonly flushPeriodSec?: number;
  /**
  * Format to use to serialize events before writing to Kafka. Default: "json"; must be one of ["json", "raw", "protobuf"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#format PackDestination#format}
  */
  readonly format?: string;
  /**
  * Unique ID for this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#id PackDestination#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * Initial value used to calculate the retry, in milliseconds. Maximum is 600,000 ms (10 minutes). Default: 300
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#initial_backoff PackDestination#initial_backoff}
  */
  readonly initialBackoff?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#kafka_schema_registry PackDestination#kafka_schema_registry}
  */
  readonly kafkaSchemaRegistry?: PackDestinationOutputMskKafkaSchemaRegistry;
  /**
  * The maximum wait time for a retry, in milliseconds. Default (and minimum) is 30,000 ms (30 seconds); maximum is 180,000 ms (180 seconds). Default: 30000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_back_off PackDestination#max_back_off}
  */
  readonly maxBackOff?: number;
  /**
  * Maximum size of each record batch before compression. The value must not exceed the Kafka brokers' message.max.bytes setting. Default: 768
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_record_size_kb PackDestination#max_record_size_kb}
  */
  readonly maxRecordSizeKb?: number;
  /**
  * If messages are failing, you can set the maximum number of retries as high as 100 to prevent loss of data. Default: 5
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_retries PackDestination#max_retries}
  */
  readonly maxRetries?: number;
  /**
  * How to handle events when all receivers are exerting backpressure. Default: "block"; must be one of ["block", "drop", "queue"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#on_backpressure PackDestination#on_backpressure}
  */
  readonly onBackpressure?: string;
  /**
  * Pipeline to process data before sending out to this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pipeline PackDestination#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_compress PackDestination#pq_compress}
  */
  readonly pqCompress?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_controls PackDestination#pq_controls}
  */
  readonly pqControls?: PackDestinationOutputMskPqControls;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.). Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_max_file_size PackDestination#pq_max_file_size}
  */
  readonly pqMaxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_max_size PackDestination#pq_max_size}
  */
  readonly pqMaxSize?: string;
  /**
  * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem. Default: "error"; must be one of ["error", "backpressure", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_mode PackDestination#pq_mode}
  */
  readonly pqMode?: string;
  /**
  * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged. Default: "block"; must be one of ["block", "drop"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_on_backpressure PackDestination#pq_on_backpressure}
  */
  readonly pqOnBackpressure?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_path PackDestination#pq_path}
  */
  readonly pqPath?: string;
  /**
  * Select a set of Protobuf definitions for the events you want to send
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#protobuf_library_id PackDestination#protobuf_library_id}
  */
  readonly protobufLibraryId?: string;
  /**
  * Specifies a time window during which @{product} can reauthenticate if needed. Creates the window measuring backward from the moment when credentials are set to expire. Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#reauthentication_threshold PackDestination#reauthentication_threshold}
  */
  readonly reauthenticationThreshold?: number;
  /**
  * Region where the MSK cluster is located
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#region PackDestination#region}
  */
  readonly region: string;
  /**
  * Reject certificates that cannot be verified against a valid CA, such as self-signed certificates. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#reject_unauthorized PackDestination#reject_unauthorized}
  */
  readonly rejectUnauthorized?: boolean | cdktf.IResolvable;
  /**
  * Maximum time to wait for Kafka to respond to a request. Default: 60000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#request_timeout PackDestination#request_timeout}
  */
  readonly requestTimeout?: number;
  /**
  * Reuse connections between requests, which can improve performance. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#reuse_connections PackDestination#reuse_connections}
  */
  readonly reuseConnections?: boolean | cdktf.IResolvable;
  /**
  * Signature version to use for signing MSK cluster requests. Default: "v4"; must be one of ["v2", "v4"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#signature_version PackDestination#signature_version}
  */
  readonly signatureVersion?: string;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#streamtags PackDestination#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Fields to automatically add to events, such as cribl_pipe. Supports wildcards. Default: ["cribl_pipe"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#system_fields PackDestination#system_fields}
  */
  readonly systemFields?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#tls PackDestination#tls}
  */
  readonly tls?: PackDestinationOutputMskTls;
  /**
  * The topic to publish events to. Can be overridden using the __topicOut field.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#topic PackDestination#topic}
  */
  readonly topic: string;
  /**
  * must be "msk"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#type PackDestination#type}
  */
  readonly type?: string;
}

export function packDestinationOutputMskToTerraform(struct?: PackDestinationOutputMsk | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ack: cdktf.numberToTerraform(struct!.ack),
    assume_role_arn: cdktf.stringToTerraform(struct!.assumeRoleArn),
    assume_role_external_id: cdktf.stringToTerraform(struct!.assumeRoleExternalId),
    authentication_timeout: cdktf.numberToTerraform(struct!.authenticationTimeout),
    aws_api_key: cdktf.stringToTerraform(struct!.awsApiKey),
    aws_authentication_method: cdktf.stringToTerraform(struct!.awsAuthenticationMethod),
    aws_secret: cdktf.stringToTerraform(struct!.awsSecret),
    aws_secret_key: cdktf.stringToTerraform(struct!.awsSecretKey),
    backoff_rate: cdktf.numberToTerraform(struct!.backoffRate),
    brokers: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.brokers),
    compression: cdktf.stringToTerraform(struct!.compression),
    connection_timeout: cdktf.numberToTerraform(struct!.connectionTimeout),
    description: cdktf.stringToTerraform(struct!.description),
    duration_seconds: cdktf.numberToTerraform(struct!.durationSeconds),
    enable_assume_role: cdktf.booleanToTerraform(struct!.enableAssumeRole),
    endpoint: cdktf.stringToTerraform(struct!.endpoint),
    environment: cdktf.stringToTerraform(struct!.environment),
    flush_event_count: cdktf.numberToTerraform(struct!.flushEventCount),
    flush_period_sec: cdktf.numberToTerraform(struct!.flushPeriodSec),
    format: cdktf.stringToTerraform(struct!.format),
    id: cdktf.stringToTerraform(struct!.id),
    initial_backoff: cdktf.numberToTerraform(struct!.initialBackoff),
    kafka_schema_registry: packDestinationOutputMskKafkaSchemaRegistryToTerraform(struct!.kafkaSchemaRegistry),
    max_back_off: cdktf.numberToTerraform(struct!.maxBackOff),
    max_record_size_kb: cdktf.numberToTerraform(struct!.maxRecordSizeKb),
    max_retries: cdktf.numberToTerraform(struct!.maxRetries),
    on_backpressure: cdktf.stringToTerraform(struct!.onBackpressure),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    pq_compress: cdktf.stringToTerraform(struct!.pqCompress),
    pq_controls: packDestinationOutputMskPqControlsToTerraform(struct!.pqControls),
    pq_max_file_size: cdktf.stringToTerraform(struct!.pqMaxFileSize),
    pq_max_size: cdktf.stringToTerraform(struct!.pqMaxSize),
    pq_mode: cdktf.stringToTerraform(struct!.pqMode),
    pq_on_backpressure: cdktf.stringToTerraform(struct!.pqOnBackpressure),
    pq_path: cdktf.stringToTerraform(struct!.pqPath),
    protobuf_library_id: cdktf.stringToTerraform(struct!.protobufLibraryId),
    reauthentication_threshold: cdktf.numberToTerraform(struct!.reauthenticationThreshold),
    region: cdktf.stringToTerraform(struct!.region),
    reject_unauthorized: cdktf.booleanToTerraform(struct!.rejectUnauthorized),
    request_timeout: cdktf.numberToTerraform(struct!.requestTimeout),
    reuse_connections: cdktf.booleanToTerraform(struct!.reuseConnections),
    signature_version: cdktf.stringToTerraform(struct!.signatureVersion),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    system_fields: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.systemFields),
    tls: packDestinationOutputMskTlsToTerraform(struct!.tls),
    topic: cdktf.stringToTerraform(struct!.topic),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function packDestinationOutputMskToHclTerraform(struct?: PackDestinationOutputMsk | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ack: {
      value: cdktf.numberToHclTerraform(struct!.ack),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    assume_role_arn: {
      value: cdktf.stringToHclTerraform(struct!.assumeRoleArn),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    assume_role_external_id: {
      value: cdktf.stringToHclTerraform(struct!.assumeRoleExternalId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    authentication_timeout: {
      value: cdktf.numberToHclTerraform(struct!.authenticationTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    aws_api_key: {
      value: cdktf.stringToHclTerraform(struct!.awsApiKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    aws_authentication_method: {
      value: cdktf.stringToHclTerraform(struct!.awsAuthenticationMethod),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    aws_secret: {
      value: cdktf.stringToHclTerraform(struct!.awsSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    aws_secret_key: {
      value: cdktf.stringToHclTerraform(struct!.awsSecretKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    backoff_rate: {
      value: cdktf.numberToHclTerraform(struct!.backoffRate),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    brokers: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.brokers),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    compression: {
      value: cdktf.stringToHclTerraform(struct!.compression),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    connection_timeout: {
      value: cdktf.numberToHclTerraform(struct!.connectionTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    duration_seconds: {
      value: cdktf.numberToHclTerraform(struct!.durationSeconds),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    enable_assume_role: {
      value: cdktf.booleanToHclTerraform(struct!.enableAssumeRole),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    endpoint: {
      value: cdktf.stringToHclTerraform(struct!.endpoint),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    flush_event_count: {
      value: cdktf.numberToHclTerraform(struct!.flushEventCount),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    flush_period_sec: {
      value: cdktf.numberToHclTerraform(struct!.flushPeriodSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    format: {
      value: cdktf.stringToHclTerraform(struct!.format),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    initial_backoff: {
      value: cdktf.numberToHclTerraform(struct!.initialBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    kafka_schema_registry: {
      value: packDestinationOutputMskKafkaSchemaRegistryToHclTerraform(struct!.kafkaSchemaRegistry),
      isBlock: true,
      type: "struct",
      storageClassType: "PackDestinationOutputMskKafkaSchemaRegistry",
    },
    max_back_off: {
      value: cdktf.numberToHclTerraform(struct!.maxBackOff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_record_size_kb: {
      value: cdktf.numberToHclTerraform(struct!.maxRecordSizeKb),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_retries: {
      value: cdktf.numberToHclTerraform(struct!.maxRetries),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.onBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_compress: {
      value: cdktf.stringToHclTerraform(struct!.pqCompress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_controls: {
      value: packDestinationOutputMskPqControlsToHclTerraform(struct!.pqControls),
      isBlock: true,
      type: "struct",
      storageClassType: "PackDestinationOutputMskPqControls",
    },
    pq_max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_max_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_mode: {
      value: cdktf.stringToHclTerraform(struct!.pqMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.pqOnBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_path: {
      value: cdktf.stringToHclTerraform(struct!.pqPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    protobuf_library_id: {
      value: cdktf.stringToHclTerraform(struct!.protobufLibraryId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reauthentication_threshold: {
      value: cdktf.numberToHclTerraform(struct!.reauthenticationThreshold),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    region: {
      value: cdktf.stringToHclTerraform(struct!.region),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reject_unauthorized: {
      value: cdktf.booleanToHclTerraform(struct!.rejectUnauthorized),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    request_timeout: {
      value: cdktf.numberToHclTerraform(struct!.requestTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    reuse_connections: {
      value: cdktf.booleanToHclTerraform(struct!.reuseConnections),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    signature_version: {
      value: cdktf.stringToHclTerraform(struct!.signatureVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    system_fields: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.systemFields),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    tls: {
      value: packDestinationOutputMskTlsToHclTerraform(struct!.tls),
      isBlock: true,
      type: "struct",
      storageClassType: "PackDestinationOutputMskTls",
    },
    topic: {
      value: cdktf.stringToHclTerraform(struct!.topic),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputMskOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackDestinationOutputMsk | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._ack !== undefined) {
      hasAnyValues = true;
      internalValueResult.ack = this._ack;
    }
    if (this._assumeRoleArn !== undefined) {
      hasAnyValues = true;
      internalValueResult.assumeRoleArn = this._assumeRoleArn;
    }
    if (this._assumeRoleExternalId !== undefined) {
      hasAnyValues = true;
      internalValueResult.assumeRoleExternalId = this._assumeRoleExternalId;
    }
    if (this._authenticationTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.authenticationTimeout = this._authenticationTimeout;
    }
    if (this._awsApiKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.awsApiKey = this._awsApiKey;
    }
    if (this._awsAuthenticationMethod !== undefined) {
      hasAnyValues = true;
      internalValueResult.awsAuthenticationMethod = this._awsAuthenticationMethod;
    }
    if (this._awsSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.awsSecret = this._awsSecret;
    }
    if (this._awsSecretKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.awsSecretKey = this._awsSecretKey;
    }
    if (this._backoffRate !== undefined) {
      hasAnyValues = true;
      internalValueResult.backoffRate = this._backoffRate;
    }
    if (this._brokers !== undefined) {
      hasAnyValues = true;
      internalValueResult.brokers = this._brokers;
    }
    if (this._compression !== undefined) {
      hasAnyValues = true;
      internalValueResult.compression = this._compression;
    }
    if (this._connectionTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.connectionTimeout = this._connectionTimeout;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._durationSeconds !== undefined) {
      hasAnyValues = true;
      internalValueResult.durationSeconds = this._durationSeconds;
    }
    if (this._enableAssumeRole !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableAssumeRole = this._enableAssumeRole;
    }
    if (this._endpoint !== undefined) {
      hasAnyValues = true;
      internalValueResult.endpoint = this._endpoint;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._flushEventCount !== undefined) {
      hasAnyValues = true;
      internalValueResult.flushEventCount = this._flushEventCount;
    }
    if (this._flushPeriodSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.flushPeriodSec = this._flushPeriodSec;
    }
    if (this._format !== undefined) {
      hasAnyValues = true;
      internalValueResult.format = this._format;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._initialBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.initialBackoff = this._initialBackoff;
    }
    if (this._kafkaSchemaRegistry?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.kafkaSchemaRegistry = this._kafkaSchemaRegistry?.internalValue;
    }
    if (this._maxBackOff !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBackOff = this._maxBackOff;
    }
    if (this._maxRecordSizeKb !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxRecordSizeKb = this._maxRecordSizeKb;
    }
    if (this._maxRetries !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxRetries = this._maxRetries;
    }
    if (this._onBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.onBackpressure = this._onBackpressure;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._pqCompress !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqCompress = this._pqCompress;
    }
    if (this._pqControls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqControls = this._pqControls?.internalValue;
    }
    if (this._pqMaxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxFileSize = this._pqMaxFileSize;
    }
    if (this._pqMaxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxSize = this._pqMaxSize;
    }
    if (this._pqMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMode = this._pqMode;
    }
    if (this._pqOnBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqOnBackpressure = this._pqOnBackpressure;
    }
    if (this._pqPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqPath = this._pqPath;
    }
    if (this._protobufLibraryId !== undefined) {
      hasAnyValues = true;
      internalValueResult.protobufLibraryId = this._protobufLibraryId;
    }
    if (this._reauthenticationThreshold !== undefined) {
      hasAnyValues = true;
      internalValueResult.reauthenticationThreshold = this._reauthenticationThreshold;
    }
    if (this._region !== undefined) {
      hasAnyValues = true;
      internalValueResult.region = this._region;
    }
    if (this._rejectUnauthorized !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectUnauthorized = this._rejectUnauthorized;
    }
    if (this._requestTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.requestTimeout = this._requestTimeout;
    }
    if (this._reuseConnections !== undefined) {
      hasAnyValues = true;
      internalValueResult.reuseConnections = this._reuseConnections;
    }
    if (this._signatureVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.signatureVersion = this._signatureVersion;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._systemFields !== undefined) {
      hasAnyValues = true;
      internalValueResult.systemFields = this._systemFields;
    }
    if (this._tls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tls = this._tls?.internalValue;
    }
    if (this._topic !== undefined) {
      hasAnyValues = true;
      internalValueResult.topic = this._topic;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputMsk | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._ack = undefined;
      this._assumeRoleArn = undefined;
      this._assumeRoleExternalId = undefined;
      this._authenticationTimeout = undefined;
      this._awsApiKey = undefined;
      this._awsAuthenticationMethod = undefined;
      this._awsSecret = undefined;
      this._awsSecretKey = undefined;
      this._backoffRate = undefined;
      this._brokers = undefined;
      this._compression = undefined;
      this._connectionTimeout = undefined;
      this._description = undefined;
      this._durationSeconds = undefined;
      this._enableAssumeRole = undefined;
      this._endpoint = undefined;
      this._environment = undefined;
      this._flushEventCount = undefined;
      this._flushPeriodSec = undefined;
      this._format = undefined;
      this._id = undefined;
      this._initialBackoff = undefined;
      this._kafkaSchemaRegistry.internalValue = undefined;
      this._maxBackOff = undefined;
      this._maxRecordSizeKb = undefined;
      this._maxRetries = undefined;
      this._onBackpressure = undefined;
      this._pipeline = undefined;
      this._pqCompress = undefined;
      this._pqControls.internalValue = undefined;
      this._pqMaxFileSize = undefined;
      this._pqMaxSize = undefined;
      this._pqMode = undefined;
      this._pqOnBackpressure = undefined;
      this._pqPath = undefined;
      this._protobufLibraryId = undefined;
      this._reauthenticationThreshold = undefined;
      this._region = undefined;
      this._rejectUnauthorized = undefined;
      this._requestTimeout = undefined;
      this._reuseConnections = undefined;
      this._signatureVersion = undefined;
      this._streamtags = undefined;
      this._systemFields = undefined;
      this._tls.internalValue = undefined;
      this._topic = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._ack = value.ack;
      this._assumeRoleArn = value.assumeRoleArn;
      this._assumeRoleExternalId = value.assumeRoleExternalId;
      this._authenticationTimeout = value.authenticationTimeout;
      this._awsApiKey = value.awsApiKey;
      this._awsAuthenticationMethod = value.awsAuthenticationMethod;
      this._awsSecret = value.awsSecret;
      this._awsSecretKey = value.awsSecretKey;
      this._backoffRate = value.backoffRate;
      this._brokers = value.brokers;
      this._compression = value.compression;
      this._connectionTimeout = value.connectionTimeout;
      this._description = value.description;
      this._durationSeconds = value.durationSeconds;
      this._enableAssumeRole = value.enableAssumeRole;
      this._endpoint = value.endpoint;
      this._environment = value.environment;
      this._flushEventCount = value.flushEventCount;
      this._flushPeriodSec = value.flushPeriodSec;
      this._format = value.format;
      this._id = value.id;
      this._initialBackoff = value.initialBackoff;
      this._kafkaSchemaRegistry.internalValue = value.kafkaSchemaRegistry;
      this._maxBackOff = value.maxBackOff;
      this._maxRecordSizeKb = value.maxRecordSizeKb;
      this._maxRetries = value.maxRetries;
      this._onBackpressure = value.onBackpressure;
      this._pipeline = value.pipeline;
      this._pqCompress = value.pqCompress;
      this._pqControls.internalValue = value.pqControls;
      this._pqMaxFileSize = value.pqMaxFileSize;
      this._pqMaxSize = value.pqMaxSize;
      this._pqMode = value.pqMode;
      this._pqOnBackpressure = value.pqOnBackpressure;
      this._pqPath = value.pqPath;
      this._protobufLibraryId = value.protobufLibraryId;
      this._reauthenticationThreshold = value.reauthenticationThreshold;
      this._region = value.region;
      this._rejectUnauthorized = value.rejectUnauthorized;
      this._requestTimeout = value.requestTimeout;
      this._reuseConnections = value.reuseConnections;
      this._signatureVersion = value.signatureVersion;
      this._streamtags = value.streamtags;
      this._systemFields = value.systemFields;
      this._tls.internalValue = value.tls;
      this._topic = value.topic;
      this._type = value.type;
    }
  }

  // ack - computed: true, optional: true, required: false
  private _ack?: number; 
  public get ack() {
    return this.getNumberAttribute('ack');
  }
  public set ack(value: number) {
    this._ack = value;
  }
  public resetAck() {
    this._ack = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ackInput() {
    return this._ack;
  }

  // assume_role_arn - computed: false, optional: true, required: false
  private _assumeRoleArn?: string; 
  public get assumeRoleArn() {
    return this.getStringAttribute('assume_role_arn');
  }
  public set assumeRoleArn(value: string) {
    this._assumeRoleArn = value;
  }
  public resetAssumeRoleArn() {
    this._assumeRoleArn = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get assumeRoleArnInput() {
    return this._assumeRoleArn;
  }

  // assume_role_external_id - computed: false, optional: true, required: false
  private _assumeRoleExternalId?: string; 
  public get assumeRoleExternalId() {
    return this.getStringAttribute('assume_role_external_id');
  }
  public set assumeRoleExternalId(value: string) {
    this._assumeRoleExternalId = value;
  }
  public resetAssumeRoleExternalId() {
    this._assumeRoleExternalId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get assumeRoleExternalIdInput() {
    return this._assumeRoleExternalId;
  }

  // authentication_timeout - computed: true, optional: true, required: false
  private _authenticationTimeout?: number; 
  public get authenticationTimeout() {
    return this.getNumberAttribute('authentication_timeout');
  }
  public set authenticationTimeout(value: number) {
    this._authenticationTimeout = value;
  }
  public resetAuthenticationTimeout() {
    this._authenticationTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authenticationTimeoutInput() {
    return this._authenticationTimeout;
  }

  // aws_api_key - computed: false, optional: true, required: false
  private _awsApiKey?: string; 
  public get awsApiKey() {
    return this.getStringAttribute('aws_api_key');
  }
  public set awsApiKey(value: string) {
    this._awsApiKey = value;
  }
  public resetAwsApiKey() {
    this._awsApiKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsApiKeyInput() {
    return this._awsApiKey;
  }

  // aws_authentication_method - computed: true, optional: true, required: false
  private _awsAuthenticationMethod?: string; 
  public get awsAuthenticationMethod() {
    return this.getStringAttribute('aws_authentication_method');
  }
  public set awsAuthenticationMethod(value: string) {
    this._awsAuthenticationMethod = value;
  }
  public resetAwsAuthenticationMethod() {
    this._awsAuthenticationMethod = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsAuthenticationMethodInput() {
    return this._awsAuthenticationMethod;
  }

  // aws_secret - computed: false, optional: true, required: false
  private _awsSecret?: string; 
  public get awsSecret() {
    return this.getStringAttribute('aws_secret');
  }
  public set awsSecret(value: string) {
    this._awsSecret = value;
  }
  public resetAwsSecret() {
    this._awsSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsSecretInput() {
    return this._awsSecret;
  }

  // aws_secret_key - computed: false, optional: true, required: false
  private _awsSecretKey?: string; 
  public get awsSecretKey() {
    return this.getStringAttribute('aws_secret_key');
  }
  public set awsSecretKey(value: string) {
    this._awsSecretKey = value;
  }
  public resetAwsSecretKey() {
    this._awsSecretKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsSecretKeyInput() {
    return this._awsSecretKey;
  }

  // backoff_rate - computed: true, optional: true, required: false
  private _backoffRate?: number; 
  public get backoffRate() {
    return this.getNumberAttribute('backoff_rate');
  }
  public set backoffRate(value: number) {
    this._backoffRate = value;
  }
  public resetBackoffRate() {
    this._backoffRate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get backoffRateInput() {
    return this._backoffRate;
  }

  // brokers - computed: false, optional: false, required: true
  private _brokers?: string[]; 
  public get brokers() {
    return this.getListAttribute('brokers');
  }
  public set brokers(value: string[]) {
    this._brokers = value;
  }
  // Temporarily expose input value. Use with caution.
  public get brokersInput() {
    return this._brokers;
  }

  // compression - computed: true, optional: true, required: false
  private _compression?: string; 
  public get compression() {
    return this.getStringAttribute('compression');
  }
  public set compression(value: string) {
    this._compression = value;
  }
  public resetCompression() {
    this._compression = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressionInput() {
    return this._compression;
  }

  // connection_timeout - computed: true, optional: true, required: false
  private _connectionTimeout?: number; 
  public get connectionTimeout() {
    return this.getNumberAttribute('connection_timeout');
  }
  public set connectionTimeout(value: number) {
    this._connectionTimeout = value;
  }
  public resetConnectionTimeout() {
    this._connectionTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectionTimeoutInput() {
    return this._connectionTimeout;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // duration_seconds - computed: true, optional: true, required: false
  private _durationSeconds?: number; 
  public get durationSeconds() {
    return this.getNumberAttribute('duration_seconds');
  }
  public set durationSeconds(value: number) {
    this._durationSeconds = value;
  }
  public resetDurationSeconds() {
    this._durationSeconds = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get durationSecondsInput() {
    return this._durationSeconds;
  }

  // enable_assume_role - computed: true, optional: true, required: false
  private _enableAssumeRole?: boolean | cdktf.IResolvable; 
  public get enableAssumeRole() {
    return this.getBooleanAttribute('enable_assume_role');
  }
  public set enableAssumeRole(value: boolean | cdktf.IResolvable) {
    this._enableAssumeRole = value;
  }
  public resetEnableAssumeRole() {
    this._enableAssumeRole = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableAssumeRoleInput() {
    return this._enableAssumeRole;
  }

  // endpoint - computed: false, optional: true, required: false
  private _endpoint?: string; 
  public get endpoint() {
    return this.getStringAttribute('endpoint');
  }
  public set endpoint(value: string) {
    this._endpoint = value;
  }
  public resetEndpoint() {
    this._endpoint = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get endpointInput() {
    return this._endpoint;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // flush_event_count - computed: true, optional: true, required: false
  private _flushEventCount?: number; 
  public get flushEventCount() {
    return this.getNumberAttribute('flush_event_count');
  }
  public set flushEventCount(value: number) {
    this._flushEventCount = value;
  }
  public resetFlushEventCount() {
    this._flushEventCount = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get flushEventCountInput() {
    return this._flushEventCount;
  }

  // flush_period_sec - computed: true, optional: true, required: false
  private _flushPeriodSec?: number; 
  public get flushPeriodSec() {
    return this.getNumberAttribute('flush_period_sec');
  }
  public set flushPeriodSec(value: number) {
    this._flushPeriodSec = value;
  }
  public resetFlushPeriodSec() {
    this._flushPeriodSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get flushPeriodSecInput() {
    return this._flushPeriodSec;
  }

  // format - computed: true, optional: true, required: false
  private _format?: string; 
  public get format() {
    return this.getStringAttribute('format');
  }
  public set format(value: string) {
    this._format = value;
  }
  public resetFormat() {
    this._format = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get formatInput() {
    return this._format;
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // initial_backoff - computed: true, optional: true, required: false
  private _initialBackoff?: number; 
  public get initialBackoff() {
    return this.getNumberAttribute('initial_backoff');
  }
  public set initialBackoff(value: number) {
    this._initialBackoff = value;
  }
  public resetInitialBackoff() {
    this._initialBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get initialBackoffInput() {
    return this._initialBackoff;
  }

  // kafka_schema_registry - computed: false, optional: true, required: false
  private _kafkaSchemaRegistry = new PackDestinationOutputMskKafkaSchemaRegistryOutputReference(this, "kafka_schema_registry");
  public get kafkaSchemaRegistry() {
    return this._kafkaSchemaRegistry;
  }
  public putKafkaSchemaRegistry(value: PackDestinationOutputMskKafkaSchemaRegistry) {
    this._kafkaSchemaRegistry.internalValue = value;
  }
  public resetKafkaSchemaRegistry() {
    this._kafkaSchemaRegistry.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get kafkaSchemaRegistryInput() {
    return this._kafkaSchemaRegistry.internalValue;
  }

  // max_back_off - computed: true, optional: true, required: false
  private _maxBackOff?: number; 
  public get maxBackOff() {
    return this.getNumberAttribute('max_back_off');
  }
  public set maxBackOff(value: number) {
    this._maxBackOff = value;
  }
  public resetMaxBackOff() {
    this._maxBackOff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBackOffInput() {
    return this._maxBackOff;
  }

  // max_record_size_kb - computed: true, optional: true, required: false
  private _maxRecordSizeKb?: number; 
  public get maxRecordSizeKb() {
    return this.getNumberAttribute('max_record_size_kb');
  }
  public set maxRecordSizeKb(value: number) {
    this._maxRecordSizeKb = value;
  }
  public resetMaxRecordSizeKb() {
    this._maxRecordSizeKb = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxRecordSizeKbInput() {
    return this._maxRecordSizeKb;
  }

  // max_retries - computed: true, optional: true, required: false
  private _maxRetries?: number; 
  public get maxRetries() {
    return this.getNumberAttribute('max_retries');
  }
  public set maxRetries(value: number) {
    this._maxRetries = value;
  }
  public resetMaxRetries() {
    this._maxRetries = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxRetriesInput() {
    return this._maxRetries;
  }

  // on_backpressure - computed: true, optional: true, required: false
  private _onBackpressure?: string; 
  public get onBackpressure() {
    return this.getStringAttribute('on_backpressure');
  }
  public set onBackpressure(value: string) {
    this._onBackpressure = value;
  }
  public resetOnBackpressure() {
    this._onBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get onBackpressureInput() {
    return this._onBackpressure;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // pq_compress - computed: true, optional: true, required: false
  private _pqCompress?: string; 
  public get pqCompress() {
    return this.getStringAttribute('pq_compress');
  }
  public set pqCompress(value: string) {
    this._pqCompress = value;
  }
  public resetPqCompress() {
    this._pqCompress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqCompressInput() {
    return this._pqCompress;
  }

  // pq_controls - computed: false, optional: true, required: false
  private _pqControls = new PackDestinationOutputMskPqControlsOutputReference(this, "pq_controls");
  public get pqControls() {
    return this._pqControls;
  }
  public putPqControls(value: PackDestinationOutputMskPqControls) {
    this._pqControls.internalValue = value;
  }
  public resetPqControls() {
    this._pqControls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqControlsInput() {
    return this._pqControls.internalValue;
  }

  // pq_max_file_size - computed: true, optional: true, required: false
  private _pqMaxFileSize?: string; 
  public get pqMaxFileSize() {
    return this.getStringAttribute('pq_max_file_size');
  }
  public set pqMaxFileSize(value: string) {
    this._pqMaxFileSize = value;
  }
  public resetPqMaxFileSize() {
    this._pqMaxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxFileSizeInput() {
    return this._pqMaxFileSize;
  }

  // pq_max_size - computed: true, optional: true, required: false
  private _pqMaxSize?: string; 
  public get pqMaxSize() {
    return this.getStringAttribute('pq_max_size');
  }
  public set pqMaxSize(value: string) {
    this._pqMaxSize = value;
  }
  public resetPqMaxSize() {
    this._pqMaxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxSizeInput() {
    return this._pqMaxSize;
  }

  // pq_mode - computed: true, optional: true, required: false
  private _pqMode?: string; 
  public get pqMode() {
    return this.getStringAttribute('pq_mode');
  }
  public set pqMode(value: string) {
    this._pqMode = value;
  }
  public resetPqMode() {
    this._pqMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqModeInput() {
    return this._pqMode;
  }

  // pq_on_backpressure - computed: true, optional: true, required: false
  private _pqOnBackpressure?: string; 
  public get pqOnBackpressure() {
    return this.getStringAttribute('pq_on_backpressure');
  }
  public set pqOnBackpressure(value: string) {
    this._pqOnBackpressure = value;
  }
  public resetPqOnBackpressure() {
    this._pqOnBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqOnBackpressureInput() {
    return this._pqOnBackpressure;
  }

  // pq_path - computed: true, optional: true, required: false
  private _pqPath?: string; 
  public get pqPath() {
    return this.getStringAttribute('pq_path');
  }
  public set pqPath(value: string) {
    this._pqPath = value;
  }
  public resetPqPath() {
    this._pqPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqPathInput() {
    return this._pqPath;
  }

  // protobuf_library_id - computed: false, optional: true, required: false
  private _protobufLibraryId?: string; 
  public get protobufLibraryId() {
    return this.getStringAttribute('protobuf_library_id');
  }
  public set protobufLibraryId(value: string) {
    this._protobufLibraryId = value;
  }
  public resetProtobufLibraryId() {
    this._protobufLibraryId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get protobufLibraryIdInput() {
    return this._protobufLibraryId;
  }

  // reauthentication_threshold - computed: true, optional: true, required: false
  private _reauthenticationThreshold?: number; 
  public get reauthenticationThreshold() {
    return this.getNumberAttribute('reauthentication_threshold');
  }
  public set reauthenticationThreshold(value: number) {
    this._reauthenticationThreshold = value;
  }
  public resetReauthenticationThreshold() {
    this._reauthenticationThreshold = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get reauthenticationThresholdInput() {
    return this._reauthenticationThreshold;
  }

  // region - computed: false, optional: false, required: true
  private _region?: string; 
  public get region() {
    return this.getStringAttribute('region');
  }
  public set region(value: string) {
    this._region = value;
  }
  // Temporarily expose input value. Use with caution.
  public get regionInput() {
    return this._region;
  }

  // reject_unauthorized - computed: true, optional: true, required: false
  private _rejectUnauthorized?: boolean | cdktf.IResolvable; 
  public get rejectUnauthorized() {
    return this.getBooleanAttribute('reject_unauthorized');
  }
  public set rejectUnauthorized(value: boolean | cdktf.IResolvable) {
    this._rejectUnauthorized = value;
  }
  public resetRejectUnauthorized() {
    this._rejectUnauthorized = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectUnauthorizedInput() {
    return this._rejectUnauthorized;
  }

  // request_timeout - computed: true, optional: true, required: false
  private _requestTimeout?: number; 
  public get requestTimeout() {
    return this.getNumberAttribute('request_timeout');
  }
  public set requestTimeout(value: number) {
    this._requestTimeout = value;
  }
  public resetRequestTimeout() {
    this._requestTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestTimeoutInput() {
    return this._requestTimeout;
  }

  // reuse_connections - computed: true, optional: true, required: false
  private _reuseConnections?: boolean | cdktf.IResolvable; 
  public get reuseConnections() {
    return this.getBooleanAttribute('reuse_connections');
  }
  public set reuseConnections(value: boolean | cdktf.IResolvable) {
    this._reuseConnections = value;
  }
  public resetReuseConnections() {
    this._reuseConnections = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get reuseConnectionsInput() {
    return this._reuseConnections;
  }

  // signature_version - computed: true, optional: true, required: false
  private _signatureVersion?: string; 
  public get signatureVersion() {
    return this.getStringAttribute('signature_version');
  }
  public set signatureVersion(value: string) {
    this._signatureVersion = value;
  }
  public resetSignatureVersion() {
    this._signatureVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get signatureVersionInput() {
    return this._signatureVersion;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // system_fields - computed: true, optional: true, required: false
  private _systemFields?: string[]; 
  public get systemFields() {
    return this.getListAttribute('system_fields');
  }
  public set systemFields(value: string[]) {
    this._systemFields = value;
  }
  public resetSystemFields() {
    this._systemFields = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get systemFieldsInput() {
    return this._systemFields;
  }

  // tls - computed: false, optional: true, required: false
  private _tls = new PackDestinationOutputMskTlsOutputReference(this, "tls");
  public get tls() {
    return this._tls;
  }
  public putTls(value: PackDestinationOutputMskTls) {
    this._tls.internalValue = value;
  }
  public resetTls() {
    this._tls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsInput() {
    return this._tls.internalValue;
  }

  // topic - computed: false, optional: false, required: true
  private _topic?: string; 
  public get topic() {
    return this.getStringAttribute('topic');
  }
  public set topic(value: string) {
    this._topic = value;
  }
  // Temporarily expose input value. Use with caution.
  public get topicInput() {
    return this._topic;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface PackDestinationOutputNetflowHosts {
  /**
  * Destination host
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#host PackDestination#host}
  */
  readonly host: string;
  /**
  * Destination port, default is 2055. Default: 2055
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#port PackDestination#port}
  */
  readonly port?: number;
}

export function packDestinationOutputNetflowHostsToTerraform(struct?: PackDestinationOutputNetflowHosts | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    host: cdktf.stringToTerraform(struct!.host),
    port: cdktf.numberToTerraform(struct!.port),
  }
}


export function packDestinationOutputNetflowHostsToHclTerraform(struct?: PackDestinationOutputNetflowHosts | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    host: {
      value: cdktf.stringToHclTerraform(struct!.host),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputNetflowHostsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackDestinationOutputNetflowHosts | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._host !== undefined) {
      hasAnyValues = true;
      internalValueResult.host = this._host;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputNetflowHosts | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._host = undefined;
      this._port = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._host = value.host;
      this._port = value.port;
    }
  }

  // host - computed: false, optional: false, required: true
  private _host?: string; 
  public get host() {
    return this.getStringAttribute('host');
  }
  public set host(value: string) {
    this._host = value;
  }
  // Temporarily expose input value. Use with caution.
  public get hostInput() {
    return this._host;
  }

  // port - computed: true, optional: true, required: false
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }
}

export class PackDestinationOutputNetflowHostsList extends cdktf.ComplexList {
  public internalValue? : PackDestinationOutputNetflowHosts[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackDestinationOutputNetflowHostsOutputReference {
    return new PackDestinationOutputNetflowHostsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackDestinationOutputNetflow {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#description PackDestination#description}
  */
  readonly description?: string;
  /**
  * How often to resolve the destination hostname to an IP address. Ignored if all destinations are IP addresses. A value of 0 means every datagram sent will incur a DNS lookup. Default: 0
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#dns_resolve_period_sec PackDestination#dns_resolve_period_sec}
  */
  readonly dnsResolvePeriodSec?: number;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#environment PackDestination#environment}
  */
  readonly environment?: string;
  /**
  * One or more NetFlow destinations to forward events to
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#hosts PackDestination#hosts}
  */
  readonly hosts: PackDestinationOutputNetflowHosts[] | cdktf.IResolvable;
  /**
  * Unique ID for this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#id PackDestination#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * Pipeline to process data before sending out to this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pipeline PackDestination#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#streamtags PackDestination#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Fields to automatically add to events, such as cribl_pipe. Supports wildcards. Default: ["cribl_pipe"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#system_fields PackDestination#system_fields}
  */
  readonly systemFields?: string[];
  /**
  * must be "netflow"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#type PackDestination#type}
  */
  readonly type: string;
}

export function packDestinationOutputNetflowToTerraform(struct?: PackDestinationOutputNetflow | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    description: cdktf.stringToTerraform(struct!.description),
    dns_resolve_period_sec: cdktf.numberToTerraform(struct!.dnsResolvePeriodSec),
    environment: cdktf.stringToTerraform(struct!.environment),
    hosts: cdktf.listMapper(packDestinationOutputNetflowHostsToTerraform, false)(struct!.hosts),
    id: cdktf.stringToTerraform(struct!.id),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    system_fields: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.systemFields),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function packDestinationOutputNetflowToHclTerraform(struct?: PackDestinationOutputNetflow | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    dns_resolve_period_sec: {
      value: cdktf.numberToHclTerraform(struct!.dnsResolvePeriodSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    hosts: {
      value: cdktf.listMapperHcl(packDestinationOutputNetflowHostsToHclTerraform, false)(struct!.hosts),
      isBlock: true,
      type: "list",
      storageClassType: "PackDestinationOutputNetflowHostsList",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    system_fields: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.systemFields),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputNetflowOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackDestinationOutputNetflow | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._dnsResolvePeriodSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.dnsResolvePeriodSec = this._dnsResolvePeriodSec;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._hosts?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.hosts = this._hosts?.internalValue;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._systemFields !== undefined) {
      hasAnyValues = true;
      internalValueResult.systemFields = this._systemFields;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputNetflow | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._description = undefined;
      this._dnsResolvePeriodSec = undefined;
      this._environment = undefined;
      this._hosts.internalValue = undefined;
      this._id = undefined;
      this._pipeline = undefined;
      this._streamtags = undefined;
      this._systemFields = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._description = value.description;
      this._dnsResolvePeriodSec = value.dnsResolvePeriodSec;
      this._environment = value.environment;
      this._hosts.internalValue = value.hosts;
      this._id = value.id;
      this._pipeline = value.pipeline;
      this._streamtags = value.streamtags;
      this._systemFields = value.systemFields;
      this._type = value.type;
    }
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // dns_resolve_period_sec - computed: true, optional: true, required: false
  private _dnsResolvePeriodSec?: number; 
  public get dnsResolvePeriodSec() {
    return this.getNumberAttribute('dns_resolve_period_sec');
  }
  public set dnsResolvePeriodSec(value: number) {
    this._dnsResolvePeriodSec = value;
  }
  public resetDnsResolvePeriodSec() {
    this._dnsResolvePeriodSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dnsResolvePeriodSecInput() {
    return this._dnsResolvePeriodSec;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // hosts - computed: false, optional: false, required: true
  private _hosts = new PackDestinationOutputNetflowHostsList(this, "hosts", false);
  public get hosts() {
    return this._hosts;
  }
  public putHosts(value: PackDestinationOutputNetflowHosts[] | cdktf.IResolvable) {
    this._hosts.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get hostsInput() {
    return this._hosts.internalValue;
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // system_fields - computed: true, optional: true, required: false
  private _systemFields?: string[]; 
  public get systemFields() {
    return this.getListAttribute('system_fields');
  }
  public set systemFields(value: string[]) {
    this._systemFields = value;
  }
  public resetSystemFields() {
    this._systemFields = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get systemFieldsInput() {
    return this._systemFields;
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface PackDestinationOutputNewrelicExtraHttpHeaders {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#name PackDestination#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#value PackDestination#value}
  */
  readonly value: string;
}

export function packDestinationOutputNewrelicExtraHttpHeadersToTerraform(struct?: PackDestinationOutputNewrelicExtraHttpHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function packDestinationOutputNewrelicExtraHttpHeadersToHclTerraform(struct?: PackDestinationOutputNewrelicExtraHttpHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputNewrelicExtraHttpHeadersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackDestinationOutputNewrelicExtraHttpHeaders | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputNewrelicExtraHttpHeaders | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class PackDestinationOutputNewrelicExtraHttpHeadersList extends cdktf.ComplexList {
  public internalValue? : PackDestinationOutputNewrelicExtraHttpHeaders[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackDestinationOutputNewrelicExtraHttpHeadersOutputReference {
    return new PackDestinationOutputNewrelicExtraHttpHeadersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackDestinationOutputNewrelicMetadata {
  /**
  * must be one of ["service", "hostname", "timestamp", "auditId"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#name PackDestination#name}
  */
  readonly name: string;
  /**
  * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#value PackDestination#value}
  */
  readonly value: string;
}

export function packDestinationOutputNewrelicMetadataToTerraform(struct?: PackDestinationOutputNewrelicMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function packDestinationOutputNewrelicMetadataToHclTerraform(struct?: PackDestinationOutputNewrelicMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputNewrelicMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackDestinationOutputNewrelicMetadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputNewrelicMetadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class PackDestinationOutputNewrelicMetadataList extends cdktf.ComplexList {
  public internalValue? : PackDestinationOutputNewrelicMetadata[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackDestinationOutputNewrelicMetadataOutputReference {
    return new PackDestinationOutputNewrelicMetadataOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackDestinationOutputNewrelicPqControls {
}

export function packDestinationOutputNewrelicPqControlsToTerraform(struct?: PackDestinationOutputNewrelicPqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function packDestinationOutputNewrelicPqControlsToHclTerraform(struct?: PackDestinationOutputNewrelicPqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class PackDestinationOutputNewrelicPqControlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackDestinationOutputNewrelicPqControls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputNewrelicPqControls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface PackDestinationOutputNewrelicResponseRetrySettings {
  /**
  * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc. Default: 2
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#backoff_rate PackDestination#backoff_rate}
  */
  readonly backoffRate?: number;
  /**
  * The HTTP response status code that will trigger retries
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#http_status PackDestination#http_status}
  */
  readonly httpStatus: number;
  /**
  * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes). Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#initial_backoff PackDestination#initial_backoff}
  */
  readonly initialBackoff?: number;
  /**
  * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds). Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_backoff PackDestination#max_backoff}
  */
  readonly maxBackoff?: number;
}

export function packDestinationOutputNewrelicResponseRetrySettingsToTerraform(struct?: PackDestinationOutputNewrelicResponseRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    backoff_rate: cdktf.numberToTerraform(struct!.backoffRate),
    http_status: cdktf.numberToTerraform(struct!.httpStatus),
    initial_backoff: cdktf.numberToTerraform(struct!.initialBackoff),
    max_backoff: cdktf.numberToTerraform(struct!.maxBackoff),
  }
}


export function packDestinationOutputNewrelicResponseRetrySettingsToHclTerraform(struct?: PackDestinationOutputNewrelicResponseRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    backoff_rate: {
      value: cdktf.numberToHclTerraform(struct!.backoffRate),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    http_status: {
      value: cdktf.numberToHclTerraform(struct!.httpStatus),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    initial_backoff: {
      value: cdktf.numberToHclTerraform(struct!.initialBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_backoff: {
      value: cdktf.numberToHclTerraform(struct!.maxBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputNewrelicResponseRetrySettingsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackDestinationOutputNewrelicResponseRetrySettings | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._backoffRate !== undefined) {
      hasAnyValues = true;
      internalValueResult.backoffRate = this._backoffRate;
    }
    if (this._httpStatus !== undefined) {
      hasAnyValues = true;
      internalValueResult.httpStatus = this._httpStatus;
    }
    if (this._initialBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.initialBackoff = this._initialBackoff;
    }
    if (this._maxBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBackoff = this._maxBackoff;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputNewrelicResponseRetrySettings | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._backoffRate = undefined;
      this._httpStatus = undefined;
      this._initialBackoff = undefined;
      this._maxBackoff = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._backoffRate = value.backoffRate;
      this._httpStatus = value.httpStatus;
      this._initialBackoff = value.initialBackoff;
      this._maxBackoff = value.maxBackoff;
    }
  }

  // backoff_rate - computed: true, optional: true, required: false
  private _backoffRate?: number; 
  public get backoffRate() {
    return this.getNumberAttribute('backoff_rate');
  }
  public set backoffRate(value: number) {
    this._backoffRate = value;
  }
  public resetBackoffRate() {
    this._backoffRate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get backoffRateInput() {
    return this._backoffRate;
  }

  // http_status - computed: false, optional: false, required: true
  private _httpStatus?: number; 
  public get httpStatus() {
    return this.getNumberAttribute('http_status');
  }
  public set httpStatus(value: number) {
    this._httpStatus = value;
  }
  // Temporarily expose input value. Use with caution.
  public get httpStatusInput() {
    return this._httpStatus;
  }

  // initial_backoff - computed: true, optional: true, required: false
  private _initialBackoff?: number; 
  public get initialBackoff() {
    return this.getNumberAttribute('initial_backoff');
  }
  public set initialBackoff(value: number) {
    this._initialBackoff = value;
  }
  public resetInitialBackoff() {
    this._initialBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get initialBackoffInput() {
    return this._initialBackoff;
  }

  // max_backoff - computed: true, optional: true, required: false
  private _maxBackoff?: number; 
  public get maxBackoff() {
    return this.getNumberAttribute('max_backoff');
  }
  public set maxBackoff(value: number) {
    this._maxBackoff = value;
  }
  public resetMaxBackoff() {
    this._maxBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBackoffInput() {
    return this._maxBackoff;
  }
}

export class PackDestinationOutputNewrelicResponseRetrySettingsList extends cdktf.ComplexList {
  public internalValue? : PackDestinationOutputNewrelicResponseRetrySettings[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackDestinationOutputNewrelicResponseRetrySettingsOutputReference {
    return new PackDestinationOutputNewrelicResponseRetrySettingsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackDestinationOutputNewrelicTimeoutRetrySettings {
  /**
  * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc. Default: 2
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#backoff_rate PackDestination#backoff_rate}
  */
  readonly backoffRate?: number;
  /**
  * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes). Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#initial_backoff PackDestination#initial_backoff}
  */
  readonly initialBackoff?: number;
  /**
  * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds). Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_backoff PackDestination#max_backoff}
  */
  readonly maxBackoff?: number;
  /**
  * Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#timeout_retry PackDestination#timeout_retry}
  */
  readonly timeoutRetry?: boolean | cdktf.IResolvable;
}

export function packDestinationOutputNewrelicTimeoutRetrySettingsToTerraform(struct?: PackDestinationOutputNewrelicTimeoutRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    backoff_rate: cdktf.numberToTerraform(struct!.backoffRate),
    initial_backoff: cdktf.numberToTerraform(struct!.initialBackoff),
    max_backoff: cdktf.numberToTerraform(struct!.maxBackoff),
    timeout_retry: cdktf.booleanToTerraform(struct!.timeoutRetry),
  }
}


export function packDestinationOutputNewrelicTimeoutRetrySettingsToHclTerraform(struct?: PackDestinationOutputNewrelicTimeoutRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    backoff_rate: {
      value: cdktf.numberToHclTerraform(struct!.backoffRate),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    initial_backoff: {
      value: cdktf.numberToHclTerraform(struct!.initialBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_backoff: {
      value: cdktf.numberToHclTerraform(struct!.maxBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    timeout_retry: {
      value: cdktf.booleanToHclTerraform(struct!.timeoutRetry),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputNewrelicTimeoutRetrySettingsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackDestinationOutputNewrelicTimeoutRetrySettings | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._backoffRate !== undefined) {
      hasAnyValues = true;
      internalValueResult.backoffRate = this._backoffRate;
    }
    if (this._initialBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.initialBackoff = this._initialBackoff;
    }
    if (this._maxBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBackoff = this._maxBackoff;
    }
    if (this._timeoutRetry !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutRetry = this._timeoutRetry;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputNewrelicTimeoutRetrySettings | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._backoffRate = undefined;
      this._initialBackoff = undefined;
      this._maxBackoff = undefined;
      this._timeoutRetry = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._backoffRate = value.backoffRate;
      this._initialBackoff = value.initialBackoff;
      this._maxBackoff = value.maxBackoff;
      this._timeoutRetry = value.timeoutRetry;
    }
  }

  // backoff_rate - computed: true, optional: true, required: false
  private _backoffRate?: number; 
  public get backoffRate() {
    return this.getNumberAttribute('backoff_rate');
  }
  public set backoffRate(value: number) {
    this._backoffRate = value;
  }
  public resetBackoffRate() {
    this._backoffRate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get backoffRateInput() {
    return this._backoffRate;
  }

  // initial_backoff - computed: true, optional: true, required: false
  private _initialBackoff?: number; 
  public get initialBackoff() {
    return this.getNumberAttribute('initial_backoff');
  }
  public set initialBackoff(value: number) {
    this._initialBackoff = value;
  }
  public resetInitialBackoff() {
    this._initialBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get initialBackoffInput() {
    return this._initialBackoff;
  }

  // max_backoff - computed: true, optional: true, required: false
  private _maxBackoff?: number; 
  public get maxBackoff() {
    return this.getNumberAttribute('max_backoff');
  }
  public set maxBackoff(value: number) {
    this._maxBackoff = value;
  }
  public resetMaxBackoff() {
    this._maxBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBackoffInput() {
    return this._maxBackoff;
  }

  // timeout_retry - computed: true, optional: true, required: false
  private _timeoutRetry?: boolean | cdktf.IResolvable; 
  public get timeoutRetry() {
    return this.getBooleanAttribute('timeout_retry');
  }
  public set timeoutRetry(value: boolean | cdktf.IResolvable) {
    this._timeoutRetry = value;
  }
  public resetTimeoutRetry() {
    this._timeoutRetry = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutRetryInput() {
    return this._timeoutRetry;
  }
}
export interface PackDestinationOutputNewrelic {
  /**
  * New Relic API key. Can be overridden using __newRelic_apiKey field.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#api_key PackDestination#api_key}
  */
  readonly apiKey?: string;
  /**
  * Enter API key directly, or select a stored secret. Default: "manual"; must be one of ["manual", "secret"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#auth_type PackDestination#auth_type}
  */
  readonly authType?: string;
  /**
  * Compress the payload body before sending. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#compress PackDestination#compress}
  */
  readonly compress?: boolean | cdktf.IResolvable;
  /**
  * Maximum number of ongoing requests before blocking. Default: 5
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#concurrency PackDestination#concurrency}
  */
  readonly concurrency?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#custom_url PackDestination#custom_url}
  */
  readonly customUrl?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#description PackDestination#description}
  */
  readonly description?: string;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#environment PackDestination#environment}
  */
  readonly environment?: string;
  /**
  * Headers to add to all events
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#extra_http_headers PackDestination#extra_http_headers}
  */
  readonly extraHttpHeaders?: PackDestinationOutputNewrelicExtraHttpHeaders[] | cdktf.IResolvable;
  /**
  * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below. Default: "none"; must be one of ["payload", "payloadAndHeaders", "none"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#failed_request_logging_mode PackDestination#failed_request_logging_mode}
  */
  readonly failedRequestLoggingMode?: string;
  /**
  * Maximum time between requests. Small values could cause the payload size to be smaller than the configured Body size limit. Default: 1
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#flush_period_sec PackDestination#flush_period_sec}
  */
  readonly flushPeriodSec?: number;
  /**
  * Unique ID for this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#id PackDestination#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id: string;
  /**
  * Name of the logtype to send with events, e.g.: observability, access_log. The event's 'sourcetype' field (if set) will override this value. Default: ""
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#log_type PackDestination#log_type}
  */
  readonly logType?: string;
  /**
  * Maximum number of events to include in the request body. Default is 0 (unlimited). Default: 0
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_payload_events PackDestination#max_payload_events}
  */
  readonly maxPayloadEvents?: number;
  /**
  * Maximum size, in KB, of the request body. Default: 1024
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_payload_size_kb PackDestination#max_payload_size_kb}
  */
  readonly maxPayloadSizeKb?: number;
  /**
  * Name of field to send as log message value. If not present, event will be serialized and sent as JSON. Default: ""
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#message_field PackDestination#message_field}
  */
  readonly messageField?: string;
  /**
  * Fields to add to events from this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#metadata PackDestination#metadata}
  */
  readonly metadata?: PackDestinationOutputNewrelicMetadata[] | cdktf.IResolvable;
  /**
  * How to handle events when all receivers are exerting backpressure. Default: "block"; must be one of ["block", "drop", "queue"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#on_backpressure PackDestination#on_backpressure}
  */
  readonly onBackpressure?: string;
  /**
  * Pipeline to process data before sending out to this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pipeline PackDestination#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_compress PackDestination#pq_compress}
  */
  readonly pqCompress?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_controls PackDestination#pq_controls}
  */
  readonly pqControls?: PackDestinationOutputNewrelicPqControls;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.). Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_max_file_size PackDestination#pq_max_file_size}
  */
  readonly pqMaxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_max_size PackDestination#pq_max_size}
  */
  readonly pqMaxSize?: string;
  /**
  * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem. Default: "error"; must be one of ["error", "backpressure", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_mode PackDestination#pq_mode}
  */
  readonly pqMode?: string;
  /**
  * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged. Default: "block"; must be one of ["block", "drop"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_on_backpressure PackDestination#pq_on_backpressure}
  */
  readonly pqOnBackpressure?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_path PackDestination#pq_path}
  */
  readonly pqPath?: string;
  /**
  * Which New Relic region endpoint to use. Default: "US"; must be one of ["US", "EU", "Custom"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#region PackDestination#region}
  */
  readonly region?: string;
  /**
  * Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's). 
  *         Enabled by default. When this setting is also present in TLS Settings (Client Side), 
  *         that value will take precedence.
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#reject_unauthorized PackDestination#reject_unauthorized}
  */
  readonly rejectUnauthorized?: boolean | cdktf.IResolvable;
  /**
  * Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#response_honor_retry_after_header PackDestination#response_honor_retry_after_header}
  */
  readonly responseHonorRetryAfterHeader?: boolean | cdktf.IResolvable;
  /**
  * Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#response_retry_settings PackDestination#response_retry_settings}
  */
  readonly responseRetrySettings?: PackDestinationOutputNewrelicResponseRetrySettings[] | cdktf.IResolvable;
  /**
  * List of headers that are safe to log in plain text. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#safe_headers PackDestination#safe_headers}
  */
  readonly safeHeaders?: string[];
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#streamtags PackDestination#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Fields to automatically add to events, such as cribl_pipe. Supports wildcards. Default: ["cribl_pipe"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#system_fields PackDestination#system_fields}
  */
  readonly systemFields?: string[];
  /**
  * Select or create a stored text secret
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#text_secret PackDestination#text_secret}
  */
  readonly textSecret?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#timeout_retry_settings PackDestination#timeout_retry_settings}
  */
  readonly timeoutRetrySettings?: PackDestinationOutputNewrelicTimeoutRetrySettings;
  /**
  * Amount of time, in seconds, to wait for a request to complete before canceling it. Default: 30
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#timeout_sec PackDestination#timeout_sec}
  */
  readonly timeoutSec?: number;
  /**
  * Maximum total size of the batches waiting to be sent. If left blank, defaults to 5 times the max body size (if set). If 0, no limit is enforced.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#total_memory_limit_kb PackDestination#total_memory_limit_kb}
  */
  readonly totalMemoryLimitKb?: number;
  /**
  * must be "newrelic"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#type PackDestination#type}
  */
  readonly type: string;
  /**
  * Enable round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. For optimal performance, consider enabling this setting for non-load balanced destinations. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#use_round_robin_dns PackDestination#use_round_robin_dns}
  */
  readonly useRoundRobinDns?: boolean | cdktf.IResolvable;
}

export function packDestinationOutputNewrelicToTerraform(struct?: PackDestinationOutputNewrelic | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    api_key: cdktf.stringToTerraform(struct!.apiKey),
    auth_type: cdktf.stringToTerraform(struct!.authType),
    compress: cdktf.booleanToTerraform(struct!.compress),
    concurrency: cdktf.numberToTerraform(struct!.concurrency),
    custom_url: cdktf.stringToTerraform(struct!.customUrl),
    description: cdktf.stringToTerraform(struct!.description),
    environment: cdktf.stringToTerraform(struct!.environment),
    extra_http_headers: cdktf.listMapper(packDestinationOutputNewrelicExtraHttpHeadersToTerraform, false)(struct!.extraHttpHeaders),
    failed_request_logging_mode: cdktf.stringToTerraform(struct!.failedRequestLoggingMode),
    flush_period_sec: cdktf.numberToTerraform(struct!.flushPeriodSec),
    id: cdktf.stringToTerraform(struct!.id),
    log_type: cdktf.stringToTerraform(struct!.logType),
    max_payload_events: cdktf.numberToTerraform(struct!.maxPayloadEvents),
    max_payload_size_kb: cdktf.numberToTerraform(struct!.maxPayloadSizeKb),
    message_field: cdktf.stringToTerraform(struct!.messageField),
    metadata: cdktf.listMapper(packDestinationOutputNewrelicMetadataToTerraform, false)(struct!.metadata),
    on_backpressure: cdktf.stringToTerraform(struct!.onBackpressure),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    pq_compress: cdktf.stringToTerraform(struct!.pqCompress),
    pq_controls: packDestinationOutputNewrelicPqControlsToTerraform(struct!.pqControls),
    pq_max_file_size: cdktf.stringToTerraform(struct!.pqMaxFileSize),
    pq_max_size: cdktf.stringToTerraform(struct!.pqMaxSize),
    pq_mode: cdktf.stringToTerraform(struct!.pqMode),
    pq_on_backpressure: cdktf.stringToTerraform(struct!.pqOnBackpressure),
    pq_path: cdktf.stringToTerraform(struct!.pqPath),
    region: cdktf.stringToTerraform(struct!.region),
    reject_unauthorized: cdktf.booleanToTerraform(struct!.rejectUnauthorized),
    response_honor_retry_after_header: cdktf.booleanToTerraform(struct!.responseHonorRetryAfterHeader),
    response_retry_settings: cdktf.listMapper(packDestinationOutputNewrelicResponseRetrySettingsToTerraform, false)(struct!.responseRetrySettings),
    safe_headers: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.safeHeaders),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    system_fields: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.systemFields),
    text_secret: cdktf.stringToTerraform(struct!.textSecret),
    timeout_retry_settings: packDestinationOutputNewrelicTimeoutRetrySettingsToTerraform(struct!.timeoutRetrySettings),
    timeout_sec: cdktf.numberToTerraform(struct!.timeoutSec),
    total_memory_limit_kb: cdktf.numberToTerraform(struct!.totalMemoryLimitKb),
    type: cdktf.stringToTerraform(struct!.type),
    use_round_robin_dns: cdktf.booleanToTerraform(struct!.useRoundRobinDns),
  }
}


export function packDestinationOutputNewrelicToHclTerraform(struct?: PackDestinationOutputNewrelic | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    api_key: {
      value: cdktf.stringToHclTerraform(struct!.apiKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    auth_type: {
      value: cdktf.stringToHclTerraform(struct!.authType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    compress: {
      value: cdktf.booleanToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    concurrency: {
      value: cdktf.numberToHclTerraform(struct!.concurrency),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    custom_url: {
      value: cdktf.stringToHclTerraform(struct!.customUrl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    extra_http_headers: {
      value: cdktf.listMapperHcl(packDestinationOutputNewrelicExtraHttpHeadersToHclTerraform, false)(struct!.extraHttpHeaders),
      isBlock: true,
      type: "list",
      storageClassType: "PackDestinationOutputNewrelicExtraHttpHeadersList",
    },
    failed_request_logging_mode: {
      value: cdktf.stringToHclTerraform(struct!.failedRequestLoggingMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    flush_period_sec: {
      value: cdktf.numberToHclTerraform(struct!.flushPeriodSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    log_type: {
      value: cdktf.stringToHclTerraform(struct!.logType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_payload_events: {
      value: cdktf.numberToHclTerraform(struct!.maxPayloadEvents),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_payload_size_kb: {
      value: cdktf.numberToHclTerraform(struct!.maxPayloadSizeKb),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    message_field: {
      value: cdktf.stringToHclTerraform(struct!.messageField),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    metadata: {
      value: cdktf.listMapperHcl(packDestinationOutputNewrelicMetadataToHclTerraform, false)(struct!.metadata),
      isBlock: true,
      type: "list",
      storageClassType: "PackDestinationOutputNewrelicMetadataList",
    },
    on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.onBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_compress: {
      value: cdktf.stringToHclTerraform(struct!.pqCompress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_controls: {
      value: packDestinationOutputNewrelicPqControlsToHclTerraform(struct!.pqControls),
      isBlock: true,
      type: "struct",
      storageClassType: "PackDestinationOutputNewrelicPqControls",
    },
    pq_max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_max_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_mode: {
      value: cdktf.stringToHclTerraform(struct!.pqMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.pqOnBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_path: {
      value: cdktf.stringToHclTerraform(struct!.pqPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    region: {
      value: cdktf.stringToHclTerraform(struct!.region),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reject_unauthorized: {
      value: cdktf.booleanToHclTerraform(struct!.rejectUnauthorized),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    response_honor_retry_after_header: {
      value: cdktf.booleanToHclTerraform(struct!.responseHonorRetryAfterHeader),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    response_retry_settings: {
      value: cdktf.listMapperHcl(packDestinationOutputNewrelicResponseRetrySettingsToHclTerraform, false)(struct!.responseRetrySettings),
      isBlock: true,
      type: "list",
      storageClassType: "PackDestinationOutputNewrelicResponseRetrySettingsList",
    },
    safe_headers: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.safeHeaders),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    system_fields: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.systemFields),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    text_secret: {
      value: cdktf.stringToHclTerraform(struct!.textSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    timeout_retry_settings: {
      value: packDestinationOutputNewrelicTimeoutRetrySettingsToHclTerraform(struct!.timeoutRetrySettings),
      isBlock: true,
      type: "struct",
      storageClassType: "PackDestinationOutputNewrelicTimeoutRetrySettings",
    },
    timeout_sec: {
      value: cdktf.numberToHclTerraform(struct!.timeoutSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    total_memory_limit_kb: {
      value: cdktf.numberToHclTerraform(struct!.totalMemoryLimitKb),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    use_round_robin_dns: {
      value: cdktf.booleanToHclTerraform(struct!.useRoundRobinDns),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputNewrelicOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackDestinationOutputNewrelic | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._apiKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.apiKey = this._apiKey;
    }
    if (this._authType !== undefined) {
      hasAnyValues = true;
      internalValueResult.authType = this._authType;
    }
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._concurrency !== undefined) {
      hasAnyValues = true;
      internalValueResult.concurrency = this._concurrency;
    }
    if (this._customUrl !== undefined) {
      hasAnyValues = true;
      internalValueResult.customUrl = this._customUrl;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._extraHttpHeaders?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.extraHttpHeaders = this._extraHttpHeaders?.internalValue;
    }
    if (this._failedRequestLoggingMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.failedRequestLoggingMode = this._failedRequestLoggingMode;
    }
    if (this._flushPeriodSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.flushPeriodSec = this._flushPeriodSec;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._logType !== undefined) {
      hasAnyValues = true;
      internalValueResult.logType = this._logType;
    }
    if (this._maxPayloadEvents !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxPayloadEvents = this._maxPayloadEvents;
    }
    if (this._maxPayloadSizeKb !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxPayloadSizeKb = this._maxPayloadSizeKb;
    }
    if (this._messageField !== undefined) {
      hasAnyValues = true;
      internalValueResult.messageField = this._messageField;
    }
    if (this._metadata?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadata = this._metadata?.internalValue;
    }
    if (this._onBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.onBackpressure = this._onBackpressure;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._pqCompress !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqCompress = this._pqCompress;
    }
    if (this._pqControls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqControls = this._pqControls?.internalValue;
    }
    if (this._pqMaxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxFileSize = this._pqMaxFileSize;
    }
    if (this._pqMaxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxSize = this._pqMaxSize;
    }
    if (this._pqMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMode = this._pqMode;
    }
    if (this._pqOnBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqOnBackpressure = this._pqOnBackpressure;
    }
    if (this._pqPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqPath = this._pqPath;
    }
    if (this._region !== undefined) {
      hasAnyValues = true;
      internalValueResult.region = this._region;
    }
    if (this._rejectUnauthorized !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectUnauthorized = this._rejectUnauthorized;
    }
    if (this._responseHonorRetryAfterHeader !== undefined) {
      hasAnyValues = true;
      internalValueResult.responseHonorRetryAfterHeader = this._responseHonorRetryAfterHeader;
    }
    if (this._responseRetrySettings?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.responseRetrySettings = this._responseRetrySettings?.internalValue;
    }
    if (this._safeHeaders !== undefined) {
      hasAnyValues = true;
      internalValueResult.safeHeaders = this._safeHeaders;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._systemFields !== undefined) {
      hasAnyValues = true;
      internalValueResult.systemFields = this._systemFields;
    }
    if (this._textSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.textSecret = this._textSecret;
    }
    if (this._timeoutRetrySettings?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutRetrySettings = this._timeoutRetrySettings?.internalValue;
    }
    if (this._timeoutSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutSec = this._timeoutSec;
    }
    if (this._totalMemoryLimitKb !== undefined) {
      hasAnyValues = true;
      internalValueResult.totalMemoryLimitKb = this._totalMemoryLimitKb;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._useRoundRobinDns !== undefined) {
      hasAnyValues = true;
      internalValueResult.useRoundRobinDns = this._useRoundRobinDns;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputNewrelic | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._apiKey = undefined;
      this._authType = undefined;
      this._compress = undefined;
      this._concurrency = undefined;
      this._customUrl = undefined;
      this._description = undefined;
      this._environment = undefined;
      this._extraHttpHeaders.internalValue = undefined;
      this._failedRequestLoggingMode = undefined;
      this._flushPeriodSec = undefined;
      this._id = undefined;
      this._logType = undefined;
      this._maxPayloadEvents = undefined;
      this._maxPayloadSizeKb = undefined;
      this._messageField = undefined;
      this._metadata.internalValue = undefined;
      this._onBackpressure = undefined;
      this._pipeline = undefined;
      this._pqCompress = undefined;
      this._pqControls.internalValue = undefined;
      this._pqMaxFileSize = undefined;
      this._pqMaxSize = undefined;
      this._pqMode = undefined;
      this._pqOnBackpressure = undefined;
      this._pqPath = undefined;
      this._region = undefined;
      this._rejectUnauthorized = undefined;
      this._responseHonorRetryAfterHeader = undefined;
      this._responseRetrySettings.internalValue = undefined;
      this._safeHeaders = undefined;
      this._streamtags = undefined;
      this._systemFields = undefined;
      this._textSecret = undefined;
      this._timeoutRetrySettings.internalValue = undefined;
      this._timeoutSec = undefined;
      this._totalMemoryLimitKb = undefined;
      this._type = undefined;
      this._useRoundRobinDns = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._apiKey = value.apiKey;
      this._authType = value.authType;
      this._compress = value.compress;
      this._concurrency = value.concurrency;
      this._customUrl = value.customUrl;
      this._description = value.description;
      this._environment = value.environment;
      this._extraHttpHeaders.internalValue = value.extraHttpHeaders;
      this._failedRequestLoggingMode = value.failedRequestLoggingMode;
      this._flushPeriodSec = value.flushPeriodSec;
      this._id = value.id;
      this._logType = value.logType;
      this._maxPayloadEvents = value.maxPayloadEvents;
      this._maxPayloadSizeKb = value.maxPayloadSizeKb;
      this._messageField = value.messageField;
      this._metadata.internalValue = value.metadata;
      this._onBackpressure = value.onBackpressure;
      this._pipeline = value.pipeline;
      this._pqCompress = value.pqCompress;
      this._pqControls.internalValue = value.pqControls;
      this._pqMaxFileSize = value.pqMaxFileSize;
      this._pqMaxSize = value.pqMaxSize;
      this._pqMode = value.pqMode;
      this._pqOnBackpressure = value.pqOnBackpressure;
      this._pqPath = value.pqPath;
      this._region = value.region;
      this._rejectUnauthorized = value.rejectUnauthorized;
      this._responseHonorRetryAfterHeader = value.responseHonorRetryAfterHeader;
      this._responseRetrySettings.internalValue = value.responseRetrySettings;
      this._safeHeaders = value.safeHeaders;
      this._streamtags = value.streamtags;
      this._systemFields = value.systemFields;
      this._textSecret = value.textSecret;
      this._timeoutRetrySettings.internalValue = value.timeoutRetrySettings;
      this._timeoutSec = value.timeoutSec;
      this._totalMemoryLimitKb = value.totalMemoryLimitKb;
      this._type = value.type;
      this._useRoundRobinDns = value.useRoundRobinDns;
    }
  }

  // api_key - computed: false, optional: true, required: false
  private _apiKey?: string; 
  public get apiKey() {
    return this.getStringAttribute('api_key');
  }
  public set apiKey(value: string) {
    this._apiKey = value;
  }
  public resetApiKey() {
    this._apiKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get apiKeyInput() {
    return this._apiKey;
  }

  // auth_type - computed: true, optional: true, required: false
  private _authType?: string; 
  public get authType() {
    return this.getStringAttribute('auth_type');
  }
  public set authType(value: string) {
    this._authType = value;
  }
  public resetAuthType() {
    this._authType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authTypeInput() {
    return this._authType;
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: boolean | cdktf.IResolvable; 
  public get compress() {
    return this.getBooleanAttribute('compress');
  }
  public set compress(value: boolean | cdktf.IResolvable) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // concurrency - computed: true, optional: true, required: false
  private _concurrency?: number; 
  public get concurrency() {
    return this.getNumberAttribute('concurrency');
  }
  public set concurrency(value: number) {
    this._concurrency = value;
  }
  public resetConcurrency() {
    this._concurrency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get concurrencyInput() {
    return this._concurrency;
  }

  // custom_url - computed: false, optional: true, required: false
  private _customUrl?: string; 
  public get customUrl() {
    return this.getStringAttribute('custom_url');
  }
  public set customUrl(value: string) {
    this._customUrl = value;
  }
  public resetCustomUrl() {
    this._customUrl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get customUrlInput() {
    return this._customUrl;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // extra_http_headers - computed: false, optional: true, required: false
  private _extraHttpHeaders = new PackDestinationOutputNewrelicExtraHttpHeadersList(this, "extra_http_headers", false);
  public get extraHttpHeaders() {
    return this._extraHttpHeaders;
  }
  public putExtraHttpHeaders(value: PackDestinationOutputNewrelicExtraHttpHeaders[] | cdktf.IResolvable) {
    this._extraHttpHeaders.internalValue = value;
  }
  public resetExtraHttpHeaders() {
    this._extraHttpHeaders.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get extraHttpHeadersInput() {
    return this._extraHttpHeaders.internalValue;
  }

  // failed_request_logging_mode - computed: true, optional: true, required: false
  private _failedRequestLoggingMode?: string; 
  public get failedRequestLoggingMode() {
    return this.getStringAttribute('failed_request_logging_mode');
  }
  public set failedRequestLoggingMode(value: string) {
    this._failedRequestLoggingMode = value;
  }
  public resetFailedRequestLoggingMode() {
    this._failedRequestLoggingMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get failedRequestLoggingModeInput() {
    return this._failedRequestLoggingMode;
  }

  // flush_period_sec - computed: true, optional: true, required: false
  private _flushPeriodSec?: number; 
  public get flushPeriodSec() {
    return this.getNumberAttribute('flush_period_sec');
  }
  public set flushPeriodSec(value: number) {
    this._flushPeriodSec = value;
  }
  public resetFlushPeriodSec() {
    this._flushPeriodSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get flushPeriodSecInput() {
    return this._flushPeriodSec;
  }

  // id - computed: false, optional: false, required: true
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // log_type - computed: true, optional: true, required: false
  private _logType?: string; 
  public get logType() {
    return this.getStringAttribute('log_type');
  }
  public set logType(value: string) {
    this._logType = value;
  }
  public resetLogType() {
    this._logType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get logTypeInput() {
    return this._logType;
  }

  // max_payload_events - computed: true, optional: true, required: false
  private _maxPayloadEvents?: number; 
  public get maxPayloadEvents() {
    return this.getNumberAttribute('max_payload_events');
  }
  public set maxPayloadEvents(value: number) {
    this._maxPayloadEvents = value;
  }
  public resetMaxPayloadEvents() {
    this._maxPayloadEvents = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxPayloadEventsInput() {
    return this._maxPayloadEvents;
  }

  // max_payload_size_kb - computed: true, optional: true, required: false
  private _maxPayloadSizeKb?: number; 
  public get maxPayloadSizeKb() {
    return this.getNumberAttribute('max_payload_size_kb');
  }
  public set maxPayloadSizeKb(value: number) {
    this._maxPayloadSizeKb = value;
  }
  public resetMaxPayloadSizeKb() {
    this._maxPayloadSizeKb = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxPayloadSizeKbInput() {
    return this._maxPayloadSizeKb;
  }

  // message_field - computed: true, optional: true, required: false
  private _messageField?: string; 
  public get messageField() {
    return this.getStringAttribute('message_field');
  }
  public set messageField(value: string) {
    this._messageField = value;
  }
  public resetMessageField() {
    this._messageField = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get messageFieldInput() {
    return this._messageField;
  }

  // metadata - computed: false, optional: true, required: false
  private _metadata = new PackDestinationOutputNewrelicMetadataList(this, "metadata", false);
  public get metadata() {
    return this._metadata;
  }
  public putMetadata(value: PackDestinationOutputNewrelicMetadata[] | cdktf.IResolvable) {
    this._metadata.internalValue = value;
  }
  public resetMetadata() {
    this._metadata.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataInput() {
    return this._metadata.internalValue;
  }

  // on_backpressure - computed: true, optional: true, required: false
  private _onBackpressure?: string; 
  public get onBackpressure() {
    return this.getStringAttribute('on_backpressure');
  }
  public set onBackpressure(value: string) {
    this._onBackpressure = value;
  }
  public resetOnBackpressure() {
    this._onBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get onBackpressureInput() {
    return this._onBackpressure;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // pq_compress - computed: true, optional: true, required: false
  private _pqCompress?: string; 
  public get pqCompress() {
    return this.getStringAttribute('pq_compress');
  }
  public set pqCompress(value: string) {
    this._pqCompress = value;
  }
  public resetPqCompress() {
    this._pqCompress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqCompressInput() {
    return this._pqCompress;
  }

  // pq_controls - computed: false, optional: true, required: false
  private _pqControls = new PackDestinationOutputNewrelicPqControlsOutputReference(this, "pq_controls");
  public get pqControls() {
    return this._pqControls;
  }
  public putPqControls(value: PackDestinationOutputNewrelicPqControls) {
    this._pqControls.internalValue = value;
  }
  public resetPqControls() {
    this._pqControls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqControlsInput() {
    return this._pqControls.internalValue;
  }

  // pq_max_file_size - computed: true, optional: true, required: false
  private _pqMaxFileSize?: string; 
  public get pqMaxFileSize() {
    return this.getStringAttribute('pq_max_file_size');
  }
  public set pqMaxFileSize(value: string) {
    this._pqMaxFileSize = value;
  }
  public resetPqMaxFileSize() {
    this._pqMaxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxFileSizeInput() {
    return this._pqMaxFileSize;
  }

  // pq_max_size - computed: true, optional: true, required: false
  private _pqMaxSize?: string; 
  public get pqMaxSize() {
    return this.getStringAttribute('pq_max_size');
  }
  public set pqMaxSize(value: string) {
    this._pqMaxSize = value;
  }
  public resetPqMaxSize() {
    this._pqMaxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxSizeInput() {
    return this._pqMaxSize;
  }

  // pq_mode - computed: true, optional: true, required: false
  private _pqMode?: string; 
  public get pqMode() {
    return this.getStringAttribute('pq_mode');
  }
  public set pqMode(value: string) {
    this._pqMode = value;
  }
  public resetPqMode() {
    this._pqMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqModeInput() {
    return this._pqMode;
  }

  // pq_on_backpressure - computed: true, optional: true, required: false
  private _pqOnBackpressure?: string; 
  public get pqOnBackpressure() {
    return this.getStringAttribute('pq_on_backpressure');
  }
  public set pqOnBackpressure(value: string) {
    this._pqOnBackpressure = value;
  }
  public resetPqOnBackpressure() {
    this._pqOnBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqOnBackpressureInput() {
    return this._pqOnBackpressure;
  }

  // pq_path - computed: true, optional: true, required: false
  private _pqPath?: string; 
  public get pqPath() {
    return this.getStringAttribute('pq_path');
  }
  public set pqPath(value: string) {
    this._pqPath = value;
  }
  public resetPqPath() {
    this._pqPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqPathInput() {
    return this._pqPath;
  }

  // region - computed: true, optional: true, required: false
  private _region?: string; 
  public get region() {
    return this.getStringAttribute('region');
  }
  public set region(value: string) {
    this._region = value;
  }
  public resetRegion() {
    this._region = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get regionInput() {
    return this._region;
  }

  // reject_unauthorized - computed: true, optional: true, required: false
  private _rejectUnauthorized?: boolean | cdktf.IResolvable; 
  public get rejectUnauthorized() {
    return this.getBooleanAttribute('reject_unauthorized');
  }
  public set rejectUnauthorized(value: boolean | cdktf.IResolvable) {
    this._rejectUnauthorized = value;
  }
  public resetRejectUnauthorized() {
    this._rejectUnauthorized = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectUnauthorizedInput() {
    return this._rejectUnauthorized;
  }

  // response_honor_retry_after_header - computed: true, optional: true, required: false
  private _responseHonorRetryAfterHeader?: boolean | cdktf.IResolvable; 
  public get responseHonorRetryAfterHeader() {
    return this.getBooleanAttribute('response_honor_retry_after_header');
  }
  public set responseHonorRetryAfterHeader(value: boolean | cdktf.IResolvable) {
    this._responseHonorRetryAfterHeader = value;
  }
  public resetResponseHonorRetryAfterHeader() {
    this._responseHonorRetryAfterHeader = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get responseHonorRetryAfterHeaderInput() {
    return this._responseHonorRetryAfterHeader;
  }

  // response_retry_settings - computed: false, optional: true, required: false
  private _responseRetrySettings = new PackDestinationOutputNewrelicResponseRetrySettingsList(this, "response_retry_settings", false);
  public get responseRetrySettings() {
    return this._responseRetrySettings;
  }
  public putResponseRetrySettings(value: PackDestinationOutputNewrelicResponseRetrySettings[] | cdktf.IResolvable) {
    this._responseRetrySettings.internalValue = value;
  }
  public resetResponseRetrySettings() {
    this._responseRetrySettings.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get responseRetrySettingsInput() {
    return this._responseRetrySettings.internalValue;
  }

  // safe_headers - computed: true, optional: true, required: false
  private _safeHeaders?: string[]; 
  public get safeHeaders() {
    return this.getListAttribute('safe_headers');
  }
  public set safeHeaders(value: string[]) {
    this._safeHeaders = value;
  }
  public resetSafeHeaders() {
    this._safeHeaders = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get safeHeadersInput() {
    return this._safeHeaders;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // system_fields - computed: true, optional: true, required: false
  private _systemFields?: string[]; 
  public get systemFields() {
    return this.getListAttribute('system_fields');
  }
  public set systemFields(value: string[]) {
    this._systemFields = value;
  }
  public resetSystemFields() {
    this._systemFields = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get systemFieldsInput() {
    return this._systemFields;
  }

  // text_secret - computed: false, optional: true, required: false
  private _textSecret?: string; 
  public get textSecret() {
    return this.getStringAttribute('text_secret');
  }
  public set textSecret(value: string) {
    this._textSecret = value;
  }
  public resetTextSecret() {
    this._textSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get textSecretInput() {
    return this._textSecret;
  }

  // timeout_retry_settings - computed: false, optional: true, required: false
  private _timeoutRetrySettings = new PackDestinationOutputNewrelicTimeoutRetrySettingsOutputReference(this, "timeout_retry_settings");
  public get timeoutRetrySettings() {
    return this._timeoutRetrySettings;
  }
  public putTimeoutRetrySettings(value: PackDestinationOutputNewrelicTimeoutRetrySettings) {
    this._timeoutRetrySettings.internalValue = value;
  }
  public resetTimeoutRetrySettings() {
    this._timeoutRetrySettings.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutRetrySettingsInput() {
    return this._timeoutRetrySettings.internalValue;
  }

  // timeout_sec - computed: true, optional: true, required: false
  private _timeoutSec?: number; 
  public get timeoutSec() {
    return this.getNumberAttribute('timeout_sec');
  }
  public set timeoutSec(value: number) {
    this._timeoutSec = value;
  }
  public resetTimeoutSec() {
    this._timeoutSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutSecInput() {
    return this._timeoutSec;
  }

  // total_memory_limit_kb - computed: false, optional: true, required: false
  private _totalMemoryLimitKb?: number; 
  public get totalMemoryLimitKb() {
    return this.getNumberAttribute('total_memory_limit_kb');
  }
  public set totalMemoryLimitKb(value: number) {
    this._totalMemoryLimitKb = value;
  }
  public resetTotalMemoryLimitKb() {
    this._totalMemoryLimitKb = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get totalMemoryLimitKbInput() {
    return this._totalMemoryLimitKb;
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // use_round_robin_dns - computed: true, optional: true, required: false
  private _useRoundRobinDns?: boolean | cdktf.IResolvable; 
  public get useRoundRobinDns() {
    return this.getBooleanAttribute('use_round_robin_dns');
  }
  public set useRoundRobinDns(value: boolean | cdktf.IResolvable) {
    this._useRoundRobinDns = value;
  }
  public resetUseRoundRobinDns() {
    this._useRoundRobinDns = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get useRoundRobinDnsInput() {
    return this._useRoundRobinDns;
  }
}
export interface PackDestinationOutputNewrelicEventsExtraHttpHeaders {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#name PackDestination#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#value PackDestination#value}
  */
  readonly value: string;
}

export function packDestinationOutputNewrelicEventsExtraHttpHeadersToTerraform(struct?: PackDestinationOutputNewrelicEventsExtraHttpHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function packDestinationOutputNewrelicEventsExtraHttpHeadersToHclTerraform(struct?: PackDestinationOutputNewrelicEventsExtraHttpHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputNewrelicEventsExtraHttpHeadersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackDestinationOutputNewrelicEventsExtraHttpHeaders | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputNewrelicEventsExtraHttpHeaders | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class PackDestinationOutputNewrelicEventsExtraHttpHeadersList extends cdktf.ComplexList {
  public internalValue? : PackDestinationOutputNewrelicEventsExtraHttpHeaders[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackDestinationOutputNewrelicEventsExtraHttpHeadersOutputReference {
    return new PackDestinationOutputNewrelicEventsExtraHttpHeadersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackDestinationOutputNewrelicEventsPqControls {
}

export function packDestinationOutputNewrelicEventsPqControlsToTerraform(struct?: PackDestinationOutputNewrelicEventsPqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function packDestinationOutputNewrelicEventsPqControlsToHclTerraform(struct?: PackDestinationOutputNewrelicEventsPqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class PackDestinationOutputNewrelicEventsPqControlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackDestinationOutputNewrelicEventsPqControls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputNewrelicEventsPqControls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface PackDestinationOutputNewrelicEventsResponseRetrySettings {
  /**
  * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc. Default: 2
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#backoff_rate PackDestination#backoff_rate}
  */
  readonly backoffRate?: number;
  /**
  * The HTTP response status code that will trigger retries
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#http_status PackDestination#http_status}
  */
  readonly httpStatus: number;
  /**
  * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes). Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#initial_backoff PackDestination#initial_backoff}
  */
  readonly initialBackoff?: number;
  /**
  * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds). Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_backoff PackDestination#max_backoff}
  */
  readonly maxBackoff?: number;
}

export function packDestinationOutputNewrelicEventsResponseRetrySettingsToTerraform(struct?: PackDestinationOutputNewrelicEventsResponseRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    backoff_rate: cdktf.numberToTerraform(struct!.backoffRate),
    http_status: cdktf.numberToTerraform(struct!.httpStatus),
    initial_backoff: cdktf.numberToTerraform(struct!.initialBackoff),
    max_backoff: cdktf.numberToTerraform(struct!.maxBackoff),
  }
}


export function packDestinationOutputNewrelicEventsResponseRetrySettingsToHclTerraform(struct?: PackDestinationOutputNewrelicEventsResponseRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    backoff_rate: {
      value: cdktf.numberToHclTerraform(struct!.backoffRate),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    http_status: {
      value: cdktf.numberToHclTerraform(struct!.httpStatus),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    initial_backoff: {
      value: cdktf.numberToHclTerraform(struct!.initialBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_backoff: {
      value: cdktf.numberToHclTerraform(struct!.maxBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputNewrelicEventsResponseRetrySettingsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackDestinationOutputNewrelicEventsResponseRetrySettings | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._backoffRate !== undefined) {
      hasAnyValues = true;
      internalValueResult.backoffRate = this._backoffRate;
    }
    if (this._httpStatus !== undefined) {
      hasAnyValues = true;
      internalValueResult.httpStatus = this._httpStatus;
    }
    if (this._initialBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.initialBackoff = this._initialBackoff;
    }
    if (this._maxBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBackoff = this._maxBackoff;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputNewrelicEventsResponseRetrySettings | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._backoffRate = undefined;
      this._httpStatus = undefined;
      this._initialBackoff = undefined;
      this._maxBackoff = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._backoffRate = value.backoffRate;
      this._httpStatus = value.httpStatus;
      this._initialBackoff = value.initialBackoff;
      this._maxBackoff = value.maxBackoff;
    }
  }

  // backoff_rate - computed: true, optional: true, required: false
  private _backoffRate?: number; 
  public get backoffRate() {
    return this.getNumberAttribute('backoff_rate');
  }
  public set backoffRate(value: number) {
    this._backoffRate = value;
  }
  public resetBackoffRate() {
    this._backoffRate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get backoffRateInput() {
    return this._backoffRate;
  }

  // http_status - computed: false, optional: false, required: true
  private _httpStatus?: number; 
  public get httpStatus() {
    return this.getNumberAttribute('http_status');
  }
  public set httpStatus(value: number) {
    this._httpStatus = value;
  }
  // Temporarily expose input value. Use with caution.
  public get httpStatusInput() {
    return this._httpStatus;
  }

  // initial_backoff - computed: true, optional: true, required: false
  private _initialBackoff?: number; 
  public get initialBackoff() {
    return this.getNumberAttribute('initial_backoff');
  }
  public set initialBackoff(value: number) {
    this._initialBackoff = value;
  }
  public resetInitialBackoff() {
    this._initialBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get initialBackoffInput() {
    return this._initialBackoff;
  }

  // max_backoff - computed: true, optional: true, required: false
  private _maxBackoff?: number; 
  public get maxBackoff() {
    return this.getNumberAttribute('max_backoff');
  }
  public set maxBackoff(value: number) {
    this._maxBackoff = value;
  }
  public resetMaxBackoff() {
    this._maxBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBackoffInput() {
    return this._maxBackoff;
  }
}

export class PackDestinationOutputNewrelicEventsResponseRetrySettingsList extends cdktf.ComplexList {
  public internalValue? : PackDestinationOutputNewrelicEventsResponseRetrySettings[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackDestinationOutputNewrelicEventsResponseRetrySettingsOutputReference {
    return new PackDestinationOutputNewrelicEventsResponseRetrySettingsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackDestinationOutputNewrelicEventsTimeoutRetrySettings {
  /**
  * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc. Default: 2
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#backoff_rate PackDestination#backoff_rate}
  */
  readonly backoffRate?: number;
  /**
  * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes). Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#initial_backoff PackDestination#initial_backoff}
  */
  readonly initialBackoff?: number;
  /**
  * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds). Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_backoff PackDestination#max_backoff}
  */
  readonly maxBackoff?: number;
  /**
  * Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#timeout_retry PackDestination#timeout_retry}
  */
  readonly timeoutRetry?: boolean | cdktf.IResolvable;
}

export function packDestinationOutputNewrelicEventsTimeoutRetrySettingsToTerraform(struct?: PackDestinationOutputNewrelicEventsTimeoutRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    backoff_rate: cdktf.numberToTerraform(struct!.backoffRate),
    initial_backoff: cdktf.numberToTerraform(struct!.initialBackoff),
    max_backoff: cdktf.numberToTerraform(struct!.maxBackoff),
    timeout_retry: cdktf.booleanToTerraform(struct!.timeoutRetry),
  }
}


export function packDestinationOutputNewrelicEventsTimeoutRetrySettingsToHclTerraform(struct?: PackDestinationOutputNewrelicEventsTimeoutRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    backoff_rate: {
      value: cdktf.numberToHclTerraform(struct!.backoffRate),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    initial_backoff: {
      value: cdktf.numberToHclTerraform(struct!.initialBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_backoff: {
      value: cdktf.numberToHclTerraform(struct!.maxBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    timeout_retry: {
      value: cdktf.booleanToHclTerraform(struct!.timeoutRetry),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputNewrelicEventsTimeoutRetrySettingsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackDestinationOutputNewrelicEventsTimeoutRetrySettings | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._backoffRate !== undefined) {
      hasAnyValues = true;
      internalValueResult.backoffRate = this._backoffRate;
    }
    if (this._initialBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.initialBackoff = this._initialBackoff;
    }
    if (this._maxBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBackoff = this._maxBackoff;
    }
    if (this._timeoutRetry !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutRetry = this._timeoutRetry;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputNewrelicEventsTimeoutRetrySettings | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._backoffRate = undefined;
      this._initialBackoff = undefined;
      this._maxBackoff = undefined;
      this._timeoutRetry = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._backoffRate = value.backoffRate;
      this._initialBackoff = value.initialBackoff;
      this._maxBackoff = value.maxBackoff;
      this._timeoutRetry = value.timeoutRetry;
    }
  }

  // backoff_rate - computed: true, optional: true, required: false
  private _backoffRate?: number; 
  public get backoffRate() {
    return this.getNumberAttribute('backoff_rate');
  }
  public set backoffRate(value: number) {
    this._backoffRate = value;
  }
  public resetBackoffRate() {
    this._backoffRate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get backoffRateInput() {
    return this._backoffRate;
  }

  // initial_backoff - computed: true, optional: true, required: false
  private _initialBackoff?: number; 
  public get initialBackoff() {
    return this.getNumberAttribute('initial_backoff');
  }
  public set initialBackoff(value: number) {
    this._initialBackoff = value;
  }
  public resetInitialBackoff() {
    this._initialBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get initialBackoffInput() {
    return this._initialBackoff;
  }

  // max_backoff - computed: true, optional: true, required: false
  private _maxBackoff?: number; 
  public get maxBackoff() {
    return this.getNumberAttribute('max_backoff');
  }
  public set maxBackoff(value: number) {
    this._maxBackoff = value;
  }
  public resetMaxBackoff() {
    this._maxBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBackoffInput() {
    return this._maxBackoff;
  }

  // timeout_retry - computed: true, optional: true, required: false
  private _timeoutRetry?: boolean | cdktf.IResolvable; 
  public get timeoutRetry() {
    return this.getBooleanAttribute('timeout_retry');
  }
  public set timeoutRetry(value: boolean | cdktf.IResolvable) {
    this._timeoutRetry = value;
  }
  public resetTimeoutRetry() {
    this._timeoutRetry = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutRetryInput() {
    return this._timeoutRetry;
  }
}
export interface PackDestinationOutputNewrelicEvents {
  /**
  * New Relic account ID
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#account_id PackDestination#account_id}
  */
  readonly accountId: string;
  /**
  * New Relic API key. Can be overridden using __newRelic_apiKey field.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#api_key PackDestination#api_key}
  */
  readonly apiKey?: string;
  /**
  * Enter API key directly, or select a stored secret. Default: "manual"; must be one of ["manual", "secret"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#auth_type PackDestination#auth_type}
  */
  readonly authType?: string;
  /**
  * Compress the payload body before sending. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#compress PackDestination#compress}
  */
  readonly compress?: boolean | cdktf.IResolvable;
  /**
  * Maximum number of ongoing requests before blocking. Default: 5
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#concurrency PackDestination#concurrency}
  */
  readonly concurrency?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#custom_url PackDestination#custom_url}
  */
  readonly customUrl?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#description PackDestination#description}
  */
  readonly description?: string;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#environment PackDestination#environment}
  */
  readonly environment?: string;
  /**
  * Default eventType to use when not present in an event. For more information, see [here](https://docs.newrelic.com/docs/telemetry-data-platform/custom-data/custom-events/data-requirements-limits-custom-event-data/#reserved-words).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#event_type PackDestination#event_type}
  */
  readonly eventType: string;
  /**
  * Headers to add to all events
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#extra_http_headers PackDestination#extra_http_headers}
  */
  readonly extraHttpHeaders?: PackDestinationOutputNewrelicEventsExtraHttpHeaders[] | cdktf.IResolvable;
  /**
  * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below. Default: "none"; must be one of ["payload", "payloadAndHeaders", "none"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#failed_request_logging_mode PackDestination#failed_request_logging_mode}
  */
  readonly failedRequestLoggingMode?: string;
  /**
  * Maximum time between requests. Small values could cause the payload size to be smaller than the configured Body size limit. Default: 1
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#flush_period_sec PackDestination#flush_period_sec}
  */
  readonly flushPeriodSec?: number;
  /**
  * Unique ID for this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#id PackDestination#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * Maximum number of events to include in the request body. Default is 0 (unlimited). Default: 0
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_payload_events PackDestination#max_payload_events}
  */
  readonly maxPayloadEvents?: number;
  /**
  * Maximum size, in KB, of the request body. Default: 1024
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_payload_size_kb PackDestination#max_payload_size_kb}
  */
  readonly maxPayloadSizeKb?: number;
  /**
  * How to handle events when all receivers are exerting backpressure. Default: "block"; must be one of ["block", "drop", "queue"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#on_backpressure PackDestination#on_backpressure}
  */
  readonly onBackpressure?: string;
  /**
  * Pipeline to process data before sending out to this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pipeline PackDestination#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_compress PackDestination#pq_compress}
  */
  readonly pqCompress?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_controls PackDestination#pq_controls}
  */
  readonly pqControls?: PackDestinationOutputNewrelicEventsPqControls;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.). Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_max_file_size PackDestination#pq_max_file_size}
  */
  readonly pqMaxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_max_size PackDestination#pq_max_size}
  */
  readonly pqMaxSize?: string;
  /**
  * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem. Default: "error"; must be one of ["error", "backpressure", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_mode PackDestination#pq_mode}
  */
  readonly pqMode?: string;
  /**
  * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged. Default: "block"; must be one of ["block", "drop"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_on_backpressure PackDestination#pq_on_backpressure}
  */
  readonly pqOnBackpressure?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_path PackDestination#pq_path}
  */
  readonly pqPath?: string;
  /**
  * Which New Relic region endpoint to use. Default: "US"; must be one of ["US", "EU", "Custom"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#region PackDestination#region}
  */
  readonly region?: string;
  /**
  * Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's). 
  *         Enabled by default. When this setting is also present in TLS Settings (Client Side), 
  *         that value will take precedence.
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#reject_unauthorized PackDestination#reject_unauthorized}
  */
  readonly rejectUnauthorized?: boolean | cdktf.IResolvable;
  /**
  * Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#response_honor_retry_after_header PackDestination#response_honor_retry_after_header}
  */
  readonly responseHonorRetryAfterHeader?: boolean | cdktf.IResolvable;
  /**
  * Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#response_retry_settings PackDestination#response_retry_settings}
  */
  readonly responseRetrySettings?: PackDestinationOutputNewrelicEventsResponseRetrySettings[] | cdktf.IResolvable;
  /**
  * List of headers that are safe to log in plain text. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#safe_headers PackDestination#safe_headers}
  */
  readonly safeHeaders?: string[];
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#streamtags PackDestination#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Fields to automatically add to events, such as cribl_pipe. Supports wildcards. Default: ["cribl_pipe"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#system_fields PackDestination#system_fields}
  */
  readonly systemFields?: string[];
  /**
  * Select or create a stored text secret
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#text_secret PackDestination#text_secret}
  */
  readonly textSecret?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#timeout_retry_settings PackDestination#timeout_retry_settings}
  */
  readonly timeoutRetrySettings?: PackDestinationOutputNewrelicEventsTimeoutRetrySettings;
  /**
  * Amount of time, in seconds, to wait for a request to complete before canceling it. Default: 30
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#timeout_sec PackDestination#timeout_sec}
  */
  readonly timeoutSec?: number;
  /**
  * must be "newrelic_events"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#type PackDestination#type}
  */
  readonly type?: string;
  /**
  * Enable round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. For optimal performance, consider enabling this setting for non-load balanced destinations. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#use_round_robin_dns PackDestination#use_round_robin_dns}
  */
  readonly useRoundRobinDns?: boolean | cdktf.IResolvable;
}

export function packDestinationOutputNewrelicEventsToTerraform(struct?: PackDestinationOutputNewrelicEvents | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    account_id: cdktf.stringToTerraform(struct!.accountId),
    api_key: cdktf.stringToTerraform(struct!.apiKey),
    auth_type: cdktf.stringToTerraform(struct!.authType),
    compress: cdktf.booleanToTerraform(struct!.compress),
    concurrency: cdktf.numberToTerraform(struct!.concurrency),
    custom_url: cdktf.stringToTerraform(struct!.customUrl),
    description: cdktf.stringToTerraform(struct!.description),
    environment: cdktf.stringToTerraform(struct!.environment),
    event_type: cdktf.stringToTerraform(struct!.eventType),
    extra_http_headers: cdktf.listMapper(packDestinationOutputNewrelicEventsExtraHttpHeadersToTerraform, false)(struct!.extraHttpHeaders),
    failed_request_logging_mode: cdktf.stringToTerraform(struct!.failedRequestLoggingMode),
    flush_period_sec: cdktf.numberToTerraform(struct!.flushPeriodSec),
    id: cdktf.stringToTerraform(struct!.id),
    max_payload_events: cdktf.numberToTerraform(struct!.maxPayloadEvents),
    max_payload_size_kb: cdktf.numberToTerraform(struct!.maxPayloadSizeKb),
    on_backpressure: cdktf.stringToTerraform(struct!.onBackpressure),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    pq_compress: cdktf.stringToTerraform(struct!.pqCompress),
    pq_controls: packDestinationOutputNewrelicEventsPqControlsToTerraform(struct!.pqControls),
    pq_max_file_size: cdktf.stringToTerraform(struct!.pqMaxFileSize),
    pq_max_size: cdktf.stringToTerraform(struct!.pqMaxSize),
    pq_mode: cdktf.stringToTerraform(struct!.pqMode),
    pq_on_backpressure: cdktf.stringToTerraform(struct!.pqOnBackpressure),
    pq_path: cdktf.stringToTerraform(struct!.pqPath),
    region: cdktf.stringToTerraform(struct!.region),
    reject_unauthorized: cdktf.booleanToTerraform(struct!.rejectUnauthorized),
    response_honor_retry_after_header: cdktf.booleanToTerraform(struct!.responseHonorRetryAfterHeader),
    response_retry_settings: cdktf.listMapper(packDestinationOutputNewrelicEventsResponseRetrySettingsToTerraform, false)(struct!.responseRetrySettings),
    safe_headers: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.safeHeaders),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    system_fields: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.systemFields),
    text_secret: cdktf.stringToTerraform(struct!.textSecret),
    timeout_retry_settings: packDestinationOutputNewrelicEventsTimeoutRetrySettingsToTerraform(struct!.timeoutRetrySettings),
    timeout_sec: cdktf.numberToTerraform(struct!.timeoutSec),
    type: cdktf.stringToTerraform(struct!.type),
    use_round_robin_dns: cdktf.booleanToTerraform(struct!.useRoundRobinDns),
  }
}


export function packDestinationOutputNewrelicEventsToHclTerraform(struct?: PackDestinationOutputNewrelicEvents | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    account_id: {
      value: cdktf.stringToHclTerraform(struct!.accountId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    api_key: {
      value: cdktf.stringToHclTerraform(struct!.apiKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    auth_type: {
      value: cdktf.stringToHclTerraform(struct!.authType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    compress: {
      value: cdktf.booleanToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    concurrency: {
      value: cdktf.numberToHclTerraform(struct!.concurrency),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    custom_url: {
      value: cdktf.stringToHclTerraform(struct!.customUrl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    event_type: {
      value: cdktf.stringToHclTerraform(struct!.eventType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    extra_http_headers: {
      value: cdktf.listMapperHcl(packDestinationOutputNewrelicEventsExtraHttpHeadersToHclTerraform, false)(struct!.extraHttpHeaders),
      isBlock: true,
      type: "list",
      storageClassType: "PackDestinationOutputNewrelicEventsExtraHttpHeadersList",
    },
    failed_request_logging_mode: {
      value: cdktf.stringToHclTerraform(struct!.failedRequestLoggingMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    flush_period_sec: {
      value: cdktf.numberToHclTerraform(struct!.flushPeriodSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_payload_events: {
      value: cdktf.numberToHclTerraform(struct!.maxPayloadEvents),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_payload_size_kb: {
      value: cdktf.numberToHclTerraform(struct!.maxPayloadSizeKb),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.onBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_compress: {
      value: cdktf.stringToHclTerraform(struct!.pqCompress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_controls: {
      value: packDestinationOutputNewrelicEventsPqControlsToHclTerraform(struct!.pqControls),
      isBlock: true,
      type: "struct",
      storageClassType: "PackDestinationOutputNewrelicEventsPqControls",
    },
    pq_max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_max_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_mode: {
      value: cdktf.stringToHclTerraform(struct!.pqMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.pqOnBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_path: {
      value: cdktf.stringToHclTerraform(struct!.pqPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    region: {
      value: cdktf.stringToHclTerraform(struct!.region),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reject_unauthorized: {
      value: cdktf.booleanToHclTerraform(struct!.rejectUnauthorized),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    response_honor_retry_after_header: {
      value: cdktf.booleanToHclTerraform(struct!.responseHonorRetryAfterHeader),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    response_retry_settings: {
      value: cdktf.listMapperHcl(packDestinationOutputNewrelicEventsResponseRetrySettingsToHclTerraform, false)(struct!.responseRetrySettings),
      isBlock: true,
      type: "list",
      storageClassType: "PackDestinationOutputNewrelicEventsResponseRetrySettingsList",
    },
    safe_headers: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.safeHeaders),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    system_fields: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.systemFields),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    text_secret: {
      value: cdktf.stringToHclTerraform(struct!.textSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    timeout_retry_settings: {
      value: packDestinationOutputNewrelicEventsTimeoutRetrySettingsToHclTerraform(struct!.timeoutRetrySettings),
      isBlock: true,
      type: "struct",
      storageClassType: "PackDestinationOutputNewrelicEventsTimeoutRetrySettings",
    },
    timeout_sec: {
      value: cdktf.numberToHclTerraform(struct!.timeoutSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    use_round_robin_dns: {
      value: cdktf.booleanToHclTerraform(struct!.useRoundRobinDns),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputNewrelicEventsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackDestinationOutputNewrelicEvents | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._accountId !== undefined) {
      hasAnyValues = true;
      internalValueResult.accountId = this._accountId;
    }
    if (this._apiKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.apiKey = this._apiKey;
    }
    if (this._authType !== undefined) {
      hasAnyValues = true;
      internalValueResult.authType = this._authType;
    }
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._concurrency !== undefined) {
      hasAnyValues = true;
      internalValueResult.concurrency = this._concurrency;
    }
    if (this._customUrl !== undefined) {
      hasAnyValues = true;
      internalValueResult.customUrl = this._customUrl;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._eventType !== undefined) {
      hasAnyValues = true;
      internalValueResult.eventType = this._eventType;
    }
    if (this._extraHttpHeaders?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.extraHttpHeaders = this._extraHttpHeaders?.internalValue;
    }
    if (this._failedRequestLoggingMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.failedRequestLoggingMode = this._failedRequestLoggingMode;
    }
    if (this._flushPeriodSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.flushPeriodSec = this._flushPeriodSec;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._maxPayloadEvents !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxPayloadEvents = this._maxPayloadEvents;
    }
    if (this._maxPayloadSizeKb !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxPayloadSizeKb = this._maxPayloadSizeKb;
    }
    if (this._onBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.onBackpressure = this._onBackpressure;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._pqCompress !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqCompress = this._pqCompress;
    }
    if (this._pqControls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqControls = this._pqControls?.internalValue;
    }
    if (this._pqMaxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxFileSize = this._pqMaxFileSize;
    }
    if (this._pqMaxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxSize = this._pqMaxSize;
    }
    if (this._pqMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMode = this._pqMode;
    }
    if (this._pqOnBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqOnBackpressure = this._pqOnBackpressure;
    }
    if (this._pqPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqPath = this._pqPath;
    }
    if (this._region !== undefined) {
      hasAnyValues = true;
      internalValueResult.region = this._region;
    }
    if (this._rejectUnauthorized !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectUnauthorized = this._rejectUnauthorized;
    }
    if (this._responseHonorRetryAfterHeader !== undefined) {
      hasAnyValues = true;
      internalValueResult.responseHonorRetryAfterHeader = this._responseHonorRetryAfterHeader;
    }
    if (this._responseRetrySettings?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.responseRetrySettings = this._responseRetrySettings?.internalValue;
    }
    if (this._safeHeaders !== undefined) {
      hasAnyValues = true;
      internalValueResult.safeHeaders = this._safeHeaders;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._systemFields !== undefined) {
      hasAnyValues = true;
      internalValueResult.systemFields = this._systemFields;
    }
    if (this._textSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.textSecret = this._textSecret;
    }
    if (this._timeoutRetrySettings?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutRetrySettings = this._timeoutRetrySettings?.internalValue;
    }
    if (this._timeoutSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutSec = this._timeoutSec;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._useRoundRobinDns !== undefined) {
      hasAnyValues = true;
      internalValueResult.useRoundRobinDns = this._useRoundRobinDns;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputNewrelicEvents | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._accountId = undefined;
      this._apiKey = undefined;
      this._authType = undefined;
      this._compress = undefined;
      this._concurrency = undefined;
      this._customUrl = undefined;
      this._description = undefined;
      this._environment = undefined;
      this._eventType = undefined;
      this._extraHttpHeaders.internalValue = undefined;
      this._failedRequestLoggingMode = undefined;
      this._flushPeriodSec = undefined;
      this._id = undefined;
      this._maxPayloadEvents = undefined;
      this._maxPayloadSizeKb = undefined;
      this._onBackpressure = undefined;
      this._pipeline = undefined;
      this._pqCompress = undefined;
      this._pqControls.internalValue = undefined;
      this._pqMaxFileSize = undefined;
      this._pqMaxSize = undefined;
      this._pqMode = undefined;
      this._pqOnBackpressure = undefined;
      this._pqPath = undefined;
      this._region = undefined;
      this._rejectUnauthorized = undefined;
      this._responseHonorRetryAfterHeader = undefined;
      this._responseRetrySettings.internalValue = undefined;
      this._safeHeaders = undefined;
      this._streamtags = undefined;
      this._systemFields = undefined;
      this._textSecret = undefined;
      this._timeoutRetrySettings.internalValue = undefined;
      this._timeoutSec = undefined;
      this._type = undefined;
      this._useRoundRobinDns = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._accountId = value.accountId;
      this._apiKey = value.apiKey;
      this._authType = value.authType;
      this._compress = value.compress;
      this._concurrency = value.concurrency;
      this._customUrl = value.customUrl;
      this._description = value.description;
      this._environment = value.environment;
      this._eventType = value.eventType;
      this._extraHttpHeaders.internalValue = value.extraHttpHeaders;
      this._failedRequestLoggingMode = value.failedRequestLoggingMode;
      this._flushPeriodSec = value.flushPeriodSec;
      this._id = value.id;
      this._maxPayloadEvents = value.maxPayloadEvents;
      this._maxPayloadSizeKb = value.maxPayloadSizeKb;
      this._onBackpressure = value.onBackpressure;
      this._pipeline = value.pipeline;
      this._pqCompress = value.pqCompress;
      this._pqControls.internalValue = value.pqControls;
      this._pqMaxFileSize = value.pqMaxFileSize;
      this._pqMaxSize = value.pqMaxSize;
      this._pqMode = value.pqMode;
      this._pqOnBackpressure = value.pqOnBackpressure;
      this._pqPath = value.pqPath;
      this._region = value.region;
      this._rejectUnauthorized = value.rejectUnauthorized;
      this._responseHonorRetryAfterHeader = value.responseHonorRetryAfterHeader;
      this._responseRetrySettings.internalValue = value.responseRetrySettings;
      this._safeHeaders = value.safeHeaders;
      this._streamtags = value.streamtags;
      this._systemFields = value.systemFields;
      this._textSecret = value.textSecret;
      this._timeoutRetrySettings.internalValue = value.timeoutRetrySettings;
      this._timeoutSec = value.timeoutSec;
      this._type = value.type;
      this._useRoundRobinDns = value.useRoundRobinDns;
    }
  }

  // account_id - computed: false, optional: false, required: true
  private _accountId?: string; 
  public get accountId() {
    return this.getStringAttribute('account_id');
  }
  public set accountId(value: string) {
    this._accountId = value;
  }
  // Temporarily expose input value. Use with caution.
  public get accountIdInput() {
    return this._accountId;
  }

  // api_key - computed: false, optional: true, required: false
  private _apiKey?: string; 
  public get apiKey() {
    return this.getStringAttribute('api_key');
  }
  public set apiKey(value: string) {
    this._apiKey = value;
  }
  public resetApiKey() {
    this._apiKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get apiKeyInput() {
    return this._apiKey;
  }

  // auth_type - computed: true, optional: true, required: false
  private _authType?: string; 
  public get authType() {
    return this.getStringAttribute('auth_type');
  }
  public set authType(value: string) {
    this._authType = value;
  }
  public resetAuthType() {
    this._authType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authTypeInput() {
    return this._authType;
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: boolean | cdktf.IResolvable; 
  public get compress() {
    return this.getBooleanAttribute('compress');
  }
  public set compress(value: boolean | cdktf.IResolvable) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // concurrency - computed: true, optional: true, required: false
  private _concurrency?: number; 
  public get concurrency() {
    return this.getNumberAttribute('concurrency');
  }
  public set concurrency(value: number) {
    this._concurrency = value;
  }
  public resetConcurrency() {
    this._concurrency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get concurrencyInput() {
    return this._concurrency;
  }

  // custom_url - computed: false, optional: true, required: false
  private _customUrl?: string; 
  public get customUrl() {
    return this.getStringAttribute('custom_url');
  }
  public set customUrl(value: string) {
    this._customUrl = value;
  }
  public resetCustomUrl() {
    this._customUrl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get customUrlInput() {
    return this._customUrl;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // event_type - computed: false, optional: false, required: true
  private _eventType?: string; 
  public get eventType() {
    return this.getStringAttribute('event_type');
  }
  public set eventType(value: string) {
    this._eventType = value;
  }
  // Temporarily expose input value. Use with caution.
  public get eventTypeInput() {
    return this._eventType;
  }

  // extra_http_headers - computed: false, optional: true, required: false
  private _extraHttpHeaders = new PackDestinationOutputNewrelicEventsExtraHttpHeadersList(this, "extra_http_headers", false);
  public get extraHttpHeaders() {
    return this._extraHttpHeaders;
  }
  public putExtraHttpHeaders(value: PackDestinationOutputNewrelicEventsExtraHttpHeaders[] | cdktf.IResolvable) {
    this._extraHttpHeaders.internalValue = value;
  }
  public resetExtraHttpHeaders() {
    this._extraHttpHeaders.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get extraHttpHeadersInput() {
    return this._extraHttpHeaders.internalValue;
  }

  // failed_request_logging_mode - computed: true, optional: true, required: false
  private _failedRequestLoggingMode?: string; 
  public get failedRequestLoggingMode() {
    return this.getStringAttribute('failed_request_logging_mode');
  }
  public set failedRequestLoggingMode(value: string) {
    this._failedRequestLoggingMode = value;
  }
  public resetFailedRequestLoggingMode() {
    this._failedRequestLoggingMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get failedRequestLoggingModeInput() {
    return this._failedRequestLoggingMode;
  }

  // flush_period_sec - computed: true, optional: true, required: false
  private _flushPeriodSec?: number; 
  public get flushPeriodSec() {
    return this.getNumberAttribute('flush_period_sec');
  }
  public set flushPeriodSec(value: number) {
    this._flushPeriodSec = value;
  }
  public resetFlushPeriodSec() {
    this._flushPeriodSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get flushPeriodSecInput() {
    return this._flushPeriodSec;
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // max_payload_events - computed: true, optional: true, required: false
  private _maxPayloadEvents?: number; 
  public get maxPayloadEvents() {
    return this.getNumberAttribute('max_payload_events');
  }
  public set maxPayloadEvents(value: number) {
    this._maxPayloadEvents = value;
  }
  public resetMaxPayloadEvents() {
    this._maxPayloadEvents = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxPayloadEventsInput() {
    return this._maxPayloadEvents;
  }

  // max_payload_size_kb - computed: true, optional: true, required: false
  private _maxPayloadSizeKb?: number; 
  public get maxPayloadSizeKb() {
    return this.getNumberAttribute('max_payload_size_kb');
  }
  public set maxPayloadSizeKb(value: number) {
    this._maxPayloadSizeKb = value;
  }
  public resetMaxPayloadSizeKb() {
    this._maxPayloadSizeKb = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxPayloadSizeKbInput() {
    return this._maxPayloadSizeKb;
  }

  // on_backpressure - computed: true, optional: true, required: false
  private _onBackpressure?: string; 
  public get onBackpressure() {
    return this.getStringAttribute('on_backpressure');
  }
  public set onBackpressure(value: string) {
    this._onBackpressure = value;
  }
  public resetOnBackpressure() {
    this._onBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get onBackpressureInput() {
    return this._onBackpressure;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // pq_compress - computed: true, optional: true, required: false
  private _pqCompress?: string; 
  public get pqCompress() {
    return this.getStringAttribute('pq_compress');
  }
  public set pqCompress(value: string) {
    this._pqCompress = value;
  }
  public resetPqCompress() {
    this._pqCompress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqCompressInput() {
    return this._pqCompress;
  }

  // pq_controls - computed: false, optional: true, required: false
  private _pqControls = new PackDestinationOutputNewrelicEventsPqControlsOutputReference(this, "pq_controls");
  public get pqControls() {
    return this._pqControls;
  }
  public putPqControls(value: PackDestinationOutputNewrelicEventsPqControls) {
    this._pqControls.internalValue = value;
  }
  public resetPqControls() {
    this._pqControls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqControlsInput() {
    return this._pqControls.internalValue;
  }

  // pq_max_file_size - computed: true, optional: true, required: false
  private _pqMaxFileSize?: string; 
  public get pqMaxFileSize() {
    return this.getStringAttribute('pq_max_file_size');
  }
  public set pqMaxFileSize(value: string) {
    this._pqMaxFileSize = value;
  }
  public resetPqMaxFileSize() {
    this._pqMaxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxFileSizeInput() {
    return this._pqMaxFileSize;
  }

  // pq_max_size - computed: true, optional: true, required: false
  private _pqMaxSize?: string; 
  public get pqMaxSize() {
    return this.getStringAttribute('pq_max_size');
  }
  public set pqMaxSize(value: string) {
    this._pqMaxSize = value;
  }
  public resetPqMaxSize() {
    this._pqMaxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxSizeInput() {
    return this._pqMaxSize;
  }

  // pq_mode - computed: true, optional: true, required: false
  private _pqMode?: string; 
  public get pqMode() {
    return this.getStringAttribute('pq_mode');
  }
  public set pqMode(value: string) {
    this._pqMode = value;
  }
  public resetPqMode() {
    this._pqMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqModeInput() {
    return this._pqMode;
  }

  // pq_on_backpressure - computed: true, optional: true, required: false
  private _pqOnBackpressure?: string; 
  public get pqOnBackpressure() {
    return this.getStringAttribute('pq_on_backpressure');
  }
  public set pqOnBackpressure(value: string) {
    this._pqOnBackpressure = value;
  }
  public resetPqOnBackpressure() {
    this._pqOnBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqOnBackpressureInput() {
    return this._pqOnBackpressure;
  }

  // pq_path - computed: true, optional: true, required: false
  private _pqPath?: string; 
  public get pqPath() {
    return this.getStringAttribute('pq_path');
  }
  public set pqPath(value: string) {
    this._pqPath = value;
  }
  public resetPqPath() {
    this._pqPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqPathInput() {
    return this._pqPath;
  }

  // region - computed: true, optional: true, required: false
  private _region?: string; 
  public get region() {
    return this.getStringAttribute('region');
  }
  public set region(value: string) {
    this._region = value;
  }
  public resetRegion() {
    this._region = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get regionInput() {
    return this._region;
  }

  // reject_unauthorized - computed: true, optional: true, required: false
  private _rejectUnauthorized?: boolean | cdktf.IResolvable; 
  public get rejectUnauthorized() {
    return this.getBooleanAttribute('reject_unauthorized');
  }
  public set rejectUnauthorized(value: boolean | cdktf.IResolvable) {
    this._rejectUnauthorized = value;
  }
  public resetRejectUnauthorized() {
    this._rejectUnauthorized = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectUnauthorizedInput() {
    return this._rejectUnauthorized;
  }

  // response_honor_retry_after_header - computed: true, optional: true, required: false
  private _responseHonorRetryAfterHeader?: boolean | cdktf.IResolvable; 
  public get responseHonorRetryAfterHeader() {
    return this.getBooleanAttribute('response_honor_retry_after_header');
  }
  public set responseHonorRetryAfterHeader(value: boolean | cdktf.IResolvable) {
    this._responseHonorRetryAfterHeader = value;
  }
  public resetResponseHonorRetryAfterHeader() {
    this._responseHonorRetryAfterHeader = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get responseHonorRetryAfterHeaderInput() {
    return this._responseHonorRetryAfterHeader;
  }

  // response_retry_settings - computed: false, optional: true, required: false
  private _responseRetrySettings = new PackDestinationOutputNewrelicEventsResponseRetrySettingsList(this, "response_retry_settings", false);
  public get responseRetrySettings() {
    return this._responseRetrySettings;
  }
  public putResponseRetrySettings(value: PackDestinationOutputNewrelicEventsResponseRetrySettings[] | cdktf.IResolvable) {
    this._responseRetrySettings.internalValue = value;
  }
  public resetResponseRetrySettings() {
    this._responseRetrySettings.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get responseRetrySettingsInput() {
    return this._responseRetrySettings.internalValue;
  }

  // safe_headers - computed: true, optional: true, required: false
  private _safeHeaders?: string[]; 
  public get safeHeaders() {
    return this.getListAttribute('safe_headers');
  }
  public set safeHeaders(value: string[]) {
    this._safeHeaders = value;
  }
  public resetSafeHeaders() {
    this._safeHeaders = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get safeHeadersInput() {
    return this._safeHeaders;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // system_fields - computed: true, optional: true, required: false
  private _systemFields?: string[]; 
  public get systemFields() {
    return this.getListAttribute('system_fields');
  }
  public set systemFields(value: string[]) {
    this._systemFields = value;
  }
  public resetSystemFields() {
    this._systemFields = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get systemFieldsInput() {
    return this._systemFields;
  }

  // text_secret - computed: false, optional: true, required: false
  private _textSecret?: string; 
  public get textSecret() {
    return this.getStringAttribute('text_secret');
  }
  public set textSecret(value: string) {
    this._textSecret = value;
  }
  public resetTextSecret() {
    this._textSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get textSecretInput() {
    return this._textSecret;
  }

  // timeout_retry_settings - computed: false, optional: true, required: false
  private _timeoutRetrySettings = new PackDestinationOutputNewrelicEventsTimeoutRetrySettingsOutputReference(this, "timeout_retry_settings");
  public get timeoutRetrySettings() {
    return this._timeoutRetrySettings;
  }
  public putTimeoutRetrySettings(value: PackDestinationOutputNewrelicEventsTimeoutRetrySettings) {
    this._timeoutRetrySettings.internalValue = value;
  }
  public resetTimeoutRetrySettings() {
    this._timeoutRetrySettings.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutRetrySettingsInput() {
    return this._timeoutRetrySettings.internalValue;
  }

  // timeout_sec - computed: true, optional: true, required: false
  private _timeoutSec?: number; 
  public get timeoutSec() {
    return this.getNumberAttribute('timeout_sec');
  }
  public set timeoutSec(value: number) {
    this._timeoutSec = value;
  }
  public resetTimeoutSec() {
    this._timeoutSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutSecInput() {
    return this._timeoutSec;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // use_round_robin_dns - computed: true, optional: true, required: false
  private _useRoundRobinDns?: boolean | cdktf.IResolvable; 
  public get useRoundRobinDns() {
    return this.getBooleanAttribute('use_round_robin_dns');
  }
  public set useRoundRobinDns(value: boolean | cdktf.IResolvable) {
    this._useRoundRobinDns = value;
  }
  public resetUseRoundRobinDns() {
    this._useRoundRobinDns = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get useRoundRobinDnsInput() {
    return this._useRoundRobinDns;
  }
}
export interface PackDestinationOutputOpenTelemetryExtraHttpHeaders {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#name PackDestination#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#value PackDestination#value}
  */
  readonly value: string;
}

export function packDestinationOutputOpenTelemetryExtraHttpHeadersToTerraform(struct?: PackDestinationOutputOpenTelemetryExtraHttpHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function packDestinationOutputOpenTelemetryExtraHttpHeadersToHclTerraform(struct?: PackDestinationOutputOpenTelemetryExtraHttpHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputOpenTelemetryExtraHttpHeadersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackDestinationOutputOpenTelemetryExtraHttpHeaders | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputOpenTelemetryExtraHttpHeaders | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class PackDestinationOutputOpenTelemetryExtraHttpHeadersList extends cdktf.ComplexList {
  public internalValue? : PackDestinationOutputOpenTelemetryExtraHttpHeaders[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackDestinationOutputOpenTelemetryExtraHttpHeadersOutputReference {
    return new PackDestinationOutputOpenTelemetryExtraHttpHeadersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackDestinationOutputOpenTelemetryMetadata {
  /**
  * Default: ""
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#key PackDestination#key}
  */
  readonly key?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#value PackDestination#value}
  */
  readonly value: string;
}

export function packDestinationOutputOpenTelemetryMetadataToTerraform(struct?: PackDestinationOutputOpenTelemetryMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function packDestinationOutputOpenTelemetryMetadataToHclTerraform(struct?: PackDestinationOutputOpenTelemetryMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputOpenTelemetryMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackDestinationOutputOpenTelemetryMetadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputOpenTelemetryMetadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._value = value.value;
    }
  }

  // key - computed: true, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class PackDestinationOutputOpenTelemetryMetadataList extends cdktf.ComplexList {
  public internalValue? : PackDestinationOutputOpenTelemetryMetadata[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackDestinationOutputOpenTelemetryMetadataOutputReference {
    return new PackDestinationOutputOpenTelemetryMetadataOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackDestinationOutputOpenTelemetryOauthHeaders {
  /**
  * OAuth header name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#name PackDestination#name}
  */
  readonly name: string;
  /**
  * OAuth header value
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#value PackDestination#value}
  */
  readonly value: string;
}

export function packDestinationOutputOpenTelemetryOauthHeadersToTerraform(struct?: PackDestinationOutputOpenTelemetryOauthHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function packDestinationOutputOpenTelemetryOauthHeadersToHclTerraform(struct?: PackDestinationOutputOpenTelemetryOauthHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputOpenTelemetryOauthHeadersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackDestinationOutputOpenTelemetryOauthHeaders | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputOpenTelemetryOauthHeaders | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class PackDestinationOutputOpenTelemetryOauthHeadersList extends cdktf.ComplexList {
  public internalValue? : PackDestinationOutputOpenTelemetryOauthHeaders[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackDestinationOutputOpenTelemetryOauthHeadersOutputReference {
    return new PackDestinationOutputOpenTelemetryOauthHeadersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackDestinationOutputOpenTelemetryOauthParams {
  /**
  * OAuth parameter name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#name PackDestination#name}
  */
  readonly name: string;
  /**
  * OAuth parameter value
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#value PackDestination#value}
  */
  readonly value: string;
}

export function packDestinationOutputOpenTelemetryOauthParamsToTerraform(struct?: PackDestinationOutputOpenTelemetryOauthParams | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function packDestinationOutputOpenTelemetryOauthParamsToHclTerraform(struct?: PackDestinationOutputOpenTelemetryOauthParams | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputOpenTelemetryOauthParamsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackDestinationOutputOpenTelemetryOauthParams | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputOpenTelemetryOauthParams | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class PackDestinationOutputOpenTelemetryOauthParamsList extends cdktf.ComplexList {
  public internalValue? : PackDestinationOutputOpenTelemetryOauthParams[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackDestinationOutputOpenTelemetryOauthParamsOutputReference {
    return new PackDestinationOutputOpenTelemetryOauthParamsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackDestinationOutputOpenTelemetryPqControls {
}

export function packDestinationOutputOpenTelemetryPqControlsToTerraform(struct?: PackDestinationOutputOpenTelemetryPqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function packDestinationOutputOpenTelemetryPqControlsToHclTerraform(struct?: PackDestinationOutputOpenTelemetryPqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class PackDestinationOutputOpenTelemetryPqControlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackDestinationOutputOpenTelemetryPqControls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputOpenTelemetryPqControls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface PackDestinationOutputOpenTelemetryResponseRetrySettings {
  /**
  * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc. Default: 2
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#backoff_rate PackDestination#backoff_rate}
  */
  readonly backoffRate?: number;
  /**
  * The HTTP response status code that will trigger retries
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#http_status PackDestination#http_status}
  */
  readonly httpStatus: number;
  /**
  * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes). Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#initial_backoff PackDestination#initial_backoff}
  */
  readonly initialBackoff?: number;
  /**
  * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds). Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_backoff PackDestination#max_backoff}
  */
  readonly maxBackoff?: number;
}

export function packDestinationOutputOpenTelemetryResponseRetrySettingsToTerraform(struct?: PackDestinationOutputOpenTelemetryResponseRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    backoff_rate: cdktf.numberToTerraform(struct!.backoffRate),
    http_status: cdktf.numberToTerraform(struct!.httpStatus),
    initial_backoff: cdktf.numberToTerraform(struct!.initialBackoff),
    max_backoff: cdktf.numberToTerraform(struct!.maxBackoff),
  }
}


export function packDestinationOutputOpenTelemetryResponseRetrySettingsToHclTerraform(struct?: PackDestinationOutputOpenTelemetryResponseRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    backoff_rate: {
      value: cdktf.numberToHclTerraform(struct!.backoffRate),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    http_status: {
      value: cdktf.numberToHclTerraform(struct!.httpStatus),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    initial_backoff: {
      value: cdktf.numberToHclTerraform(struct!.initialBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_backoff: {
      value: cdktf.numberToHclTerraform(struct!.maxBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputOpenTelemetryResponseRetrySettingsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackDestinationOutputOpenTelemetryResponseRetrySettings | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._backoffRate !== undefined) {
      hasAnyValues = true;
      internalValueResult.backoffRate = this._backoffRate;
    }
    if (this._httpStatus !== undefined) {
      hasAnyValues = true;
      internalValueResult.httpStatus = this._httpStatus;
    }
    if (this._initialBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.initialBackoff = this._initialBackoff;
    }
    if (this._maxBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBackoff = this._maxBackoff;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputOpenTelemetryResponseRetrySettings | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._backoffRate = undefined;
      this._httpStatus = undefined;
      this._initialBackoff = undefined;
      this._maxBackoff = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._backoffRate = value.backoffRate;
      this._httpStatus = value.httpStatus;
      this._initialBackoff = value.initialBackoff;
      this._maxBackoff = value.maxBackoff;
    }
  }

  // backoff_rate - computed: true, optional: true, required: false
  private _backoffRate?: number; 
  public get backoffRate() {
    return this.getNumberAttribute('backoff_rate');
  }
  public set backoffRate(value: number) {
    this._backoffRate = value;
  }
  public resetBackoffRate() {
    this._backoffRate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get backoffRateInput() {
    return this._backoffRate;
  }

  // http_status - computed: false, optional: false, required: true
  private _httpStatus?: number; 
  public get httpStatus() {
    return this.getNumberAttribute('http_status');
  }
  public set httpStatus(value: number) {
    this._httpStatus = value;
  }
  // Temporarily expose input value. Use with caution.
  public get httpStatusInput() {
    return this._httpStatus;
  }

  // initial_backoff - computed: true, optional: true, required: false
  private _initialBackoff?: number; 
  public get initialBackoff() {
    return this.getNumberAttribute('initial_backoff');
  }
  public set initialBackoff(value: number) {
    this._initialBackoff = value;
  }
  public resetInitialBackoff() {
    this._initialBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get initialBackoffInput() {
    return this._initialBackoff;
  }

  // max_backoff - computed: true, optional: true, required: false
  private _maxBackoff?: number; 
  public get maxBackoff() {
    return this.getNumberAttribute('max_backoff');
  }
  public set maxBackoff(value: number) {
    this._maxBackoff = value;
  }
  public resetMaxBackoff() {
    this._maxBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBackoffInput() {
    return this._maxBackoff;
  }
}

export class PackDestinationOutputOpenTelemetryResponseRetrySettingsList extends cdktf.ComplexList {
  public internalValue? : PackDestinationOutputOpenTelemetryResponseRetrySettings[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackDestinationOutputOpenTelemetryResponseRetrySettingsOutputReference {
    return new PackDestinationOutputOpenTelemetryResponseRetrySettingsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackDestinationOutputOpenTelemetryTimeoutRetrySettings {
  /**
  * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc. Default: 2
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#backoff_rate PackDestination#backoff_rate}
  */
  readonly backoffRate?: number;
  /**
  * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes). Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#initial_backoff PackDestination#initial_backoff}
  */
  readonly initialBackoff?: number;
  /**
  * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds). Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_backoff PackDestination#max_backoff}
  */
  readonly maxBackoff?: number;
  /**
  * Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#timeout_retry PackDestination#timeout_retry}
  */
  readonly timeoutRetry?: boolean | cdktf.IResolvable;
}

export function packDestinationOutputOpenTelemetryTimeoutRetrySettingsToTerraform(struct?: PackDestinationOutputOpenTelemetryTimeoutRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    backoff_rate: cdktf.numberToTerraform(struct!.backoffRate),
    initial_backoff: cdktf.numberToTerraform(struct!.initialBackoff),
    max_backoff: cdktf.numberToTerraform(struct!.maxBackoff),
    timeout_retry: cdktf.booleanToTerraform(struct!.timeoutRetry),
  }
}


export function packDestinationOutputOpenTelemetryTimeoutRetrySettingsToHclTerraform(struct?: PackDestinationOutputOpenTelemetryTimeoutRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    backoff_rate: {
      value: cdktf.numberToHclTerraform(struct!.backoffRate),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    initial_backoff: {
      value: cdktf.numberToHclTerraform(struct!.initialBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_backoff: {
      value: cdktf.numberToHclTerraform(struct!.maxBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    timeout_retry: {
      value: cdktf.booleanToHclTerraform(struct!.timeoutRetry),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputOpenTelemetryTimeoutRetrySettingsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackDestinationOutputOpenTelemetryTimeoutRetrySettings | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._backoffRate !== undefined) {
      hasAnyValues = true;
      internalValueResult.backoffRate = this._backoffRate;
    }
    if (this._initialBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.initialBackoff = this._initialBackoff;
    }
    if (this._maxBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBackoff = this._maxBackoff;
    }
    if (this._timeoutRetry !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutRetry = this._timeoutRetry;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputOpenTelemetryTimeoutRetrySettings | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._backoffRate = undefined;
      this._initialBackoff = undefined;
      this._maxBackoff = undefined;
      this._timeoutRetry = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._backoffRate = value.backoffRate;
      this._initialBackoff = value.initialBackoff;
      this._maxBackoff = value.maxBackoff;
      this._timeoutRetry = value.timeoutRetry;
    }
  }

  // backoff_rate - computed: true, optional: true, required: false
  private _backoffRate?: number; 
  public get backoffRate() {
    return this.getNumberAttribute('backoff_rate');
  }
  public set backoffRate(value: number) {
    this._backoffRate = value;
  }
  public resetBackoffRate() {
    this._backoffRate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get backoffRateInput() {
    return this._backoffRate;
  }

  // initial_backoff - computed: true, optional: true, required: false
  private _initialBackoff?: number; 
  public get initialBackoff() {
    return this.getNumberAttribute('initial_backoff');
  }
  public set initialBackoff(value: number) {
    this._initialBackoff = value;
  }
  public resetInitialBackoff() {
    this._initialBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get initialBackoffInput() {
    return this._initialBackoff;
  }

  // max_backoff - computed: true, optional: true, required: false
  private _maxBackoff?: number; 
  public get maxBackoff() {
    return this.getNumberAttribute('max_backoff');
  }
  public set maxBackoff(value: number) {
    this._maxBackoff = value;
  }
  public resetMaxBackoff() {
    this._maxBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBackoffInput() {
    return this._maxBackoff;
  }

  // timeout_retry - computed: true, optional: true, required: false
  private _timeoutRetry?: boolean | cdktf.IResolvable; 
  public get timeoutRetry() {
    return this.getBooleanAttribute('timeout_retry');
  }
  public set timeoutRetry(value: boolean | cdktf.IResolvable) {
    this._timeoutRetry = value;
  }
  public resetTimeoutRetry() {
    this._timeoutRetry = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutRetryInput() {
    return this._timeoutRetry;
  }
}
export interface PackDestinationOutputOpenTelemetryTls {
  /**
  * Path on client in which to find CA certificates to verify the server's cert. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#ca_path PackDestination#ca_path}
  */
  readonly caPath?: string;
  /**
  * Path on client in which to find certificates to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#cert_path PackDestination#cert_path}
  */
  readonly certPath?: string;
  /**
  * The name of the predefined certificate
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#certificate_name PackDestination#certificate_name}
  */
  readonly certificateName?: string;
  /**
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#disabled PackDestination#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_version PackDestination#max_version}
  */
  readonly maxVersion?: string;
  /**
  * must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#min_version PackDestination#min_version}
  */
  readonly minVersion?: string;
  /**
  * Passphrase to use to decrypt private key
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#passphrase PackDestination#passphrase}
  */
  readonly passphrase?: string;
  /**
  * Path on client in which to find the private key to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#priv_key_path PackDestination#priv_key_path}
  */
  readonly privKeyPath?: string;
  /**
  * Reject certificates that are not authorized by a CA in the CA certificate path, or by another
  * 
  * 
  *                     trusted CA (such as the system's). Defaults to Enabled. Overrides the toggle from Advanced Settings, when also present.
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#reject_unauthorized PackDestination#reject_unauthorized}
  */
  readonly rejectUnauthorized?: boolean | cdktf.IResolvable;
}

export function packDestinationOutputOpenTelemetryTlsToTerraform(struct?: PackDestinationOutputOpenTelemetryTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ca_path: cdktf.stringToTerraform(struct!.caPath),
    cert_path: cdktf.stringToTerraform(struct!.certPath),
    certificate_name: cdktf.stringToTerraform(struct!.certificateName),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    max_version: cdktf.stringToTerraform(struct!.maxVersion),
    min_version: cdktf.stringToTerraform(struct!.minVersion),
    passphrase: cdktf.stringToTerraform(struct!.passphrase),
    priv_key_path: cdktf.stringToTerraform(struct!.privKeyPath),
    reject_unauthorized: cdktf.booleanToTerraform(struct!.rejectUnauthorized),
  }
}


export function packDestinationOutputOpenTelemetryTlsToHclTerraform(struct?: PackDestinationOutputOpenTelemetryTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ca_path: {
      value: cdktf.stringToHclTerraform(struct!.caPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    cert_path: {
      value: cdktf.stringToHclTerraform(struct!.certPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    certificate_name: {
      value: cdktf.stringToHclTerraform(struct!.certificateName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    max_version: {
      value: cdktf.stringToHclTerraform(struct!.maxVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    min_version: {
      value: cdktf.stringToHclTerraform(struct!.minVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    passphrase: {
      value: cdktf.stringToHclTerraform(struct!.passphrase),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    priv_key_path: {
      value: cdktf.stringToHclTerraform(struct!.privKeyPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reject_unauthorized: {
      value: cdktf.booleanToHclTerraform(struct!.rejectUnauthorized),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputOpenTelemetryTlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackDestinationOutputOpenTelemetryTls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._caPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.caPath = this._caPath;
    }
    if (this._certPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.certPath = this._certPath;
    }
    if (this._certificateName !== undefined) {
      hasAnyValues = true;
      internalValueResult.certificateName = this._certificateName;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._maxVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxVersion = this._maxVersion;
    }
    if (this._minVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.minVersion = this._minVersion;
    }
    if (this._passphrase !== undefined) {
      hasAnyValues = true;
      internalValueResult.passphrase = this._passphrase;
    }
    if (this._privKeyPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.privKeyPath = this._privKeyPath;
    }
    if (this._rejectUnauthorized !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectUnauthorized = this._rejectUnauthorized;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputOpenTelemetryTls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._caPath = undefined;
      this._certPath = undefined;
      this._certificateName = undefined;
      this._disabled = undefined;
      this._maxVersion = undefined;
      this._minVersion = undefined;
      this._passphrase = undefined;
      this._privKeyPath = undefined;
      this._rejectUnauthorized = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._caPath = value.caPath;
      this._certPath = value.certPath;
      this._certificateName = value.certificateName;
      this._disabled = value.disabled;
      this._maxVersion = value.maxVersion;
      this._minVersion = value.minVersion;
      this._passphrase = value.passphrase;
      this._privKeyPath = value.privKeyPath;
      this._rejectUnauthorized = value.rejectUnauthorized;
    }
  }

  // ca_path - computed: false, optional: true, required: false
  private _caPath?: string; 
  public get caPath() {
    return this.getStringAttribute('ca_path');
  }
  public set caPath(value: string) {
    this._caPath = value;
  }
  public resetCaPath() {
    this._caPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get caPathInput() {
    return this._caPath;
  }

  // cert_path - computed: false, optional: true, required: false
  private _certPath?: string; 
  public get certPath() {
    return this.getStringAttribute('cert_path');
  }
  public set certPath(value: string) {
    this._certPath = value;
  }
  public resetCertPath() {
    this._certPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certPathInput() {
    return this._certPath;
  }

  // certificate_name - computed: false, optional: true, required: false
  private _certificateName?: string; 
  public get certificateName() {
    return this.getStringAttribute('certificate_name');
  }
  public set certificateName(value: string) {
    this._certificateName = value;
  }
  public resetCertificateName() {
    this._certificateName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certificateNameInput() {
    return this._certificateName;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // max_version - computed: false, optional: true, required: false
  private _maxVersion?: string; 
  public get maxVersion() {
    return this.getStringAttribute('max_version');
  }
  public set maxVersion(value: string) {
    this._maxVersion = value;
  }
  public resetMaxVersion() {
    this._maxVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxVersionInput() {
    return this._maxVersion;
  }

  // min_version - computed: false, optional: true, required: false
  private _minVersion?: string; 
  public get minVersion() {
    return this.getStringAttribute('min_version');
  }
  public set minVersion(value: string) {
    this._minVersion = value;
  }
  public resetMinVersion() {
    this._minVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get minVersionInput() {
    return this._minVersion;
  }

  // passphrase - computed: false, optional: true, required: false
  private _passphrase?: string; 
  public get passphrase() {
    return this.getStringAttribute('passphrase');
  }
  public set passphrase(value: string) {
    this._passphrase = value;
  }
  public resetPassphrase() {
    this._passphrase = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passphraseInput() {
    return this._passphrase;
  }

  // priv_key_path - computed: false, optional: true, required: false
  private _privKeyPath?: string; 
  public get privKeyPath() {
    return this.getStringAttribute('priv_key_path');
  }
  public set privKeyPath(value: string) {
    this._privKeyPath = value;
  }
  public resetPrivKeyPath() {
    this._privKeyPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get privKeyPathInput() {
    return this._privKeyPath;
  }

  // reject_unauthorized - computed: true, optional: true, required: false
  private _rejectUnauthorized?: boolean | cdktf.IResolvable; 
  public get rejectUnauthorized() {
    return this.getBooleanAttribute('reject_unauthorized');
  }
  public set rejectUnauthorized(value: boolean | cdktf.IResolvable) {
    this._rejectUnauthorized = value;
  }
  public resetRejectUnauthorized() {
    this._rejectUnauthorized = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectUnauthorizedInput() {
    return this._rejectUnauthorized;
  }
}
export interface PackDestinationOutputOpenTelemetry {
  /**
  * JavaScript expression to compute the Authorization header value to pass in requests. The value `${token}` is used to reference the token obtained from authentication, e.g.: `Bearer ${token}`. Default: "`Bearer ${token}`"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#auth_header_expr PackDestination#auth_header_expr}
  */
  readonly authHeaderExpr?: string;
  /**
  * OpenTelemetry authentication type. Default: "none"; must be one of ["none", "basic", "credentialsSecret", "token", "textSecret", "oauth"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#auth_type PackDestination#auth_type}
  */
  readonly authType?: string;
  /**
  * Type of compression to apply to messages sent to the OpenTelemetry endpoint. Default: "gzip"; must be one of ["none", "deflate", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#compress PackDestination#compress}
  */
  readonly compress?: string;
  /**
  * Maximum number of ongoing requests before blocking. Default: 5
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#concurrency PackDestination#concurrency}
  */
  readonly concurrency?: number;
  /**
  * Amount of time (milliseconds) to wait for the connection to establish before retrying. Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#connection_timeout PackDestination#connection_timeout}
  */
  readonly connectionTimeout?: number;
  /**
  * Select or create a secret that references your credentials
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#credentials_secret PackDestination#credentials_secret}
  */
  readonly credentialsSecret?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#description PackDestination#description}
  */
  readonly description?: string;
  /**
  * The endpoint where OTel events will be sent. Enter any valid URL or an IP address (IPv4 or IPv6; enclose IPv6 addresses in square brackets). Unspecified ports will default to 4317, unless the endpoint is an HTTPS-based URL or TLS is enabled, in which case 443 will be used.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#endpoint PackDestination#endpoint}
  */
  readonly endpoint: string;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#environment PackDestination#environment}
  */
  readonly environment?: string;
  /**
  * Headers to add to all events
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#extra_http_headers PackDestination#extra_http_headers}
  */
  readonly extraHttpHeaders?: PackDestinationOutputOpenTelemetryExtraHttpHeaders[] | cdktf.IResolvable;
  /**
  * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below. Default: "none"; must be one of ["payload", "payloadAndHeaders", "none"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#failed_request_logging_mode PackDestination#failed_request_logging_mode}
  */
  readonly failedRequestLoggingMode?: string;
  /**
  * Maximum time between requests. Small values could cause the payload size to be smaller than the configured Body size limit. Default: 1
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#flush_period_sec PackDestination#flush_period_sec}
  */
  readonly flushPeriodSec?: number;
  /**
  * Type of compression to apply to messages sent to the OpenTelemetry endpoint. Default: "gzip"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#http_compress PackDestination#http_compress}
  */
  readonly httpCompress?: string;
  /**
  * If you want to send logs to the default `{endpoint}/v1/logs` endpoint, leave this field empty; otherwise, specify the desired endpoint
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#http_logs_endpoint_override PackDestination#http_logs_endpoint_override}
  */
  readonly httpLogsEndpointOverride?: string;
  /**
  * If you want to send metrics to the default `{endpoint}/v1/metrics` endpoint, leave this field empty; otherwise, specify the desired endpoint
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#http_metrics_endpoint_override PackDestination#http_metrics_endpoint_override}
  */
  readonly httpMetricsEndpointOverride?: string;
  /**
  * If you want to send traces to the default `{endpoint}/v1/traces` endpoint, leave this field empty; otherwise, specify the desired endpoint
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#http_traces_endpoint_override PackDestination#http_traces_endpoint_override}
  */
  readonly httpTracesEndpointOverride?: string;
  /**
  * Unique ID for this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#id PackDestination#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * Disable to close the connection immediately after sending the outgoing request. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#keep_alive PackDestination#keep_alive}
  */
  readonly keepAlive?: boolean | cdktf.IResolvable;
  /**
  * How often the sender should ping the peer to keep the connection open. Default: 30
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#keep_alive_time PackDestination#keep_alive_time}
  */
  readonly keepAliveTime?: number;
  /**
  * URL for OAuth
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#login_url PackDestination#login_url}
  */
  readonly loginUrl?: string;
  /**
  * Maximum size, in KB, of the request body. Default: 4096
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_payload_size_kb PackDestination#max_payload_size_kb}
  */
  readonly maxPayloadSizeKb?: number;
  /**
  * List of key-value pairs to send with each gRPC request. Value supports JavaScript expressions that are evaluated just once, when the destination gets started. To pass credentials as metadata, use 'C.Secret'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#metadata PackDestination#metadata}
  */
  readonly metadata?: PackDestinationOutputOpenTelemetryMetadata[] | cdktf.IResolvable;
  /**
  * Additional headers to send in the OAuth login request. @{product} will automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#oauth_headers PackDestination#oauth_headers}
  */
  readonly oauthHeaders?: PackDestinationOutputOpenTelemetryOauthHeaders[] | cdktf.IResolvable;
  /**
  * Additional parameters to send in the OAuth login request. @{product} will combine the secret with these parameters, and will send the URL-encoded result in a POST request to the endpoint specified in the 'Login URL'. We'll automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#oauth_params PackDestination#oauth_params}
  */
  readonly oauthParams?: PackDestinationOutputOpenTelemetryOauthParams[] | cdktf.IResolvable;
  /**
  * How to handle events when all receivers are exerting backpressure. Default: "block"; must be one of ["block", "drop", "queue"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#on_backpressure PackDestination#on_backpressure}
  */
  readonly onBackpressure?: string;
  /**
  * The version of OTLP Protobuf definitions to use when structuring data to send. Default: "0.10.0"; must be one of ["0.10.0", "1.3.1"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#otlp_version PackDestination#otlp_version}
  */
  readonly otlpVersion?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#password PackDestination#password}
  */
  readonly password?: string;
  /**
  * Pipeline to process data before sending out to this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pipeline PackDestination#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_compress PackDestination#pq_compress}
  */
  readonly pqCompress?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_controls PackDestination#pq_controls}
  */
  readonly pqControls?: PackDestinationOutputOpenTelemetryPqControls;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.). Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_max_file_size PackDestination#pq_max_file_size}
  */
  readonly pqMaxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_max_size PackDestination#pq_max_size}
  */
  readonly pqMaxSize?: string;
  /**
  * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem. Default: "error"; must be one of ["error", "backpressure", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_mode PackDestination#pq_mode}
  */
  readonly pqMode?: string;
  /**
  * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged. Default: "block"; must be one of ["block", "drop"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_on_backpressure PackDestination#pq_on_backpressure}
  */
  readonly pqOnBackpressure?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_path PackDestination#pq_path}
  */
  readonly pqPath?: string;
  /**
  * Select a transport option for OpenTelemetry. Default: "grpc"; must be one of ["grpc", "http"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#protocol PackDestination#protocol}
  */
  readonly protocol?: string;
  /**
  * Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's).
  * 
  * 
  *         Enabled by default. When this setting is also present in TLS Settings (Client Side),
  *         that value will take precedence.
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#reject_unauthorized PackDestination#reject_unauthorized}
  */
  readonly rejectUnauthorized?: boolean | cdktf.IResolvable;
  /**
  * Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#response_honor_retry_after_header PackDestination#response_honor_retry_after_header}
  */
  readonly responseHonorRetryAfterHeader?: boolean | cdktf.IResolvable;
  /**
  * Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#response_retry_settings PackDestination#response_retry_settings}
  */
  readonly responseRetrySettings?: PackDestinationOutputOpenTelemetryResponseRetrySettings[] | cdktf.IResolvable;
  /**
  * List of headers that are safe to log in plain text. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#safe_headers PackDestination#safe_headers}
  */
  readonly safeHeaders?: string[];
  /**
  * Secret parameter value to pass in request body
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#secret PackDestination#secret}
  */
  readonly secret?: string;
  /**
  * Secret parameter name to pass in request body
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#secret_param_name PackDestination#secret_param_name}
  */
  readonly secretParamName?: string;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#streamtags PackDestination#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Fields to automatically add to events, such as cribl_pipe. Supports wildcards. Default: ["cribl_pipe"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#system_fields PackDestination#system_fields}
  */
  readonly systemFields?: string[];
  /**
  * Select or create a stored text secret
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#text_secret PackDestination#text_secret}
  */
  readonly textSecret?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#timeout_retry_settings PackDestination#timeout_retry_settings}
  */
  readonly timeoutRetrySettings?: PackDestinationOutputOpenTelemetryTimeoutRetrySettings;
  /**
  * Amount of time, in seconds, to wait for a request to complete before canceling it. Default: 30
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#timeout_sec PackDestination#timeout_sec}
  */
  readonly timeoutSec?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#tls PackDestination#tls}
  */
  readonly tls?: PackDestinationOutputOpenTelemetryTls;
  /**
  * Bearer token to include in the authorization header
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#token PackDestination#token}
  */
  readonly token?: string;
  /**
  * Name of the auth token attribute in the OAuth response. Can be top-level (e.g., 'token'); or nested, using a period (e.g., 'data.token').
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#token_attribute_name PackDestination#token_attribute_name}
  */
  readonly tokenAttributeName?: string;
  /**
  * How often the OAuth token should be refreshed. Default: 3600
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#token_timeout_secs PackDestination#token_timeout_secs}
  */
  readonly tokenTimeoutSecs?: number;
  /**
  * must be "open_telemetry"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#type PackDestination#type}
  */
  readonly type: string;
  /**
  * Enable round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. For optimal performance, consider enabling this setting for non-load balanced destinations. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#use_round_robin_dns PackDestination#use_round_robin_dns}
  */
  readonly useRoundRobinDns?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#username PackDestination#username}
  */
  readonly username?: string;
}

export function packDestinationOutputOpenTelemetryToTerraform(struct?: PackDestinationOutputOpenTelemetry | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    auth_header_expr: cdktf.stringToTerraform(struct!.authHeaderExpr),
    auth_type: cdktf.stringToTerraform(struct!.authType),
    compress: cdktf.stringToTerraform(struct!.compress),
    concurrency: cdktf.numberToTerraform(struct!.concurrency),
    connection_timeout: cdktf.numberToTerraform(struct!.connectionTimeout),
    credentials_secret: cdktf.stringToTerraform(struct!.credentialsSecret),
    description: cdktf.stringToTerraform(struct!.description),
    endpoint: cdktf.stringToTerraform(struct!.endpoint),
    environment: cdktf.stringToTerraform(struct!.environment),
    extra_http_headers: cdktf.listMapper(packDestinationOutputOpenTelemetryExtraHttpHeadersToTerraform, false)(struct!.extraHttpHeaders),
    failed_request_logging_mode: cdktf.stringToTerraform(struct!.failedRequestLoggingMode),
    flush_period_sec: cdktf.numberToTerraform(struct!.flushPeriodSec),
    http_compress: cdktf.stringToTerraform(struct!.httpCompress),
    http_logs_endpoint_override: cdktf.stringToTerraform(struct!.httpLogsEndpointOverride),
    http_metrics_endpoint_override: cdktf.stringToTerraform(struct!.httpMetricsEndpointOverride),
    http_traces_endpoint_override: cdktf.stringToTerraform(struct!.httpTracesEndpointOverride),
    id: cdktf.stringToTerraform(struct!.id),
    keep_alive: cdktf.booleanToTerraform(struct!.keepAlive),
    keep_alive_time: cdktf.numberToTerraform(struct!.keepAliveTime),
    login_url: cdktf.stringToTerraform(struct!.loginUrl),
    max_payload_size_kb: cdktf.numberToTerraform(struct!.maxPayloadSizeKb),
    metadata: cdktf.listMapper(packDestinationOutputOpenTelemetryMetadataToTerraform, false)(struct!.metadata),
    oauth_headers: cdktf.listMapper(packDestinationOutputOpenTelemetryOauthHeadersToTerraform, false)(struct!.oauthHeaders),
    oauth_params: cdktf.listMapper(packDestinationOutputOpenTelemetryOauthParamsToTerraform, false)(struct!.oauthParams),
    on_backpressure: cdktf.stringToTerraform(struct!.onBackpressure),
    otlp_version: cdktf.stringToTerraform(struct!.otlpVersion),
    password: cdktf.stringToTerraform(struct!.password),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    pq_compress: cdktf.stringToTerraform(struct!.pqCompress),
    pq_controls: packDestinationOutputOpenTelemetryPqControlsToTerraform(struct!.pqControls),
    pq_max_file_size: cdktf.stringToTerraform(struct!.pqMaxFileSize),
    pq_max_size: cdktf.stringToTerraform(struct!.pqMaxSize),
    pq_mode: cdktf.stringToTerraform(struct!.pqMode),
    pq_on_backpressure: cdktf.stringToTerraform(struct!.pqOnBackpressure),
    pq_path: cdktf.stringToTerraform(struct!.pqPath),
    protocol: cdktf.stringToTerraform(struct!.protocol),
    reject_unauthorized: cdktf.booleanToTerraform(struct!.rejectUnauthorized),
    response_honor_retry_after_header: cdktf.booleanToTerraform(struct!.responseHonorRetryAfterHeader),
    response_retry_settings: cdktf.listMapper(packDestinationOutputOpenTelemetryResponseRetrySettingsToTerraform, false)(struct!.responseRetrySettings),
    safe_headers: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.safeHeaders),
    secret: cdktf.stringToTerraform(struct!.secret),
    secret_param_name: cdktf.stringToTerraform(struct!.secretParamName),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    system_fields: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.systemFields),
    text_secret: cdktf.stringToTerraform(struct!.textSecret),
    timeout_retry_settings: packDestinationOutputOpenTelemetryTimeoutRetrySettingsToTerraform(struct!.timeoutRetrySettings),
    timeout_sec: cdktf.numberToTerraform(struct!.timeoutSec),
    tls: packDestinationOutputOpenTelemetryTlsToTerraform(struct!.tls),
    token: cdktf.stringToTerraform(struct!.token),
    token_attribute_name: cdktf.stringToTerraform(struct!.tokenAttributeName),
    token_timeout_secs: cdktf.numberToTerraform(struct!.tokenTimeoutSecs),
    type: cdktf.stringToTerraform(struct!.type),
    use_round_robin_dns: cdktf.booleanToTerraform(struct!.useRoundRobinDns),
    username: cdktf.stringToTerraform(struct!.username),
  }
}


export function packDestinationOutputOpenTelemetryToHclTerraform(struct?: PackDestinationOutputOpenTelemetry | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    auth_header_expr: {
      value: cdktf.stringToHclTerraform(struct!.authHeaderExpr),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    auth_type: {
      value: cdktf.stringToHclTerraform(struct!.authType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    compress: {
      value: cdktf.stringToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    concurrency: {
      value: cdktf.numberToHclTerraform(struct!.concurrency),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    connection_timeout: {
      value: cdktf.numberToHclTerraform(struct!.connectionTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    credentials_secret: {
      value: cdktf.stringToHclTerraform(struct!.credentialsSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    endpoint: {
      value: cdktf.stringToHclTerraform(struct!.endpoint),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    extra_http_headers: {
      value: cdktf.listMapperHcl(packDestinationOutputOpenTelemetryExtraHttpHeadersToHclTerraform, false)(struct!.extraHttpHeaders),
      isBlock: true,
      type: "list",
      storageClassType: "PackDestinationOutputOpenTelemetryExtraHttpHeadersList",
    },
    failed_request_logging_mode: {
      value: cdktf.stringToHclTerraform(struct!.failedRequestLoggingMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    flush_period_sec: {
      value: cdktf.numberToHclTerraform(struct!.flushPeriodSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    http_compress: {
      value: cdktf.stringToHclTerraform(struct!.httpCompress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    http_logs_endpoint_override: {
      value: cdktf.stringToHclTerraform(struct!.httpLogsEndpointOverride),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    http_metrics_endpoint_override: {
      value: cdktf.stringToHclTerraform(struct!.httpMetricsEndpointOverride),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    http_traces_endpoint_override: {
      value: cdktf.stringToHclTerraform(struct!.httpTracesEndpointOverride),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    keep_alive: {
      value: cdktf.booleanToHclTerraform(struct!.keepAlive),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    keep_alive_time: {
      value: cdktf.numberToHclTerraform(struct!.keepAliveTime),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    login_url: {
      value: cdktf.stringToHclTerraform(struct!.loginUrl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_payload_size_kb: {
      value: cdktf.numberToHclTerraform(struct!.maxPayloadSizeKb),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    metadata: {
      value: cdktf.listMapperHcl(packDestinationOutputOpenTelemetryMetadataToHclTerraform, false)(struct!.metadata),
      isBlock: true,
      type: "list",
      storageClassType: "PackDestinationOutputOpenTelemetryMetadataList",
    },
    oauth_headers: {
      value: cdktf.listMapperHcl(packDestinationOutputOpenTelemetryOauthHeadersToHclTerraform, false)(struct!.oauthHeaders),
      isBlock: true,
      type: "list",
      storageClassType: "PackDestinationOutputOpenTelemetryOauthHeadersList",
    },
    oauth_params: {
      value: cdktf.listMapperHcl(packDestinationOutputOpenTelemetryOauthParamsToHclTerraform, false)(struct!.oauthParams),
      isBlock: true,
      type: "list",
      storageClassType: "PackDestinationOutputOpenTelemetryOauthParamsList",
    },
    on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.onBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    otlp_version: {
      value: cdktf.stringToHclTerraform(struct!.otlpVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    password: {
      value: cdktf.stringToHclTerraform(struct!.password),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_compress: {
      value: cdktf.stringToHclTerraform(struct!.pqCompress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_controls: {
      value: packDestinationOutputOpenTelemetryPqControlsToHclTerraform(struct!.pqControls),
      isBlock: true,
      type: "struct",
      storageClassType: "PackDestinationOutputOpenTelemetryPqControls",
    },
    pq_max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_max_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_mode: {
      value: cdktf.stringToHclTerraform(struct!.pqMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.pqOnBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_path: {
      value: cdktf.stringToHclTerraform(struct!.pqPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    protocol: {
      value: cdktf.stringToHclTerraform(struct!.protocol),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reject_unauthorized: {
      value: cdktf.booleanToHclTerraform(struct!.rejectUnauthorized),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    response_honor_retry_after_header: {
      value: cdktf.booleanToHclTerraform(struct!.responseHonorRetryAfterHeader),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    response_retry_settings: {
      value: cdktf.listMapperHcl(packDestinationOutputOpenTelemetryResponseRetrySettingsToHclTerraform, false)(struct!.responseRetrySettings),
      isBlock: true,
      type: "list",
      storageClassType: "PackDestinationOutputOpenTelemetryResponseRetrySettingsList",
    },
    safe_headers: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.safeHeaders),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    secret: {
      value: cdktf.stringToHclTerraform(struct!.secret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_param_name: {
      value: cdktf.stringToHclTerraform(struct!.secretParamName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    system_fields: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.systemFields),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    text_secret: {
      value: cdktf.stringToHclTerraform(struct!.textSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    timeout_retry_settings: {
      value: packDestinationOutputOpenTelemetryTimeoutRetrySettingsToHclTerraform(struct!.timeoutRetrySettings),
      isBlock: true,
      type: "struct",
      storageClassType: "PackDestinationOutputOpenTelemetryTimeoutRetrySettings",
    },
    timeout_sec: {
      value: cdktf.numberToHclTerraform(struct!.timeoutSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    tls: {
      value: packDestinationOutputOpenTelemetryTlsToHclTerraform(struct!.tls),
      isBlock: true,
      type: "struct",
      storageClassType: "PackDestinationOutputOpenTelemetryTls",
    },
    token: {
      value: cdktf.stringToHclTerraform(struct!.token),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    token_attribute_name: {
      value: cdktf.stringToHclTerraform(struct!.tokenAttributeName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    token_timeout_secs: {
      value: cdktf.numberToHclTerraform(struct!.tokenTimeoutSecs),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    use_round_robin_dns: {
      value: cdktf.booleanToHclTerraform(struct!.useRoundRobinDns),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    username: {
      value: cdktf.stringToHclTerraform(struct!.username),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputOpenTelemetryOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackDestinationOutputOpenTelemetry | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._authHeaderExpr !== undefined) {
      hasAnyValues = true;
      internalValueResult.authHeaderExpr = this._authHeaderExpr;
    }
    if (this._authType !== undefined) {
      hasAnyValues = true;
      internalValueResult.authType = this._authType;
    }
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._concurrency !== undefined) {
      hasAnyValues = true;
      internalValueResult.concurrency = this._concurrency;
    }
    if (this._connectionTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.connectionTimeout = this._connectionTimeout;
    }
    if (this._credentialsSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.credentialsSecret = this._credentialsSecret;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._endpoint !== undefined) {
      hasAnyValues = true;
      internalValueResult.endpoint = this._endpoint;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._extraHttpHeaders?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.extraHttpHeaders = this._extraHttpHeaders?.internalValue;
    }
    if (this._failedRequestLoggingMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.failedRequestLoggingMode = this._failedRequestLoggingMode;
    }
    if (this._flushPeriodSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.flushPeriodSec = this._flushPeriodSec;
    }
    if (this._httpCompress !== undefined) {
      hasAnyValues = true;
      internalValueResult.httpCompress = this._httpCompress;
    }
    if (this._httpLogsEndpointOverride !== undefined) {
      hasAnyValues = true;
      internalValueResult.httpLogsEndpointOverride = this._httpLogsEndpointOverride;
    }
    if (this._httpMetricsEndpointOverride !== undefined) {
      hasAnyValues = true;
      internalValueResult.httpMetricsEndpointOverride = this._httpMetricsEndpointOverride;
    }
    if (this._httpTracesEndpointOverride !== undefined) {
      hasAnyValues = true;
      internalValueResult.httpTracesEndpointOverride = this._httpTracesEndpointOverride;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._keepAlive !== undefined) {
      hasAnyValues = true;
      internalValueResult.keepAlive = this._keepAlive;
    }
    if (this._keepAliveTime !== undefined) {
      hasAnyValues = true;
      internalValueResult.keepAliveTime = this._keepAliveTime;
    }
    if (this._loginUrl !== undefined) {
      hasAnyValues = true;
      internalValueResult.loginUrl = this._loginUrl;
    }
    if (this._maxPayloadSizeKb !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxPayloadSizeKb = this._maxPayloadSizeKb;
    }
    if (this._metadata?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadata = this._metadata?.internalValue;
    }
    if (this._oauthHeaders?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.oauthHeaders = this._oauthHeaders?.internalValue;
    }
    if (this._oauthParams?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.oauthParams = this._oauthParams?.internalValue;
    }
    if (this._onBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.onBackpressure = this._onBackpressure;
    }
    if (this._otlpVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.otlpVersion = this._otlpVersion;
    }
    if (this._password !== undefined) {
      hasAnyValues = true;
      internalValueResult.password = this._password;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._pqCompress !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqCompress = this._pqCompress;
    }
    if (this._pqControls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqControls = this._pqControls?.internalValue;
    }
    if (this._pqMaxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxFileSize = this._pqMaxFileSize;
    }
    if (this._pqMaxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxSize = this._pqMaxSize;
    }
    if (this._pqMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMode = this._pqMode;
    }
    if (this._pqOnBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqOnBackpressure = this._pqOnBackpressure;
    }
    if (this._pqPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqPath = this._pqPath;
    }
    if (this._protocol !== undefined) {
      hasAnyValues = true;
      internalValueResult.protocol = this._protocol;
    }
    if (this._rejectUnauthorized !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectUnauthorized = this._rejectUnauthorized;
    }
    if (this._responseHonorRetryAfterHeader !== undefined) {
      hasAnyValues = true;
      internalValueResult.responseHonorRetryAfterHeader = this._responseHonorRetryAfterHeader;
    }
    if (this._responseRetrySettings?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.responseRetrySettings = this._responseRetrySettings?.internalValue;
    }
    if (this._safeHeaders !== undefined) {
      hasAnyValues = true;
      internalValueResult.safeHeaders = this._safeHeaders;
    }
    if (this._secret !== undefined) {
      hasAnyValues = true;
      internalValueResult.secret = this._secret;
    }
    if (this._secretParamName !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretParamName = this._secretParamName;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._systemFields !== undefined) {
      hasAnyValues = true;
      internalValueResult.systemFields = this._systemFields;
    }
    if (this._textSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.textSecret = this._textSecret;
    }
    if (this._timeoutRetrySettings?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutRetrySettings = this._timeoutRetrySettings?.internalValue;
    }
    if (this._timeoutSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutSec = this._timeoutSec;
    }
    if (this._tls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tls = this._tls?.internalValue;
    }
    if (this._token !== undefined) {
      hasAnyValues = true;
      internalValueResult.token = this._token;
    }
    if (this._tokenAttributeName !== undefined) {
      hasAnyValues = true;
      internalValueResult.tokenAttributeName = this._tokenAttributeName;
    }
    if (this._tokenTimeoutSecs !== undefined) {
      hasAnyValues = true;
      internalValueResult.tokenTimeoutSecs = this._tokenTimeoutSecs;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._useRoundRobinDns !== undefined) {
      hasAnyValues = true;
      internalValueResult.useRoundRobinDns = this._useRoundRobinDns;
    }
    if (this._username !== undefined) {
      hasAnyValues = true;
      internalValueResult.username = this._username;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputOpenTelemetry | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._authHeaderExpr = undefined;
      this._authType = undefined;
      this._compress = undefined;
      this._concurrency = undefined;
      this._connectionTimeout = undefined;
      this._credentialsSecret = undefined;
      this._description = undefined;
      this._endpoint = undefined;
      this._environment = undefined;
      this._extraHttpHeaders.internalValue = undefined;
      this._failedRequestLoggingMode = undefined;
      this._flushPeriodSec = undefined;
      this._httpCompress = undefined;
      this._httpLogsEndpointOverride = undefined;
      this._httpMetricsEndpointOverride = undefined;
      this._httpTracesEndpointOverride = undefined;
      this._id = undefined;
      this._keepAlive = undefined;
      this._keepAliveTime = undefined;
      this._loginUrl = undefined;
      this._maxPayloadSizeKb = undefined;
      this._metadata.internalValue = undefined;
      this._oauthHeaders.internalValue = undefined;
      this._oauthParams.internalValue = undefined;
      this._onBackpressure = undefined;
      this._otlpVersion = undefined;
      this._password = undefined;
      this._pipeline = undefined;
      this._pqCompress = undefined;
      this._pqControls.internalValue = undefined;
      this._pqMaxFileSize = undefined;
      this._pqMaxSize = undefined;
      this._pqMode = undefined;
      this._pqOnBackpressure = undefined;
      this._pqPath = undefined;
      this._protocol = undefined;
      this._rejectUnauthorized = undefined;
      this._responseHonorRetryAfterHeader = undefined;
      this._responseRetrySettings.internalValue = undefined;
      this._safeHeaders = undefined;
      this._secret = undefined;
      this._secretParamName = undefined;
      this._streamtags = undefined;
      this._systemFields = undefined;
      this._textSecret = undefined;
      this._timeoutRetrySettings.internalValue = undefined;
      this._timeoutSec = undefined;
      this._tls.internalValue = undefined;
      this._token = undefined;
      this._tokenAttributeName = undefined;
      this._tokenTimeoutSecs = undefined;
      this._type = undefined;
      this._useRoundRobinDns = undefined;
      this._username = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._authHeaderExpr = value.authHeaderExpr;
      this._authType = value.authType;
      this._compress = value.compress;
      this._concurrency = value.concurrency;
      this._connectionTimeout = value.connectionTimeout;
      this._credentialsSecret = value.credentialsSecret;
      this._description = value.description;
      this._endpoint = value.endpoint;
      this._environment = value.environment;
      this._extraHttpHeaders.internalValue = value.extraHttpHeaders;
      this._failedRequestLoggingMode = value.failedRequestLoggingMode;
      this._flushPeriodSec = value.flushPeriodSec;
      this._httpCompress = value.httpCompress;
      this._httpLogsEndpointOverride = value.httpLogsEndpointOverride;
      this._httpMetricsEndpointOverride = value.httpMetricsEndpointOverride;
      this._httpTracesEndpointOverride = value.httpTracesEndpointOverride;
      this._id = value.id;
      this._keepAlive = value.keepAlive;
      this._keepAliveTime = value.keepAliveTime;
      this._loginUrl = value.loginUrl;
      this._maxPayloadSizeKb = value.maxPayloadSizeKb;
      this._metadata.internalValue = value.metadata;
      this._oauthHeaders.internalValue = value.oauthHeaders;
      this._oauthParams.internalValue = value.oauthParams;
      this._onBackpressure = value.onBackpressure;
      this._otlpVersion = value.otlpVersion;
      this._password = value.password;
      this._pipeline = value.pipeline;
      this._pqCompress = value.pqCompress;
      this._pqControls.internalValue = value.pqControls;
      this._pqMaxFileSize = value.pqMaxFileSize;
      this._pqMaxSize = value.pqMaxSize;
      this._pqMode = value.pqMode;
      this._pqOnBackpressure = value.pqOnBackpressure;
      this._pqPath = value.pqPath;
      this._protocol = value.protocol;
      this._rejectUnauthorized = value.rejectUnauthorized;
      this._responseHonorRetryAfterHeader = value.responseHonorRetryAfterHeader;
      this._responseRetrySettings.internalValue = value.responseRetrySettings;
      this._safeHeaders = value.safeHeaders;
      this._secret = value.secret;
      this._secretParamName = value.secretParamName;
      this._streamtags = value.streamtags;
      this._systemFields = value.systemFields;
      this._textSecret = value.textSecret;
      this._timeoutRetrySettings.internalValue = value.timeoutRetrySettings;
      this._timeoutSec = value.timeoutSec;
      this._tls.internalValue = value.tls;
      this._token = value.token;
      this._tokenAttributeName = value.tokenAttributeName;
      this._tokenTimeoutSecs = value.tokenTimeoutSecs;
      this._type = value.type;
      this._useRoundRobinDns = value.useRoundRobinDns;
      this._username = value.username;
    }
  }

  // auth_header_expr - computed: true, optional: true, required: false
  private _authHeaderExpr?: string; 
  public get authHeaderExpr() {
    return this.getStringAttribute('auth_header_expr');
  }
  public set authHeaderExpr(value: string) {
    this._authHeaderExpr = value;
  }
  public resetAuthHeaderExpr() {
    this._authHeaderExpr = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authHeaderExprInput() {
    return this._authHeaderExpr;
  }

  // auth_type - computed: true, optional: true, required: false
  private _authType?: string; 
  public get authType() {
    return this.getStringAttribute('auth_type');
  }
  public set authType(value: string) {
    this._authType = value;
  }
  public resetAuthType() {
    this._authType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authTypeInput() {
    return this._authType;
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: string; 
  public get compress() {
    return this.getStringAttribute('compress');
  }
  public set compress(value: string) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // concurrency - computed: true, optional: true, required: false
  private _concurrency?: number; 
  public get concurrency() {
    return this.getNumberAttribute('concurrency');
  }
  public set concurrency(value: number) {
    this._concurrency = value;
  }
  public resetConcurrency() {
    this._concurrency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get concurrencyInput() {
    return this._concurrency;
  }

  // connection_timeout - computed: true, optional: true, required: false
  private _connectionTimeout?: number; 
  public get connectionTimeout() {
    return this.getNumberAttribute('connection_timeout');
  }
  public set connectionTimeout(value: number) {
    this._connectionTimeout = value;
  }
  public resetConnectionTimeout() {
    this._connectionTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectionTimeoutInput() {
    return this._connectionTimeout;
  }

  // credentials_secret - computed: false, optional: true, required: false
  private _credentialsSecret?: string; 
  public get credentialsSecret() {
    return this.getStringAttribute('credentials_secret');
  }
  public set credentialsSecret(value: string) {
    this._credentialsSecret = value;
  }
  public resetCredentialsSecret() {
    this._credentialsSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get credentialsSecretInput() {
    return this._credentialsSecret;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // endpoint - computed: false, optional: false, required: true
  private _endpoint?: string; 
  public get endpoint() {
    return this.getStringAttribute('endpoint');
  }
  public set endpoint(value: string) {
    this._endpoint = value;
  }
  // Temporarily expose input value. Use with caution.
  public get endpointInput() {
    return this._endpoint;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // extra_http_headers - computed: false, optional: true, required: false
  private _extraHttpHeaders = new PackDestinationOutputOpenTelemetryExtraHttpHeadersList(this, "extra_http_headers", false);
  public get extraHttpHeaders() {
    return this._extraHttpHeaders;
  }
  public putExtraHttpHeaders(value: PackDestinationOutputOpenTelemetryExtraHttpHeaders[] | cdktf.IResolvable) {
    this._extraHttpHeaders.internalValue = value;
  }
  public resetExtraHttpHeaders() {
    this._extraHttpHeaders.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get extraHttpHeadersInput() {
    return this._extraHttpHeaders.internalValue;
  }

  // failed_request_logging_mode - computed: true, optional: true, required: false
  private _failedRequestLoggingMode?: string; 
  public get failedRequestLoggingMode() {
    return this.getStringAttribute('failed_request_logging_mode');
  }
  public set failedRequestLoggingMode(value: string) {
    this._failedRequestLoggingMode = value;
  }
  public resetFailedRequestLoggingMode() {
    this._failedRequestLoggingMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get failedRequestLoggingModeInput() {
    return this._failedRequestLoggingMode;
  }

  // flush_period_sec - computed: true, optional: true, required: false
  private _flushPeriodSec?: number; 
  public get flushPeriodSec() {
    return this.getNumberAttribute('flush_period_sec');
  }
  public set flushPeriodSec(value: number) {
    this._flushPeriodSec = value;
  }
  public resetFlushPeriodSec() {
    this._flushPeriodSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get flushPeriodSecInput() {
    return this._flushPeriodSec;
  }

  // http_compress - computed: true, optional: true, required: false
  private _httpCompress?: string; 
  public get httpCompress() {
    return this.getStringAttribute('http_compress');
  }
  public set httpCompress(value: string) {
    this._httpCompress = value;
  }
  public resetHttpCompress() {
    this._httpCompress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get httpCompressInput() {
    return this._httpCompress;
  }

  // http_logs_endpoint_override - computed: false, optional: true, required: false
  private _httpLogsEndpointOverride?: string; 
  public get httpLogsEndpointOverride() {
    return this.getStringAttribute('http_logs_endpoint_override');
  }
  public set httpLogsEndpointOverride(value: string) {
    this._httpLogsEndpointOverride = value;
  }
  public resetHttpLogsEndpointOverride() {
    this._httpLogsEndpointOverride = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get httpLogsEndpointOverrideInput() {
    return this._httpLogsEndpointOverride;
  }

  // http_metrics_endpoint_override - computed: false, optional: true, required: false
  private _httpMetricsEndpointOverride?: string; 
  public get httpMetricsEndpointOverride() {
    return this.getStringAttribute('http_metrics_endpoint_override');
  }
  public set httpMetricsEndpointOverride(value: string) {
    this._httpMetricsEndpointOverride = value;
  }
  public resetHttpMetricsEndpointOverride() {
    this._httpMetricsEndpointOverride = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get httpMetricsEndpointOverrideInput() {
    return this._httpMetricsEndpointOverride;
  }

  // http_traces_endpoint_override - computed: false, optional: true, required: false
  private _httpTracesEndpointOverride?: string; 
  public get httpTracesEndpointOverride() {
    return this.getStringAttribute('http_traces_endpoint_override');
  }
  public set httpTracesEndpointOverride(value: string) {
    this._httpTracesEndpointOverride = value;
  }
  public resetHttpTracesEndpointOverride() {
    this._httpTracesEndpointOverride = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get httpTracesEndpointOverrideInput() {
    return this._httpTracesEndpointOverride;
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // keep_alive - computed: true, optional: true, required: false
  private _keepAlive?: boolean | cdktf.IResolvable; 
  public get keepAlive() {
    return this.getBooleanAttribute('keep_alive');
  }
  public set keepAlive(value: boolean | cdktf.IResolvable) {
    this._keepAlive = value;
  }
  public resetKeepAlive() {
    this._keepAlive = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keepAliveInput() {
    return this._keepAlive;
  }

  // keep_alive_time - computed: true, optional: true, required: false
  private _keepAliveTime?: number; 
  public get keepAliveTime() {
    return this.getNumberAttribute('keep_alive_time');
  }
  public set keepAliveTime(value: number) {
    this._keepAliveTime = value;
  }
  public resetKeepAliveTime() {
    this._keepAliveTime = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keepAliveTimeInput() {
    return this._keepAliveTime;
  }

  // login_url - computed: false, optional: true, required: false
  private _loginUrl?: string; 
  public get loginUrl() {
    return this.getStringAttribute('login_url');
  }
  public set loginUrl(value: string) {
    this._loginUrl = value;
  }
  public resetLoginUrl() {
    this._loginUrl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get loginUrlInput() {
    return this._loginUrl;
  }

  // max_payload_size_kb - computed: true, optional: true, required: false
  private _maxPayloadSizeKb?: number; 
  public get maxPayloadSizeKb() {
    return this.getNumberAttribute('max_payload_size_kb');
  }
  public set maxPayloadSizeKb(value: number) {
    this._maxPayloadSizeKb = value;
  }
  public resetMaxPayloadSizeKb() {
    this._maxPayloadSizeKb = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxPayloadSizeKbInput() {
    return this._maxPayloadSizeKb;
  }

  // metadata - computed: false, optional: true, required: false
  private _metadata = new PackDestinationOutputOpenTelemetryMetadataList(this, "metadata", false);
  public get metadata() {
    return this._metadata;
  }
  public putMetadata(value: PackDestinationOutputOpenTelemetryMetadata[] | cdktf.IResolvable) {
    this._metadata.internalValue = value;
  }
  public resetMetadata() {
    this._metadata.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataInput() {
    return this._metadata.internalValue;
  }

  // oauth_headers - computed: false, optional: true, required: false
  private _oauthHeaders = new PackDestinationOutputOpenTelemetryOauthHeadersList(this, "oauth_headers", false);
  public get oauthHeaders() {
    return this._oauthHeaders;
  }
  public putOauthHeaders(value: PackDestinationOutputOpenTelemetryOauthHeaders[] | cdktf.IResolvable) {
    this._oauthHeaders.internalValue = value;
  }
  public resetOauthHeaders() {
    this._oauthHeaders.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get oauthHeadersInput() {
    return this._oauthHeaders.internalValue;
  }

  // oauth_params - computed: false, optional: true, required: false
  private _oauthParams = new PackDestinationOutputOpenTelemetryOauthParamsList(this, "oauth_params", false);
  public get oauthParams() {
    return this._oauthParams;
  }
  public putOauthParams(value: PackDestinationOutputOpenTelemetryOauthParams[] | cdktf.IResolvable) {
    this._oauthParams.internalValue = value;
  }
  public resetOauthParams() {
    this._oauthParams.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get oauthParamsInput() {
    return this._oauthParams.internalValue;
  }

  // on_backpressure - computed: true, optional: true, required: false
  private _onBackpressure?: string; 
  public get onBackpressure() {
    return this.getStringAttribute('on_backpressure');
  }
  public set onBackpressure(value: string) {
    this._onBackpressure = value;
  }
  public resetOnBackpressure() {
    this._onBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get onBackpressureInput() {
    return this._onBackpressure;
  }

  // otlp_version - computed: true, optional: true, required: false
  private _otlpVersion?: string; 
  public get otlpVersion() {
    return this.getStringAttribute('otlp_version');
  }
  public set otlpVersion(value: string) {
    this._otlpVersion = value;
  }
  public resetOtlpVersion() {
    this._otlpVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get otlpVersionInput() {
    return this._otlpVersion;
  }

  // password - computed: false, optional: true, required: false
  private _password?: string; 
  public get password() {
    return this.getStringAttribute('password');
  }
  public set password(value: string) {
    this._password = value;
  }
  public resetPassword() {
    this._password = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passwordInput() {
    return this._password;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // pq_compress - computed: true, optional: true, required: false
  private _pqCompress?: string; 
  public get pqCompress() {
    return this.getStringAttribute('pq_compress');
  }
  public set pqCompress(value: string) {
    this._pqCompress = value;
  }
  public resetPqCompress() {
    this._pqCompress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqCompressInput() {
    return this._pqCompress;
  }

  // pq_controls - computed: false, optional: true, required: false
  private _pqControls = new PackDestinationOutputOpenTelemetryPqControlsOutputReference(this, "pq_controls");
  public get pqControls() {
    return this._pqControls;
  }
  public putPqControls(value: PackDestinationOutputOpenTelemetryPqControls) {
    this._pqControls.internalValue = value;
  }
  public resetPqControls() {
    this._pqControls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqControlsInput() {
    return this._pqControls.internalValue;
  }

  // pq_max_file_size - computed: true, optional: true, required: false
  private _pqMaxFileSize?: string; 
  public get pqMaxFileSize() {
    return this.getStringAttribute('pq_max_file_size');
  }
  public set pqMaxFileSize(value: string) {
    this._pqMaxFileSize = value;
  }
  public resetPqMaxFileSize() {
    this._pqMaxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxFileSizeInput() {
    return this._pqMaxFileSize;
  }

  // pq_max_size - computed: true, optional: true, required: false
  private _pqMaxSize?: string; 
  public get pqMaxSize() {
    return this.getStringAttribute('pq_max_size');
  }
  public set pqMaxSize(value: string) {
    this._pqMaxSize = value;
  }
  public resetPqMaxSize() {
    this._pqMaxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxSizeInput() {
    return this._pqMaxSize;
  }

  // pq_mode - computed: true, optional: true, required: false
  private _pqMode?: string; 
  public get pqMode() {
    return this.getStringAttribute('pq_mode');
  }
  public set pqMode(value: string) {
    this._pqMode = value;
  }
  public resetPqMode() {
    this._pqMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqModeInput() {
    return this._pqMode;
  }

  // pq_on_backpressure - computed: true, optional: true, required: false
  private _pqOnBackpressure?: string; 
  public get pqOnBackpressure() {
    return this.getStringAttribute('pq_on_backpressure');
  }
  public set pqOnBackpressure(value: string) {
    this._pqOnBackpressure = value;
  }
  public resetPqOnBackpressure() {
    this._pqOnBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqOnBackpressureInput() {
    return this._pqOnBackpressure;
  }

  // pq_path - computed: true, optional: true, required: false
  private _pqPath?: string; 
  public get pqPath() {
    return this.getStringAttribute('pq_path');
  }
  public set pqPath(value: string) {
    this._pqPath = value;
  }
  public resetPqPath() {
    this._pqPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqPathInput() {
    return this._pqPath;
  }

  // protocol - computed: true, optional: true, required: false
  private _protocol?: string; 
  public get protocol() {
    return this.getStringAttribute('protocol');
  }
  public set protocol(value: string) {
    this._protocol = value;
  }
  public resetProtocol() {
    this._protocol = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get protocolInput() {
    return this._protocol;
  }

  // reject_unauthorized - computed: true, optional: true, required: false
  private _rejectUnauthorized?: boolean | cdktf.IResolvable; 
  public get rejectUnauthorized() {
    return this.getBooleanAttribute('reject_unauthorized');
  }
  public set rejectUnauthorized(value: boolean | cdktf.IResolvable) {
    this._rejectUnauthorized = value;
  }
  public resetRejectUnauthorized() {
    this._rejectUnauthorized = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectUnauthorizedInput() {
    return this._rejectUnauthorized;
  }

  // response_honor_retry_after_header - computed: true, optional: true, required: false
  private _responseHonorRetryAfterHeader?: boolean | cdktf.IResolvable; 
  public get responseHonorRetryAfterHeader() {
    return this.getBooleanAttribute('response_honor_retry_after_header');
  }
  public set responseHonorRetryAfterHeader(value: boolean | cdktf.IResolvable) {
    this._responseHonorRetryAfterHeader = value;
  }
  public resetResponseHonorRetryAfterHeader() {
    this._responseHonorRetryAfterHeader = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get responseHonorRetryAfterHeaderInput() {
    return this._responseHonorRetryAfterHeader;
  }

  // response_retry_settings - computed: false, optional: true, required: false
  private _responseRetrySettings = new PackDestinationOutputOpenTelemetryResponseRetrySettingsList(this, "response_retry_settings", false);
  public get responseRetrySettings() {
    return this._responseRetrySettings;
  }
  public putResponseRetrySettings(value: PackDestinationOutputOpenTelemetryResponseRetrySettings[] | cdktf.IResolvable) {
    this._responseRetrySettings.internalValue = value;
  }
  public resetResponseRetrySettings() {
    this._responseRetrySettings.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get responseRetrySettingsInput() {
    return this._responseRetrySettings.internalValue;
  }

  // safe_headers - computed: true, optional: true, required: false
  private _safeHeaders?: string[]; 
  public get safeHeaders() {
    return this.getListAttribute('safe_headers');
  }
  public set safeHeaders(value: string[]) {
    this._safeHeaders = value;
  }
  public resetSafeHeaders() {
    this._safeHeaders = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get safeHeadersInput() {
    return this._safeHeaders;
  }

  // secret - computed: false, optional: true, required: false
  private _secret?: string; 
  public get secret() {
    return this.getStringAttribute('secret');
  }
  public set secret(value: string) {
    this._secret = value;
  }
  public resetSecret() {
    this._secret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretInput() {
    return this._secret;
  }

  // secret_param_name - computed: false, optional: true, required: false
  private _secretParamName?: string; 
  public get secretParamName() {
    return this.getStringAttribute('secret_param_name');
  }
  public set secretParamName(value: string) {
    this._secretParamName = value;
  }
  public resetSecretParamName() {
    this._secretParamName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretParamNameInput() {
    return this._secretParamName;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // system_fields - computed: true, optional: true, required: false
  private _systemFields?: string[]; 
  public get systemFields() {
    return this.getListAttribute('system_fields');
  }
  public set systemFields(value: string[]) {
    this._systemFields = value;
  }
  public resetSystemFields() {
    this._systemFields = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get systemFieldsInput() {
    return this._systemFields;
  }

  // text_secret - computed: false, optional: true, required: false
  private _textSecret?: string; 
  public get textSecret() {
    return this.getStringAttribute('text_secret');
  }
  public set textSecret(value: string) {
    this._textSecret = value;
  }
  public resetTextSecret() {
    this._textSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get textSecretInput() {
    return this._textSecret;
  }

  // timeout_retry_settings - computed: false, optional: true, required: false
  private _timeoutRetrySettings = new PackDestinationOutputOpenTelemetryTimeoutRetrySettingsOutputReference(this, "timeout_retry_settings");
  public get timeoutRetrySettings() {
    return this._timeoutRetrySettings;
  }
  public putTimeoutRetrySettings(value: PackDestinationOutputOpenTelemetryTimeoutRetrySettings) {
    this._timeoutRetrySettings.internalValue = value;
  }
  public resetTimeoutRetrySettings() {
    this._timeoutRetrySettings.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutRetrySettingsInput() {
    return this._timeoutRetrySettings.internalValue;
  }

  // timeout_sec - computed: true, optional: true, required: false
  private _timeoutSec?: number; 
  public get timeoutSec() {
    return this.getNumberAttribute('timeout_sec');
  }
  public set timeoutSec(value: number) {
    this._timeoutSec = value;
  }
  public resetTimeoutSec() {
    this._timeoutSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutSecInput() {
    return this._timeoutSec;
  }

  // tls - computed: false, optional: true, required: false
  private _tls = new PackDestinationOutputOpenTelemetryTlsOutputReference(this, "tls");
  public get tls() {
    return this._tls;
  }
  public putTls(value: PackDestinationOutputOpenTelemetryTls) {
    this._tls.internalValue = value;
  }
  public resetTls() {
    this._tls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsInput() {
    return this._tls.internalValue;
  }

  // token - computed: false, optional: true, required: false
  private _token?: string; 
  public get token() {
    return this.getStringAttribute('token');
  }
  public set token(value: string) {
    this._token = value;
  }
  public resetToken() {
    this._token = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tokenInput() {
    return this._token;
  }

  // token_attribute_name - computed: false, optional: true, required: false
  private _tokenAttributeName?: string; 
  public get tokenAttributeName() {
    return this.getStringAttribute('token_attribute_name');
  }
  public set tokenAttributeName(value: string) {
    this._tokenAttributeName = value;
  }
  public resetTokenAttributeName() {
    this._tokenAttributeName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tokenAttributeNameInput() {
    return this._tokenAttributeName;
  }

  // token_timeout_secs - computed: true, optional: true, required: false
  private _tokenTimeoutSecs?: number; 
  public get tokenTimeoutSecs() {
    return this.getNumberAttribute('token_timeout_secs');
  }
  public set tokenTimeoutSecs(value: number) {
    this._tokenTimeoutSecs = value;
  }
  public resetTokenTimeoutSecs() {
    this._tokenTimeoutSecs = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tokenTimeoutSecsInput() {
    return this._tokenTimeoutSecs;
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // use_round_robin_dns - computed: true, optional: true, required: false
  private _useRoundRobinDns?: boolean | cdktf.IResolvable; 
  public get useRoundRobinDns() {
    return this.getBooleanAttribute('use_round_robin_dns');
  }
  public set useRoundRobinDns(value: boolean | cdktf.IResolvable) {
    this._useRoundRobinDns = value;
  }
  public resetUseRoundRobinDns() {
    this._useRoundRobinDns = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get useRoundRobinDnsInput() {
    return this._useRoundRobinDns;
  }

  // username - computed: false, optional: true, required: false
  private _username?: string; 
  public get username() {
    return this.getStringAttribute('username');
  }
  public set username(value: string) {
    this._username = value;
  }
  public resetUsername() {
    this._username = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usernameInput() {
    return this._username;
  }
}
export interface PackDestinationOutputPrometheusExtraHttpHeaders {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#name PackDestination#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#value PackDestination#value}
  */
  readonly value: string;
}

export function packDestinationOutputPrometheusExtraHttpHeadersToTerraform(struct?: PackDestinationOutputPrometheusExtraHttpHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function packDestinationOutputPrometheusExtraHttpHeadersToHclTerraform(struct?: PackDestinationOutputPrometheusExtraHttpHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputPrometheusExtraHttpHeadersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackDestinationOutputPrometheusExtraHttpHeaders | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputPrometheusExtraHttpHeaders | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class PackDestinationOutputPrometheusExtraHttpHeadersList extends cdktf.ComplexList {
  public internalValue? : PackDestinationOutputPrometheusExtraHttpHeaders[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackDestinationOutputPrometheusExtraHttpHeadersOutputReference {
    return new PackDestinationOutputPrometheusExtraHttpHeadersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackDestinationOutputPrometheusOauthHeaders {
  /**
  * OAuth header name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#name PackDestination#name}
  */
  readonly name: string;
  /**
  * OAuth header value
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#value PackDestination#value}
  */
  readonly value: string;
}

export function packDestinationOutputPrometheusOauthHeadersToTerraform(struct?: PackDestinationOutputPrometheusOauthHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function packDestinationOutputPrometheusOauthHeadersToHclTerraform(struct?: PackDestinationOutputPrometheusOauthHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputPrometheusOauthHeadersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackDestinationOutputPrometheusOauthHeaders | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputPrometheusOauthHeaders | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class PackDestinationOutputPrometheusOauthHeadersList extends cdktf.ComplexList {
  public internalValue? : PackDestinationOutputPrometheusOauthHeaders[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackDestinationOutputPrometheusOauthHeadersOutputReference {
    return new PackDestinationOutputPrometheusOauthHeadersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackDestinationOutputPrometheusOauthParams {
  /**
  * OAuth parameter name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#name PackDestination#name}
  */
  readonly name: string;
  /**
  * OAuth parameter value
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#value PackDestination#value}
  */
  readonly value: string;
}

export function packDestinationOutputPrometheusOauthParamsToTerraform(struct?: PackDestinationOutputPrometheusOauthParams | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function packDestinationOutputPrometheusOauthParamsToHclTerraform(struct?: PackDestinationOutputPrometheusOauthParams | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputPrometheusOauthParamsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackDestinationOutputPrometheusOauthParams | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputPrometheusOauthParams | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class PackDestinationOutputPrometheusOauthParamsList extends cdktf.ComplexList {
  public internalValue? : PackDestinationOutputPrometheusOauthParams[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackDestinationOutputPrometheusOauthParamsOutputReference {
    return new PackDestinationOutputPrometheusOauthParamsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackDestinationOutputPrometheusPqControls {
}

export function packDestinationOutputPrometheusPqControlsToTerraform(struct?: PackDestinationOutputPrometheusPqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function packDestinationOutputPrometheusPqControlsToHclTerraform(struct?: PackDestinationOutputPrometheusPqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class PackDestinationOutputPrometheusPqControlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackDestinationOutputPrometheusPqControls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputPrometheusPqControls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface PackDestinationOutputPrometheusResponseRetrySettings {
  /**
  * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc. Default: 2
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#backoff_rate PackDestination#backoff_rate}
  */
  readonly backoffRate?: number;
  /**
  * The HTTP response status code that will trigger retries
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#http_status PackDestination#http_status}
  */
  readonly httpStatus: number;
  /**
  * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes). Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#initial_backoff PackDestination#initial_backoff}
  */
  readonly initialBackoff?: number;
  /**
  * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds). Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_backoff PackDestination#max_backoff}
  */
  readonly maxBackoff?: number;
}

export function packDestinationOutputPrometheusResponseRetrySettingsToTerraform(struct?: PackDestinationOutputPrometheusResponseRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    backoff_rate: cdktf.numberToTerraform(struct!.backoffRate),
    http_status: cdktf.numberToTerraform(struct!.httpStatus),
    initial_backoff: cdktf.numberToTerraform(struct!.initialBackoff),
    max_backoff: cdktf.numberToTerraform(struct!.maxBackoff),
  }
}


export function packDestinationOutputPrometheusResponseRetrySettingsToHclTerraform(struct?: PackDestinationOutputPrometheusResponseRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    backoff_rate: {
      value: cdktf.numberToHclTerraform(struct!.backoffRate),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    http_status: {
      value: cdktf.numberToHclTerraform(struct!.httpStatus),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    initial_backoff: {
      value: cdktf.numberToHclTerraform(struct!.initialBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_backoff: {
      value: cdktf.numberToHclTerraform(struct!.maxBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputPrometheusResponseRetrySettingsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackDestinationOutputPrometheusResponseRetrySettings | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._backoffRate !== undefined) {
      hasAnyValues = true;
      internalValueResult.backoffRate = this._backoffRate;
    }
    if (this._httpStatus !== undefined) {
      hasAnyValues = true;
      internalValueResult.httpStatus = this._httpStatus;
    }
    if (this._initialBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.initialBackoff = this._initialBackoff;
    }
    if (this._maxBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBackoff = this._maxBackoff;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputPrometheusResponseRetrySettings | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._backoffRate = undefined;
      this._httpStatus = undefined;
      this._initialBackoff = undefined;
      this._maxBackoff = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._backoffRate = value.backoffRate;
      this._httpStatus = value.httpStatus;
      this._initialBackoff = value.initialBackoff;
      this._maxBackoff = value.maxBackoff;
    }
  }

  // backoff_rate - computed: true, optional: true, required: false
  private _backoffRate?: number; 
  public get backoffRate() {
    return this.getNumberAttribute('backoff_rate');
  }
  public set backoffRate(value: number) {
    this._backoffRate = value;
  }
  public resetBackoffRate() {
    this._backoffRate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get backoffRateInput() {
    return this._backoffRate;
  }

  // http_status - computed: false, optional: false, required: true
  private _httpStatus?: number; 
  public get httpStatus() {
    return this.getNumberAttribute('http_status');
  }
  public set httpStatus(value: number) {
    this._httpStatus = value;
  }
  // Temporarily expose input value. Use with caution.
  public get httpStatusInput() {
    return this._httpStatus;
  }

  // initial_backoff - computed: true, optional: true, required: false
  private _initialBackoff?: number; 
  public get initialBackoff() {
    return this.getNumberAttribute('initial_backoff');
  }
  public set initialBackoff(value: number) {
    this._initialBackoff = value;
  }
  public resetInitialBackoff() {
    this._initialBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get initialBackoffInput() {
    return this._initialBackoff;
  }

  // max_backoff - computed: true, optional: true, required: false
  private _maxBackoff?: number; 
  public get maxBackoff() {
    return this.getNumberAttribute('max_backoff');
  }
  public set maxBackoff(value: number) {
    this._maxBackoff = value;
  }
  public resetMaxBackoff() {
    this._maxBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBackoffInput() {
    return this._maxBackoff;
  }
}

export class PackDestinationOutputPrometheusResponseRetrySettingsList extends cdktf.ComplexList {
  public internalValue? : PackDestinationOutputPrometheusResponseRetrySettings[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackDestinationOutputPrometheusResponseRetrySettingsOutputReference {
    return new PackDestinationOutputPrometheusResponseRetrySettingsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackDestinationOutputPrometheusTimeoutRetrySettings {
  /**
  * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc. Default: 2
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#backoff_rate PackDestination#backoff_rate}
  */
  readonly backoffRate?: number;
  /**
  * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes). Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#initial_backoff PackDestination#initial_backoff}
  */
  readonly initialBackoff?: number;
  /**
  * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds). Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_backoff PackDestination#max_backoff}
  */
  readonly maxBackoff?: number;
  /**
  * Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#timeout_retry PackDestination#timeout_retry}
  */
  readonly timeoutRetry?: boolean | cdktf.IResolvable;
}

export function packDestinationOutputPrometheusTimeoutRetrySettingsToTerraform(struct?: PackDestinationOutputPrometheusTimeoutRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    backoff_rate: cdktf.numberToTerraform(struct!.backoffRate),
    initial_backoff: cdktf.numberToTerraform(struct!.initialBackoff),
    max_backoff: cdktf.numberToTerraform(struct!.maxBackoff),
    timeout_retry: cdktf.booleanToTerraform(struct!.timeoutRetry),
  }
}


export function packDestinationOutputPrometheusTimeoutRetrySettingsToHclTerraform(struct?: PackDestinationOutputPrometheusTimeoutRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    backoff_rate: {
      value: cdktf.numberToHclTerraform(struct!.backoffRate),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    initial_backoff: {
      value: cdktf.numberToHclTerraform(struct!.initialBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_backoff: {
      value: cdktf.numberToHclTerraform(struct!.maxBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    timeout_retry: {
      value: cdktf.booleanToHclTerraform(struct!.timeoutRetry),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputPrometheusTimeoutRetrySettingsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackDestinationOutputPrometheusTimeoutRetrySettings | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._backoffRate !== undefined) {
      hasAnyValues = true;
      internalValueResult.backoffRate = this._backoffRate;
    }
    if (this._initialBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.initialBackoff = this._initialBackoff;
    }
    if (this._maxBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBackoff = this._maxBackoff;
    }
    if (this._timeoutRetry !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutRetry = this._timeoutRetry;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputPrometheusTimeoutRetrySettings | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._backoffRate = undefined;
      this._initialBackoff = undefined;
      this._maxBackoff = undefined;
      this._timeoutRetry = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._backoffRate = value.backoffRate;
      this._initialBackoff = value.initialBackoff;
      this._maxBackoff = value.maxBackoff;
      this._timeoutRetry = value.timeoutRetry;
    }
  }

  // backoff_rate - computed: true, optional: true, required: false
  private _backoffRate?: number; 
  public get backoffRate() {
    return this.getNumberAttribute('backoff_rate');
  }
  public set backoffRate(value: number) {
    this._backoffRate = value;
  }
  public resetBackoffRate() {
    this._backoffRate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get backoffRateInput() {
    return this._backoffRate;
  }

  // initial_backoff - computed: true, optional: true, required: false
  private _initialBackoff?: number; 
  public get initialBackoff() {
    return this.getNumberAttribute('initial_backoff');
  }
  public set initialBackoff(value: number) {
    this._initialBackoff = value;
  }
  public resetInitialBackoff() {
    this._initialBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get initialBackoffInput() {
    return this._initialBackoff;
  }

  // max_backoff - computed: true, optional: true, required: false
  private _maxBackoff?: number; 
  public get maxBackoff() {
    return this.getNumberAttribute('max_backoff');
  }
  public set maxBackoff(value: number) {
    this._maxBackoff = value;
  }
  public resetMaxBackoff() {
    this._maxBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBackoffInput() {
    return this._maxBackoff;
  }

  // timeout_retry - computed: true, optional: true, required: false
  private _timeoutRetry?: boolean | cdktf.IResolvable; 
  public get timeoutRetry() {
    return this.getBooleanAttribute('timeout_retry');
  }
  public set timeoutRetry(value: boolean | cdktf.IResolvable) {
    this._timeoutRetry = value;
  }
  public resetTimeoutRetry() {
    this._timeoutRetry = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutRetryInput() {
    return this._timeoutRetry;
  }
}
export interface PackDestinationOutputPrometheus {
  /**
  * JavaScript expression to compute the Authorization header value to pass in requests. The value `${token}` is used to reference the token obtained from authentication, e.g.: `Bearer ${token}`. Default: "`Bearer ${token}`"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#auth_header_expr PackDestination#auth_header_expr}
  */
  readonly authHeaderExpr?: string;
  /**
  * Remote Write authentication type. Default: "none"; must be one of ["none", "basic", "credentialsSecret", "token", "textSecret", "oauth"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#auth_type PackDestination#auth_type}
  */
  readonly authType?: string;
  /**
  * Maximum number of ongoing requests before blocking. Default: 5
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#concurrency PackDestination#concurrency}
  */
  readonly concurrency?: number;
  /**
  * Select or create a secret that references your credentials
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#credentials_secret PackDestination#credentials_secret}
  */
  readonly credentialsSecret?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#description PackDestination#description}
  */
  readonly description?: string;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#environment PackDestination#environment}
  */
  readonly environment?: string;
  /**
  * Headers to add to all events
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#extra_http_headers PackDestination#extra_http_headers}
  */
  readonly extraHttpHeaders?: PackDestinationOutputPrometheusExtraHttpHeaders[] | cdktf.IResolvable;
  /**
  * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below. Default: "none"; must be one of ["payload", "payloadAndHeaders", "none"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#failed_request_logging_mode PackDestination#failed_request_logging_mode}
  */
  readonly failedRequestLoggingMode?: string;
  /**
  * Maximum time between requests. Small values could cause the payload size to be smaller than the configured Body size limit. Default: 1
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#flush_period_sec PackDestination#flush_period_sec}
  */
  readonly flushPeriodSec?: number;
  /**
  * Unique ID for this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#id PackDestination#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * URL for OAuth
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#login_url PackDestination#login_url}
  */
  readonly loginUrl?: string;
  /**
  * Maximum number of events to include in the request body. Default is 0 (unlimited). Default: 0
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_payload_events PackDestination#max_payload_events}
  */
  readonly maxPayloadEvents?: number;
  /**
  * Maximum size, in KB, of the request body. Default: 4096
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_payload_size_kb PackDestination#max_payload_size_kb}
  */
  readonly maxPayloadSizeKb?: number;
  /**
  * JavaScript expression that can be used to rename metrics. For example, name.replace(/\./g, '_') will replace all '.' characters in a metric's name with the supported '_' character. Use the 'name' global variable to access the metric's name. You can access event fields' values via __e.<fieldName>. Default: "name.replace(/[^a-zA-Z0-9_]/g, '_')"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#metric_rename_expr PackDestination#metric_rename_expr}
  */
  readonly metricRenameExpr?: string;
  /**
  * How frequently metrics metadata is sent out. Value cannot be smaller than the base Flush period set above. Default: 60
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#metrics_flush_period_sec PackDestination#metrics_flush_period_sec}
  */
  readonly metricsFlushPeriodSec?: number;
  /**
  * Additional headers to send in the OAuth login request. @{product} will automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#oauth_headers PackDestination#oauth_headers}
  */
  readonly oauthHeaders?: PackDestinationOutputPrometheusOauthHeaders[] | cdktf.IResolvable;
  /**
  * Additional parameters to send in the OAuth login request. @{product} will combine the secret with these parameters, and will send the URL-encoded result in a POST request to the endpoint specified in the 'Login URL'. We'll automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#oauth_params PackDestination#oauth_params}
  */
  readonly oauthParams?: PackDestinationOutputPrometheusOauthParams[] | cdktf.IResolvable;
  /**
  * How to handle events when all receivers are exerting backpressure. Default: "block"; must be one of ["block", "drop", "queue"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#on_backpressure PackDestination#on_backpressure}
  */
  readonly onBackpressure?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#password PackDestination#password}
  */
  readonly password?: string;
  /**
  * Pipeline to process data before sending out to this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pipeline PackDestination#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_compress PackDestination#pq_compress}
  */
  readonly pqCompress?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_controls PackDestination#pq_controls}
  */
  readonly pqControls?: PackDestinationOutputPrometheusPqControls;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.). Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_max_file_size PackDestination#pq_max_file_size}
  */
  readonly pqMaxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_max_size PackDestination#pq_max_size}
  */
  readonly pqMaxSize?: string;
  /**
  * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem. Default: "error"; must be one of ["error", "backpressure", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_mode PackDestination#pq_mode}
  */
  readonly pqMode?: string;
  /**
  * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged. Default: "block"; must be one of ["block", "drop"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_on_backpressure PackDestination#pq_on_backpressure}
  */
  readonly pqOnBackpressure?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_path PackDestination#pq_path}
  */
  readonly pqPath?: string;
  /**
  * Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's). 
  *         Enabled by default. When this setting is also present in TLS Settings (Client Side), 
  *         that value will take precedence.
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#reject_unauthorized PackDestination#reject_unauthorized}
  */
  readonly rejectUnauthorized?: boolean | cdktf.IResolvable;
  /**
  * Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#response_honor_retry_after_header PackDestination#response_honor_retry_after_header}
  */
  readonly responseHonorRetryAfterHeader?: boolean | cdktf.IResolvable;
  /**
  * Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#response_retry_settings PackDestination#response_retry_settings}
  */
  readonly responseRetrySettings?: PackDestinationOutputPrometheusResponseRetrySettings[] | cdktf.IResolvable;
  /**
  * List of headers that are safe to log in plain text. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#safe_headers PackDestination#safe_headers}
  */
  readonly safeHeaders?: string[];
  /**
  * Secret parameter value to pass in request body
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#secret PackDestination#secret}
  */
  readonly secret?: string;
  /**
  * Secret parameter name to pass in request body
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#secret_param_name PackDestination#secret_param_name}
  */
  readonly secretParamName?: string;
  /**
  * Generate and send metadata (`type` and `metricFamilyName`) requests. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#send_metadata PackDestination#send_metadata}
  */
  readonly sendMetadata?: boolean | cdktf.IResolvable;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#streamtags PackDestination#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Fields to automatically add to events, such as cribl_pipe. Supports wildcards. These fields are added as dimensions to generated metrics. Default: ["cribl_host","cribl_wp"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#system_fields PackDestination#system_fields}
  */
  readonly systemFields?: string[];
  /**
  * Select or create a stored text secret
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#text_secret PackDestination#text_secret}
  */
  readonly textSecret?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#timeout_retry_settings PackDestination#timeout_retry_settings}
  */
  readonly timeoutRetrySettings?: PackDestinationOutputPrometheusTimeoutRetrySettings;
  /**
  * Amount of time, in seconds, to wait for a request to complete before canceling it. Default: 30
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#timeout_sec PackDestination#timeout_sec}
  */
  readonly timeoutSec?: number;
  /**
  * Bearer token to include in the authorization header
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#token PackDestination#token}
  */
  readonly token?: string;
  /**
  * Name of the auth token attribute in the OAuth response. Can be top-level (e.g., 'token'); or nested, using a period (e.g., 'data.token').
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#token_attribute_name PackDestination#token_attribute_name}
  */
  readonly tokenAttributeName?: string;
  /**
  * How often the OAuth token should be refreshed. Default: 3600
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#token_timeout_secs PackDestination#token_timeout_secs}
  */
  readonly tokenTimeoutSecs?: number;
  /**
  * must be "prometheus"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#type PackDestination#type}
  */
  readonly type: string;
  /**
  * The endpoint to send metrics to
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#url PackDestination#url}
  */
  readonly url: string;
  /**
  * Enable round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. For optimal performance, consider enabling this setting for non-load balanced destinations. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#use_round_robin_dns PackDestination#use_round_robin_dns}
  */
  readonly useRoundRobinDns?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#username PackDestination#username}
  */
  readonly username?: string;
}

export function packDestinationOutputPrometheusToTerraform(struct?: PackDestinationOutputPrometheus | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    auth_header_expr: cdktf.stringToTerraform(struct!.authHeaderExpr),
    auth_type: cdktf.stringToTerraform(struct!.authType),
    concurrency: cdktf.numberToTerraform(struct!.concurrency),
    credentials_secret: cdktf.stringToTerraform(struct!.credentialsSecret),
    description: cdktf.stringToTerraform(struct!.description),
    environment: cdktf.stringToTerraform(struct!.environment),
    extra_http_headers: cdktf.listMapper(packDestinationOutputPrometheusExtraHttpHeadersToTerraform, false)(struct!.extraHttpHeaders),
    failed_request_logging_mode: cdktf.stringToTerraform(struct!.failedRequestLoggingMode),
    flush_period_sec: cdktf.numberToTerraform(struct!.flushPeriodSec),
    id: cdktf.stringToTerraform(struct!.id),
    login_url: cdktf.stringToTerraform(struct!.loginUrl),
    max_payload_events: cdktf.numberToTerraform(struct!.maxPayloadEvents),
    max_payload_size_kb: cdktf.numberToTerraform(struct!.maxPayloadSizeKb),
    metric_rename_expr: cdktf.stringToTerraform(struct!.metricRenameExpr),
    metrics_flush_period_sec: cdktf.numberToTerraform(struct!.metricsFlushPeriodSec),
    oauth_headers: cdktf.listMapper(packDestinationOutputPrometheusOauthHeadersToTerraform, false)(struct!.oauthHeaders),
    oauth_params: cdktf.listMapper(packDestinationOutputPrometheusOauthParamsToTerraform, false)(struct!.oauthParams),
    on_backpressure: cdktf.stringToTerraform(struct!.onBackpressure),
    password: cdktf.stringToTerraform(struct!.password),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    pq_compress: cdktf.stringToTerraform(struct!.pqCompress),
    pq_controls: packDestinationOutputPrometheusPqControlsToTerraform(struct!.pqControls),
    pq_max_file_size: cdktf.stringToTerraform(struct!.pqMaxFileSize),
    pq_max_size: cdktf.stringToTerraform(struct!.pqMaxSize),
    pq_mode: cdktf.stringToTerraform(struct!.pqMode),
    pq_on_backpressure: cdktf.stringToTerraform(struct!.pqOnBackpressure),
    pq_path: cdktf.stringToTerraform(struct!.pqPath),
    reject_unauthorized: cdktf.booleanToTerraform(struct!.rejectUnauthorized),
    response_honor_retry_after_header: cdktf.booleanToTerraform(struct!.responseHonorRetryAfterHeader),
    response_retry_settings: cdktf.listMapper(packDestinationOutputPrometheusResponseRetrySettingsToTerraform, false)(struct!.responseRetrySettings),
    safe_headers: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.safeHeaders),
    secret: cdktf.stringToTerraform(struct!.secret),
    secret_param_name: cdktf.stringToTerraform(struct!.secretParamName),
    send_metadata: cdktf.booleanToTerraform(struct!.sendMetadata),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    system_fields: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.systemFields),
    text_secret: cdktf.stringToTerraform(struct!.textSecret),
    timeout_retry_settings: packDestinationOutputPrometheusTimeoutRetrySettingsToTerraform(struct!.timeoutRetrySettings),
    timeout_sec: cdktf.numberToTerraform(struct!.timeoutSec),
    token: cdktf.stringToTerraform(struct!.token),
    token_attribute_name: cdktf.stringToTerraform(struct!.tokenAttributeName),
    token_timeout_secs: cdktf.numberToTerraform(struct!.tokenTimeoutSecs),
    type: cdktf.stringToTerraform(struct!.type),
    url: cdktf.stringToTerraform(struct!.url),
    use_round_robin_dns: cdktf.booleanToTerraform(struct!.useRoundRobinDns),
    username: cdktf.stringToTerraform(struct!.username),
  }
}


export function packDestinationOutputPrometheusToHclTerraform(struct?: PackDestinationOutputPrometheus | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    auth_header_expr: {
      value: cdktf.stringToHclTerraform(struct!.authHeaderExpr),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    auth_type: {
      value: cdktf.stringToHclTerraform(struct!.authType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    concurrency: {
      value: cdktf.numberToHclTerraform(struct!.concurrency),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    credentials_secret: {
      value: cdktf.stringToHclTerraform(struct!.credentialsSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    extra_http_headers: {
      value: cdktf.listMapperHcl(packDestinationOutputPrometheusExtraHttpHeadersToHclTerraform, false)(struct!.extraHttpHeaders),
      isBlock: true,
      type: "list",
      storageClassType: "PackDestinationOutputPrometheusExtraHttpHeadersList",
    },
    failed_request_logging_mode: {
      value: cdktf.stringToHclTerraform(struct!.failedRequestLoggingMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    flush_period_sec: {
      value: cdktf.numberToHclTerraform(struct!.flushPeriodSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    login_url: {
      value: cdktf.stringToHclTerraform(struct!.loginUrl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_payload_events: {
      value: cdktf.numberToHclTerraform(struct!.maxPayloadEvents),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_payload_size_kb: {
      value: cdktf.numberToHclTerraform(struct!.maxPayloadSizeKb),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    metric_rename_expr: {
      value: cdktf.stringToHclTerraform(struct!.metricRenameExpr),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    metrics_flush_period_sec: {
      value: cdktf.numberToHclTerraform(struct!.metricsFlushPeriodSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    oauth_headers: {
      value: cdktf.listMapperHcl(packDestinationOutputPrometheusOauthHeadersToHclTerraform, false)(struct!.oauthHeaders),
      isBlock: true,
      type: "list",
      storageClassType: "PackDestinationOutputPrometheusOauthHeadersList",
    },
    oauth_params: {
      value: cdktf.listMapperHcl(packDestinationOutputPrometheusOauthParamsToHclTerraform, false)(struct!.oauthParams),
      isBlock: true,
      type: "list",
      storageClassType: "PackDestinationOutputPrometheusOauthParamsList",
    },
    on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.onBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    password: {
      value: cdktf.stringToHclTerraform(struct!.password),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_compress: {
      value: cdktf.stringToHclTerraform(struct!.pqCompress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_controls: {
      value: packDestinationOutputPrometheusPqControlsToHclTerraform(struct!.pqControls),
      isBlock: true,
      type: "struct",
      storageClassType: "PackDestinationOutputPrometheusPqControls",
    },
    pq_max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_max_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_mode: {
      value: cdktf.stringToHclTerraform(struct!.pqMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.pqOnBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_path: {
      value: cdktf.stringToHclTerraform(struct!.pqPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reject_unauthorized: {
      value: cdktf.booleanToHclTerraform(struct!.rejectUnauthorized),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    response_honor_retry_after_header: {
      value: cdktf.booleanToHclTerraform(struct!.responseHonorRetryAfterHeader),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    response_retry_settings: {
      value: cdktf.listMapperHcl(packDestinationOutputPrometheusResponseRetrySettingsToHclTerraform, false)(struct!.responseRetrySettings),
      isBlock: true,
      type: "list",
      storageClassType: "PackDestinationOutputPrometheusResponseRetrySettingsList",
    },
    safe_headers: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.safeHeaders),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    secret: {
      value: cdktf.stringToHclTerraform(struct!.secret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_param_name: {
      value: cdktf.stringToHclTerraform(struct!.secretParamName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    send_metadata: {
      value: cdktf.booleanToHclTerraform(struct!.sendMetadata),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    system_fields: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.systemFields),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    text_secret: {
      value: cdktf.stringToHclTerraform(struct!.textSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    timeout_retry_settings: {
      value: packDestinationOutputPrometheusTimeoutRetrySettingsToHclTerraform(struct!.timeoutRetrySettings),
      isBlock: true,
      type: "struct",
      storageClassType: "PackDestinationOutputPrometheusTimeoutRetrySettings",
    },
    timeout_sec: {
      value: cdktf.numberToHclTerraform(struct!.timeoutSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    token: {
      value: cdktf.stringToHclTerraform(struct!.token),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    token_attribute_name: {
      value: cdktf.stringToHclTerraform(struct!.tokenAttributeName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    token_timeout_secs: {
      value: cdktf.numberToHclTerraform(struct!.tokenTimeoutSecs),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    url: {
      value: cdktf.stringToHclTerraform(struct!.url),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    use_round_robin_dns: {
      value: cdktf.booleanToHclTerraform(struct!.useRoundRobinDns),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    username: {
      value: cdktf.stringToHclTerraform(struct!.username),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputPrometheusOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackDestinationOutputPrometheus | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._authHeaderExpr !== undefined) {
      hasAnyValues = true;
      internalValueResult.authHeaderExpr = this._authHeaderExpr;
    }
    if (this._authType !== undefined) {
      hasAnyValues = true;
      internalValueResult.authType = this._authType;
    }
    if (this._concurrency !== undefined) {
      hasAnyValues = true;
      internalValueResult.concurrency = this._concurrency;
    }
    if (this._credentialsSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.credentialsSecret = this._credentialsSecret;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._extraHttpHeaders?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.extraHttpHeaders = this._extraHttpHeaders?.internalValue;
    }
    if (this._failedRequestLoggingMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.failedRequestLoggingMode = this._failedRequestLoggingMode;
    }
    if (this._flushPeriodSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.flushPeriodSec = this._flushPeriodSec;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._loginUrl !== undefined) {
      hasAnyValues = true;
      internalValueResult.loginUrl = this._loginUrl;
    }
    if (this._maxPayloadEvents !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxPayloadEvents = this._maxPayloadEvents;
    }
    if (this._maxPayloadSizeKb !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxPayloadSizeKb = this._maxPayloadSizeKb;
    }
    if (this._metricRenameExpr !== undefined) {
      hasAnyValues = true;
      internalValueResult.metricRenameExpr = this._metricRenameExpr;
    }
    if (this._metricsFlushPeriodSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.metricsFlushPeriodSec = this._metricsFlushPeriodSec;
    }
    if (this._oauthHeaders?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.oauthHeaders = this._oauthHeaders?.internalValue;
    }
    if (this._oauthParams?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.oauthParams = this._oauthParams?.internalValue;
    }
    if (this._onBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.onBackpressure = this._onBackpressure;
    }
    if (this._password !== undefined) {
      hasAnyValues = true;
      internalValueResult.password = this._password;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._pqCompress !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqCompress = this._pqCompress;
    }
    if (this._pqControls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqControls = this._pqControls?.internalValue;
    }
    if (this._pqMaxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxFileSize = this._pqMaxFileSize;
    }
    if (this._pqMaxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxSize = this._pqMaxSize;
    }
    if (this._pqMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMode = this._pqMode;
    }
    if (this._pqOnBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqOnBackpressure = this._pqOnBackpressure;
    }
    if (this._pqPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqPath = this._pqPath;
    }
    if (this._rejectUnauthorized !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectUnauthorized = this._rejectUnauthorized;
    }
    if (this._responseHonorRetryAfterHeader !== undefined) {
      hasAnyValues = true;
      internalValueResult.responseHonorRetryAfterHeader = this._responseHonorRetryAfterHeader;
    }
    if (this._responseRetrySettings?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.responseRetrySettings = this._responseRetrySettings?.internalValue;
    }
    if (this._safeHeaders !== undefined) {
      hasAnyValues = true;
      internalValueResult.safeHeaders = this._safeHeaders;
    }
    if (this._secret !== undefined) {
      hasAnyValues = true;
      internalValueResult.secret = this._secret;
    }
    if (this._secretParamName !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretParamName = this._secretParamName;
    }
    if (this._sendMetadata !== undefined) {
      hasAnyValues = true;
      internalValueResult.sendMetadata = this._sendMetadata;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._systemFields !== undefined) {
      hasAnyValues = true;
      internalValueResult.systemFields = this._systemFields;
    }
    if (this._textSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.textSecret = this._textSecret;
    }
    if (this._timeoutRetrySettings?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutRetrySettings = this._timeoutRetrySettings?.internalValue;
    }
    if (this._timeoutSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutSec = this._timeoutSec;
    }
    if (this._token !== undefined) {
      hasAnyValues = true;
      internalValueResult.token = this._token;
    }
    if (this._tokenAttributeName !== undefined) {
      hasAnyValues = true;
      internalValueResult.tokenAttributeName = this._tokenAttributeName;
    }
    if (this._tokenTimeoutSecs !== undefined) {
      hasAnyValues = true;
      internalValueResult.tokenTimeoutSecs = this._tokenTimeoutSecs;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._url !== undefined) {
      hasAnyValues = true;
      internalValueResult.url = this._url;
    }
    if (this._useRoundRobinDns !== undefined) {
      hasAnyValues = true;
      internalValueResult.useRoundRobinDns = this._useRoundRobinDns;
    }
    if (this._username !== undefined) {
      hasAnyValues = true;
      internalValueResult.username = this._username;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputPrometheus | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._authHeaderExpr = undefined;
      this._authType = undefined;
      this._concurrency = undefined;
      this._credentialsSecret = undefined;
      this._description = undefined;
      this._environment = undefined;
      this._extraHttpHeaders.internalValue = undefined;
      this._failedRequestLoggingMode = undefined;
      this._flushPeriodSec = undefined;
      this._id = undefined;
      this._loginUrl = undefined;
      this._maxPayloadEvents = undefined;
      this._maxPayloadSizeKb = undefined;
      this._metricRenameExpr = undefined;
      this._metricsFlushPeriodSec = undefined;
      this._oauthHeaders.internalValue = undefined;
      this._oauthParams.internalValue = undefined;
      this._onBackpressure = undefined;
      this._password = undefined;
      this._pipeline = undefined;
      this._pqCompress = undefined;
      this._pqControls.internalValue = undefined;
      this._pqMaxFileSize = undefined;
      this._pqMaxSize = undefined;
      this._pqMode = undefined;
      this._pqOnBackpressure = undefined;
      this._pqPath = undefined;
      this._rejectUnauthorized = undefined;
      this._responseHonorRetryAfterHeader = undefined;
      this._responseRetrySettings.internalValue = undefined;
      this._safeHeaders = undefined;
      this._secret = undefined;
      this._secretParamName = undefined;
      this._sendMetadata = undefined;
      this._streamtags = undefined;
      this._systemFields = undefined;
      this._textSecret = undefined;
      this._timeoutRetrySettings.internalValue = undefined;
      this._timeoutSec = undefined;
      this._token = undefined;
      this._tokenAttributeName = undefined;
      this._tokenTimeoutSecs = undefined;
      this._type = undefined;
      this._url = undefined;
      this._useRoundRobinDns = undefined;
      this._username = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._authHeaderExpr = value.authHeaderExpr;
      this._authType = value.authType;
      this._concurrency = value.concurrency;
      this._credentialsSecret = value.credentialsSecret;
      this._description = value.description;
      this._environment = value.environment;
      this._extraHttpHeaders.internalValue = value.extraHttpHeaders;
      this._failedRequestLoggingMode = value.failedRequestLoggingMode;
      this._flushPeriodSec = value.flushPeriodSec;
      this._id = value.id;
      this._loginUrl = value.loginUrl;
      this._maxPayloadEvents = value.maxPayloadEvents;
      this._maxPayloadSizeKb = value.maxPayloadSizeKb;
      this._metricRenameExpr = value.metricRenameExpr;
      this._metricsFlushPeriodSec = value.metricsFlushPeriodSec;
      this._oauthHeaders.internalValue = value.oauthHeaders;
      this._oauthParams.internalValue = value.oauthParams;
      this._onBackpressure = value.onBackpressure;
      this._password = value.password;
      this._pipeline = value.pipeline;
      this._pqCompress = value.pqCompress;
      this._pqControls.internalValue = value.pqControls;
      this._pqMaxFileSize = value.pqMaxFileSize;
      this._pqMaxSize = value.pqMaxSize;
      this._pqMode = value.pqMode;
      this._pqOnBackpressure = value.pqOnBackpressure;
      this._pqPath = value.pqPath;
      this._rejectUnauthorized = value.rejectUnauthorized;
      this._responseHonorRetryAfterHeader = value.responseHonorRetryAfterHeader;
      this._responseRetrySettings.internalValue = value.responseRetrySettings;
      this._safeHeaders = value.safeHeaders;
      this._secret = value.secret;
      this._secretParamName = value.secretParamName;
      this._sendMetadata = value.sendMetadata;
      this._streamtags = value.streamtags;
      this._systemFields = value.systemFields;
      this._textSecret = value.textSecret;
      this._timeoutRetrySettings.internalValue = value.timeoutRetrySettings;
      this._timeoutSec = value.timeoutSec;
      this._token = value.token;
      this._tokenAttributeName = value.tokenAttributeName;
      this._tokenTimeoutSecs = value.tokenTimeoutSecs;
      this._type = value.type;
      this._url = value.url;
      this._useRoundRobinDns = value.useRoundRobinDns;
      this._username = value.username;
    }
  }

  // auth_header_expr - computed: true, optional: true, required: false
  private _authHeaderExpr?: string; 
  public get authHeaderExpr() {
    return this.getStringAttribute('auth_header_expr');
  }
  public set authHeaderExpr(value: string) {
    this._authHeaderExpr = value;
  }
  public resetAuthHeaderExpr() {
    this._authHeaderExpr = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authHeaderExprInput() {
    return this._authHeaderExpr;
  }

  // auth_type - computed: true, optional: true, required: false
  private _authType?: string; 
  public get authType() {
    return this.getStringAttribute('auth_type');
  }
  public set authType(value: string) {
    this._authType = value;
  }
  public resetAuthType() {
    this._authType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authTypeInput() {
    return this._authType;
  }

  // concurrency - computed: true, optional: true, required: false
  private _concurrency?: number; 
  public get concurrency() {
    return this.getNumberAttribute('concurrency');
  }
  public set concurrency(value: number) {
    this._concurrency = value;
  }
  public resetConcurrency() {
    this._concurrency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get concurrencyInput() {
    return this._concurrency;
  }

  // credentials_secret - computed: false, optional: true, required: false
  private _credentialsSecret?: string; 
  public get credentialsSecret() {
    return this.getStringAttribute('credentials_secret');
  }
  public set credentialsSecret(value: string) {
    this._credentialsSecret = value;
  }
  public resetCredentialsSecret() {
    this._credentialsSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get credentialsSecretInput() {
    return this._credentialsSecret;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // extra_http_headers - computed: false, optional: true, required: false
  private _extraHttpHeaders = new PackDestinationOutputPrometheusExtraHttpHeadersList(this, "extra_http_headers", false);
  public get extraHttpHeaders() {
    return this._extraHttpHeaders;
  }
  public putExtraHttpHeaders(value: PackDestinationOutputPrometheusExtraHttpHeaders[] | cdktf.IResolvable) {
    this._extraHttpHeaders.internalValue = value;
  }
  public resetExtraHttpHeaders() {
    this._extraHttpHeaders.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get extraHttpHeadersInput() {
    return this._extraHttpHeaders.internalValue;
  }

  // failed_request_logging_mode - computed: true, optional: true, required: false
  private _failedRequestLoggingMode?: string; 
  public get failedRequestLoggingMode() {
    return this.getStringAttribute('failed_request_logging_mode');
  }
  public set failedRequestLoggingMode(value: string) {
    this._failedRequestLoggingMode = value;
  }
  public resetFailedRequestLoggingMode() {
    this._failedRequestLoggingMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get failedRequestLoggingModeInput() {
    return this._failedRequestLoggingMode;
  }

  // flush_period_sec - computed: true, optional: true, required: false
  private _flushPeriodSec?: number; 
  public get flushPeriodSec() {
    return this.getNumberAttribute('flush_period_sec');
  }
  public set flushPeriodSec(value: number) {
    this._flushPeriodSec = value;
  }
  public resetFlushPeriodSec() {
    this._flushPeriodSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get flushPeriodSecInput() {
    return this._flushPeriodSec;
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // login_url - computed: false, optional: true, required: false
  private _loginUrl?: string; 
  public get loginUrl() {
    return this.getStringAttribute('login_url');
  }
  public set loginUrl(value: string) {
    this._loginUrl = value;
  }
  public resetLoginUrl() {
    this._loginUrl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get loginUrlInput() {
    return this._loginUrl;
  }

  // max_payload_events - computed: true, optional: true, required: false
  private _maxPayloadEvents?: number; 
  public get maxPayloadEvents() {
    return this.getNumberAttribute('max_payload_events');
  }
  public set maxPayloadEvents(value: number) {
    this._maxPayloadEvents = value;
  }
  public resetMaxPayloadEvents() {
    this._maxPayloadEvents = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxPayloadEventsInput() {
    return this._maxPayloadEvents;
  }

  // max_payload_size_kb - computed: true, optional: true, required: false
  private _maxPayloadSizeKb?: number; 
  public get maxPayloadSizeKb() {
    return this.getNumberAttribute('max_payload_size_kb');
  }
  public set maxPayloadSizeKb(value: number) {
    this._maxPayloadSizeKb = value;
  }
  public resetMaxPayloadSizeKb() {
    this._maxPayloadSizeKb = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxPayloadSizeKbInput() {
    return this._maxPayloadSizeKb;
  }

  // metric_rename_expr - computed: true, optional: true, required: false
  private _metricRenameExpr?: string; 
  public get metricRenameExpr() {
    return this.getStringAttribute('metric_rename_expr');
  }
  public set metricRenameExpr(value: string) {
    this._metricRenameExpr = value;
  }
  public resetMetricRenameExpr() {
    this._metricRenameExpr = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metricRenameExprInput() {
    return this._metricRenameExpr;
  }

  // metrics_flush_period_sec - computed: true, optional: true, required: false
  private _metricsFlushPeriodSec?: number; 
  public get metricsFlushPeriodSec() {
    return this.getNumberAttribute('metrics_flush_period_sec');
  }
  public set metricsFlushPeriodSec(value: number) {
    this._metricsFlushPeriodSec = value;
  }
  public resetMetricsFlushPeriodSec() {
    this._metricsFlushPeriodSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metricsFlushPeriodSecInput() {
    return this._metricsFlushPeriodSec;
  }

  // oauth_headers - computed: false, optional: true, required: false
  private _oauthHeaders = new PackDestinationOutputPrometheusOauthHeadersList(this, "oauth_headers", false);
  public get oauthHeaders() {
    return this._oauthHeaders;
  }
  public putOauthHeaders(value: PackDestinationOutputPrometheusOauthHeaders[] | cdktf.IResolvable) {
    this._oauthHeaders.internalValue = value;
  }
  public resetOauthHeaders() {
    this._oauthHeaders.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get oauthHeadersInput() {
    return this._oauthHeaders.internalValue;
  }

  // oauth_params - computed: false, optional: true, required: false
  private _oauthParams = new PackDestinationOutputPrometheusOauthParamsList(this, "oauth_params", false);
  public get oauthParams() {
    return this._oauthParams;
  }
  public putOauthParams(value: PackDestinationOutputPrometheusOauthParams[] | cdktf.IResolvable) {
    this._oauthParams.internalValue = value;
  }
  public resetOauthParams() {
    this._oauthParams.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get oauthParamsInput() {
    return this._oauthParams.internalValue;
  }

  // on_backpressure - computed: true, optional: true, required: false
  private _onBackpressure?: string; 
  public get onBackpressure() {
    return this.getStringAttribute('on_backpressure');
  }
  public set onBackpressure(value: string) {
    this._onBackpressure = value;
  }
  public resetOnBackpressure() {
    this._onBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get onBackpressureInput() {
    return this._onBackpressure;
  }

  // password - computed: false, optional: true, required: false
  private _password?: string; 
  public get password() {
    return this.getStringAttribute('password');
  }
  public set password(value: string) {
    this._password = value;
  }
  public resetPassword() {
    this._password = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passwordInput() {
    return this._password;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // pq_compress - computed: true, optional: true, required: false
  private _pqCompress?: string; 
  public get pqCompress() {
    return this.getStringAttribute('pq_compress');
  }
  public set pqCompress(value: string) {
    this._pqCompress = value;
  }
  public resetPqCompress() {
    this._pqCompress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqCompressInput() {
    return this._pqCompress;
  }

  // pq_controls - computed: false, optional: true, required: false
  private _pqControls = new PackDestinationOutputPrometheusPqControlsOutputReference(this, "pq_controls");
  public get pqControls() {
    return this._pqControls;
  }
  public putPqControls(value: PackDestinationOutputPrometheusPqControls) {
    this._pqControls.internalValue = value;
  }
  public resetPqControls() {
    this._pqControls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqControlsInput() {
    return this._pqControls.internalValue;
  }

  // pq_max_file_size - computed: true, optional: true, required: false
  private _pqMaxFileSize?: string; 
  public get pqMaxFileSize() {
    return this.getStringAttribute('pq_max_file_size');
  }
  public set pqMaxFileSize(value: string) {
    this._pqMaxFileSize = value;
  }
  public resetPqMaxFileSize() {
    this._pqMaxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxFileSizeInput() {
    return this._pqMaxFileSize;
  }

  // pq_max_size - computed: true, optional: true, required: false
  private _pqMaxSize?: string; 
  public get pqMaxSize() {
    return this.getStringAttribute('pq_max_size');
  }
  public set pqMaxSize(value: string) {
    this._pqMaxSize = value;
  }
  public resetPqMaxSize() {
    this._pqMaxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxSizeInput() {
    return this._pqMaxSize;
  }

  // pq_mode - computed: true, optional: true, required: false
  private _pqMode?: string; 
  public get pqMode() {
    return this.getStringAttribute('pq_mode');
  }
  public set pqMode(value: string) {
    this._pqMode = value;
  }
  public resetPqMode() {
    this._pqMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqModeInput() {
    return this._pqMode;
  }

  // pq_on_backpressure - computed: true, optional: true, required: false
  private _pqOnBackpressure?: string; 
  public get pqOnBackpressure() {
    return this.getStringAttribute('pq_on_backpressure');
  }
  public set pqOnBackpressure(value: string) {
    this._pqOnBackpressure = value;
  }
  public resetPqOnBackpressure() {
    this._pqOnBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqOnBackpressureInput() {
    return this._pqOnBackpressure;
  }

  // pq_path - computed: true, optional: true, required: false
  private _pqPath?: string; 
  public get pqPath() {
    return this.getStringAttribute('pq_path');
  }
  public set pqPath(value: string) {
    this._pqPath = value;
  }
  public resetPqPath() {
    this._pqPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqPathInput() {
    return this._pqPath;
  }

  // reject_unauthorized - computed: true, optional: true, required: false
  private _rejectUnauthorized?: boolean | cdktf.IResolvable; 
  public get rejectUnauthorized() {
    return this.getBooleanAttribute('reject_unauthorized');
  }
  public set rejectUnauthorized(value: boolean | cdktf.IResolvable) {
    this._rejectUnauthorized = value;
  }
  public resetRejectUnauthorized() {
    this._rejectUnauthorized = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectUnauthorizedInput() {
    return this._rejectUnauthorized;
  }

  // response_honor_retry_after_header - computed: true, optional: true, required: false
  private _responseHonorRetryAfterHeader?: boolean | cdktf.IResolvable; 
  public get responseHonorRetryAfterHeader() {
    return this.getBooleanAttribute('response_honor_retry_after_header');
  }
  public set responseHonorRetryAfterHeader(value: boolean | cdktf.IResolvable) {
    this._responseHonorRetryAfterHeader = value;
  }
  public resetResponseHonorRetryAfterHeader() {
    this._responseHonorRetryAfterHeader = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get responseHonorRetryAfterHeaderInput() {
    return this._responseHonorRetryAfterHeader;
  }

  // response_retry_settings - computed: false, optional: true, required: false
  private _responseRetrySettings = new PackDestinationOutputPrometheusResponseRetrySettingsList(this, "response_retry_settings", false);
  public get responseRetrySettings() {
    return this._responseRetrySettings;
  }
  public putResponseRetrySettings(value: PackDestinationOutputPrometheusResponseRetrySettings[] | cdktf.IResolvable) {
    this._responseRetrySettings.internalValue = value;
  }
  public resetResponseRetrySettings() {
    this._responseRetrySettings.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get responseRetrySettingsInput() {
    return this._responseRetrySettings.internalValue;
  }

  // safe_headers - computed: true, optional: true, required: false
  private _safeHeaders?: string[]; 
  public get safeHeaders() {
    return this.getListAttribute('safe_headers');
  }
  public set safeHeaders(value: string[]) {
    this._safeHeaders = value;
  }
  public resetSafeHeaders() {
    this._safeHeaders = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get safeHeadersInput() {
    return this._safeHeaders;
  }

  // secret - computed: false, optional: true, required: false
  private _secret?: string; 
  public get secret() {
    return this.getStringAttribute('secret');
  }
  public set secret(value: string) {
    this._secret = value;
  }
  public resetSecret() {
    this._secret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretInput() {
    return this._secret;
  }

  // secret_param_name - computed: false, optional: true, required: false
  private _secretParamName?: string; 
  public get secretParamName() {
    return this.getStringAttribute('secret_param_name');
  }
  public set secretParamName(value: string) {
    this._secretParamName = value;
  }
  public resetSecretParamName() {
    this._secretParamName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretParamNameInput() {
    return this._secretParamName;
  }

  // send_metadata - computed: true, optional: true, required: false
  private _sendMetadata?: boolean | cdktf.IResolvable; 
  public get sendMetadata() {
    return this.getBooleanAttribute('send_metadata');
  }
  public set sendMetadata(value: boolean | cdktf.IResolvable) {
    this._sendMetadata = value;
  }
  public resetSendMetadata() {
    this._sendMetadata = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sendMetadataInput() {
    return this._sendMetadata;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // system_fields - computed: true, optional: true, required: false
  private _systemFields?: string[]; 
  public get systemFields() {
    return this.getListAttribute('system_fields');
  }
  public set systemFields(value: string[]) {
    this._systemFields = value;
  }
  public resetSystemFields() {
    this._systemFields = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get systemFieldsInput() {
    return this._systemFields;
  }

  // text_secret - computed: false, optional: true, required: false
  private _textSecret?: string; 
  public get textSecret() {
    return this.getStringAttribute('text_secret');
  }
  public set textSecret(value: string) {
    this._textSecret = value;
  }
  public resetTextSecret() {
    this._textSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get textSecretInput() {
    return this._textSecret;
  }

  // timeout_retry_settings - computed: false, optional: true, required: false
  private _timeoutRetrySettings = new PackDestinationOutputPrometheusTimeoutRetrySettingsOutputReference(this, "timeout_retry_settings");
  public get timeoutRetrySettings() {
    return this._timeoutRetrySettings;
  }
  public putTimeoutRetrySettings(value: PackDestinationOutputPrometheusTimeoutRetrySettings) {
    this._timeoutRetrySettings.internalValue = value;
  }
  public resetTimeoutRetrySettings() {
    this._timeoutRetrySettings.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutRetrySettingsInput() {
    return this._timeoutRetrySettings.internalValue;
  }

  // timeout_sec - computed: true, optional: true, required: false
  private _timeoutSec?: number; 
  public get timeoutSec() {
    return this.getNumberAttribute('timeout_sec');
  }
  public set timeoutSec(value: number) {
    this._timeoutSec = value;
  }
  public resetTimeoutSec() {
    this._timeoutSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutSecInput() {
    return this._timeoutSec;
  }

  // token - computed: false, optional: true, required: false
  private _token?: string; 
  public get token() {
    return this.getStringAttribute('token');
  }
  public set token(value: string) {
    this._token = value;
  }
  public resetToken() {
    this._token = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tokenInput() {
    return this._token;
  }

  // token_attribute_name - computed: false, optional: true, required: false
  private _tokenAttributeName?: string; 
  public get tokenAttributeName() {
    return this.getStringAttribute('token_attribute_name');
  }
  public set tokenAttributeName(value: string) {
    this._tokenAttributeName = value;
  }
  public resetTokenAttributeName() {
    this._tokenAttributeName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tokenAttributeNameInput() {
    return this._tokenAttributeName;
  }

  // token_timeout_secs - computed: true, optional: true, required: false
  private _tokenTimeoutSecs?: number; 
  public get tokenTimeoutSecs() {
    return this.getNumberAttribute('token_timeout_secs');
  }
  public set tokenTimeoutSecs(value: number) {
    this._tokenTimeoutSecs = value;
  }
  public resetTokenTimeoutSecs() {
    this._tokenTimeoutSecs = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tokenTimeoutSecsInput() {
    return this._tokenTimeoutSecs;
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // url - computed: false, optional: false, required: true
  private _url?: string; 
  public get url() {
    return this.getStringAttribute('url');
  }
  public set url(value: string) {
    this._url = value;
  }
  // Temporarily expose input value. Use with caution.
  public get urlInput() {
    return this._url;
  }

  // use_round_robin_dns - computed: true, optional: true, required: false
  private _useRoundRobinDns?: boolean | cdktf.IResolvable; 
  public get useRoundRobinDns() {
    return this.getBooleanAttribute('use_round_robin_dns');
  }
  public set useRoundRobinDns(value: boolean | cdktf.IResolvable) {
    this._useRoundRobinDns = value;
  }
  public resetUseRoundRobinDns() {
    this._useRoundRobinDns = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get useRoundRobinDnsInput() {
    return this._useRoundRobinDns;
  }

  // username - computed: false, optional: true, required: false
  private _username?: string; 
  public get username() {
    return this.getStringAttribute('username');
  }
  public set username(value: string) {
    this._username = value;
  }
  public resetUsername() {
    this._username = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usernameInput() {
    return this._username;
  }
}
export interface PackDestinationOutputRing {
  /**
  * Default: "gzip"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#compress PackDestination#compress}
  */
  readonly compress?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#description PackDestination#description}
  */
  readonly description?: string;
  /**
  * Path to use to write metrics. Defaults to $CRIBL_HOME/state/<id>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#dest_path PackDestination#dest_path}
  */
  readonly destPath?: string;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#environment PackDestination#environment}
  */
  readonly environment?: string;
  /**
  * Format of the output data. Default: "json"; must be one of ["json", "raw"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#format PackDestination#format}
  */
  readonly format?: string;
  /**
  * Unique ID for this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#id PackDestination#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id: string;
  /**
  * Maximum disk space allowed to be consumed (examples: 420MB, 4GB). When limit is reached, older data will be deleted. Default: "1GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_data_size PackDestination#max_data_size}
  */
  readonly maxDataSize?: string;
  /**
  * Maximum amount of time to retain data (examples: 2h, 4d). When limit is reached, older data will be deleted. Default: "24h"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_data_time PackDestination#max_data_time}
  */
  readonly maxDataTime?: string;
  /**
  * How to handle events when all receivers are exerting backpressure. Default: "block"; must be one of ["block", "drop"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#on_backpressure PackDestination#on_backpressure}
  */
  readonly onBackpressure?: string;
  /**
  * JS expression to define how files are partitioned and organized. If left blank, Cribl Stream will fallback on event.__partition.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#partition_expr PackDestination#partition_expr}
  */
  readonly partitionExpr?: string;
  /**
  * Pipeline to process data before sending out to this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pipeline PackDestination#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#streamtags PackDestination#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Fields to automatically add to events, such as cribl_pipe. Supports wildcards. Default: ["cribl_pipe"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#system_fields PackDestination#system_fields}
  */
  readonly systemFields?: string[];
  /**
  * must be "ring"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#type PackDestination#type}
  */
  readonly type: string;
}

export function packDestinationOutputRingToTerraform(struct?: PackDestinationOutputRing | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    compress: cdktf.stringToTerraform(struct!.compress),
    description: cdktf.stringToTerraform(struct!.description),
    dest_path: cdktf.stringToTerraform(struct!.destPath),
    environment: cdktf.stringToTerraform(struct!.environment),
    format: cdktf.stringToTerraform(struct!.format),
    id: cdktf.stringToTerraform(struct!.id),
    max_data_size: cdktf.stringToTerraform(struct!.maxDataSize),
    max_data_time: cdktf.stringToTerraform(struct!.maxDataTime),
    on_backpressure: cdktf.stringToTerraform(struct!.onBackpressure),
    partition_expr: cdktf.stringToTerraform(struct!.partitionExpr),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    system_fields: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.systemFields),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function packDestinationOutputRingToHclTerraform(struct?: PackDestinationOutputRing | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    compress: {
      value: cdktf.stringToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    dest_path: {
      value: cdktf.stringToHclTerraform(struct!.destPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    format: {
      value: cdktf.stringToHclTerraform(struct!.format),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_data_size: {
      value: cdktf.stringToHclTerraform(struct!.maxDataSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_data_time: {
      value: cdktf.stringToHclTerraform(struct!.maxDataTime),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.onBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    partition_expr: {
      value: cdktf.stringToHclTerraform(struct!.partitionExpr),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    system_fields: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.systemFields),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputRingOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackDestinationOutputRing | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._destPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.destPath = this._destPath;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._format !== undefined) {
      hasAnyValues = true;
      internalValueResult.format = this._format;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._maxDataSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxDataSize = this._maxDataSize;
    }
    if (this._maxDataTime !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxDataTime = this._maxDataTime;
    }
    if (this._onBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.onBackpressure = this._onBackpressure;
    }
    if (this._partitionExpr !== undefined) {
      hasAnyValues = true;
      internalValueResult.partitionExpr = this._partitionExpr;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._systemFields !== undefined) {
      hasAnyValues = true;
      internalValueResult.systemFields = this._systemFields;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputRing | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._compress = undefined;
      this._description = undefined;
      this._destPath = undefined;
      this._environment = undefined;
      this._format = undefined;
      this._id = undefined;
      this._maxDataSize = undefined;
      this._maxDataTime = undefined;
      this._onBackpressure = undefined;
      this._partitionExpr = undefined;
      this._pipeline = undefined;
      this._streamtags = undefined;
      this._systemFields = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._compress = value.compress;
      this._description = value.description;
      this._destPath = value.destPath;
      this._environment = value.environment;
      this._format = value.format;
      this._id = value.id;
      this._maxDataSize = value.maxDataSize;
      this._maxDataTime = value.maxDataTime;
      this._onBackpressure = value.onBackpressure;
      this._partitionExpr = value.partitionExpr;
      this._pipeline = value.pipeline;
      this._streamtags = value.streamtags;
      this._systemFields = value.systemFields;
      this._type = value.type;
    }
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: string; 
  public get compress() {
    return this.getStringAttribute('compress');
  }
  public set compress(value: string) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // dest_path - computed: false, optional: true, required: false
  private _destPath?: string; 
  public get destPath() {
    return this.getStringAttribute('dest_path');
  }
  public set destPath(value: string) {
    this._destPath = value;
  }
  public resetDestPath() {
    this._destPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get destPathInput() {
    return this._destPath;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // format - computed: true, optional: true, required: false
  private _format?: string; 
  public get format() {
    return this.getStringAttribute('format');
  }
  public set format(value: string) {
    this._format = value;
  }
  public resetFormat() {
    this._format = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get formatInput() {
    return this._format;
  }

  // id - computed: false, optional: false, required: true
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // max_data_size - computed: true, optional: true, required: false
  private _maxDataSize?: string; 
  public get maxDataSize() {
    return this.getStringAttribute('max_data_size');
  }
  public set maxDataSize(value: string) {
    this._maxDataSize = value;
  }
  public resetMaxDataSize() {
    this._maxDataSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxDataSizeInput() {
    return this._maxDataSize;
  }

  // max_data_time - computed: true, optional: true, required: false
  private _maxDataTime?: string; 
  public get maxDataTime() {
    return this.getStringAttribute('max_data_time');
  }
  public set maxDataTime(value: string) {
    this._maxDataTime = value;
  }
  public resetMaxDataTime() {
    this._maxDataTime = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxDataTimeInput() {
    return this._maxDataTime;
  }

  // on_backpressure - computed: true, optional: true, required: false
  private _onBackpressure?: string; 
  public get onBackpressure() {
    return this.getStringAttribute('on_backpressure');
  }
  public set onBackpressure(value: string) {
    this._onBackpressure = value;
  }
  public resetOnBackpressure() {
    this._onBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get onBackpressureInput() {
    return this._onBackpressure;
  }

  // partition_expr - computed: false, optional: true, required: false
  private _partitionExpr?: string; 
  public get partitionExpr() {
    return this.getStringAttribute('partition_expr');
  }
  public set partitionExpr(value: string) {
    this._partitionExpr = value;
  }
  public resetPartitionExpr() {
    this._partitionExpr = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get partitionExprInput() {
    return this._partitionExpr;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // system_fields - computed: true, optional: true, required: false
  private _systemFields?: string[]; 
  public get systemFields() {
    return this.getListAttribute('system_fields');
  }
  public set systemFields(value: string[]) {
    this._systemFields = value;
  }
  public resetSystemFields() {
    this._systemFields = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get systemFieldsInput() {
    return this._systemFields;
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface PackDestinationOutputRouterRules {
  /**
  * Description of this rule's purpose
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#description PackDestination#description}
  */
  readonly description?: string;
  /**
  * JavaScript expression to select events to send to output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#filter PackDestination#filter}
  */
  readonly filter: string;
  /**
  * Flag to control whether to stop the event from being checked against other rules. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#final PackDestination#final}
  */
  readonly final?: boolean | cdktf.IResolvable;
  /**
  * Output to send matching events to
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#output PackDestination#output}
  */
  readonly output: string;
}

export function packDestinationOutputRouterRulesToTerraform(struct?: PackDestinationOutputRouterRules | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    description: cdktf.stringToTerraform(struct!.description),
    filter: cdktf.stringToTerraform(struct!.filter),
    final: cdktf.booleanToTerraform(struct!.final),
    output: cdktf.stringToTerraform(struct!.output),
  }
}


export function packDestinationOutputRouterRulesToHclTerraform(struct?: PackDestinationOutputRouterRules | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    filter: {
      value: cdktf.stringToHclTerraform(struct!.filter),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    final: {
      value: cdktf.booleanToHclTerraform(struct!.final),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    output: {
      value: cdktf.stringToHclTerraform(struct!.output),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputRouterRulesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackDestinationOutputRouterRules | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._filter !== undefined) {
      hasAnyValues = true;
      internalValueResult.filter = this._filter;
    }
    if (this._final !== undefined) {
      hasAnyValues = true;
      internalValueResult.final = this._final;
    }
    if (this._output !== undefined) {
      hasAnyValues = true;
      internalValueResult.output = this._output;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputRouterRules | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._description = undefined;
      this._filter = undefined;
      this._final = undefined;
      this._output = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._description = value.description;
      this._filter = value.filter;
      this._final = value.final;
      this._output = value.output;
    }
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // filter - computed: false, optional: false, required: true
  private _filter?: string; 
  public get filter() {
    return this.getStringAttribute('filter');
  }
  public set filter(value: string) {
    this._filter = value;
  }
  // Temporarily expose input value. Use with caution.
  public get filterInput() {
    return this._filter;
  }

  // final - computed: true, optional: true, required: false
  private _final?: boolean | cdktf.IResolvable; 
  public get final() {
    return this.getBooleanAttribute('final');
  }
  public set final(value: boolean | cdktf.IResolvable) {
    this._final = value;
  }
  public resetFinal() {
    this._final = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get finalInput() {
    return this._final;
  }

  // output - computed: false, optional: false, required: true
  private _output?: string; 
  public get output() {
    return this.getStringAttribute('output');
  }
  public set output(value: string) {
    this._output = value;
  }
  // Temporarily expose input value. Use with caution.
  public get outputInput() {
    return this._output;
  }
}

export class PackDestinationOutputRouterRulesList extends cdktf.ComplexList {
  public internalValue? : PackDestinationOutputRouterRules[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackDestinationOutputRouterRulesOutputReference {
    return new PackDestinationOutputRouterRulesOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackDestinationOutputRouter {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#description PackDestination#description}
  */
  readonly description?: string;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#environment PackDestination#environment}
  */
  readonly environment?: string;
  /**
  * Unique ID for this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#id PackDestination#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * Pipeline to process data before sending out to this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pipeline PackDestination#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Event routing rules
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#rules PackDestination#rules}
  */
  readonly rules: PackDestinationOutputRouterRules[] | cdktf.IResolvable;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#streamtags PackDestination#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Fields to automatically add to events, such as cribl_pipe. Supports wildcards. Default: ["cribl_pipe"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#system_fields PackDestination#system_fields}
  */
  readonly systemFields?: string[];
  /**
  * must be "router"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#type PackDestination#type}
  */
  readonly type: string;
}

export function packDestinationOutputRouterToTerraform(struct?: PackDestinationOutputRouter | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    description: cdktf.stringToTerraform(struct!.description),
    environment: cdktf.stringToTerraform(struct!.environment),
    id: cdktf.stringToTerraform(struct!.id),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    rules: cdktf.listMapper(packDestinationOutputRouterRulesToTerraform, false)(struct!.rules),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    system_fields: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.systemFields),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function packDestinationOutputRouterToHclTerraform(struct?: PackDestinationOutputRouter | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    rules: {
      value: cdktf.listMapperHcl(packDestinationOutputRouterRulesToHclTerraform, false)(struct!.rules),
      isBlock: true,
      type: "list",
      storageClassType: "PackDestinationOutputRouterRulesList",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    system_fields: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.systemFields),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputRouterOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackDestinationOutputRouter | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._rules?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.rules = this._rules?.internalValue;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._systemFields !== undefined) {
      hasAnyValues = true;
      internalValueResult.systemFields = this._systemFields;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputRouter | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._description = undefined;
      this._environment = undefined;
      this._id = undefined;
      this._pipeline = undefined;
      this._rules.internalValue = undefined;
      this._streamtags = undefined;
      this._systemFields = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._description = value.description;
      this._environment = value.environment;
      this._id = value.id;
      this._pipeline = value.pipeline;
      this._rules.internalValue = value.rules;
      this._streamtags = value.streamtags;
      this._systemFields = value.systemFields;
      this._type = value.type;
    }
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // rules - computed: false, optional: false, required: true
  private _rules = new PackDestinationOutputRouterRulesList(this, "rules", false);
  public get rules() {
    return this._rules;
  }
  public putRules(value: PackDestinationOutputRouterRules[] | cdktf.IResolvable) {
    this._rules.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get rulesInput() {
    return this._rules.internalValue;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // system_fields - computed: true, optional: true, required: false
  private _systemFields?: string[]; 
  public get systemFields() {
    return this.getListAttribute('system_fields');
  }
  public set systemFields(value: string[]) {
    this._systemFields = value;
  }
  public resetSystemFields() {
    this._systemFields = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get systemFieldsInput() {
    return this._systemFields;
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface PackDestinationOutputS3KeyValueMetadata {
  /**
  * Default: ""
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#key PackDestination#key}
  */
  readonly key?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#value PackDestination#value}
  */
  readonly value: string;
}

export function packDestinationOutputS3KeyValueMetadataToTerraform(struct?: PackDestinationOutputS3KeyValueMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function packDestinationOutputS3KeyValueMetadataToHclTerraform(struct?: PackDestinationOutputS3KeyValueMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputS3KeyValueMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackDestinationOutputS3KeyValueMetadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputS3KeyValueMetadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._value = value.value;
    }
  }

  // key - computed: true, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class PackDestinationOutputS3KeyValueMetadataList extends cdktf.ComplexList {
  public internalValue? : PackDestinationOutputS3KeyValueMetadata[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackDestinationOutputS3KeyValueMetadataOutputReference {
    return new PackDestinationOutputS3KeyValueMetadataOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackDestinationOutputS3 {
  /**
  * Add the Output ID value to staging location. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#add_id_to_stage_path PackDestination#add_id_to_stage_path}
  */
  readonly addIdToStagePath?: boolean | cdktf.IResolvable;
  /**
  * Amazon Resource Name (ARN) of the role to assume
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#assume_role_arn PackDestination#assume_role_arn}
  */
  readonly assumeRoleArn?: string;
  /**
  * External ID to use when assuming role
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#assume_role_external_id PackDestination#assume_role_external_id}
  */
  readonly assumeRoleExternalId?: string;
  /**
  * Automatically calculate the schema based on the events of each Parquet file generated. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#automatic_schema PackDestination#automatic_schema}
  */
  readonly automaticSchema?: boolean | cdktf.IResolvable;
  /**
  * This value can be a constant or a JavaScript expression (`${C.env.SOME_ACCESS_KEY}`)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#aws_api_key PackDestination#aws_api_key}
  */
  readonly awsApiKey?: string;
  /**
  * AWS authentication method. Choose Auto to use IAM roles. Default: "auto"; must be one of ["auto", "manual", "secret"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#aws_authentication_method PackDestination#aws_authentication_method}
  */
  readonly awsAuthenticationMethod?: string;
  /**
  * Select or create a stored secret that references your access key and secret key
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#aws_secret PackDestination#aws_secret}
  */
  readonly awsSecret?: string;
  /**
  * Secret key. This value can be a constant or a JavaScript expression. Example: `${C.env.SOME_SECRET}`)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#aws_secret_key PackDestination#aws_secret_key}
  */
  readonly awsSecretKey?: string;
  /**
  * JavaScript expression to define the output filename prefix (can be constant). Default: "`CriblOut`"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#base_file_name PackDestination#base_file_name}
  */
  readonly baseFileName?: string;
  /**
  * Name of the destination S3 bucket. Must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can be evaluated only at initialization time. Example referencing a Global Variable: `myBucket-${C.vars.myVar}`
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#bucket PackDestination#bucket}
  */
  readonly bucket: string;
  /**
  * Data compression format to apply to HTTP content before it is delivered. Default: "gzip"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#compress PackDestination#compress}
  */
  readonly compress?: string;
  /**
  * Compression level to apply before moving files to final destination. Default: "best_speed"; must be one of ["best_speed", "normal", "best_compression"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#compression_level PackDestination#compression_level}
  */
  readonly compressionLevel?: string;
  /**
  * If a file fails to move to its final destination after the maximum number of retries, move it to a designated directory to prevent further errors. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#deadletter_enabled PackDestination#deadletter_enabled}
  */
  readonly deadletterEnabled?: boolean | cdktf.IResolvable;
  /**
  * Storage location for files that fail to reach their final destination after maximum retries are exceeded. Default: "$CRIBL_HOME/state/outputs/dead-letter"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#deadletter_path PackDestination#deadletter_path}
  */
  readonly deadletterPath?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#description PackDestination#description}
  */
  readonly description?: string;
  /**
  * Prefix to append to files before uploading. Must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can be evaluated only at init time. Example referencing a Global Variable: `myKeyPrefix-${C.vars.myVar}`. Default: ""
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#dest_path PackDestination#dest_path}
  */
  readonly destPath?: string;
  /**
  * Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours). Default: 3600
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#duration_seconds PackDestination#duration_seconds}
  */
  readonly durationSeconds?: number;
  /**
  * How frequently, in seconds, to clean up empty directories. Default: 300
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#empty_dir_cleanup_sec PackDestination#empty_dir_cleanup_sec}
  */
  readonly emptyDirCleanupSec?: number;
  /**
  * Use Assume Role credentials to access S3. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#enable_assume_role PackDestination#enable_assume_role}
  */
  readonly enableAssumeRole?: boolean | cdktf.IResolvable;
  /**
  * Parquet tools can use the checksum of a Parquet page to verify data integrity. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#enable_page_checksum PackDestination#enable_page_checksum}
  */
  readonly enablePageChecksum?: boolean | cdktf.IResolvable;
  /**
  * Statistics profile an entire file in terms of minimum/maximum values within data, numbers of nulls, etc. You can use Parquet tools to view statistics. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#enable_statistics PackDestination#enable_statistics}
  */
  readonly enableStatistics?: boolean | cdktf.IResolvable;
  /**
  * One page index contains statistics for one data page. Parquet readers use statistics to enable page skipping. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#enable_write_page_index PackDestination#enable_write_page_index}
  */
  readonly enableWritePageIndex?: boolean | cdktf.IResolvable;
  /**
  * S3 service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to S3-compatible endpoint.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#endpoint PackDestination#endpoint}
  */
  readonly endpoint?: string;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#environment PackDestination#environment}
  */
  readonly environment?: string;
  /**
  * JavaScript expression to define the output filename suffix (can be constant).  The `__format` variable refers to the value of the `Data format` field (`json` or `raw`).  The `__compression` field refers to the kind of compression being used (`none` or `gzip`). Default: "`.${C.env[\"CRIBL_WORKER_ID\"]}.${__format}${__compression === \"gzip\" ? \".gz\" : \"\"}`"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#file_name_suffix PackDestination#file_name_suffix}
  */
  readonly fileNameSuffix?: string;
  /**
  * Format of the output data. Default: "json"; must be one of ["json", "raw", "parquet"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#format PackDestination#format}
  */
  readonly format?: string;
  /**
  * If set, this line will be written to the beginning of each output file. Default: ""
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#header_line PackDestination#header_line}
  */
  readonly headerLine?: string;
  /**
  * Unique ID for this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#id PackDestination#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * The metadata of files the Destination writes will include the properties you add here as key-value pairs. Useful for tagging. Examples: "key":"OCSF Event Class", "value":"9001"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#key_value_metadata PackDestination#key_value_metadata}
  */
  readonly keyValueMetadata?: PackDestinationOutputS3KeyValueMetadata[] | cdktf.IResolvable;
  /**
  * ID or ARN of the KMS customer-managed key to use for encryption
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#kms_key_id PackDestination#kms_key_id}
  */
  readonly kmsKeyId?: string;
  /**
  * Maximum number of files that can be waiting for upload before backpressure is applied. Default: 100
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_closing_files_to_backpressure PackDestination#max_closing_files_to_backpressure}
  */
  readonly maxClosingFilesToBackpressure?: number;
  /**
  * Maximum number of parts to upload in parallel per file. Minimum part size is 5MB. Default: 4
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_concurrent_file_parts PackDestination#max_concurrent_file_parts}
  */
  readonly maxConcurrentFileParts?: number;
  /**
  * Maximum amount of time to keep inactive files open. Files open for longer than this will be closed and moved to final output location. Default: 30
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_file_idle_time_sec PackDestination#max_file_idle_time_sec}
  */
  readonly maxFileIdleTimeSec?: number;
  /**
  * Maximum amount of time to write to a file. Files open for longer than this will be closed and moved to final output location. Default: 300
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_file_open_time_sec PackDestination#max_file_open_time_sec}
  */
  readonly maxFileOpenTimeSec?: number;
  /**
  * Maximum uncompressed output file size. Files of this size will be closed and moved to final output location. Default: 32
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_file_size_mb PackDestination#max_file_size_mb}
  */
  readonly maxFileSizeMb?: number;
  /**
  * Maximum number of files to keep open concurrently. When exceeded, @{product} will close the oldest open files and move them to the final output location. Default: 100
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_open_files PackDestination#max_open_files}
  */
  readonly maxOpenFiles?: number;
  /**
  * The maximum number of times a file will attempt to move to its final destination before being dead-lettered. Default: 20
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_retry_num PackDestination#max_retry_num}
  */
  readonly maxRetryNum?: number;
  /**
  * Object ACL to assign to uploaded objects. Default: "private"; must be one of ["private", "public-read", "public-read-write", "authenticated-read", "aws-exec-read", "bucket-owner-read", "bucket-owner-full-control"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#object_acl PackDestination#object_acl}
  */
  readonly objectAcl?: string;
  /**
  * How to handle events when all receivers are exerting backpressure. Default: "block"; must be one of ["block", "drop", "queue"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#on_backpressure PackDestination#on_backpressure}
  */
  readonly onBackpressure?: string;
  /**
  * How to handle events when disk space is below the global 'Min free disk space' limit. Default: "block"; must be one of ["block", "drop"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#on_disk_full_backpressure PackDestination#on_disk_full_backpressure}
  */
  readonly onDiskFullBackpressure?: string;
  /**
  * Serialization format of data pages. Note that some reader implementations use Data page V2's attributes to work more efficiently, while others ignore it. Default: "DATA_PAGE_V2"; must be one of ["DATA_PAGE_V1", "DATA_PAGE_V2"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#parquet_data_page_version PackDestination#parquet_data_page_version}
  */
  readonly parquetDataPageVersion?: string;
  /**
  * Target memory size for page segments, such as 1MB or 128MB. Generally, lower values improve reading speed, while higher values improve compression. Default: "1MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#parquet_page_size PackDestination#parquet_page_size}
  */
  readonly parquetPageSize?: string;
  /**
  * The number of rows that every group will contain. The final group can contain a smaller number of rows. Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#parquet_row_group_length PackDestination#parquet_row_group_length}
  */
  readonly parquetRowGroupLength?: number;
  /**
  * Determines which data types are supported and how they are represented. Default: "PARQUET_2_6"; must be one of ["PARQUET_1_0", "PARQUET_2_4", "PARQUET_2_6"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#parquet_version PackDestination#parquet_version}
  */
  readonly parquetVersion?: string;
  /**
  * JavaScript expression defining how files are partitioned and organized. Default is date-based. If blank, Stream will fall back to the event's __partition field value – if present – otherwise to each location's root directory. Default: "C.Time.strftime(_time ? _time : Date.now()/1000, '%Y/%m/%d')"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#partition_expr PackDestination#partition_expr}
  */
  readonly partitionExpr?: string;
  /**
  * Pipeline to process data before sending out to this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pipeline PackDestination#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Region where the S3 bucket is located
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#region PackDestination#region}
  */
  readonly region?: string;
  /**
  * Reject certificates that cannot be verified against a valid CA, such as self-signed certificates. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#reject_unauthorized PackDestination#reject_unauthorized}
  */
  readonly rejectUnauthorized?: boolean | cdktf.IResolvable;
  /**
  * Remove empty staging directories after moving files. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#remove_empty_dirs PackDestination#remove_empty_dirs}
  */
  readonly removeEmptyDirs?: boolean | cdktf.IResolvable;
  /**
  * Reuse connections between requests, which can improve performance. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#reuse_connections PackDestination#reuse_connections}
  */
  readonly reuseConnections?: boolean | cdktf.IResolvable;
  /**
  * must be one of ["AES256", "aws:kms"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#server_side_encryption PackDestination#server_side_encryption}
  */
  readonly serverSideEncryption?: string;
  /**
  * Log up to 3 rows that @{product} skips due to data mismatch
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#should_log_invalid_rows PackDestination#should_log_invalid_rows}
  */
  readonly shouldLogInvalidRows?: boolean | cdktf.IResolvable;
  /**
  * Signature version to use for signing S3 requests. Default: "v4"; must be one of ["v2", "v4"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#signature_version PackDestination#signature_version}
  */
  readonly signatureVersion?: string;
  /**
  * Filesystem location in which to buffer files, before compressing and moving to final destination. Use performant and stable storage. Default: "$CRIBL_HOME/state/outputs/staging"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#stage_path PackDestination#stage_path}
  */
  readonly stagePath?: string;
  /**
  * Storage class to select for uploaded objects. must be one of ["STANDARD", "REDUCED_REDUNDANCY", "STANDARD_IA", "ONEZONE_IA", "INTELLIGENT_TIERING", "GLACIER", "GLACIER_IR", "DEEP_ARCHIVE"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#storage_class PackDestination#storage_class}
  */
  readonly storageClass?: string;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#streamtags PackDestination#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Fields to automatically add to events, such as cribl_pipe. Supports wildcards. Default: ["cribl_pipe"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#system_fields PackDestination#system_fields}
  */
  readonly systemFields?: string[];
  /**
  * must be "s3"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#type PackDestination#type}
  */
  readonly type?: string;
  /**
  * Disable if you can access files within the bucket but not the bucket itself. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#verify_permissions PackDestination#verify_permissions}
  */
  readonly verifyPermissions?: boolean | cdktf.IResolvable;
  /**
  * Buffer size used to write to a file. Default: 64
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#write_high_water_mark PackDestination#write_high_water_mark}
  */
  readonly writeHighWaterMark?: number;
}

export function packDestinationOutputS3ToTerraform(struct?: PackDestinationOutputS3 | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    add_id_to_stage_path: cdktf.booleanToTerraform(struct!.addIdToStagePath),
    assume_role_arn: cdktf.stringToTerraform(struct!.assumeRoleArn),
    assume_role_external_id: cdktf.stringToTerraform(struct!.assumeRoleExternalId),
    automatic_schema: cdktf.booleanToTerraform(struct!.automaticSchema),
    aws_api_key: cdktf.stringToTerraform(struct!.awsApiKey),
    aws_authentication_method: cdktf.stringToTerraform(struct!.awsAuthenticationMethod),
    aws_secret: cdktf.stringToTerraform(struct!.awsSecret),
    aws_secret_key: cdktf.stringToTerraform(struct!.awsSecretKey),
    base_file_name: cdktf.stringToTerraform(struct!.baseFileName),
    bucket: cdktf.stringToTerraform(struct!.bucket),
    compress: cdktf.stringToTerraform(struct!.compress),
    compression_level: cdktf.stringToTerraform(struct!.compressionLevel),
    deadletter_enabled: cdktf.booleanToTerraform(struct!.deadletterEnabled),
    deadletter_path: cdktf.stringToTerraform(struct!.deadletterPath),
    description: cdktf.stringToTerraform(struct!.description),
    dest_path: cdktf.stringToTerraform(struct!.destPath),
    duration_seconds: cdktf.numberToTerraform(struct!.durationSeconds),
    empty_dir_cleanup_sec: cdktf.numberToTerraform(struct!.emptyDirCleanupSec),
    enable_assume_role: cdktf.booleanToTerraform(struct!.enableAssumeRole),
    enable_page_checksum: cdktf.booleanToTerraform(struct!.enablePageChecksum),
    enable_statistics: cdktf.booleanToTerraform(struct!.enableStatistics),
    enable_write_page_index: cdktf.booleanToTerraform(struct!.enableWritePageIndex),
    endpoint: cdktf.stringToTerraform(struct!.endpoint),
    environment: cdktf.stringToTerraform(struct!.environment),
    file_name_suffix: cdktf.stringToTerraform(struct!.fileNameSuffix),
    format: cdktf.stringToTerraform(struct!.format),
    header_line: cdktf.stringToTerraform(struct!.headerLine),
    id: cdktf.stringToTerraform(struct!.id),
    key_value_metadata: cdktf.listMapper(packDestinationOutputS3KeyValueMetadataToTerraform, false)(struct!.keyValueMetadata),
    kms_key_id: cdktf.stringToTerraform(struct!.kmsKeyId),
    max_closing_files_to_backpressure: cdktf.numberToTerraform(struct!.maxClosingFilesToBackpressure),
    max_concurrent_file_parts: cdktf.numberToTerraform(struct!.maxConcurrentFileParts),
    max_file_idle_time_sec: cdktf.numberToTerraform(struct!.maxFileIdleTimeSec),
    max_file_open_time_sec: cdktf.numberToTerraform(struct!.maxFileOpenTimeSec),
    max_file_size_mb: cdktf.numberToTerraform(struct!.maxFileSizeMb),
    max_open_files: cdktf.numberToTerraform(struct!.maxOpenFiles),
    max_retry_num: cdktf.numberToTerraform(struct!.maxRetryNum),
    object_acl: cdktf.stringToTerraform(struct!.objectAcl),
    on_backpressure: cdktf.stringToTerraform(struct!.onBackpressure),
    on_disk_full_backpressure: cdktf.stringToTerraform(struct!.onDiskFullBackpressure),
    parquet_data_page_version: cdktf.stringToTerraform(struct!.parquetDataPageVersion),
    parquet_page_size: cdktf.stringToTerraform(struct!.parquetPageSize),
    parquet_row_group_length: cdktf.numberToTerraform(struct!.parquetRowGroupLength),
    parquet_version: cdktf.stringToTerraform(struct!.parquetVersion),
    partition_expr: cdktf.stringToTerraform(struct!.partitionExpr),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    region: cdktf.stringToTerraform(struct!.region),
    reject_unauthorized: cdktf.booleanToTerraform(struct!.rejectUnauthorized),
    remove_empty_dirs: cdktf.booleanToTerraform(struct!.removeEmptyDirs),
    reuse_connections: cdktf.booleanToTerraform(struct!.reuseConnections),
    server_side_encryption: cdktf.stringToTerraform(struct!.serverSideEncryption),
    should_log_invalid_rows: cdktf.booleanToTerraform(struct!.shouldLogInvalidRows),
    signature_version: cdktf.stringToTerraform(struct!.signatureVersion),
    stage_path: cdktf.stringToTerraform(struct!.stagePath),
    storage_class: cdktf.stringToTerraform(struct!.storageClass),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    system_fields: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.systemFields),
    type: cdktf.stringToTerraform(struct!.type),
    verify_permissions: cdktf.booleanToTerraform(struct!.verifyPermissions),
    write_high_water_mark: cdktf.numberToTerraform(struct!.writeHighWaterMark),
  }
}


export function packDestinationOutputS3ToHclTerraform(struct?: PackDestinationOutputS3 | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    add_id_to_stage_path: {
      value: cdktf.booleanToHclTerraform(struct!.addIdToStagePath),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    assume_role_arn: {
      value: cdktf.stringToHclTerraform(struct!.assumeRoleArn),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    assume_role_external_id: {
      value: cdktf.stringToHclTerraform(struct!.assumeRoleExternalId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    automatic_schema: {
      value: cdktf.booleanToHclTerraform(struct!.automaticSchema),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    aws_api_key: {
      value: cdktf.stringToHclTerraform(struct!.awsApiKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    aws_authentication_method: {
      value: cdktf.stringToHclTerraform(struct!.awsAuthenticationMethod),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    aws_secret: {
      value: cdktf.stringToHclTerraform(struct!.awsSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    aws_secret_key: {
      value: cdktf.stringToHclTerraform(struct!.awsSecretKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    base_file_name: {
      value: cdktf.stringToHclTerraform(struct!.baseFileName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    bucket: {
      value: cdktf.stringToHclTerraform(struct!.bucket),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    compress: {
      value: cdktf.stringToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    compression_level: {
      value: cdktf.stringToHclTerraform(struct!.compressionLevel),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    deadletter_enabled: {
      value: cdktf.booleanToHclTerraform(struct!.deadletterEnabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    deadletter_path: {
      value: cdktf.stringToHclTerraform(struct!.deadletterPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    dest_path: {
      value: cdktf.stringToHclTerraform(struct!.destPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    duration_seconds: {
      value: cdktf.numberToHclTerraform(struct!.durationSeconds),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    empty_dir_cleanup_sec: {
      value: cdktf.numberToHclTerraform(struct!.emptyDirCleanupSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    enable_assume_role: {
      value: cdktf.booleanToHclTerraform(struct!.enableAssumeRole),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    enable_page_checksum: {
      value: cdktf.booleanToHclTerraform(struct!.enablePageChecksum),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    enable_statistics: {
      value: cdktf.booleanToHclTerraform(struct!.enableStatistics),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    enable_write_page_index: {
      value: cdktf.booleanToHclTerraform(struct!.enableWritePageIndex),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    endpoint: {
      value: cdktf.stringToHclTerraform(struct!.endpoint),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    file_name_suffix: {
      value: cdktf.stringToHclTerraform(struct!.fileNameSuffix),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    format: {
      value: cdktf.stringToHclTerraform(struct!.format),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    header_line: {
      value: cdktf.stringToHclTerraform(struct!.headerLine),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    key_value_metadata: {
      value: cdktf.listMapperHcl(packDestinationOutputS3KeyValueMetadataToHclTerraform, false)(struct!.keyValueMetadata),
      isBlock: true,
      type: "list",
      storageClassType: "PackDestinationOutputS3KeyValueMetadataList",
    },
    kms_key_id: {
      value: cdktf.stringToHclTerraform(struct!.kmsKeyId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_closing_files_to_backpressure: {
      value: cdktf.numberToHclTerraform(struct!.maxClosingFilesToBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_concurrent_file_parts: {
      value: cdktf.numberToHclTerraform(struct!.maxConcurrentFileParts),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_file_idle_time_sec: {
      value: cdktf.numberToHclTerraform(struct!.maxFileIdleTimeSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_file_open_time_sec: {
      value: cdktf.numberToHclTerraform(struct!.maxFileOpenTimeSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_file_size_mb: {
      value: cdktf.numberToHclTerraform(struct!.maxFileSizeMb),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_open_files: {
      value: cdktf.numberToHclTerraform(struct!.maxOpenFiles),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_retry_num: {
      value: cdktf.numberToHclTerraform(struct!.maxRetryNum),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    object_acl: {
      value: cdktf.stringToHclTerraform(struct!.objectAcl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.onBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    on_disk_full_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.onDiskFullBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    parquet_data_page_version: {
      value: cdktf.stringToHclTerraform(struct!.parquetDataPageVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    parquet_page_size: {
      value: cdktf.stringToHclTerraform(struct!.parquetPageSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    parquet_row_group_length: {
      value: cdktf.numberToHclTerraform(struct!.parquetRowGroupLength),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    parquet_version: {
      value: cdktf.stringToHclTerraform(struct!.parquetVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    partition_expr: {
      value: cdktf.stringToHclTerraform(struct!.partitionExpr),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    region: {
      value: cdktf.stringToHclTerraform(struct!.region),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reject_unauthorized: {
      value: cdktf.booleanToHclTerraform(struct!.rejectUnauthorized),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    remove_empty_dirs: {
      value: cdktf.booleanToHclTerraform(struct!.removeEmptyDirs),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    reuse_connections: {
      value: cdktf.booleanToHclTerraform(struct!.reuseConnections),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    server_side_encryption: {
      value: cdktf.stringToHclTerraform(struct!.serverSideEncryption),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    should_log_invalid_rows: {
      value: cdktf.booleanToHclTerraform(struct!.shouldLogInvalidRows),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    signature_version: {
      value: cdktf.stringToHclTerraform(struct!.signatureVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    stage_path: {
      value: cdktf.stringToHclTerraform(struct!.stagePath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    storage_class: {
      value: cdktf.stringToHclTerraform(struct!.storageClass),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    system_fields: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.systemFields),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    verify_permissions: {
      value: cdktf.booleanToHclTerraform(struct!.verifyPermissions),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    write_high_water_mark: {
      value: cdktf.numberToHclTerraform(struct!.writeHighWaterMark),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputS3OutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackDestinationOutputS3 | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._addIdToStagePath !== undefined) {
      hasAnyValues = true;
      internalValueResult.addIdToStagePath = this._addIdToStagePath;
    }
    if (this._assumeRoleArn !== undefined) {
      hasAnyValues = true;
      internalValueResult.assumeRoleArn = this._assumeRoleArn;
    }
    if (this._assumeRoleExternalId !== undefined) {
      hasAnyValues = true;
      internalValueResult.assumeRoleExternalId = this._assumeRoleExternalId;
    }
    if (this._automaticSchema !== undefined) {
      hasAnyValues = true;
      internalValueResult.automaticSchema = this._automaticSchema;
    }
    if (this._awsApiKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.awsApiKey = this._awsApiKey;
    }
    if (this._awsAuthenticationMethod !== undefined) {
      hasAnyValues = true;
      internalValueResult.awsAuthenticationMethod = this._awsAuthenticationMethod;
    }
    if (this._awsSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.awsSecret = this._awsSecret;
    }
    if (this._awsSecretKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.awsSecretKey = this._awsSecretKey;
    }
    if (this._baseFileName !== undefined) {
      hasAnyValues = true;
      internalValueResult.baseFileName = this._baseFileName;
    }
    if (this._bucket !== undefined) {
      hasAnyValues = true;
      internalValueResult.bucket = this._bucket;
    }
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._compressionLevel !== undefined) {
      hasAnyValues = true;
      internalValueResult.compressionLevel = this._compressionLevel;
    }
    if (this._deadletterEnabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.deadletterEnabled = this._deadletterEnabled;
    }
    if (this._deadletterPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.deadletterPath = this._deadletterPath;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._destPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.destPath = this._destPath;
    }
    if (this._durationSeconds !== undefined) {
      hasAnyValues = true;
      internalValueResult.durationSeconds = this._durationSeconds;
    }
    if (this._emptyDirCleanupSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.emptyDirCleanupSec = this._emptyDirCleanupSec;
    }
    if (this._enableAssumeRole !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableAssumeRole = this._enableAssumeRole;
    }
    if (this._enablePageChecksum !== undefined) {
      hasAnyValues = true;
      internalValueResult.enablePageChecksum = this._enablePageChecksum;
    }
    if (this._enableStatistics !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableStatistics = this._enableStatistics;
    }
    if (this._enableWritePageIndex !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableWritePageIndex = this._enableWritePageIndex;
    }
    if (this._endpoint !== undefined) {
      hasAnyValues = true;
      internalValueResult.endpoint = this._endpoint;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._fileNameSuffix !== undefined) {
      hasAnyValues = true;
      internalValueResult.fileNameSuffix = this._fileNameSuffix;
    }
    if (this._format !== undefined) {
      hasAnyValues = true;
      internalValueResult.format = this._format;
    }
    if (this._headerLine !== undefined) {
      hasAnyValues = true;
      internalValueResult.headerLine = this._headerLine;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._keyValueMetadata?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.keyValueMetadata = this._keyValueMetadata?.internalValue;
    }
    if (this._kmsKeyId !== undefined) {
      hasAnyValues = true;
      internalValueResult.kmsKeyId = this._kmsKeyId;
    }
    if (this._maxClosingFilesToBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxClosingFilesToBackpressure = this._maxClosingFilesToBackpressure;
    }
    if (this._maxConcurrentFileParts !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxConcurrentFileParts = this._maxConcurrentFileParts;
    }
    if (this._maxFileIdleTimeSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxFileIdleTimeSec = this._maxFileIdleTimeSec;
    }
    if (this._maxFileOpenTimeSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxFileOpenTimeSec = this._maxFileOpenTimeSec;
    }
    if (this._maxFileSizeMb !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxFileSizeMb = this._maxFileSizeMb;
    }
    if (this._maxOpenFiles !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxOpenFiles = this._maxOpenFiles;
    }
    if (this._maxRetryNum !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxRetryNum = this._maxRetryNum;
    }
    if (this._objectAcl !== undefined) {
      hasAnyValues = true;
      internalValueResult.objectAcl = this._objectAcl;
    }
    if (this._onBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.onBackpressure = this._onBackpressure;
    }
    if (this._onDiskFullBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.onDiskFullBackpressure = this._onDiskFullBackpressure;
    }
    if (this._parquetDataPageVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.parquetDataPageVersion = this._parquetDataPageVersion;
    }
    if (this._parquetPageSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.parquetPageSize = this._parquetPageSize;
    }
    if (this._parquetRowGroupLength !== undefined) {
      hasAnyValues = true;
      internalValueResult.parquetRowGroupLength = this._parquetRowGroupLength;
    }
    if (this._parquetVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.parquetVersion = this._parquetVersion;
    }
    if (this._partitionExpr !== undefined) {
      hasAnyValues = true;
      internalValueResult.partitionExpr = this._partitionExpr;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._region !== undefined) {
      hasAnyValues = true;
      internalValueResult.region = this._region;
    }
    if (this._rejectUnauthorized !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectUnauthorized = this._rejectUnauthorized;
    }
    if (this._removeEmptyDirs !== undefined) {
      hasAnyValues = true;
      internalValueResult.removeEmptyDirs = this._removeEmptyDirs;
    }
    if (this._reuseConnections !== undefined) {
      hasAnyValues = true;
      internalValueResult.reuseConnections = this._reuseConnections;
    }
    if (this._serverSideEncryption !== undefined) {
      hasAnyValues = true;
      internalValueResult.serverSideEncryption = this._serverSideEncryption;
    }
    if (this._shouldLogInvalidRows !== undefined) {
      hasAnyValues = true;
      internalValueResult.shouldLogInvalidRows = this._shouldLogInvalidRows;
    }
    if (this._signatureVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.signatureVersion = this._signatureVersion;
    }
    if (this._stagePath !== undefined) {
      hasAnyValues = true;
      internalValueResult.stagePath = this._stagePath;
    }
    if (this._storageClass !== undefined) {
      hasAnyValues = true;
      internalValueResult.storageClass = this._storageClass;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._systemFields !== undefined) {
      hasAnyValues = true;
      internalValueResult.systemFields = this._systemFields;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._verifyPermissions !== undefined) {
      hasAnyValues = true;
      internalValueResult.verifyPermissions = this._verifyPermissions;
    }
    if (this._writeHighWaterMark !== undefined) {
      hasAnyValues = true;
      internalValueResult.writeHighWaterMark = this._writeHighWaterMark;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputS3 | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._addIdToStagePath = undefined;
      this._assumeRoleArn = undefined;
      this._assumeRoleExternalId = undefined;
      this._automaticSchema = undefined;
      this._awsApiKey = undefined;
      this._awsAuthenticationMethod = undefined;
      this._awsSecret = undefined;
      this._awsSecretKey = undefined;
      this._baseFileName = undefined;
      this._bucket = undefined;
      this._compress = undefined;
      this._compressionLevel = undefined;
      this._deadletterEnabled = undefined;
      this._deadletterPath = undefined;
      this._description = undefined;
      this._destPath = undefined;
      this._durationSeconds = undefined;
      this._emptyDirCleanupSec = undefined;
      this._enableAssumeRole = undefined;
      this._enablePageChecksum = undefined;
      this._enableStatistics = undefined;
      this._enableWritePageIndex = undefined;
      this._endpoint = undefined;
      this._environment = undefined;
      this._fileNameSuffix = undefined;
      this._format = undefined;
      this._headerLine = undefined;
      this._id = undefined;
      this._keyValueMetadata.internalValue = undefined;
      this._kmsKeyId = undefined;
      this._maxClosingFilesToBackpressure = undefined;
      this._maxConcurrentFileParts = undefined;
      this._maxFileIdleTimeSec = undefined;
      this._maxFileOpenTimeSec = undefined;
      this._maxFileSizeMb = undefined;
      this._maxOpenFiles = undefined;
      this._maxRetryNum = undefined;
      this._objectAcl = undefined;
      this._onBackpressure = undefined;
      this._onDiskFullBackpressure = undefined;
      this._parquetDataPageVersion = undefined;
      this._parquetPageSize = undefined;
      this._parquetRowGroupLength = undefined;
      this._parquetVersion = undefined;
      this._partitionExpr = undefined;
      this._pipeline = undefined;
      this._region = undefined;
      this._rejectUnauthorized = undefined;
      this._removeEmptyDirs = undefined;
      this._reuseConnections = undefined;
      this._serverSideEncryption = undefined;
      this._shouldLogInvalidRows = undefined;
      this._signatureVersion = undefined;
      this._stagePath = undefined;
      this._storageClass = undefined;
      this._streamtags = undefined;
      this._systemFields = undefined;
      this._type = undefined;
      this._verifyPermissions = undefined;
      this._writeHighWaterMark = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._addIdToStagePath = value.addIdToStagePath;
      this._assumeRoleArn = value.assumeRoleArn;
      this._assumeRoleExternalId = value.assumeRoleExternalId;
      this._automaticSchema = value.automaticSchema;
      this._awsApiKey = value.awsApiKey;
      this._awsAuthenticationMethod = value.awsAuthenticationMethod;
      this._awsSecret = value.awsSecret;
      this._awsSecretKey = value.awsSecretKey;
      this._baseFileName = value.baseFileName;
      this._bucket = value.bucket;
      this._compress = value.compress;
      this._compressionLevel = value.compressionLevel;
      this._deadletterEnabled = value.deadletterEnabled;
      this._deadletterPath = value.deadletterPath;
      this._description = value.description;
      this._destPath = value.destPath;
      this._durationSeconds = value.durationSeconds;
      this._emptyDirCleanupSec = value.emptyDirCleanupSec;
      this._enableAssumeRole = value.enableAssumeRole;
      this._enablePageChecksum = value.enablePageChecksum;
      this._enableStatistics = value.enableStatistics;
      this._enableWritePageIndex = value.enableWritePageIndex;
      this._endpoint = value.endpoint;
      this._environment = value.environment;
      this._fileNameSuffix = value.fileNameSuffix;
      this._format = value.format;
      this._headerLine = value.headerLine;
      this._id = value.id;
      this._keyValueMetadata.internalValue = value.keyValueMetadata;
      this._kmsKeyId = value.kmsKeyId;
      this._maxClosingFilesToBackpressure = value.maxClosingFilesToBackpressure;
      this._maxConcurrentFileParts = value.maxConcurrentFileParts;
      this._maxFileIdleTimeSec = value.maxFileIdleTimeSec;
      this._maxFileOpenTimeSec = value.maxFileOpenTimeSec;
      this._maxFileSizeMb = value.maxFileSizeMb;
      this._maxOpenFiles = value.maxOpenFiles;
      this._maxRetryNum = value.maxRetryNum;
      this._objectAcl = value.objectAcl;
      this._onBackpressure = value.onBackpressure;
      this._onDiskFullBackpressure = value.onDiskFullBackpressure;
      this._parquetDataPageVersion = value.parquetDataPageVersion;
      this._parquetPageSize = value.parquetPageSize;
      this._parquetRowGroupLength = value.parquetRowGroupLength;
      this._parquetVersion = value.parquetVersion;
      this._partitionExpr = value.partitionExpr;
      this._pipeline = value.pipeline;
      this._region = value.region;
      this._rejectUnauthorized = value.rejectUnauthorized;
      this._removeEmptyDirs = value.removeEmptyDirs;
      this._reuseConnections = value.reuseConnections;
      this._serverSideEncryption = value.serverSideEncryption;
      this._shouldLogInvalidRows = value.shouldLogInvalidRows;
      this._signatureVersion = value.signatureVersion;
      this._stagePath = value.stagePath;
      this._storageClass = value.storageClass;
      this._streamtags = value.streamtags;
      this._systemFields = value.systemFields;
      this._type = value.type;
      this._verifyPermissions = value.verifyPermissions;
      this._writeHighWaterMark = value.writeHighWaterMark;
    }
  }

  // add_id_to_stage_path - computed: true, optional: true, required: false
  private _addIdToStagePath?: boolean | cdktf.IResolvable; 
  public get addIdToStagePath() {
    return this.getBooleanAttribute('add_id_to_stage_path');
  }
  public set addIdToStagePath(value: boolean | cdktf.IResolvable) {
    this._addIdToStagePath = value;
  }
  public resetAddIdToStagePath() {
    this._addIdToStagePath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addIdToStagePathInput() {
    return this._addIdToStagePath;
  }

  // assume_role_arn - computed: false, optional: true, required: false
  private _assumeRoleArn?: string; 
  public get assumeRoleArn() {
    return this.getStringAttribute('assume_role_arn');
  }
  public set assumeRoleArn(value: string) {
    this._assumeRoleArn = value;
  }
  public resetAssumeRoleArn() {
    this._assumeRoleArn = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get assumeRoleArnInput() {
    return this._assumeRoleArn;
  }

  // assume_role_external_id - computed: false, optional: true, required: false
  private _assumeRoleExternalId?: string; 
  public get assumeRoleExternalId() {
    return this.getStringAttribute('assume_role_external_id');
  }
  public set assumeRoleExternalId(value: string) {
    this._assumeRoleExternalId = value;
  }
  public resetAssumeRoleExternalId() {
    this._assumeRoleExternalId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get assumeRoleExternalIdInput() {
    return this._assumeRoleExternalId;
  }

  // automatic_schema - computed: true, optional: true, required: false
  private _automaticSchema?: boolean | cdktf.IResolvable; 
  public get automaticSchema() {
    return this.getBooleanAttribute('automatic_schema');
  }
  public set automaticSchema(value: boolean | cdktf.IResolvable) {
    this._automaticSchema = value;
  }
  public resetAutomaticSchema() {
    this._automaticSchema = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get automaticSchemaInput() {
    return this._automaticSchema;
  }

  // aws_api_key - computed: false, optional: true, required: false
  private _awsApiKey?: string; 
  public get awsApiKey() {
    return this.getStringAttribute('aws_api_key');
  }
  public set awsApiKey(value: string) {
    this._awsApiKey = value;
  }
  public resetAwsApiKey() {
    this._awsApiKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsApiKeyInput() {
    return this._awsApiKey;
  }

  // aws_authentication_method - computed: true, optional: true, required: false
  private _awsAuthenticationMethod?: string; 
  public get awsAuthenticationMethod() {
    return this.getStringAttribute('aws_authentication_method');
  }
  public set awsAuthenticationMethod(value: string) {
    this._awsAuthenticationMethod = value;
  }
  public resetAwsAuthenticationMethod() {
    this._awsAuthenticationMethod = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsAuthenticationMethodInput() {
    return this._awsAuthenticationMethod;
  }

  // aws_secret - computed: false, optional: true, required: false
  private _awsSecret?: string; 
  public get awsSecret() {
    return this.getStringAttribute('aws_secret');
  }
  public set awsSecret(value: string) {
    this._awsSecret = value;
  }
  public resetAwsSecret() {
    this._awsSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsSecretInput() {
    return this._awsSecret;
  }

  // aws_secret_key - computed: false, optional: true, required: false
  private _awsSecretKey?: string; 
  public get awsSecretKey() {
    return this.getStringAttribute('aws_secret_key');
  }
  public set awsSecretKey(value: string) {
    this._awsSecretKey = value;
  }
  public resetAwsSecretKey() {
    this._awsSecretKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsSecretKeyInput() {
    return this._awsSecretKey;
  }

  // base_file_name - computed: true, optional: true, required: false
  private _baseFileName?: string; 
  public get baseFileName() {
    return this.getStringAttribute('base_file_name');
  }
  public set baseFileName(value: string) {
    this._baseFileName = value;
  }
  public resetBaseFileName() {
    this._baseFileName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get baseFileNameInput() {
    return this._baseFileName;
  }

  // bucket - computed: false, optional: false, required: true
  private _bucket?: string; 
  public get bucket() {
    return this.getStringAttribute('bucket');
  }
  public set bucket(value: string) {
    this._bucket = value;
  }
  // Temporarily expose input value. Use with caution.
  public get bucketInput() {
    return this._bucket;
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: string; 
  public get compress() {
    return this.getStringAttribute('compress');
  }
  public set compress(value: string) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // compression_level - computed: true, optional: true, required: false
  private _compressionLevel?: string; 
  public get compressionLevel() {
    return this.getStringAttribute('compression_level');
  }
  public set compressionLevel(value: string) {
    this._compressionLevel = value;
  }
  public resetCompressionLevel() {
    this._compressionLevel = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressionLevelInput() {
    return this._compressionLevel;
  }

  // deadletter_enabled - computed: true, optional: true, required: false
  private _deadletterEnabled?: boolean | cdktf.IResolvable; 
  public get deadletterEnabled() {
    return this.getBooleanAttribute('deadletter_enabled');
  }
  public set deadletterEnabled(value: boolean | cdktf.IResolvable) {
    this._deadletterEnabled = value;
  }
  public resetDeadletterEnabled() {
    this._deadletterEnabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get deadletterEnabledInput() {
    return this._deadletterEnabled;
  }

  // deadletter_path - computed: true, optional: true, required: false
  private _deadletterPath?: string; 
  public get deadletterPath() {
    return this.getStringAttribute('deadletter_path');
  }
  public set deadletterPath(value: string) {
    this._deadletterPath = value;
  }
  public resetDeadletterPath() {
    this._deadletterPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get deadletterPathInput() {
    return this._deadletterPath;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // dest_path - computed: true, optional: true, required: false
  private _destPath?: string; 
  public get destPath() {
    return this.getStringAttribute('dest_path');
  }
  public set destPath(value: string) {
    this._destPath = value;
  }
  public resetDestPath() {
    this._destPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get destPathInput() {
    return this._destPath;
  }

  // duration_seconds - computed: true, optional: true, required: false
  private _durationSeconds?: number; 
  public get durationSeconds() {
    return this.getNumberAttribute('duration_seconds');
  }
  public set durationSeconds(value: number) {
    this._durationSeconds = value;
  }
  public resetDurationSeconds() {
    this._durationSeconds = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get durationSecondsInput() {
    return this._durationSeconds;
  }

  // empty_dir_cleanup_sec - computed: true, optional: true, required: false
  private _emptyDirCleanupSec?: number; 
  public get emptyDirCleanupSec() {
    return this.getNumberAttribute('empty_dir_cleanup_sec');
  }
  public set emptyDirCleanupSec(value: number) {
    this._emptyDirCleanupSec = value;
  }
  public resetEmptyDirCleanupSec() {
    this._emptyDirCleanupSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get emptyDirCleanupSecInput() {
    return this._emptyDirCleanupSec;
  }

  // enable_assume_role - computed: true, optional: true, required: false
  private _enableAssumeRole?: boolean | cdktf.IResolvable; 
  public get enableAssumeRole() {
    return this.getBooleanAttribute('enable_assume_role');
  }
  public set enableAssumeRole(value: boolean | cdktf.IResolvable) {
    this._enableAssumeRole = value;
  }
  public resetEnableAssumeRole() {
    this._enableAssumeRole = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableAssumeRoleInput() {
    return this._enableAssumeRole;
  }

  // enable_page_checksum - computed: true, optional: true, required: false
  private _enablePageChecksum?: boolean | cdktf.IResolvable; 
  public get enablePageChecksum() {
    return this.getBooleanAttribute('enable_page_checksum');
  }
  public set enablePageChecksum(value: boolean | cdktf.IResolvable) {
    this._enablePageChecksum = value;
  }
  public resetEnablePageChecksum() {
    this._enablePageChecksum = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enablePageChecksumInput() {
    return this._enablePageChecksum;
  }

  // enable_statistics - computed: true, optional: true, required: false
  private _enableStatistics?: boolean | cdktf.IResolvable; 
  public get enableStatistics() {
    return this.getBooleanAttribute('enable_statistics');
  }
  public set enableStatistics(value: boolean | cdktf.IResolvable) {
    this._enableStatistics = value;
  }
  public resetEnableStatistics() {
    this._enableStatistics = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableStatisticsInput() {
    return this._enableStatistics;
  }

  // enable_write_page_index - computed: true, optional: true, required: false
  private _enableWritePageIndex?: boolean | cdktf.IResolvable; 
  public get enableWritePageIndex() {
    return this.getBooleanAttribute('enable_write_page_index');
  }
  public set enableWritePageIndex(value: boolean | cdktf.IResolvable) {
    this._enableWritePageIndex = value;
  }
  public resetEnableWritePageIndex() {
    this._enableWritePageIndex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableWritePageIndexInput() {
    return this._enableWritePageIndex;
  }

  // endpoint - computed: false, optional: true, required: false
  private _endpoint?: string; 
  public get endpoint() {
    return this.getStringAttribute('endpoint');
  }
  public set endpoint(value: string) {
    this._endpoint = value;
  }
  public resetEndpoint() {
    this._endpoint = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get endpointInput() {
    return this._endpoint;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // file_name_suffix - computed: true, optional: true, required: false
  private _fileNameSuffix?: string; 
  public get fileNameSuffix() {
    return this.getStringAttribute('file_name_suffix');
  }
  public set fileNameSuffix(value: string) {
    this._fileNameSuffix = value;
  }
  public resetFileNameSuffix() {
    this._fileNameSuffix = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fileNameSuffixInput() {
    return this._fileNameSuffix;
  }

  // format - computed: true, optional: true, required: false
  private _format?: string; 
  public get format() {
    return this.getStringAttribute('format');
  }
  public set format(value: string) {
    this._format = value;
  }
  public resetFormat() {
    this._format = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get formatInput() {
    return this._format;
  }

  // header_line - computed: true, optional: true, required: false
  private _headerLine?: string; 
  public get headerLine() {
    return this.getStringAttribute('header_line');
  }
  public set headerLine(value: string) {
    this._headerLine = value;
  }
  public resetHeaderLine() {
    this._headerLine = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get headerLineInput() {
    return this._headerLine;
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // key_value_metadata - computed: false, optional: true, required: false
  private _keyValueMetadata = new PackDestinationOutputS3KeyValueMetadataList(this, "key_value_metadata", false);
  public get keyValueMetadata() {
    return this._keyValueMetadata;
  }
  public putKeyValueMetadata(value: PackDestinationOutputS3KeyValueMetadata[] | cdktf.IResolvable) {
    this._keyValueMetadata.internalValue = value;
  }
  public resetKeyValueMetadata() {
    this._keyValueMetadata.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyValueMetadataInput() {
    return this._keyValueMetadata.internalValue;
  }

  // kms_key_id - computed: false, optional: true, required: false
  private _kmsKeyId?: string; 
  public get kmsKeyId() {
    return this.getStringAttribute('kms_key_id');
  }
  public set kmsKeyId(value: string) {
    this._kmsKeyId = value;
  }
  public resetKmsKeyId() {
    this._kmsKeyId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get kmsKeyIdInput() {
    return this._kmsKeyId;
  }

  // max_closing_files_to_backpressure - computed: true, optional: true, required: false
  private _maxClosingFilesToBackpressure?: number; 
  public get maxClosingFilesToBackpressure() {
    return this.getNumberAttribute('max_closing_files_to_backpressure');
  }
  public set maxClosingFilesToBackpressure(value: number) {
    this._maxClosingFilesToBackpressure = value;
  }
  public resetMaxClosingFilesToBackpressure() {
    this._maxClosingFilesToBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxClosingFilesToBackpressureInput() {
    return this._maxClosingFilesToBackpressure;
  }

  // max_concurrent_file_parts - computed: true, optional: true, required: false
  private _maxConcurrentFileParts?: number; 
  public get maxConcurrentFileParts() {
    return this.getNumberAttribute('max_concurrent_file_parts');
  }
  public set maxConcurrentFileParts(value: number) {
    this._maxConcurrentFileParts = value;
  }
  public resetMaxConcurrentFileParts() {
    this._maxConcurrentFileParts = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxConcurrentFilePartsInput() {
    return this._maxConcurrentFileParts;
  }

  // max_file_idle_time_sec - computed: true, optional: true, required: false
  private _maxFileIdleTimeSec?: number; 
  public get maxFileIdleTimeSec() {
    return this.getNumberAttribute('max_file_idle_time_sec');
  }
  public set maxFileIdleTimeSec(value: number) {
    this._maxFileIdleTimeSec = value;
  }
  public resetMaxFileIdleTimeSec() {
    this._maxFileIdleTimeSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxFileIdleTimeSecInput() {
    return this._maxFileIdleTimeSec;
  }

  // max_file_open_time_sec - computed: true, optional: true, required: false
  private _maxFileOpenTimeSec?: number; 
  public get maxFileOpenTimeSec() {
    return this.getNumberAttribute('max_file_open_time_sec');
  }
  public set maxFileOpenTimeSec(value: number) {
    this._maxFileOpenTimeSec = value;
  }
  public resetMaxFileOpenTimeSec() {
    this._maxFileOpenTimeSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxFileOpenTimeSecInput() {
    return this._maxFileOpenTimeSec;
  }

  // max_file_size_mb - computed: true, optional: true, required: false
  private _maxFileSizeMb?: number; 
  public get maxFileSizeMb() {
    return this.getNumberAttribute('max_file_size_mb');
  }
  public set maxFileSizeMb(value: number) {
    this._maxFileSizeMb = value;
  }
  public resetMaxFileSizeMb() {
    this._maxFileSizeMb = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxFileSizeMbInput() {
    return this._maxFileSizeMb;
  }

  // max_open_files - computed: true, optional: true, required: false
  private _maxOpenFiles?: number; 
  public get maxOpenFiles() {
    return this.getNumberAttribute('max_open_files');
  }
  public set maxOpenFiles(value: number) {
    this._maxOpenFiles = value;
  }
  public resetMaxOpenFiles() {
    this._maxOpenFiles = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxOpenFilesInput() {
    return this._maxOpenFiles;
  }

  // max_retry_num - computed: true, optional: true, required: false
  private _maxRetryNum?: number; 
  public get maxRetryNum() {
    return this.getNumberAttribute('max_retry_num');
  }
  public set maxRetryNum(value: number) {
    this._maxRetryNum = value;
  }
  public resetMaxRetryNum() {
    this._maxRetryNum = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxRetryNumInput() {
    return this._maxRetryNum;
  }

  // object_acl - computed: true, optional: true, required: false
  private _objectAcl?: string; 
  public get objectAcl() {
    return this.getStringAttribute('object_acl');
  }
  public set objectAcl(value: string) {
    this._objectAcl = value;
  }
  public resetObjectAcl() {
    this._objectAcl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get objectAclInput() {
    return this._objectAcl;
  }

  // on_backpressure - computed: true, optional: true, required: false
  private _onBackpressure?: string; 
  public get onBackpressure() {
    return this.getStringAttribute('on_backpressure');
  }
  public set onBackpressure(value: string) {
    this._onBackpressure = value;
  }
  public resetOnBackpressure() {
    this._onBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get onBackpressureInput() {
    return this._onBackpressure;
  }

  // on_disk_full_backpressure - computed: true, optional: true, required: false
  private _onDiskFullBackpressure?: string; 
  public get onDiskFullBackpressure() {
    return this.getStringAttribute('on_disk_full_backpressure');
  }
  public set onDiskFullBackpressure(value: string) {
    this._onDiskFullBackpressure = value;
  }
  public resetOnDiskFullBackpressure() {
    this._onDiskFullBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get onDiskFullBackpressureInput() {
    return this._onDiskFullBackpressure;
  }

  // parquet_data_page_version - computed: true, optional: true, required: false
  private _parquetDataPageVersion?: string; 
  public get parquetDataPageVersion() {
    return this.getStringAttribute('parquet_data_page_version');
  }
  public set parquetDataPageVersion(value: string) {
    this._parquetDataPageVersion = value;
  }
  public resetParquetDataPageVersion() {
    this._parquetDataPageVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get parquetDataPageVersionInput() {
    return this._parquetDataPageVersion;
  }

  // parquet_page_size - computed: true, optional: true, required: false
  private _parquetPageSize?: string; 
  public get parquetPageSize() {
    return this.getStringAttribute('parquet_page_size');
  }
  public set parquetPageSize(value: string) {
    this._parquetPageSize = value;
  }
  public resetParquetPageSize() {
    this._parquetPageSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get parquetPageSizeInput() {
    return this._parquetPageSize;
  }

  // parquet_row_group_length - computed: true, optional: true, required: false
  private _parquetRowGroupLength?: number; 
  public get parquetRowGroupLength() {
    return this.getNumberAttribute('parquet_row_group_length');
  }
  public set parquetRowGroupLength(value: number) {
    this._parquetRowGroupLength = value;
  }
  public resetParquetRowGroupLength() {
    this._parquetRowGroupLength = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get parquetRowGroupLengthInput() {
    return this._parquetRowGroupLength;
  }

  // parquet_version - computed: true, optional: true, required: false
  private _parquetVersion?: string; 
  public get parquetVersion() {
    return this.getStringAttribute('parquet_version');
  }
  public set parquetVersion(value: string) {
    this._parquetVersion = value;
  }
  public resetParquetVersion() {
    this._parquetVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get parquetVersionInput() {
    return this._parquetVersion;
  }

  // partition_expr - computed: true, optional: true, required: false
  private _partitionExpr?: string; 
  public get partitionExpr() {
    return this.getStringAttribute('partition_expr');
  }
  public set partitionExpr(value: string) {
    this._partitionExpr = value;
  }
  public resetPartitionExpr() {
    this._partitionExpr = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get partitionExprInput() {
    return this._partitionExpr;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // region - computed: false, optional: true, required: false
  private _region?: string; 
  public get region() {
    return this.getStringAttribute('region');
  }
  public set region(value: string) {
    this._region = value;
  }
  public resetRegion() {
    this._region = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get regionInput() {
    return this._region;
  }

  // reject_unauthorized - computed: true, optional: true, required: false
  private _rejectUnauthorized?: boolean | cdktf.IResolvable; 
  public get rejectUnauthorized() {
    return this.getBooleanAttribute('reject_unauthorized');
  }
  public set rejectUnauthorized(value: boolean | cdktf.IResolvable) {
    this._rejectUnauthorized = value;
  }
  public resetRejectUnauthorized() {
    this._rejectUnauthorized = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectUnauthorizedInput() {
    return this._rejectUnauthorized;
  }

  // remove_empty_dirs - computed: true, optional: true, required: false
  private _removeEmptyDirs?: boolean | cdktf.IResolvable; 
  public get removeEmptyDirs() {
    return this.getBooleanAttribute('remove_empty_dirs');
  }
  public set removeEmptyDirs(value: boolean | cdktf.IResolvable) {
    this._removeEmptyDirs = value;
  }
  public resetRemoveEmptyDirs() {
    this._removeEmptyDirs = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get removeEmptyDirsInput() {
    return this._removeEmptyDirs;
  }

  // reuse_connections - computed: true, optional: true, required: false
  private _reuseConnections?: boolean | cdktf.IResolvable; 
  public get reuseConnections() {
    return this.getBooleanAttribute('reuse_connections');
  }
  public set reuseConnections(value: boolean | cdktf.IResolvable) {
    this._reuseConnections = value;
  }
  public resetReuseConnections() {
    this._reuseConnections = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get reuseConnectionsInput() {
    return this._reuseConnections;
  }

  // server_side_encryption - computed: false, optional: true, required: false
  private _serverSideEncryption?: string; 
  public get serverSideEncryption() {
    return this.getStringAttribute('server_side_encryption');
  }
  public set serverSideEncryption(value: string) {
    this._serverSideEncryption = value;
  }
  public resetServerSideEncryption() {
    this._serverSideEncryption = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serverSideEncryptionInput() {
    return this._serverSideEncryption;
  }

  // should_log_invalid_rows - computed: false, optional: true, required: false
  private _shouldLogInvalidRows?: boolean | cdktf.IResolvable; 
  public get shouldLogInvalidRows() {
    return this.getBooleanAttribute('should_log_invalid_rows');
  }
  public set shouldLogInvalidRows(value: boolean | cdktf.IResolvable) {
    this._shouldLogInvalidRows = value;
  }
  public resetShouldLogInvalidRows() {
    this._shouldLogInvalidRows = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get shouldLogInvalidRowsInput() {
    return this._shouldLogInvalidRows;
  }

  // signature_version - computed: true, optional: true, required: false
  private _signatureVersion?: string; 
  public get signatureVersion() {
    return this.getStringAttribute('signature_version');
  }
  public set signatureVersion(value: string) {
    this._signatureVersion = value;
  }
  public resetSignatureVersion() {
    this._signatureVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get signatureVersionInput() {
    return this._signatureVersion;
  }

  // stage_path - computed: true, optional: true, required: false
  private _stagePath?: string; 
  public get stagePath() {
    return this.getStringAttribute('stage_path');
  }
  public set stagePath(value: string) {
    this._stagePath = value;
  }
  public resetStagePath() {
    this._stagePath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get stagePathInput() {
    return this._stagePath;
  }

  // storage_class - computed: false, optional: true, required: false
  private _storageClass?: string; 
  public get storageClass() {
    return this.getStringAttribute('storage_class');
  }
  public set storageClass(value: string) {
    this._storageClass = value;
  }
  public resetStorageClass() {
    this._storageClass = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get storageClassInput() {
    return this._storageClass;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // system_fields - computed: true, optional: true, required: false
  private _systemFields?: string[]; 
  public get systemFields() {
    return this.getListAttribute('system_fields');
  }
  public set systemFields(value: string[]) {
    this._systemFields = value;
  }
  public resetSystemFields() {
    this._systemFields = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get systemFieldsInput() {
    return this._systemFields;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // verify_permissions - computed: true, optional: true, required: false
  private _verifyPermissions?: boolean | cdktf.IResolvable; 
  public get verifyPermissions() {
    return this.getBooleanAttribute('verify_permissions');
  }
  public set verifyPermissions(value: boolean | cdktf.IResolvable) {
    this._verifyPermissions = value;
  }
  public resetVerifyPermissions() {
    this._verifyPermissions = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get verifyPermissionsInput() {
    return this._verifyPermissions;
  }

  // write_high_water_mark - computed: true, optional: true, required: false
  private _writeHighWaterMark?: number; 
  public get writeHighWaterMark() {
    return this.getNumberAttribute('write_high_water_mark');
  }
  public set writeHighWaterMark(value: number) {
    this._writeHighWaterMark = value;
  }
  public resetWriteHighWaterMark() {
    this._writeHighWaterMark = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get writeHighWaterMarkInput() {
    return this._writeHighWaterMark;
  }
}
export interface PackDestinationOutputSecurityLakeKeyValueMetadata {
  /**
  * Default: ""
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#key PackDestination#key}
  */
  readonly key?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#value PackDestination#value}
  */
  readonly value: string;
}

export function packDestinationOutputSecurityLakeKeyValueMetadataToTerraform(struct?: PackDestinationOutputSecurityLakeKeyValueMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function packDestinationOutputSecurityLakeKeyValueMetadataToHclTerraform(struct?: PackDestinationOutputSecurityLakeKeyValueMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputSecurityLakeKeyValueMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackDestinationOutputSecurityLakeKeyValueMetadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputSecurityLakeKeyValueMetadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._value = value.value;
    }
  }

  // key - computed: true, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class PackDestinationOutputSecurityLakeKeyValueMetadataList extends cdktf.ComplexList {
  public internalValue? : PackDestinationOutputSecurityLakeKeyValueMetadata[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackDestinationOutputSecurityLakeKeyValueMetadataOutputReference {
    return new PackDestinationOutputSecurityLakeKeyValueMetadataOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackDestinationOutputSecurityLake {
  /**
  * ID of the AWS account whose data the Destination will write to Security Lake. This should have been configured when creating the Amazon Security Lake custom source.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#account_id PackDestination#account_id}
  */
  readonly accountId: string;
  /**
  * Add the Output ID value to staging location. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#add_id_to_stage_path PackDestination#add_id_to_stage_path}
  */
  readonly addIdToStagePath?: boolean | cdktf.IResolvable;
  /**
  * Amazon Resource Name (ARN) of the role to assume
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#assume_role_arn PackDestination#assume_role_arn}
  */
  readonly assumeRoleArn: string;
  /**
  * External ID to use when assuming role
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#assume_role_external_id PackDestination#assume_role_external_id}
  */
  readonly assumeRoleExternalId?: string;
  /**
  * Automatically calculate the schema based on the events of each Parquet file generated. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#automatic_schema PackDestination#automatic_schema}
  */
  readonly automaticSchema?: boolean | cdktf.IResolvable;
  /**
  * This value can be a constant or a JavaScript expression (`${C.env.SOME_ACCESS_KEY}`)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#aws_api_key PackDestination#aws_api_key}
  */
  readonly awsApiKey?: string;
  /**
  * AWS authentication method. Choose Auto to use IAM roles. Default: "auto"; must be one of ["auto", "manual", "secret"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#aws_authentication_method PackDestination#aws_authentication_method}
  */
  readonly awsAuthenticationMethod?: string;
  /**
  * Select or create a stored secret that references your access key and secret key
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#aws_secret PackDestination#aws_secret}
  */
  readonly awsSecret?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#aws_secret_key PackDestination#aws_secret_key}
  */
  readonly awsSecretKey?: string;
  /**
  * JavaScript expression to define the output filename prefix (can be constant). Default: "`CriblOut`"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#base_file_name PackDestination#base_file_name}
  */
  readonly baseFileName?: string;
  /**
  * Name of the destination S3 bucket. Must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can be evaluated only at initialization time. Example referencing a Global Variable: `myBucket-${C.vars.myVar}`
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#bucket PackDestination#bucket}
  */
  readonly bucket: string;
  /**
  * Name of the custom source configured in Amazon Security Lake
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#custom_source PackDestination#custom_source}
  */
  readonly customSource: string;
  /**
  * If a file fails to move to its final destination after the maximum number of retries, move it to a designated directory to prevent further errors. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#deadletter_enabled PackDestination#deadletter_enabled}
  */
  readonly deadletterEnabled?: boolean | cdktf.IResolvable;
  /**
  * Storage location for files that fail to reach their final destination after maximum retries are exceeded. Default: "$CRIBL_HOME/state/outputs/dead-letter"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#deadletter_path PackDestination#deadletter_path}
  */
  readonly deadletterPath?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#description PackDestination#description}
  */
  readonly description?: string;
  /**
  * Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours). Default: 3600
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#duration_seconds PackDestination#duration_seconds}
  */
  readonly durationSeconds?: number;
  /**
  * How frequently, in seconds, to clean up empty directories. Default: 300
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#empty_dir_cleanup_sec PackDestination#empty_dir_cleanup_sec}
  */
  readonly emptyDirCleanupSec?: number;
  /**
  * Use Assume Role credentials to access S3. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#enable_assume_role PackDestination#enable_assume_role}
  */
  readonly enableAssumeRole?: boolean | cdktf.IResolvable;
  /**
  * Parquet tools can use the checksum of a Parquet page to verify data integrity. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#enable_page_checksum PackDestination#enable_page_checksum}
  */
  readonly enablePageChecksum?: boolean | cdktf.IResolvable;
  /**
  * Statistics profile an entire file in terms of minimum/maximum values within data, numbers of nulls, etc. You can use Parquet tools to view statistics. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#enable_statistics PackDestination#enable_statistics}
  */
  readonly enableStatistics?: boolean | cdktf.IResolvable;
  /**
  * One page index contains statistics for one data page. Parquet readers use statistics to enable page skipping. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#enable_write_page_index PackDestination#enable_write_page_index}
  */
  readonly enableWritePageIndex?: boolean | cdktf.IResolvable;
  /**
  * Amazon Security Lake service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to Amazon Security Lake-compatible endpoint.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#endpoint PackDestination#endpoint}
  */
  readonly endpoint?: string;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#environment PackDestination#environment}
  */
  readonly environment?: string;
  /**
  * If set, this line will be written to the beginning of each output file. Default: ""
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#header_line PackDestination#header_line}
  */
  readonly headerLine?: string;
  /**
  * Unique ID for this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#id PackDestination#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * The metadata of files the Destination writes will include the properties you add here as key-value pairs. Useful for tagging. Examples: "key":"OCSF Event Class", "value":"9001"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#key_value_metadata PackDestination#key_value_metadata}
  */
  readonly keyValueMetadata?: PackDestinationOutputSecurityLakeKeyValueMetadata[] | cdktf.IResolvable;
  /**
  * ID or ARN of the KMS customer-managed key to use for encryption
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#kms_key_id PackDestination#kms_key_id}
  */
  readonly kmsKeyId?: string;
  /**
  * Maximum number of files that can be waiting for upload before backpressure is applied. Default: 100
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_closing_files_to_backpressure PackDestination#max_closing_files_to_backpressure}
  */
  readonly maxClosingFilesToBackpressure?: number;
  /**
  * Maximum number of parts to upload in parallel per file. Minimum part size is 5MB. Default: 4
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_concurrent_file_parts PackDestination#max_concurrent_file_parts}
  */
  readonly maxConcurrentFileParts?: number;
  /**
  * Maximum amount of time to keep inactive files open. Files open for longer than this will be closed and moved to final output location. Default: 30
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_file_idle_time_sec PackDestination#max_file_idle_time_sec}
  */
  readonly maxFileIdleTimeSec?: number;
  /**
  * Maximum amount of time to write to a file. Files open for longer than this will be closed and moved to final output location. Default: 300
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_file_open_time_sec PackDestination#max_file_open_time_sec}
  */
  readonly maxFileOpenTimeSec?: number;
  /**
  * Maximum uncompressed output file size. Files of this size will be closed and moved to final output location. Default: 32
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_file_size_mb PackDestination#max_file_size_mb}
  */
  readonly maxFileSizeMb?: number;
  /**
  * Maximum number of files to keep open concurrently. When exceeded, @{product} will close the oldest open files and move them to the final output location. Default: 100
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_open_files PackDestination#max_open_files}
  */
  readonly maxOpenFiles?: number;
  /**
  * The maximum number of times a file will attempt to move to its final destination before being dead-lettered. Default: 20
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_retry_num PackDestination#max_retry_num}
  */
  readonly maxRetryNum?: number;
  /**
  * Object ACL to assign to uploaded objects. Default: "private"; must be one of ["private", "public-read", "public-read-write", "authenticated-read", "aws-exec-read", "bucket-owner-read", "bucket-owner-full-control"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#object_acl PackDestination#object_acl}
  */
  readonly objectAcl?: string;
  /**
  * How to handle events when all receivers are exerting backpressure. Default: "block"; must be one of ["block", "drop"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#on_backpressure PackDestination#on_backpressure}
  */
  readonly onBackpressure?: string;
  /**
  * How to handle events when disk space is below the global 'Min free disk space' limit. Default: "block"; must be one of ["block", "drop"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#on_disk_full_backpressure PackDestination#on_disk_full_backpressure}
  */
  readonly onDiskFullBackpressure?: string;
  /**
  * Serialization format of data pages. Note that some reader implementations use Data page V2's attributes to work more efficiently, while others ignore it. Default: "DATA_PAGE_V2"; must be one of ["DATA_PAGE_V1", "DATA_PAGE_V2"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#parquet_data_page_version PackDestination#parquet_data_page_version}
  */
  readonly parquetDataPageVersion?: string;
  /**
  * Target memory size for page segments, such as 1MB or 128MB. Generally, lower values improve reading speed, while higher values improve compression. Default: "1MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#parquet_page_size PackDestination#parquet_page_size}
  */
  readonly parquetPageSize?: string;
  /**
  * The number of rows that every group will contain. The final group can contain a smaller number of rows. Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#parquet_row_group_length PackDestination#parquet_row_group_length}
  */
  readonly parquetRowGroupLength?: number;
  /**
  * To add a new schema, navigate to Processing > Knowledge > Parquet Schemas
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#parquet_schema PackDestination#parquet_schema}
  */
  readonly parquetSchema?: string;
  /**
  * Determines which data types are supported and how they are represented. Default: "PARQUET_2_6"; must be one of ["PARQUET_1_0", "PARQUET_2_4", "PARQUET_2_6"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#parquet_version PackDestination#parquet_version}
  */
  readonly parquetVersion?: string;
  /**
  * Pipeline to process data before sending out to this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pipeline PackDestination#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Region where the Amazon Security Lake is located.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#region PackDestination#region}
  */
  readonly region: string;
  /**
  * Reject certificates that cannot be verified against a valid CA, such as self-signed certificates. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#reject_unauthorized PackDestination#reject_unauthorized}
  */
  readonly rejectUnauthorized?: boolean | cdktf.IResolvable;
  /**
  * Remove empty staging directories after moving files. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#remove_empty_dirs PackDestination#remove_empty_dirs}
  */
  readonly removeEmptyDirs?: boolean | cdktf.IResolvable;
  /**
  * Reuse connections between requests, which can improve performance. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#reuse_connections PackDestination#reuse_connections}
  */
  readonly reuseConnections?: boolean | cdktf.IResolvable;
  /**
  * must be one of ["AES256", "aws:kms"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#server_side_encryption PackDestination#server_side_encryption}
  */
  readonly serverSideEncryption?: string;
  /**
  * Log up to 3 rows that @{product} skips due to data mismatch
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#should_log_invalid_rows PackDestination#should_log_invalid_rows}
  */
  readonly shouldLogInvalidRows?: boolean | cdktf.IResolvable;
  /**
  * Signature version to use for signing Amazon Security Lake requests. Default: "v4"; must be one of ["v2", "v4"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#signature_version PackDestination#signature_version}
  */
  readonly signatureVersion?: string;
  /**
  * Filesystem location in which to buffer files, before compressing and moving to final destination. Use performant and stable storage. Default: "$CRIBL_HOME/state/outputs/staging"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#stage_path PackDestination#stage_path}
  */
  readonly stagePath?: string;
  /**
  * Storage class to select for uploaded objects. must be one of ["STANDARD", "REDUCED_REDUNDANCY", "STANDARD_IA", "ONEZONE_IA", "INTELLIGENT_TIERING", "GLACIER", "GLACIER_IR", "DEEP_ARCHIVE"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#storage_class PackDestination#storage_class}
  */
  readonly storageClass?: string;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#streamtags PackDestination#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Fields to automatically add to events, such as cribl_pipe. Supports wildcards. These fields are added as dimensions and labels to generated metrics and logs, respectively. Default: ["cribl_pipe"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#system_fields PackDestination#system_fields}
  */
  readonly systemFields?: string[];
  /**
  * must be "security_lake"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#type PackDestination#type}
  */
  readonly type?: string;
  /**
  * Disable if you can access files within the bucket but not the bucket itself. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#verify_permissions PackDestination#verify_permissions}
  */
  readonly verifyPermissions?: boolean | cdktf.IResolvable;
  /**
  * Buffer size used to write to a file. Default: 64
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#write_high_water_mark PackDestination#write_high_water_mark}
  */
  readonly writeHighWaterMark?: number;
}

export function packDestinationOutputSecurityLakeToTerraform(struct?: PackDestinationOutputSecurityLake | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    account_id: cdktf.stringToTerraform(struct!.accountId),
    add_id_to_stage_path: cdktf.booleanToTerraform(struct!.addIdToStagePath),
    assume_role_arn: cdktf.stringToTerraform(struct!.assumeRoleArn),
    assume_role_external_id: cdktf.stringToTerraform(struct!.assumeRoleExternalId),
    automatic_schema: cdktf.booleanToTerraform(struct!.automaticSchema),
    aws_api_key: cdktf.stringToTerraform(struct!.awsApiKey),
    aws_authentication_method: cdktf.stringToTerraform(struct!.awsAuthenticationMethod),
    aws_secret: cdktf.stringToTerraform(struct!.awsSecret),
    aws_secret_key: cdktf.stringToTerraform(struct!.awsSecretKey),
    base_file_name: cdktf.stringToTerraform(struct!.baseFileName),
    bucket: cdktf.stringToTerraform(struct!.bucket),
    custom_source: cdktf.stringToTerraform(struct!.customSource),
    deadletter_enabled: cdktf.booleanToTerraform(struct!.deadletterEnabled),
    deadletter_path: cdktf.stringToTerraform(struct!.deadletterPath),
    description: cdktf.stringToTerraform(struct!.description),
    duration_seconds: cdktf.numberToTerraform(struct!.durationSeconds),
    empty_dir_cleanup_sec: cdktf.numberToTerraform(struct!.emptyDirCleanupSec),
    enable_assume_role: cdktf.booleanToTerraform(struct!.enableAssumeRole),
    enable_page_checksum: cdktf.booleanToTerraform(struct!.enablePageChecksum),
    enable_statistics: cdktf.booleanToTerraform(struct!.enableStatistics),
    enable_write_page_index: cdktf.booleanToTerraform(struct!.enableWritePageIndex),
    endpoint: cdktf.stringToTerraform(struct!.endpoint),
    environment: cdktf.stringToTerraform(struct!.environment),
    header_line: cdktf.stringToTerraform(struct!.headerLine),
    id: cdktf.stringToTerraform(struct!.id),
    key_value_metadata: cdktf.listMapper(packDestinationOutputSecurityLakeKeyValueMetadataToTerraform, false)(struct!.keyValueMetadata),
    kms_key_id: cdktf.stringToTerraform(struct!.kmsKeyId),
    max_closing_files_to_backpressure: cdktf.numberToTerraform(struct!.maxClosingFilesToBackpressure),
    max_concurrent_file_parts: cdktf.numberToTerraform(struct!.maxConcurrentFileParts),
    max_file_idle_time_sec: cdktf.numberToTerraform(struct!.maxFileIdleTimeSec),
    max_file_open_time_sec: cdktf.numberToTerraform(struct!.maxFileOpenTimeSec),
    max_file_size_mb: cdktf.numberToTerraform(struct!.maxFileSizeMb),
    max_open_files: cdktf.numberToTerraform(struct!.maxOpenFiles),
    max_retry_num: cdktf.numberToTerraform(struct!.maxRetryNum),
    object_acl: cdktf.stringToTerraform(struct!.objectAcl),
    on_backpressure: cdktf.stringToTerraform(struct!.onBackpressure),
    on_disk_full_backpressure: cdktf.stringToTerraform(struct!.onDiskFullBackpressure),
    parquet_data_page_version: cdktf.stringToTerraform(struct!.parquetDataPageVersion),
    parquet_page_size: cdktf.stringToTerraform(struct!.parquetPageSize),
    parquet_row_group_length: cdktf.numberToTerraform(struct!.parquetRowGroupLength),
    parquet_schema: cdktf.stringToTerraform(struct!.parquetSchema),
    parquet_version: cdktf.stringToTerraform(struct!.parquetVersion),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    region: cdktf.stringToTerraform(struct!.region),
    reject_unauthorized: cdktf.booleanToTerraform(struct!.rejectUnauthorized),
    remove_empty_dirs: cdktf.booleanToTerraform(struct!.removeEmptyDirs),
    reuse_connections: cdktf.booleanToTerraform(struct!.reuseConnections),
    server_side_encryption: cdktf.stringToTerraform(struct!.serverSideEncryption),
    should_log_invalid_rows: cdktf.booleanToTerraform(struct!.shouldLogInvalidRows),
    signature_version: cdktf.stringToTerraform(struct!.signatureVersion),
    stage_path: cdktf.stringToTerraform(struct!.stagePath),
    storage_class: cdktf.stringToTerraform(struct!.storageClass),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    system_fields: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.systemFields),
    type: cdktf.stringToTerraform(struct!.type),
    verify_permissions: cdktf.booleanToTerraform(struct!.verifyPermissions),
    write_high_water_mark: cdktf.numberToTerraform(struct!.writeHighWaterMark),
  }
}


export function packDestinationOutputSecurityLakeToHclTerraform(struct?: PackDestinationOutputSecurityLake | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    account_id: {
      value: cdktf.stringToHclTerraform(struct!.accountId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    add_id_to_stage_path: {
      value: cdktf.booleanToHclTerraform(struct!.addIdToStagePath),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    assume_role_arn: {
      value: cdktf.stringToHclTerraform(struct!.assumeRoleArn),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    assume_role_external_id: {
      value: cdktf.stringToHclTerraform(struct!.assumeRoleExternalId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    automatic_schema: {
      value: cdktf.booleanToHclTerraform(struct!.automaticSchema),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    aws_api_key: {
      value: cdktf.stringToHclTerraform(struct!.awsApiKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    aws_authentication_method: {
      value: cdktf.stringToHclTerraform(struct!.awsAuthenticationMethod),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    aws_secret: {
      value: cdktf.stringToHclTerraform(struct!.awsSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    aws_secret_key: {
      value: cdktf.stringToHclTerraform(struct!.awsSecretKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    base_file_name: {
      value: cdktf.stringToHclTerraform(struct!.baseFileName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    bucket: {
      value: cdktf.stringToHclTerraform(struct!.bucket),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    custom_source: {
      value: cdktf.stringToHclTerraform(struct!.customSource),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    deadletter_enabled: {
      value: cdktf.booleanToHclTerraform(struct!.deadletterEnabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    deadletter_path: {
      value: cdktf.stringToHclTerraform(struct!.deadletterPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    duration_seconds: {
      value: cdktf.numberToHclTerraform(struct!.durationSeconds),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    empty_dir_cleanup_sec: {
      value: cdktf.numberToHclTerraform(struct!.emptyDirCleanupSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    enable_assume_role: {
      value: cdktf.booleanToHclTerraform(struct!.enableAssumeRole),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    enable_page_checksum: {
      value: cdktf.booleanToHclTerraform(struct!.enablePageChecksum),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    enable_statistics: {
      value: cdktf.booleanToHclTerraform(struct!.enableStatistics),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    enable_write_page_index: {
      value: cdktf.booleanToHclTerraform(struct!.enableWritePageIndex),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    endpoint: {
      value: cdktf.stringToHclTerraform(struct!.endpoint),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    header_line: {
      value: cdktf.stringToHclTerraform(struct!.headerLine),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    key_value_metadata: {
      value: cdktf.listMapperHcl(packDestinationOutputSecurityLakeKeyValueMetadataToHclTerraform, false)(struct!.keyValueMetadata),
      isBlock: true,
      type: "list",
      storageClassType: "PackDestinationOutputSecurityLakeKeyValueMetadataList",
    },
    kms_key_id: {
      value: cdktf.stringToHclTerraform(struct!.kmsKeyId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_closing_files_to_backpressure: {
      value: cdktf.numberToHclTerraform(struct!.maxClosingFilesToBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_concurrent_file_parts: {
      value: cdktf.numberToHclTerraform(struct!.maxConcurrentFileParts),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_file_idle_time_sec: {
      value: cdktf.numberToHclTerraform(struct!.maxFileIdleTimeSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_file_open_time_sec: {
      value: cdktf.numberToHclTerraform(struct!.maxFileOpenTimeSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_file_size_mb: {
      value: cdktf.numberToHclTerraform(struct!.maxFileSizeMb),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_open_files: {
      value: cdktf.numberToHclTerraform(struct!.maxOpenFiles),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_retry_num: {
      value: cdktf.numberToHclTerraform(struct!.maxRetryNum),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    object_acl: {
      value: cdktf.stringToHclTerraform(struct!.objectAcl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.onBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    on_disk_full_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.onDiskFullBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    parquet_data_page_version: {
      value: cdktf.stringToHclTerraform(struct!.parquetDataPageVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    parquet_page_size: {
      value: cdktf.stringToHclTerraform(struct!.parquetPageSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    parquet_row_group_length: {
      value: cdktf.numberToHclTerraform(struct!.parquetRowGroupLength),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    parquet_schema: {
      value: cdktf.stringToHclTerraform(struct!.parquetSchema),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    parquet_version: {
      value: cdktf.stringToHclTerraform(struct!.parquetVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    region: {
      value: cdktf.stringToHclTerraform(struct!.region),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reject_unauthorized: {
      value: cdktf.booleanToHclTerraform(struct!.rejectUnauthorized),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    remove_empty_dirs: {
      value: cdktf.booleanToHclTerraform(struct!.removeEmptyDirs),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    reuse_connections: {
      value: cdktf.booleanToHclTerraform(struct!.reuseConnections),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    server_side_encryption: {
      value: cdktf.stringToHclTerraform(struct!.serverSideEncryption),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    should_log_invalid_rows: {
      value: cdktf.booleanToHclTerraform(struct!.shouldLogInvalidRows),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    signature_version: {
      value: cdktf.stringToHclTerraform(struct!.signatureVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    stage_path: {
      value: cdktf.stringToHclTerraform(struct!.stagePath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    storage_class: {
      value: cdktf.stringToHclTerraform(struct!.storageClass),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    system_fields: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.systemFields),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    verify_permissions: {
      value: cdktf.booleanToHclTerraform(struct!.verifyPermissions),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    write_high_water_mark: {
      value: cdktf.numberToHclTerraform(struct!.writeHighWaterMark),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputSecurityLakeOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackDestinationOutputSecurityLake | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._accountId !== undefined) {
      hasAnyValues = true;
      internalValueResult.accountId = this._accountId;
    }
    if (this._addIdToStagePath !== undefined) {
      hasAnyValues = true;
      internalValueResult.addIdToStagePath = this._addIdToStagePath;
    }
    if (this._assumeRoleArn !== undefined) {
      hasAnyValues = true;
      internalValueResult.assumeRoleArn = this._assumeRoleArn;
    }
    if (this._assumeRoleExternalId !== undefined) {
      hasAnyValues = true;
      internalValueResult.assumeRoleExternalId = this._assumeRoleExternalId;
    }
    if (this._automaticSchema !== undefined) {
      hasAnyValues = true;
      internalValueResult.automaticSchema = this._automaticSchema;
    }
    if (this._awsApiKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.awsApiKey = this._awsApiKey;
    }
    if (this._awsAuthenticationMethod !== undefined) {
      hasAnyValues = true;
      internalValueResult.awsAuthenticationMethod = this._awsAuthenticationMethod;
    }
    if (this._awsSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.awsSecret = this._awsSecret;
    }
    if (this._awsSecretKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.awsSecretKey = this._awsSecretKey;
    }
    if (this._baseFileName !== undefined) {
      hasAnyValues = true;
      internalValueResult.baseFileName = this._baseFileName;
    }
    if (this._bucket !== undefined) {
      hasAnyValues = true;
      internalValueResult.bucket = this._bucket;
    }
    if (this._customSource !== undefined) {
      hasAnyValues = true;
      internalValueResult.customSource = this._customSource;
    }
    if (this._deadletterEnabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.deadletterEnabled = this._deadletterEnabled;
    }
    if (this._deadletterPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.deadletterPath = this._deadletterPath;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._durationSeconds !== undefined) {
      hasAnyValues = true;
      internalValueResult.durationSeconds = this._durationSeconds;
    }
    if (this._emptyDirCleanupSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.emptyDirCleanupSec = this._emptyDirCleanupSec;
    }
    if (this._enableAssumeRole !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableAssumeRole = this._enableAssumeRole;
    }
    if (this._enablePageChecksum !== undefined) {
      hasAnyValues = true;
      internalValueResult.enablePageChecksum = this._enablePageChecksum;
    }
    if (this._enableStatistics !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableStatistics = this._enableStatistics;
    }
    if (this._enableWritePageIndex !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableWritePageIndex = this._enableWritePageIndex;
    }
    if (this._endpoint !== undefined) {
      hasAnyValues = true;
      internalValueResult.endpoint = this._endpoint;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._headerLine !== undefined) {
      hasAnyValues = true;
      internalValueResult.headerLine = this._headerLine;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._keyValueMetadata?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.keyValueMetadata = this._keyValueMetadata?.internalValue;
    }
    if (this._kmsKeyId !== undefined) {
      hasAnyValues = true;
      internalValueResult.kmsKeyId = this._kmsKeyId;
    }
    if (this._maxClosingFilesToBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxClosingFilesToBackpressure = this._maxClosingFilesToBackpressure;
    }
    if (this._maxConcurrentFileParts !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxConcurrentFileParts = this._maxConcurrentFileParts;
    }
    if (this._maxFileIdleTimeSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxFileIdleTimeSec = this._maxFileIdleTimeSec;
    }
    if (this._maxFileOpenTimeSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxFileOpenTimeSec = this._maxFileOpenTimeSec;
    }
    if (this._maxFileSizeMb !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxFileSizeMb = this._maxFileSizeMb;
    }
    if (this._maxOpenFiles !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxOpenFiles = this._maxOpenFiles;
    }
    if (this._maxRetryNum !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxRetryNum = this._maxRetryNum;
    }
    if (this._objectAcl !== undefined) {
      hasAnyValues = true;
      internalValueResult.objectAcl = this._objectAcl;
    }
    if (this._onBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.onBackpressure = this._onBackpressure;
    }
    if (this._onDiskFullBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.onDiskFullBackpressure = this._onDiskFullBackpressure;
    }
    if (this._parquetDataPageVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.parquetDataPageVersion = this._parquetDataPageVersion;
    }
    if (this._parquetPageSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.parquetPageSize = this._parquetPageSize;
    }
    if (this._parquetRowGroupLength !== undefined) {
      hasAnyValues = true;
      internalValueResult.parquetRowGroupLength = this._parquetRowGroupLength;
    }
    if (this._parquetSchema !== undefined) {
      hasAnyValues = true;
      internalValueResult.parquetSchema = this._parquetSchema;
    }
    if (this._parquetVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.parquetVersion = this._parquetVersion;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._region !== undefined) {
      hasAnyValues = true;
      internalValueResult.region = this._region;
    }
    if (this._rejectUnauthorized !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectUnauthorized = this._rejectUnauthorized;
    }
    if (this._removeEmptyDirs !== undefined) {
      hasAnyValues = true;
      internalValueResult.removeEmptyDirs = this._removeEmptyDirs;
    }
    if (this._reuseConnections !== undefined) {
      hasAnyValues = true;
      internalValueResult.reuseConnections = this._reuseConnections;
    }
    if (this._serverSideEncryption !== undefined) {
      hasAnyValues = true;
      internalValueResult.serverSideEncryption = this._serverSideEncryption;
    }
    if (this._shouldLogInvalidRows !== undefined) {
      hasAnyValues = true;
      internalValueResult.shouldLogInvalidRows = this._shouldLogInvalidRows;
    }
    if (this._signatureVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.signatureVersion = this._signatureVersion;
    }
    if (this._stagePath !== undefined) {
      hasAnyValues = true;
      internalValueResult.stagePath = this._stagePath;
    }
    if (this._storageClass !== undefined) {
      hasAnyValues = true;
      internalValueResult.storageClass = this._storageClass;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._systemFields !== undefined) {
      hasAnyValues = true;
      internalValueResult.systemFields = this._systemFields;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._verifyPermissions !== undefined) {
      hasAnyValues = true;
      internalValueResult.verifyPermissions = this._verifyPermissions;
    }
    if (this._writeHighWaterMark !== undefined) {
      hasAnyValues = true;
      internalValueResult.writeHighWaterMark = this._writeHighWaterMark;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputSecurityLake | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._accountId = undefined;
      this._addIdToStagePath = undefined;
      this._assumeRoleArn = undefined;
      this._assumeRoleExternalId = undefined;
      this._automaticSchema = undefined;
      this._awsApiKey = undefined;
      this._awsAuthenticationMethod = undefined;
      this._awsSecret = undefined;
      this._awsSecretKey = undefined;
      this._baseFileName = undefined;
      this._bucket = undefined;
      this._customSource = undefined;
      this._deadletterEnabled = undefined;
      this._deadletterPath = undefined;
      this._description = undefined;
      this._durationSeconds = undefined;
      this._emptyDirCleanupSec = undefined;
      this._enableAssumeRole = undefined;
      this._enablePageChecksum = undefined;
      this._enableStatistics = undefined;
      this._enableWritePageIndex = undefined;
      this._endpoint = undefined;
      this._environment = undefined;
      this._headerLine = undefined;
      this._id = undefined;
      this._keyValueMetadata.internalValue = undefined;
      this._kmsKeyId = undefined;
      this._maxClosingFilesToBackpressure = undefined;
      this._maxConcurrentFileParts = undefined;
      this._maxFileIdleTimeSec = undefined;
      this._maxFileOpenTimeSec = undefined;
      this._maxFileSizeMb = undefined;
      this._maxOpenFiles = undefined;
      this._maxRetryNum = undefined;
      this._objectAcl = undefined;
      this._onBackpressure = undefined;
      this._onDiskFullBackpressure = undefined;
      this._parquetDataPageVersion = undefined;
      this._parquetPageSize = undefined;
      this._parquetRowGroupLength = undefined;
      this._parquetSchema = undefined;
      this._parquetVersion = undefined;
      this._pipeline = undefined;
      this._region = undefined;
      this._rejectUnauthorized = undefined;
      this._removeEmptyDirs = undefined;
      this._reuseConnections = undefined;
      this._serverSideEncryption = undefined;
      this._shouldLogInvalidRows = undefined;
      this._signatureVersion = undefined;
      this._stagePath = undefined;
      this._storageClass = undefined;
      this._streamtags = undefined;
      this._systemFields = undefined;
      this._type = undefined;
      this._verifyPermissions = undefined;
      this._writeHighWaterMark = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._accountId = value.accountId;
      this._addIdToStagePath = value.addIdToStagePath;
      this._assumeRoleArn = value.assumeRoleArn;
      this._assumeRoleExternalId = value.assumeRoleExternalId;
      this._automaticSchema = value.automaticSchema;
      this._awsApiKey = value.awsApiKey;
      this._awsAuthenticationMethod = value.awsAuthenticationMethod;
      this._awsSecret = value.awsSecret;
      this._awsSecretKey = value.awsSecretKey;
      this._baseFileName = value.baseFileName;
      this._bucket = value.bucket;
      this._customSource = value.customSource;
      this._deadletterEnabled = value.deadletterEnabled;
      this._deadletterPath = value.deadletterPath;
      this._description = value.description;
      this._durationSeconds = value.durationSeconds;
      this._emptyDirCleanupSec = value.emptyDirCleanupSec;
      this._enableAssumeRole = value.enableAssumeRole;
      this._enablePageChecksum = value.enablePageChecksum;
      this._enableStatistics = value.enableStatistics;
      this._enableWritePageIndex = value.enableWritePageIndex;
      this._endpoint = value.endpoint;
      this._environment = value.environment;
      this._headerLine = value.headerLine;
      this._id = value.id;
      this._keyValueMetadata.internalValue = value.keyValueMetadata;
      this._kmsKeyId = value.kmsKeyId;
      this._maxClosingFilesToBackpressure = value.maxClosingFilesToBackpressure;
      this._maxConcurrentFileParts = value.maxConcurrentFileParts;
      this._maxFileIdleTimeSec = value.maxFileIdleTimeSec;
      this._maxFileOpenTimeSec = value.maxFileOpenTimeSec;
      this._maxFileSizeMb = value.maxFileSizeMb;
      this._maxOpenFiles = value.maxOpenFiles;
      this._maxRetryNum = value.maxRetryNum;
      this._objectAcl = value.objectAcl;
      this._onBackpressure = value.onBackpressure;
      this._onDiskFullBackpressure = value.onDiskFullBackpressure;
      this._parquetDataPageVersion = value.parquetDataPageVersion;
      this._parquetPageSize = value.parquetPageSize;
      this._parquetRowGroupLength = value.parquetRowGroupLength;
      this._parquetSchema = value.parquetSchema;
      this._parquetVersion = value.parquetVersion;
      this._pipeline = value.pipeline;
      this._region = value.region;
      this._rejectUnauthorized = value.rejectUnauthorized;
      this._removeEmptyDirs = value.removeEmptyDirs;
      this._reuseConnections = value.reuseConnections;
      this._serverSideEncryption = value.serverSideEncryption;
      this._shouldLogInvalidRows = value.shouldLogInvalidRows;
      this._signatureVersion = value.signatureVersion;
      this._stagePath = value.stagePath;
      this._storageClass = value.storageClass;
      this._streamtags = value.streamtags;
      this._systemFields = value.systemFields;
      this._type = value.type;
      this._verifyPermissions = value.verifyPermissions;
      this._writeHighWaterMark = value.writeHighWaterMark;
    }
  }

  // account_id - computed: false, optional: false, required: true
  private _accountId?: string; 
  public get accountId() {
    return this.getStringAttribute('account_id');
  }
  public set accountId(value: string) {
    this._accountId = value;
  }
  // Temporarily expose input value. Use with caution.
  public get accountIdInput() {
    return this._accountId;
  }

  // add_id_to_stage_path - computed: true, optional: true, required: false
  private _addIdToStagePath?: boolean | cdktf.IResolvable; 
  public get addIdToStagePath() {
    return this.getBooleanAttribute('add_id_to_stage_path');
  }
  public set addIdToStagePath(value: boolean | cdktf.IResolvable) {
    this._addIdToStagePath = value;
  }
  public resetAddIdToStagePath() {
    this._addIdToStagePath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addIdToStagePathInput() {
    return this._addIdToStagePath;
  }

  // assume_role_arn - computed: false, optional: false, required: true
  private _assumeRoleArn?: string; 
  public get assumeRoleArn() {
    return this.getStringAttribute('assume_role_arn');
  }
  public set assumeRoleArn(value: string) {
    this._assumeRoleArn = value;
  }
  // Temporarily expose input value. Use with caution.
  public get assumeRoleArnInput() {
    return this._assumeRoleArn;
  }

  // assume_role_external_id - computed: false, optional: true, required: false
  private _assumeRoleExternalId?: string; 
  public get assumeRoleExternalId() {
    return this.getStringAttribute('assume_role_external_id');
  }
  public set assumeRoleExternalId(value: string) {
    this._assumeRoleExternalId = value;
  }
  public resetAssumeRoleExternalId() {
    this._assumeRoleExternalId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get assumeRoleExternalIdInput() {
    return this._assumeRoleExternalId;
  }

  // automatic_schema - computed: true, optional: true, required: false
  private _automaticSchema?: boolean | cdktf.IResolvable; 
  public get automaticSchema() {
    return this.getBooleanAttribute('automatic_schema');
  }
  public set automaticSchema(value: boolean | cdktf.IResolvable) {
    this._automaticSchema = value;
  }
  public resetAutomaticSchema() {
    this._automaticSchema = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get automaticSchemaInput() {
    return this._automaticSchema;
  }

  // aws_api_key - computed: false, optional: true, required: false
  private _awsApiKey?: string; 
  public get awsApiKey() {
    return this.getStringAttribute('aws_api_key');
  }
  public set awsApiKey(value: string) {
    this._awsApiKey = value;
  }
  public resetAwsApiKey() {
    this._awsApiKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsApiKeyInput() {
    return this._awsApiKey;
  }

  // aws_authentication_method - computed: true, optional: true, required: false
  private _awsAuthenticationMethod?: string; 
  public get awsAuthenticationMethod() {
    return this.getStringAttribute('aws_authentication_method');
  }
  public set awsAuthenticationMethod(value: string) {
    this._awsAuthenticationMethod = value;
  }
  public resetAwsAuthenticationMethod() {
    this._awsAuthenticationMethod = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsAuthenticationMethodInput() {
    return this._awsAuthenticationMethod;
  }

  // aws_secret - computed: false, optional: true, required: false
  private _awsSecret?: string; 
  public get awsSecret() {
    return this.getStringAttribute('aws_secret');
  }
  public set awsSecret(value: string) {
    this._awsSecret = value;
  }
  public resetAwsSecret() {
    this._awsSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsSecretInput() {
    return this._awsSecret;
  }

  // aws_secret_key - computed: false, optional: true, required: false
  private _awsSecretKey?: string; 
  public get awsSecretKey() {
    return this.getStringAttribute('aws_secret_key');
  }
  public set awsSecretKey(value: string) {
    this._awsSecretKey = value;
  }
  public resetAwsSecretKey() {
    this._awsSecretKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsSecretKeyInput() {
    return this._awsSecretKey;
  }

  // base_file_name - computed: true, optional: true, required: false
  private _baseFileName?: string; 
  public get baseFileName() {
    return this.getStringAttribute('base_file_name');
  }
  public set baseFileName(value: string) {
    this._baseFileName = value;
  }
  public resetBaseFileName() {
    this._baseFileName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get baseFileNameInput() {
    return this._baseFileName;
  }

  // bucket - computed: false, optional: false, required: true
  private _bucket?: string; 
  public get bucket() {
    return this.getStringAttribute('bucket');
  }
  public set bucket(value: string) {
    this._bucket = value;
  }
  // Temporarily expose input value. Use with caution.
  public get bucketInput() {
    return this._bucket;
  }

  // custom_source - computed: false, optional: false, required: true
  private _customSource?: string; 
  public get customSource() {
    return this.getStringAttribute('custom_source');
  }
  public set customSource(value: string) {
    this._customSource = value;
  }
  // Temporarily expose input value. Use with caution.
  public get customSourceInput() {
    return this._customSource;
  }

  // deadletter_enabled - computed: true, optional: true, required: false
  private _deadletterEnabled?: boolean | cdktf.IResolvable; 
  public get deadletterEnabled() {
    return this.getBooleanAttribute('deadletter_enabled');
  }
  public set deadletterEnabled(value: boolean | cdktf.IResolvable) {
    this._deadletterEnabled = value;
  }
  public resetDeadletterEnabled() {
    this._deadletterEnabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get deadletterEnabledInput() {
    return this._deadletterEnabled;
  }

  // deadletter_path - computed: true, optional: true, required: false
  private _deadletterPath?: string; 
  public get deadletterPath() {
    return this.getStringAttribute('deadletter_path');
  }
  public set deadletterPath(value: string) {
    this._deadletterPath = value;
  }
  public resetDeadletterPath() {
    this._deadletterPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get deadletterPathInput() {
    return this._deadletterPath;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // duration_seconds - computed: true, optional: true, required: false
  private _durationSeconds?: number; 
  public get durationSeconds() {
    return this.getNumberAttribute('duration_seconds');
  }
  public set durationSeconds(value: number) {
    this._durationSeconds = value;
  }
  public resetDurationSeconds() {
    this._durationSeconds = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get durationSecondsInput() {
    return this._durationSeconds;
  }

  // empty_dir_cleanup_sec - computed: true, optional: true, required: false
  private _emptyDirCleanupSec?: number; 
  public get emptyDirCleanupSec() {
    return this.getNumberAttribute('empty_dir_cleanup_sec');
  }
  public set emptyDirCleanupSec(value: number) {
    this._emptyDirCleanupSec = value;
  }
  public resetEmptyDirCleanupSec() {
    this._emptyDirCleanupSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get emptyDirCleanupSecInput() {
    return this._emptyDirCleanupSec;
  }

  // enable_assume_role - computed: true, optional: true, required: false
  private _enableAssumeRole?: boolean | cdktf.IResolvable; 
  public get enableAssumeRole() {
    return this.getBooleanAttribute('enable_assume_role');
  }
  public set enableAssumeRole(value: boolean | cdktf.IResolvable) {
    this._enableAssumeRole = value;
  }
  public resetEnableAssumeRole() {
    this._enableAssumeRole = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableAssumeRoleInput() {
    return this._enableAssumeRole;
  }

  // enable_page_checksum - computed: true, optional: true, required: false
  private _enablePageChecksum?: boolean | cdktf.IResolvable; 
  public get enablePageChecksum() {
    return this.getBooleanAttribute('enable_page_checksum');
  }
  public set enablePageChecksum(value: boolean | cdktf.IResolvable) {
    this._enablePageChecksum = value;
  }
  public resetEnablePageChecksum() {
    this._enablePageChecksum = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enablePageChecksumInput() {
    return this._enablePageChecksum;
  }

  // enable_statistics - computed: true, optional: true, required: false
  private _enableStatistics?: boolean | cdktf.IResolvable; 
  public get enableStatistics() {
    return this.getBooleanAttribute('enable_statistics');
  }
  public set enableStatistics(value: boolean | cdktf.IResolvable) {
    this._enableStatistics = value;
  }
  public resetEnableStatistics() {
    this._enableStatistics = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableStatisticsInput() {
    return this._enableStatistics;
  }

  // enable_write_page_index - computed: true, optional: true, required: false
  private _enableWritePageIndex?: boolean | cdktf.IResolvable; 
  public get enableWritePageIndex() {
    return this.getBooleanAttribute('enable_write_page_index');
  }
  public set enableWritePageIndex(value: boolean | cdktf.IResolvable) {
    this._enableWritePageIndex = value;
  }
  public resetEnableWritePageIndex() {
    this._enableWritePageIndex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableWritePageIndexInput() {
    return this._enableWritePageIndex;
  }

  // endpoint - computed: false, optional: true, required: false
  private _endpoint?: string; 
  public get endpoint() {
    return this.getStringAttribute('endpoint');
  }
  public set endpoint(value: string) {
    this._endpoint = value;
  }
  public resetEndpoint() {
    this._endpoint = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get endpointInput() {
    return this._endpoint;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // header_line - computed: true, optional: true, required: false
  private _headerLine?: string; 
  public get headerLine() {
    return this.getStringAttribute('header_line');
  }
  public set headerLine(value: string) {
    this._headerLine = value;
  }
  public resetHeaderLine() {
    this._headerLine = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get headerLineInput() {
    return this._headerLine;
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // key_value_metadata - computed: false, optional: true, required: false
  private _keyValueMetadata = new PackDestinationOutputSecurityLakeKeyValueMetadataList(this, "key_value_metadata", false);
  public get keyValueMetadata() {
    return this._keyValueMetadata;
  }
  public putKeyValueMetadata(value: PackDestinationOutputSecurityLakeKeyValueMetadata[] | cdktf.IResolvable) {
    this._keyValueMetadata.internalValue = value;
  }
  public resetKeyValueMetadata() {
    this._keyValueMetadata.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyValueMetadataInput() {
    return this._keyValueMetadata.internalValue;
  }

  // kms_key_id - computed: false, optional: true, required: false
  private _kmsKeyId?: string; 
  public get kmsKeyId() {
    return this.getStringAttribute('kms_key_id');
  }
  public set kmsKeyId(value: string) {
    this._kmsKeyId = value;
  }
  public resetKmsKeyId() {
    this._kmsKeyId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get kmsKeyIdInput() {
    return this._kmsKeyId;
  }

  // max_closing_files_to_backpressure - computed: true, optional: true, required: false
  private _maxClosingFilesToBackpressure?: number; 
  public get maxClosingFilesToBackpressure() {
    return this.getNumberAttribute('max_closing_files_to_backpressure');
  }
  public set maxClosingFilesToBackpressure(value: number) {
    this._maxClosingFilesToBackpressure = value;
  }
  public resetMaxClosingFilesToBackpressure() {
    this._maxClosingFilesToBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxClosingFilesToBackpressureInput() {
    return this._maxClosingFilesToBackpressure;
  }

  // max_concurrent_file_parts - computed: true, optional: true, required: false
  private _maxConcurrentFileParts?: number; 
  public get maxConcurrentFileParts() {
    return this.getNumberAttribute('max_concurrent_file_parts');
  }
  public set maxConcurrentFileParts(value: number) {
    this._maxConcurrentFileParts = value;
  }
  public resetMaxConcurrentFileParts() {
    this._maxConcurrentFileParts = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxConcurrentFilePartsInput() {
    return this._maxConcurrentFileParts;
  }

  // max_file_idle_time_sec - computed: true, optional: true, required: false
  private _maxFileIdleTimeSec?: number; 
  public get maxFileIdleTimeSec() {
    return this.getNumberAttribute('max_file_idle_time_sec');
  }
  public set maxFileIdleTimeSec(value: number) {
    this._maxFileIdleTimeSec = value;
  }
  public resetMaxFileIdleTimeSec() {
    this._maxFileIdleTimeSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxFileIdleTimeSecInput() {
    return this._maxFileIdleTimeSec;
  }

  // max_file_open_time_sec - computed: true, optional: true, required: false
  private _maxFileOpenTimeSec?: number; 
  public get maxFileOpenTimeSec() {
    return this.getNumberAttribute('max_file_open_time_sec');
  }
  public set maxFileOpenTimeSec(value: number) {
    this._maxFileOpenTimeSec = value;
  }
  public resetMaxFileOpenTimeSec() {
    this._maxFileOpenTimeSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxFileOpenTimeSecInput() {
    return this._maxFileOpenTimeSec;
  }

  // max_file_size_mb - computed: true, optional: true, required: false
  private _maxFileSizeMb?: number; 
  public get maxFileSizeMb() {
    return this.getNumberAttribute('max_file_size_mb');
  }
  public set maxFileSizeMb(value: number) {
    this._maxFileSizeMb = value;
  }
  public resetMaxFileSizeMb() {
    this._maxFileSizeMb = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxFileSizeMbInput() {
    return this._maxFileSizeMb;
  }

  // max_open_files - computed: true, optional: true, required: false
  private _maxOpenFiles?: number; 
  public get maxOpenFiles() {
    return this.getNumberAttribute('max_open_files');
  }
  public set maxOpenFiles(value: number) {
    this._maxOpenFiles = value;
  }
  public resetMaxOpenFiles() {
    this._maxOpenFiles = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxOpenFilesInput() {
    return this._maxOpenFiles;
  }

  // max_retry_num - computed: true, optional: true, required: false
  private _maxRetryNum?: number; 
  public get maxRetryNum() {
    return this.getNumberAttribute('max_retry_num');
  }
  public set maxRetryNum(value: number) {
    this._maxRetryNum = value;
  }
  public resetMaxRetryNum() {
    this._maxRetryNum = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxRetryNumInput() {
    return this._maxRetryNum;
  }

  // object_acl - computed: true, optional: true, required: false
  private _objectAcl?: string; 
  public get objectAcl() {
    return this.getStringAttribute('object_acl');
  }
  public set objectAcl(value: string) {
    this._objectAcl = value;
  }
  public resetObjectAcl() {
    this._objectAcl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get objectAclInput() {
    return this._objectAcl;
  }

  // on_backpressure - computed: true, optional: true, required: false
  private _onBackpressure?: string; 
  public get onBackpressure() {
    return this.getStringAttribute('on_backpressure');
  }
  public set onBackpressure(value: string) {
    this._onBackpressure = value;
  }
  public resetOnBackpressure() {
    this._onBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get onBackpressureInput() {
    return this._onBackpressure;
  }

  // on_disk_full_backpressure - computed: true, optional: true, required: false
  private _onDiskFullBackpressure?: string; 
  public get onDiskFullBackpressure() {
    return this.getStringAttribute('on_disk_full_backpressure');
  }
  public set onDiskFullBackpressure(value: string) {
    this._onDiskFullBackpressure = value;
  }
  public resetOnDiskFullBackpressure() {
    this._onDiskFullBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get onDiskFullBackpressureInput() {
    return this._onDiskFullBackpressure;
  }

  // parquet_data_page_version - computed: true, optional: true, required: false
  private _parquetDataPageVersion?: string; 
  public get parquetDataPageVersion() {
    return this.getStringAttribute('parquet_data_page_version');
  }
  public set parquetDataPageVersion(value: string) {
    this._parquetDataPageVersion = value;
  }
  public resetParquetDataPageVersion() {
    this._parquetDataPageVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get parquetDataPageVersionInput() {
    return this._parquetDataPageVersion;
  }

  // parquet_page_size - computed: true, optional: true, required: false
  private _parquetPageSize?: string; 
  public get parquetPageSize() {
    return this.getStringAttribute('parquet_page_size');
  }
  public set parquetPageSize(value: string) {
    this._parquetPageSize = value;
  }
  public resetParquetPageSize() {
    this._parquetPageSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get parquetPageSizeInput() {
    return this._parquetPageSize;
  }

  // parquet_row_group_length - computed: true, optional: true, required: false
  private _parquetRowGroupLength?: number; 
  public get parquetRowGroupLength() {
    return this.getNumberAttribute('parquet_row_group_length');
  }
  public set parquetRowGroupLength(value: number) {
    this._parquetRowGroupLength = value;
  }
  public resetParquetRowGroupLength() {
    this._parquetRowGroupLength = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get parquetRowGroupLengthInput() {
    return this._parquetRowGroupLength;
  }

  // parquet_schema - computed: false, optional: true, required: false
  private _parquetSchema?: string; 
  public get parquetSchema() {
    return this.getStringAttribute('parquet_schema');
  }
  public set parquetSchema(value: string) {
    this._parquetSchema = value;
  }
  public resetParquetSchema() {
    this._parquetSchema = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get parquetSchemaInput() {
    return this._parquetSchema;
  }

  // parquet_version - computed: true, optional: true, required: false
  private _parquetVersion?: string; 
  public get parquetVersion() {
    return this.getStringAttribute('parquet_version');
  }
  public set parquetVersion(value: string) {
    this._parquetVersion = value;
  }
  public resetParquetVersion() {
    this._parquetVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get parquetVersionInput() {
    return this._parquetVersion;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // region - computed: false, optional: false, required: true
  private _region?: string; 
  public get region() {
    return this.getStringAttribute('region');
  }
  public set region(value: string) {
    this._region = value;
  }
  // Temporarily expose input value. Use with caution.
  public get regionInput() {
    return this._region;
  }

  // reject_unauthorized - computed: true, optional: true, required: false
  private _rejectUnauthorized?: boolean | cdktf.IResolvable; 
  public get rejectUnauthorized() {
    return this.getBooleanAttribute('reject_unauthorized');
  }
  public set rejectUnauthorized(value: boolean | cdktf.IResolvable) {
    this._rejectUnauthorized = value;
  }
  public resetRejectUnauthorized() {
    this._rejectUnauthorized = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectUnauthorizedInput() {
    return this._rejectUnauthorized;
  }

  // remove_empty_dirs - computed: true, optional: true, required: false
  private _removeEmptyDirs?: boolean | cdktf.IResolvable; 
  public get removeEmptyDirs() {
    return this.getBooleanAttribute('remove_empty_dirs');
  }
  public set removeEmptyDirs(value: boolean | cdktf.IResolvable) {
    this._removeEmptyDirs = value;
  }
  public resetRemoveEmptyDirs() {
    this._removeEmptyDirs = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get removeEmptyDirsInput() {
    return this._removeEmptyDirs;
  }

  // reuse_connections - computed: true, optional: true, required: false
  private _reuseConnections?: boolean | cdktf.IResolvable; 
  public get reuseConnections() {
    return this.getBooleanAttribute('reuse_connections');
  }
  public set reuseConnections(value: boolean | cdktf.IResolvable) {
    this._reuseConnections = value;
  }
  public resetReuseConnections() {
    this._reuseConnections = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get reuseConnectionsInput() {
    return this._reuseConnections;
  }

  // server_side_encryption - computed: false, optional: true, required: false
  private _serverSideEncryption?: string; 
  public get serverSideEncryption() {
    return this.getStringAttribute('server_side_encryption');
  }
  public set serverSideEncryption(value: string) {
    this._serverSideEncryption = value;
  }
  public resetServerSideEncryption() {
    this._serverSideEncryption = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serverSideEncryptionInput() {
    return this._serverSideEncryption;
  }

  // should_log_invalid_rows - computed: false, optional: true, required: false
  private _shouldLogInvalidRows?: boolean | cdktf.IResolvable; 
  public get shouldLogInvalidRows() {
    return this.getBooleanAttribute('should_log_invalid_rows');
  }
  public set shouldLogInvalidRows(value: boolean | cdktf.IResolvable) {
    this._shouldLogInvalidRows = value;
  }
  public resetShouldLogInvalidRows() {
    this._shouldLogInvalidRows = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get shouldLogInvalidRowsInput() {
    return this._shouldLogInvalidRows;
  }

  // signature_version - computed: true, optional: true, required: false
  private _signatureVersion?: string; 
  public get signatureVersion() {
    return this.getStringAttribute('signature_version');
  }
  public set signatureVersion(value: string) {
    this._signatureVersion = value;
  }
  public resetSignatureVersion() {
    this._signatureVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get signatureVersionInput() {
    return this._signatureVersion;
  }

  // stage_path - computed: true, optional: true, required: false
  private _stagePath?: string; 
  public get stagePath() {
    return this.getStringAttribute('stage_path');
  }
  public set stagePath(value: string) {
    this._stagePath = value;
  }
  public resetStagePath() {
    this._stagePath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get stagePathInput() {
    return this._stagePath;
  }

  // storage_class - computed: false, optional: true, required: false
  private _storageClass?: string; 
  public get storageClass() {
    return this.getStringAttribute('storage_class');
  }
  public set storageClass(value: string) {
    this._storageClass = value;
  }
  public resetStorageClass() {
    this._storageClass = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get storageClassInput() {
    return this._storageClass;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // system_fields - computed: true, optional: true, required: false
  private _systemFields?: string[]; 
  public get systemFields() {
    return this.getListAttribute('system_fields');
  }
  public set systemFields(value: string[]) {
    this._systemFields = value;
  }
  public resetSystemFields() {
    this._systemFields = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get systemFieldsInput() {
    return this._systemFields;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // verify_permissions - computed: true, optional: true, required: false
  private _verifyPermissions?: boolean | cdktf.IResolvable; 
  public get verifyPermissions() {
    return this.getBooleanAttribute('verify_permissions');
  }
  public set verifyPermissions(value: boolean | cdktf.IResolvable) {
    this._verifyPermissions = value;
  }
  public resetVerifyPermissions() {
    this._verifyPermissions = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get verifyPermissionsInput() {
    return this._verifyPermissions;
  }

  // write_high_water_mark - computed: true, optional: true, required: false
  private _writeHighWaterMark?: number; 
  public get writeHighWaterMark() {
    return this.getNumberAttribute('write_high_water_mark');
  }
  public set writeHighWaterMark(value: number) {
    this._writeHighWaterMark = value;
  }
  public resetWriteHighWaterMark() {
    this._writeHighWaterMark = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get writeHighWaterMarkInput() {
    return this._writeHighWaterMark;
  }
}
export interface PackDestinationOutputSentinelExtraHttpHeaders {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#name PackDestination#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#value PackDestination#value}
  */
  readonly value: string;
}

export function packDestinationOutputSentinelExtraHttpHeadersToTerraform(struct?: PackDestinationOutputSentinelExtraHttpHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function packDestinationOutputSentinelExtraHttpHeadersToHclTerraform(struct?: PackDestinationOutputSentinelExtraHttpHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputSentinelExtraHttpHeadersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackDestinationOutputSentinelExtraHttpHeaders | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputSentinelExtraHttpHeaders | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class PackDestinationOutputSentinelExtraHttpHeadersList extends cdktf.ComplexList {
  public internalValue? : PackDestinationOutputSentinelExtraHttpHeaders[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackDestinationOutputSentinelExtraHttpHeadersOutputReference {
    return new PackDestinationOutputSentinelExtraHttpHeadersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackDestinationOutputSentinelPqControls {
}

export function packDestinationOutputSentinelPqControlsToTerraform(struct?: PackDestinationOutputSentinelPqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function packDestinationOutputSentinelPqControlsToHclTerraform(struct?: PackDestinationOutputSentinelPqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class PackDestinationOutputSentinelPqControlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackDestinationOutputSentinelPqControls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputSentinelPqControls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface PackDestinationOutputSentinelResponseRetrySettings {
  /**
  * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc. Default: 2
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#backoff_rate PackDestination#backoff_rate}
  */
  readonly backoffRate?: number;
  /**
  * The HTTP response status code that will trigger retries
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#http_status PackDestination#http_status}
  */
  readonly httpStatus: number;
  /**
  * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes). Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#initial_backoff PackDestination#initial_backoff}
  */
  readonly initialBackoff?: number;
  /**
  * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds). Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_backoff PackDestination#max_backoff}
  */
  readonly maxBackoff?: number;
}

export function packDestinationOutputSentinelResponseRetrySettingsToTerraform(struct?: PackDestinationOutputSentinelResponseRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    backoff_rate: cdktf.numberToTerraform(struct!.backoffRate),
    http_status: cdktf.numberToTerraform(struct!.httpStatus),
    initial_backoff: cdktf.numberToTerraform(struct!.initialBackoff),
    max_backoff: cdktf.numberToTerraform(struct!.maxBackoff),
  }
}


export function packDestinationOutputSentinelResponseRetrySettingsToHclTerraform(struct?: PackDestinationOutputSentinelResponseRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    backoff_rate: {
      value: cdktf.numberToHclTerraform(struct!.backoffRate),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    http_status: {
      value: cdktf.numberToHclTerraform(struct!.httpStatus),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    initial_backoff: {
      value: cdktf.numberToHclTerraform(struct!.initialBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_backoff: {
      value: cdktf.numberToHclTerraform(struct!.maxBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputSentinelResponseRetrySettingsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackDestinationOutputSentinelResponseRetrySettings | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._backoffRate !== undefined) {
      hasAnyValues = true;
      internalValueResult.backoffRate = this._backoffRate;
    }
    if (this._httpStatus !== undefined) {
      hasAnyValues = true;
      internalValueResult.httpStatus = this._httpStatus;
    }
    if (this._initialBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.initialBackoff = this._initialBackoff;
    }
    if (this._maxBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBackoff = this._maxBackoff;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputSentinelResponseRetrySettings | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._backoffRate = undefined;
      this._httpStatus = undefined;
      this._initialBackoff = undefined;
      this._maxBackoff = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._backoffRate = value.backoffRate;
      this._httpStatus = value.httpStatus;
      this._initialBackoff = value.initialBackoff;
      this._maxBackoff = value.maxBackoff;
    }
  }

  // backoff_rate - computed: true, optional: true, required: false
  private _backoffRate?: number; 
  public get backoffRate() {
    return this.getNumberAttribute('backoff_rate');
  }
  public set backoffRate(value: number) {
    this._backoffRate = value;
  }
  public resetBackoffRate() {
    this._backoffRate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get backoffRateInput() {
    return this._backoffRate;
  }

  // http_status - computed: false, optional: false, required: true
  private _httpStatus?: number; 
  public get httpStatus() {
    return this.getNumberAttribute('http_status');
  }
  public set httpStatus(value: number) {
    this._httpStatus = value;
  }
  // Temporarily expose input value. Use with caution.
  public get httpStatusInput() {
    return this._httpStatus;
  }

  // initial_backoff - computed: true, optional: true, required: false
  private _initialBackoff?: number; 
  public get initialBackoff() {
    return this.getNumberAttribute('initial_backoff');
  }
  public set initialBackoff(value: number) {
    this._initialBackoff = value;
  }
  public resetInitialBackoff() {
    this._initialBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get initialBackoffInput() {
    return this._initialBackoff;
  }

  // max_backoff - computed: true, optional: true, required: false
  private _maxBackoff?: number; 
  public get maxBackoff() {
    return this.getNumberAttribute('max_backoff');
  }
  public set maxBackoff(value: number) {
    this._maxBackoff = value;
  }
  public resetMaxBackoff() {
    this._maxBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBackoffInput() {
    return this._maxBackoff;
  }
}

export class PackDestinationOutputSentinelResponseRetrySettingsList extends cdktf.ComplexList {
  public internalValue? : PackDestinationOutputSentinelResponseRetrySettings[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackDestinationOutputSentinelResponseRetrySettingsOutputReference {
    return new PackDestinationOutputSentinelResponseRetrySettingsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackDestinationOutputSentinelTimeoutRetrySettings {
  /**
  * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc. Default: 2
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#backoff_rate PackDestination#backoff_rate}
  */
  readonly backoffRate?: number;
  /**
  * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes). Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#initial_backoff PackDestination#initial_backoff}
  */
  readonly initialBackoff?: number;
  /**
  * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds). Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_backoff PackDestination#max_backoff}
  */
  readonly maxBackoff?: number;
  /**
  * Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#timeout_retry PackDestination#timeout_retry}
  */
  readonly timeoutRetry?: boolean | cdktf.IResolvable;
}

export function packDestinationOutputSentinelTimeoutRetrySettingsToTerraform(struct?: PackDestinationOutputSentinelTimeoutRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    backoff_rate: cdktf.numberToTerraform(struct!.backoffRate),
    initial_backoff: cdktf.numberToTerraform(struct!.initialBackoff),
    max_backoff: cdktf.numberToTerraform(struct!.maxBackoff),
    timeout_retry: cdktf.booleanToTerraform(struct!.timeoutRetry),
  }
}


export function packDestinationOutputSentinelTimeoutRetrySettingsToHclTerraform(struct?: PackDestinationOutputSentinelTimeoutRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    backoff_rate: {
      value: cdktf.numberToHclTerraform(struct!.backoffRate),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    initial_backoff: {
      value: cdktf.numberToHclTerraform(struct!.initialBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_backoff: {
      value: cdktf.numberToHclTerraform(struct!.maxBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    timeout_retry: {
      value: cdktf.booleanToHclTerraform(struct!.timeoutRetry),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputSentinelTimeoutRetrySettingsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackDestinationOutputSentinelTimeoutRetrySettings | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._backoffRate !== undefined) {
      hasAnyValues = true;
      internalValueResult.backoffRate = this._backoffRate;
    }
    if (this._initialBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.initialBackoff = this._initialBackoff;
    }
    if (this._maxBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBackoff = this._maxBackoff;
    }
    if (this._timeoutRetry !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutRetry = this._timeoutRetry;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputSentinelTimeoutRetrySettings | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._backoffRate = undefined;
      this._initialBackoff = undefined;
      this._maxBackoff = undefined;
      this._timeoutRetry = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._backoffRate = value.backoffRate;
      this._initialBackoff = value.initialBackoff;
      this._maxBackoff = value.maxBackoff;
      this._timeoutRetry = value.timeoutRetry;
    }
  }

  // backoff_rate - computed: true, optional: true, required: false
  private _backoffRate?: number; 
  public get backoffRate() {
    return this.getNumberAttribute('backoff_rate');
  }
  public set backoffRate(value: number) {
    this._backoffRate = value;
  }
  public resetBackoffRate() {
    this._backoffRate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get backoffRateInput() {
    return this._backoffRate;
  }

  // initial_backoff - computed: true, optional: true, required: false
  private _initialBackoff?: number; 
  public get initialBackoff() {
    return this.getNumberAttribute('initial_backoff');
  }
  public set initialBackoff(value: number) {
    this._initialBackoff = value;
  }
  public resetInitialBackoff() {
    this._initialBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get initialBackoffInput() {
    return this._initialBackoff;
  }

  // max_backoff - computed: true, optional: true, required: false
  private _maxBackoff?: number; 
  public get maxBackoff() {
    return this.getNumberAttribute('max_backoff');
  }
  public set maxBackoff(value: number) {
    this._maxBackoff = value;
  }
  public resetMaxBackoff() {
    this._maxBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBackoffInput() {
    return this._maxBackoff;
  }

  // timeout_retry - computed: true, optional: true, required: false
  private _timeoutRetry?: boolean | cdktf.IResolvable; 
  public get timeoutRetry() {
    return this.getBooleanAttribute('timeout_retry');
  }
  public set timeoutRetry(value: boolean | cdktf.IResolvable) {
    this._timeoutRetry = value;
  }
  public resetTimeoutRetry() {
    this._timeoutRetry = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutRetryInput() {
    return this._timeoutRetry;
  }
}
export interface PackDestinationOutputSentinel {
  /**
  * HTTP content-type header value. Default: "application/json"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#advanced_content_type PackDestination#advanced_content_type}
  */
  readonly advancedContentType?: string;
  /**
  * must be "oauth"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#auth_type PackDestination#auth_type}
  */
  readonly authType?: string;
  /**
  * JavaScript expression to compute the Client ID for the Azure application. Can be a constant.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#client_id PackDestination#client_id}
  */
  readonly clientId: string;
  /**
  * Compress the payload body before sending. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#compress PackDestination#compress}
  */
  readonly compress?: boolean | cdktf.IResolvable;
  /**
  * Maximum number of ongoing requests before blocking. Default: 5
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#concurrency PackDestination#concurrency}
  */
  readonly concurrency?: number;
  /**
  * Content type to use for request. Defaults to application/x-ndjson. Any content types set in Advanced Settings > Extra HTTP headers will override this entry. Default: "application/x-ndjson"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#custom_content_type PackDestination#custom_content_type}
  */
  readonly customContentType?: string;
  /**
  * Whether to drop events when the source expression evaluates to null. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#custom_drop_when_null PackDestination#custom_drop_when_null}
  */
  readonly customDropWhenNull?: boolean | cdktf.IResolvable;
  /**
  * Delimiter string to insert between individual events. Defaults to newline character. Default: "\n"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#custom_event_delimiter PackDestination#custom_event_delimiter}
  */
  readonly customEventDelimiter?: string;
  /**
  * Expression specifying how to format the payload for each batch. To reference the events to send, use the `${events}` variable. Example expression: `{ "items" : [${events}] }` would send the batch inside a JSON object. Default: "`${events}`"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#custom_payload_expression PackDestination#custom_payload_expression}
  */
  readonly customPayloadExpression?: string;
  /**
  * Expression to evaluate on events to generate output. Example: `raw=${_raw}`. See [Cribl Docs](https://docs.cribl.io/stream/destinations-webhook#custom-format) for other examples. If empty, the full event is sent as stringified JSON. Default: "__httpOut"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#custom_source_expression PackDestination#custom_source_expression}
  */
  readonly customSourceExpression?: string;
  /**
  * Data collection endpoint (DCE) URL. In the format: `https://<Endpoint-Name>-<Identifier>.<Region>.ingest.monitor.azure.com`
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#dce_endpoint PackDestination#dce_endpoint}
  */
  readonly dceEndpoint?: string;
  /**
  * Immutable ID for the Data Collection Rule (DCR)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#dcr_id PackDestination#dcr_id}
  */
  readonly dcrId?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#description PackDestination#description}
  */
  readonly description?: string;
  /**
  * Enter the data collection endpoint URL or the individual ID. Default: "url"; must be one of ["url", "ID"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#endpoint_url_configuration PackDestination#endpoint_url_configuration}
  */
  readonly endpointUrlConfiguration?: string;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#environment PackDestination#environment}
  */
  readonly environment?: string;
  /**
  * Headers to add to all events. You can also add headers dynamically on a per-event basis in the __headers field.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#extra_http_headers PackDestination#extra_http_headers}
  */
  readonly extraHttpHeaders?: PackDestinationOutputSentinelExtraHttpHeaders[] | cdktf.IResolvable;
  /**
  * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below. Default: "none"; must be one of ["payload", "payloadAndHeaders", "none"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#failed_request_logging_mode PackDestination#failed_request_logging_mode}
  */
  readonly failedRequestLoggingMode?: string;
  /**
  * Maximum time between requests. Small values could cause the payload size to be smaller than the configured Body size limit. Default: 1
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#flush_period_sec PackDestination#flush_period_sec}
  */
  readonly flushPeriodSec?: number;
  /**
  * must be one of ["ndjson", "json_array", "custom", "advanced"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#format PackDestination#format}
  */
  readonly format?: string;
  /**
  * Custom JavaScript code to format incoming event data accessible through the __e variable. The formatted content is added to (__e['__eventOut']) if available. Otherwise, the original event is serialized as JSON. Caution: This function is evaluated in an unprotected context, allowing you to execute almost any JavaScript code.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#format_event_code PackDestination#format_event_code}
  */
  readonly formatEventCode?: string;
  /**
  * Optional JavaScript code to format the payload sent to the Destination. The payload, containing a batch of formatted events, is accessible through the __e['payload'] variable. The formatted payload is returned in the __e['__payloadOut'] variable. Caution: This function is evaluated in an unprotected context, allowing you to execute almost any JavaScript code.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#format_payload_code PackDestination#format_payload_code}
  */
  readonly formatPayloadCode?: string;
  /**
  * Unique ID for this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#id PackDestination#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * Disable to close the connection immediately after sending the outgoing request. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#keep_alive PackDestination#keep_alive}
  */
  readonly keepAlive?: boolean | cdktf.IResolvable;
  /**
  * URL for OAuth
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#login_url PackDestination#login_url}
  */
  readonly loginUrl: string;
  /**
  * Maximum number of events to include in the request body. Default is 0 (unlimited). Default: 0
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_payload_events PackDestination#max_payload_events}
  */
  readonly maxPayloadEvents?: number;
  /**
  * Maximum size (KB) of the request body (defaults to the API's maximum limit of 1000 KB). Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_payload_size_kb PackDestination#max_payload_size_kb}
  */
  readonly maxPayloadSizeKb?: number;
  /**
  * How to handle events when all receivers are exerting backpressure. Default: "block"; must be one of ["block", "drop", "queue"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#on_backpressure PackDestination#on_backpressure}
  */
  readonly onBackpressure?: string;
  /**
  * Pipeline to process data before sending out to this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pipeline PackDestination#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_compress PackDestination#pq_compress}
  */
  readonly pqCompress?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_controls PackDestination#pq_controls}
  */
  readonly pqControls?: PackDestinationOutputSentinelPqControls;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.). Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_max_file_size PackDestination#pq_max_file_size}
  */
  readonly pqMaxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_max_size PackDestination#pq_max_size}
  */
  readonly pqMaxSize?: string;
  /**
  * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem. Default: "error"; must be one of ["error", "backpressure", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_mode PackDestination#pq_mode}
  */
  readonly pqMode?: string;
  /**
  * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged. Default: "block"; must be one of ["block", "drop"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_on_backpressure PackDestination#pq_on_backpressure}
  */
  readonly pqOnBackpressure?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_path PackDestination#pq_path}
  */
  readonly pqPath?: string;
  /**
  * Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's). 
  *         Enabled by default. When this setting is also present in TLS Settings (Client Side), 
  *         that value will take precedence.
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#reject_unauthorized PackDestination#reject_unauthorized}
  */
  readonly rejectUnauthorized?: boolean | cdktf.IResolvable;
  /**
  * Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#response_honor_retry_after_header PackDestination#response_honor_retry_after_header}
  */
  readonly responseHonorRetryAfterHeader?: boolean | cdktf.IResolvable;
  /**
  * Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#response_retry_settings PackDestination#response_retry_settings}
  */
  readonly responseRetrySettings?: PackDestinationOutputSentinelResponseRetrySettings[] | cdktf.IResolvable;
  /**
  * List of headers that are safe to log in plain text. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#safe_headers PackDestination#safe_headers}
  */
  readonly safeHeaders?: string[];
  /**
  * Scope to pass in the OAuth request. Default: "https://monitor.azure.com/.default"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#scope PackDestination#scope}
  */
  readonly scope?: string;
  /**
  * Secret parameter value to pass in request body
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#secret PackDestination#secret}
  */
  readonly secret: string;
  /**
  * The name of the stream (Sentinel table) in which to store the events
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#stream_name PackDestination#stream_name}
  */
  readonly streamName?: string;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#streamtags PackDestination#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Fields to automatically add to events, such as cribl_pipe. Supports wildcards. Default: ["cribl_pipe"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#system_fields PackDestination#system_fields}
  */
  readonly systemFields?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#timeout_retry_settings PackDestination#timeout_retry_settings}
  */
  readonly timeoutRetrySettings?: PackDestinationOutputSentinelTimeoutRetrySettings;
  /**
  * Amount of time, in seconds, to wait for a request to complete before canceling it. Default: 30
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#timeout_sec PackDestination#timeout_sec}
  */
  readonly timeoutSec?: number;
  /**
  * Maximum total size of the batches waiting to be sent. If left blank, defaults to 5 times the max body size (if set). If 0, no limit is enforced.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#total_memory_limit_kb PackDestination#total_memory_limit_kb}
  */
  readonly totalMemoryLimitKb?: number;
  /**
  * must be "sentinel"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#type PackDestination#type}
  */
  readonly type?: string;
  /**
  * URL to send events to. Can be overwritten by an event's __url field.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#url PackDestination#url}
  */
  readonly url?: string;
  /**
  * Enable round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. For optimal performance, consider enabling this setting for non-load balanced destinations. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#use_round_robin_dns PackDestination#use_round_robin_dns}
  */
  readonly useRoundRobinDns?: boolean | cdktf.IResolvable;
}

export function packDestinationOutputSentinelToTerraform(struct?: PackDestinationOutputSentinel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    advanced_content_type: cdktf.stringToTerraform(struct!.advancedContentType),
    auth_type: cdktf.stringToTerraform(struct!.authType),
    client_id: cdktf.stringToTerraform(struct!.clientId),
    compress: cdktf.booleanToTerraform(struct!.compress),
    concurrency: cdktf.numberToTerraform(struct!.concurrency),
    custom_content_type: cdktf.stringToTerraform(struct!.customContentType),
    custom_drop_when_null: cdktf.booleanToTerraform(struct!.customDropWhenNull),
    custom_event_delimiter: cdktf.stringToTerraform(struct!.customEventDelimiter),
    custom_payload_expression: cdktf.stringToTerraform(struct!.customPayloadExpression),
    custom_source_expression: cdktf.stringToTerraform(struct!.customSourceExpression),
    dce_endpoint: cdktf.stringToTerraform(struct!.dceEndpoint),
    dcr_id: cdktf.stringToTerraform(struct!.dcrId),
    description: cdktf.stringToTerraform(struct!.description),
    endpoint_url_configuration: cdktf.stringToTerraform(struct!.endpointUrlConfiguration),
    environment: cdktf.stringToTerraform(struct!.environment),
    extra_http_headers: cdktf.listMapper(packDestinationOutputSentinelExtraHttpHeadersToTerraform, false)(struct!.extraHttpHeaders),
    failed_request_logging_mode: cdktf.stringToTerraform(struct!.failedRequestLoggingMode),
    flush_period_sec: cdktf.numberToTerraform(struct!.flushPeriodSec),
    format: cdktf.stringToTerraform(struct!.format),
    format_event_code: cdktf.stringToTerraform(struct!.formatEventCode),
    format_payload_code: cdktf.stringToTerraform(struct!.formatPayloadCode),
    id: cdktf.stringToTerraform(struct!.id),
    keep_alive: cdktf.booleanToTerraform(struct!.keepAlive),
    login_url: cdktf.stringToTerraform(struct!.loginUrl),
    max_payload_events: cdktf.numberToTerraform(struct!.maxPayloadEvents),
    max_payload_size_kb: cdktf.numberToTerraform(struct!.maxPayloadSizeKb),
    on_backpressure: cdktf.stringToTerraform(struct!.onBackpressure),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    pq_compress: cdktf.stringToTerraform(struct!.pqCompress),
    pq_controls: packDestinationOutputSentinelPqControlsToTerraform(struct!.pqControls),
    pq_max_file_size: cdktf.stringToTerraform(struct!.pqMaxFileSize),
    pq_max_size: cdktf.stringToTerraform(struct!.pqMaxSize),
    pq_mode: cdktf.stringToTerraform(struct!.pqMode),
    pq_on_backpressure: cdktf.stringToTerraform(struct!.pqOnBackpressure),
    pq_path: cdktf.stringToTerraform(struct!.pqPath),
    reject_unauthorized: cdktf.booleanToTerraform(struct!.rejectUnauthorized),
    response_honor_retry_after_header: cdktf.booleanToTerraform(struct!.responseHonorRetryAfterHeader),
    response_retry_settings: cdktf.listMapper(packDestinationOutputSentinelResponseRetrySettingsToTerraform, false)(struct!.responseRetrySettings),
    safe_headers: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.safeHeaders),
    scope: cdktf.stringToTerraform(struct!.scope),
    secret: cdktf.stringToTerraform(struct!.secret),
    stream_name: cdktf.stringToTerraform(struct!.streamName),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    system_fields: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.systemFields),
    timeout_retry_settings: packDestinationOutputSentinelTimeoutRetrySettingsToTerraform(struct!.timeoutRetrySettings),
    timeout_sec: cdktf.numberToTerraform(struct!.timeoutSec),
    total_memory_limit_kb: cdktf.numberToTerraform(struct!.totalMemoryLimitKb),
    type: cdktf.stringToTerraform(struct!.type),
    url: cdktf.stringToTerraform(struct!.url),
    use_round_robin_dns: cdktf.booleanToTerraform(struct!.useRoundRobinDns),
  }
}


export function packDestinationOutputSentinelToHclTerraform(struct?: PackDestinationOutputSentinel | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    advanced_content_type: {
      value: cdktf.stringToHclTerraform(struct!.advancedContentType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    auth_type: {
      value: cdktf.stringToHclTerraform(struct!.authType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    client_id: {
      value: cdktf.stringToHclTerraform(struct!.clientId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    compress: {
      value: cdktf.booleanToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    concurrency: {
      value: cdktf.numberToHclTerraform(struct!.concurrency),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    custom_content_type: {
      value: cdktf.stringToHclTerraform(struct!.customContentType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    custom_drop_when_null: {
      value: cdktf.booleanToHclTerraform(struct!.customDropWhenNull),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    custom_event_delimiter: {
      value: cdktf.stringToHclTerraform(struct!.customEventDelimiter),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    custom_payload_expression: {
      value: cdktf.stringToHclTerraform(struct!.customPayloadExpression),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    custom_source_expression: {
      value: cdktf.stringToHclTerraform(struct!.customSourceExpression),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    dce_endpoint: {
      value: cdktf.stringToHclTerraform(struct!.dceEndpoint),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    dcr_id: {
      value: cdktf.stringToHclTerraform(struct!.dcrId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    endpoint_url_configuration: {
      value: cdktf.stringToHclTerraform(struct!.endpointUrlConfiguration),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    extra_http_headers: {
      value: cdktf.listMapperHcl(packDestinationOutputSentinelExtraHttpHeadersToHclTerraform, false)(struct!.extraHttpHeaders),
      isBlock: true,
      type: "list",
      storageClassType: "PackDestinationOutputSentinelExtraHttpHeadersList",
    },
    failed_request_logging_mode: {
      value: cdktf.stringToHclTerraform(struct!.failedRequestLoggingMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    flush_period_sec: {
      value: cdktf.numberToHclTerraform(struct!.flushPeriodSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    format: {
      value: cdktf.stringToHclTerraform(struct!.format),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    format_event_code: {
      value: cdktf.stringToHclTerraform(struct!.formatEventCode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    format_payload_code: {
      value: cdktf.stringToHclTerraform(struct!.formatPayloadCode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    keep_alive: {
      value: cdktf.booleanToHclTerraform(struct!.keepAlive),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    login_url: {
      value: cdktf.stringToHclTerraform(struct!.loginUrl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_payload_events: {
      value: cdktf.numberToHclTerraform(struct!.maxPayloadEvents),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_payload_size_kb: {
      value: cdktf.numberToHclTerraform(struct!.maxPayloadSizeKb),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.onBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_compress: {
      value: cdktf.stringToHclTerraform(struct!.pqCompress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_controls: {
      value: packDestinationOutputSentinelPqControlsToHclTerraform(struct!.pqControls),
      isBlock: true,
      type: "struct",
      storageClassType: "PackDestinationOutputSentinelPqControls",
    },
    pq_max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_max_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_mode: {
      value: cdktf.stringToHclTerraform(struct!.pqMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.pqOnBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_path: {
      value: cdktf.stringToHclTerraform(struct!.pqPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reject_unauthorized: {
      value: cdktf.booleanToHclTerraform(struct!.rejectUnauthorized),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    response_honor_retry_after_header: {
      value: cdktf.booleanToHclTerraform(struct!.responseHonorRetryAfterHeader),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    response_retry_settings: {
      value: cdktf.listMapperHcl(packDestinationOutputSentinelResponseRetrySettingsToHclTerraform, false)(struct!.responseRetrySettings),
      isBlock: true,
      type: "list",
      storageClassType: "PackDestinationOutputSentinelResponseRetrySettingsList",
    },
    safe_headers: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.safeHeaders),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    scope: {
      value: cdktf.stringToHclTerraform(struct!.scope),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret: {
      value: cdktf.stringToHclTerraform(struct!.secret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    stream_name: {
      value: cdktf.stringToHclTerraform(struct!.streamName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    system_fields: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.systemFields),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    timeout_retry_settings: {
      value: packDestinationOutputSentinelTimeoutRetrySettingsToHclTerraform(struct!.timeoutRetrySettings),
      isBlock: true,
      type: "struct",
      storageClassType: "PackDestinationOutputSentinelTimeoutRetrySettings",
    },
    timeout_sec: {
      value: cdktf.numberToHclTerraform(struct!.timeoutSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    total_memory_limit_kb: {
      value: cdktf.numberToHclTerraform(struct!.totalMemoryLimitKb),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    url: {
      value: cdktf.stringToHclTerraform(struct!.url),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    use_round_robin_dns: {
      value: cdktf.booleanToHclTerraform(struct!.useRoundRobinDns),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputSentinelOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackDestinationOutputSentinel | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._advancedContentType !== undefined) {
      hasAnyValues = true;
      internalValueResult.advancedContentType = this._advancedContentType;
    }
    if (this._authType !== undefined) {
      hasAnyValues = true;
      internalValueResult.authType = this._authType;
    }
    if (this._clientId !== undefined) {
      hasAnyValues = true;
      internalValueResult.clientId = this._clientId;
    }
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._concurrency !== undefined) {
      hasAnyValues = true;
      internalValueResult.concurrency = this._concurrency;
    }
    if (this._customContentType !== undefined) {
      hasAnyValues = true;
      internalValueResult.customContentType = this._customContentType;
    }
    if (this._customDropWhenNull !== undefined) {
      hasAnyValues = true;
      internalValueResult.customDropWhenNull = this._customDropWhenNull;
    }
    if (this._customEventDelimiter !== undefined) {
      hasAnyValues = true;
      internalValueResult.customEventDelimiter = this._customEventDelimiter;
    }
    if (this._customPayloadExpression !== undefined) {
      hasAnyValues = true;
      internalValueResult.customPayloadExpression = this._customPayloadExpression;
    }
    if (this._customSourceExpression !== undefined) {
      hasAnyValues = true;
      internalValueResult.customSourceExpression = this._customSourceExpression;
    }
    if (this._dceEndpoint !== undefined) {
      hasAnyValues = true;
      internalValueResult.dceEndpoint = this._dceEndpoint;
    }
    if (this._dcrId !== undefined) {
      hasAnyValues = true;
      internalValueResult.dcrId = this._dcrId;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._endpointUrlConfiguration !== undefined) {
      hasAnyValues = true;
      internalValueResult.endpointUrlConfiguration = this._endpointUrlConfiguration;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._extraHttpHeaders?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.extraHttpHeaders = this._extraHttpHeaders?.internalValue;
    }
    if (this._failedRequestLoggingMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.failedRequestLoggingMode = this._failedRequestLoggingMode;
    }
    if (this._flushPeriodSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.flushPeriodSec = this._flushPeriodSec;
    }
    if (this._format !== undefined) {
      hasAnyValues = true;
      internalValueResult.format = this._format;
    }
    if (this._formatEventCode !== undefined) {
      hasAnyValues = true;
      internalValueResult.formatEventCode = this._formatEventCode;
    }
    if (this._formatPayloadCode !== undefined) {
      hasAnyValues = true;
      internalValueResult.formatPayloadCode = this._formatPayloadCode;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._keepAlive !== undefined) {
      hasAnyValues = true;
      internalValueResult.keepAlive = this._keepAlive;
    }
    if (this._loginUrl !== undefined) {
      hasAnyValues = true;
      internalValueResult.loginUrl = this._loginUrl;
    }
    if (this._maxPayloadEvents !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxPayloadEvents = this._maxPayloadEvents;
    }
    if (this._maxPayloadSizeKb !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxPayloadSizeKb = this._maxPayloadSizeKb;
    }
    if (this._onBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.onBackpressure = this._onBackpressure;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._pqCompress !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqCompress = this._pqCompress;
    }
    if (this._pqControls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqControls = this._pqControls?.internalValue;
    }
    if (this._pqMaxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxFileSize = this._pqMaxFileSize;
    }
    if (this._pqMaxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxSize = this._pqMaxSize;
    }
    if (this._pqMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMode = this._pqMode;
    }
    if (this._pqOnBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqOnBackpressure = this._pqOnBackpressure;
    }
    if (this._pqPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqPath = this._pqPath;
    }
    if (this._rejectUnauthorized !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectUnauthorized = this._rejectUnauthorized;
    }
    if (this._responseHonorRetryAfterHeader !== undefined) {
      hasAnyValues = true;
      internalValueResult.responseHonorRetryAfterHeader = this._responseHonorRetryAfterHeader;
    }
    if (this._responseRetrySettings?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.responseRetrySettings = this._responseRetrySettings?.internalValue;
    }
    if (this._safeHeaders !== undefined) {
      hasAnyValues = true;
      internalValueResult.safeHeaders = this._safeHeaders;
    }
    if (this._scope !== undefined) {
      hasAnyValues = true;
      internalValueResult.scope = this._scope;
    }
    if (this._secret !== undefined) {
      hasAnyValues = true;
      internalValueResult.secret = this._secret;
    }
    if (this._streamName !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamName = this._streamName;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._systemFields !== undefined) {
      hasAnyValues = true;
      internalValueResult.systemFields = this._systemFields;
    }
    if (this._timeoutRetrySettings?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutRetrySettings = this._timeoutRetrySettings?.internalValue;
    }
    if (this._timeoutSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutSec = this._timeoutSec;
    }
    if (this._totalMemoryLimitKb !== undefined) {
      hasAnyValues = true;
      internalValueResult.totalMemoryLimitKb = this._totalMemoryLimitKb;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._url !== undefined) {
      hasAnyValues = true;
      internalValueResult.url = this._url;
    }
    if (this._useRoundRobinDns !== undefined) {
      hasAnyValues = true;
      internalValueResult.useRoundRobinDns = this._useRoundRobinDns;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputSentinel | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._advancedContentType = undefined;
      this._authType = undefined;
      this._clientId = undefined;
      this._compress = undefined;
      this._concurrency = undefined;
      this._customContentType = undefined;
      this._customDropWhenNull = undefined;
      this._customEventDelimiter = undefined;
      this._customPayloadExpression = undefined;
      this._customSourceExpression = undefined;
      this._dceEndpoint = undefined;
      this._dcrId = undefined;
      this._description = undefined;
      this._endpointUrlConfiguration = undefined;
      this._environment = undefined;
      this._extraHttpHeaders.internalValue = undefined;
      this._failedRequestLoggingMode = undefined;
      this._flushPeriodSec = undefined;
      this._format = undefined;
      this._formatEventCode = undefined;
      this._formatPayloadCode = undefined;
      this._id = undefined;
      this._keepAlive = undefined;
      this._loginUrl = undefined;
      this._maxPayloadEvents = undefined;
      this._maxPayloadSizeKb = undefined;
      this._onBackpressure = undefined;
      this._pipeline = undefined;
      this._pqCompress = undefined;
      this._pqControls.internalValue = undefined;
      this._pqMaxFileSize = undefined;
      this._pqMaxSize = undefined;
      this._pqMode = undefined;
      this._pqOnBackpressure = undefined;
      this._pqPath = undefined;
      this._rejectUnauthorized = undefined;
      this._responseHonorRetryAfterHeader = undefined;
      this._responseRetrySettings.internalValue = undefined;
      this._safeHeaders = undefined;
      this._scope = undefined;
      this._secret = undefined;
      this._streamName = undefined;
      this._streamtags = undefined;
      this._systemFields = undefined;
      this._timeoutRetrySettings.internalValue = undefined;
      this._timeoutSec = undefined;
      this._totalMemoryLimitKb = undefined;
      this._type = undefined;
      this._url = undefined;
      this._useRoundRobinDns = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._advancedContentType = value.advancedContentType;
      this._authType = value.authType;
      this._clientId = value.clientId;
      this._compress = value.compress;
      this._concurrency = value.concurrency;
      this._customContentType = value.customContentType;
      this._customDropWhenNull = value.customDropWhenNull;
      this._customEventDelimiter = value.customEventDelimiter;
      this._customPayloadExpression = value.customPayloadExpression;
      this._customSourceExpression = value.customSourceExpression;
      this._dceEndpoint = value.dceEndpoint;
      this._dcrId = value.dcrId;
      this._description = value.description;
      this._endpointUrlConfiguration = value.endpointUrlConfiguration;
      this._environment = value.environment;
      this._extraHttpHeaders.internalValue = value.extraHttpHeaders;
      this._failedRequestLoggingMode = value.failedRequestLoggingMode;
      this._flushPeriodSec = value.flushPeriodSec;
      this._format = value.format;
      this._formatEventCode = value.formatEventCode;
      this._formatPayloadCode = value.formatPayloadCode;
      this._id = value.id;
      this._keepAlive = value.keepAlive;
      this._loginUrl = value.loginUrl;
      this._maxPayloadEvents = value.maxPayloadEvents;
      this._maxPayloadSizeKb = value.maxPayloadSizeKb;
      this._onBackpressure = value.onBackpressure;
      this._pipeline = value.pipeline;
      this._pqCompress = value.pqCompress;
      this._pqControls.internalValue = value.pqControls;
      this._pqMaxFileSize = value.pqMaxFileSize;
      this._pqMaxSize = value.pqMaxSize;
      this._pqMode = value.pqMode;
      this._pqOnBackpressure = value.pqOnBackpressure;
      this._pqPath = value.pqPath;
      this._rejectUnauthorized = value.rejectUnauthorized;
      this._responseHonorRetryAfterHeader = value.responseHonorRetryAfterHeader;
      this._responseRetrySettings.internalValue = value.responseRetrySettings;
      this._safeHeaders = value.safeHeaders;
      this._scope = value.scope;
      this._secret = value.secret;
      this._streamName = value.streamName;
      this._streamtags = value.streamtags;
      this._systemFields = value.systemFields;
      this._timeoutRetrySettings.internalValue = value.timeoutRetrySettings;
      this._timeoutSec = value.timeoutSec;
      this._totalMemoryLimitKb = value.totalMemoryLimitKb;
      this._type = value.type;
      this._url = value.url;
      this._useRoundRobinDns = value.useRoundRobinDns;
    }
  }

  // advanced_content_type - computed: true, optional: true, required: false
  private _advancedContentType?: string; 
  public get advancedContentType() {
    return this.getStringAttribute('advanced_content_type');
  }
  public set advancedContentType(value: string) {
    this._advancedContentType = value;
  }
  public resetAdvancedContentType() {
    this._advancedContentType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get advancedContentTypeInput() {
    return this._advancedContentType;
  }

  // auth_type - computed: false, optional: true, required: false
  private _authType?: string; 
  public get authType() {
    return this.getStringAttribute('auth_type');
  }
  public set authType(value: string) {
    this._authType = value;
  }
  public resetAuthType() {
    this._authType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authTypeInput() {
    return this._authType;
  }

  // client_id - computed: false, optional: false, required: true
  private _clientId?: string; 
  public get clientId() {
    return this.getStringAttribute('client_id');
  }
  public set clientId(value: string) {
    this._clientId = value;
  }
  // Temporarily expose input value. Use with caution.
  public get clientIdInput() {
    return this._clientId;
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: boolean | cdktf.IResolvable; 
  public get compress() {
    return this.getBooleanAttribute('compress');
  }
  public set compress(value: boolean | cdktf.IResolvable) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // concurrency - computed: true, optional: true, required: false
  private _concurrency?: number; 
  public get concurrency() {
    return this.getNumberAttribute('concurrency');
  }
  public set concurrency(value: number) {
    this._concurrency = value;
  }
  public resetConcurrency() {
    this._concurrency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get concurrencyInput() {
    return this._concurrency;
  }

  // custom_content_type - computed: true, optional: true, required: false
  private _customContentType?: string; 
  public get customContentType() {
    return this.getStringAttribute('custom_content_type');
  }
  public set customContentType(value: string) {
    this._customContentType = value;
  }
  public resetCustomContentType() {
    this._customContentType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get customContentTypeInput() {
    return this._customContentType;
  }

  // custom_drop_when_null - computed: true, optional: true, required: false
  private _customDropWhenNull?: boolean | cdktf.IResolvable; 
  public get customDropWhenNull() {
    return this.getBooleanAttribute('custom_drop_when_null');
  }
  public set customDropWhenNull(value: boolean | cdktf.IResolvable) {
    this._customDropWhenNull = value;
  }
  public resetCustomDropWhenNull() {
    this._customDropWhenNull = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get customDropWhenNullInput() {
    return this._customDropWhenNull;
  }

  // custom_event_delimiter - computed: true, optional: true, required: false
  private _customEventDelimiter?: string; 
  public get customEventDelimiter() {
    return this.getStringAttribute('custom_event_delimiter');
  }
  public set customEventDelimiter(value: string) {
    this._customEventDelimiter = value;
  }
  public resetCustomEventDelimiter() {
    this._customEventDelimiter = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get customEventDelimiterInput() {
    return this._customEventDelimiter;
  }

  // custom_payload_expression - computed: true, optional: true, required: false
  private _customPayloadExpression?: string; 
  public get customPayloadExpression() {
    return this.getStringAttribute('custom_payload_expression');
  }
  public set customPayloadExpression(value: string) {
    this._customPayloadExpression = value;
  }
  public resetCustomPayloadExpression() {
    this._customPayloadExpression = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get customPayloadExpressionInput() {
    return this._customPayloadExpression;
  }

  // custom_source_expression - computed: true, optional: true, required: false
  private _customSourceExpression?: string; 
  public get customSourceExpression() {
    return this.getStringAttribute('custom_source_expression');
  }
  public set customSourceExpression(value: string) {
    this._customSourceExpression = value;
  }
  public resetCustomSourceExpression() {
    this._customSourceExpression = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get customSourceExpressionInput() {
    return this._customSourceExpression;
  }

  // dce_endpoint - computed: false, optional: true, required: false
  private _dceEndpoint?: string; 
  public get dceEndpoint() {
    return this.getStringAttribute('dce_endpoint');
  }
  public set dceEndpoint(value: string) {
    this._dceEndpoint = value;
  }
  public resetDceEndpoint() {
    this._dceEndpoint = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dceEndpointInput() {
    return this._dceEndpoint;
  }

  // dcr_id - computed: false, optional: true, required: false
  private _dcrId?: string; 
  public get dcrId() {
    return this.getStringAttribute('dcr_id');
  }
  public set dcrId(value: string) {
    this._dcrId = value;
  }
  public resetDcrId() {
    this._dcrId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dcrIdInput() {
    return this._dcrId;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // endpoint_url_configuration - computed: true, optional: true, required: false
  private _endpointUrlConfiguration?: string; 
  public get endpointUrlConfiguration() {
    return this.getStringAttribute('endpoint_url_configuration');
  }
  public set endpointUrlConfiguration(value: string) {
    this._endpointUrlConfiguration = value;
  }
  public resetEndpointUrlConfiguration() {
    this._endpointUrlConfiguration = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get endpointUrlConfigurationInput() {
    return this._endpointUrlConfiguration;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // extra_http_headers - computed: false, optional: true, required: false
  private _extraHttpHeaders = new PackDestinationOutputSentinelExtraHttpHeadersList(this, "extra_http_headers", false);
  public get extraHttpHeaders() {
    return this._extraHttpHeaders;
  }
  public putExtraHttpHeaders(value: PackDestinationOutputSentinelExtraHttpHeaders[] | cdktf.IResolvable) {
    this._extraHttpHeaders.internalValue = value;
  }
  public resetExtraHttpHeaders() {
    this._extraHttpHeaders.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get extraHttpHeadersInput() {
    return this._extraHttpHeaders.internalValue;
  }

  // failed_request_logging_mode - computed: true, optional: true, required: false
  private _failedRequestLoggingMode?: string; 
  public get failedRequestLoggingMode() {
    return this.getStringAttribute('failed_request_logging_mode');
  }
  public set failedRequestLoggingMode(value: string) {
    this._failedRequestLoggingMode = value;
  }
  public resetFailedRequestLoggingMode() {
    this._failedRequestLoggingMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get failedRequestLoggingModeInput() {
    return this._failedRequestLoggingMode;
  }

  // flush_period_sec - computed: true, optional: true, required: false
  private _flushPeriodSec?: number; 
  public get flushPeriodSec() {
    return this.getNumberAttribute('flush_period_sec');
  }
  public set flushPeriodSec(value: number) {
    this._flushPeriodSec = value;
  }
  public resetFlushPeriodSec() {
    this._flushPeriodSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get flushPeriodSecInput() {
    return this._flushPeriodSec;
  }

  // format - computed: false, optional: true, required: false
  private _format?: string; 
  public get format() {
    return this.getStringAttribute('format');
  }
  public set format(value: string) {
    this._format = value;
  }
  public resetFormat() {
    this._format = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get formatInput() {
    return this._format;
  }

  // format_event_code - computed: false, optional: true, required: false
  private _formatEventCode?: string; 
  public get formatEventCode() {
    return this.getStringAttribute('format_event_code');
  }
  public set formatEventCode(value: string) {
    this._formatEventCode = value;
  }
  public resetFormatEventCode() {
    this._formatEventCode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get formatEventCodeInput() {
    return this._formatEventCode;
  }

  // format_payload_code - computed: false, optional: true, required: false
  private _formatPayloadCode?: string; 
  public get formatPayloadCode() {
    return this.getStringAttribute('format_payload_code');
  }
  public set formatPayloadCode(value: string) {
    this._formatPayloadCode = value;
  }
  public resetFormatPayloadCode() {
    this._formatPayloadCode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get formatPayloadCodeInput() {
    return this._formatPayloadCode;
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // keep_alive - computed: true, optional: true, required: false
  private _keepAlive?: boolean | cdktf.IResolvable; 
  public get keepAlive() {
    return this.getBooleanAttribute('keep_alive');
  }
  public set keepAlive(value: boolean | cdktf.IResolvable) {
    this._keepAlive = value;
  }
  public resetKeepAlive() {
    this._keepAlive = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keepAliveInput() {
    return this._keepAlive;
  }

  // login_url - computed: false, optional: false, required: true
  private _loginUrl?: string; 
  public get loginUrl() {
    return this.getStringAttribute('login_url');
  }
  public set loginUrl(value: string) {
    this._loginUrl = value;
  }
  // Temporarily expose input value. Use with caution.
  public get loginUrlInput() {
    return this._loginUrl;
  }

  // max_payload_events - computed: true, optional: true, required: false
  private _maxPayloadEvents?: number; 
  public get maxPayloadEvents() {
    return this.getNumberAttribute('max_payload_events');
  }
  public set maxPayloadEvents(value: number) {
    this._maxPayloadEvents = value;
  }
  public resetMaxPayloadEvents() {
    this._maxPayloadEvents = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxPayloadEventsInput() {
    return this._maxPayloadEvents;
  }

  // max_payload_size_kb - computed: true, optional: true, required: false
  private _maxPayloadSizeKb?: number; 
  public get maxPayloadSizeKb() {
    return this.getNumberAttribute('max_payload_size_kb');
  }
  public set maxPayloadSizeKb(value: number) {
    this._maxPayloadSizeKb = value;
  }
  public resetMaxPayloadSizeKb() {
    this._maxPayloadSizeKb = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxPayloadSizeKbInput() {
    return this._maxPayloadSizeKb;
  }

  // on_backpressure - computed: true, optional: true, required: false
  private _onBackpressure?: string; 
  public get onBackpressure() {
    return this.getStringAttribute('on_backpressure');
  }
  public set onBackpressure(value: string) {
    this._onBackpressure = value;
  }
  public resetOnBackpressure() {
    this._onBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get onBackpressureInput() {
    return this._onBackpressure;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // pq_compress - computed: true, optional: true, required: false
  private _pqCompress?: string; 
  public get pqCompress() {
    return this.getStringAttribute('pq_compress');
  }
  public set pqCompress(value: string) {
    this._pqCompress = value;
  }
  public resetPqCompress() {
    this._pqCompress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqCompressInput() {
    return this._pqCompress;
  }

  // pq_controls - computed: false, optional: true, required: false
  private _pqControls = new PackDestinationOutputSentinelPqControlsOutputReference(this, "pq_controls");
  public get pqControls() {
    return this._pqControls;
  }
  public putPqControls(value: PackDestinationOutputSentinelPqControls) {
    this._pqControls.internalValue = value;
  }
  public resetPqControls() {
    this._pqControls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqControlsInput() {
    return this._pqControls.internalValue;
  }

  // pq_max_file_size - computed: true, optional: true, required: false
  private _pqMaxFileSize?: string; 
  public get pqMaxFileSize() {
    return this.getStringAttribute('pq_max_file_size');
  }
  public set pqMaxFileSize(value: string) {
    this._pqMaxFileSize = value;
  }
  public resetPqMaxFileSize() {
    this._pqMaxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxFileSizeInput() {
    return this._pqMaxFileSize;
  }

  // pq_max_size - computed: true, optional: true, required: false
  private _pqMaxSize?: string; 
  public get pqMaxSize() {
    return this.getStringAttribute('pq_max_size');
  }
  public set pqMaxSize(value: string) {
    this._pqMaxSize = value;
  }
  public resetPqMaxSize() {
    this._pqMaxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxSizeInput() {
    return this._pqMaxSize;
  }

  // pq_mode - computed: true, optional: true, required: false
  private _pqMode?: string; 
  public get pqMode() {
    return this.getStringAttribute('pq_mode');
  }
  public set pqMode(value: string) {
    this._pqMode = value;
  }
  public resetPqMode() {
    this._pqMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqModeInput() {
    return this._pqMode;
  }

  // pq_on_backpressure - computed: true, optional: true, required: false
  private _pqOnBackpressure?: string; 
  public get pqOnBackpressure() {
    return this.getStringAttribute('pq_on_backpressure');
  }
  public set pqOnBackpressure(value: string) {
    this._pqOnBackpressure = value;
  }
  public resetPqOnBackpressure() {
    this._pqOnBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqOnBackpressureInput() {
    return this._pqOnBackpressure;
  }

  // pq_path - computed: true, optional: true, required: false
  private _pqPath?: string; 
  public get pqPath() {
    return this.getStringAttribute('pq_path');
  }
  public set pqPath(value: string) {
    this._pqPath = value;
  }
  public resetPqPath() {
    this._pqPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqPathInput() {
    return this._pqPath;
  }

  // reject_unauthorized - computed: true, optional: true, required: false
  private _rejectUnauthorized?: boolean | cdktf.IResolvable; 
  public get rejectUnauthorized() {
    return this.getBooleanAttribute('reject_unauthorized');
  }
  public set rejectUnauthorized(value: boolean | cdktf.IResolvable) {
    this._rejectUnauthorized = value;
  }
  public resetRejectUnauthorized() {
    this._rejectUnauthorized = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectUnauthorizedInput() {
    return this._rejectUnauthorized;
  }

  // response_honor_retry_after_header - computed: true, optional: true, required: false
  private _responseHonorRetryAfterHeader?: boolean | cdktf.IResolvable; 
  public get responseHonorRetryAfterHeader() {
    return this.getBooleanAttribute('response_honor_retry_after_header');
  }
  public set responseHonorRetryAfterHeader(value: boolean | cdktf.IResolvable) {
    this._responseHonorRetryAfterHeader = value;
  }
  public resetResponseHonorRetryAfterHeader() {
    this._responseHonorRetryAfterHeader = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get responseHonorRetryAfterHeaderInput() {
    return this._responseHonorRetryAfterHeader;
  }

  // response_retry_settings - computed: false, optional: true, required: false
  private _responseRetrySettings = new PackDestinationOutputSentinelResponseRetrySettingsList(this, "response_retry_settings", false);
  public get responseRetrySettings() {
    return this._responseRetrySettings;
  }
  public putResponseRetrySettings(value: PackDestinationOutputSentinelResponseRetrySettings[] | cdktf.IResolvable) {
    this._responseRetrySettings.internalValue = value;
  }
  public resetResponseRetrySettings() {
    this._responseRetrySettings.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get responseRetrySettingsInput() {
    return this._responseRetrySettings.internalValue;
  }

  // safe_headers - computed: true, optional: true, required: false
  private _safeHeaders?: string[]; 
  public get safeHeaders() {
    return this.getListAttribute('safe_headers');
  }
  public set safeHeaders(value: string[]) {
    this._safeHeaders = value;
  }
  public resetSafeHeaders() {
    this._safeHeaders = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get safeHeadersInput() {
    return this._safeHeaders;
  }

  // scope - computed: true, optional: true, required: false
  private _scope?: string; 
  public get scope() {
    return this.getStringAttribute('scope');
  }
  public set scope(value: string) {
    this._scope = value;
  }
  public resetScope() {
    this._scope = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get scopeInput() {
    return this._scope;
  }

  // secret - computed: false, optional: false, required: true
  private _secret?: string; 
  public get secret() {
    return this.getStringAttribute('secret');
  }
  public set secret(value: string) {
    this._secret = value;
  }
  // Temporarily expose input value. Use with caution.
  public get secretInput() {
    return this._secret;
  }

  // stream_name - computed: false, optional: true, required: false
  private _streamName?: string; 
  public get streamName() {
    return this.getStringAttribute('stream_name');
  }
  public set streamName(value: string) {
    this._streamName = value;
  }
  public resetStreamName() {
    this._streamName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamNameInput() {
    return this._streamName;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // system_fields - computed: true, optional: true, required: false
  private _systemFields?: string[]; 
  public get systemFields() {
    return this.getListAttribute('system_fields');
  }
  public set systemFields(value: string[]) {
    this._systemFields = value;
  }
  public resetSystemFields() {
    this._systemFields = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get systemFieldsInput() {
    return this._systemFields;
  }

  // timeout_retry_settings - computed: false, optional: true, required: false
  private _timeoutRetrySettings = new PackDestinationOutputSentinelTimeoutRetrySettingsOutputReference(this, "timeout_retry_settings");
  public get timeoutRetrySettings() {
    return this._timeoutRetrySettings;
  }
  public putTimeoutRetrySettings(value: PackDestinationOutputSentinelTimeoutRetrySettings) {
    this._timeoutRetrySettings.internalValue = value;
  }
  public resetTimeoutRetrySettings() {
    this._timeoutRetrySettings.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutRetrySettingsInput() {
    return this._timeoutRetrySettings.internalValue;
  }

  // timeout_sec - computed: true, optional: true, required: false
  private _timeoutSec?: number; 
  public get timeoutSec() {
    return this.getNumberAttribute('timeout_sec');
  }
  public set timeoutSec(value: number) {
    this._timeoutSec = value;
  }
  public resetTimeoutSec() {
    this._timeoutSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutSecInput() {
    return this._timeoutSec;
  }

  // total_memory_limit_kb - computed: false, optional: true, required: false
  private _totalMemoryLimitKb?: number; 
  public get totalMemoryLimitKb() {
    return this.getNumberAttribute('total_memory_limit_kb');
  }
  public set totalMemoryLimitKb(value: number) {
    this._totalMemoryLimitKb = value;
  }
  public resetTotalMemoryLimitKb() {
    this._totalMemoryLimitKb = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get totalMemoryLimitKbInput() {
    return this._totalMemoryLimitKb;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // url - computed: false, optional: true, required: false
  private _url?: string; 
  public get url() {
    return this.getStringAttribute('url');
  }
  public set url(value: string) {
    this._url = value;
  }
  public resetUrl() {
    this._url = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get urlInput() {
    return this._url;
  }

  // use_round_robin_dns - computed: true, optional: true, required: false
  private _useRoundRobinDns?: boolean | cdktf.IResolvable; 
  public get useRoundRobinDns() {
    return this.getBooleanAttribute('use_round_robin_dns');
  }
  public set useRoundRobinDns(value: boolean | cdktf.IResolvable) {
    this._useRoundRobinDns = value;
  }
  public resetUseRoundRobinDns() {
    this._useRoundRobinDns = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get useRoundRobinDnsInput() {
    return this._useRoundRobinDns;
  }
}
export interface PackDestinationOutputServiceNowExtraHttpHeaders {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#name PackDestination#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#value PackDestination#value}
  */
  readonly value: string;
}

export function packDestinationOutputServiceNowExtraHttpHeadersToTerraform(struct?: PackDestinationOutputServiceNowExtraHttpHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function packDestinationOutputServiceNowExtraHttpHeadersToHclTerraform(struct?: PackDestinationOutputServiceNowExtraHttpHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputServiceNowExtraHttpHeadersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackDestinationOutputServiceNowExtraHttpHeaders | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputServiceNowExtraHttpHeaders | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class PackDestinationOutputServiceNowExtraHttpHeadersList extends cdktf.ComplexList {
  public internalValue? : PackDestinationOutputServiceNowExtraHttpHeaders[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackDestinationOutputServiceNowExtraHttpHeadersOutputReference {
    return new PackDestinationOutputServiceNowExtraHttpHeadersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackDestinationOutputServiceNowMetadata {
  /**
  * Default: ""
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#key PackDestination#key}
  */
  readonly key?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#value PackDestination#value}
  */
  readonly value: string;
}

export function packDestinationOutputServiceNowMetadataToTerraform(struct?: PackDestinationOutputServiceNowMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function packDestinationOutputServiceNowMetadataToHclTerraform(struct?: PackDestinationOutputServiceNowMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputServiceNowMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackDestinationOutputServiceNowMetadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputServiceNowMetadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._value = value.value;
    }
  }

  // key - computed: true, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class PackDestinationOutputServiceNowMetadataList extends cdktf.ComplexList {
  public internalValue? : PackDestinationOutputServiceNowMetadata[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackDestinationOutputServiceNowMetadataOutputReference {
    return new PackDestinationOutputServiceNowMetadataOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackDestinationOutputServiceNowPqControls {
}

export function packDestinationOutputServiceNowPqControlsToTerraform(struct?: PackDestinationOutputServiceNowPqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function packDestinationOutputServiceNowPqControlsToHclTerraform(struct?: PackDestinationOutputServiceNowPqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class PackDestinationOutputServiceNowPqControlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackDestinationOutputServiceNowPqControls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputServiceNowPqControls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface PackDestinationOutputServiceNowResponseRetrySettings {
  /**
  * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc. Default: 2
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#backoff_rate PackDestination#backoff_rate}
  */
  readonly backoffRate?: number;
  /**
  * The HTTP response status code that will trigger retries
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#http_status PackDestination#http_status}
  */
  readonly httpStatus: number;
  /**
  * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes). Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#initial_backoff PackDestination#initial_backoff}
  */
  readonly initialBackoff?: number;
  /**
  * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds). Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_backoff PackDestination#max_backoff}
  */
  readonly maxBackoff?: number;
}

export function packDestinationOutputServiceNowResponseRetrySettingsToTerraform(struct?: PackDestinationOutputServiceNowResponseRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    backoff_rate: cdktf.numberToTerraform(struct!.backoffRate),
    http_status: cdktf.numberToTerraform(struct!.httpStatus),
    initial_backoff: cdktf.numberToTerraform(struct!.initialBackoff),
    max_backoff: cdktf.numberToTerraform(struct!.maxBackoff),
  }
}


export function packDestinationOutputServiceNowResponseRetrySettingsToHclTerraform(struct?: PackDestinationOutputServiceNowResponseRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    backoff_rate: {
      value: cdktf.numberToHclTerraform(struct!.backoffRate),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    http_status: {
      value: cdktf.numberToHclTerraform(struct!.httpStatus),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    initial_backoff: {
      value: cdktf.numberToHclTerraform(struct!.initialBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_backoff: {
      value: cdktf.numberToHclTerraform(struct!.maxBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputServiceNowResponseRetrySettingsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackDestinationOutputServiceNowResponseRetrySettings | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._backoffRate !== undefined) {
      hasAnyValues = true;
      internalValueResult.backoffRate = this._backoffRate;
    }
    if (this._httpStatus !== undefined) {
      hasAnyValues = true;
      internalValueResult.httpStatus = this._httpStatus;
    }
    if (this._initialBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.initialBackoff = this._initialBackoff;
    }
    if (this._maxBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBackoff = this._maxBackoff;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputServiceNowResponseRetrySettings | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._backoffRate = undefined;
      this._httpStatus = undefined;
      this._initialBackoff = undefined;
      this._maxBackoff = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._backoffRate = value.backoffRate;
      this._httpStatus = value.httpStatus;
      this._initialBackoff = value.initialBackoff;
      this._maxBackoff = value.maxBackoff;
    }
  }

  // backoff_rate - computed: true, optional: true, required: false
  private _backoffRate?: number; 
  public get backoffRate() {
    return this.getNumberAttribute('backoff_rate');
  }
  public set backoffRate(value: number) {
    this._backoffRate = value;
  }
  public resetBackoffRate() {
    this._backoffRate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get backoffRateInput() {
    return this._backoffRate;
  }

  // http_status - computed: false, optional: false, required: true
  private _httpStatus?: number; 
  public get httpStatus() {
    return this.getNumberAttribute('http_status');
  }
  public set httpStatus(value: number) {
    this._httpStatus = value;
  }
  // Temporarily expose input value. Use with caution.
  public get httpStatusInput() {
    return this._httpStatus;
  }

  // initial_backoff - computed: true, optional: true, required: false
  private _initialBackoff?: number; 
  public get initialBackoff() {
    return this.getNumberAttribute('initial_backoff');
  }
  public set initialBackoff(value: number) {
    this._initialBackoff = value;
  }
  public resetInitialBackoff() {
    this._initialBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get initialBackoffInput() {
    return this._initialBackoff;
  }

  // max_backoff - computed: true, optional: true, required: false
  private _maxBackoff?: number; 
  public get maxBackoff() {
    return this.getNumberAttribute('max_backoff');
  }
  public set maxBackoff(value: number) {
    this._maxBackoff = value;
  }
  public resetMaxBackoff() {
    this._maxBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBackoffInput() {
    return this._maxBackoff;
  }
}

export class PackDestinationOutputServiceNowResponseRetrySettingsList extends cdktf.ComplexList {
  public internalValue? : PackDestinationOutputServiceNowResponseRetrySettings[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackDestinationOutputServiceNowResponseRetrySettingsOutputReference {
    return new PackDestinationOutputServiceNowResponseRetrySettingsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackDestinationOutputServiceNowTimeoutRetrySettings {
  /**
  * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc. Default: 2
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#backoff_rate PackDestination#backoff_rate}
  */
  readonly backoffRate?: number;
  /**
  * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes). Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#initial_backoff PackDestination#initial_backoff}
  */
  readonly initialBackoff?: number;
  /**
  * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds). Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_backoff PackDestination#max_backoff}
  */
  readonly maxBackoff?: number;
  /**
  * Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#timeout_retry PackDestination#timeout_retry}
  */
  readonly timeoutRetry?: boolean | cdktf.IResolvable;
}

export function packDestinationOutputServiceNowTimeoutRetrySettingsToTerraform(struct?: PackDestinationOutputServiceNowTimeoutRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    backoff_rate: cdktf.numberToTerraform(struct!.backoffRate),
    initial_backoff: cdktf.numberToTerraform(struct!.initialBackoff),
    max_backoff: cdktf.numberToTerraform(struct!.maxBackoff),
    timeout_retry: cdktf.booleanToTerraform(struct!.timeoutRetry),
  }
}


export function packDestinationOutputServiceNowTimeoutRetrySettingsToHclTerraform(struct?: PackDestinationOutputServiceNowTimeoutRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    backoff_rate: {
      value: cdktf.numberToHclTerraform(struct!.backoffRate),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    initial_backoff: {
      value: cdktf.numberToHclTerraform(struct!.initialBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_backoff: {
      value: cdktf.numberToHclTerraform(struct!.maxBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    timeout_retry: {
      value: cdktf.booleanToHclTerraform(struct!.timeoutRetry),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputServiceNowTimeoutRetrySettingsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackDestinationOutputServiceNowTimeoutRetrySettings | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._backoffRate !== undefined) {
      hasAnyValues = true;
      internalValueResult.backoffRate = this._backoffRate;
    }
    if (this._initialBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.initialBackoff = this._initialBackoff;
    }
    if (this._maxBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBackoff = this._maxBackoff;
    }
    if (this._timeoutRetry !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutRetry = this._timeoutRetry;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputServiceNowTimeoutRetrySettings | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._backoffRate = undefined;
      this._initialBackoff = undefined;
      this._maxBackoff = undefined;
      this._timeoutRetry = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._backoffRate = value.backoffRate;
      this._initialBackoff = value.initialBackoff;
      this._maxBackoff = value.maxBackoff;
      this._timeoutRetry = value.timeoutRetry;
    }
  }

  // backoff_rate - computed: true, optional: true, required: false
  private _backoffRate?: number; 
  public get backoffRate() {
    return this.getNumberAttribute('backoff_rate');
  }
  public set backoffRate(value: number) {
    this._backoffRate = value;
  }
  public resetBackoffRate() {
    this._backoffRate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get backoffRateInput() {
    return this._backoffRate;
  }

  // initial_backoff - computed: true, optional: true, required: false
  private _initialBackoff?: number; 
  public get initialBackoff() {
    return this.getNumberAttribute('initial_backoff');
  }
  public set initialBackoff(value: number) {
    this._initialBackoff = value;
  }
  public resetInitialBackoff() {
    this._initialBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get initialBackoffInput() {
    return this._initialBackoff;
  }

  // max_backoff - computed: true, optional: true, required: false
  private _maxBackoff?: number; 
  public get maxBackoff() {
    return this.getNumberAttribute('max_backoff');
  }
  public set maxBackoff(value: number) {
    this._maxBackoff = value;
  }
  public resetMaxBackoff() {
    this._maxBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBackoffInput() {
    return this._maxBackoff;
  }

  // timeout_retry - computed: true, optional: true, required: false
  private _timeoutRetry?: boolean | cdktf.IResolvable; 
  public get timeoutRetry() {
    return this.getBooleanAttribute('timeout_retry');
  }
  public set timeoutRetry(value: boolean | cdktf.IResolvable) {
    this._timeoutRetry = value;
  }
  public resetTimeoutRetry() {
    this._timeoutRetry = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutRetryInput() {
    return this._timeoutRetry;
  }
}
export interface PackDestinationOutputServiceNowTls {
  /**
  * Path on client in which to find CA certificates to verify the server's cert. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#ca_path PackDestination#ca_path}
  */
  readonly caPath?: string;
  /**
  * Path on client in which to find certificates to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#cert_path PackDestination#cert_path}
  */
  readonly certPath?: string;
  /**
  * The name of the predefined certificate
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#certificate_name PackDestination#certificate_name}
  */
  readonly certificateName?: string;
  /**
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#disabled PackDestination#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_version PackDestination#max_version}
  */
  readonly maxVersion?: string;
  /**
  * must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#min_version PackDestination#min_version}
  */
  readonly minVersion?: string;
  /**
  * Passphrase to use to decrypt private key
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#passphrase PackDestination#passphrase}
  */
  readonly passphrase?: string;
  /**
  * Path on client in which to find the private key to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#priv_key_path PackDestination#priv_key_path}
  */
  readonly privKeyPath?: string;
  /**
  * Reject certificates that are not authorized by a CA in the CA certificate path, or by another
  * 
  * 
  *                     trusted CA (such as the system's). Defaults to Enabled. Overrides the toggle from Advanced Settings, when also present.
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#reject_unauthorized PackDestination#reject_unauthorized}
  */
  readonly rejectUnauthorized?: boolean | cdktf.IResolvable;
}

export function packDestinationOutputServiceNowTlsToTerraform(struct?: PackDestinationOutputServiceNowTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ca_path: cdktf.stringToTerraform(struct!.caPath),
    cert_path: cdktf.stringToTerraform(struct!.certPath),
    certificate_name: cdktf.stringToTerraform(struct!.certificateName),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    max_version: cdktf.stringToTerraform(struct!.maxVersion),
    min_version: cdktf.stringToTerraform(struct!.minVersion),
    passphrase: cdktf.stringToTerraform(struct!.passphrase),
    priv_key_path: cdktf.stringToTerraform(struct!.privKeyPath),
    reject_unauthorized: cdktf.booleanToTerraform(struct!.rejectUnauthorized),
  }
}


export function packDestinationOutputServiceNowTlsToHclTerraform(struct?: PackDestinationOutputServiceNowTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ca_path: {
      value: cdktf.stringToHclTerraform(struct!.caPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    cert_path: {
      value: cdktf.stringToHclTerraform(struct!.certPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    certificate_name: {
      value: cdktf.stringToHclTerraform(struct!.certificateName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    max_version: {
      value: cdktf.stringToHclTerraform(struct!.maxVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    min_version: {
      value: cdktf.stringToHclTerraform(struct!.minVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    passphrase: {
      value: cdktf.stringToHclTerraform(struct!.passphrase),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    priv_key_path: {
      value: cdktf.stringToHclTerraform(struct!.privKeyPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reject_unauthorized: {
      value: cdktf.booleanToHclTerraform(struct!.rejectUnauthorized),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputServiceNowTlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackDestinationOutputServiceNowTls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._caPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.caPath = this._caPath;
    }
    if (this._certPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.certPath = this._certPath;
    }
    if (this._certificateName !== undefined) {
      hasAnyValues = true;
      internalValueResult.certificateName = this._certificateName;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._maxVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxVersion = this._maxVersion;
    }
    if (this._minVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.minVersion = this._minVersion;
    }
    if (this._passphrase !== undefined) {
      hasAnyValues = true;
      internalValueResult.passphrase = this._passphrase;
    }
    if (this._privKeyPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.privKeyPath = this._privKeyPath;
    }
    if (this._rejectUnauthorized !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectUnauthorized = this._rejectUnauthorized;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputServiceNowTls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._caPath = undefined;
      this._certPath = undefined;
      this._certificateName = undefined;
      this._disabled = undefined;
      this._maxVersion = undefined;
      this._minVersion = undefined;
      this._passphrase = undefined;
      this._privKeyPath = undefined;
      this._rejectUnauthorized = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._caPath = value.caPath;
      this._certPath = value.certPath;
      this._certificateName = value.certificateName;
      this._disabled = value.disabled;
      this._maxVersion = value.maxVersion;
      this._minVersion = value.minVersion;
      this._passphrase = value.passphrase;
      this._privKeyPath = value.privKeyPath;
      this._rejectUnauthorized = value.rejectUnauthorized;
    }
  }

  // ca_path - computed: false, optional: true, required: false
  private _caPath?: string; 
  public get caPath() {
    return this.getStringAttribute('ca_path');
  }
  public set caPath(value: string) {
    this._caPath = value;
  }
  public resetCaPath() {
    this._caPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get caPathInput() {
    return this._caPath;
  }

  // cert_path - computed: false, optional: true, required: false
  private _certPath?: string; 
  public get certPath() {
    return this.getStringAttribute('cert_path');
  }
  public set certPath(value: string) {
    this._certPath = value;
  }
  public resetCertPath() {
    this._certPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certPathInput() {
    return this._certPath;
  }

  // certificate_name - computed: false, optional: true, required: false
  private _certificateName?: string; 
  public get certificateName() {
    return this.getStringAttribute('certificate_name');
  }
  public set certificateName(value: string) {
    this._certificateName = value;
  }
  public resetCertificateName() {
    this._certificateName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certificateNameInput() {
    return this._certificateName;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // max_version - computed: false, optional: true, required: false
  private _maxVersion?: string; 
  public get maxVersion() {
    return this.getStringAttribute('max_version');
  }
  public set maxVersion(value: string) {
    this._maxVersion = value;
  }
  public resetMaxVersion() {
    this._maxVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxVersionInput() {
    return this._maxVersion;
  }

  // min_version - computed: false, optional: true, required: false
  private _minVersion?: string; 
  public get minVersion() {
    return this.getStringAttribute('min_version');
  }
  public set minVersion(value: string) {
    this._minVersion = value;
  }
  public resetMinVersion() {
    this._minVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get minVersionInput() {
    return this._minVersion;
  }

  // passphrase - computed: false, optional: true, required: false
  private _passphrase?: string; 
  public get passphrase() {
    return this.getStringAttribute('passphrase');
  }
  public set passphrase(value: string) {
    this._passphrase = value;
  }
  public resetPassphrase() {
    this._passphrase = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passphraseInput() {
    return this._passphrase;
  }

  // priv_key_path - computed: false, optional: true, required: false
  private _privKeyPath?: string; 
  public get privKeyPath() {
    return this.getStringAttribute('priv_key_path');
  }
  public set privKeyPath(value: string) {
    this._privKeyPath = value;
  }
  public resetPrivKeyPath() {
    this._privKeyPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get privKeyPathInput() {
    return this._privKeyPath;
  }

  // reject_unauthorized - computed: true, optional: true, required: false
  private _rejectUnauthorized?: boolean | cdktf.IResolvable; 
  public get rejectUnauthorized() {
    return this.getBooleanAttribute('reject_unauthorized');
  }
  public set rejectUnauthorized(value: boolean | cdktf.IResolvable) {
    this._rejectUnauthorized = value;
  }
  public resetRejectUnauthorized() {
    this._rejectUnauthorized = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectUnauthorizedInput() {
    return this._rejectUnauthorized;
  }
}
export interface PackDestinationOutputServiceNow {
  /**
  * Default: "lightstep-access-token"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#auth_token_name PackDestination#auth_token_name}
  */
  readonly authTokenName?: string;
  /**
  * Type of compression to apply to messages sent to the OpenTelemetry endpoint. Default: "gzip"; must be one of ["none", "deflate", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#compress PackDestination#compress}
  */
  readonly compress?: string;
  /**
  * Maximum number of ongoing requests before blocking. Default: 5
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#concurrency PackDestination#concurrency}
  */
  readonly concurrency?: number;
  /**
  * Amount of time (milliseconds) to wait for the connection to establish before retrying. Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#connection_timeout PackDestination#connection_timeout}
  */
  readonly connectionTimeout?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#description PackDestination#description}
  */
  readonly description?: string;
  /**
  * The endpoint where ServiceNow events will be sent. Enter any valid URL or an IP address (IPv4 or IPv6; enclose IPv6 addresses in square brackets). Default: "ingest.lightstep.com:443"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#endpoint PackDestination#endpoint}
  */
  readonly endpoint?: string;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#environment PackDestination#environment}
  */
  readonly environment?: string;
  /**
  * Headers to add to all events
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#extra_http_headers PackDestination#extra_http_headers}
  */
  readonly extraHttpHeaders?: PackDestinationOutputServiceNowExtraHttpHeaders[] | cdktf.IResolvable;
  /**
  * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below. Default: "none"; must be one of ["payload", "payloadAndHeaders", "none"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#failed_request_logging_mode PackDestination#failed_request_logging_mode}
  */
  readonly failedRequestLoggingMode?: string;
  /**
  * Maximum time between requests. Small values could cause the payload size to be smaller than the configured Body size limit. Default: 1
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#flush_period_sec PackDestination#flush_period_sec}
  */
  readonly flushPeriodSec?: number;
  /**
  * Type of compression to apply to messages sent to the OpenTelemetry endpoint. Default: "gzip"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#http_compress PackDestination#http_compress}
  */
  readonly httpCompress?: string;
  /**
  * If you want to send logs to the default `{endpoint}/v1/logs` endpoint, leave this field empty; otherwise, specify the desired endpoint
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#http_logs_endpoint_override PackDestination#http_logs_endpoint_override}
  */
  readonly httpLogsEndpointOverride?: string;
  /**
  * If you want to send metrics to the default `{endpoint}/v1/metrics` endpoint, leave this field empty; otherwise, specify the desired endpoint
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#http_metrics_endpoint_override PackDestination#http_metrics_endpoint_override}
  */
  readonly httpMetricsEndpointOverride?: string;
  /**
  * If you want to send traces to the default `{endpoint}/v1/traces` endpoint, leave this field empty; otherwise, specify the desired endpoint
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#http_traces_endpoint_override PackDestination#http_traces_endpoint_override}
  */
  readonly httpTracesEndpointOverride?: string;
  /**
  * Unique ID for this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#id PackDestination#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * Disable to close the connection immediately after sending the outgoing request. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#keep_alive PackDestination#keep_alive}
  */
  readonly keepAlive?: boolean | cdktf.IResolvable;
  /**
  * How often the sender should ping the peer to keep the connection open. Default: 30
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#keep_alive_time PackDestination#keep_alive_time}
  */
  readonly keepAliveTime?: number;
  /**
  * Maximum size, in KB, of the request body. Default: 2048
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_payload_size_kb PackDestination#max_payload_size_kb}
  */
  readonly maxPayloadSizeKb?: number;
  /**
  * List of key-value pairs to send with each gRPC request. Value supports JavaScript expressions that are evaluated just once, when the destination gets started. To pass credentials as metadata, use 'C.Secret'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#metadata PackDestination#metadata}
  */
  readonly metadata?: PackDestinationOutputServiceNowMetadata[] | cdktf.IResolvable;
  /**
  * How to handle events when all receivers are exerting backpressure. Default: "block"; must be one of ["block", "drop", "queue"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#on_backpressure PackDestination#on_backpressure}
  */
  readonly onBackpressure?: string;
  /**
  * The version of OTLP Protobuf definitions to use when structuring data to send. Default: "1.3.1"; must be "1.3.1"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#otlp_version PackDestination#otlp_version}
  */
  readonly otlpVersion?: string;
  /**
  * Pipeline to process data before sending out to this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pipeline PackDestination#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_compress PackDestination#pq_compress}
  */
  readonly pqCompress?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_controls PackDestination#pq_controls}
  */
  readonly pqControls?: PackDestinationOutputServiceNowPqControls;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.). Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_max_file_size PackDestination#pq_max_file_size}
  */
  readonly pqMaxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_max_size PackDestination#pq_max_size}
  */
  readonly pqMaxSize?: string;
  /**
  * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem. Default: "error"; must be one of ["error", "backpressure", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_mode PackDestination#pq_mode}
  */
  readonly pqMode?: string;
  /**
  * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged. Default: "block"; must be one of ["block", "drop"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_on_backpressure PackDestination#pq_on_backpressure}
  */
  readonly pqOnBackpressure?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_path PackDestination#pq_path}
  */
  readonly pqPath?: string;
  /**
  * Select a transport option for OpenTelemetry. Default: "grpc"; must be one of ["grpc", "http"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#protocol PackDestination#protocol}
  */
  readonly protocol?: string;
  /**
  * Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's). 
  *         Enabled by default. When this setting is also present in TLS Settings (Client Side), 
  *         that value will take precedence.
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#reject_unauthorized PackDestination#reject_unauthorized}
  */
  readonly rejectUnauthorized?: boolean | cdktf.IResolvable;
  /**
  * Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#response_honor_retry_after_header PackDestination#response_honor_retry_after_header}
  */
  readonly responseHonorRetryAfterHeader?: boolean | cdktf.IResolvable;
  /**
  * Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#response_retry_settings PackDestination#response_retry_settings}
  */
  readonly responseRetrySettings?: PackDestinationOutputServiceNowResponseRetrySettings[] | cdktf.IResolvable;
  /**
  * List of headers that are safe to log in plain text. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#safe_headers PackDestination#safe_headers}
  */
  readonly safeHeaders?: string[];
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#streamtags PackDestination#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Fields to automatically add to events, such as cribl_pipe. Supports wildcards. Default: ["cribl_pipe"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#system_fields PackDestination#system_fields}
  */
  readonly systemFields?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#timeout_retry_settings PackDestination#timeout_retry_settings}
  */
  readonly timeoutRetrySettings?: PackDestinationOutputServiceNowTimeoutRetrySettings;
  /**
  * Amount of time, in seconds, to wait for a request to complete before canceling it. Default: 30
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#timeout_sec PackDestination#timeout_sec}
  */
  readonly timeoutSec?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#tls PackDestination#tls}
  */
  readonly tls?: PackDestinationOutputServiceNowTls;
  /**
  * Select or create a stored text secret
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#token_secret PackDestination#token_secret}
  */
  readonly tokenSecret: string;
  /**
  * must be "service_now"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#type PackDestination#type}
  */
  readonly type?: string;
  /**
  * Enable round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. For optimal performance, consider enabling this setting for non-load balanced destinations. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#use_round_robin_dns PackDestination#use_round_robin_dns}
  */
  readonly useRoundRobinDns?: boolean | cdktf.IResolvable;
}

export function packDestinationOutputServiceNowToTerraform(struct?: PackDestinationOutputServiceNow | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    auth_token_name: cdktf.stringToTerraform(struct!.authTokenName),
    compress: cdktf.stringToTerraform(struct!.compress),
    concurrency: cdktf.numberToTerraform(struct!.concurrency),
    connection_timeout: cdktf.numberToTerraform(struct!.connectionTimeout),
    description: cdktf.stringToTerraform(struct!.description),
    endpoint: cdktf.stringToTerraform(struct!.endpoint),
    environment: cdktf.stringToTerraform(struct!.environment),
    extra_http_headers: cdktf.listMapper(packDestinationOutputServiceNowExtraHttpHeadersToTerraform, false)(struct!.extraHttpHeaders),
    failed_request_logging_mode: cdktf.stringToTerraform(struct!.failedRequestLoggingMode),
    flush_period_sec: cdktf.numberToTerraform(struct!.flushPeriodSec),
    http_compress: cdktf.stringToTerraform(struct!.httpCompress),
    http_logs_endpoint_override: cdktf.stringToTerraform(struct!.httpLogsEndpointOverride),
    http_metrics_endpoint_override: cdktf.stringToTerraform(struct!.httpMetricsEndpointOverride),
    http_traces_endpoint_override: cdktf.stringToTerraform(struct!.httpTracesEndpointOverride),
    id: cdktf.stringToTerraform(struct!.id),
    keep_alive: cdktf.booleanToTerraform(struct!.keepAlive),
    keep_alive_time: cdktf.numberToTerraform(struct!.keepAliveTime),
    max_payload_size_kb: cdktf.numberToTerraform(struct!.maxPayloadSizeKb),
    metadata: cdktf.listMapper(packDestinationOutputServiceNowMetadataToTerraform, false)(struct!.metadata),
    on_backpressure: cdktf.stringToTerraform(struct!.onBackpressure),
    otlp_version: cdktf.stringToTerraform(struct!.otlpVersion),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    pq_compress: cdktf.stringToTerraform(struct!.pqCompress),
    pq_controls: packDestinationOutputServiceNowPqControlsToTerraform(struct!.pqControls),
    pq_max_file_size: cdktf.stringToTerraform(struct!.pqMaxFileSize),
    pq_max_size: cdktf.stringToTerraform(struct!.pqMaxSize),
    pq_mode: cdktf.stringToTerraform(struct!.pqMode),
    pq_on_backpressure: cdktf.stringToTerraform(struct!.pqOnBackpressure),
    pq_path: cdktf.stringToTerraform(struct!.pqPath),
    protocol: cdktf.stringToTerraform(struct!.protocol),
    reject_unauthorized: cdktf.booleanToTerraform(struct!.rejectUnauthorized),
    response_honor_retry_after_header: cdktf.booleanToTerraform(struct!.responseHonorRetryAfterHeader),
    response_retry_settings: cdktf.listMapper(packDestinationOutputServiceNowResponseRetrySettingsToTerraform, false)(struct!.responseRetrySettings),
    safe_headers: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.safeHeaders),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    system_fields: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.systemFields),
    timeout_retry_settings: packDestinationOutputServiceNowTimeoutRetrySettingsToTerraform(struct!.timeoutRetrySettings),
    timeout_sec: cdktf.numberToTerraform(struct!.timeoutSec),
    tls: packDestinationOutputServiceNowTlsToTerraform(struct!.tls),
    token_secret: cdktf.stringToTerraform(struct!.tokenSecret),
    type: cdktf.stringToTerraform(struct!.type),
    use_round_robin_dns: cdktf.booleanToTerraform(struct!.useRoundRobinDns),
  }
}


export function packDestinationOutputServiceNowToHclTerraform(struct?: PackDestinationOutputServiceNow | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    auth_token_name: {
      value: cdktf.stringToHclTerraform(struct!.authTokenName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    compress: {
      value: cdktf.stringToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    concurrency: {
      value: cdktf.numberToHclTerraform(struct!.concurrency),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    connection_timeout: {
      value: cdktf.numberToHclTerraform(struct!.connectionTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    endpoint: {
      value: cdktf.stringToHclTerraform(struct!.endpoint),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    extra_http_headers: {
      value: cdktf.listMapperHcl(packDestinationOutputServiceNowExtraHttpHeadersToHclTerraform, false)(struct!.extraHttpHeaders),
      isBlock: true,
      type: "list",
      storageClassType: "PackDestinationOutputServiceNowExtraHttpHeadersList",
    },
    failed_request_logging_mode: {
      value: cdktf.stringToHclTerraform(struct!.failedRequestLoggingMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    flush_period_sec: {
      value: cdktf.numberToHclTerraform(struct!.flushPeriodSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    http_compress: {
      value: cdktf.stringToHclTerraform(struct!.httpCompress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    http_logs_endpoint_override: {
      value: cdktf.stringToHclTerraform(struct!.httpLogsEndpointOverride),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    http_metrics_endpoint_override: {
      value: cdktf.stringToHclTerraform(struct!.httpMetricsEndpointOverride),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    http_traces_endpoint_override: {
      value: cdktf.stringToHclTerraform(struct!.httpTracesEndpointOverride),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    keep_alive: {
      value: cdktf.booleanToHclTerraform(struct!.keepAlive),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    keep_alive_time: {
      value: cdktf.numberToHclTerraform(struct!.keepAliveTime),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_payload_size_kb: {
      value: cdktf.numberToHclTerraform(struct!.maxPayloadSizeKb),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    metadata: {
      value: cdktf.listMapperHcl(packDestinationOutputServiceNowMetadataToHclTerraform, false)(struct!.metadata),
      isBlock: true,
      type: "list",
      storageClassType: "PackDestinationOutputServiceNowMetadataList",
    },
    on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.onBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    otlp_version: {
      value: cdktf.stringToHclTerraform(struct!.otlpVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_compress: {
      value: cdktf.stringToHclTerraform(struct!.pqCompress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_controls: {
      value: packDestinationOutputServiceNowPqControlsToHclTerraform(struct!.pqControls),
      isBlock: true,
      type: "struct",
      storageClassType: "PackDestinationOutputServiceNowPqControls",
    },
    pq_max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_max_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_mode: {
      value: cdktf.stringToHclTerraform(struct!.pqMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.pqOnBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_path: {
      value: cdktf.stringToHclTerraform(struct!.pqPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    protocol: {
      value: cdktf.stringToHclTerraform(struct!.protocol),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reject_unauthorized: {
      value: cdktf.booleanToHclTerraform(struct!.rejectUnauthorized),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    response_honor_retry_after_header: {
      value: cdktf.booleanToHclTerraform(struct!.responseHonorRetryAfterHeader),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    response_retry_settings: {
      value: cdktf.listMapperHcl(packDestinationOutputServiceNowResponseRetrySettingsToHclTerraform, false)(struct!.responseRetrySettings),
      isBlock: true,
      type: "list",
      storageClassType: "PackDestinationOutputServiceNowResponseRetrySettingsList",
    },
    safe_headers: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.safeHeaders),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    system_fields: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.systemFields),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    timeout_retry_settings: {
      value: packDestinationOutputServiceNowTimeoutRetrySettingsToHclTerraform(struct!.timeoutRetrySettings),
      isBlock: true,
      type: "struct",
      storageClassType: "PackDestinationOutputServiceNowTimeoutRetrySettings",
    },
    timeout_sec: {
      value: cdktf.numberToHclTerraform(struct!.timeoutSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    tls: {
      value: packDestinationOutputServiceNowTlsToHclTerraform(struct!.tls),
      isBlock: true,
      type: "struct",
      storageClassType: "PackDestinationOutputServiceNowTls",
    },
    token_secret: {
      value: cdktf.stringToHclTerraform(struct!.tokenSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    use_round_robin_dns: {
      value: cdktf.booleanToHclTerraform(struct!.useRoundRobinDns),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputServiceNowOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackDestinationOutputServiceNow | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._authTokenName !== undefined) {
      hasAnyValues = true;
      internalValueResult.authTokenName = this._authTokenName;
    }
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._concurrency !== undefined) {
      hasAnyValues = true;
      internalValueResult.concurrency = this._concurrency;
    }
    if (this._connectionTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.connectionTimeout = this._connectionTimeout;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._endpoint !== undefined) {
      hasAnyValues = true;
      internalValueResult.endpoint = this._endpoint;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._extraHttpHeaders?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.extraHttpHeaders = this._extraHttpHeaders?.internalValue;
    }
    if (this._failedRequestLoggingMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.failedRequestLoggingMode = this._failedRequestLoggingMode;
    }
    if (this._flushPeriodSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.flushPeriodSec = this._flushPeriodSec;
    }
    if (this._httpCompress !== undefined) {
      hasAnyValues = true;
      internalValueResult.httpCompress = this._httpCompress;
    }
    if (this._httpLogsEndpointOverride !== undefined) {
      hasAnyValues = true;
      internalValueResult.httpLogsEndpointOverride = this._httpLogsEndpointOverride;
    }
    if (this._httpMetricsEndpointOverride !== undefined) {
      hasAnyValues = true;
      internalValueResult.httpMetricsEndpointOverride = this._httpMetricsEndpointOverride;
    }
    if (this._httpTracesEndpointOverride !== undefined) {
      hasAnyValues = true;
      internalValueResult.httpTracesEndpointOverride = this._httpTracesEndpointOverride;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._keepAlive !== undefined) {
      hasAnyValues = true;
      internalValueResult.keepAlive = this._keepAlive;
    }
    if (this._keepAliveTime !== undefined) {
      hasAnyValues = true;
      internalValueResult.keepAliveTime = this._keepAliveTime;
    }
    if (this._maxPayloadSizeKb !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxPayloadSizeKb = this._maxPayloadSizeKb;
    }
    if (this._metadata?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadata = this._metadata?.internalValue;
    }
    if (this._onBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.onBackpressure = this._onBackpressure;
    }
    if (this._otlpVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.otlpVersion = this._otlpVersion;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._pqCompress !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqCompress = this._pqCompress;
    }
    if (this._pqControls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqControls = this._pqControls?.internalValue;
    }
    if (this._pqMaxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxFileSize = this._pqMaxFileSize;
    }
    if (this._pqMaxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxSize = this._pqMaxSize;
    }
    if (this._pqMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMode = this._pqMode;
    }
    if (this._pqOnBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqOnBackpressure = this._pqOnBackpressure;
    }
    if (this._pqPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqPath = this._pqPath;
    }
    if (this._protocol !== undefined) {
      hasAnyValues = true;
      internalValueResult.protocol = this._protocol;
    }
    if (this._rejectUnauthorized !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectUnauthorized = this._rejectUnauthorized;
    }
    if (this._responseHonorRetryAfterHeader !== undefined) {
      hasAnyValues = true;
      internalValueResult.responseHonorRetryAfterHeader = this._responseHonorRetryAfterHeader;
    }
    if (this._responseRetrySettings?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.responseRetrySettings = this._responseRetrySettings?.internalValue;
    }
    if (this._safeHeaders !== undefined) {
      hasAnyValues = true;
      internalValueResult.safeHeaders = this._safeHeaders;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._systemFields !== undefined) {
      hasAnyValues = true;
      internalValueResult.systemFields = this._systemFields;
    }
    if (this._timeoutRetrySettings?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutRetrySettings = this._timeoutRetrySettings?.internalValue;
    }
    if (this._timeoutSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutSec = this._timeoutSec;
    }
    if (this._tls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tls = this._tls?.internalValue;
    }
    if (this._tokenSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.tokenSecret = this._tokenSecret;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._useRoundRobinDns !== undefined) {
      hasAnyValues = true;
      internalValueResult.useRoundRobinDns = this._useRoundRobinDns;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputServiceNow | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._authTokenName = undefined;
      this._compress = undefined;
      this._concurrency = undefined;
      this._connectionTimeout = undefined;
      this._description = undefined;
      this._endpoint = undefined;
      this._environment = undefined;
      this._extraHttpHeaders.internalValue = undefined;
      this._failedRequestLoggingMode = undefined;
      this._flushPeriodSec = undefined;
      this._httpCompress = undefined;
      this._httpLogsEndpointOverride = undefined;
      this._httpMetricsEndpointOverride = undefined;
      this._httpTracesEndpointOverride = undefined;
      this._id = undefined;
      this._keepAlive = undefined;
      this._keepAliveTime = undefined;
      this._maxPayloadSizeKb = undefined;
      this._metadata.internalValue = undefined;
      this._onBackpressure = undefined;
      this._otlpVersion = undefined;
      this._pipeline = undefined;
      this._pqCompress = undefined;
      this._pqControls.internalValue = undefined;
      this._pqMaxFileSize = undefined;
      this._pqMaxSize = undefined;
      this._pqMode = undefined;
      this._pqOnBackpressure = undefined;
      this._pqPath = undefined;
      this._protocol = undefined;
      this._rejectUnauthorized = undefined;
      this._responseHonorRetryAfterHeader = undefined;
      this._responseRetrySettings.internalValue = undefined;
      this._safeHeaders = undefined;
      this._streamtags = undefined;
      this._systemFields = undefined;
      this._timeoutRetrySettings.internalValue = undefined;
      this._timeoutSec = undefined;
      this._tls.internalValue = undefined;
      this._tokenSecret = undefined;
      this._type = undefined;
      this._useRoundRobinDns = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._authTokenName = value.authTokenName;
      this._compress = value.compress;
      this._concurrency = value.concurrency;
      this._connectionTimeout = value.connectionTimeout;
      this._description = value.description;
      this._endpoint = value.endpoint;
      this._environment = value.environment;
      this._extraHttpHeaders.internalValue = value.extraHttpHeaders;
      this._failedRequestLoggingMode = value.failedRequestLoggingMode;
      this._flushPeriodSec = value.flushPeriodSec;
      this._httpCompress = value.httpCompress;
      this._httpLogsEndpointOverride = value.httpLogsEndpointOverride;
      this._httpMetricsEndpointOverride = value.httpMetricsEndpointOverride;
      this._httpTracesEndpointOverride = value.httpTracesEndpointOverride;
      this._id = value.id;
      this._keepAlive = value.keepAlive;
      this._keepAliveTime = value.keepAliveTime;
      this._maxPayloadSizeKb = value.maxPayloadSizeKb;
      this._metadata.internalValue = value.metadata;
      this._onBackpressure = value.onBackpressure;
      this._otlpVersion = value.otlpVersion;
      this._pipeline = value.pipeline;
      this._pqCompress = value.pqCompress;
      this._pqControls.internalValue = value.pqControls;
      this._pqMaxFileSize = value.pqMaxFileSize;
      this._pqMaxSize = value.pqMaxSize;
      this._pqMode = value.pqMode;
      this._pqOnBackpressure = value.pqOnBackpressure;
      this._pqPath = value.pqPath;
      this._protocol = value.protocol;
      this._rejectUnauthorized = value.rejectUnauthorized;
      this._responseHonorRetryAfterHeader = value.responseHonorRetryAfterHeader;
      this._responseRetrySettings.internalValue = value.responseRetrySettings;
      this._safeHeaders = value.safeHeaders;
      this._streamtags = value.streamtags;
      this._systemFields = value.systemFields;
      this._timeoutRetrySettings.internalValue = value.timeoutRetrySettings;
      this._timeoutSec = value.timeoutSec;
      this._tls.internalValue = value.tls;
      this._tokenSecret = value.tokenSecret;
      this._type = value.type;
      this._useRoundRobinDns = value.useRoundRobinDns;
    }
  }

  // auth_token_name - computed: true, optional: true, required: false
  private _authTokenName?: string; 
  public get authTokenName() {
    return this.getStringAttribute('auth_token_name');
  }
  public set authTokenName(value: string) {
    this._authTokenName = value;
  }
  public resetAuthTokenName() {
    this._authTokenName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authTokenNameInput() {
    return this._authTokenName;
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: string; 
  public get compress() {
    return this.getStringAttribute('compress');
  }
  public set compress(value: string) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // concurrency - computed: true, optional: true, required: false
  private _concurrency?: number; 
  public get concurrency() {
    return this.getNumberAttribute('concurrency');
  }
  public set concurrency(value: number) {
    this._concurrency = value;
  }
  public resetConcurrency() {
    this._concurrency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get concurrencyInput() {
    return this._concurrency;
  }

  // connection_timeout - computed: true, optional: true, required: false
  private _connectionTimeout?: number; 
  public get connectionTimeout() {
    return this.getNumberAttribute('connection_timeout');
  }
  public set connectionTimeout(value: number) {
    this._connectionTimeout = value;
  }
  public resetConnectionTimeout() {
    this._connectionTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectionTimeoutInput() {
    return this._connectionTimeout;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // endpoint - computed: true, optional: true, required: false
  private _endpoint?: string; 
  public get endpoint() {
    return this.getStringAttribute('endpoint');
  }
  public set endpoint(value: string) {
    this._endpoint = value;
  }
  public resetEndpoint() {
    this._endpoint = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get endpointInput() {
    return this._endpoint;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // extra_http_headers - computed: false, optional: true, required: false
  private _extraHttpHeaders = new PackDestinationOutputServiceNowExtraHttpHeadersList(this, "extra_http_headers", false);
  public get extraHttpHeaders() {
    return this._extraHttpHeaders;
  }
  public putExtraHttpHeaders(value: PackDestinationOutputServiceNowExtraHttpHeaders[] | cdktf.IResolvable) {
    this._extraHttpHeaders.internalValue = value;
  }
  public resetExtraHttpHeaders() {
    this._extraHttpHeaders.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get extraHttpHeadersInput() {
    return this._extraHttpHeaders.internalValue;
  }

  // failed_request_logging_mode - computed: true, optional: true, required: false
  private _failedRequestLoggingMode?: string; 
  public get failedRequestLoggingMode() {
    return this.getStringAttribute('failed_request_logging_mode');
  }
  public set failedRequestLoggingMode(value: string) {
    this._failedRequestLoggingMode = value;
  }
  public resetFailedRequestLoggingMode() {
    this._failedRequestLoggingMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get failedRequestLoggingModeInput() {
    return this._failedRequestLoggingMode;
  }

  // flush_period_sec - computed: true, optional: true, required: false
  private _flushPeriodSec?: number; 
  public get flushPeriodSec() {
    return this.getNumberAttribute('flush_period_sec');
  }
  public set flushPeriodSec(value: number) {
    this._flushPeriodSec = value;
  }
  public resetFlushPeriodSec() {
    this._flushPeriodSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get flushPeriodSecInput() {
    return this._flushPeriodSec;
  }

  // http_compress - computed: true, optional: true, required: false
  private _httpCompress?: string; 
  public get httpCompress() {
    return this.getStringAttribute('http_compress');
  }
  public set httpCompress(value: string) {
    this._httpCompress = value;
  }
  public resetHttpCompress() {
    this._httpCompress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get httpCompressInput() {
    return this._httpCompress;
  }

  // http_logs_endpoint_override - computed: false, optional: true, required: false
  private _httpLogsEndpointOverride?: string; 
  public get httpLogsEndpointOverride() {
    return this.getStringAttribute('http_logs_endpoint_override');
  }
  public set httpLogsEndpointOverride(value: string) {
    this._httpLogsEndpointOverride = value;
  }
  public resetHttpLogsEndpointOverride() {
    this._httpLogsEndpointOverride = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get httpLogsEndpointOverrideInput() {
    return this._httpLogsEndpointOverride;
  }

  // http_metrics_endpoint_override - computed: false, optional: true, required: false
  private _httpMetricsEndpointOverride?: string; 
  public get httpMetricsEndpointOverride() {
    return this.getStringAttribute('http_metrics_endpoint_override');
  }
  public set httpMetricsEndpointOverride(value: string) {
    this._httpMetricsEndpointOverride = value;
  }
  public resetHttpMetricsEndpointOverride() {
    this._httpMetricsEndpointOverride = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get httpMetricsEndpointOverrideInput() {
    return this._httpMetricsEndpointOverride;
  }

  // http_traces_endpoint_override - computed: false, optional: true, required: false
  private _httpTracesEndpointOverride?: string; 
  public get httpTracesEndpointOverride() {
    return this.getStringAttribute('http_traces_endpoint_override');
  }
  public set httpTracesEndpointOverride(value: string) {
    this._httpTracesEndpointOverride = value;
  }
  public resetHttpTracesEndpointOverride() {
    this._httpTracesEndpointOverride = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get httpTracesEndpointOverrideInput() {
    return this._httpTracesEndpointOverride;
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // keep_alive - computed: true, optional: true, required: false
  private _keepAlive?: boolean | cdktf.IResolvable; 
  public get keepAlive() {
    return this.getBooleanAttribute('keep_alive');
  }
  public set keepAlive(value: boolean | cdktf.IResolvable) {
    this._keepAlive = value;
  }
  public resetKeepAlive() {
    this._keepAlive = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keepAliveInput() {
    return this._keepAlive;
  }

  // keep_alive_time - computed: true, optional: true, required: false
  private _keepAliveTime?: number; 
  public get keepAliveTime() {
    return this.getNumberAttribute('keep_alive_time');
  }
  public set keepAliveTime(value: number) {
    this._keepAliveTime = value;
  }
  public resetKeepAliveTime() {
    this._keepAliveTime = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keepAliveTimeInput() {
    return this._keepAliveTime;
  }

  // max_payload_size_kb - computed: true, optional: true, required: false
  private _maxPayloadSizeKb?: number; 
  public get maxPayloadSizeKb() {
    return this.getNumberAttribute('max_payload_size_kb');
  }
  public set maxPayloadSizeKb(value: number) {
    this._maxPayloadSizeKb = value;
  }
  public resetMaxPayloadSizeKb() {
    this._maxPayloadSizeKb = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxPayloadSizeKbInput() {
    return this._maxPayloadSizeKb;
  }

  // metadata - computed: false, optional: true, required: false
  private _metadata = new PackDestinationOutputServiceNowMetadataList(this, "metadata", false);
  public get metadata() {
    return this._metadata;
  }
  public putMetadata(value: PackDestinationOutputServiceNowMetadata[] | cdktf.IResolvable) {
    this._metadata.internalValue = value;
  }
  public resetMetadata() {
    this._metadata.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataInput() {
    return this._metadata.internalValue;
  }

  // on_backpressure - computed: true, optional: true, required: false
  private _onBackpressure?: string; 
  public get onBackpressure() {
    return this.getStringAttribute('on_backpressure');
  }
  public set onBackpressure(value: string) {
    this._onBackpressure = value;
  }
  public resetOnBackpressure() {
    this._onBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get onBackpressureInput() {
    return this._onBackpressure;
  }

  // otlp_version - computed: true, optional: true, required: false
  private _otlpVersion?: string; 
  public get otlpVersion() {
    return this.getStringAttribute('otlp_version');
  }
  public set otlpVersion(value: string) {
    this._otlpVersion = value;
  }
  public resetOtlpVersion() {
    this._otlpVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get otlpVersionInput() {
    return this._otlpVersion;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // pq_compress - computed: true, optional: true, required: false
  private _pqCompress?: string; 
  public get pqCompress() {
    return this.getStringAttribute('pq_compress');
  }
  public set pqCompress(value: string) {
    this._pqCompress = value;
  }
  public resetPqCompress() {
    this._pqCompress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqCompressInput() {
    return this._pqCompress;
  }

  // pq_controls - computed: false, optional: true, required: false
  private _pqControls = new PackDestinationOutputServiceNowPqControlsOutputReference(this, "pq_controls");
  public get pqControls() {
    return this._pqControls;
  }
  public putPqControls(value: PackDestinationOutputServiceNowPqControls) {
    this._pqControls.internalValue = value;
  }
  public resetPqControls() {
    this._pqControls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqControlsInput() {
    return this._pqControls.internalValue;
  }

  // pq_max_file_size - computed: true, optional: true, required: false
  private _pqMaxFileSize?: string; 
  public get pqMaxFileSize() {
    return this.getStringAttribute('pq_max_file_size');
  }
  public set pqMaxFileSize(value: string) {
    this._pqMaxFileSize = value;
  }
  public resetPqMaxFileSize() {
    this._pqMaxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxFileSizeInput() {
    return this._pqMaxFileSize;
  }

  // pq_max_size - computed: true, optional: true, required: false
  private _pqMaxSize?: string; 
  public get pqMaxSize() {
    return this.getStringAttribute('pq_max_size');
  }
  public set pqMaxSize(value: string) {
    this._pqMaxSize = value;
  }
  public resetPqMaxSize() {
    this._pqMaxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxSizeInput() {
    return this._pqMaxSize;
  }

  // pq_mode - computed: true, optional: true, required: false
  private _pqMode?: string; 
  public get pqMode() {
    return this.getStringAttribute('pq_mode');
  }
  public set pqMode(value: string) {
    this._pqMode = value;
  }
  public resetPqMode() {
    this._pqMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqModeInput() {
    return this._pqMode;
  }

  // pq_on_backpressure - computed: true, optional: true, required: false
  private _pqOnBackpressure?: string; 
  public get pqOnBackpressure() {
    return this.getStringAttribute('pq_on_backpressure');
  }
  public set pqOnBackpressure(value: string) {
    this._pqOnBackpressure = value;
  }
  public resetPqOnBackpressure() {
    this._pqOnBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqOnBackpressureInput() {
    return this._pqOnBackpressure;
  }

  // pq_path - computed: true, optional: true, required: false
  private _pqPath?: string; 
  public get pqPath() {
    return this.getStringAttribute('pq_path');
  }
  public set pqPath(value: string) {
    this._pqPath = value;
  }
  public resetPqPath() {
    this._pqPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqPathInput() {
    return this._pqPath;
  }

  // protocol - computed: true, optional: true, required: false
  private _protocol?: string; 
  public get protocol() {
    return this.getStringAttribute('protocol');
  }
  public set protocol(value: string) {
    this._protocol = value;
  }
  public resetProtocol() {
    this._protocol = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get protocolInput() {
    return this._protocol;
  }

  // reject_unauthorized - computed: true, optional: true, required: false
  private _rejectUnauthorized?: boolean | cdktf.IResolvable; 
  public get rejectUnauthorized() {
    return this.getBooleanAttribute('reject_unauthorized');
  }
  public set rejectUnauthorized(value: boolean | cdktf.IResolvable) {
    this._rejectUnauthorized = value;
  }
  public resetRejectUnauthorized() {
    this._rejectUnauthorized = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectUnauthorizedInput() {
    return this._rejectUnauthorized;
  }

  // response_honor_retry_after_header - computed: true, optional: true, required: false
  private _responseHonorRetryAfterHeader?: boolean | cdktf.IResolvable; 
  public get responseHonorRetryAfterHeader() {
    return this.getBooleanAttribute('response_honor_retry_after_header');
  }
  public set responseHonorRetryAfterHeader(value: boolean | cdktf.IResolvable) {
    this._responseHonorRetryAfterHeader = value;
  }
  public resetResponseHonorRetryAfterHeader() {
    this._responseHonorRetryAfterHeader = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get responseHonorRetryAfterHeaderInput() {
    return this._responseHonorRetryAfterHeader;
  }

  // response_retry_settings - computed: false, optional: true, required: false
  private _responseRetrySettings = new PackDestinationOutputServiceNowResponseRetrySettingsList(this, "response_retry_settings", false);
  public get responseRetrySettings() {
    return this._responseRetrySettings;
  }
  public putResponseRetrySettings(value: PackDestinationOutputServiceNowResponseRetrySettings[] | cdktf.IResolvable) {
    this._responseRetrySettings.internalValue = value;
  }
  public resetResponseRetrySettings() {
    this._responseRetrySettings.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get responseRetrySettingsInput() {
    return this._responseRetrySettings.internalValue;
  }

  // safe_headers - computed: true, optional: true, required: false
  private _safeHeaders?: string[]; 
  public get safeHeaders() {
    return this.getListAttribute('safe_headers');
  }
  public set safeHeaders(value: string[]) {
    this._safeHeaders = value;
  }
  public resetSafeHeaders() {
    this._safeHeaders = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get safeHeadersInput() {
    return this._safeHeaders;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // system_fields - computed: true, optional: true, required: false
  private _systemFields?: string[]; 
  public get systemFields() {
    return this.getListAttribute('system_fields');
  }
  public set systemFields(value: string[]) {
    this._systemFields = value;
  }
  public resetSystemFields() {
    this._systemFields = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get systemFieldsInput() {
    return this._systemFields;
  }

  // timeout_retry_settings - computed: false, optional: true, required: false
  private _timeoutRetrySettings = new PackDestinationOutputServiceNowTimeoutRetrySettingsOutputReference(this, "timeout_retry_settings");
  public get timeoutRetrySettings() {
    return this._timeoutRetrySettings;
  }
  public putTimeoutRetrySettings(value: PackDestinationOutputServiceNowTimeoutRetrySettings) {
    this._timeoutRetrySettings.internalValue = value;
  }
  public resetTimeoutRetrySettings() {
    this._timeoutRetrySettings.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutRetrySettingsInput() {
    return this._timeoutRetrySettings.internalValue;
  }

  // timeout_sec - computed: true, optional: true, required: false
  private _timeoutSec?: number; 
  public get timeoutSec() {
    return this.getNumberAttribute('timeout_sec');
  }
  public set timeoutSec(value: number) {
    this._timeoutSec = value;
  }
  public resetTimeoutSec() {
    this._timeoutSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutSecInput() {
    return this._timeoutSec;
  }

  // tls - computed: false, optional: true, required: false
  private _tls = new PackDestinationOutputServiceNowTlsOutputReference(this, "tls");
  public get tls() {
    return this._tls;
  }
  public putTls(value: PackDestinationOutputServiceNowTls) {
    this._tls.internalValue = value;
  }
  public resetTls() {
    this._tls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsInput() {
    return this._tls.internalValue;
  }

  // token_secret - computed: false, optional: false, required: true
  private _tokenSecret?: string; 
  public get tokenSecret() {
    return this.getStringAttribute('token_secret');
  }
  public set tokenSecret(value: string) {
    this._tokenSecret = value;
  }
  // Temporarily expose input value. Use with caution.
  public get tokenSecretInput() {
    return this._tokenSecret;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // use_round_robin_dns - computed: true, optional: true, required: false
  private _useRoundRobinDns?: boolean | cdktf.IResolvable; 
  public get useRoundRobinDns() {
    return this.getBooleanAttribute('use_round_robin_dns');
  }
  public set useRoundRobinDns(value: boolean | cdktf.IResolvable) {
    this._useRoundRobinDns = value;
  }
  public resetUseRoundRobinDns() {
    this._useRoundRobinDns = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get useRoundRobinDnsInput() {
    return this._useRoundRobinDns;
  }
}
export interface PackDestinationOutputSignalfxExtraHttpHeaders {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#name PackDestination#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#value PackDestination#value}
  */
  readonly value: string;
}

export function packDestinationOutputSignalfxExtraHttpHeadersToTerraform(struct?: PackDestinationOutputSignalfxExtraHttpHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function packDestinationOutputSignalfxExtraHttpHeadersToHclTerraform(struct?: PackDestinationOutputSignalfxExtraHttpHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputSignalfxExtraHttpHeadersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackDestinationOutputSignalfxExtraHttpHeaders | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputSignalfxExtraHttpHeaders | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class PackDestinationOutputSignalfxExtraHttpHeadersList extends cdktf.ComplexList {
  public internalValue? : PackDestinationOutputSignalfxExtraHttpHeaders[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackDestinationOutputSignalfxExtraHttpHeadersOutputReference {
    return new PackDestinationOutputSignalfxExtraHttpHeadersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackDestinationOutputSignalfxPqControls {
}

export function packDestinationOutputSignalfxPqControlsToTerraform(struct?: PackDestinationOutputSignalfxPqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function packDestinationOutputSignalfxPqControlsToHclTerraform(struct?: PackDestinationOutputSignalfxPqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class PackDestinationOutputSignalfxPqControlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackDestinationOutputSignalfxPqControls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputSignalfxPqControls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface PackDestinationOutputSignalfxResponseRetrySettings {
  /**
  * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc. Default: 2
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#backoff_rate PackDestination#backoff_rate}
  */
  readonly backoffRate?: number;
  /**
  * The HTTP response status code that will trigger retries
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#http_status PackDestination#http_status}
  */
  readonly httpStatus: number;
  /**
  * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes). Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#initial_backoff PackDestination#initial_backoff}
  */
  readonly initialBackoff?: number;
  /**
  * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds). Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_backoff PackDestination#max_backoff}
  */
  readonly maxBackoff?: number;
}

export function packDestinationOutputSignalfxResponseRetrySettingsToTerraform(struct?: PackDestinationOutputSignalfxResponseRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    backoff_rate: cdktf.numberToTerraform(struct!.backoffRate),
    http_status: cdktf.numberToTerraform(struct!.httpStatus),
    initial_backoff: cdktf.numberToTerraform(struct!.initialBackoff),
    max_backoff: cdktf.numberToTerraform(struct!.maxBackoff),
  }
}


export function packDestinationOutputSignalfxResponseRetrySettingsToHclTerraform(struct?: PackDestinationOutputSignalfxResponseRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    backoff_rate: {
      value: cdktf.numberToHclTerraform(struct!.backoffRate),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    http_status: {
      value: cdktf.numberToHclTerraform(struct!.httpStatus),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    initial_backoff: {
      value: cdktf.numberToHclTerraform(struct!.initialBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_backoff: {
      value: cdktf.numberToHclTerraform(struct!.maxBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputSignalfxResponseRetrySettingsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackDestinationOutputSignalfxResponseRetrySettings | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._backoffRate !== undefined) {
      hasAnyValues = true;
      internalValueResult.backoffRate = this._backoffRate;
    }
    if (this._httpStatus !== undefined) {
      hasAnyValues = true;
      internalValueResult.httpStatus = this._httpStatus;
    }
    if (this._initialBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.initialBackoff = this._initialBackoff;
    }
    if (this._maxBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBackoff = this._maxBackoff;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputSignalfxResponseRetrySettings | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._backoffRate = undefined;
      this._httpStatus = undefined;
      this._initialBackoff = undefined;
      this._maxBackoff = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._backoffRate = value.backoffRate;
      this._httpStatus = value.httpStatus;
      this._initialBackoff = value.initialBackoff;
      this._maxBackoff = value.maxBackoff;
    }
  }

  // backoff_rate - computed: true, optional: true, required: false
  private _backoffRate?: number; 
  public get backoffRate() {
    return this.getNumberAttribute('backoff_rate');
  }
  public set backoffRate(value: number) {
    this._backoffRate = value;
  }
  public resetBackoffRate() {
    this._backoffRate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get backoffRateInput() {
    return this._backoffRate;
  }

  // http_status - computed: false, optional: false, required: true
  private _httpStatus?: number; 
  public get httpStatus() {
    return this.getNumberAttribute('http_status');
  }
  public set httpStatus(value: number) {
    this._httpStatus = value;
  }
  // Temporarily expose input value. Use with caution.
  public get httpStatusInput() {
    return this._httpStatus;
  }

  // initial_backoff - computed: true, optional: true, required: false
  private _initialBackoff?: number; 
  public get initialBackoff() {
    return this.getNumberAttribute('initial_backoff');
  }
  public set initialBackoff(value: number) {
    this._initialBackoff = value;
  }
  public resetInitialBackoff() {
    this._initialBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get initialBackoffInput() {
    return this._initialBackoff;
  }

  // max_backoff - computed: true, optional: true, required: false
  private _maxBackoff?: number; 
  public get maxBackoff() {
    return this.getNumberAttribute('max_backoff');
  }
  public set maxBackoff(value: number) {
    this._maxBackoff = value;
  }
  public resetMaxBackoff() {
    this._maxBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBackoffInput() {
    return this._maxBackoff;
  }
}

export class PackDestinationOutputSignalfxResponseRetrySettingsList extends cdktf.ComplexList {
  public internalValue? : PackDestinationOutputSignalfxResponseRetrySettings[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackDestinationOutputSignalfxResponseRetrySettingsOutputReference {
    return new PackDestinationOutputSignalfxResponseRetrySettingsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackDestinationOutputSignalfxTimeoutRetrySettings {
  /**
  * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc. Default: 2
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#backoff_rate PackDestination#backoff_rate}
  */
  readonly backoffRate?: number;
  /**
  * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes). Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#initial_backoff PackDestination#initial_backoff}
  */
  readonly initialBackoff?: number;
  /**
  * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds). Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_backoff PackDestination#max_backoff}
  */
  readonly maxBackoff?: number;
  /**
  * Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#timeout_retry PackDestination#timeout_retry}
  */
  readonly timeoutRetry?: boolean | cdktf.IResolvable;
}

export function packDestinationOutputSignalfxTimeoutRetrySettingsToTerraform(struct?: PackDestinationOutputSignalfxTimeoutRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    backoff_rate: cdktf.numberToTerraform(struct!.backoffRate),
    initial_backoff: cdktf.numberToTerraform(struct!.initialBackoff),
    max_backoff: cdktf.numberToTerraform(struct!.maxBackoff),
    timeout_retry: cdktf.booleanToTerraform(struct!.timeoutRetry),
  }
}


export function packDestinationOutputSignalfxTimeoutRetrySettingsToHclTerraform(struct?: PackDestinationOutputSignalfxTimeoutRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    backoff_rate: {
      value: cdktf.numberToHclTerraform(struct!.backoffRate),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    initial_backoff: {
      value: cdktf.numberToHclTerraform(struct!.initialBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_backoff: {
      value: cdktf.numberToHclTerraform(struct!.maxBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    timeout_retry: {
      value: cdktf.booleanToHclTerraform(struct!.timeoutRetry),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputSignalfxTimeoutRetrySettingsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackDestinationOutputSignalfxTimeoutRetrySettings | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._backoffRate !== undefined) {
      hasAnyValues = true;
      internalValueResult.backoffRate = this._backoffRate;
    }
    if (this._initialBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.initialBackoff = this._initialBackoff;
    }
    if (this._maxBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBackoff = this._maxBackoff;
    }
    if (this._timeoutRetry !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutRetry = this._timeoutRetry;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputSignalfxTimeoutRetrySettings | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._backoffRate = undefined;
      this._initialBackoff = undefined;
      this._maxBackoff = undefined;
      this._timeoutRetry = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._backoffRate = value.backoffRate;
      this._initialBackoff = value.initialBackoff;
      this._maxBackoff = value.maxBackoff;
      this._timeoutRetry = value.timeoutRetry;
    }
  }

  // backoff_rate - computed: true, optional: true, required: false
  private _backoffRate?: number; 
  public get backoffRate() {
    return this.getNumberAttribute('backoff_rate');
  }
  public set backoffRate(value: number) {
    this._backoffRate = value;
  }
  public resetBackoffRate() {
    this._backoffRate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get backoffRateInput() {
    return this._backoffRate;
  }

  // initial_backoff - computed: true, optional: true, required: false
  private _initialBackoff?: number; 
  public get initialBackoff() {
    return this.getNumberAttribute('initial_backoff');
  }
  public set initialBackoff(value: number) {
    this._initialBackoff = value;
  }
  public resetInitialBackoff() {
    this._initialBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get initialBackoffInput() {
    return this._initialBackoff;
  }

  // max_backoff - computed: true, optional: true, required: false
  private _maxBackoff?: number; 
  public get maxBackoff() {
    return this.getNumberAttribute('max_backoff');
  }
  public set maxBackoff(value: number) {
    this._maxBackoff = value;
  }
  public resetMaxBackoff() {
    this._maxBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBackoffInput() {
    return this._maxBackoff;
  }

  // timeout_retry - computed: true, optional: true, required: false
  private _timeoutRetry?: boolean | cdktf.IResolvable; 
  public get timeoutRetry() {
    return this.getBooleanAttribute('timeout_retry');
  }
  public set timeoutRetry(value: boolean | cdktf.IResolvable) {
    this._timeoutRetry = value;
  }
  public resetTimeoutRetry() {
    this._timeoutRetry = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutRetryInput() {
    return this._timeoutRetry;
  }
}
export interface PackDestinationOutputSignalfx {
  /**
  * Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate. Default: "manual"; must be one of ["manual", "secret"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#auth_type PackDestination#auth_type}
  */
  readonly authType?: string;
  /**
  * Compress the payload body before sending. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#compress PackDestination#compress}
  */
  readonly compress?: boolean | cdktf.IResolvable;
  /**
  * Maximum number of ongoing requests before blocking. Default: 5
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#concurrency PackDestination#concurrency}
  */
  readonly concurrency?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#description PackDestination#description}
  */
  readonly description?: string;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#environment PackDestination#environment}
  */
  readonly environment?: string;
  /**
  * Headers to add to all events
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#extra_http_headers PackDestination#extra_http_headers}
  */
  readonly extraHttpHeaders?: PackDestinationOutputSignalfxExtraHttpHeaders[] | cdktf.IResolvable;
  /**
  * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below. Default: "none"; must be one of ["payload", "payloadAndHeaders", "none"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#failed_request_logging_mode PackDestination#failed_request_logging_mode}
  */
  readonly failedRequestLoggingMode?: string;
  /**
  * Maximum time between requests. Small values could cause the payload size to be smaller than the configured Body size limit. Default: 1
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#flush_period_sec PackDestination#flush_period_sec}
  */
  readonly flushPeriodSec?: number;
  /**
  * Unique ID for this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#id PackDestination#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * Maximum number of events to include in the request body. Default is 0 (unlimited). Default: 0
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_payload_events PackDestination#max_payload_events}
  */
  readonly maxPayloadEvents?: number;
  /**
  * Maximum size, in KB, of the request body. Default: 4096
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_payload_size_kb PackDestination#max_payload_size_kb}
  */
  readonly maxPayloadSizeKb?: number;
  /**
  * How to handle events when all receivers are exerting backpressure. Default: "block"; must be one of ["block", "drop", "queue"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#on_backpressure PackDestination#on_backpressure}
  */
  readonly onBackpressure?: string;
  /**
  * Pipeline to process data before sending out to this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pipeline PackDestination#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_compress PackDestination#pq_compress}
  */
  readonly pqCompress?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_controls PackDestination#pq_controls}
  */
  readonly pqControls?: PackDestinationOutputSignalfxPqControls;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.). Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_max_file_size PackDestination#pq_max_file_size}
  */
  readonly pqMaxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_max_size PackDestination#pq_max_size}
  */
  readonly pqMaxSize?: string;
  /**
  * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem. Default: "error"; must be one of ["error", "backpressure", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_mode PackDestination#pq_mode}
  */
  readonly pqMode?: string;
  /**
  * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged. Default: "block"; must be one of ["block", "drop"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_on_backpressure PackDestination#pq_on_backpressure}
  */
  readonly pqOnBackpressure?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_path PackDestination#pq_path}
  */
  readonly pqPath?: string;
  /**
  * SignalFx realm name, e.g. "us0". For a complete list of available SignalFx realm names, please check [here](https://docs.splunk.com/observability/en/get-started/service-description.html#sd-regions). Default: "us0"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#realm PackDestination#realm}
  */
  readonly realm?: string;
  /**
  * Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's). 
  *         Enabled by default. When this setting is also present in TLS Settings (Client Side), 
  *         that value will take precedence.
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#reject_unauthorized PackDestination#reject_unauthorized}
  */
  readonly rejectUnauthorized?: boolean | cdktf.IResolvable;
  /**
  * Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#response_honor_retry_after_header PackDestination#response_honor_retry_after_header}
  */
  readonly responseHonorRetryAfterHeader?: boolean | cdktf.IResolvable;
  /**
  * Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#response_retry_settings PackDestination#response_retry_settings}
  */
  readonly responseRetrySettings?: PackDestinationOutputSignalfxResponseRetrySettings[] | cdktf.IResolvable;
  /**
  * List of headers that are safe to log in plain text. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#safe_headers PackDestination#safe_headers}
  */
  readonly safeHeaders?: string[];
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#streamtags PackDestination#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Fields to automatically add to events, such as cribl_pipe. Supports wildcards. Default: ["cribl_pipe"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#system_fields PackDestination#system_fields}
  */
  readonly systemFields?: string[];
  /**
  * Select or create a stored text secret
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#text_secret PackDestination#text_secret}
  */
  readonly textSecret?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#timeout_retry_settings PackDestination#timeout_retry_settings}
  */
  readonly timeoutRetrySettings?: PackDestinationOutputSignalfxTimeoutRetrySettings;
  /**
  * Amount of time, in seconds, to wait for a request to complete before canceling it. Default: 30
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#timeout_sec PackDestination#timeout_sec}
  */
  readonly timeoutSec?: number;
  /**
  * SignalFx API access token (see [here](https://docs.signalfx.com/en/latest/admin-guide/tokens.html#working-with-access-tokens))
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#token PackDestination#token}
  */
  readonly token?: string;
  /**
  * must be "signalfx"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#type PackDestination#type}
  */
  readonly type: string;
  /**
  * Enable round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. For optimal performance, consider enabling this setting for non-load balanced destinations. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#use_round_robin_dns PackDestination#use_round_robin_dns}
  */
  readonly useRoundRobinDns?: boolean | cdktf.IResolvable;
}

export function packDestinationOutputSignalfxToTerraform(struct?: PackDestinationOutputSignalfx | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    auth_type: cdktf.stringToTerraform(struct!.authType),
    compress: cdktf.booleanToTerraform(struct!.compress),
    concurrency: cdktf.numberToTerraform(struct!.concurrency),
    description: cdktf.stringToTerraform(struct!.description),
    environment: cdktf.stringToTerraform(struct!.environment),
    extra_http_headers: cdktf.listMapper(packDestinationOutputSignalfxExtraHttpHeadersToTerraform, false)(struct!.extraHttpHeaders),
    failed_request_logging_mode: cdktf.stringToTerraform(struct!.failedRequestLoggingMode),
    flush_period_sec: cdktf.numberToTerraform(struct!.flushPeriodSec),
    id: cdktf.stringToTerraform(struct!.id),
    max_payload_events: cdktf.numberToTerraform(struct!.maxPayloadEvents),
    max_payload_size_kb: cdktf.numberToTerraform(struct!.maxPayloadSizeKb),
    on_backpressure: cdktf.stringToTerraform(struct!.onBackpressure),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    pq_compress: cdktf.stringToTerraform(struct!.pqCompress),
    pq_controls: packDestinationOutputSignalfxPqControlsToTerraform(struct!.pqControls),
    pq_max_file_size: cdktf.stringToTerraform(struct!.pqMaxFileSize),
    pq_max_size: cdktf.stringToTerraform(struct!.pqMaxSize),
    pq_mode: cdktf.stringToTerraform(struct!.pqMode),
    pq_on_backpressure: cdktf.stringToTerraform(struct!.pqOnBackpressure),
    pq_path: cdktf.stringToTerraform(struct!.pqPath),
    realm: cdktf.stringToTerraform(struct!.realm),
    reject_unauthorized: cdktf.booleanToTerraform(struct!.rejectUnauthorized),
    response_honor_retry_after_header: cdktf.booleanToTerraform(struct!.responseHonorRetryAfterHeader),
    response_retry_settings: cdktf.listMapper(packDestinationOutputSignalfxResponseRetrySettingsToTerraform, false)(struct!.responseRetrySettings),
    safe_headers: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.safeHeaders),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    system_fields: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.systemFields),
    text_secret: cdktf.stringToTerraform(struct!.textSecret),
    timeout_retry_settings: packDestinationOutputSignalfxTimeoutRetrySettingsToTerraform(struct!.timeoutRetrySettings),
    timeout_sec: cdktf.numberToTerraform(struct!.timeoutSec),
    token: cdktf.stringToTerraform(struct!.token),
    type: cdktf.stringToTerraform(struct!.type),
    use_round_robin_dns: cdktf.booleanToTerraform(struct!.useRoundRobinDns),
  }
}


export function packDestinationOutputSignalfxToHclTerraform(struct?: PackDestinationOutputSignalfx | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    auth_type: {
      value: cdktf.stringToHclTerraform(struct!.authType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    compress: {
      value: cdktf.booleanToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    concurrency: {
      value: cdktf.numberToHclTerraform(struct!.concurrency),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    extra_http_headers: {
      value: cdktf.listMapperHcl(packDestinationOutputSignalfxExtraHttpHeadersToHclTerraform, false)(struct!.extraHttpHeaders),
      isBlock: true,
      type: "list",
      storageClassType: "PackDestinationOutputSignalfxExtraHttpHeadersList",
    },
    failed_request_logging_mode: {
      value: cdktf.stringToHclTerraform(struct!.failedRequestLoggingMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    flush_period_sec: {
      value: cdktf.numberToHclTerraform(struct!.flushPeriodSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_payload_events: {
      value: cdktf.numberToHclTerraform(struct!.maxPayloadEvents),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_payload_size_kb: {
      value: cdktf.numberToHclTerraform(struct!.maxPayloadSizeKb),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.onBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_compress: {
      value: cdktf.stringToHclTerraform(struct!.pqCompress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_controls: {
      value: packDestinationOutputSignalfxPqControlsToHclTerraform(struct!.pqControls),
      isBlock: true,
      type: "struct",
      storageClassType: "PackDestinationOutputSignalfxPqControls",
    },
    pq_max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_max_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_mode: {
      value: cdktf.stringToHclTerraform(struct!.pqMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.pqOnBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_path: {
      value: cdktf.stringToHclTerraform(struct!.pqPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    realm: {
      value: cdktf.stringToHclTerraform(struct!.realm),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reject_unauthorized: {
      value: cdktf.booleanToHclTerraform(struct!.rejectUnauthorized),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    response_honor_retry_after_header: {
      value: cdktf.booleanToHclTerraform(struct!.responseHonorRetryAfterHeader),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    response_retry_settings: {
      value: cdktf.listMapperHcl(packDestinationOutputSignalfxResponseRetrySettingsToHclTerraform, false)(struct!.responseRetrySettings),
      isBlock: true,
      type: "list",
      storageClassType: "PackDestinationOutputSignalfxResponseRetrySettingsList",
    },
    safe_headers: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.safeHeaders),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    system_fields: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.systemFields),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    text_secret: {
      value: cdktf.stringToHclTerraform(struct!.textSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    timeout_retry_settings: {
      value: packDestinationOutputSignalfxTimeoutRetrySettingsToHclTerraform(struct!.timeoutRetrySettings),
      isBlock: true,
      type: "struct",
      storageClassType: "PackDestinationOutputSignalfxTimeoutRetrySettings",
    },
    timeout_sec: {
      value: cdktf.numberToHclTerraform(struct!.timeoutSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    token: {
      value: cdktf.stringToHclTerraform(struct!.token),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    use_round_robin_dns: {
      value: cdktf.booleanToHclTerraform(struct!.useRoundRobinDns),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputSignalfxOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackDestinationOutputSignalfx | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._authType !== undefined) {
      hasAnyValues = true;
      internalValueResult.authType = this._authType;
    }
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._concurrency !== undefined) {
      hasAnyValues = true;
      internalValueResult.concurrency = this._concurrency;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._extraHttpHeaders?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.extraHttpHeaders = this._extraHttpHeaders?.internalValue;
    }
    if (this._failedRequestLoggingMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.failedRequestLoggingMode = this._failedRequestLoggingMode;
    }
    if (this._flushPeriodSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.flushPeriodSec = this._flushPeriodSec;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._maxPayloadEvents !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxPayloadEvents = this._maxPayloadEvents;
    }
    if (this._maxPayloadSizeKb !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxPayloadSizeKb = this._maxPayloadSizeKb;
    }
    if (this._onBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.onBackpressure = this._onBackpressure;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._pqCompress !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqCompress = this._pqCompress;
    }
    if (this._pqControls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqControls = this._pqControls?.internalValue;
    }
    if (this._pqMaxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxFileSize = this._pqMaxFileSize;
    }
    if (this._pqMaxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxSize = this._pqMaxSize;
    }
    if (this._pqMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMode = this._pqMode;
    }
    if (this._pqOnBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqOnBackpressure = this._pqOnBackpressure;
    }
    if (this._pqPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqPath = this._pqPath;
    }
    if (this._realm !== undefined) {
      hasAnyValues = true;
      internalValueResult.realm = this._realm;
    }
    if (this._rejectUnauthorized !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectUnauthorized = this._rejectUnauthorized;
    }
    if (this._responseHonorRetryAfterHeader !== undefined) {
      hasAnyValues = true;
      internalValueResult.responseHonorRetryAfterHeader = this._responseHonorRetryAfterHeader;
    }
    if (this._responseRetrySettings?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.responseRetrySettings = this._responseRetrySettings?.internalValue;
    }
    if (this._safeHeaders !== undefined) {
      hasAnyValues = true;
      internalValueResult.safeHeaders = this._safeHeaders;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._systemFields !== undefined) {
      hasAnyValues = true;
      internalValueResult.systemFields = this._systemFields;
    }
    if (this._textSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.textSecret = this._textSecret;
    }
    if (this._timeoutRetrySettings?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutRetrySettings = this._timeoutRetrySettings?.internalValue;
    }
    if (this._timeoutSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutSec = this._timeoutSec;
    }
    if (this._token !== undefined) {
      hasAnyValues = true;
      internalValueResult.token = this._token;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._useRoundRobinDns !== undefined) {
      hasAnyValues = true;
      internalValueResult.useRoundRobinDns = this._useRoundRobinDns;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputSignalfx | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._authType = undefined;
      this._compress = undefined;
      this._concurrency = undefined;
      this._description = undefined;
      this._environment = undefined;
      this._extraHttpHeaders.internalValue = undefined;
      this._failedRequestLoggingMode = undefined;
      this._flushPeriodSec = undefined;
      this._id = undefined;
      this._maxPayloadEvents = undefined;
      this._maxPayloadSizeKb = undefined;
      this._onBackpressure = undefined;
      this._pipeline = undefined;
      this._pqCompress = undefined;
      this._pqControls.internalValue = undefined;
      this._pqMaxFileSize = undefined;
      this._pqMaxSize = undefined;
      this._pqMode = undefined;
      this._pqOnBackpressure = undefined;
      this._pqPath = undefined;
      this._realm = undefined;
      this._rejectUnauthorized = undefined;
      this._responseHonorRetryAfterHeader = undefined;
      this._responseRetrySettings.internalValue = undefined;
      this._safeHeaders = undefined;
      this._streamtags = undefined;
      this._systemFields = undefined;
      this._textSecret = undefined;
      this._timeoutRetrySettings.internalValue = undefined;
      this._timeoutSec = undefined;
      this._token = undefined;
      this._type = undefined;
      this._useRoundRobinDns = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._authType = value.authType;
      this._compress = value.compress;
      this._concurrency = value.concurrency;
      this._description = value.description;
      this._environment = value.environment;
      this._extraHttpHeaders.internalValue = value.extraHttpHeaders;
      this._failedRequestLoggingMode = value.failedRequestLoggingMode;
      this._flushPeriodSec = value.flushPeriodSec;
      this._id = value.id;
      this._maxPayloadEvents = value.maxPayloadEvents;
      this._maxPayloadSizeKb = value.maxPayloadSizeKb;
      this._onBackpressure = value.onBackpressure;
      this._pipeline = value.pipeline;
      this._pqCompress = value.pqCompress;
      this._pqControls.internalValue = value.pqControls;
      this._pqMaxFileSize = value.pqMaxFileSize;
      this._pqMaxSize = value.pqMaxSize;
      this._pqMode = value.pqMode;
      this._pqOnBackpressure = value.pqOnBackpressure;
      this._pqPath = value.pqPath;
      this._realm = value.realm;
      this._rejectUnauthorized = value.rejectUnauthorized;
      this._responseHonorRetryAfterHeader = value.responseHonorRetryAfterHeader;
      this._responseRetrySettings.internalValue = value.responseRetrySettings;
      this._safeHeaders = value.safeHeaders;
      this._streamtags = value.streamtags;
      this._systemFields = value.systemFields;
      this._textSecret = value.textSecret;
      this._timeoutRetrySettings.internalValue = value.timeoutRetrySettings;
      this._timeoutSec = value.timeoutSec;
      this._token = value.token;
      this._type = value.type;
      this._useRoundRobinDns = value.useRoundRobinDns;
    }
  }

  // auth_type - computed: true, optional: true, required: false
  private _authType?: string; 
  public get authType() {
    return this.getStringAttribute('auth_type');
  }
  public set authType(value: string) {
    this._authType = value;
  }
  public resetAuthType() {
    this._authType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authTypeInput() {
    return this._authType;
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: boolean | cdktf.IResolvable; 
  public get compress() {
    return this.getBooleanAttribute('compress');
  }
  public set compress(value: boolean | cdktf.IResolvable) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // concurrency - computed: true, optional: true, required: false
  private _concurrency?: number; 
  public get concurrency() {
    return this.getNumberAttribute('concurrency');
  }
  public set concurrency(value: number) {
    this._concurrency = value;
  }
  public resetConcurrency() {
    this._concurrency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get concurrencyInput() {
    return this._concurrency;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // extra_http_headers - computed: false, optional: true, required: false
  private _extraHttpHeaders = new PackDestinationOutputSignalfxExtraHttpHeadersList(this, "extra_http_headers", false);
  public get extraHttpHeaders() {
    return this._extraHttpHeaders;
  }
  public putExtraHttpHeaders(value: PackDestinationOutputSignalfxExtraHttpHeaders[] | cdktf.IResolvable) {
    this._extraHttpHeaders.internalValue = value;
  }
  public resetExtraHttpHeaders() {
    this._extraHttpHeaders.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get extraHttpHeadersInput() {
    return this._extraHttpHeaders.internalValue;
  }

  // failed_request_logging_mode - computed: true, optional: true, required: false
  private _failedRequestLoggingMode?: string; 
  public get failedRequestLoggingMode() {
    return this.getStringAttribute('failed_request_logging_mode');
  }
  public set failedRequestLoggingMode(value: string) {
    this._failedRequestLoggingMode = value;
  }
  public resetFailedRequestLoggingMode() {
    this._failedRequestLoggingMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get failedRequestLoggingModeInput() {
    return this._failedRequestLoggingMode;
  }

  // flush_period_sec - computed: true, optional: true, required: false
  private _flushPeriodSec?: number; 
  public get flushPeriodSec() {
    return this.getNumberAttribute('flush_period_sec');
  }
  public set flushPeriodSec(value: number) {
    this._flushPeriodSec = value;
  }
  public resetFlushPeriodSec() {
    this._flushPeriodSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get flushPeriodSecInput() {
    return this._flushPeriodSec;
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // max_payload_events - computed: true, optional: true, required: false
  private _maxPayloadEvents?: number; 
  public get maxPayloadEvents() {
    return this.getNumberAttribute('max_payload_events');
  }
  public set maxPayloadEvents(value: number) {
    this._maxPayloadEvents = value;
  }
  public resetMaxPayloadEvents() {
    this._maxPayloadEvents = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxPayloadEventsInput() {
    return this._maxPayloadEvents;
  }

  // max_payload_size_kb - computed: true, optional: true, required: false
  private _maxPayloadSizeKb?: number; 
  public get maxPayloadSizeKb() {
    return this.getNumberAttribute('max_payload_size_kb');
  }
  public set maxPayloadSizeKb(value: number) {
    this._maxPayloadSizeKb = value;
  }
  public resetMaxPayloadSizeKb() {
    this._maxPayloadSizeKb = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxPayloadSizeKbInput() {
    return this._maxPayloadSizeKb;
  }

  // on_backpressure - computed: true, optional: true, required: false
  private _onBackpressure?: string; 
  public get onBackpressure() {
    return this.getStringAttribute('on_backpressure');
  }
  public set onBackpressure(value: string) {
    this._onBackpressure = value;
  }
  public resetOnBackpressure() {
    this._onBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get onBackpressureInput() {
    return this._onBackpressure;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // pq_compress - computed: true, optional: true, required: false
  private _pqCompress?: string; 
  public get pqCompress() {
    return this.getStringAttribute('pq_compress');
  }
  public set pqCompress(value: string) {
    this._pqCompress = value;
  }
  public resetPqCompress() {
    this._pqCompress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqCompressInput() {
    return this._pqCompress;
  }

  // pq_controls - computed: false, optional: true, required: false
  private _pqControls = new PackDestinationOutputSignalfxPqControlsOutputReference(this, "pq_controls");
  public get pqControls() {
    return this._pqControls;
  }
  public putPqControls(value: PackDestinationOutputSignalfxPqControls) {
    this._pqControls.internalValue = value;
  }
  public resetPqControls() {
    this._pqControls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqControlsInput() {
    return this._pqControls.internalValue;
  }

  // pq_max_file_size - computed: true, optional: true, required: false
  private _pqMaxFileSize?: string; 
  public get pqMaxFileSize() {
    return this.getStringAttribute('pq_max_file_size');
  }
  public set pqMaxFileSize(value: string) {
    this._pqMaxFileSize = value;
  }
  public resetPqMaxFileSize() {
    this._pqMaxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxFileSizeInput() {
    return this._pqMaxFileSize;
  }

  // pq_max_size - computed: true, optional: true, required: false
  private _pqMaxSize?: string; 
  public get pqMaxSize() {
    return this.getStringAttribute('pq_max_size');
  }
  public set pqMaxSize(value: string) {
    this._pqMaxSize = value;
  }
  public resetPqMaxSize() {
    this._pqMaxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxSizeInput() {
    return this._pqMaxSize;
  }

  // pq_mode - computed: true, optional: true, required: false
  private _pqMode?: string; 
  public get pqMode() {
    return this.getStringAttribute('pq_mode');
  }
  public set pqMode(value: string) {
    this._pqMode = value;
  }
  public resetPqMode() {
    this._pqMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqModeInput() {
    return this._pqMode;
  }

  // pq_on_backpressure - computed: true, optional: true, required: false
  private _pqOnBackpressure?: string; 
  public get pqOnBackpressure() {
    return this.getStringAttribute('pq_on_backpressure');
  }
  public set pqOnBackpressure(value: string) {
    this._pqOnBackpressure = value;
  }
  public resetPqOnBackpressure() {
    this._pqOnBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqOnBackpressureInput() {
    return this._pqOnBackpressure;
  }

  // pq_path - computed: true, optional: true, required: false
  private _pqPath?: string; 
  public get pqPath() {
    return this.getStringAttribute('pq_path');
  }
  public set pqPath(value: string) {
    this._pqPath = value;
  }
  public resetPqPath() {
    this._pqPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqPathInput() {
    return this._pqPath;
  }

  // realm - computed: true, optional: true, required: false
  private _realm?: string; 
  public get realm() {
    return this.getStringAttribute('realm');
  }
  public set realm(value: string) {
    this._realm = value;
  }
  public resetRealm() {
    this._realm = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get realmInput() {
    return this._realm;
  }

  // reject_unauthorized - computed: true, optional: true, required: false
  private _rejectUnauthorized?: boolean | cdktf.IResolvable; 
  public get rejectUnauthorized() {
    return this.getBooleanAttribute('reject_unauthorized');
  }
  public set rejectUnauthorized(value: boolean | cdktf.IResolvable) {
    this._rejectUnauthorized = value;
  }
  public resetRejectUnauthorized() {
    this._rejectUnauthorized = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectUnauthorizedInput() {
    return this._rejectUnauthorized;
  }

  // response_honor_retry_after_header - computed: true, optional: true, required: false
  private _responseHonorRetryAfterHeader?: boolean | cdktf.IResolvable; 
  public get responseHonorRetryAfterHeader() {
    return this.getBooleanAttribute('response_honor_retry_after_header');
  }
  public set responseHonorRetryAfterHeader(value: boolean | cdktf.IResolvable) {
    this._responseHonorRetryAfterHeader = value;
  }
  public resetResponseHonorRetryAfterHeader() {
    this._responseHonorRetryAfterHeader = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get responseHonorRetryAfterHeaderInput() {
    return this._responseHonorRetryAfterHeader;
  }

  // response_retry_settings - computed: false, optional: true, required: false
  private _responseRetrySettings = new PackDestinationOutputSignalfxResponseRetrySettingsList(this, "response_retry_settings", false);
  public get responseRetrySettings() {
    return this._responseRetrySettings;
  }
  public putResponseRetrySettings(value: PackDestinationOutputSignalfxResponseRetrySettings[] | cdktf.IResolvable) {
    this._responseRetrySettings.internalValue = value;
  }
  public resetResponseRetrySettings() {
    this._responseRetrySettings.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get responseRetrySettingsInput() {
    return this._responseRetrySettings.internalValue;
  }

  // safe_headers - computed: true, optional: true, required: false
  private _safeHeaders?: string[]; 
  public get safeHeaders() {
    return this.getListAttribute('safe_headers');
  }
  public set safeHeaders(value: string[]) {
    this._safeHeaders = value;
  }
  public resetSafeHeaders() {
    this._safeHeaders = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get safeHeadersInput() {
    return this._safeHeaders;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // system_fields - computed: true, optional: true, required: false
  private _systemFields?: string[]; 
  public get systemFields() {
    return this.getListAttribute('system_fields');
  }
  public set systemFields(value: string[]) {
    this._systemFields = value;
  }
  public resetSystemFields() {
    this._systemFields = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get systemFieldsInput() {
    return this._systemFields;
  }

  // text_secret - computed: false, optional: true, required: false
  private _textSecret?: string; 
  public get textSecret() {
    return this.getStringAttribute('text_secret');
  }
  public set textSecret(value: string) {
    this._textSecret = value;
  }
  public resetTextSecret() {
    this._textSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get textSecretInput() {
    return this._textSecret;
  }

  // timeout_retry_settings - computed: false, optional: true, required: false
  private _timeoutRetrySettings = new PackDestinationOutputSignalfxTimeoutRetrySettingsOutputReference(this, "timeout_retry_settings");
  public get timeoutRetrySettings() {
    return this._timeoutRetrySettings;
  }
  public putTimeoutRetrySettings(value: PackDestinationOutputSignalfxTimeoutRetrySettings) {
    this._timeoutRetrySettings.internalValue = value;
  }
  public resetTimeoutRetrySettings() {
    this._timeoutRetrySettings.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutRetrySettingsInput() {
    return this._timeoutRetrySettings.internalValue;
  }

  // timeout_sec - computed: true, optional: true, required: false
  private _timeoutSec?: number; 
  public get timeoutSec() {
    return this.getNumberAttribute('timeout_sec');
  }
  public set timeoutSec(value: number) {
    this._timeoutSec = value;
  }
  public resetTimeoutSec() {
    this._timeoutSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutSecInput() {
    return this._timeoutSec;
  }

  // token - computed: false, optional: true, required: false
  private _token?: string; 
  public get token() {
    return this.getStringAttribute('token');
  }
  public set token(value: string) {
    this._token = value;
  }
  public resetToken() {
    this._token = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tokenInput() {
    return this._token;
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // use_round_robin_dns - computed: true, optional: true, required: false
  private _useRoundRobinDns?: boolean | cdktf.IResolvable; 
  public get useRoundRobinDns() {
    return this.getBooleanAttribute('use_round_robin_dns');
  }
  public set useRoundRobinDns(value: boolean | cdktf.IResolvable) {
    this._useRoundRobinDns = value;
  }
  public resetUseRoundRobinDns() {
    this._useRoundRobinDns = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get useRoundRobinDnsInput() {
    return this._useRoundRobinDns;
  }
}
export interface PackDestinationOutputSnmpHosts {
  /**
  * Destination host
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#host PackDestination#host}
  */
  readonly host: string;
  /**
  * Destination port, default is 162. Default: 162
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#port PackDestination#port}
  */
  readonly port?: number;
}

export function packDestinationOutputSnmpHostsToTerraform(struct?: PackDestinationOutputSnmpHosts | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    host: cdktf.stringToTerraform(struct!.host),
    port: cdktf.numberToTerraform(struct!.port),
  }
}


export function packDestinationOutputSnmpHostsToHclTerraform(struct?: PackDestinationOutputSnmpHosts | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    host: {
      value: cdktf.stringToHclTerraform(struct!.host),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputSnmpHostsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackDestinationOutputSnmpHosts | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._host !== undefined) {
      hasAnyValues = true;
      internalValueResult.host = this._host;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputSnmpHosts | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._host = undefined;
      this._port = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._host = value.host;
      this._port = value.port;
    }
  }

  // host - computed: false, optional: false, required: true
  private _host?: string; 
  public get host() {
    return this.getStringAttribute('host');
  }
  public set host(value: string) {
    this._host = value;
  }
  // Temporarily expose input value. Use with caution.
  public get hostInput() {
    return this._host;
  }

  // port - computed: true, optional: true, required: false
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }
}

export class PackDestinationOutputSnmpHostsList extends cdktf.ComplexList {
  public internalValue? : PackDestinationOutputSnmpHosts[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackDestinationOutputSnmpHostsOutputReference {
    return new PackDestinationOutputSnmpHostsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackDestinationOutputSnmp {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#description PackDestination#description}
  */
  readonly description?: string;
  /**
  * How often to resolve the destination hostname to an IP address. Ignored if all destinations are IP addresses. A value of 0 means every trap sent will incur a DNS lookup. Default: 0
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#dns_resolve_period_sec PackDestination#dns_resolve_period_sec}
  */
  readonly dnsResolvePeriodSec?: number;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#environment PackDestination#environment}
  */
  readonly environment?: string;
  /**
  * One or more SNMP destinations to forward traps to
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#hosts PackDestination#hosts}
  */
  readonly hosts: PackDestinationOutputSnmpHosts[] | cdktf.IResolvable;
  /**
  * Unique ID for this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#id PackDestination#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * Pipeline to process data before sending out to this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pipeline PackDestination#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#streamtags PackDestination#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Fields to automatically add to events, such as cribl_pipe. Supports wildcards. Default: ["cribl_pipe"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#system_fields PackDestination#system_fields}
  */
  readonly systemFields?: string[];
  /**
  * must be "snmp"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#type PackDestination#type}
  */
  readonly type: string;
}

export function packDestinationOutputSnmpToTerraform(struct?: PackDestinationOutputSnmp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    description: cdktf.stringToTerraform(struct!.description),
    dns_resolve_period_sec: cdktf.numberToTerraform(struct!.dnsResolvePeriodSec),
    environment: cdktf.stringToTerraform(struct!.environment),
    hosts: cdktf.listMapper(packDestinationOutputSnmpHostsToTerraform, false)(struct!.hosts),
    id: cdktf.stringToTerraform(struct!.id),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    system_fields: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.systemFields),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function packDestinationOutputSnmpToHclTerraform(struct?: PackDestinationOutputSnmp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    dns_resolve_period_sec: {
      value: cdktf.numberToHclTerraform(struct!.dnsResolvePeriodSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    hosts: {
      value: cdktf.listMapperHcl(packDestinationOutputSnmpHostsToHclTerraform, false)(struct!.hosts),
      isBlock: true,
      type: "list",
      storageClassType: "PackDestinationOutputSnmpHostsList",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    system_fields: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.systemFields),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputSnmpOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackDestinationOutputSnmp | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._dnsResolvePeriodSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.dnsResolvePeriodSec = this._dnsResolvePeriodSec;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._hosts?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.hosts = this._hosts?.internalValue;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._systemFields !== undefined) {
      hasAnyValues = true;
      internalValueResult.systemFields = this._systemFields;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputSnmp | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._description = undefined;
      this._dnsResolvePeriodSec = undefined;
      this._environment = undefined;
      this._hosts.internalValue = undefined;
      this._id = undefined;
      this._pipeline = undefined;
      this._streamtags = undefined;
      this._systemFields = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._description = value.description;
      this._dnsResolvePeriodSec = value.dnsResolvePeriodSec;
      this._environment = value.environment;
      this._hosts.internalValue = value.hosts;
      this._id = value.id;
      this._pipeline = value.pipeline;
      this._streamtags = value.streamtags;
      this._systemFields = value.systemFields;
      this._type = value.type;
    }
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // dns_resolve_period_sec - computed: true, optional: true, required: false
  private _dnsResolvePeriodSec?: number; 
  public get dnsResolvePeriodSec() {
    return this.getNumberAttribute('dns_resolve_period_sec');
  }
  public set dnsResolvePeriodSec(value: number) {
    this._dnsResolvePeriodSec = value;
  }
  public resetDnsResolvePeriodSec() {
    this._dnsResolvePeriodSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dnsResolvePeriodSecInput() {
    return this._dnsResolvePeriodSec;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // hosts - computed: false, optional: false, required: true
  private _hosts = new PackDestinationOutputSnmpHostsList(this, "hosts", false);
  public get hosts() {
    return this._hosts;
  }
  public putHosts(value: PackDestinationOutputSnmpHosts[] | cdktf.IResolvable) {
    this._hosts.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get hostsInput() {
    return this._hosts.internalValue;
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // system_fields - computed: true, optional: true, required: false
  private _systemFields?: string[]; 
  public get systemFields() {
    return this.getListAttribute('system_fields');
  }
  public set systemFields(value: string[]) {
    this._systemFields = value;
  }
  public resetSystemFields() {
    this._systemFields = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get systemFieldsInput() {
    return this._systemFields;
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface PackDestinationOutputSnsPqControls {
}

export function packDestinationOutputSnsPqControlsToTerraform(struct?: PackDestinationOutputSnsPqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function packDestinationOutputSnsPqControlsToHclTerraform(struct?: PackDestinationOutputSnsPqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class PackDestinationOutputSnsPqControlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackDestinationOutputSnsPqControls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputSnsPqControls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface PackDestinationOutputSns {
  /**
  * Amazon Resource Name (ARN) of the role to assume
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#assume_role_arn PackDestination#assume_role_arn}
  */
  readonly assumeRoleArn?: string;
  /**
  * External ID to use when assuming role
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#assume_role_external_id PackDestination#assume_role_external_id}
  */
  readonly assumeRoleExternalId?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#aws_api_key PackDestination#aws_api_key}
  */
  readonly awsApiKey?: string;
  /**
  * AWS authentication method. Choose Auto to use IAM roles. Default: "auto"; must be one of ["auto", "manual", "secret"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#aws_authentication_method PackDestination#aws_authentication_method}
  */
  readonly awsAuthenticationMethod?: string;
  /**
  * Select or create a stored secret that references your access key and secret key
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#aws_secret PackDestination#aws_secret}
  */
  readonly awsSecret?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#aws_secret_key PackDestination#aws_secret_key}
  */
  readonly awsSecretKey?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#description PackDestination#description}
  */
  readonly description?: string;
  /**
  * Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours). Default: 3600
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#duration_seconds PackDestination#duration_seconds}
  */
  readonly durationSeconds?: number;
  /**
  * Use Assume Role credentials to access SNS. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#enable_assume_role PackDestination#enable_assume_role}
  */
  readonly enableAssumeRole?: boolean | cdktf.IResolvable;
  /**
  * SNS service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to SNS-compatible endpoint.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#endpoint PackDestination#endpoint}
  */
  readonly endpoint?: string;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#environment PackDestination#environment}
  */
  readonly environment?: string;
  /**
  * Unique ID for this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#id PackDestination#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * Maximum number of retries before the output returns an error. Note that not all errors are retryable. The retries use an exponential backoff policy.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_retries PackDestination#max_retries}
  */
  readonly maxRetries?: number;
  /**
  * Messages in the same group are processed in a FIFO manner. Must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can be evaluated only at init time. Example referencing a Global Variable: `https://host:port/myQueue-${C.vars.myVar}`.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#message_group_id PackDestination#message_group_id}
  */
  readonly messageGroupId: string;
  /**
  * How to handle events when all receivers are exerting backpressure. Default: "block"; must be one of ["block", "drop", "queue"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#on_backpressure PackDestination#on_backpressure}
  */
  readonly onBackpressure?: string;
  /**
  * Pipeline to process data before sending out to this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pipeline PackDestination#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_compress PackDestination#pq_compress}
  */
  readonly pqCompress?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_controls PackDestination#pq_controls}
  */
  readonly pqControls?: PackDestinationOutputSnsPqControls;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.). Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_max_file_size PackDestination#pq_max_file_size}
  */
  readonly pqMaxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_max_size PackDestination#pq_max_size}
  */
  readonly pqMaxSize?: string;
  /**
  * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem. Default: "error"; must be one of ["error", "backpressure", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_mode PackDestination#pq_mode}
  */
  readonly pqMode?: string;
  /**
  * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged. Default: "block"; must be one of ["block", "drop"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_on_backpressure PackDestination#pq_on_backpressure}
  */
  readonly pqOnBackpressure?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_path PackDestination#pq_path}
  */
  readonly pqPath?: string;
  /**
  * Region where the SNS is located
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#region PackDestination#region}
  */
  readonly region?: string;
  /**
  * Reject certificates that cannot be verified against a valid CA, such as self-signed certificates. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#reject_unauthorized PackDestination#reject_unauthorized}
  */
  readonly rejectUnauthorized?: boolean | cdktf.IResolvable;
  /**
  * Reuse connections between requests, which can improve performance. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#reuse_connections PackDestination#reuse_connections}
  */
  readonly reuseConnections?: boolean | cdktf.IResolvable;
  /**
  * Signature version to use for signing SNS requests. Default: "v4"; must be one of ["v2", "v4"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#signature_version PackDestination#signature_version}
  */
  readonly signatureVersion?: string;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#streamtags PackDestination#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Fields to automatically add to events, such as cribl_pipe. Supports wildcards. Default: ["cribl_pipe"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#system_fields PackDestination#system_fields}
  */
  readonly systemFields?: string[];
  /**
  * The ARN of the SNS topic to send events to. When a non-AWS URL is specified, format must be: '{url}/myQueueName'. E.g., 'https://host:port/myQueueName'. Must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can be evaluated only at initialization time. Example referencing a Global Variable: `https://host:port/myQueue-${C.vars.myVar}`
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#topic_arn PackDestination#topic_arn}
  */
  readonly topicArn: string;
  /**
  * must be "sns"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#type PackDestination#type}
  */
  readonly type?: string;
}

export function packDestinationOutputSnsToTerraform(struct?: PackDestinationOutputSns | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    assume_role_arn: cdktf.stringToTerraform(struct!.assumeRoleArn),
    assume_role_external_id: cdktf.stringToTerraform(struct!.assumeRoleExternalId),
    aws_api_key: cdktf.stringToTerraform(struct!.awsApiKey),
    aws_authentication_method: cdktf.stringToTerraform(struct!.awsAuthenticationMethod),
    aws_secret: cdktf.stringToTerraform(struct!.awsSecret),
    aws_secret_key: cdktf.stringToTerraform(struct!.awsSecretKey),
    description: cdktf.stringToTerraform(struct!.description),
    duration_seconds: cdktf.numberToTerraform(struct!.durationSeconds),
    enable_assume_role: cdktf.booleanToTerraform(struct!.enableAssumeRole),
    endpoint: cdktf.stringToTerraform(struct!.endpoint),
    environment: cdktf.stringToTerraform(struct!.environment),
    id: cdktf.stringToTerraform(struct!.id),
    max_retries: cdktf.numberToTerraform(struct!.maxRetries),
    message_group_id: cdktf.stringToTerraform(struct!.messageGroupId),
    on_backpressure: cdktf.stringToTerraform(struct!.onBackpressure),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    pq_compress: cdktf.stringToTerraform(struct!.pqCompress),
    pq_controls: packDestinationOutputSnsPqControlsToTerraform(struct!.pqControls),
    pq_max_file_size: cdktf.stringToTerraform(struct!.pqMaxFileSize),
    pq_max_size: cdktf.stringToTerraform(struct!.pqMaxSize),
    pq_mode: cdktf.stringToTerraform(struct!.pqMode),
    pq_on_backpressure: cdktf.stringToTerraform(struct!.pqOnBackpressure),
    pq_path: cdktf.stringToTerraform(struct!.pqPath),
    region: cdktf.stringToTerraform(struct!.region),
    reject_unauthorized: cdktf.booleanToTerraform(struct!.rejectUnauthorized),
    reuse_connections: cdktf.booleanToTerraform(struct!.reuseConnections),
    signature_version: cdktf.stringToTerraform(struct!.signatureVersion),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    system_fields: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.systemFields),
    topic_arn: cdktf.stringToTerraform(struct!.topicArn),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function packDestinationOutputSnsToHclTerraform(struct?: PackDestinationOutputSns | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    assume_role_arn: {
      value: cdktf.stringToHclTerraform(struct!.assumeRoleArn),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    assume_role_external_id: {
      value: cdktf.stringToHclTerraform(struct!.assumeRoleExternalId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    aws_api_key: {
      value: cdktf.stringToHclTerraform(struct!.awsApiKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    aws_authentication_method: {
      value: cdktf.stringToHclTerraform(struct!.awsAuthenticationMethod),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    aws_secret: {
      value: cdktf.stringToHclTerraform(struct!.awsSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    aws_secret_key: {
      value: cdktf.stringToHclTerraform(struct!.awsSecretKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    duration_seconds: {
      value: cdktf.numberToHclTerraform(struct!.durationSeconds),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    enable_assume_role: {
      value: cdktf.booleanToHclTerraform(struct!.enableAssumeRole),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    endpoint: {
      value: cdktf.stringToHclTerraform(struct!.endpoint),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_retries: {
      value: cdktf.numberToHclTerraform(struct!.maxRetries),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    message_group_id: {
      value: cdktf.stringToHclTerraform(struct!.messageGroupId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.onBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_compress: {
      value: cdktf.stringToHclTerraform(struct!.pqCompress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_controls: {
      value: packDestinationOutputSnsPqControlsToHclTerraform(struct!.pqControls),
      isBlock: true,
      type: "struct",
      storageClassType: "PackDestinationOutputSnsPqControls",
    },
    pq_max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_max_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_mode: {
      value: cdktf.stringToHclTerraform(struct!.pqMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.pqOnBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_path: {
      value: cdktf.stringToHclTerraform(struct!.pqPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    region: {
      value: cdktf.stringToHclTerraform(struct!.region),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reject_unauthorized: {
      value: cdktf.booleanToHclTerraform(struct!.rejectUnauthorized),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    reuse_connections: {
      value: cdktf.booleanToHclTerraform(struct!.reuseConnections),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    signature_version: {
      value: cdktf.stringToHclTerraform(struct!.signatureVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    system_fields: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.systemFields),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    topic_arn: {
      value: cdktf.stringToHclTerraform(struct!.topicArn),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputSnsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackDestinationOutputSns | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._assumeRoleArn !== undefined) {
      hasAnyValues = true;
      internalValueResult.assumeRoleArn = this._assumeRoleArn;
    }
    if (this._assumeRoleExternalId !== undefined) {
      hasAnyValues = true;
      internalValueResult.assumeRoleExternalId = this._assumeRoleExternalId;
    }
    if (this._awsApiKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.awsApiKey = this._awsApiKey;
    }
    if (this._awsAuthenticationMethod !== undefined) {
      hasAnyValues = true;
      internalValueResult.awsAuthenticationMethod = this._awsAuthenticationMethod;
    }
    if (this._awsSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.awsSecret = this._awsSecret;
    }
    if (this._awsSecretKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.awsSecretKey = this._awsSecretKey;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._durationSeconds !== undefined) {
      hasAnyValues = true;
      internalValueResult.durationSeconds = this._durationSeconds;
    }
    if (this._enableAssumeRole !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableAssumeRole = this._enableAssumeRole;
    }
    if (this._endpoint !== undefined) {
      hasAnyValues = true;
      internalValueResult.endpoint = this._endpoint;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._maxRetries !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxRetries = this._maxRetries;
    }
    if (this._messageGroupId !== undefined) {
      hasAnyValues = true;
      internalValueResult.messageGroupId = this._messageGroupId;
    }
    if (this._onBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.onBackpressure = this._onBackpressure;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._pqCompress !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqCompress = this._pqCompress;
    }
    if (this._pqControls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqControls = this._pqControls?.internalValue;
    }
    if (this._pqMaxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxFileSize = this._pqMaxFileSize;
    }
    if (this._pqMaxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxSize = this._pqMaxSize;
    }
    if (this._pqMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMode = this._pqMode;
    }
    if (this._pqOnBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqOnBackpressure = this._pqOnBackpressure;
    }
    if (this._pqPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqPath = this._pqPath;
    }
    if (this._region !== undefined) {
      hasAnyValues = true;
      internalValueResult.region = this._region;
    }
    if (this._rejectUnauthorized !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectUnauthorized = this._rejectUnauthorized;
    }
    if (this._reuseConnections !== undefined) {
      hasAnyValues = true;
      internalValueResult.reuseConnections = this._reuseConnections;
    }
    if (this._signatureVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.signatureVersion = this._signatureVersion;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._systemFields !== undefined) {
      hasAnyValues = true;
      internalValueResult.systemFields = this._systemFields;
    }
    if (this._topicArn !== undefined) {
      hasAnyValues = true;
      internalValueResult.topicArn = this._topicArn;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputSns | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._assumeRoleArn = undefined;
      this._assumeRoleExternalId = undefined;
      this._awsApiKey = undefined;
      this._awsAuthenticationMethod = undefined;
      this._awsSecret = undefined;
      this._awsSecretKey = undefined;
      this._description = undefined;
      this._durationSeconds = undefined;
      this._enableAssumeRole = undefined;
      this._endpoint = undefined;
      this._environment = undefined;
      this._id = undefined;
      this._maxRetries = undefined;
      this._messageGroupId = undefined;
      this._onBackpressure = undefined;
      this._pipeline = undefined;
      this._pqCompress = undefined;
      this._pqControls.internalValue = undefined;
      this._pqMaxFileSize = undefined;
      this._pqMaxSize = undefined;
      this._pqMode = undefined;
      this._pqOnBackpressure = undefined;
      this._pqPath = undefined;
      this._region = undefined;
      this._rejectUnauthorized = undefined;
      this._reuseConnections = undefined;
      this._signatureVersion = undefined;
      this._streamtags = undefined;
      this._systemFields = undefined;
      this._topicArn = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._assumeRoleArn = value.assumeRoleArn;
      this._assumeRoleExternalId = value.assumeRoleExternalId;
      this._awsApiKey = value.awsApiKey;
      this._awsAuthenticationMethod = value.awsAuthenticationMethod;
      this._awsSecret = value.awsSecret;
      this._awsSecretKey = value.awsSecretKey;
      this._description = value.description;
      this._durationSeconds = value.durationSeconds;
      this._enableAssumeRole = value.enableAssumeRole;
      this._endpoint = value.endpoint;
      this._environment = value.environment;
      this._id = value.id;
      this._maxRetries = value.maxRetries;
      this._messageGroupId = value.messageGroupId;
      this._onBackpressure = value.onBackpressure;
      this._pipeline = value.pipeline;
      this._pqCompress = value.pqCompress;
      this._pqControls.internalValue = value.pqControls;
      this._pqMaxFileSize = value.pqMaxFileSize;
      this._pqMaxSize = value.pqMaxSize;
      this._pqMode = value.pqMode;
      this._pqOnBackpressure = value.pqOnBackpressure;
      this._pqPath = value.pqPath;
      this._region = value.region;
      this._rejectUnauthorized = value.rejectUnauthorized;
      this._reuseConnections = value.reuseConnections;
      this._signatureVersion = value.signatureVersion;
      this._streamtags = value.streamtags;
      this._systemFields = value.systemFields;
      this._topicArn = value.topicArn;
      this._type = value.type;
    }
  }

  // assume_role_arn - computed: false, optional: true, required: false
  private _assumeRoleArn?: string; 
  public get assumeRoleArn() {
    return this.getStringAttribute('assume_role_arn');
  }
  public set assumeRoleArn(value: string) {
    this._assumeRoleArn = value;
  }
  public resetAssumeRoleArn() {
    this._assumeRoleArn = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get assumeRoleArnInput() {
    return this._assumeRoleArn;
  }

  // assume_role_external_id - computed: false, optional: true, required: false
  private _assumeRoleExternalId?: string; 
  public get assumeRoleExternalId() {
    return this.getStringAttribute('assume_role_external_id');
  }
  public set assumeRoleExternalId(value: string) {
    this._assumeRoleExternalId = value;
  }
  public resetAssumeRoleExternalId() {
    this._assumeRoleExternalId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get assumeRoleExternalIdInput() {
    return this._assumeRoleExternalId;
  }

  // aws_api_key - computed: false, optional: true, required: false
  private _awsApiKey?: string; 
  public get awsApiKey() {
    return this.getStringAttribute('aws_api_key');
  }
  public set awsApiKey(value: string) {
    this._awsApiKey = value;
  }
  public resetAwsApiKey() {
    this._awsApiKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsApiKeyInput() {
    return this._awsApiKey;
  }

  // aws_authentication_method - computed: true, optional: true, required: false
  private _awsAuthenticationMethod?: string; 
  public get awsAuthenticationMethod() {
    return this.getStringAttribute('aws_authentication_method');
  }
  public set awsAuthenticationMethod(value: string) {
    this._awsAuthenticationMethod = value;
  }
  public resetAwsAuthenticationMethod() {
    this._awsAuthenticationMethod = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsAuthenticationMethodInput() {
    return this._awsAuthenticationMethod;
  }

  // aws_secret - computed: false, optional: true, required: false
  private _awsSecret?: string; 
  public get awsSecret() {
    return this.getStringAttribute('aws_secret');
  }
  public set awsSecret(value: string) {
    this._awsSecret = value;
  }
  public resetAwsSecret() {
    this._awsSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsSecretInput() {
    return this._awsSecret;
  }

  // aws_secret_key - computed: false, optional: true, required: false
  private _awsSecretKey?: string; 
  public get awsSecretKey() {
    return this.getStringAttribute('aws_secret_key');
  }
  public set awsSecretKey(value: string) {
    this._awsSecretKey = value;
  }
  public resetAwsSecretKey() {
    this._awsSecretKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsSecretKeyInput() {
    return this._awsSecretKey;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // duration_seconds - computed: true, optional: true, required: false
  private _durationSeconds?: number; 
  public get durationSeconds() {
    return this.getNumberAttribute('duration_seconds');
  }
  public set durationSeconds(value: number) {
    this._durationSeconds = value;
  }
  public resetDurationSeconds() {
    this._durationSeconds = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get durationSecondsInput() {
    return this._durationSeconds;
  }

  // enable_assume_role - computed: true, optional: true, required: false
  private _enableAssumeRole?: boolean | cdktf.IResolvable; 
  public get enableAssumeRole() {
    return this.getBooleanAttribute('enable_assume_role');
  }
  public set enableAssumeRole(value: boolean | cdktf.IResolvable) {
    this._enableAssumeRole = value;
  }
  public resetEnableAssumeRole() {
    this._enableAssumeRole = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableAssumeRoleInput() {
    return this._enableAssumeRole;
  }

  // endpoint - computed: false, optional: true, required: false
  private _endpoint?: string; 
  public get endpoint() {
    return this.getStringAttribute('endpoint');
  }
  public set endpoint(value: string) {
    this._endpoint = value;
  }
  public resetEndpoint() {
    this._endpoint = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get endpointInput() {
    return this._endpoint;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // max_retries - computed: false, optional: true, required: false
  private _maxRetries?: number; 
  public get maxRetries() {
    return this.getNumberAttribute('max_retries');
  }
  public set maxRetries(value: number) {
    this._maxRetries = value;
  }
  public resetMaxRetries() {
    this._maxRetries = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxRetriesInput() {
    return this._maxRetries;
  }

  // message_group_id - computed: false, optional: false, required: true
  private _messageGroupId?: string; 
  public get messageGroupId() {
    return this.getStringAttribute('message_group_id');
  }
  public set messageGroupId(value: string) {
    this._messageGroupId = value;
  }
  // Temporarily expose input value. Use with caution.
  public get messageGroupIdInput() {
    return this._messageGroupId;
  }

  // on_backpressure - computed: true, optional: true, required: false
  private _onBackpressure?: string; 
  public get onBackpressure() {
    return this.getStringAttribute('on_backpressure');
  }
  public set onBackpressure(value: string) {
    this._onBackpressure = value;
  }
  public resetOnBackpressure() {
    this._onBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get onBackpressureInput() {
    return this._onBackpressure;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // pq_compress - computed: true, optional: true, required: false
  private _pqCompress?: string; 
  public get pqCompress() {
    return this.getStringAttribute('pq_compress');
  }
  public set pqCompress(value: string) {
    this._pqCompress = value;
  }
  public resetPqCompress() {
    this._pqCompress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqCompressInput() {
    return this._pqCompress;
  }

  // pq_controls - computed: false, optional: true, required: false
  private _pqControls = new PackDestinationOutputSnsPqControlsOutputReference(this, "pq_controls");
  public get pqControls() {
    return this._pqControls;
  }
  public putPqControls(value: PackDestinationOutputSnsPqControls) {
    this._pqControls.internalValue = value;
  }
  public resetPqControls() {
    this._pqControls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqControlsInput() {
    return this._pqControls.internalValue;
  }

  // pq_max_file_size - computed: true, optional: true, required: false
  private _pqMaxFileSize?: string; 
  public get pqMaxFileSize() {
    return this.getStringAttribute('pq_max_file_size');
  }
  public set pqMaxFileSize(value: string) {
    this._pqMaxFileSize = value;
  }
  public resetPqMaxFileSize() {
    this._pqMaxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxFileSizeInput() {
    return this._pqMaxFileSize;
  }

  // pq_max_size - computed: true, optional: true, required: false
  private _pqMaxSize?: string; 
  public get pqMaxSize() {
    return this.getStringAttribute('pq_max_size');
  }
  public set pqMaxSize(value: string) {
    this._pqMaxSize = value;
  }
  public resetPqMaxSize() {
    this._pqMaxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxSizeInput() {
    return this._pqMaxSize;
  }

  // pq_mode - computed: true, optional: true, required: false
  private _pqMode?: string; 
  public get pqMode() {
    return this.getStringAttribute('pq_mode');
  }
  public set pqMode(value: string) {
    this._pqMode = value;
  }
  public resetPqMode() {
    this._pqMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqModeInput() {
    return this._pqMode;
  }

  // pq_on_backpressure - computed: true, optional: true, required: false
  private _pqOnBackpressure?: string; 
  public get pqOnBackpressure() {
    return this.getStringAttribute('pq_on_backpressure');
  }
  public set pqOnBackpressure(value: string) {
    this._pqOnBackpressure = value;
  }
  public resetPqOnBackpressure() {
    this._pqOnBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqOnBackpressureInput() {
    return this._pqOnBackpressure;
  }

  // pq_path - computed: true, optional: true, required: false
  private _pqPath?: string; 
  public get pqPath() {
    return this.getStringAttribute('pq_path');
  }
  public set pqPath(value: string) {
    this._pqPath = value;
  }
  public resetPqPath() {
    this._pqPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqPathInput() {
    return this._pqPath;
  }

  // region - computed: false, optional: true, required: false
  private _region?: string; 
  public get region() {
    return this.getStringAttribute('region');
  }
  public set region(value: string) {
    this._region = value;
  }
  public resetRegion() {
    this._region = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get regionInput() {
    return this._region;
  }

  // reject_unauthorized - computed: true, optional: true, required: false
  private _rejectUnauthorized?: boolean | cdktf.IResolvable; 
  public get rejectUnauthorized() {
    return this.getBooleanAttribute('reject_unauthorized');
  }
  public set rejectUnauthorized(value: boolean | cdktf.IResolvable) {
    this._rejectUnauthorized = value;
  }
  public resetRejectUnauthorized() {
    this._rejectUnauthorized = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectUnauthorizedInput() {
    return this._rejectUnauthorized;
  }

  // reuse_connections - computed: true, optional: true, required: false
  private _reuseConnections?: boolean | cdktf.IResolvable; 
  public get reuseConnections() {
    return this.getBooleanAttribute('reuse_connections');
  }
  public set reuseConnections(value: boolean | cdktf.IResolvable) {
    this._reuseConnections = value;
  }
  public resetReuseConnections() {
    this._reuseConnections = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get reuseConnectionsInput() {
    return this._reuseConnections;
  }

  // signature_version - computed: true, optional: true, required: false
  private _signatureVersion?: string; 
  public get signatureVersion() {
    return this.getStringAttribute('signature_version');
  }
  public set signatureVersion(value: string) {
    this._signatureVersion = value;
  }
  public resetSignatureVersion() {
    this._signatureVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get signatureVersionInput() {
    return this._signatureVersion;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // system_fields - computed: true, optional: true, required: false
  private _systemFields?: string[]; 
  public get systemFields() {
    return this.getListAttribute('system_fields');
  }
  public set systemFields(value: string[]) {
    this._systemFields = value;
  }
  public resetSystemFields() {
    this._systemFields = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get systemFieldsInput() {
    return this._systemFields;
  }

  // topic_arn - computed: false, optional: false, required: true
  private _topicArn?: string; 
  public get topicArn() {
    return this.getStringAttribute('topic_arn');
  }
  public set topicArn(value: string) {
    this._topicArn = value;
  }
  // Temporarily expose input value. Use with caution.
  public get topicArnInput() {
    return this._topicArn;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface PackDestinationOutputSplunkPqControls {
}

export function packDestinationOutputSplunkPqControlsToTerraform(struct?: PackDestinationOutputSplunkPqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function packDestinationOutputSplunkPqControlsToHclTerraform(struct?: PackDestinationOutputSplunkPqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class PackDestinationOutputSplunkPqControlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackDestinationOutputSplunkPqControls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputSplunkPqControls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface PackDestinationOutputSplunkTls {
  /**
  * Path on client in which to find CA certificates to verify the server's cert. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#ca_path PackDestination#ca_path}
  */
  readonly caPath?: string;
  /**
  * Path on client in which to find certificates to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#cert_path PackDestination#cert_path}
  */
  readonly certPath?: string;
  /**
  * The name of the predefined certificate
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#certificate_name PackDestination#certificate_name}
  */
  readonly certificateName?: string;
  /**
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#disabled PackDestination#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_version PackDestination#max_version}
  */
  readonly maxVersion?: string;
  /**
  * must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#min_version PackDestination#min_version}
  */
  readonly minVersion?: string;
  /**
  * Passphrase to use to decrypt private key
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#passphrase PackDestination#passphrase}
  */
  readonly passphrase?: string;
  /**
  * Path on client in which to find the private key to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#priv_key_path PackDestination#priv_key_path}
  */
  readonly privKeyPath?: string;
  /**
  * Reject certificates that are not authorized by a CA in the CA certificate path, or by another 
  *                     trusted CA (such as the system's). Defaults to Enabled. Overrides the toggle from Advanced Settings, when also present.
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#reject_unauthorized PackDestination#reject_unauthorized}
  */
  readonly rejectUnauthorized?: boolean | cdktf.IResolvable;
  /**
  * Server name for the SNI (Server Name Indication) TLS extension. It must be a host name, and not an IP address.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#servername PackDestination#servername}
  */
  readonly servername?: string;
}

export function packDestinationOutputSplunkTlsToTerraform(struct?: PackDestinationOutputSplunkTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ca_path: cdktf.stringToTerraform(struct!.caPath),
    cert_path: cdktf.stringToTerraform(struct!.certPath),
    certificate_name: cdktf.stringToTerraform(struct!.certificateName),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    max_version: cdktf.stringToTerraform(struct!.maxVersion),
    min_version: cdktf.stringToTerraform(struct!.minVersion),
    passphrase: cdktf.stringToTerraform(struct!.passphrase),
    priv_key_path: cdktf.stringToTerraform(struct!.privKeyPath),
    reject_unauthorized: cdktf.booleanToTerraform(struct!.rejectUnauthorized),
    servername: cdktf.stringToTerraform(struct!.servername),
  }
}


export function packDestinationOutputSplunkTlsToHclTerraform(struct?: PackDestinationOutputSplunkTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ca_path: {
      value: cdktf.stringToHclTerraform(struct!.caPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    cert_path: {
      value: cdktf.stringToHclTerraform(struct!.certPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    certificate_name: {
      value: cdktf.stringToHclTerraform(struct!.certificateName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    max_version: {
      value: cdktf.stringToHclTerraform(struct!.maxVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    min_version: {
      value: cdktf.stringToHclTerraform(struct!.minVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    passphrase: {
      value: cdktf.stringToHclTerraform(struct!.passphrase),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    priv_key_path: {
      value: cdktf.stringToHclTerraform(struct!.privKeyPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reject_unauthorized: {
      value: cdktf.booleanToHclTerraform(struct!.rejectUnauthorized),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    servername: {
      value: cdktf.stringToHclTerraform(struct!.servername),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputSplunkTlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackDestinationOutputSplunkTls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._caPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.caPath = this._caPath;
    }
    if (this._certPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.certPath = this._certPath;
    }
    if (this._certificateName !== undefined) {
      hasAnyValues = true;
      internalValueResult.certificateName = this._certificateName;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._maxVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxVersion = this._maxVersion;
    }
    if (this._minVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.minVersion = this._minVersion;
    }
    if (this._passphrase !== undefined) {
      hasAnyValues = true;
      internalValueResult.passphrase = this._passphrase;
    }
    if (this._privKeyPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.privKeyPath = this._privKeyPath;
    }
    if (this._rejectUnauthorized !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectUnauthorized = this._rejectUnauthorized;
    }
    if (this._servername !== undefined) {
      hasAnyValues = true;
      internalValueResult.servername = this._servername;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputSplunkTls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._caPath = undefined;
      this._certPath = undefined;
      this._certificateName = undefined;
      this._disabled = undefined;
      this._maxVersion = undefined;
      this._minVersion = undefined;
      this._passphrase = undefined;
      this._privKeyPath = undefined;
      this._rejectUnauthorized = undefined;
      this._servername = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._caPath = value.caPath;
      this._certPath = value.certPath;
      this._certificateName = value.certificateName;
      this._disabled = value.disabled;
      this._maxVersion = value.maxVersion;
      this._minVersion = value.minVersion;
      this._passphrase = value.passphrase;
      this._privKeyPath = value.privKeyPath;
      this._rejectUnauthorized = value.rejectUnauthorized;
      this._servername = value.servername;
    }
  }

  // ca_path - computed: false, optional: true, required: false
  private _caPath?: string; 
  public get caPath() {
    return this.getStringAttribute('ca_path');
  }
  public set caPath(value: string) {
    this._caPath = value;
  }
  public resetCaPath() {
    this._caPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get caPathInput() {
    return this._caPath;
  }

  // cert_path - computed: false, optional: true, required: false
  private _certPath?: string; 
  public get certPath() {
    return this.getStringAttribute('cert_path');
  }
  public set certPath(value: string) {
    this._certPath = value;
  }
  public resetCertPath() {
    this._certPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certPathInput() {
    return this._certPath;
  }

  // certificate_name - computed: false, optional: true, required: false
  private _certificateName?: string; 
  public get certificateName() {
    return this.getStringAttribute('certificate_name');
  }
  public set certificateName(value: string) {
    this._certificateName = value;
  }
  public resetCertificateName() {
    this._certificateName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certificateNameInput() {
    return this._certificateName;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // max_version - computed: false, optional: true, required: false
  private _maxVersion?: string; 
  public get maxVersion() {
    return this.getStringAttribute('max_version');
  }
  public set maxVersion(value: string) {
    this._maxVersion = value;
  }
  public resetMaxVersion() {
    this._maxVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxVersionInput() {
    return this._maxVersion;
  }

  // min_version - computed: false, optional: true, required: false
  private _minVersion?: string; 
  public get minVersion() {
    return this.getStringAttribute('min_version');
  }
  public set minVersion(value: string) {
    this._minVersion = value;
  }
  public resetMinVersion() {
    this._minVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get minVersionInput() {
    return this._minVersion;
  }

  // passphrase - computed: false, optional: true, required: false
  private _passphrase?: string; 
  public get passphrase() {
    return this.getStringAttribute('passphrase');
  }
  public set passphrase(value: string) {
    this._passphrase = value;
  }
  public resetPassphrase() {
    this._passphrase = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passphraseInput() {
    return this._passphrase;
  }

  // priv_key_path - computed: false, optional: true, required: false
  private _privKeyPath?: string; 
  public get privKeyPath() {
    return this.getStringAttribute('priv_key_path');
  }
  public set privKeyPath(value: string) {
    this._privKeyPath = value;
  }
  public resetPrivKeyPath() {
    this._privKeyPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get privKeyPathInput() {
    return this._privKeyPath;
  }

  // reject_unauthorized - computed: true, optional: true, required: false
  private _rejectUnauthorized?: boolean | cdktf.IResolvable; 
  public get rejectUnauthorized() {
    return this.getBooleanAttribute('reject_unauthorized');
  }
  public set rejectUnauthorized(value: boolean | cdktf.IResolvable) {
    this._rejectUnauthorized = value;
  }
  public resetRejectUnauthorized() {
    this._rejectUnauthorized = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectUnauthorizedInput() {
    return this._rejectUnauthorized;
  }

  // servername - computed: false, optional: true, required: false
  private _servername?: string; 
  public get servername() {
    return this.getStringAttribute('servername');
  }
  public set servername(value: string) {
    this._servername = value;
  }
  public resetServername() {
    this._servername = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get servernameInput() {
    return this._servername;
  }
}
export interface PackDestinationOutputSplunk {
  /**
  * Shared secret token to use when establishing a connection to a Splunk indexer. Default: ""
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#auth_token PackDestination#auth_token}
  */
  readonly authToken?: string;
  /**
  * Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate. Default: "manual"; must be one of ["manual", "secret"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#auth_type PackDestination#auth_type}
  */
  readonly authType?: string;
  /**
  * Controls whether the sender should send compressed data to the server. Select 'Disabled' to reject compressed connections or 'Always' to ignore server's configuration and send compressed data. Default: "disabled"; must be one of ["disabled", "auto", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#compress PackDestination#compress}
  */
  readonly compress?: string;
  /**
  * Amount of time (milliseconds) to wait for the connection to establish before retrying. Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#connection_timeout PackDestination#connection_timeout}
  */
  readonly connectionTimeout?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#description PackDestination#description}
  */
  readonly description?: string;
  /**
  * Check if indexer is shutting down and stop sending data. This helps minimize data loss during shutdown. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#enable_ack PackDestination#enable_ack}
  */
  readonly enableAck?: boolean | cdktf.IResolvable;
  /**
  * Output metrics in multiple-metric format in a single event. Supported in Splunk 8.0 and above. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#enable_multi_metrics PackDestination#enable_multi_metrics}
  */
  readonly enableMultiMetrics?: boolean | cdktf.IResolvable;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#environment PackDestination#environment}
  */
  readonly environment?: string;
  /**
  * The hostname of the receiver
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#host PackDestination#host}
  */
  readonly host: string;
  /**
  * Unique ID for this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#id PackDestination#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * Use to troubleshoot issues with sending data. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#log_failed_requests PackDestination#log_failed_requests}
  */
  readonly logFailedRequests?: boolean | cdktf.IResolvable;
  /**
  * Maximum number of times healthcheck can fail before we close connection. If set to 0 (disabled), and the connection to Splunk is forcibly closed, some data loss might occur. Default: 1
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_failed_health_checks PackDestination#max_failed_health_checks}
  */
  readonly maxFailedHealthChecks?: number;
  /**
  * The highest S2S protocol version to advertise during handshake. Default: "v3"; must be one of ["v3", "v4"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_s2_sversion PackDestination#max_s2_sversion}
  */
  readonly maxS2Sversion?: string;
  /**
  * How to serialize nested fields into index-time fields. Default: "none"; must be one of ["json", "none"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#nested_fields PackDestination#nested_fields}
  */
  readonly nestedFields?: string;
  /**
  * How to handle events when all receivers are exerting backpressure. Default: "block"; must be one of ["block", "drop", "queue"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#on_backpressure PackDestination#on_backpressure}
  */
  readonly onBackpressure?: string;
  /**
  * Pipeline to process data before sending out to this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pipeline PackDestination#pipeline}
  */
  readonly pipeline?: string;
  /**
  * The port to connect to on the provided host. Default: 9997
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#port PackDestination#port}
  */
  readonly port?: number;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_compress PackDestination#pq_compress}
  */
  readonly pqCompress?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_controls PackDestination#pq_controls}
  */
  readonly pqControls?: PackDestinationOutputSplunkPqControls;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.). Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_max_file_size PackDestination#pq_max_file_size}
  */
  readonly pqMaxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_max_size PackDestination#pq_max_size}
  */
  readonly pqMaxSize?: string;
  /**
  * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem. Default: "error"; must be one of ["error", "backpressure", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_mode PackDestination#pq_mode}
  */
  readonly pqMode?: string;
  /**
  * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged. Default: "block"; must be one of ["block", "drop"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_on_backpressure PackDestination#pq_on_backpressure}
  */
  readonly pqOnBackpressure?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_path PackDestination#pq_path}
  */
  readonly pqPath?: string;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#streamtags PackDestination#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Fields to automatically add to events, such as cribl_pipe. Supports wildcards. Default: ["cribl_pipe"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#system_fields PackDestination#system_fields}
  */
  readonly systemFields?: string[];
  /**
  * Select or create a stored text secret
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#text_secret PackDestination#text_secret}
  */
  readonly textSecret?: string;
  /**
  * Rate (in bytes per second) to throttle while writing to an output. Accepts values with multiple-byte units, such as KB, MB, and GB. (Example: 42 MB) Default value of 0 specifies no throttling. Default: "0"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#throttle_rate_per_sec PackDestination#throttle_rate_per_sec}
  */
  readonly throttleRatePerSec?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#tls PackDestination#tls}
  */
  readonly tls?: PackDestinationOutputSplunkTls;
  /**
  * must be "splunk"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#type PackDestination#type}
  */
  readonly type?: string;
  /**
  * Amount of time (milliseconds) to wait for a write to complete before assuming connection is dead. Default: 60000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#write_timeout PackDestination#write_timeout}
  */
  readonly writeTimeout?: number;
}

export function packDestinationOutputSplunkToTerraform(struct?: PackDestinationOutputSplunk | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    auth_token: cdktf.stringToTerraform(struct!.authToken),
    auth_type: cdktf.stringToTerraform(struct!.authType),
    compress: cdktf.stringToTerraform(struct!.compress),
    connection_timeout: cdktf.numberToTerraform(struct!.connectionTimeout),
    description: cdktf.stringToTerraform(struct!.description),
    enable_ack: cdktf.booleanToTerraform(struct!.enableAck),
    enable_multi_metrics: cdktf.booleanToTerraform(struct!.enableMultiMetrics),
    environment: cdktf.stringToTerraform(struct!.environment),
    host: cdktf.stringToTerraform(struct!.host),
    id: cdktf.stringToTerraform(struct!.id),
    log_failed_requests: cdktf.booleanToTerraform(struct!.logFailedRequests),
    max_failed_health_checks: cdktf.numberToTerraform(struct!.maxFailedHealthChecks),
    max_s2_sversion: cdktf.stringToTerraform(struct!.maxS2Sversion),
    nested_fields: cdktf.stringToTerraform(struct!.nestedFields),
    on_backpressure: cdktf.stringToTerraform(struct!.onBackpressure),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    port: cdktf.numberToTerraform(struct!.port),
    pq_compress: cdktf.stringToTerraform(struct!.pqCompress),
    pq_controls: packDestinationOutputSplunkPqControlsToTerraform(struct!.pqControls),
    pq_max_file_size: cdktf.stringToTerraform(struct!.pqMaxFileSize),
    pq_max_size: cdktf.stringToTerraform(struct!.pqMaxSize),
    pq_mode: cdktf.stringToTerraform(struct!.pqMode),
    pq_on_backpressure: cdktf.stringToTerraform(struct!.pqOnBackpressure),
    pq_path: cdktf.stringToTerraform(struct!.pqPath),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    system_fields: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.systemFields),
    text_secret: cdktf.stringToTerraform(struct!.textSecret),
    throttle_rate_per_sec: cdktf.stringToTerraform(struct!.throttleRatePerSec),
    tls: packDestinationOutputSplunkTlsToTerraform(struct!.tls),
    type: cdktf.stringToTerraform(struct!.type),
    write_timeout: cdktf.numberToTerraform(struct!.writeTimeout),
  }
}


export function packDestinationOutputSplunkToHclTerraform(struct?: PackDestinationOutputSplunk | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    auth_token: {
      value: cdktf.stringToHclTerraform(struct!.authToken),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    auth_type: {
      value: cdktf.stringToHclTerraform(struct!.authType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    compress: {
      value: cdktf.stringToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    connection_timeout: {
      value: cdktf.numberToHclTerraform(struct!.connectionTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    enable_ack: {
      value: cdktf.booleanToHclTerraform(struct!.enableAck),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    enable_multi_metrics: {
      value: cdktf.booleanToHclTerraform(struct!.enableMultiMetrics),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    host: {
      value: cdktf.stringToHclTerraform(struct!.host),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    log_failed_requests: {
      value: cdktf.booleanToHclTerraform(struct!.logFailedRequests),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    max_failed_health_checks: {
      value: cdktf.numberToHclTerraform(struct!.maxFailedHealthChecks),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_s2_sversion: {
      value: cdktf.stringToHclTerraform(struct!.maxS2Sversion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    nested_fields: {
      value: cdktf.stringToHclTerraform(struct!.nestedFields),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.onBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    pq_compress: {
      value: cdktf.stringToHclTerraform(struct!.pqCompress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_controls: {
      value: packDestinationOutputSplunkPqControlsToHclTerraform(struct!.pqControls),
      isBlock: true,
      type: "struct",
      storageClassType: "PackDestinationOutputSplunkPqControls",
    },
    pq_max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_max_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_mode: {
      value: cdktf.stringToHclTerraform(struct!.pqMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.pqOnBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_path: {
      value: cdktf.stringToHclTerraform(struct!.pqPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    system_fields: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.systemFields),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    text_secret: {
      value: cdktf.stringToHclTerraform(struct!.textSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    throttle_rate_per_sec: {
      value: cdktf.stringToHclTerraform(struct!.throttleRatePerSec),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tls: {
      value: packDestinationOutputSplunkTlsToHclTerraform(struct!.tls),
      isBlock: true,
      type: "struct",
      storageClassType: "PackDestinationOutputSplunkTls",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    write_timeout: {
      value: cdktf.numberToHclTerraform(struct!.writeTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputSplunkOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackDestinationOutputSplunk | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._authToken !== undefined) {
      hasAnyValues = true;
      internalValueResult.authToken = this._authToken;
    }
    if (this._authType !== undefined) {
      hasAnyValues = true;
      internalValueResult.authType = this._authType;
    }
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._connectionTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.connectionTimeout = this._connectionTimeout;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._enableAck !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableAck = this._enableAck;
    }
    if (this._enableMultiMetrics !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableMultiMetrics = this._enableMultiMetrics;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._host !== undefined) {
      hasAnyValues = true;
      internalValueResult.host = this._host;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._logFailedRequests !== undefined) {
      hasAnyValues = true;
      internalValueResult.logFailedRequests = this._logFailedRequests;
    }
    if (this._maxFailedHealthChecks !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxFailedHealthChecks = this._maxFailedHealthChecks;
    }
    if (this._maxS2Sversion !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxS2Sversion = this._maxS2Sversion;
    }
    if (this._nestedFields !== undefined) {
      hasAnyValues = true;
      internalValueResult.nestedFields = this._nestedFields;
    }
    if (this._onBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.onBackpressure = this._onBackpressure;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._pqCompress !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqCompress = this._pqCompress;
    }
    if (this._pqControls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqControls = this._pqControls?.internalValue;
    }
    if (this._pqMaxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxFileSize = this._pqMaxFileSize;
    }
    if (this._pqMaxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxSize = this._pqMaxSize;
    }
    if (this._pqMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMode = this._pqMode;
    }
    if (this._pqOnBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqOnBackpressure = this._pqOnBackpressure;
    }
    if (this._pqPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqPath = this._pqPath;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._systemFields !== undefined) {
      hasAnyValues = true;
      internalValueResult.systemFields = this._systemFields;
    }
    if (this._textSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.textSecret = this._textSecret;
    }
    if (this._throttleRatePerSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.throttleRatePerSec = this._throttleRatePerSec;
    }
    if (this._tls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tls = this._tls?.internalValue;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._writeTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.writeTimeout = this._writeTimeout;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputSplunk | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._authToken = undefined;
      this._authType = undefined;
      this._compress = undefined;
      this._connectionTimeout = undefined;
      this._description = undefined;
      this._enableAck = undefined;
      this._enableMultiMetrics = undefined;
      this._environment = undefined;
      this._host = undefined;
      this._id = undefined;
      this._logFailedRequests = undefined;
      this._maxFailedHealthChecks = undefined;
      this._maxS2Sversion = undefined;
      this._nestedFields = undefined;
      this._onBackpressure = undefined;
      this._pipeline = undefined;
      this._port = undefined;
      this._pqCompress = undefined;
      this._pqControls.internalValue = undefined;
      this._pqMaxFileSize = undefined;
      this._pqMaxSize = undefined;
      this._pqMode = undefined;
      this._pqOnBackpressure = undefined;
      this._pqPath = undefined;
      this._streamtags = undefined;
      this._systemFields = undefined;
      this._textSecret = undefined;
      this._throttleRatePerSec = undefined;
      this._tls.internalValue = undefined;
      this._type = undefined;
      this._writeTimeout = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._authToken = value.authToken;
      this._authType = value.authType;
      this._compress = value.compress;
      this._connectionTimeout = value.connectionTimeout;
      this._description = value.description;
      this._enableAck = value.enableAck;
      this._enableMultiMetrics = value.enableMultiMetrics;
      this._environment = value.environment;
      this._host = value.host;
      this._id = value.id;
      this._logFailedRequests = value.logFailedRequests;
      this._maxFailedHealthChecks = value.maxFailedHealthChecks;
      this._maxS2Sversion = value.maxS2Sversion;
      this._nestedFields = value.nestedFields;
      this._onBackpressure = value.onBackpressure;
      this._pipeline = value.pipeline;
      this._port = value.port;
      this._pqCompress = value.pqCompress;
      this._pqControls.internalValue = value.pqControls;
      this._pqMaxFileSize = value.pqMaxFileSize;
      this._pqMaxSize = value.pqMaxSize;
      this._pqMode = value.pqMode;
      this._pqOnBackpressure = value.pqOnBackpressure;
      this._pqPath = value.pqPath;
      this._streamtags = value.streamtags;
      this._systemFields = value.systemFields;
      this._textSecret = value.textSecret;
      this._throttleRatePerSec = value.throttleRatePerSec;
      this._tls.internalValue = value.tls;
      this._type = value.type;
      this._writeTimeout = value.writeTimeout;
    }
  }

  // auth_token - computed: true, optional: true, required: false
  private _authToken?: string; 
  public get authToken() {
    return this.getStringAttribute('auth_token');
  }
  public set authToken(value: string) {
    this._authToken = value;
  }
  public resetAuthToken() {
    this._authToken = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authTokenInput() {
    return this._authToken;
  }

  // auth_type - computed: true, optional: true, required: false
  private _authType?: string; 
  public get authType() {
    return this.getStringAttribute('auth_type');
  }
  public set authType(value: string) {
    this._authType = value;
  }
  public resetAuthType() {
    this._authType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authTypeInput() {
    return this._authType;
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: string; 
  public get compress() {
    return this.getStringAttribute('compress');
  }
  public set compress(value: string) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // connection_timeout - computed: true, optional: true, required: false
  private _connectionTimeout?: number; 
  public get connectionTimeout() {
    return this.getNumberAttribute('connection_timeout');
  }
  public set connectionTimeout(value: number) {
    this._connectionTimeout = value;
  }
  public resetConnectionTimeout() {
    this._connectionTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectionTimeoutInput() {
    return this._connectionTimeout;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // enable_ack - computed: true, optional: true, required: false
  private _enableAck?: boolean | cdktf.IResolvable; 
  public get enableAck() {
    return this.getBooleanAttribute('enable_ack');
  }
  public set enableAck(value: boolean | cdktf.IResolvable) {
    this._enableAck = value;
  }
  public resetEnableAck() {
    this._enableAck = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableAckInput() {
    return this._enableAck;
  }

  // enable_multi_metrics - computed: true, optional: true, required: false
  private _enableMultiMetrics?: boolean | cdktf.IResolvable; 
  public get enableMultiMetrics() {
    return this.getBooleanAttribute('enable_multi_metrics');
  }
  public set enableMultiMetrics(value: boolean | cdktf.IResolvable) {
    this._enableMultiMetrics = value;
  }
  public resetEnableMultiMetrics() {
    this._enableMultiMetrics = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableMultiMetricsInput() {
    return this._enableMultiMetrics;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // host - computed: false, optional: false, required: true
  private _host?: string; 
  public get host() {
    return this.getStringAttribute('host');
  }
  public set host(value: string) {
    this._host = value;
  }
  // Temporarily expose input value. Use with caution.
  public get hostInput() {
    return this._host;
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // log_failed_requests - computed: true, optional: true, required: false
  private _logFailedRequests?: boolean | cdktf.IResolvable; 
  public get logFailedRequests() {
    return this.getBooleanAttribute('log_failed_requests');
  }
  public set logFailedRequests(value: boolean | cdktf.IResolvable) {
    this._logFailedRequests = value;
  }
  public resetLogFailedRequests() {
    this._logFailedRequests = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get logFailedRequestsInput() {
    return this._logFailedRequests;
  }

  // max_failed_health_checks - computed: true, optional: true, required: false
  private _maxFailedHealthChecks?: number; 
  public get maxFailedHealthChecks() {
    return this.getNumberAttribute('max_failed_health_checks');
  }
  public set maxFailedHealthChecks(value: number) {
    this._maxFailedHealthChecks = value;
  }
  public resetMaxFailedHealthChecks() {
    this._maxFailedHealthChecks = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxFailedHealthChecksInput() {
    return this._maxFailedHealthChecks;
  }

  // max_s2_sversion - computed: true, optional: true, required: false
  private _maxS2Sversion?: string; 
  public get maxS2Sversion() {
    return this.getStringAttribute('max_s2_sversion');
  }
  public set maxS2Sversion(value: string) {
    this._maxS2Sversion = value;
  }
  public resetMaxS2Sversion() {
    this._maxS2Sversion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxS2SversionInput() {
    return this._maxS2Sversion;
  }

  // nested_fields - computed: true, optional: true, required: false
  private _nestedFields?: string; 
  public get nestedFields() {
    return this.getStringAttribute('nested_fields');
  }
  public set nestedFields(value: string) {
    this._nestedFields = value;
  }
  public resetNestedFields() {
    this._nestedFields = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nestedFieldsInput() {
    return this._nestedFields;
  }

  // on_backpressure - computed: true, optional: true, required: false
  private _onBackpressure?: string; 
  public get onBackpressure() {
    return this.getStringAttribute('on_backpressure');
  }
  public set onBackpressure(value: string) {
    this._onBackpressure = value;
  }
  public resetOnBackpressure() {
    this._onBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get onBackpressureInput() {
    return this._onBackpressure;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // port - computed: true, optional: true, required: false
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // pq_compress - computed: true, optional: true, required: false
  private _pqCompress?: string; 
  public get pqCompress() {
    return this.getStringAttribute('pq_compress');
  }
  public set pqCompress(value: string) {
    this._pqCompress = value;
  }
  public resetPqCompress() {
    this._pqCompress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqCompressInput() {
    return this._pqCompress;
  }

  // pq_controls - computed: false, optional: true, required: false
  private _pqControls = new PackDestinationOutputSplunkPqControlsOutputReference(this, "pq_controls");
  public get pqControls() {
    return this._pqControls;
  }
  public putPqControls(value: PackDestinationOutputSplunkPqControls) {
    this._pqControls.internalValue = value;
  }
  public resetPqControls() {
    this._pqControls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqControlsInput() {
    return this._pqControls.internalValue;
  }

  // pq_max_file_size - computed: true, optional: true, required: false
  private _pqMaxFileSize?: string; 
  public get pqMaxFileSize() {
    return this.getStringAttribute('pq_max_file_size');
  }
  public set pqMaxFileSize(value: string) {
    this._pqMaxFileSize = value;
  }
  public resetPqMaxFileSize() {
    this._pqMaxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxFileSizeInput() {
    return this._pqMaxFileSize;
  }

  // pq_max_size - computed: true, optional: true, required: false
  private _pqMaxSize?: string; 
  public get pqMaxSize() {
    return this.getStringAttribute('pq_max_size');
  }
  public set pqMaxSize(value: string) {
    this._pqMaxSize = value;
  }
  public resetPqMaxSize() {
    this._pqMaxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxSizeInput() {
    return this._pqMaxSize;
  }

  // pq_mode - computed: true, optional: true, required: false
  private _pqMode?: string; 
  public get pqMode() {
    return this.getStringAttribute('pq_mode');
  }
  public set pqMode(value: string) {
    this._pqMode = value;
  }
  public resetPqMode() {
    this._pqMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqModeInput() {
    return this._pqMode;
  }

  // pq_on_backpressure - computed: true, optional: true, required: false
  private _pqOnBackpressure?: string; 
  public get pqOnBackpressure() {
    return this.getStringAttribute('pq_on_backpressure');
  }
  public set pqOnBackpressure(value: string) {
    this._pqOnBackpressure = value;
  }
  public resetPqOnBackpressure() {
    this._pqOnBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqOnBackpressureInput() {
    return this._pqOnBackpressure;
  }

  // pq_path - computed: true, optional: true, required: false
  private _pqPath?: string; 
  public get pqPath() {
    return this.getStringAttribute('pq_path');
  }
  public set pqPath(value: string) {
    this._pqPath = value;
  }
  public resetPqPath() {
    this._pqPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqPathInput() {
    return this._pqPath;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // system_fields - computed: true, optional: true, required: false
  private _systemFields?: string[]; 
  public get systemFields() {
    return this.getListAttribute('system_fields');
  }
  public set systemFields(value: string[]) {
    this._systemFields = value;
  }
  public resetSystemFields() {
    this._systemFields = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get systemFieldsInput() {
    return this._systemFields;
  }

  // text_secret - computed: false, optional: true, required: false
  private _textSecret?: string; 
  public get textSecret() {
    return this.getStringAttribute('text_secret');
  }
  public set textSecret(value: string) {
    this._textSecret = value;
  }
  public resetTextSecret() {
    this._textSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get textSecretInput() {
    return this._textSecret;
  }

  // throttle_rate_per_sec - computed: true, optional: true, required: false
  private _throttleRatePerSec?: string; 
  public get throttleRatePerSec() {
    return this.getStringAttribute('throttle_rate_per_sec');
  }
  public set throttleRatePerSec(value: string) {
    this._throttleRatePerSec = value;
  }
  public resetThrottleRatePerSec() {
    this._throttleRatePerSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get throttleRatePerSecInput() {
    return this._throttleRatePerSec;
  }

  // tls - computed: false, optional: true, required: false
  private _tls = new PackDestinationOutputSplunkTlsOutputReference(this, "tls");
  public get tls() {
    return this._tls;
  }
  public putTls(value: PackDestinationOutputSplunkTls) {
    this._tls.internalValue = value;
  }
  public resetTls() {
    this._tls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsInput() {
    return this._tls.internalValue;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // write_timeout - computed: true, optional: true, required: false
  private _writeTimeout?: number; 
  public get writeTimeout() {
    return this.getNumberAttribute('write_timeout');
  }
  public set writeTimeout(value: number) {
    this._writeTimeout = value;
  }
  public resetWriteTimeout() {
    this._writeTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get writeTimeoutInput() {
    return this._writeTimeout;
  }
}
export interface PackDestinationOutputSplunkHecExtraHttpHeaders {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#name PackDestination#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#value PackDestination#value}
  */
  readonly value: string;
}

export function packDestinationOutputSplunkHecExtraHttpHeadersToTerraform(struct?: PackDestinationOutputSplunkHecExtraHttpHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function packDestinationOutputSplunkHecExtraHttpHeadersToHclTerraform(struct?: PackDestinationOutputSplunkHecExtraHttpHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputSplunkHecExtraHttpHeadersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackDestinationOutputSplunkHecExtraHttpHeaders | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputSplunkHecExtraHttpHeaders | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class PackDestinationOutputSplunkHecExtraHttpHeadersList extends cdktf.ComplexList {
  public internalValue? : PackDestinationOutputSplunkHecExtraHttpHeaders[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackDestinationOutputSplunkHecExtraHttpHeadersOutputReference {
    return new PackDestinationOutputSplunkHecExtraHttpHeadersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackDestinationOutputSplunkHecPqControls {
}

export function packDestinationOutputSplunkHecPqControlsToTerraform(struct?: PackDestinationOutputSplunkHecPqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function packDestinationOutputSplunkHecPqControlsToHclTerraform(struct?: PackDestinationOutputSplunkHecPqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class PackDestinationOutputSplunkHecPqControlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackDestinationOutputSplunkHecPqControls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputSplunkHecPqControls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface PackDestinationOutputSplunkHecResponseRetrySettings {
  /**
  * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc. Default: 2
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#backoff_rate PackDestination#backoff_rate}
  */
  readonly backoffRate?: number;
  /**
  * The HTTP response status code that will trigger retries
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#http_status PackDestination#http_status}
  */
  readonly httpStatus: number;
  /**
  * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes). Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#initial_backoff PackDestination#initial_backoff}
  */
  readonly initialBackoff?: number;
  /**
  * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds). Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_backoff PackDestination#max_backoff}
  */
  readonly maxBackoff?: number;
}

export function packDestinationOutputSplunkHecResponseRetrySettingsToTerraform(struct?: PackDestinationOutputSplunkHecResponseRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    backoff_rate: cdktf.numberToTerraform(struct!.backoffRate),
    http_status: cdktf.numberToTerraform(struct!.httpStatus),
    initial_backoff: cdktf.numberToTerraform(struct!.initialBackoff),
    max_backoff: cdktf.numberToTerraform(struct!.maxBackoff),
  }
}


export function packDestinationOutputSplunkHecResponseRetrySettingsToHclTerraform(struct?: PackDestinationOutputSplunkHecResponseRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    backoff_rate: {
      value: cdktf.numberToHclTerraform(struct!.backoffRate),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    http_status: {
      value: cdktf.numberToHclTerraform(struct!.httpStatus),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    initial_backoff: {
      value: cdktf.numberToHclTerraform(struct!.initialBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_backoff: {
      value: cdktf.numberToHclTerraform(struct!.maxBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputSplunkHecResponseRetrySettingsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackDestinationOutputSplunkHecResponseRetrySettings | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._backoffRate !== undefined) {
      hasAnyValues = true;
      internalValueResult.backoffRate = this._backoffRate;
    }
    if (this._httpStatus !== undefined) {
      hasAnyValues = true;
      internalValueResult.httpStatus = this._httpStatus;
    }
    if (this._initialBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.initialBackoff = this._initialBackoff;
    }
    if (this._maxBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBackoff = this._maxBackoff;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputSplunkHecResponseRetrySettings | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._backoffRate = undefined;
      this._httpStatus = undefined;
      this._initialBackoff = undefined;
      this._maxBackoff = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._backoffRate = value.backoffRate;
      this._httpStatus = value.httpStatus;
      this._initialBackoff = value.initialBackoff;
      this._maxBackoff = value.maxBackoff;
    }
  }

  // backoff_rate - computed: true, optional: true, required: false
  private _backoffRate?: number; 
  public get backoffRate() {
    return this.getNumberAttribute('backoff_rate');
  }
  public set backoffRate(value: number) {
    this._backoffRate = value;
  }
  public resetBackoffRate() {
    this._backoffRate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get backoffRateInput() {
    return this._backoffRate;
  }

  // http_status - computed: false, optional: false, required: true
  private _httpStatus?: number; 
  public get httpStatus() {
    return this.getNumberAttribute('http_status');
  }
  public set httpStatus(value: number) {
    this._httpStatus = value;
  }
  // Temporarily expose input value. Use with caution.
  public get httpStatusInput() {
    return this._httpStatus;
  }

  // initial_backoff - computed: true, optional: true, required: false
  private _initialBackoff?: number; 
  public get initialBackoff() {
    return this.getNumberAttribute('initial_backoff');
  }
  public set initialBackoff(value: number) {
    this._initialBackoff = value;
  }
  public resetInitialBackoff() {
    this._initialBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get initialBackoffInput() {
    return this._initialBackoff;
  }

  // max_backoff - computed: true, optional: true, required: false
  private _maxBackoff?: number; 
  public get maxBackoff() {
    return this.getNumberAttribute('max_backoff');
  }
  public set maxBackoff(value: number) {
    this._maxBackoff = value;
  }
  public resetMaxBackoff() {
    this._maxBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBackoffInput() {
    return this._maxBackoff;
  }
}

export class PackDestinationOutputSplunkHecResponseRetrySettingsList extends cdktf.ComplexList {
  public internalValue? : PackDestinationOutputSplunkHecResponseRetrySettings[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackDestinationOutputSplunkHecResponseRetrySettingsOutputReference {
    return new PackDestinationOutputSplunkHecResponseRetrySettingsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackDestinationOutputSplunkHecTimeoutRetrySettings {
  /**
  * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc. Default: 2
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#backoff_rate PackDestination#backoff_rate}
  */
  readonly backoffRate?: number;
  /**
  * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes). Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#initial_backoff PackDestination#initial_backoff}
  */
  readonly initialBackoff?: number;
  /**
  * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds). Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_backoff PackDestination#max_backoff}
  */
  readonly maxBackoff?: number;
  /**
  * Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#timeout_retry PackDestination#timeout_retry}
  */
  readonly timeoutRetry?: boolean | cdktf.IResolvable;
}

export function packDestinationOutputSplunkHecTimeoutRetrySettingsToTerraform(struct?: PackDestinationOutputSplunkHecTimeoutRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    backoff_rate: cdktf.numberToTerraform(struct!.backoffRate),
    initial_backoff: cdktf.numberToTerraform(struct!.initialBackoff),
    max_backoff: cdktf.numberToTerraform(struct!.maxBackoff),
    timeout_retry: cdktf.booleanToTerraform(struct!.timeoutRetry),
  }
}


export function packDestinationOutputSplunkHecTimeoutRetrySettingsToHclTerraform(struct?: PackDestinationOutputSplunkHecTimeoutRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    backoff_rate: {
      value: cdktf.numberToHclTerraform(struct!.backoffRate),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    initial_backoff: {
      value: cdktf.numberToHclTerraform(struct!.initialBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_backoff: {
      value: cdktf.numberToHclTerraform(struct!.maxBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    timeout_retry: {
      value: cdktf.booleanToHclTerraform(struct!.timeoutRetry),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputSplunkHecTimeoutRetrySettingsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackDestinationOutputSplunkHecTimeoutRetrySettings | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._backoffRate !== undefined) {
      hasAnyValues = true;
      internalValueResult.backoffRate = this._backoffRate;
    }
    if (this._initialBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.initialBackoff = this._initialBackoff;
    }
    if (this._maxBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBackoff = this._maxBackoff;
    }
    if (this._timeoutRetry !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutRetry = this._timeoutRetry;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputSplunkHecTimeoutRetrySettings | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._backoffRate = undefined;
      this._initialBackoff = undefined;
      this._maxBackoff = undefined;
      this._timeoutRetry = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._backoffRate = value.backoffRate;
      this._initialBackoff = value.initialBackoff;
      this._maxBackoff = value.maxBackoff;
      this._timeoutRetry = value.timeoutRetry;
    }
  }

  // backoff_rate - computed: true, optional: true, required: false
  private _backoffRate?: number; 
  public get backoffRate() {
    return this.getNumberAttribute('backoff_rate');
  }
  public set backoffRate(value: number) {
    this._backoffRate = value;
  }
  public resetBackoffRate() {
    this._backoffRate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get backoffRateInput() {
    return this._backoffRate;
  }

  // initial_backoff - computed: true, optional: true, required: false
  private _initialBackoff?: number; 
  public get initialBackoff() {
    return this.getNumberAttribute('initial_backoff');
  }
  public set initialBackoff(value: number) {
    this._initialBackoff = value;
  }
  public resetInitialBackoff() {
    this._initialBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get initialBackoffInput() {
    return this._initialBackoff;
  }

  // max_backoff - computed: true, optional: true, required: false
  private _maxBackoff?: number; 
  public get maxBackoff() {
    return this.getNumberAttribute('max_backoff');
  }
  public set maxBackoff(value: number) {
    this._maxBackoff = value;
  }
  public resetMaxBackoff() {
    this._maxBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBackoffInput() {
    return this._maxBackoff;
  }

  // timeout_retry - computed: true, optional: true, required: false
  private _timeoutRetry?: boolean | cdktf.IResolvable; 
  public get timeoutRetry() {
    return this.getBooleanAttribute('timeout_retry');
  }
  public set timeoutRetry(value: boolean | cdktf.IResolvable) {
    this._timeoutRetry = value;
  }
  public resetTimeoutRetry() {
    this._timeoutRetry = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutRetryInput() {
    return this._timeoutRetry;
  }
}
export interface PackDestinationOutputSplunkHecUrls {
  /**
  * URL to a Splunk HEC endpoint to send events to, e.g., http://localhost:8088/services/collector/event. Default: "http://localhost:8088/services/collector/event"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#url PackDestination#url}
  */
  readonly url?: string;
  /**
  * Assign a weight (>0) to each endpoint to indicate its traffic-handling capability. Default: 1
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#weight PackDestination#weight}
  */
  readonly weight?: number;
}

export function packDestinationOutputSplunkHecUrlsToTerraform(struct?: PackDestinationOutputSplunkHecUrls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    url: cdktf.stringToTerraform(struct!.url),
    weight: cdktf.numberToTerraform(struct!.weight),
  }
}


export function packDestinationOutputSplunkHecUrlsToHclTerraform(struct?: PackDestinationOutputSplunkHecUrls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    url: {
      value: cdktf.stringToHclTerraform(struct!.url),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    weight: {
      value: cdktf.numberToHclTerraform(struct!.weight),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputSplunkHecUrlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackDestinationOutputSplunkHecUrls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._url !== undefined) {
      hasAnyValues = true;
      internalValueResult.url = this._url;
    }
    if (this._weight !== undefined) {
      hasAnyValues = true;
      internalValueResult.weight = this._weight;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputSplunkHecUrls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._url = undefined;
      this._weight = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._url = value.url;
      this._weight = value.weight;
    }
  }

  // url - computed: true, optional: true, required: false
  private _url?: string; 
  public get url() {
    return this.getStringAttribute('url');
  }
  public set url(value: string) {
    this._url = value;
  }
  public resetUrl() {
    this._url = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get urlInput() {
    return this._url;
  }

  // weight - computed: true, optional: true, required: false
  private _weight?: number; 
  public get weight() {
    return this.getNumberAttribute('weight');
  }
  public set weight(value: number) {
    this._weight = value;
  }
  public resetWeight() {
    this._weight = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get weightInput() {
    return this._weight;
  }
}

export class PackDestinationOutputSplunkHecUrlsList extends cdktf.ComplexList {
  public internalValue? : PackDestinationOutputSplunkHecUrls[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackDestinationOutputSplunkHecUrlsOutputReference {
    return new PackDestinationOutputSplunkHecUrlsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackDestinationOutputSplunkHec {
  /**
  * Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate. Default: "manual"; must be one of ["manual", "secret"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#auth_type PackDestination#auth_type}
  */
  readonly authType?: string;
  /**
  * Compress the payload body before sending. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#compress PackDestination#compress}
  */
  readonly compress?: boolean | cdktf.IResolvable;
  /**
  * Maximum number of ongoing requests before blocking. Default: 5
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#concurrency PackDestination#concurrency}
  */
  readonly concurrency?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#description PackDestination#description}
  */
  readonly description?: string;
  /**
  * The interval in which to re-resolve any hostnames and pick up destinations from A records. Default: 600
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#dns_resolve_period_sec PackDestination#dns_resolve_period_sec}
  */
  readonly dnsResolvePeriodSec?: number;
  /**
  * Output metrics in multiple-metric format, supported in Splunk 8.0 and above to allow multiple metrics in a single event. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#enable_multi_metrics PackDestination#enable_multi_metrics}
  */
  readonly enableMultiMetrics?: boolean | cdktf.IResolvable;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#environment PackDestination#environment}
  */
  readonly environment?: string;
  /**
  * Exclude all IPs of the current host from the list of any resolved hostnames. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#exclude_self PackDestination#exclude_self}
  */
  readonly excludeSelf?: boolean | cdktf.IResolvable;
  /**
  * Headers to add to all events
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#extra_http_headers PackDestination#extra_http_headers}
  */
  readonly extraHttpHeaders?: PackDestinationOutputSplunkHecExtraHttpHeaders[] | cdktf.IResolvable;
  /**
  * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below. Default: "none"; must be one of ["payload", "payloadAndHeaders", "none"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#failed_request_logging_mode PackDestination#failed_request_logging_mode}
  */
  readonly failedRequestLoggingMode?: string;
  /**
  * Maximum time between requests. Small values could cause the payload size to be smaller than the configured Body size limit. Default: 1
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#flush_period_sec PackDestination#flush_period_sec}
  */
  readonly flushPeriodSec?: number;
  /**
  * Unique ID for this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#id PackDestination#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id: string;
  /**
  * How far back in time to keep traffic stats for load balancing purposes. Default: 300
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#load_balance_stats_period_sec PackDestination#load_balance_stats_period_sec}
  */
  readonly loadBalanceStatsPeriodSec?: number;
  /**
  * Enable for optimal performance. Even if you have one hostname, it can expand to multiple IPs. If disabled, consider enabling round-robin DNS. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#load_balanced PackDestination#load_balanced}
  */
  readonly loadBalanced?: boolean | cdktf.IResolvable;
  /**
  * Maximum number of events to include in the request body. Default is 0 (unlimited). Default: 0
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_payload_events PackDestination#max_payload_events}
  */
  readonly maxPayloadEvents?: number;
  /**
  * Maximum size, in KB, of the request body. Default: 4096
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_payload_size_kb PackDestination#max_payload_size_kb}
  */
  readonly maxPayloadSizeKb?: number;
  /**
  * In the Splunk app, define which Splunk processing queue to send the events after HEC processing. Default: "indexQueue"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#next_queue PackDestination#next_queue}
  */
  readonly nextQueue?: string;
  /**
  * How to handle events when all receivers are exerting backpressure. Default: "block"; must be one of ["block", "drop", "queue"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#on_backpressure PackDestination#on_backpressure}
  */
  readonly onBackpressure?: string;
  /**
  * Pipeline to process data before sending out to this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pipeline PackDestination#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_compress PackDestination#pq_compress}
  */
  readonly pqCompress?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_controls PackDestination#pq_controls}
  */
  readonly pqControls?: PackDestinationOutputSplunkHecPqControls;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.). Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_max_file_size PackDestination#pq_max_file_size}
  */
  readonly pqMaxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_max_size PackDestination#pq_max_size}
  */
  readonly pqMaxSize?: string;
  /**
  * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem. Default: "error"; must be one of ["error", "backpressure", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_mode PackDestination#pq_mode}
  */
  readonly pqMode?: string;
  /**
  * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged. Default: "block"; must be one of ["block", "drop"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_on_backpressure PackDestination#pq_on_backpressure}
  */
  readonly pqOnBackpressure?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_path PackDestination#pq_path}
  */
  readonly pqPath?: string;
  /**
  * Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's). 
  *         Enabled by default. When this setting is also present in TLS Settings (Client Side), 
  *         that value will take precedence.
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#reject_unauthorized PackDestination#reject_unauthorized}
  */
  readonly rejectUnauthorized?: boolean | cdktf.IResolvable;
  /**
  * Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#response_honor_retry_after_header PackDestination#response_honor_retry_after_header}
  */
  readonly responseHonorRetryAfterHeader?: boolean | cdktf.IResolvable;
  /**
  * Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#response_retry_settings PackDestination#response_retry_settings}
  */
  readonly responseRetrySettings?: PackDestinationOutputSplunkHecResponseRetrySettings[] | cdktf.IResolvable;
  /**
  * List of headers that are safe to log in plain text. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#safe_headers PackDestination#safe_headers}
  */
  readonly safeHeaders?: string[];
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#streamtags PackDestination#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Fields to automatically add to events, such as cribl_pipe. Supports wildcards. Default: ["cribl_pipe"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#system_fields PackDestination#system_fields}
  */
  readonly systemFields?: string[];
  /**
  * In the Splunk app, set the value of _TCP_ROUTING for events that do not have _ctrl._TCP_ROUTING set. Default: "nowhere"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#tcp_routing PackDestination#tcp_routing}
  */
  readonly tcpRouting?: string;
  /**
  * Select or create a stored text secret
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#text_secret PackDestination#text_secret}
  */
  readonly textSecret?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#timeout_retry_settings PackDestination#timeout_retry_settings}
  */
  readonly timeoutRetrySettings?: PackDestinationOutputSplunkHecTimeoutRetrySettings;
  /**
  * Amount of time, in seconds, to wait for a request to complete before canceling it. Default: 30
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#timeout_sec PackDestination#timeout_sec}
  */
  readonly timeoutSec?: number;
  /**
  * Splunk HEC authentication token
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#token PackDestination#token}
  */
  readonly token?: string;
  /**
  * must be "splunk_hec"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#type PackDestination#type}
  */
  readonly type: string;
  /**
  * URL to a Splunk HEC endpoint to send events to, e.g., http://localhost:8088/services/collector/event. Default: "http://localhost:8088/services/collector/event"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#url PackDestination#url}
  */
  readonly url?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#urls PackDestination#urls}
  */
  readonly urls?: PackDestinationOutputSplunkHecUrls[] | cdktf.IResolvable;
  /**
  * Enable round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. For optimal performance, consider enabling this setting for non-load balanced destinations. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#use_round_robin_dns PackDestination#use_round_robin_dns}
  */
  readonly useRoundRobinDns?: boolean | cdktf.IResolvable;
}

export function packDestinationOutputSplunkHecToTerraform(struct?: PackDestinationOutputSplunkHec | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    auth_type: cdktf.stringToTerraform(struct!.authType),
    compress: cdktf.booleanToTerraform(struct!.compress),
    concurrency: cdktf.numberToTerraform(struct!.concurrency),
    description: cdktf.stringToTerraform(struct!.description),
    dns_resolve_period_sec: cdktf.numberToTerraform(struct!.dnsResolvePeriodSec),
    enable_multi_metrics: cdktf.booleanToTerraform(struct!.enableMultiMetrics),
    environment: cdktf.stringToTerraform(struct!.environment),
    exclude_self: cdktf.booleanToTerraform(struct!.excludeSelf),
    extra_http_headers: cdktf.listMapper(packDestinationOutputSplunkHecExtraHttpHeadersToTerraform, false)(struct!.extraHttpHeaders),
    failed_request_logging_mode: cdktf.stringToTerraform(struct!.failedRequestLoggingMode),
    flush_period_sec: cdktf.numberToTerraform(struct!.flushPeriodSec),
    id: cdktf.stringToTerraform(struct!.id),
    load_balance_stats_period_sec: cdktf.numberToTerraform(struct!.loadBalanceStatsPeriodSec),
    load_balanced: cdktf.booleanToTerraform(struct!.loadBalanced),
    max_payload_events: cdktf.numberToTerraform(struct!.maxPayloadEvents),
    max_payload_size_kb: cdktf.numberToTerraform(struct!.maxPayloadSizeKb),
    next_queue: cdktf.stringToTerraform(struct!.nextQueue),
    on_backpressure: cdktf.stringToTerraform(struct!.onBackpressure),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    pq_compress: cdktf.stringToTerraform(struct!.pqCompress),
    pq_controls: packDestinationOutputSplunkHecPqControlsToTerraform(struct!.pqControls),
    pq_max_file_size: cdktf.stringToTerraform(struct!.pqMaxFileSize),
    pq_max_size: cdktf.stringToTerraform(struct!.pqMaxSize),
    pq_mode: cdktf.stringToTerraform(struct!.pqMode),
    pq_on_backpressure: cdktf.stringToTerraform(struct!.pqOnBackpressure),
    pq_path: cdktf.stringToTerraform(struct!.pqPath),
    reject_unauthorized: cdktf.booleanToTerraform(struct!.rejectUnauthorized),
    response_honor_retry_after_header: cdktf.booleanToTerraform(struct!.responseHonorRetryAfterHeader),
    response_retry_settings: cdktf.listMapper(packDestinationOutputSplunkHecResponseRetrySettingsToTerraform, false)(struct!.responseRetrySettings),
    safe_headers: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.safeHeaders),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    system_fields: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.systemFields),
    tcp_routing: cdktf.stringToTerraform(struct!.tcpRouting),
    text_secret: cdktf.stringToTerraform(struct!.textSecret),
    timeout_retry_settings: packDestinationOutputSplunkHecTimeoutRetrySettingsToTerraform(struct!.timeoutRetrySettings),
    timeout_sec: cdktf.numberToTerraform(struct!.timeoutSec),
    token: cdktf.stringToTerraform(struct!.token),
    type: cdktf.stringToTerraform(struct!.type),
    url: cdktf.stringToTerraform(struct!.url),
    urls: cdktf.listMapper(packDestinationOutputSplunkHecUrlsToTerraform, false)(struct!.urls),
    use_round_robin_dns: cdktf.booleanToTerraform(struct!.useRoundRobinDns),
  }
}


export function packDestinationOutputSplunkHecToHclTerraform(struct?: PackDestinationOutputSplunkHec | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    auth_type: {
      value: cdktf.stringToHclTerraform(struct!.authType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    compress: {
      value: cdktf.booleanToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    concurrency: {
      value: cdktf.numberToHclTerraform(struct!.concurrency),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    dns_resolve_period_sec: {
      value: cdktf.numberToHclTerraform(struct!.dnsResolvePeriodSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    enable_multi_metrics: {
      value: cdktf.booleanToHclTerraform(struct!.enableMultiMetrics),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    exclude_self: {
      value: cdktf.booleanToHclTerraform(struct!.excludeSelf),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    extra_http_headers: {
      value: cdktf.listMapperHcl(packDestinationOutputSplunkHecExtraHttpHeadersToHclTerraform, false)(struct!.extraHttpHeaders),
      isBlock: true,
      type: "list",
      storageClassType: "PackDestinationOutputSplunkHecExtraHttpHeadersList",
    },
    failed_request_logging_mode: {
      value: cdktf.stringToHclTerraform(struct!.failedRequestLoggingMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    flush_period_sec: {
      value: cdktf.numberToHclTerraform(struct!.flushPeriodSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    load_balance_stats_period_sec: {
      value: cdktf.numberToHclTerraform(struct!.loadBalanceStatsPeriodSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    load_balanced: {
      value: cdktf.booleanToHclTerraform(struct!.loadBalanced),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    max_payload_events: {
      value: cdktf.numberToHclTerraform(struct!.maxPayloadEvents),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_payload_size_kb: {
      value: cdktf.numberToHclTerraform(struct!.maxPayloadSizeKb),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    next_queue: {
      value: cdktf.stringToHclTerraform(struct!.nextQueue),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.onBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_compress: {
      value: cdktf.stringToHclTerraform(struct!.pqCompress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_controls: {
      value: packDestinationOutputSplunkHecPqControlsToHclTerraform(struct!.pqControls),
      isBlock: true,
      type: "struct",
      storageClassType: "PackDestinationOutputSplunkHecPqControls",
    },
    pq_max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_max_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_mode: {
      value: cdktf.stringToHclTerraform(struct!.pqMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.pqOnBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_path: {
      value: cdktf.stringToHclTerraform(struct!.pqPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reject_unauthorized: {
      value: cdktf.booleanToHclTerraform(struct!.rejectUnauthorized),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    response_honor_retry_after_header: {
      value: cdktf.booleanToHclTerraform(struct!.responseHonorRetryAfterHeader),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    response_retry_settings: {
      value: cdktf.listMapperHcl(packDestinationOutputSplunkHecResponseRetrySettingsToHclTerraform, false)(struct!.responseRetrySettings),
      isBlock: true,
      type: "list",
      storageClassType: "PackDestinationOutputSplunkHecResponseRetrySettingsList",
    },
    safe_headers: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.safeHeaders),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    system_fields: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.systemFields),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    tcp_routing: {
      value: cdktf.stringToHclTerraform(struct!.tcpRouting),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    text_secret: {
      value: cdktf.stringToHclTerraform(struct!.textSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    timeout_retry_settings: {
      value: packDestinationOutputSplunkHecTimeoutRetrySettingsToHclTerraform(struct!.timeoutRetrySettings),
      isBlock: true,
      type: "struct",
      storageClassType: "PackDestinationOutputSplunkHecTimeoutRetrySettings",
    },
    timeout_sec: {
      value: cdktf.numberToHclTerraform(struct!.timeoutSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    token: {
      value: cdktf.stringToHclTerraform(struct!.token),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    url: {
      value: cdktf.stringToHclTerraform(struct!.url),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    urls: {
      value: cdktf.listMapperHcl(packDestinationOutputSplunkHecUrlsToHclTerraform, false)(struct!.urls),
      isBlock: true,
      type: "list",
      storageClassType: "PackDestinationOutputSplunkHecUrlsList",
    },
    use_round_robin_dns: {
      value: cdktf.booleanToHclTerraform(struct!.useRoundRobinDns),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputSplunkHecOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackDestinationOutputSplunkHec | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._authType !== undefined) {
      hasAnyValues = true;
      internalValueResult.authType = this._authType;
    }
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._concurrency !== undefined) {
      hasAnyValues = true;
      internalValueResult.concurrency = this._concurrency;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._dnsResolvePeriodSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.dnsResolvePeriodSec = this._dnsResolvePeriodSec;
    }
    if (this._enableMultiMetrics !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableMultiMetrics = this._enableMultiMetrics;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._excludeSelf !== undefined) {
      hasAnyValues = true;
      internalValueResult.excludeSelf = this._excludeSelf;
    }
    if (this._extraHttpHeaders?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.extraHttpHeaders = this._extraHttpHeaders?.internalValue;
    }
    if (this._failedRequestLoggingMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.failedRequestLoggingMode = this._failedRequestLoggingMode;
    }
    if (this._flushPeriodSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.flushPeriodSec = this._flushPeriodSec;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._loadBalanceStatsPeriodSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.loadBalanceStatsPeriodSec = this._loadBalanceStatsPeriodSec;
    }
    if (this._loadBalanced !== undefined) {
      hasAnyValues = true;
      internalValueResult.loadBalanced = this._loadBalanced;
    }
    if (this._maxPayloadEvents !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxPayloadEvents = this._maxPayloadEvents;
    }
    if (this._maxPayloadSizeKb !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxPayloadSizeKb = this._maxPayloadSizeKb;
    }
    if (this._nextQueue !== undefined) {
      hasAnyValues = true;
      internalValueResult.nextQueue = this._nextQueue;
    }
    if (this._onBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.onBackpressure = this._onBackpressure;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._pqCompress !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqCompress = this._pqCompress;
    }
    if (this._pqControls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqControls = this._pqControls?.internalValue;
    }
    if (this._pqMaxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxFileSize = this._pqMaxFileSize;
    }
    if (this._pqMaxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxSize = this._pqMaxSize;
    }
    if (this._pqMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMode = this._pqMode;
    }
    if (this._pqOnBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqOnBackpressure = this._pqOnBackpressure;
    }
    if (this._pqPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqPath = this._pqPath;
    }
    if (this._rejectUnauthorized !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectUnauthorized = this._rejectUnauthorized;
    }
    if (this._responseHonorRetryAfterHeader !== undefined) {
      hasAnyValues = true;
      internalValueResult.responseHonorRetryAfterHeader = this._responseHonorRetryAfterHeader;
    }
    if (this._responseRetrySettings?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.responseRetrySettings = this._responseRetrySettings?.internalValue;
    }
    if (this._safeHeaders !== undefined) {
      hasAnyValues = true;
      internalValueResult.safeHeaders = this._safeHeaders;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._systemFields !== undefined) {
      hasAnyValues = true;
      internalValueResult.systemFields = this._systemFields;
    }
    if (this._tcpRouting !== undefined) {
      hasAnyValues = true;
      internalValueResult.tcpRouting = this._tcpRouting;
    }
    if (this._textSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.textSecret = this._textSecret;
    }
    if (this._timeoutRetrySettings?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutRetrySettings = this._timeoutRetrySettings?.internalValue;
    }
    if (this._timeoutSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutSec = this._timeoutSec;
    }
    if (this._token !== undefined) {
      hasAnyValues = true;
      internalValueResult.token = this._token;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._url !== undefined) {
      hasAnyValues = true;
      internalValueResult.url = this._url;
    }
    if (this._urls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.urls = this._urls?.internalValue;
    }
    if (this._useRoundRobinDns !== undefined) {
      hasAnyValues = true;
      internalValueResult.useRoundRobinDns = this._useRoundRobinDns;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputSplunkHec | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._authType = undefined;
      this._compress = undefined;
      this._concurrency = undefined;
      this._description = undefined;
      this._dnsResolvePeriodSec = undefined;
      this._enableMultiMetrics = undefined;
      this._environment = undefined;
      this._excludeSelf = undefined;
      this._extraHttpHeaders.internalValue = undefined;
      this._failedRequestLoggingMode = undefined;
      this._flushPeriodSec = undefined;
      this._id = undefined;
      this._loadBalanceStatsPeriodSec = undefined;
      this._loadBalanced = undefined;
      this._maxPayloadEvents = undefined;
      this._maxPayloadSizeKb = undefined;
      this._nextQueue = undefined;
      this._onBackpressure = undefined;
      this._pipeline = undefined;
      this._pqCompress = undefined;
      this._pqControls.internalValue = undefined;
      this._pqMaxFileSize = undefined;
      this._pqMaxSize = undefined;
      this._pqMode = undefined;
      this._pqOnBackpressure = undefined;
      this._pqPath = undefined;
      this._rejectUnauthorized = undefined;
      this._responseHonorRetryAfterHeader = undefined;
      this._responseRetrySettings.internalValue = undefined;
      this._safeHeaders = undefined;
      this._streamtags = undefined;
      this._systemFields = undefined;
      this._tcpRouting = undefined;
      this._textSecret = undefined;
      this._timeoutRetrySettings.internalValue = undefined;
      this._timeoutSec = undefined;
      this._token = undefined;
      this._type = undefined;
      this._url = undefined;
      this._urls.internalValue = undefined;
      this._useRoundRobinDns = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._authType = value.authType;
      this._compress = value.compress;
      this._concurrency = value.concurrency;
      this._description = value.description;
      this._dnsResolvePeriodSec = value.dnsResolvePeriodSec;
      this._enableMultiMetrics = value.enableMultiMetrics;
      this._environment = value.environment;
      this._excludeSelf = value.excludeSelf;
      this._extraHttpHeaders.internalValue = value.extraHttpHeaders;
      this._failedRequestLoggingMode = value.failedRequestLoggingMode;
      this._flushPeriodSec = value.flushPeriodSec;
      this._id = value.id;
      this._loadBalanceStatsPeriodSec = value.loadBalanceStatsPeriodSec;
      this._loadBalanced = value.loadBalanced;
      this._maxPayloadEvents = value.maxPayloadEvents;
      this._maxPayloadSizeKb = value.maxPayloadSizeKb;
      this._nextQueue = value.nextQueue;
      this._onBackpressure = value.onBackpressure;
      this._pipeline = value.pipeline;
      this._pqCompress = value.pqCompress;
      this._pqControls.internalValue = value.pqControls;
      this._pqMaxFileSize = value.pqMaxFileSize;
      this._pqMaxSize = value.pqMaxSize;
      this._pqMode = value.pqMode;
      this._pqOnBackpressure = value.pqOnBackpressure;
      this._pqPath = value.pqPath;
      this._rejectUnauthorized = value.rejectUnauthorized;
      this._responseHonorRetryAfterHeader = value.responseHonorRetryAfterHeader;
      this._responseRetrySettings.internalValue = value.responseRetrySettings;
      this._safeHeaders = value.safeHeaders;
      this._streamtags = value.streamtags;
      this._systemFields = value.systemFields;
      this._tcpRouting = value.tcpRouting;
      this._textSecret = value.textSecret;
      this._timeoutRetrySettings.internalValue = value.timeoutRetrySettings;
      this._timeoutSec = value.timeoutSec;
      this._token = value.token;
      this._type = value.type;
      this._url = value.url;
      this._urls.internalValue = value.urls;
      this._useRoundRobinDns = value.useRoundRobinDns;
    }
  }

  // auth_type - computed: true, optional: true, required: false
  private _authType?: string; 
  public get authType() {
    return this.getStringAttribute('auth_type');
  }
  public set authType(value: string) {
    this._authType = value;
  }
  public resetAuthType() {
    this._authType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authTypeInput() {
    return this._authType;
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: boolean | cdktf.IResolvable; 
  public get compress() {
    return this.getBooleanAttribute('compress');
  }
  public set compress(value: boolean | cdktf.IResolvable) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // concurrency - computed: true, optional: true, required: false
  private _concurrency?: number; 
  public get concurrency() {
    return this.getNumberAttribute('concurrency');
  }
  public set concurrency(value: number) {
    this._concurrency = value;
  }
  public resetConcurrency() {
    this._concurrency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get concurrencyInput() {
    return this._concurrency;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // dns_resolve_period_sec - computed: true, optional: true, required: false
  private _dnsResolvePeriodSec?: number; 
  public get dnsResolvePeriodSec() {
    return this.getNumberAttribute('dns_resolve_period_sec');
  }
  public set dnsResolvePeriodSec(value: number) {
    this._dnsResolvePeriodSec = value;
  }
  public resetDnsResolvePeriodSec() {
    this._dnsResolvePeriodSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dnsResolvePeriodSecInput() {
    return this._dnsResolvePeriodSec;
  }

  // enable_multi_metrics - computed: true, optional: true, required: false
  private _enableMultiMetrics?: boolean | cdktf.IResolvable; 
  public get enableMultiMetrics() {
    return this.getBooleanAttribute('enable_multi_metrics');
  }
  public set enableMultiMetrics(value: boolean | cdktf.IResolvable) {
    this._enableMultiMetrics = value;
  }
  public resetEnableMultiMetrics() {
    this._enableMultiMetrics = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableMultiMetricsInput() {
    return this._enableMultiMetrics;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // exclude_self - computed: true, optional: true, required: false
  private _excludeSelf?: boolean | cdktf.IResolvable; 
  public get excludeSelf() {
    return this.getBooleanAttribute('exclude_self');
  }
  public set excludeSelf(value: boolean | cdktf.IResolvable) {
    this._excludeSelf = value;
  }
  public resetExcludeSelf() {
    this._excludeSelf = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get excludeSelfInput() {
    return this._excludeSelf;
  }

  // extra_http_headers - computed: false, optional: true, required: false
  private _extraHttpHeaders = new PackDestinationOutputSplunkHecExtraHttpHeadersList(this, "extra_http_headers", false);
  public get extraHttpHeaders() {
    return this._extraHttpHeaders;
  }
  public putExtraHttpHeaders(value: PackDestinationOutputSplunkHecExtraHttpHeaders[] | cdktf.IResolvable) {
    this._extraHttpHeaders.internalValue = value;
  }
  public resetExtraHttpHeaders() {
    this._extraHttpHeaders.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get extraHttpHeadersInput() {
    return this._extraHttpHeaders.internalValue;
  }

  // failed_request_logging_mode - computed: true, optional: true, required: false
  private _failedRequestLoggingMode?: string; 
  public get failedRequestLoggingMode() {
    return this.getStringAttribute('failed_request_logging_mode');
  }
  public set failedRequestLoggingMode(value: string) {
    this._failedRequestLoggingMode = value;
  }
  public resetFailedRequestLoggingMode() {
    this._failedRequestLoggingMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get failedRequestLoggingModeInput() {
    return this._failedRequestLoggingMode;
  }

  // flush_period_sec - computed: true, optional: true, required: false
  private _flushPeriodSec?: number; 
  public get flushPeriodSec() {
    return this.getNumberAttribute('flush_period_sec');
  }
  public set flushPeriodSec(value: number) {
    this._flushPeriodSec = value;
  }
  public resetFlushPeriodSec() {
    this._flushPeriodSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get flushPeriodSecInput() {
    return this._flushPeriodSec;
  }

  // id - computed: false, optional: false, required: true
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // load_balance_stats_period_sec - computed: true, optional: true, required: false
  private _loadBalanceStatsPeriodSec?: number; 
  public get loadBalanceStatsPeriodSec() {
    return this.getNumberAttribute('load_balance_stats_period_sec');
  }
  public set loadBalanceStatsPeriodSec(value: number) {
    this._loadBalanceStatsPeriodSec = value;
  }
  public resetLoadBalanceStatsPeriodSec() {
    this._loadBalanceStatsPeriodSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get loadBalanceStatsPeriodSecInput() {
    return this._loadBalanceStatsPeriodSec;
  }

  // load_balanced - computed: true, optional: true, required: false
  private _loadBalanced?: boolean | cdktf.IResolvable; 
  public get loadBalanced() {
    return this.getBooleanAttribute('load_balanced');
  }
  public set loadBalanced(value: boolean | cdktf.IResolvable) {
    this._loadBalanced = value;
  }
  public resetLoadBalanced() {
    this._loadBalanced = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get loadBalancedInput() {
    return this._loadBalanced;
  }

  // max_payload_events - computed: true, optional: true, required: false
  private _maxPayloadEvents?: number; 
  public get maxPayloadEvents() {
    return this.getNumberAttribute('max_payload_events');
  }
  public set maxPayloadEvents(value: number) {
    this._maxPayloadEvents = value;
  }
  public resetMaxPayloadEvents() {
    this._maxPayloadEvents = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxPayloadEventsInput() {
    return this._maxPayloadEvents;
  }

  // max_payload_size_kb - computed: true, optional: true, required: false
  private _maxPayloadSizeKb?: number; 
  public get maxPayloadSizeKb() {
    return this.getNumberAttribute('max_payload_size_kb');
  }
  public set maxPayloadSizeKb(value: number) {
    this._maxPayloadSizeKb = value;
  }
  public resetMaxPayloadSizeKb() {
    this._maxPayloadSizeKb = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxPayloadSizeKbInput() {
    return this._maxPayloadSizeKb;
  }

  // next_queue - computed: true, optional: true, required: false
  private _nextQueue?: string; 
  public get nextQueue() {
    return this.getStringAttribute('next_queue');
  }
  public set nextQueue(value: string) {
    this._nextQueue = value;
  }
  public resetNextQueue() {
    this._nextQueue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nextQueueInput() {
    return this._nextQueue;
  }

  // on_backpressure - computed: true, optional: true, required: false
  private _onBackpressure?: string; 
  public get onBackpressure() {
    return this.getStringAttribute('on_backpressure');
  }
  public set onBackpressure(value: string) {
    this._onBackpressure = value;
  }
  public resetOnBackpressure() {
    this._onBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get onBackpressureInput() {
    return this._onBackpressure;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // pq_compress - computed: true, optional: true, required: false
  private _pqCompress?: string; 
  public get pqCompress() {
    return this.getStringAttribute('pq_compress');
  }
  public set pqCompress(value: string) {
    this._pqCompress = value;
  }
  public resetPqCompress() {
    this._pqCompress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqCompressInput() {
    return this._pqCompress;
  }

  // pq_controls - computed: false, optional: true, required: false
  private _pqControls = new PackDestinationOutputSplunkHecPqControlsOutputReference(this, "pq_controls");
  public get pqControls() {
    return this._pqControls;
  }
  public putPqControls(value: PackDestinationOutputSplunkHecPqControls) {
    this._pqControls.internalValue = value;
  }
  public resetPqControls() {
    this._pqControls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqControlsInput() {
    return this._pqControls.internalValue;
  }

  // pq_max_file_size - computed: true, optional: true, required: false
  private _pqMaxFileSize?: string; 
  public get pqMaxFileSize() {
    return this.getStringAttribute('pq_max_file_size');
  }
  public set pqMaxFileSize(value: string) {
    this._pqMaxFileSize = value;
  }
  public resetPqMaxFileSize() {
    this._pqMaxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxFileSizeInput() {
    return this._pqMaxFileSize;
  }

  // pq_max_size - computed: true, optional: true, required: false
  private _pqMaxSize?: string; 
  public get pqMaxSize() {
    return this.getStringAttribute('pq_max_size');
  }
  public set pqMaxSize(value: string) {
    this._pqMaxSize = value;
  }
  public resetPqMaxSize() {
    this._pqMaxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxSizeInput() {
    return this._pqMaxSize;
  }

  // pq_mode - computed: true, optional: true, required: false
  private _pqMode?: string; 
  public get pqMode() {
    return this.getStringAttribute('pq_mode');
  }
  public set pqMode(value: string) {
    this._pqMode = value;
  }
  public resetPqMode() {
    this._pqMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqModeInput() {
    return this._pqMode;
  }

  // pq_on_backpressure - computed: true, optional: true, required: false
  private _pqOnBackpressure?: string; 
  public get pqOnBackpressure() {
    return this.getStringAttribute('pq_on_backpressure');
  }
  public set pqOnBackpressure(value: string) {
    this._pqOnBackpressure = value;
  }
  public resetPqOnBackpressure() {
    this._pqOnBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqOnBackpressureInput() {
    return this._pqOnBackpressure;
  }

  // pq_path - computed: true, optional: true, required: false
  private _pqPath?: string; 
  public get pqPath() {
    return this.getStringAttribute('pq_path');
  }
  public set pqPath(value: string) {
    this._pqPath = value;
  }
  public resetPqPath() {
    this._pqPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqPathInput() {
    return this._pqPath;
  }

  // reject_unauthorized - computed: true, optional: true, required: false
  private _rejectUnauthorized?: boolean | cdktf.IResolvable; 
  public get rejectUnauthorized() {
    return this.getBooleanAttribute('reject_unauthorized');
  }
  public set rejectUnauthorized(value: boolean | cdktf.IResolvable) {
    this._rejectUnauthorized = value;
  }
  public resetRejectUnauthorized() {
    this._rejectUnauthorized = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectUnauthorizedInput() {
    return this._rejectUnauthorized;
  }

  // response_honor_retry_after_header - computed: true, optional: true, required: false
  private _responseHonorRetryAfterHeader?: boolean | cdktf.IResolvable; 
  public get responseHonorRetryAfterHeader() {
    return this.getBooleanAttribute('response_honor_retry_after_header');
  }
  public set responseHonorRetryAfterHeader(value: boolean | cdktf.IResolvable) {
    this._responseHonorRetryAfterHeader = value;
  }
  public resetResponseHonorRetryAfterHeader() {
    this._responseHonorRetryAfterHeader = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get responseHonorRetryAfterHeaderInput() {
    return this._responseHonorRetryAfterHeader;
  }

  // response_retry_settings - computed: false, optional: true, required: false
  private _responseRetrySettings = new PackDestinationOutputSplunkHecResponseRetrySettingsList(this, "response_retry_settings", false);
  public get responseRetrySettings() {
    return this._responseRetrySettings;
  }
  public putResponseRetrySettings(value: PackDestinationOutputSplunkHecResponseRetrySettings[] | cdktf.IResolvable) {
    this._responseRetrySettings.internalValue = value;
  }
  public resetResponseRetrySettings() {
    this._responseRetrySettings.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get responseRetrySettingsInput() {
    return this._responseRetrySettings.internalValue;
  }

  // safe_headers - computed: true, optional: true, required: false
  private _safeHeaders?: string[]; 
  public get safeHeaders() {
    return this.getListAttribute('safe_headers');
  }
  public set safeHeaders(value: string[]) {
    this._safeHeaders = value;
  }
  public resetSafeHeaders() {
    this._safeHeaders = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get safeHeadersInput() {
    return this._safeHeaders;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // system_fields - computed: true, optional: true, required: false
  private _systemFields?: string[]; 
  public get systemFields() {
    return this.getListAttribute('system_fields');
  }
  public set systemFields(value: string[]) {
    this._systemFields = value;
  }
  public resetSystemFields() {
    this._systemFields = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get systemFieldsInput() {
    return this._systemFields;
  }

  // tcp_routing - computed: true, optional: true, required: false
  private _tcpRouting?: string; 
  public get tcpRouting() {
    return this.getStringAttribute('tcp_routing');
  }
  public set tcpRouting(value: string) {
    this._tcpRouting = value;
  }
  public resetTcpRouting() {
    this._tcpRouting = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tcpRoutingInput() {
    return this._tcpRouting;
  }

  // text_secret - computed: false, optional: true, required: false
  private _textSecret?: string; 
  public get textSecret() {
    return this.getStringAttribute('text_secret');
  }
  public set textSecret(value: string) {
    this._textSecret = value;
  }
  public resetTextSecret() {
    this._textSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get textSecretInput() {
    return this._textSecret;
  }

  // timeout_retry_settings - computed: false, optional: true, required: false
  private _timeoutRetrySettings = new PackDestinationOutputSplunkHecTimeoutRetrySettingsOutputReference(this, "timeout_retry_settings");
  public get timeoutRetrySettings() {
    return this._timeoutRetrySettings;
  }
  public putTimeoutRetrySettings(value: PackDestinationOutputSplunkHecTimeoutRetrySettings) {
    this._timeoutRetrySettings.internalValue = value;
  }
  public resetTimeoutRetrySettings() {
    this._timeoutRetrySettings.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutRetrySettingsInput() {
    return this._timeoutRetrySettings.internalValue;
  }

  // timeout_sec - computed: true, optional: true, required: false
  private _timeoutSec?: number; 
  public get timeoutSec() {
    return this.getNumberAttribute('timeout_sec');
  }
  public set timeoutSec(value: number) {
    this._timeoutSec = value;
  }
  public resetTimeoutSec() {
    this._timeoutSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutSecInput() {
    return this._timeoutSec;
  }

  // token - computed: false, optional: true, required: false
  private _token?: string; 
  public get token() {
    return this.getStringAttribute('token');
  }
  public set token(value: string) {
    this._token = value;
  }
  public resetToken() {
    this._token = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tokenInput() {
    return this._token;
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // url - computed: true, optional: true, required: false
  private _url?: string; 
  public get url() {
    return this.getStringAttribute('url');
  }
  public set url(value: string) {
    this._url = value;
  }
  public resetUrl() {
    this._url = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get urlInput() {
    return this._url;
  }

  // urls - computed: false, optional: true, required: false
  private _urls = new PackDestinationOutputSplunkHecUrlsList(this, "urls", false);
  public get urls() {
    return this._urls;
  }
  public putUrls(value: PackDestinationOutputSplunkHecUrls[] | cdktf.IResolvable) {
    this._urls.internalValue = value;
  }
  public resetUrls() {
    this._urls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get urlsInput() {
    return this._urls.internalValue;
  }

  // use_round_robin_dns - computed: true, optional: true, required: false
  private _useRoundRobinDns?: boolean | cdktf.IResolvable; 
  public get useRoundRobinDns() {
    return this.getBooleanAttribute('use_round_robin_dns');
  }
  public set useRoundRobinDns(value: boolean | cdktf.IResolvable) {
    this._useRoundRobinDns = value;
  }
  public resetUseRoundRobinDns() {
    this._useRoundRobinDns = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get useRoundRobinDnsInput() {
    return this._useRoundRobinDns;
  }
}
export interface PackDestinationOutputSplunkLbHosts {
  /**
  * The hostname of the receiver
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#host PackDestination#host}
  */
  readonly host: string;
  /**
  * The port to connect to on the provided host. Default: 9997
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#port PackDestination#port}
  */
  readonly port?: number;
  /**
  * Servername to use if establishing a TLS connection. If not specified, defaults to connection host (if not an IP); otherwise, uses the global TLS settings.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#servername PackDestination#servername}
  */
  readonly servername?: string;
  /**
  * Whether to inherit TLS configs from group setting or disable TLS. Default: "inherit"; must be one of ["inherit", "off"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#tls PackDestination#tls}
  */
  readonly tls?: string;
  /**
  * Assign a weight (>0) to each endpoint to indicate its traffic-handling capability. Default: 1
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#weight PackDestination#weight}
  */
  readonly weight?: number;
}

export function packDestinationOutputSplunkLbHostsToTerraform(struct?: PackDestinationOutputSplunkLbHosts | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    host: cdktf.stringToTerraform(struct!.host),
    port: cdktf.numberToTerraform(struct!.port),
    servername: cdktf.stringToTerraform(struct!.servername),
    tls: cdktf.stringToTerraform(struct!.tls),
    weight: cdktf.numberToTerraform(struct!.weight),
  }
}


export function packDestinationOutputSplunkLbHostsToHclTerraform(struct?: PackDestinationOutputSplunkLbHosts | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    host: {
      value: cdktf.stringToHclTerraform(struct!.host),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    servername: {
      value: cdktf.stringToHclTerraform(struct!.servername),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tls: {
      value: cdktf.stringToHclTerraform(struct!.tls),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    weight: {
      value: cdktf.numberToHclTerraform(struct!.weight),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputSplunkLbHostsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackDestinationOutputSplunkLbHosts | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._host !== undefined) {
      hasAnyValues = true;
      internalValueResult.host = this._host;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._servername !== undefined) {
      hasAnyValues = true;
      internalValueResult.servername = this._servername;
    }
    if (this._tls !== undefined) {
      hasAnyValues = true;
      internalValueResult.tls = this._tls;
    }
    if (this._weight !== undefined) {
      hasAnyValues = true;
      internalValueResult.weight = this._weight;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputSplunkLbHosts | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._host = undefined;
      this._port = undefined;
      this._servername = undefined;
      this._tls = undefined;
      this._weight = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._host = value.host;
      this._port = value.port;
      this._servername = value.servername;
      this._tls = value.tls;
      this._weight = value.weight;
    }
  }

  // host - computed: false, optional: false, required: true
  private _host?: string; 
  public get host() {
    return this.getStringAttribute('host');
  }
  public set host(value: string) {
    this._host = value;
  }
  // Temporarily expose input value. Use with caution.
  public get hostInput() {
    return this._host;
  }

  // port - computed: true, optional: true, required: false
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // servername - computed: false, optional: true, required: false
  private _servername?: string; 
  public get servername() {
    return this.getStringAttribute('servername');
  }
  public set servername(value: string) {
    this._servername = value;
  }
  public resetServername() {
    this._servername = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get servernameInput() {
    return this._servername;
  }

  // tls - computed: true, optional: true, required: false
  private _tls?: string; 
  public get tls() {
    return this.getStringAttribute('tls');
  }
  public set tls(value: string) {
    this._tls = value;
  }
  public resetTls() {
    this._tls = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsInput() {
    return this._tls;
  }

  // weight - computed: true, optional: true, required: false
  private _weight?: number; 
  public get weight() {
    return this.getNumberAttribute('weight');
  }
  public set weight(value: number) {
    this._weight = value;
  }
  public resetWeight() {
    this._weight = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get weightInput() {
    return this._weight;
  }
}

export class PackDestinationOutputSplunkLbHostsList extends cdktf.ComplexList {
  public internalValue? : PackDestinationOutputSplunkLbHosts[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackDestinationOutputSplunkLbHostsOutputReference {
    return new PackDestinationOutputSplunkLbHostsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackDestinationOutputSplunkLbIndexerDiscoveryConfigsAuthTokens {
  /**
  * Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate. Default: "manual"; must be one of ["manual", "secret"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#auth_type PackDestination#auth_type}
  */
  readonly authType?: string;
}

export function packDestinationOutputSplunkLbIndexerDiscoveryConfigsAuthTokensToTerraform(struct?: PackDestinationOutputSplunkLbIndexerDiscoveryConfigsAuthTokens | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    auth_type: cdktf.stringToTerraform(struct!.authType),
  }
}


export function packDestinationOutputSplunkLbIndexerDiscoveryConfigsAuthTokensToHclTerraform(struct?: PackDestinationOutputSplunkLbIndexerDiscoveryConfigsAuthTokens | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    auth_type: {
      value: cdktf.stringToHclTerraform(struct!.authType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputSplunkLbIndexerDiscoveryConfigsAuthTokensOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackDestinationOutputSplunkLbIndexerDiscoveryConfigsAuthTokens | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._authType !== undefined) {
      hasAnyValues = true;
      internalValueResult.authType = this._authType;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputSplunkLbIndexerDiscoveryConfigsAuthTokens | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._authType = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._authType = value.authType;
    }
  }

  // auth_type - computed: true, optional: true, required: false
  private _authType?: string; 
  public get authType() {
    return this.getStringAttribute('auth_type');
  }
  public set authType(value: string) {
    this._authType = value;
  }
  public resetAuthType() {
    this._authType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authTypeInput() {
    return this._authType;
  }
}

export class PackDestinationOutputSplunkLbIndexerDiscoveryConfigsAuthTokensList extends cdktf.ComplexList {
  public internalValue? : PackDestinationOutputSplunkLbIndexerDiscoveryConfigsAuthTokens[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackDestinationOutputSplunkLbIndexerDiscoveryConfigsAuthTokensOutputReference {
    return new PackDestinationOutputSplunkLbIndexerDiscoveryConfigsAuthTokensOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackDestinationOutputSplunkLbIndexerDiscoveryConfigs {
  /**
  * Shared secret to be provided by any client (in authToken header field). If empty, unauthorized access is permitted. Default: ""
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#auth_token PackDestination#auth_token}
  */
  readonly authToken?: string;
  /**
  * Tokens required to authenticate to cluster manager for indexer discovery
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#auth_tokens PackDestination#auth_tokens}
  */
  readonly authTokens?: PackDestinationOutputSplunkLbIndexerDiscoveryConfigsAuthTokens[] | cdktf.IResolvable;
  /**
  * Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate. Default: "manual"; must be one of ["manual", "secret"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#auth_type PackDestination#auth_type}
  */
  readonly authType?: string;
  /**
  * Full URI of Splunk cluster manager (scheme://host:port). Example: https://managerAddress:8089
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#master_uri PackDestination#master_uri}
  */
  readonly masterUri: string;
  /**
  * Time interval, in seconds, between two consecutive indexer list fetches from cluster manager. Default: 300
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#refresh_interval_sec PackDestination#refresh_interval_sec}
  */
  readonly refreshIntervalSec?: number;
  /**
  * During indexer discovery, reject cluster manager certificates that are not authorized by the system's CA. Disable to allow untrusted (for example, self-signed) certificates. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#reject_unauthorized PackDestination#reject_unauthorized}
  */
  readonly rejectUnauthorized?: boolean | cdktf.IResolvable;
  /**
  * Clustering site of the indexers from where indexers need to be discovered. In case of single site cluster, it defaults to 'default' site. Default: "default"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#site PackDestination#site}
  */
  readonly site?: string;
  /**
  * Select or create a stored text secret
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#text_secret PackDestination#text_secret}
  */
  readonly textSecret?: string;
}

export function packDestinationOutputSplunkLbIndexerDiscoveryConfigsToTerraform(struct?: PackDestinationOutputSplunkLbIndexerDiscoveryConfigs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    auth_token: cdktf.stringToTerraform(struct!.authToken),
    auth_tokens: cdktf.listMapper(packDestinationOutputSplunkLbIndexerDiscoveryConfigsAuthTokensToTerraform, false)(struct!.authTokens),
    auth_type: cdktf.stringToTerraform(struct!.authType),
    master_uri: cdktf.stringToTerraform(struct!.masterUri),
    refresh_interval_sec: cdktf.numberToTerraform(struct!.refreshIntervalSec),
    reject_unauthorized: cdktf.booleanToTerraform(struct!.rejectUnauthorized),
    site: cdktf.stringToTerraform(struct!.site),
    text_secret: cdktf.stringToTerraform(struct!.textSecret),
  }
}


export function packDestinationOutputSplunkLbIndexerDiscoveryConfigsToHclTerraform(struct?: PackDestinationOutputSplunkLbIndexerDiscoveryConfigs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    auth_token: {
      value: cdktf.stringToHclTerraform(struct!.authToken),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    auth_tokens: {
      value: cdktf.listMapperHcl(packDestinationOutputSplunkLbIndexerDiscoveryConfigsAuthTokensToHclTerraform, false)(struct!.authTokens),
      isBlock: true,
      type: "list",
      storageClassType: "PackDestinationOutputSplunkLbIndexerDiscoveryConfigsAuthTokensList",
    },
    auth_type: {
      value: cdktf.stringToHclTerraform(struct!.authType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    master_uri: {
      value: cdktf.stringToHclTerraform(struct!.masterUri),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    refresh_interval_sec: {
      value: cdktf.numberToHclTerraform(struct!.refreshIntervalSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    reject_unauthorized: {
      value: cdktf.booleanToHclTerraform(struct!.rejectUnauthorized),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    site: {
      value: cdktf.stringToHclTerraform(struct!.site),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    text_secret: {
      value: cdktf.stringToHclTerraform(struct!.textSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputSplunkLbIndexerDiscoveryConfigsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackDestinationOutputSplunkLbIndexerDiscoveryConfigs | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._authToken !== undefined) {
      hasAnyValues = true;
      internalValueResult.authToken = this._authToken;
    }
    if (this._authTokens?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.authTokens = this._authTokens?.internalValue;
    }
    if (this._authType !== undefined) {
      hasAnyValues = true;
      internalValueResult.authType = this._authType;
    }
    if (this._masterUri !== undefined) {
      hasAnyValues = true;
      internalValueResult.masterUri = this._masterUri;
    }
    if (this._refreshIntervalSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.refreshIntervalSec = this._refreshIntervalSec;
    }
    if (this._rejectUnauthorized !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectUnauthorized = this._rejectUnauthorized;
    }
    if (this._site !== undefined) {
      hasAnyValues = true;
      internalValueResult.site = this._site;
    }
    if (this._textSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.textSecret = this._textSecret;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputSplunkLbIndexerDiscoveryConfigs | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._authToken = undefined;
      this._authTokens.internalValue = undefined;
      this._authType = undefined;
      this._masterUri = undefined;
      this._refreshIntervalSec = undefined;
      this._rejectUnauthorized = undefined;
      this._site = undefined;
      this._textSecret = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._authToken = value.authToken;
      this._authTokens.internalValue = value.authTokens;
      this._authType = value.authType;
      this._masterUri = value.masterUri;
      this._refreshIntervalSec = value.refreshIntervalSec;
      this._rejectUnauthorized = value.rejectUnauthorized;
      this._site = value.site;
      this._textSecret = value.textSecret;
    }
  }

  // auth_token - computed: true, optional: true, required: false
  private _authToken?: string; 
  public get authToken() {
    return this.getStringAttribute('auth_token');
  }
  public set authToken(value: string) {
    this._authToken = value;
  }
  public resetAuthToken() {
    this._authToken = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authTokenInput() {
    return this._authToken;
  }

  // auth_tokens - computed: false, optional: true, required: false
  private _authTokens = new PackDestinationOutputSplunkLbIndexerDiscoveryConfigsAuthTokensList(this, "auth_tokens", false);
  public get authTokens() {
    return this._authTokens;
  }
  public putAuthTokens(value: PackDestinationOutputSplunkLbIndexerDiscoveryConfigsAuthTokens[] | cdktf.IResolvable) {
    this._authTokens.internalValue = value;
  }
  public resetAuthTokens() {
    this._authTokens.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authTokensInput() {
    return this._authTokens.internalValue;
  }

  // auth_type - computed: true, optional: true, required: false
  private _authType?: string; 
  public get authType() {
    return this.getStringAttribute('auth_type');
  }
  public set authType(value: string) {
    this._authType = value;
  }
  public resetAuthType() {
    this._authType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authTypeInput() {
    return this._authType;
  }

  // master_uri - computed: false, optional: false, required: true
  private _masterUri?: string; 
  public get masterUri() {
    return this.getStringAttribute('master_uri');
  }
  public set masterUri(value: string) {
    this._masterUri = value;
  }
  // Temporarily expose input value. Use with caution.
  public get masterUriInput() {
    return this._masterUri;
  }

  // refresh_interval_sec - computed: true, optional: true, required: false
  private _refreshIntervalSec?: number; 
  public get refreshIntervalSec() {
    return this.getNumberAttribute('refresh_interval_sec');
  }
  public set refreshIntervalSec(value: number) {
    this._refreshIntervalSec = value;
  }
  public resetRefreshIntervalSec() {
    this._refreshIntervalSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get refreshIntervalSecInput() {
    return this._refreshIntervalSec;
  }

  // reject_unauthorized - computed: true, optional: true, required: false
  private _rejectUnauthorized?: boolean | cdktf.IResolvable; 
  public get rejectUnauthorized() {
    return this.getBooleanAttribute('reject_unauthorized');
  }
  public set rejectUnauthorized(value: boolean | cdktf.IResolvable) {
    this._rejectUnauthorized = value;
  }
  public resetRejectUnauthorized() {
    this._rejectUnauthorized = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectUnauthorizedInput() {
    return this._rejectUnauthorized;
  }

  // site - computed: true, optional: true, required: false
  private _site?: string; 
  public get site() {
    return this.getStringAttribute('site');
  }
  public set site(value: string) {
    this._site = value;
  }
  public resetSite() {
    this._site = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get siteInput() {
    return this._site;
  }

  // text_secret - computed: false, optional: true, required: false
  private _textSecret?: string; 
  public get textSecret() {
    return this.getStringAttribute('text_secret');
  }
  public set textSecret(value: string) {
    this._textSecret = value;
  }
  public resetTextSecret() {
    this._textSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get textSecretInput() {
    return this._textSecret;
  }
}
export interface PackDestinationOutputSplunkLbPqControls {
}

export function packDestinationOutputSplunkLbPqControlsToTerraform(struct?: PackDestinationOutputSplunkLbPqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function packDestinationOutputSplunkLbPqControlsToHclTerraform(struct?: PackDestinationOutputSplunkLbPqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class PackDestinationOutputSplunkLbPqControlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackDestinationOutputSplunkLbPqControls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputSplunkLbPqControls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface PackDestinationOutputSplunkLbTls {
  /**
  * Path on client in which to find CA certificates to verify the server's cert. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#ca_path PackDestination#ca_path}
  */
  readonly caPath?: string;
  /**
  * Path on client in which to find certificates to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#cert_path PackDestination#cert_path}
  */
  readonly certPath?: string;
  /**
  * The name of the predefined certificate
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#certificate_name PackDestination#certificate_name}
  */
  readonly certificateName?: string;
  /**
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#disabled PackDestination#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_version PackDestination#max_version}
  */
  readonly maxVersion?: string;
  /**
  * must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#min_version PackDestination#min_version}
  */
  readonly minVersion?: string;
  /**
  * Passphrase to use to decrypt private key
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#passphrase PackDestination#passphrase}
  */
  readonly passphrase?: string;
  /**
  * Path on client in which to find the private key to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#priv_key_path PackDestination#priv_key_path}
  */
  readonly privKeyPath?: string;
  /**
  * Reject certificates that are not authorized by a CA in the CA certificate path, or by another
  * 
  * 
  *                     trusted CA (such as the system's). Defaults to Enabled. Overrides the toggle from Advanced Settings, when also present.
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#reject_unauthorized PackDestination#reject_unauthorized}
  */
  readonly rejectUnauthorized?: boolean | cdktf.IResolvable;
  /**
  * Server name for the SNI (Server Name Indication) TLS extension. It must be a host name, and not an IP address.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#servername PackDestination#servername}
  */
  readonly servername?: string;
}

export function packDestinationOutputSplunkLbTlsToTerraform(struct?: PackDestinationOutputSplunkLbTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ca_path: cdktf.stringToTerraform(struct!.caPath),
    cert_path: cdktf.stringToTerraform(struct!.certPath),
    certificate_name: cdktf.stringToTerraform(struct!.certificateName),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    max_version: cdktf.stringToTerraform(struct!.maxVersion),
    min_version: cdktf.stringToTerraform(struct!.minVersion),
    passphrase: cdktf.stringToTerraform(struct!.passphrase),
    priv_key_path: cdktf.stringToTerraform(struct!.privKeyPath),
    reject_unauthorized: cdktf.booleanToTerraform(struct!.rejectUnauthorized),
    servername: cdktf.stringToTerraform(struct!.servername),
  }
}


export function packDestinationOutputSplunkLbTlsToHclTerraform(struct?: PackDestinationOutputSplunkLbTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ca_path: {
      value: cdktf.stringToHclTerraform(struct!.caPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    cert_path: {
      value: cdktf.stringToHclTerraform(struct!.certPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    certificate_name: {
      value: cdktf.stringToHclTerraform(struct!.certificateName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    max_version: {
      value: cdktf.stringToHclTerraform(struct!.maxVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    min_version: {
      value: cdktf.stringToHclTerraform(struct!.minVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    passphrase: {
      value: cdktf.stringToHclTerraform(struct!.passphrase),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    priv_key_path: {
      value: cdktf.stringToHclTerraform(struct!.privKeyPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reject_unauthorized: {
      value: cdktf.booleanToHclTerraform(struct!.rejectUnauthorized),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    servername: {
      value: cdktf.stringToHclTerraform(struct!.servername),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputSplunkLbTlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackDestinationOutputSplunkLbTls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._caPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.caPath = this._caPath;
    }
    if (this._certPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.certPath = this._certPath;
    }
    if (this._certificateName !== undefined) {
      hasAnyValues = true;
      internalValueResult.certificateName = this._certificateName;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._maxVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxVersion = this._maxVersion;
    }
    if (this._minVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.minVersion = this._minVersion;
    }
    if (this._passphrase !== undefined) {
      hasAnyValues = true;
      internalValueResult.passphrase = this._passphrase;
    }
    if (this._privKeyPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.privKeyPath = this._privKeyPath;
    }
    if (this._rejectUnauthorized !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectUnauthorized = this._rejectUnauthorized;
    }
    if (this._servername !== undefined) {
      hasAnyValues = true;
      internalValueResult.servername = this._servername;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputSplunkLbTls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._caPath = undefined;
      this._certPath = undefined;
      this._certificateName = undefined;
      this._disabled = undefined;
      this._maxVersion = undefined;
      this._minVersion = undefined;
      this._passphrase = undefined;
      this._privKeyPath = undefined;
      this._rejectUnauthorized = undefined;
      this._servername = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._caPath = value.caPath;
      this._certPath = value.certPath;
      this._certificateName = value.certificateName;
      this._disabled = value.disabled;
      this._maxVersion = value.maxVersion;
      this._minVersion = value.minVersion;
      this._passphrase = value.passphrase;
      this._privKeyPath = value.privKeyPath;
      this._rejectUnauthorized = value.rejectUnauthorized;
      this._servername = value.servername;
    }
  }

  // ca_path - computed: false, optional: true, required: false
  private _caPath?: string; 
  public get caPath() {
    return this.getStringAttribute('ca_path');
  }
  public set caPath(value: string) {
    this._caPath = value;
  }
  public resetCaPath() {
    this._caPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get caPathInput() {
    return this._caPath;
  }

  // cert_path - computed: false, optional: true, required: false
  private _certPath?: string; 
  public get certPath() {
    return this.getStringAttribute('cert_path');
  }
  public set certPath(value: string) {
    this._certPath = value;
  }
  public resetCertPath() {
    this._certPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certPathInput() {
    return this._certPath;
  }

  // certificate_name - computed: false, optional: true, required: false
  private _certificateName?: string; 
  public get certificateName() {
    return this.getStringAttribute('certificate_name');
  }
  public set certificateName(value: string) {
    this._certificateName = value;
  }
  public resetCertificateName() {
    this._certificateName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certificateNameInput() {
    return this._certificateName;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // max_version - computed: false, optional: true, required: false
  private _maxVersion?: string; 
  public get maxVersion() {
    return this.getStringAttribute('max_version');
  }
  public set maxVersion(value: string) {
    this._maxVersion = value;
  }
  public resetMaxVersion() {
    this._maxVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxVersionInput() {
    return this._maxVersion;
  }

  // min_version - computed: false, optional: true, required: false
  private _minVersion?: string; 
  public get minVersion() {
    return this.getStringAttribute('min_version');
  }
  public set minVersion(value: string) {
    this._minVersion = value;
  }
  public resetMinVersion() {
    this._minVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get minVersionInput() {
    return this._minVersion;
  }

  // passphrase - computed: false, optional: true, required: false
  private _passphrase?: string; 
  public get passphrase() {
    return this.getStringAttribute('passphrase');
  }
  public set passphrase(value: string) {
    this._passphrase = value;
  }
  public resetPassphrase() {
    this._passphrase = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passphraseInput() {
    return this._passphrase;
  }

  // priv_key_path - computed: false, optional: true, required: false
  private _privKeyPath?: string; 
  public get privKeyPath() {
    return this.getStringAttribute('priv_key_path');
  }
  public set privKeyPath(value: string) {
    this._privKeyPath = value;
  }
  public resetPrivKeyPath() {
    this._privKeyPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get privKeyPathInput() {
    return this._privKeyPath;
  }

  // reject_unauthorized - computed: true, optional: true, required: false
  private _rejectUnauthorized?: boolean | cdktf.IResolvable; 
  public get rejectUnauthorized() {
    return this.getBooleanAttribute('reject_unauthorized');
  }
  public set rejectUnauthorized(value: boolean | cdktf.IResolvable) {
    this._rejectUnauthorized = value;
  }
  public resetRejectUnauthorized() {
    this._rejectUnauthorized = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectUnauthorizedInput() {
    return this._rejectUnauthorized;
  }

  // servername - computed: false, optional: true, required: false
  private _servername?: string; 
  public get servername() {
    return this.getStringAttribute('servername');
  }
  public set servername(value: string) {
    this._servername = value;
  }
  public resetServername() {
    this._servername = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get servernameInput() {
    return this._servername;
  }
}
export interface PackDestinationOutputSplunkLb {
  /**
  * Shared secret token to use when establishing a connection to a Splunk indexer. Default: ""
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#auth_token PackDestination#auth_token}
  */
  readonly authToken?: string;
  /**
  * Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate. Default: "manual"; must be one of ["manual", "secret"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#auth_type PackDestination#auth_type}
  */
  readonly authType?: string;
  /**
  * Controls whether the sender should send compressed data to the server. Select 'Disabled' to reject compressed connections or 'Always' to ignore server's configuration and send compressed data. Default: "disabled"; must be one of ["disabled", "auto", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#compress PackDestination#compress}
  */
  readonly compress?: string;
  /**
  * Amount of time (milliseconds) to wait for the connection to establish before retrying. Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#connection_timeout PackDestination#connection_timeout}
  */
  readonly connectionTimeout?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#description PackDestination#description}
  */
  readonly description?: string;
  /**
  * The interval in which to re-resolve any hostnames and pick up destinations from A records. Default: 600
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#dns_resolve_period_sec PackDestination#dns_resolve_period_sec}
  */
  readonly dnsResolvePeriodSec?: number;
  /**
  * Check if indexer is shutting down and stop sending data. This helps minimize data loss during shutdown. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#enable_ack PackDestination#enable_ack}
  */
  readonly enableAck?: boolean | cdktf.IResolvable;
  /**
  * Output metrics in multiple-metric format in a single event. Supported in Splunk 8.0 and above. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#enable_multi_metrics PackDestination#enable_multi_metrics}
  */
  readonly enableMultiMetrics?: boolean | cdktf.IResolvable;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#environment PackDestination#environment}
  */
  readonly environment?: string;
  /**
  * Exclude all IPs of the current host from the list of any resolved hostnames. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#exclude_self PackDestination#exclude_self}
  */
  readonly excludeSelf?: boolean | cdktf.IResolvable;
  /**
  * Set of Splunk indexers to load-balance data to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#hosts PackDestination#hosts}
  */
  readonly hosts: PackDestinationOutputSplunkLbHosts[] | cdktf.IResolvable;
  /**
  * Unique ID for this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#id PackDestination#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * Automatically discover indexers in indexer clustering environment. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#indexer_discovery PackDestination#indexer_discovery}
  */
  readonly indexerDiscovery?: boolean | cdktf.IResolvable;
  /**
  * List of configurations to set up indexer discovery in Splunk Indexer clustering environment.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#indexer_discovery_configs PackDestination#indexer_discovery_configs}
  */
  readonly indexerDiscoveryConfigs?: PackDestinationOutputSplunkLbIndexerDiscoveryConfigs;
  /**
  * How far back in time to keep traffic stats for load balancing purposes. Default: 300
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#load_balance_stats_period_sec PackDestination#load_balance_stats_period_sec}
  */
  readonly loadBalanceStatsPeriodSec?: number;
  /**
  * Use to troubleshoot issues with sending data. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#log_failed_requests PackDestination#log_failed_requests}
  */
  readonly logFailedRequests?: boolean | cdktf.IResolvable;
  /**
  * Maximum number of concurrent connections (per Worker Process). A random set of IPs will be picked on every DNS resolution period. Use 0 for unlimited. Default: 0
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_concurrent_senders PackDestination#max_concurrent_senders}
  */
  readonly maxConcurrentSenders?: number;
  /**
  * Maximum number of times healthcheck can fail before we close connection. If set to 0 (disabled), and the connection to Splunk is forcibly closed, some data loss might occur. Default: 1
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_failed_health_checks PackDestination#max_failed_health_checks}
  */
  readonly maxFailedHealthChecks?: number;
  /**
  * The highest S2S protocol version to advertise during handshake. Default: "v3"; must be one of ["v3", "v4"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_s2_sversion PackDestination#max_s2_sversion}
  */
  readonly maxS2Sversion?: string;
  /**
  * How to serialize nested fields into index-time fields. Default: "none"; must be one of ["json", "none"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#nested_fields PackDestination#nested_fields}
  */
  readonly nestedFields?: string;
  /**
  * How to handle events when all receivers are exerting backpressure. Default: "block"; must be one of ["block", "drop", "queue"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#on_backpressure PackDestination#on_backpressure}
  */
  readonly onBackpressure?: string;
  /**
  * Pipeline to process data before sending out to this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pipeline PackDestination#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_compress PackDestination#pq_compress}
  */
  readonly pqCompress?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_controls PackDestination#pq_controls}
  */
  readonly pqControls?: PackDestinationOutputSplunkLbPqControls;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.). Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_max_file_size PackDestination#pq_max_file_size}
  */
  readonly pqMaxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_max_size PackDestination#pq_max_size}
  */
  readonly pqMaxSize?: string;
  /**
  * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem. Default: "error"; must be one of ["error", "backpressure", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_mode PackDestination#pq_mode}
  */
  readonly pqMode?: string;
  /**
  * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged. Default: "block"; must be one of ["block", "drop"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_on_backpressure PackDestination#pq_on_backpressure}
  */
  readonly pqOnBackpressure?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_path PackDestination#pq_path}
  */
  readonly pqPath?: string;
  /**
  * How long (in milliseconds) each LB endpoint can report blocked before the Destination reports unhealthy, blocking the sender. (Grace period for fluctuations.) Use 0 to disable; max 1 minute. Default: 100
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#sender_unhealthy_time_allowance PackDestination#sender_unhealthy_time_allowance}
  */
  readonly senderUnhealthyTimeAllowance?: number;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#streamtags PackDestination#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Fields to automatically add to events, such as cribl_pipe. Supports wildcards. Default: ["cribl_pipe"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#system_fields PackDestination#system_fields}
  */
  readonly systemFields?: string[];
  /**
  * Select or create a stored text secret
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#text_secret PackDestination#text_secret}
  */
  readonly textSecret?: string;
  /**
  * Rate (in bytes per second) to throttle while writing to an output. Accepts values with multiple-byte units, such as KB, MB, and GB. (Example: 42 MB) Default value of 0 specifies no throttling. Default: "0"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#throttle_rate_per_sec PackDestination#throttle_rate_per_sec}
  */
  readonly throttleRatePerSec?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#tls PackDestination#tls}
  */
  readonly tls?: PackDestinationOutputSplunkLbTls;
  /**
  * must be "splunk_lb"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#type PackDestination#type}
  */
  readonly type: string;
  /**
  * Amount of time (milliseconds) to wait for a write to complete before assuming connection is dead. Default: 60000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#write_timeout PackDestination#write_timeout}
  */
  readonly writeTimeout?: number;
}

export function packDestinationOutputSplunkLbToTerraform(struct?: PackDestinationOutputSplunkLb | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    auth_token: cdktf.stringToTerraform(struct!.authToken),
    auth_type: cdktf.stringToTerraform(struct!.authType),
    compress: cdktf.stringToTerraform(struct!.compress),
    connection_timeout: cdktf.numberToTerraform(struct!.connectionTimeout),
    description: cdktf.stringToTerraform(struct!.description),
    dns_resolve_period_sec: cdktf.numberToTerraform(struct!.dnsResolvePeriodSec),
    enable_ack: cdktf.booleanToTerraform(struct!.enableAck),
    enable_multi_metrics: cdktf.booleanToTerraform(struct!.enableMultiMetrics),
    environment: cdktf.stringToTerraform(struct!.environment),
    exclude_self: cdktf.booleanToTerraform(struct!.excludeSelf),
    hosts: cdktf.listMapper(packDestinationOutputSplunkLbHostsToTerraform, false)(struct!.hosts),
    id: cdktf.stringToTerraform(struct!.id),
    indexer_discovery: cdktf.booleanToTerraform(struct!.indexerDiscovery),
    indexer_discovery_configs: packDestinationOutputSplunkLbIndexerDiscoveryConfigsToTerraform(struct!.indexerDiscoveryConfigs),
    load_balance_stats_period_sec: cdktf.numberToTerraform(struct!.loadBalanceStatsPeriodSec),
    log_failed_requests: cdktf.booleanToTerraform(struct!.logFailedRequests),
    max_concurrent_senders: cdktf.numberToTerraform(struct!.maxConcurrentSenders),
    max_failed_health_checks: cdktf.numberToTerraform(struct!.maxFailedHealthChecks),
    max_s2_sversion: cdktf.stringToTerraform(struct!.maxS2Sversion),
    nested_fields: cdktf.stringToTerraform(struct!.nestedFields),
    on_backpressure: cdktf.stringToTerraform(struct!.onBackpressure),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    pq_compress: cdktf.stringToTerraform(struct!.pqCompress),
    pq_controls: packDestinationOutputSplunkLbPqControlsToTerraform(struct!.pqControls),
    pq_max_file_size: cdktf.stringToTerraform(struct!.pqMaxFileSize),
    pq_max_size: cdktf.stringToTerraform(struct!.pqMaxSize),
    pq_mode: cdktf.stringToTerraform(struct!.pqMode),
    pq_on_backpressure: cdktf.stringToTerraform(struct!.pqOnBackpressure),
    pq_path: cdktf.stringToTerraform(struct!.pqPath),
    sender_unhealthy_time_allowance: cdktf.numberToTerraform(struct!.senderUnhealthyTimeAllowance),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    system_fields: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.systemFields),
    text_secret: cdktf.stringToTerraform(struct!.textSecret),
    throttle_rate_per_sec: cdktf.stringToTerraform(struct!.throttleRatePerSec),
    tls: packDestinationOutputSplunkLbTlsToTerraform(struct!.tls),
    type: cdktf.stringToTerraform(struct!.type),
    write_timeout: cdktf.numberToTerraform(struct!.writeTimeout),
  }
}


export function packDestinationOutputSplunkLbToHclTerraform(struct?: PackDestinationOutputSplunkLb | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    auth_token: {
      value: cdktf.stringToHclTerraform(struct!.authToken),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    auth_type: {
      value: cdktf.stringToHclTerraform(struct!.authType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    compress: {
      value: cdktf.stringToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    connection_timeout: {
      value: cdktf.numberToHclTerraform(struct!.connectionTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    dns_resolve_period_sec: {
      value: cdktf.numberToHclTerraform(struct!.dnsResolvePeriodSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    enable_ack: {
      value: cdktf.booleanToHclTerraform(struct!.enableAck),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    enable_multi_metrics: {
      value: cdktf.booleanToHclTerraform(struct!.enableMultiMetrics),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    exclude_self: {
      value: cdktf.booleanToHclTerraform(struct!.excludeSelf),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    hosts: {
      value: cdktf.listMapperHcl(packDestinationOutputSplunkLbHostsToHclTerraform, false)(struct!.hosts),
      isBlock: true,
      type: "list",
      storageClassType: "PackDestinationOutputSplunkLbHostsList",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    indexer_discovery: {
      value: cdktf.booleanToHclTerraform(struct!.indexerDiscovery),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    indexer_discovery_configs: {
      value: packDestinationOutputSplunkLbIndexerDiscoveryConfigsToHclTerraform(struct!.indexerDiscoveryConfigs),
      isBlock: true,
      type: "struct",
      storageClassType: "PackDestinationOutputSplunkLbIndexerDiscoveryConfigs",
    },
    load_balance_stats_period_sec: {
      value: cdktf.numberToHclTerraform(struct!.loadBalanceStatsPeriodSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    log_failed_requests: {
      value: cdktf.booleanToHclTerraform(struct!.logFailedRequests),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    max_concurrent_senders: {
      value: cdktf.numberToHclTerraform(struct!.maxConcurrentSenders),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_failed_health_checks: {
      value: cdktf.numberToHclTerraform(struct!.maxFailedHealthChecks),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_s2_sversion: {
      value: cdktf.stringToHclTerraform(struct!.maxS2Sversion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    nested_fields: {
      value: cdktf.stringToHclTerraform(struct!.nestedFields),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.onBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_compress: {
      value: cdktf.stringToHclTerraform(struct!.pqCompress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_controls: {
      value: packDestinationOutputSplunkLbPqControlsToHclTerraform(struct!.pqControls),
      isBlock: true,
      type: "struct",
      storageClassType: "PackDestinationOutputSplunkLbPqControls",
    },
    pq_max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_max_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_mode: {
      value: cdktf.stringToHclTerraform(struct!.pqMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.pqOnBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_path: {
      value: cdktf.stringToHclTerraform(struct!.pqPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    sender_unhealthy_time_allowance: {
      value: cdktf.numberToHclTerraform(struct!.senderUnhealthyTimeAllowance),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    system_fields: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.systemFields),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    text_secret: {
      value: cdktf.stringToHclTerraform(struct!.textSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    throttle_rate_per_sec: {
      value: cdktf.stringToHclTerraform(struct!.throttleRatePerSec),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tls: {
      value: packDestinationOutputSplunkLbTlsToHclTerraform(struct!.tls),
      isBlock: true,
      type: "struct",
      storageClassType: "PackDestinationOutputSplunkLbTls",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    write_timeout: {
      value: cdktf.numberToHclTerraform(struct!.writeTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputSplunkLbOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackDestinationOutputSplunkLb | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._authToken !== undefined) {
      hasAnyValues = true;
      internalValueResult.authToken = this._authToken;
    }
    if (this._authType !== undefined) {
      hasAnyValues = true;
      internalValueResult.authType = this._authType;
    }
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._connectionTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.connectionTimeout = this._connectionTimeout;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._dnsResolvePeriodSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.dnsResolvePeriodSec = this._dnsResolvePeriodSec;
    }
    if (this._enableAck !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableAck = this._enableAck;
    }
    if (this._enableMultiMetrics !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableMultiMetrics = this._enableMultiMetrics;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._excludeSelf !== undefined) {
      hasAnyValues = true;
      internalValueResult.excludeSelf = this._excludeSelf;
    }
    if (this._hosts?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.hosts = this._hosts?.internalValue;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._indexerDiscovery !== undefined) {
      hasAnyValues = true;
      internalValueResult.indexerDiscovery = this._indexerDiscovery;
    }
    if (this._indexerDiscoveryConfigs?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.indexerDiscoveryConfigs = this._indexerDiscoveryConfigs?.internalValue;
    }
    if (this._loadBalanceStatsPeriodSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.loadBalanceStatsPeriodSec = this._loadBalanceStatsPeriodSec;
    }
    if (this._logFailedRequests !== undefined) {
      hasAnyValues = true;
      internalValueResult.logFailedRequests = this._logFailedRequests;
    }
    if (this._maxConcurrentSenders !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxConcurrentSenders = this._maxConcurrentSenders;
    }
    if (this._maxFailedHealthChecks !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxFailedHealthChecks = this._maxFailedHealthChecks;
    }
    if (this._maxS2Sversion !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxS2Sversion = this._maxS2Sversion;
    }
    if (this._nestedFields !== undefined) {
      hasAnyValues = true;
      internalValueResult.nestedFields = this._nestedFields;
    }
    if (this._onBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.onBackpressure = this._onBackpressure;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._pqCompress !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqCompress = this._pqCompress;
    }
    if (this._pqControls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqControls = this._pqControls?.internalValue;
    }
    if (this._pqMaxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxFileSize = this._pqMaxFileSize;
    }
    if (this._pqMaxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxSize = this._pqMaxSize;
    }
    if (this._pqMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMode = this._pqMode;
    }
    if (this._pqOnBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqOnBackpressure = this._pqOnBackpressure;
    }
    if (this._pqPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqPath = this._pqPath;
    }
    if (this._senderUnhealthyTimeAllowance !== undefined) {
      hasAnyValues = true;
      internalValueResult.senderUnhealthyTimeAllowance = this._senderUnhealthyTimeAllowance;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._systemFields !== undefined) {
      hasAnyValues = true;
      internalValueResult.systemFields = this._systemFields;
    }
    if (this._textSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.textSecret = this._textSecret;
    }
    if (this._throttleRatePerSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.throttleRatePerSec = this._throttleRatePerSec;
    }
    if (this._tls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tls = this._tls?.internalValue;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._writeTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.writeTimeout = this._writeTimeout;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputSplunkLb | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._authToken = undefined;
      this._authType = undefined;
      this._compress = undefined;
      this._connectionTimeout = undefined;
      this._description = undefined;
      this._dnsResolvePeriodSec = undefined;
      this._enableAck = undefined;
      this._enableMultiMetrics = undefined;
      this._environment = undefined;
      this._excludeSelf = undefined;
      this._hosts.internalValue = undefined;
      this._id = undefined;
      this._indexerDiscovery = undefined;
      this._indexerDiscoveryConfigs.internalValue = undefined;
      this._loadBalanceStatsPeriodSec = undefined;
      this._logFailedRequests = undefined;
      this._maxConcurrentSenders = undefined;
      this._maxFailedHealthChecks = undefined;
      this._maxS2Sversion = undefined;
      this._nestedFields = undefined;
      this._onBackpressure = undefined;
      this._pipeline = undefined;
      this._pqCompress = undefined;
      this._pqControls.internalValue = undefined;
      this._pqMaxFileSize = undefined;
      this._pqMaxSize = undefined;
      this._pqMode = undefined;
      this._pqOnBackpressure = undefined;
      this._pqPath = undefined;
      this._senderUnhealthyTimeAllowance = undefined;
      this._streamtags = undefined;
      this._systemFields = undefined;
      this._textSecret = undefined;
      this._throttleRatePerSec = undefined;
      this._tls.internalValue = undefined;
      this._type = undefined;
      this._writeTimeout = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._authToken = value.authToken;
      this._authType = value.authType;
      this._compress = value.compress;
      this._connectionTimeout = value.connectionTimeout;
      this._description = value.description;
      this._dnsResolvePeriodSec = value.dnsResolvePeriodSec;
      this._enableAck = value.enableAck;
      this._enableMultiMetrics = value.enableMultiMetrics;
      this._environment = value.environment;
      this._excludeSelf = value.excludeSelf;
      this._hosts.internalValue = value.hosts;
      this._id = value.id;
      this._indexerDiscovery = value.indexerDiscovery;
      this._indexerDiscoveryConfigs.internalValue = value.indexerDiscoveryConfigs;
      this._loadBalanceStatsPeriodSec = value.loadBalanceStatsPeriodSec;
      this._logFailedRequests = value.logFailedRequests;
      this._maxConcurrentSenders = value.maxConcurrentSenders;
      this._maxFailedHealthChecks = value.maxFailedHealthChecks;
      this._maxS2Sversion = value.maxS2Sversion;
      this._nestedFields = value.nestedFields;
      this._onBackpressure = value.onBackpressure;
      this._pipeline = value.pipeline;
      this._pqCompress = value.pqCompress;
      this._pqControls.internalValue = value.pqControls;
      this._pqMaxFileSize = value.pqMaxFileSize;
      this._pqMaxSize = value.pqMaxSize;
      this._pqMode = value.pqMode;
      this._pqOnBackpressure = value.pqOnBackpressure;
      this._pqPath = value.pqPath;
      this._senderUnhealthyTimeAllowance = value.senderUnhealthyTimeAllowance;
      this._streamtags = value.streamtags;
      this._systemFields = value.systemFields;
      this._textSecret = value.textSecret;
      this._throttleRatePerSec = value.throttleRatePerSec;
      this._tls.internalValue = value.tls;
      this._type = value.type;
      this._writeTimeout = value.writeTimeout;
    }
  }

  // auth_token - computed: true, optional: true, required: false
  private _authToken?: string; 
  public get authToken() {
    return this.getStringAttribute('auth_token');
  }
  public set authToken(value: string) {
    this._authToken = value;
  }
  public resetAuthToken() {
    this._authToken = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authTokenInput() {
    return this._authToken;
  }

  // auth_type - computed: true, optional: true, required: false
  private _authType?: string; 
  public get authType() {
    return this.getStringAttribute('auth_type');
  }
  public set authType(value: string) {
    this._authType = value;
  }
  public resetAuthType() {
    this._authType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authTypeInput() {
    return this._authType;
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: string; 
  public get compress() {
    return this.getStringAttribute('compress');
  }
  public set compress(value: string) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // connection_timeout - computed: true, optional: true, required: false
  private _connectionTimeout?: number; 
  public get connectionTimeout() {
    return this.getNumberAttribute('connection_timeout');
  }
  public set connectionTimeout(value: number) {
    this._connectionTimeout = value;
  }
  public resetConnectionTimeout() {
    this._connectionTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectionTimeoutInput() {
    return this._connectionTimeout;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // dns_resolve_period_sec - computed: true, optional: true, required: false
  private _dnsResolvePeriodSec?: number; 
  public get dnsResolvePeriodSec() {
    return this.getNumberAttribute('dns_resolve_period_sec');
  }
  public set dnsResolvePeriodSec(value: number) {
    this._dnsResolvePeriodSec = value;
  }
  public resetDnsResolvePeriodSec() {
    this._dnsResolvePeriodSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dnsResolvePeriodSecInput() {
    return this._dnsResolvePeriodSec;
  }

  // enable_ack - computed: true, optional: true, required: false
  private _enableAck?: boolean | cdktf.IResolvable; 
  public get enableAck() {
    return this.getBooleanAttribute('enable_ack');
  }
  public set enableAck(value: boolean | cdktf.IResolvable) {
    this._enableAck = value;
  }
  public resetEnableAck() {
    this._enableAck = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableAckInput() {
    return this._enableAck;
  }

  // enable_multi_metrics - computed: true, optional: true, required: false
  private _enableMultiMetrics?: boolean | cdktf.IResolvable; 
  public get enableMultiMetrics() {
    return this.getBooleanAttribute('enable_multi_metrics');
  }
  public set enableMultiMetrics(value: boolean | cdktf.IResolvable) {
    this._enableMultiMetrics = value;
  }
  public resetEnableMultiMetrics() {
    this._enableMultiMetrics = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableMultiMetricsInput() {
    return this._enableMultiMetrics;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // exclude_self - computed: true, optional: true, required: false
  private _excludeSelf?: boolean | cdktf.IResolvable; 
  public get excludeSelf() {
    return this.getBooleanAttribute('exclude_self');
  }
  public set excludeSelf(value: boolean | cdktf.IResolvable) {
    this._excludeSelf = value;
  }
  public resetExcludeSelf() {
    this._excludeSelf = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get excludeSelfInput() {
    return this._excludeSelf;
  }

  // hosts - computed: false, optional: false, required: true
  private _hosts = new PackDestinationOutputSplunkLbHostsList(this, "hosts", false);
  public get hosts() {
    return this._hosts;
  }
  public putHosts(value: PackDestinationOutputSplunkLbHosts[] | cdktf.IResolvable) {
    this._hosts.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get hostsInput() {
    return this._hosts.internalValue;
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // indexer_discovery - computed: true, optional: true, required: false
  private _indexerDiscovery?: boolean | cdktf.IResolvable; 
  public get indexerDiscovery() {
    return this.getBooleanAttribute('indexer_discovery');
  }
  public set indexerDiscovery(value: boolean | cdktf.IResolvable) {
    this._indexerDiscovery = value;
  }
  public resetIndexerDiscovery() {
    this._indexerDiscovery = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get indexerDiscoveryInput() {
    return this._indexerDiscovery;
  }

  // indexer_discovery_configs - computed: false, optional: true, required: false
  private _indexerDiscoveryConfigs = new PackDestinationOutputSplunkLbIndexerDiscoveryConfigsOutputReference(this, "indexer_discovery_configs");
  public get indexerDiscoveryConfigs() {
    return this._indexerDiscoveryConfigs;
  }
  public putIndexerDiscoveryConfigs(value: PackDestinationOutputSplunkLbIndexerDiscoveryConfigs) {
    this._indexerDiscoveryConfigs.internalValue = value;
  }
  public resetIndexerDiscoveryConfigs() {
    this._indexerDiscoveryConfigs.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get indexerDiscoveryConfigsInput() {
    return this._indexerDiscoveryConfigs.internalValue;
  }

  // load_balance_stats_period_sec - computed: true, optional: true, required: false
  private _loadBalanceStatsPeriodSec?: number; 
  public get loadBalanceStatsPeriodSec() {
    return this.getNumberAttribute('load_balance_stats_period_sec');
  }
  public set loadBalanceStatsPeriodSec(value: number) {
    this._loadBalanceStatsPeriodSec = value;
  }
  public resetLoadBalanceStatsPeriodSec() {
    this._loadBalanceStatsPeriodSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get loadBalanceStatsPeriodSecInput() {
    return this._loadBalanceStatsPeriodSec;
  }

  // log_failed_requests - computed: true, optional: true, required: false
  private _logFailedRequests?: boolean | cdktf.IResolvable; 
  public get logFailedRequests() {
    return this.getBooleanAttribute('log_failed_requests');
  }
  public set logFailedRequests(value: boolean | cdktf.IResolvable) {
    this._logFailedRequests = value;
  }
  public resetLogFailedRequests() {
    this._logFailedRequests = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get logFailedRequestsInput() {
    return this._logFailedRequests;
  }

  // max_concurrent_senders - computed: true, optional: true, required: false
  private _maxConcurrentSenders?: number; 
  public get maxConcurrentSenders() {
    return this.getNumberAttribute('max_concurrent_senders');
  }
  public set maxConcurrentSenders(value: number) {
    this._maxConcurrentSenders = value;
  }
  public resetMaxConcurrentSenders() {
    this._maxConcurrentSenders = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxConcurrentSendersInput() {
    return this._maxConcurrentSenders;
  }

  // max_failed_health_checks - computed: true, optional: true, required: false
  private _maxFailedHealthChecks?: number; 
  public get maxFailedHealthChecks() {
    return this.getNumberAttribute('max_failed_health_checks');
  }
  public set maxFailedHealthChecks(value: number) {
    this._maxFailedHealthChecks = value;
  }
  public resetMaxFailedHealthChecks() {
    this._maxFailedHealthChecks = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxFailedHealthChecksInput() {
    return this._maxFailedHealthChecks;
  }

  // max_s2_sversion - computed: true, optional: true, required: false
  private _maxS2Sversion?: string; 
  public get maxS2Sversion() {
    return this.getStringAttribute('max_s2_sversion');
  }
  public set maxS2Sversion(value: string) {
    this._maxS2Sversion = value;
  }
  public resetMaxS2Sversion() {
    this._maxS2Sversion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxS2SversionInput() {
    return this._maxS2Sversion;
  }

  // nested_fields - computed: true, optional: true, required: false
  private _nestedFields?: string; 
  public get nestedFields() {
    return this.getStringAttribute('nested_fields');
  }
  public set nestedFields(value: string) {
    this._nestedFields = value;
  }
  public resetNestedFields() {
    this._nestedFields = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nestedFieldsInput() {
    return this._nestedFields;
  }

  // on_backpressure - computed: true, optional: true, required: false
  private _onBackpressure?: string; 
  public get onBackpressure() {
    return this.getStringAttribute('on_backpressure');
  }
  public set onBackpressure(value: string) {
    this._onBackpressure = value;
  }
  public resetOnBackpressure() {
    this._onBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get onBackpressureInput() {
    return this._onBackpressure;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // pq_compress - computed: true, optional: true, required: false
  private _pqCompress?: string; 
  public get pqCompress() {
    return this.getStringAttribute('pq_compress');
  }
  public set pqCompress(value: string) {
    this._pqCompress = value;
  }
  public resetPqCompress() {
    this._pqCompress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqCompressInput() {
    return this._pqCompress;
  }

  // pq_controls - computed: false, optional: true, required: false
  private _pqControls = new PackDestinationOutputSplunkLbPqControlsOutputReference(this, "pq_controls");
  public get pqControls() {
    return this._pqControls;
  }
  public putPqControls(value: PackDestinationOutputSplunkLbPqControls) {
    this._pqControls.internalValue = value;
  }
  public resetPqControls() {
    this._pqControls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqControlsInput() {
    return this._pqControls.internalValue;
  }

  // pq_max_file_size - computed: true, optional: true, required: false
  private _pqMaxFileSize?: string; 
  public get pqMaxFileSize() {
    return this.getStringAttribute('pq_max_file_size');
  }
  public set pqMaxFileSize(value: string) {
    this._pqMaxFileSize = value;
  }
  public resetPqMaxFileSize() {
    this._pqMaxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxFileSizeInput() {
    return this._pqMaxFileSize;
  }

  // pq_max_size - computed: true, optional: true, required: false
  private _pqMaxSize?: string; 
  public get pqMaxSize() {
    return this.getStringAttribute('pq_max_size');
  }
  public set pqMaxSize(value: string) {
    this._pqMaxSize = value;
  }
  public resetPqMaxSize() {
    this._pqMaxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxSizeInput() {
    return this._pqMaxSize;
  }

  // pq_mode - computed: true, optional: true, required: false
  private _pqMode?: string; 
  public get pqMode() {
    return this.getStringAttribute('pq_mode');
  }
  public set pqMode(value: string) {
    this._pqMode = value;
  }
  public resetPqMode() {
    this._pqMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqModeInput() {
    return this._pqMode;
  }

  // pq_on_backpressure - computed: true, optional: true, required: false
  private _pqOnBackpressure?: string; 
  public get pqOnBackpressure() {
    return this.getStringAttribute('pq_on_backpressure');
  }
  public set pqOnBackpressure(value: string) {
    this._pqOnBackpressure = value;
  }
  public resetPqOnBackpressure() {
    this._pqOnBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqOnBackpressureInput() {
    return this._pqOnBackpressure;
  }

  // pq_path - computed: true, optional: true, required: false
  private _pqPath?: string; 
  public get pqPath() {
    return this.getStringAttribute('pq_path');
  }
  public set pqPath(value: string) {
    this._pqPath = value;
  }
  public resetPqPath() {
    this._pqPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqPathInput() {
    return this._pqPath;
  }

  // sender_unhealthy_time_allowance - computed: true, optional: true, required: false
  private _senderUnhealthyTimeAllowance?: number; 
  public get senderUnhealthyTimeAllowance() {
    return this.getNumberAttribute('sender_unhealthy_time_allowance');
  }
  public set senderUnhealthyTimeAllowance(value: number) {
    this._senderUnhealthyTimeAllowance = value;
  }
  public resetSenderUnhealthyTimeAllowance() {
    this._senderUnhealthyTimeAllowance = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get senderUnhealthyTimeAllowanceInput() {
    return this._senderUnhealthyTimeAllowance;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // system_fields - computed: true, optional: true, required: false
  private _systemFields?: string[]; 
  public get systemFields() {
    return this.getListAttribute('system_fields');
  }
  public set systemFields(value: string[]) {
    this._systemFields = value;
  }
  public resetSystemFields() {
    this._systemFields = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get systemFieldsInput() {
    return this._systemFields;
  }

  // text_secret - computed: false, optional: true, required: false
  private _textSecret?: string; 
  public get textSecret() {
    return this.getStringAttribute('text_secret');
  }
  public set textSecret(value: string) {
    this._textSecret = value;
  }
  public resetTextSecret() {
    this._textSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get textSecretInput() {
    return this._textSecret;
  }

  // throttle_rate_per_sec - computed: true, optional: true, required: false
  private _throttleRatePerSec?: string; 
  public get throttleRatePerSec() {
    return this.getStringAttribute('throttle_rate_per_sec');
  }
  public set throttleRatePerSec(value: string) {
    this._throttleRatePerSec = value;
  }
  public resetThrottleRatePerSec() {
    this._throttleRatePerSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get throttleRatePerSecInput() {
    return this._throttleRatePerSec;
  }

  // tls - computed: false, optional: true, required: false
  private _tls = new PackDestinationOutputSplunkLbTlsOutputReference(this, "tls");
  public get tls() {
    return this._tls;
  }
  public putTls(value: PackDestinationOutputSplunkLbTls) {
    this._tls.internalValue = value;
  }
  public resetTls() {
    this._tls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsInput() {
    return this._tls.internalValue;
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // write_timeout - computed: true, optional: true, required: false
  private _writeTimeout?: number; 
  public get writeTimeout() {
    return this.getNumberAttribute('write_timeout');
  }
  public set writeTimeout(value: number) {
    this._writeTimeout = value;
  }
  public resetWriteTimeout() {
    this._writeTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get writeTimeoutInput() {
    return this._writeTimeout;
  }
}
export interface PackDestinationOutputSqsPqControls {
}

export function packDestinationOutputSqsPqControlsToTerraform(struct?: PackDestinationOutputSqsPqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function packDestinationOutputSqsPqControlsToHclTerraform(struct?: PackDestinationOutputSqsPqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class PackDestinationOutputSqsPqControlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackDestinationOutputSqsPqControls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputSqsPqControls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface PackDestinationOutputSqs {
  /**
  * Amazon Resource Name (ARN) of the role to assume
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#assume_role_arn PackDestination#assume_role_arn}
  */
  readonly assumeRoleArn?: string;
  /**
  * External ID to use when assuming role
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#assume_role_external_id PackDestination#assume_role_external_id}
  */
  readonly assumeRoleExternalId?: string;
  /**
  * SQS queue owner's AWS account ID. Leave empty if SQS queue is in same AWS account.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#aws_account_id PackDestination#aws_account_id}
  */
  readonly awsAccountId?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#aws_api_key PackDestination#aws_api_key}
  */
  readonly awsApiKey?: string;
  /**
  * AWS authentication method. Choose Auto to use IAM roles. Default: "auto"; must be one of ["auto", "manual", "secret"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#aws_authentication_method PackDestination#aws_authentication_method}
  */
  readonly awsAuthenticationMethod?: string;
  /**
  * Select or create a stored secret that references your access key and secret key
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#aws_secret PackDestination#aws_secret}
  */
  readonly awsSecret?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#aws_secret_key PackDestination#aws_secret_key}
  */
  readonly awsSecretKey?: string;
  /**
  * Create queue if it does not exist. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#create_queue PackDestination#create_queue}
  */
  readonly createQueue?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#description PackDestination#description}
  */
  readonly description?: string;
  /**
  * Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours). Default: 3600
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#duration_seconds PackDestination#duration_seconds}
  */
  readonly durationSeconds?: number;
  /**
  * Use Assume Role credentials to access SQS. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#enable_assume_role PackDestination#enable_assume_role}
  */
  readonly enableAssumeRole?: boolean | cdktf.IResolvable;
  /**
  * SQS service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to SQS-compatible endpoint.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#endpoint PackDestination#endpoint}
  */
  readonly endpoint?: string;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#environment PackDestination#environment}
  */
  readonly environment?: string;
  /**
  * Maximum time between requests. Small values could cause the payload size to be smaller than the configured Max record size. Default: 1
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#flush_period_sec PackDestination#flush_period_sec}
  */
  readonly flushPeriodSec?: number;
  /**
  * Unique ID for this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#id PackDestination#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * The maximum number of in-progress API requests before backpressure is applied. Default: 10
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_in_progress PackDestination#max_in_progress}
  */
  readonly maxInProgress?: number;
  /**
  * Maximum number of queued batches before blocking. Default: 100
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_queue_size PackDestination#max_queue_size}
  */
  readonly maxQueueSize?: number;
  /**
  * Maximum size (KB) of batches to send. Per the SQS spec, the max allowed value is 256 KB. Default: 256
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_record_size_kb PackDestination#max_record_size_kb}
  */
  readonly maxRecordSizeKb?: number;
  /**
  * This parameter applies only to FIFO queues. The tag that specifies that a message belongs to a specific message group. Messages that belong to the same message group are processed in a FIFO manner. Use event field __messageGroupId to override this value. Default: "cribl"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#message_group_id PackDestination#message_group_id}
  */
  readonly messageGroupId?: string;
  /**
  * How to handle events when all receivers are exerting backpressure. Default: "block"; must be one of ["block", "drop", "queue"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#on_backpressure PackDestination#on_backpressure}
  */
  readonly onBackpressure?: string;
  /**
  * Pipeline to process data before sending out to this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pipeline PackDestination#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_compress PackDestination#pq_compress}
  */
  readonly pqCompress?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_controls PackDestination#pq_controls}
  */
  readonly pqControls?: PackDestinationOutputSqsPqControls;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.). Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_max_file_size PackDestination#pq_max_file_size}
  */
  readonly pqMaxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_max_size PackDestination#pq_max_size}
  */
  readonly pqMaxSize?: string;
  /**
  * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem. Default: "error"; must be one of ["error", "backpressure", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_mode PackDestination#pq_mode}
  */
  readonly pqMode?: string;
  /**
  * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged. Default: "block"; must be one of ["block", "drop"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_on_backpressure PackDestination#pq_on_backpressure}
  */
  readonly pqOnBackpressure?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_path PackDestination#pq_path}
  */
  readonly pqPath?: string;
  /**
  * The name, URL, or ARN of the SQS queue to send events to. When a non-AWS URL is specified, format must be: '{url}/myQueueName'. Example: 'https://host:port/myQueueName'. Must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can be evaluated only at init time. Example referencing a Global Variable: `https://host:port/myQueue-${C.vars.myVar}`.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#queue_name PackDestination#queue_name}
  */
  readonly queueName: string;
  /**
  * The queue type used (or created). Defaults to Standard. Default: "standard"; must be one of ["standard", "fifo"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#queue_type PackDestination#queue_type}
  */
  readonly queueType?: string;
  /**
  * AWS Region where the SQS queue is located. Required, unless the Queue entry is a URL or ARN that includes a Region.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#region PackDestination#region}
  */
  readonly region?: string;
  /**
  * Reject certificates that cannot be verified against a valid CA, such as self-signed certificates. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#reject_unauthorized PackDestination#reject_unauthorized}
  */
  readonly rejectUnauthorized?: boolean | cdktf.IResolvable;
  /**
  * Reuse connections between requests, which can improve performance. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#reuse_connections PackDestination#reuse_connections}
  */
  readonly reuseConnections?: boolean | cdktf.IResolvable;
  /**
  * Signature version to use for signing SQS requests. Default: "v4"; must be one of ["v2", "v4"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#signature_version PackDestination#signature_version}
  */
  readonly signatureVersion?: string;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#streamtags PackDestination#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Fields to automatically add to events, such as cribl_pipe. Supports wildcards. Default: ["cribl_pipe"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#system_fields PackDestination#system_fields}
  */
  readonly systemFields?: string[];
  /**
  * must be "sqs"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#type PackDestination#type}
  */
  readonly type?: string;
}

export function packDestinationOutputSqsToTerraform(struct?: PackDestinationOutputSqs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    assume_role_arn: cdktf.stringToTerraform(struct!.assumeRoleArn),
    assume_role_external_id: cdktf.stringToTerraform(struct!.assumeRoleExternalId),
    aws_account_id: cdktf.stringToTerraform(struct!.awsAccountId),
    aws_api_key: cdktf.stringToTerraform(struct!.awsApiKey),
    aws_authentication_method: cdktf.stringToTerraform(struct!.awsAuthenticationMethod),
    aws_secret: cdktf.stringToTerraform(struct!.awsSecret),
    aws_secret_key: cdktf.stringToTerraform(struct!.awsSecretKey),
    create_queue: cdktf.booleanToTerraform(struct!.createQueue),
    description: cdktf.stringToTerraform(struct!.description),
    duration_seconds: cdktf.numberToTerraform(struct!.durationSeconds),
    enable_assume_role: cdktf.booleanToTerraform(struct!.enableAssumeRole),
    endpoint: cdktf.stringToTerraform(struct!.endpoint),
    environment: cdktf.stringToTerraform(struct!.environment),
    flush_period_sec: cdktf.numberToTerraform(struct!.flushPeriodSec),
    id: cdktf.stringToTerraform(struct!.id),
    max_in_progress: cdktf.numberToTerraform(struct!.maxInProgress),
    max_queue_size: cdktf.numberToTerraform(struct!.maxQueueSize),
    max_record_size_kb: cdktf.numberToTerraform(struct!.maxRecordSizeKb),
    message_group_id: cdktf.stringToTerraform(struct!.messageGroupId),
    on_backpressure: cdktf.stringToTerraform(struct!.onBackpressure),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    pq_compress: cdktf.stringToTerraform(struct!.pqCompress),
    pq_controls: packDestinationOutputSqsPqControlsToTerraform(struct!.pqControls),
    pq_max_file_size: cdktf.stringToTerraform(struct!.pqMaxFileSize),
    pq_max_size: cdktf.stringToTerraform(struct!.pqMaxSize),
    pq_mode: cdktf.stringToTerraform(struct!.pqMode),
    pq_on_backpressure: cdktf.stringToTerraform(struct!.pqOnBackpressure),
    pq_path: cdktf.stringToTerraform(struct!.pqPath),
    queue_name: cdktf.stringToTerraform(struct!.queueName),
    queue_type: cdktf.stringToTerraform(struct!.queueType),
    region: cdktf.stringToTerraform(struct!.region),
    reject_unauthorized: cdktf.booleanToTerraform(struct!.rejectUnauthorized),
    reuse_connections: cdktf.booleanToTerraform(struct!.reuseConnections),
    signature_version: cdktf.stringToTerraform(struct!.signatureVersion),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    system_fields: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.systemFields),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function packDestinationOutputSqsToHclTerraform(struct?: PackDestinationOutputSqs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    assume_role_arn: {
      value: cdktf.stringToHclTerraform(struct!.assumeRoleArn),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    assume_role_external_id: {
      value: cdktf.stringToHclTerraform(struct!.assumeRoleExternalId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    aws_account_id: {
      value: cdktf.stringToHclTerraform(struct!.awsAccountId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    aws_api_key: {
      value: cdktf.stringToHclTerraform(struct!.awsApiKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    aws_authentication_method: {
      value: cdktf.stringToHclTerraform(struct!.awsAuthenticationMethod),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    aws_secret: {
      value: cdktf.stringToHclTerraform(struct!.awsSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    aws_secret_key: {
      value: cdktf.stringToHclTerraform(struct!.awsSecretKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    create_queue: {
      value: cdktf.booleanToHclTerraform(struct!.createQueue),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    duration_seconds: {
      value: cdktf.numberToHclTerraform(struct!.durationSeconds),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    enable_assume_role: {
      value: cdktf.booleanToHclTerraform(struct!.enableAssumeRole),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    endpoint: {
      value: cdktf.stringToHclTerraform(struct!.endpoint),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    flush_period_sec: {
      value: cdktf.numberToHclTerraform(struct!.flushPeriodSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_in_progress: {
      value: cdktf.numberToHclTerraform(struct!.maxInProgress),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_queue_size: {
      value: cdktf.numberToHclTerraform(struct!.maxQueueSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_record_size_kb: {
      value: cdktf.numberToHclTerraform(struct!.maxRecordSizeKb),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    message_group_id: {
      value: cdktf.stringToHclTerraform(struct!.messageGroupId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.onBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_compress: {
      value: cdktf.stringToHclTerraform(struct!.pqCompress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_controls: {
      value: packDestinationOutputSqsPqControlsToHclTerraform(struct!.pqControls),
      isBlock: true,
      type: "struct",
      storageClassType: "PackDestinationOutputSqsPqControls",
    },
    pq_max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_max_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_mode: {
      value: cdktf.stringToHclTerraform(struct!.pqMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.pqOnBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_path: {
      value: cdktf.stringToHclTerraform(struct!.pqPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    queue_name: {
      value: cdktf.stringToHclTerraform(struct!.queueName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    queue_type: {
      value: cdktf.stringToHclTerraform(struct!.queueType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    region: {
      value: cdktf.stringToHclTerraform(struct!.region),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reject_unauthorized: {
      value: cdktf.booleanToHclTerraform(struct!.rejectUnauthorized),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    reuse_connections: {
      value: cdktf.booleanToHclTerraform(struct!.reuseConnections),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    signature_version: {
      value: cdktf.stringToHclTerraform(struct!.signatureVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    system_fields: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.systemFields),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputSqsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackDestinationOutputSqs | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._assumeRoleArn !== undefined) {
      hasAnyValues = true;
      internalValueResult.assumeRoleArn = this._assumeRoleArn;
    }
    if (this._assumeRoleExternalId !== undefined) {
      hasAnyValues = true;
      internalValueResult.assumeRoleExternalId = this._assumeRoleExternalId;
    }
    if (this._awsAccountId !== undefined) {
      hasAnyValues = true;
      internalValueResult.awsAccountId = this._awsAccountId;
    }
    if (this._awsApiKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.awsApiKey = this._awsApiKey;
    }
    if (this._awsAuthenticationMethod !== undefined) {
      hasAnyValues = true;
      internalValueResult.awsAuthenticationMethod = this._awsAuthenticationMethod;
    }
    if (this._awsSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.awsSecret = this._awsSecret;
    }
    if (this._awsSecretKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.awsSecretKey = this._awsSecretKey;
    }
    if (this._createQueue !== undefined) {
      hasAnyValues = true;
      internalValueResult.createQueue = this._createQueue;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._durationSeconds !== undefined) {
      hasAnyValues = true;
      internalValueResult.durationSeconds = this._durationSeconds;
    }
    if (this._enableAssumeRole !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableAssumeRole = this._enableAssumeRole;
    }
    if (this._endpoint !== undefined) {
      hasAnyValues = true;
      internalValueResult.endpoint = this._endpoint;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._flushPeriodSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.flushPeriodSec = this._flushPeriodSec;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._maxInProgress !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxInProgress = this._maxInProgress;
    }
    if (this._maxQueueSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxQueueSize = this._maxQueueSize;
    }
    if (this._maxRecordSizeKb !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxRecordSizeKb = this._maxRecordSizeKb;
    }
    if (this._messageGroupId !== undefined) {
      hasAnyValues = true;
      internalValueResult.messageGroupId = this._messageGroupId;
    }
    if (this._onBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.onBackpressure = this._onBackpressure;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._pqCompress !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqCompress = this._pqCompress;
    }
    if (this._pqControls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqControls = this._pqControls?.internalValue;
    }
    if (this._pqMaxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxFileSize = this._pqMaxFileSize;
    }
    if (this._pqMaxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxSize = this._pqMaxSize;
    }
    if (this._pqMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMode = this._pqMode;
    }
    if (this._pqOnBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqOnBackpressure = this._pqOnBackpressure;
    }
    if (this._pqPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqPath = this._pqPath;
    }
    if (this._queueName !== undefined) {
      hasAnyValues = true;
      internalValueResult.queueName = this._queueName;
    }
    if (this._queueType !== undefined) {
      hasAnyValues = true;
      internalValueResult.queueType = this._queueType;
    }
    if (this._region !== undefined) {
      hasAnyValues = true;
      internalValueResult.region = this._region;
    }
    if (this._rejectUnauthorized !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectUnauthorized = this._rejectUnauthorized;
    }
    if (this._reuseConnections !== undefined) {
      hasAnyValues = true;
      internalValueResult.reuseConnections = this._reuseConnections;
    }
    if (this._signatureVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.signatureVersion = this._signatureVersion;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._systemFields !== undefined) {
      hasAnyValues = true;
      internalValueResult.systemFields = this._systemFields;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputSqs | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._assumeRoleArn = undefined;
      this._assumeRoleExternalId = undefined;
      this._awsAccountId = undefined;
      this._awsApiKey = undefined;
      this._awsAuthenticationMethod = undefined;
      this._awsSecret = undefined;
      this._awsSecretKey = undefined;
      this._createQueue = undefined;
      this._description = undefined;
      this._durationSeconds = undefined;
      this._enableAssumeRole = undefined;
      this._endpoint = undefined;
      this._environment = undefined;
      this._flushPeriodSec = undefined;
      this._id = undefined;
      this._maxInProgress = undefined;
      this._maxQueueSize = undefined;
      this._maxRecordSizeKb = undefined;
      this._messageGroupId = undefined;
      this._onBackpressure = undefined;
      this._pipeline = undefined;
      this._pqCompress = undefined;
      this._pqControls.internalValue = undefined;
      this._pqMaxFileSize = undefined;
      this._pqMaxSize = undefined;
      this._pqMode = undefined;
      this._pqOnBackpressure = undefined;
      this._pqPath = undefined;
      this._queueName = undefined;
      this._queueType = undefined;
      this._region = undefined;
      this._rejectUnauthorized = undefined;
      this._reuseConnections = undefined;
      this._signatureVersion = undefined;
      this._streamtags = undefined;
      this._systemFields = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._assumeRoleArn = value.assumeRoleArn;
      this._assumeRoleExternalId = value.assumeRoleExternalId;
      this._awsAccountId = value.awsAccountId;
      this._awsApiKey = value.awsApiKey;
      this._awsAuthenticationMethod = value.awsAuthenticationMethod;
      this._awsSecret = value.awsSecret;
      this._awsSecretKey = value.awsSecretKey;
      this._createQueue = value.createQueue;
      this._description = value.description;
      this._durationSeconds = value.durationSeconds;
      this._enableAssumeRole = value.enableAssumeRole;
      this._endpoint = value.endpoint;
      this._environment = value.environment;
      this._flushPeriodSec = value.flushPeriodSec;
      this._id = value.id;
      this._maxInProgress = value.maxInProgress;
      this._maxQueueSize = value.maxQueueSize;
      this._maxRecordSizeKb = value.maxRecordSizeKb;
      this._messageGroupId = value.messageGroupId;
      this._onBackpressure = value.onBackpressure;
      this._pipeline = value.pipeline;
      this._pqCompress = value.pqCompress;
      this._pqControls.internalValue = value.pqControls;
      this._pqMaxFileSize = value.pqMaxFileSize;
      this._pqMaxSize = value.pqMaxSize;
      this._pqMode = value.pqMode;
      this._pqOnBackpressure = value.pqOnBackpressure;
      this._pqPath = value.pqPath;
      this._queueName = value.queueName;
      this._queueType = value.queueType;
      this._region = value.region;
      this._rejectUnauthorized = value.rejectUnauthorized;
      this._reuseConnections = value.reuseConnections;
      this._signatureVersion = value.signatureVersion;
      this._streamtags = value.streamtags;
      this._systemFields = value.systemFields;
      this._type = value.type;
    }
  }

  // assume_role_arn - computed: false, optional: true, required: false
  private _assumeRoleArn?: string; 
  public get assumeRoleArn() {
    return this.getStringAttribute('assume_role_arn');
  }
  public set assumeRoleArn(value: string) {
    this._assumeRoleArn = value;
  }
  public resetAssumeRoleArn() {
    this._assumeRoleArn = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get assumeRoleArnInput() {
    return this._assumeRoleArn;
  }

  // assume_role_external_id - computed: false, optional: true, required: false
  private _assumeRoleExternalId?: string; 
  public get assumeRoleExternalId() {
    return this.getStringAttribute('assume_role_external_id');
  }
  public set assumeRoleExternalId(value: string) {
    this._assumeRoleExternalId = value;
  }
  public resetAssumeRoleExternalId() {
    this._assumeRoleExternalId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get assumeRoleExternalIdInput() {
    return this._assumeRoleExternalId;
  }

  // aws_account_id - computed: false, optional: true, required: false
  private _awsAccountId?: string; 
  public get awsAccountId() {
    return this.getStringAttribute('aws_account_id');
  }
  public set awsAccountId(value: string) {
    this._awsAccountId = value;
  }
  public resetAwsAccountId() {
    this._awsAccountId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsAccountIdInput() {
    return this._awsAccountId;
  }

  // aws_api_key - computed: false, optional: true, required: false
  private _awsApiKey?: string; 
  public get awsApiKey() {
    return this.getStringAttribute('aws_api_key');
  }
  public set awsApiKey(value: string) {
    this._awsApiKey = value;
  }
  public resetAwsApiKey() {
    this._awsApiKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsApiKeyInput() {
    return this._awsApiKey;
  }

  // aws_authentication_method - computed: true, optional: true, required: false
  private _awsAuthenticationMethod?: string; 
  public get awsAuthenticationMethod() {
    return this.getStringAttribute('aws_authentication_method');
  }
  public set awsAuthenticationMethod(value: string) {
    this._awsAuthenticationMethod = value;
  }
  public resetAwsAuthenticationMethod() {
    this._awsAuthenticationMethod = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsAuthenticationMethodInput() {
    return this._awsAuthenticationMethod;
  }

  // aws_secret - computed: false, optional: true, required: false
  private _awsSecret?: string; 
  public get awsSecret() {
    return this.getStringAttribute('aws_secret');
  }
  public set awsSecret(value: string) {
    this._awsSecret = value;
  }
  public resetAwsSecret() {
    this._awsSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsSecretInput() {
    return this._awsSecret;
  }

  // aws_secret_key - computed: false, optional: true, required: false
  private _awsSecretKey?: string; 
  public get awsSecretKey() {
    return this.getStringAttribute('aws_secret_key');
  }
  public set awsSecretKey(value: string) {
    this._awsSecretKey = value;
  }
  public resetAwsSecretKey() {
    this._awsSecretKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsSecretKeyInput() {
    return this._awsSecretKey;
  }

  // create_queue - computed: true, optional: true, required: false
  private _createQueue?: boolean | cdktf.IResolvable; 
  public get createQueue() {
    return this.getBooleanAttribute('create_queue');
  }
  public set createQueue(value: boolean | cdktf.IResolvable) {
    this._createQueue = value;
  }
  public resetCreateQueue() {
    this._createQueue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get createQueueInput() {
    return this._createQueue;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // duration_seconds - computed: true, optional: true, required: false
  private _durationSeconds?: number; 
  public get durationSeconds() {
    return this.getNumberAttribute('duration_seconds');
  }
  public set durationSeconds(value: number) {
    this._durationSeconds = value;
  }
  public resetDurationSeconds() {
    this._durationSeconds = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get durationSecondsInput() {
    return this._durationSeconds;
  }

  // enable_assume_role - computed: true, optional: true, required: false
  private _enableAssumeRole?: boolean | cdktf.IResolvable; 
  public get enableAssumeRole() {
    return this.getBooleanAttribute('enable_assume_role');
  }
  public set enableAssumeRole(value: boolean | cdktf.IResolvable) {
    this._enableAssumeRole = value;
  }
  public resetEnableAssumeRole() {
    this._enableAssumeRole = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableAssumeRoleInput() {
    return this._enableAssumeRole;
  }

  // endpoint - computed: false, optional: true, required: false
  private _endpoint?: string; 
  public get endpoint() {
    return this.getStringAttribute('endpoint');
  }
  public set endpoint(value: string) {
    this._endpoint = value;
  }
  public resetEndpoint() {
    this._endpoint = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get endpointInput() {
    return this._endpoint;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // flush_period_sec - computed: true, optional: true, required: false
  private _flushPeriodSec?: number; 
  public get flushPeriodSec() {
    return this.getNumberAttribute('flush_period_sec');
  }
  public set flushPeriodSec(value: number) {
    this._flushPeriodSec = value;
  }
  public resetFlushPeriodSec() {
    this._flushPeriodSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get flushPeriodSecInput() {
    return this._flushPeriodSec;
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // max_in_progress - computed: true, optional: true, required: false
  private _maxInProgress?: number; 
  public get maxInProgress() {
    return this.getNumberAttribute('max_in_progress');
  }
  public set maxInProgress(value: number) {
    this._maxInProgress = value;
  }
  public resetMaxInProgress() {
    this._maxInProgress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxInProgressInput() {
    return this._maxInProgress;
  }

  // max_queue_size - computed: true, optional: true, required: false
  private _maxQueueSize?: number; 
  public get maxQueueSize() {
    return this.getNumberAttribute('max_queue_size');
  }
  public set maxQueueSize(value: number) {
    this._maxQueueSize = value;
  }
  public resetMaxQueueSize() {
    this._maxQueueSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxQueueSizeInput() {
    return this._maxQueueSize;
  }

  // max_record_size_kb - computed: true, optional: true, required: false
  private _maxRecordSizeKb?: number; 
  public get maxRecordSizeKb() {
    return this.getNumberAttribute('max_record_size_kb');
  }
  public set maxRecordSizeKb(value: number) {
    this._maxRecordSizeKb = value;
  }
  public resetMaxRecordSizeKb() {
    this._maxRecordSizeKb = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxRecordSizeKbInput() {
    return this._maxRecordSizeKb;
  }

  // message_group_id - computed: true, optional: true, required: false
  private _messageGroupId?: string; 
  public get messageGroupId() {
    return this.getStringAttribute('message_group_id');
  }
  public set messageGroupId(value: string) {
    this._messageGroupId = value;
  }
  public resetMessageGroupId() {
    this._messageGroupId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get messageGroupIdInput() {
    return this._messageGroupId;
  }

  // on_backpressure - computed: true, optional: true, required: false
  private _onBackpressure?: string; 
  public get onBackpressure() {
    return this.getStringAttribute('on_backpressure');
  }
  public set onBackpressure(value: string) {
    this._onBackpressure = value;
  }
  public resetOnBackpressure() {
    this._onBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get onBackpressureInput() {
    return this._onBackpressure;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // pq_compress - computed: true, optional: true, required: false
  private _pqCompress?: string; 
  public get pqCompress() {
    return this.getStringAttribute('pq_compress');
  }
  public set pqCompress(value: string) {
    this._pqCompress = value;
  }
  public resetPqCompress() {
    this._pqCompress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqCompressInput() {
    return this._pqCompress;
  }

  // pq_controls - computed: false, optional: true, required: false
  private _pqControls = new PackDestinationOutputSqsPqControlsOutputReference(this, "pq_controls");
  public get pqControls() {
    return this._pqControls;
  }
  public putPqControls(value: PackDestinationOutputSqsPqControls) {
    this._pqControls.internalValue = value;
  }
  public resetPqControls() {
    this._pqControls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqControlsInput() {
    return this._pqControls.internalValue;
  }

  // pq_max_file_size - computed: true, optional: true, required: false
  private _pqMaxFileSize?: string; 
  public get pqMaxFileSize() {
    return this.getStringAttribute('pq_max_file_size');
  }
  public set pqMaxFileSize(value: string) {
    this._pqMaxFileSize = value;
  }
  public resetPqMaxFileSize() {
    this._pqMaxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxFileSizeInput() {
    return this._pqMaxFileSize;
  }

  // pq_max_size - computed: true, optional: true, required: false
  private _pqMaxSize?: string; 
  public get pqMaxSize() {
    return this.getStringAttribute('pq_max_size');
  }
  public set pqMaxSize(value: string) {
    this._pqMaxSize = value;
  }
  public resetPqMaxSize() {
    this._pqMaxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxSizeInput() {
    return this._pqMaxSize;
  }

  // pq_mode - computed: true, optional: true, required: false
  private _pqMode?: string; 
  public get pqMode() {
    return this.getStringAttribute('pq_mode');
  }
  public set pqMode(value: string) {
    this._pqMode = value;
  }
  public resetPqMode() {
    this._pqMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqModeInput() {
    return this._pqMode;
  }

  // pq_on_backpressure - computed: true, optional: true, required: false
  private _pqOnBackpressure?: string; 
  public get pqOnBackpressure() {
    return this.getStringAttribute('pq_on_backpressure');
  }
  public set pqOnBackpressure(value: string) {
    this._pqOnBackpressure = value;
  }
  public resetPqOnBackpressure() {
    this._pqOnBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqOnBackpressureInput() {
    return this._pqOnBackpressure;
  }

  // pq_path - computed: true, optional: true, required: false
  private _pqPath?: string; 
  public get pqPath() {
    return this.getStringAttribute('pq_path');
  }
  public set pqPath(value: string) {
    this._pqPath = value;
  }
  public resetPqPath() {
    this._pqPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqPathInput() {
    return this._pqPath;
  }

  // queue_name - computed: false, optional: false, required: true
  private _queueName?: string; 
  public get queueName() {
    return this.getStringAttribute('queue_name');
  }
  public set queueName(value: string) {
    this._queueName = value;
  }
  // Temporarily expose input value. Use with caution.
  public get queueNameInput() {
    return this._queueName;
  }

  // queue_type - computed: true, optional: true, required: false
  private _queueType?: string; 
  public get queueType() {
    return this.getStringAttribute('queue_type');
  }
  public set queueType(value: string) {
    this._queueType = value;
  }
  public resetQueueType() {
    this._queueType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get queueTypeInput() {
    return this._queueType;
  }

  // region - computed: false, optional: true, required: false
  private _region?: string; 
  public get region() {
    return this.getStringAttribute('region');
  }
  public set region(value: string) {
    this._region = value;
  }
  public resetRegion() {
    this._region = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get regionInput() {
    return this._region;
  }

  // reject_unauthorized - computed: true, optional: true, required: false
  private _rejectUnauthorized?: boolean | cdktf.IResolvable; 
  public get rejectUnauthorized() {
    return this.getBooleanAttribute('reject_unauthorized');
  }
  public set rejectUnauthorized(value: boolean | cdktf.IResolvable) {
    this._rejectUnauthorized = value;
  }
  public resetRejectUnauthorized() {
    this._rejectUnauthorized = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectUnauthorizedInput() {
    return this._rejectUnauthorized;
  }

  // reuse_connections - computed: true, optional: true, required: false
  private _reuseConnections?: boolean | cdktf.IResolvable; 
  public get reuseConnections() {
    return this.getBooleanAttribute('reuse_connections');
  }
  public set reuseConnections(value: boolean | cdktf.IResolvable) {
    this._reuseConnections = value;
  }
  public resetReuseConnections() {
    this._reuseConnections = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get reuseConnectionsInput() {
    return this._reuseConnections;
  }

  // signature_version - computed: true, optional: true, required: false
  private _signatureVersion?: string; 
  public get signatureVersion() {
    return this.getStringAttribute('signature_version');
  }
  public set signatureVersion(value: string) {
    this._signatureVersion = value;
  }
  public resetSignatureVersion() {
    this._signatureVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get signatureVersionInput() {
    return this._signatureVersion;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // system_fields - computed: true, optional: true, required: false
  private _systemFields?: string[]; 
  public get systemFields() {
    return this.getListAttribute('system_fields');
  }
  public set systemFields(value: string[]) {
    this._systemFields = value;
  }
  public resetSystemFields() {
    this._systemFields = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get systemFieldsInput() {
    return this._systemFields;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface PackDestinationOutputStatsdPqControls {
}

export function packDestinationOutputStatsdPqControlsToTerraform(struct?: PackDestinationOutputStatsdPqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function packDestinationOutputStatsdPqControlsToHclTerraform(struct?: PackDestinationOutputStatsdPqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class PackDestinationOutputStatsdPqControlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackDestinationOutputStatsdPqControls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputStatsdPqControls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface PackDestinationOutputStatsd {
  /**
  * Amount of time (milliseconds) to wait for the connection to establish before retrying. Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#connection_timeout PackDestination#connection_timeout}
  */
  readonly connectionTimeout?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#description PackDestination#description}
  */
  readonly description?: string;
  /**
  * How often to resolve the destination hostname to an IP address. Ignored if the destination is an IP address. A value of 0 means every batch sent will incur a DNS lookup. Default: 0
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#dns_resolve_period_sec PackDestination#dns_resolve_period_sec}
  */
  readonly dnsResolvePeriodSec?: number;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#environment PackDestination#environment}
  */
  readonly environment?: string;
  /**
  * When protocol is TCP, specifies how often buffers should be flushed, resulting in records sent to the destination. Default: 1
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#flush_period_sec PackDestination#flush_period_sec}
  */
  readonly flushPeriodSec?: number;
  /**
  * The hostname of the destination.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#host PackDestination#host}
  */
  readonly host: string;
  /**
  * Unique ID for this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#id PackDestination#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * When protocol is UDP, specifies the maximum size of packets sent to the destination. Also known as the MTU for the network path to the destination system. Default: 512
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#mtu PackDestination#mtu}
  */
  readonly mtu?: number;
  /**
  * How to handle events when all receivers are exerting backpressure. Default: "block"; must be one of ["block", "drop", "queue"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#on_backpressure PackDestination#on_backpressure}
  */
  readonly onBackpressure?: string;
  /**
  * Pipeline to process data before sending out to this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pipeline PackDestination#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Destination port. Default: 8125
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#port PackDestination#port}
  */
  readonly port?: number;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_compress PackDestination#pq_compress}
  */
  readonly pqCompress?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_controls PackDestination#pq_controls}
  */
  readonly pqControls?: PackDestinationOutputStatsdPqControls;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.). Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_max_file_size PackDestination#pq_max_file_size}
  */
  readonly pqMaxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_max_size PackDestination#pq_max_size}
  */
  readonly pqMaxSize?: string;
  /**
  * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem. Default: "error"; must be one of ["error", "backpressure", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_mode PackDestination#pq_mode}
  */
  readonly pqMode?: string;
  /**
  * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged. Default: "block"; must be one of ["block", "drop"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_on_backpressure PackDestination#pq_on_backpressure}
  */
  readonly pqOnBackpressure?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_path PackDestination#pq_path}
  */
  readonly pqPath?: string;
  /**
  * Protocol to use when communicating with the destination. Default: "udp"; must be one of ["udp", "tcp"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#protocol PackDestination#protocol}
  */
  readonly protocol?: string;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#streamtags PackDestination#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Fields to automatically add to events, such as cribl_pipe. Supports wildcards. Default: ["cribl_pipe"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#system_fields PackDestination#system_fields}
  */
  readonly systemFields?: string[];
  /**
  * Rate (in bytes per second) to throttle while writing to an output. Accepts values with multiple-byte units, such as KB, MB, and GB. (Example: 42 MB) Default value of 0 specifies no throttling. Default: "0"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#throttle_rate_per_sec PackDestination#throttle_rate_per_sec}
  */
  readonly throttleRatePerSec?: string;
  /**
  * must be "statsd"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#type PackDestination#type}
  */
  readonly type?: string;
  /**
  * Amount of time (milliseconds) to wait for a write to complete before assuming connection is dead. Default: 60000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#write_timeout PackDestination#write_timeout}
  */
  readonly writeTimeout?: number;
}

export function packDestinationOutputStatsdToTerraform(struct?: PackDestinationOutputStatsd | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    connection_timeout: cdktf.numberToTerraform(struct!.connectionTimeout),
    description: cdktf.stringToTerraform(struct!.description),
    dns_resolve_period_sec: cdktf.numberToTerraform(struct!.dnsResolvePeriodSec),
    environment: cdktf.stringToTerraform(struct!.environment),
    flush_period_sec: cdktf.numberToTerraform(struct!.flushPeriodSec),
    host: cdktf.stringToTerraform(struct!.host),
    id: cdktf.stringToTerraform(struct!.id),
    mtu: cdktf.numberToTerraform(struct!.mtu),
    on_backpressure: cdktf.stringToTerraform(struct!.onBackpressure),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    port: cdktf.numberToTerraform(struct!.port),
    pq_compress: cdktf.stringToTerraform(struct!.pqCompress),
    pq_controls: packDestinationOutputStatsdPqControlsToTerraform(struct!.pqControls),
    pq_max_file_size: cdktf.stringToTerraform(struct!.pqMaxFileSize),
    pq_max_size: cdktf.stringToTerraform(struct!.pqMaxSize),
    pq_mode: cdktf.stringToTerraform(struct!.pqMode),
    pq_on_backpressure: cdktf.stringToTerraform(struct!.pqOnBackpressure),
    pq_path: cdktf.stringToTerraform(struct!.pqPath),
    protocol: cdktf.stringToTerraform(struct!.protocol),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    system_fields: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.systemFields),
    throttle_rate_per_sec: cdktf.stringToTerraform(struct!.throttleRatePerSec),
    type: cdktf.stringToTerraform(struct!.type),
    write_timeout: cdktf.numberToTerraform(struct!.writeTimeout),
  }
}


export function packDestinationOutputStatsdToHclTerraform(struct?: PackDestinationOutputStatsd | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    connection_timeout: {
      value: cdktf.numberToHclTerraform(struct!.connectionTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    dns_resolve_period_sec: {
      value: cdktf.numberToHclTerraform(struct!.dnsResolvePeriodSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    flush_period_sec: {
      value: cdktf.numberToHclTerraform(struct!.flushPeriodSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    host: {
      value: cdktf.stringToHclTerraform(struct!.host),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    mtu: {
      value: cdktf.numberToHclTerraform(struct!.mtu),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.onBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    pq_compress: {
      value: cdktf.stringToHclTerraform(struct!.pqCompress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_controls: {
      value: packDestinationOutputStatsdPqControlsToHclTerraform(struct!.pqControls),
      isBlock: true,
      type: "struct",
      storageClassType: "PackDestinationOutputStatsdPqControls",
    },
    pq_max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_max_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_mode: {
      value: cdktf.stringToHclTerraform(struct!.pqMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.pqOnBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_path: {
      value: cdktf.stringToHclTerraform(struct!.pqPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    protocol: {
      value: cdktf.stringToHclTerraform(struct!.protocol),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    system_fields: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.systemFields),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    throttle_rate_per_sec: {
      value: cdktf.stringToHclTerraform(struct!.throttleRatePerSec),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    write_timeout: {
      value: cdktf.numberToHclTerraform(struct!.writeTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputStatsdOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackDestinationOutputStatsd | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._connectionTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.connectionTimeout = this._connectionTimeout;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._dnsResolvePeriodSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.dnsResolvePeriodSec = this._dnsResolvePeriodSec;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._flushPeriodSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.flushPeriodSec = this._flushPeriodSec;
    }
    if (this._host !== undefined) {
      hasAnyValues = true;
      internalValueResult.host = this._host;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._mtu !== undefined) {
      hasAnyValues = true;
      internalValueResult.mtu = this._mtu;
    }
    if (this._onBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.onBackpressure = this._onBackpressure;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._pqCompress !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqCompress = this._pqCompress;
    }
    if (this._pqControls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqControls = this._pqControls?.internalValue;
    }
    if (this._pqMaxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxFileSize = this._pqMaxFileSize;
    }
    if (this._pqMaxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxSize = this._pqMaxSize;
    }
    if (this._pqMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMode = this._pqMode;
    }
    if (this._pqOnBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqOnBackpressure = this._pqOnBackpressure;
    }
    if (this._pqPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqPath = this._pqPath;
    }
    if (this._protocol !== undefined) {
      hasAnyValues = true;
      internalValueResult.protocol = this._protocol;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._systemFields !== undefined) {
      hasAnyValues = true;
      internalValueResult.systemFields = this._systemFields;
    }
    if (this._throttleRatePerSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.throttleRatePerSec = this._throttleRatePerSec;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._writeTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.writeTimeout = this._writeTimeout;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputStatsd | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._connectionTimeout = undefined;
      this._description = undefined;
      this._dnsResolvePeriodSec = undefined;
      this._environment = undefined;
      this._flushPeriodSec = undefined;
      this._host = undefined;
      this._id = undefined;
      this._mtu = undefined;
      this._onBackpressure = undefined;
      this._pipeline = undefined;
      this._port = undefined;
      this._pqCompress = undefined;
      this._pqControls.internalValue = undefined;
      this._pqMaxFileSize = undefined;
      this._pqMaxSize = undefined;
      this._pqMode = undefined;
      this._pqOnBackpressure = undefined;
      this._pqPath = undefined;
      this._protocol = undefined;
      this._streamtags = undefined;
      this._systemFields = undefined;
      this._throttleRatePerSec = undefined;
      this._type = undefined;
      this._writeTimeout = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._connectionTimeout = value.connectionTimeout;
      this._description = value.description;
      this._dnsResolvePeriodSec = value.dnsResolvePeriodSec;
      this._environment = value.environment;
      this._flushPeriodSec = value.flushPeriodSec;
      this._host = value.host;
      this._id = value.id;
      this._mtu = value.mtu;
      this._onBackpressure = value.onBackpressure;
      this._pipeline = value.pipeline;
      this._port = value.port;
      this._pqCompress = value.pqCompress;
      this._pqControls.internalValue = value.pqControls;
      this._pqMaxFileSize = value.pqMaxFileSize;
      this._pqMaxSize = value.pqMaxSize;
      this._pqMode = value.pqMode;
      this._pqOnBackpressure = value.pqOnBackpressure;
      this._pqPath = value.pqPath;
      this._protocol = value.protocol;
      this._streamtags = value.streamtags;
      this._systemFields = value.systemFields;
      this._throttleRatePerSec = value.throttleRatePerSec;
      this._type = value.type;
      this._writeTimeout = value.writeTimeout;
    }
  }

  // connection_timeout - computed: true, optional: true, required: false
  private _connectionTimeout?: number; 
  public get connectionTimeout() {
    return this.getNumberAttribute('connection_timeout');
  }
  public set connectionTimeout(value: number) {
    this._connectionTimeout = value;
  }
  public resetConnectionTimeout() {
    this._connectionTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectionTimeoutInput() {
    return this._connectionTimeout;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // dns_resolve_period_sec - computed: true, optional: true, required: false
  private _dnsResolvePeriodSec?: number; 
  public get dnsResolvePeriodSec() {
    return this.getNumberAttribute('dns_resolve_period_sec');
  }
  public set dnsResolvePeriodSec(value: number) {
    this._dnsResolvePeriodSec = value;
  }
  public resetDnsResolvePeriodSec() {
    this._dnsResolvePeriodSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dnsResolvePeriodSecInput() {
    return this._dnsResolvePeriodSec;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // flush_period_sec - computed: true, optional: true, required: false
  private _flushPeriodSec?: number; 
  public get flushPeriodSec() {
    return this.getNumberAttribute('flush_period_sec');
  }
  public set flushPeriodSec(value: number) {
    this._flushPeriodSec = value;
  }
  public resetFlushPeriodSec() {
    this._flushPeriodSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get flushPeriodSecInput() {
    return this._flushPeriodSec;
  }

  // host - computed: false, optional: false, required: true
  private _host?: string; 
  public get host() {
    return this.getStringAttribute('host');
  }
  public set host(value: string) {
    this._host = value;
  }
  // Temporarily expose input value. Use with caution.
  public get hostInput() {
    return this._host;
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // mtu - computed: true, optional: true, required: false
  private _mtu?: number; 
  public get mtu() {
    return this.getNumberAttribute('mtu');
  }
  public set mtu(value: number) {
    this._mtu = value;
  }
  public resetMtu() {
    this._mtu = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get mtuInput() {
    return this._mtu;
  }

  // on_backpressure - computed: true, optional: true, required: false
  private _onBackpressure?: string; 
  public get onBackpressure() {
    return this.getStringAttribute('on_backpressure');
  }
  public set onBackpressure(value: string) {
    this._onBackpressure = value;
  }
  public resetOnBackpressure() {
    this._onBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get onBackpressureInput() {
    return this._onBackpressure;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // port - computed: true, optional: true, required: false
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // pq_compress - computed: true, optional: true, required: false
  private _pqCompress?: string; 
  public get pqCompress() {
    return this.getStringAttribute('pq_compress');
  }
  public set pqCompress(value: string) {
    this._pqCompress = value;
  }
  public resetPqCompress() {
    this._pqCompress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqCompressInput() {
    return this._pqCompress;
  }

  // pq_controls - computed: false, optional: true, required: false
  private _pqControls = new PackDestinationOutputStatsdPqControlsOutputReference(this, "pq_controls");
  public get pqControls() {
    return this._pqControls;
  }
  public putPqControls(value: PackDestinationOutputStatsdPqControls) {
    this._pqControls.internalValue = value;
  }
  public resetPqControls() {
    this._pqControls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqControlsInput() {
    return this._pqControls.internalValue;
  }

  // pq_max_file_size - computed: true, optional: true, required: false
  private _pqMaxFileSize?: string; 
  public get pqMaxFileSize() {
    return this.getStringAttribute('pq_max_file_size');
  }
  public set pqMaxFileSize(value: string) {
    this._pqMaxFileSize = value;
  }
  public resetPqMaxFileSize() {
    this._pqMaxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxFileSizeInput() {
    return this._pqMaxFileSize;
  }

  // pq_max_size - computed: true, optional: true, required: false
  private _pqMaxSize?: string; 
  public get pqMaxSize() {
    return this.getStringAttribute('pq_max_size');
  }
  public set pqMaxSize(value: string) {
    this._pqMaxSize = value;
  }
  public resetPqMaxSize() {
    this._pqMaxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxSizeInput() {
    return this._pqMaxSize;
  }

  // pq_mode - computed: true, optional: true, required: false
  private _pqMode?: string; 
  public get pqMode() {
    return this.getStringAttribute('pq_mode');
  }
  public set pqMode(value: string) {
    this._pqMode = value;
  }
  public resetPqMode() {
    this._pqMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqModeInput() {
    return this._pqMode;
  }

  // pq_on_backpressure - computed: true, optional: true, required: false
  private _pqOnBackpressure?: string; 
  public get pqOnBackpressure() {
    return this.getStringAttribute('pq_on_backpressure');
  }
  public set pqOnBackpressure(value: string) {
    this._pqOnBackpressure = value;
  }
  public resetPqOnBackpressure() {
    this._pqOnBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqOnBackpressureInput() {
    return this._pqOnBackpressure;
  }

  // pq_path - computed: true, optional: true, required: false
  private _pqPath?: string; 
  public get pqPath() {
    return this.getStringAttribute('pq_path');
  }
  public set pqPath(value: string) {
    this._pqPath = value;
  }
  public resetPqPath() {
    this._pqPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqPathInput() {
    return this._pqPath;
  }

  // protocol - computed: true, optional: true, required: false
  private _protocol?: string; 
  public get protocol() {
    return this.getStringAttribute('protocol');
  }
  public set protocol(value: string) {
    this._protocol = value;
  }
  public resetProtocol() {
    this._protocol = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get protocolInput() {
    return this._protocol;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // system_fields - computed: true, optional: true, required: false
  private _systemFields?: string[]; 
  public get systemFields() {
    return this.getListAttribute('system_fields');
  }
  public set systemFields(value: string[]) {
    this._systemFields = value;
  }
  public resetSystemFields() {
    this._systemFields = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get systemFieldsInput() {
    return this._systemFields;
  }

  // throttle_rate_per_sec - computed: true, optional: true, required: false
  private _throttleRatePerSec?: string; 
  public get throttleRatePerSec() {
    return this.getStringAttribute('throttle_rate_per_sec');
  }
  public set throttleRatePerSec(value: string) {
    this._throttleRatePerSec = value;
  }
  public resetThrottleRatePerSec() {
    this._throttleRatePerSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get throttleRatePerSecInput() {
    return this._throttleRatePerSec;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // write_timeout - computed: true, optional: true, required: false
  private _writeTimeout?: number; 
  public get writeTimeout() {
    return this.getNumberAttribute('write_timeout');
  }
  public set writeTimeout(value: number) {
    this._writeTimeout = value;
  }
  public resetWriteTimeout() {
    this._writeTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get writeTimeoutInput() {
    return this._writeTimeout;
  }
}
export interface PackDestinationOutputStatsdExtPqControls {
}

export function packDestinationOutputStatsdExtPqControlsToTerraform(struct?: PackDestinationOutputStatsdExtPqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function packDestinationOutputStatsdExtPqControlsToHclTerraform(struct?: PackDestinationOutputStatsdExtPqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class PackDestinationOutputStatsdExtPqControlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackDestinationOutputStatsdExtPqControls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputStatsdExtPqControls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface PackDestinationOutputStatsdExt {
  /**
  * Amount of time (milliseconds) to wait for the connection to establish before retrying. Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#connection_timeout PackDestination#connection_timeout}
  */
  readonly connectionTimeout?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#description PackDestination#description}
  */
  readonly description?: string;
  /**
  * How often to resolve the destination hostname to an IP address. Ignored if the destination is an IP address. A value of 0 means every batch sent will incur a DNS lookup. Default: 0
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#dns_resolve_period_sec PackDestination#dns_resolve_period_sec}
  */
  readonly dnsResolvePeriodSec?: number;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#environment PackDestination#environment}
  */
  readonly environment?: string;
  /**
  * When protocol is TCP, specifies how often buffers should be flushed, resulting in records sent to the destination. Default: 1
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#flush_period_sec PackDestination#flush_period_sec}
  */
  readonly flushPeriodSec?: number;
  /**
  * The hostname of the destination.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#host PackDestination#host}
  */
  readonly host: string;
  /**
  * Unique ID for this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#id PackDestination#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * When protocol is UDP, specifies the maximum size of packets sent to the destination. Also known as the MTU for the network path to the destination system. Default: 512
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#mtu PackDestination#mtu}
  */
  readonly mtu?: number;
  /**
  * How to handle events when all receivers are exerting backpressure. Default: "block"; must be one of ["block", "drop", "queue"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#on_backpressure PackDestination#on_backpressure}
  */
  readonly onBackpressure?: string;
  /**
  * Pipeline to process data before sending out to this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pipeline PackDestination#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Destination port. Default: 8125
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#port PackDestination#port}
  */
  readonly port?: number;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_compress PackDestination#pq_compress}
  */
  readonly pqCompress?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_controls PackDestination#pq_controls}
  */
  readonly pqControls?: PackDestinationOutputStatsdExtPqControls;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.). Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_max_file_size PackDestination#pq_max_file_size}
  */
  readonly pqMaxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_max_size PackDestination#pq_max_size}
  */
  readonly pqMaxSize?: string;
  /**
  * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem. Default: "error"; must be one of ["error", "backpressure", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_mode PackDestination#pq_mode}
  */
  readonly pqMode?: string;
  /**
  * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged. Default: "block"; must be one of ["block", "drop"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_on_backpressure PackDestination#pq_on_backpressure}
  */
  readonly pqOnBackpressure?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_path PackDestination#pq_path}
  */
  readonly pqPath?: string;
  /**
  * Protocol to use when communicating with the destination. Default: "udp"; must be one of ["udp", "tcp"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#protocol PackDestination#protocol}
  */
  readonly protocol?: string;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#streamtags PackDestination#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Fields to automatically add to events, such as cribl_pipe. Supports wildcards. Default: ["cribl_pipe"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#system_fields PackDestination#system_fields}
  */
  readonly systemFields?: string[];
  /**
  * Rate (in bytes per second) to throttle while writing to an output. Accepts values with multiple-byte units, such as KB, MB, and GB. (Example: 42 MB) Default value of 0 specifies no throttling. Default: "0"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#throttle_rate_per_sec PackDestination#throttle_rate_per_sec}
  */
  readonly throttleRatePerSec?: string;
  /**
  * must be "statsd_ext"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#type PackDestination#type}
  */
  readonly type?: string;
  /**
  * Amount of time (milliseconds) to wait for a write to complete before assuming connection is dead. Default: 60000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#write_timeout PackDestination#write_timeout}
  */
  readonly writeTimeout?: number;
}

export function packDestinationOutputStatsdExtToTerraform(struct?: PackDestinationOutputStatsdExt | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    connection_timeout: cdktf.numberToTerraform(struct!.connectionTimeout),
    description: cdktf.stringToTerraform(struct!.description),
    dns_resolve_period_sec: cdktf.numberToTerraform(struct!.dnsResolvePeriodSec),
    environment: cdktf.stringToTerraform(struct!.environment),
    flush_period_sec: cdktf.numberToTerraform(struct!.flushPeriodSec),
    host: cdktf.stringToTerraform(struct!.host),
    id: cdktf.stringToTerraform(struct!.id),
    mtu: cdktf.numberToTerraform(struct!.mtu),
    on_backpressure: cdktf.stringToTerraform(struct!.onBackpressure),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    port: cdktf.numberToTerraform(struct!.port),
    pq_compress: cdktf.stringToTerraform(struct!.pqCompress),
    pq_controls: packDestinationOutputStatsdExtPqControlsToTerraform(struct!.pqControls),
    pq_max_file_size: cdktf.stringToTerraform(struct!.pqMaxFileSize),
    pq_max_size: cdktf.stringToTerraform(struct!.pqMaxSize),
    pq_mode: cdktf.stringToTerraform(struct!.pqMode),
    pq_on_backpressure: cdktf.stringToTerraform(struct!.pqOnBackpressure),
    pq_path: cdktf.stringToTerraform(struct!.pqPath),
    protocol: cdktf.stringToTerraform(struct!.protocol),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    system_fields: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.systemFields),
    throttle_rate_per_sec: cdktf.stringToTerraform(struct!.throttleRatePerSec),
    type: cdktf.stringToTerraform(struct!.type),
    write_timeout: cdktf.numberToTerraform(struct!.writeTimeout),
  }
}


export function packDestinationOutputStatsdExtToHclTerraform(struct?: PackDestinationOutputStatsdExt | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    connection_timeout: {
      value: cdktf.numberToHclTerraform(struct!.connectionTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    dns_resolve_period_sec: {
      value: cdktf.numberToHclTerraform(struct!.dnsResolvePeriodSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    flush_period_sec: {
      value: cdktf.numberToHclTerraform(struct!.flushPeriodSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    host: {
      value: cdktf.stringToHclTerraform(struct!.host),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    mtu: {
      value: cdktf.numberToHclTerraform(struct!.mtu),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.onBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    pq_compress: {
      value: cdktf.stringToHclTerraform(struct!.pqCompress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_controls: {
      value: packDestinationOutputStatsdExtPqControlsToHclTerraform(struct!.pqControls),
      isBlock: true,
      type: "struct",
      storageClassType: "PackDestinationOutputStatsdExtPqControls",
    },
    pq_max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_max_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_mode: {
      value: cdktf.stringToHclTerraform(struct!.pqMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.pqOnBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_path: {
      value: cdktf.stringToHclTerraform(struct!.pqPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    protocol: {
      value: cdktf.stringToHclTerraform(struct!.protocol),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    system_fields: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.systemFields),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    throttle_rate_per_sec: {
      value: cdktf.stringToHclTerraform(struct!.throttleRatePerSec),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    write_timeout: {
      value: cdktf.numberToHclTerraform(struct!.writeTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputStatsdExtOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackDestinationOutputStatsdExt | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._connectionTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.connectionTimeout = this._connectionTimeout;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._dnsResolvePeriodSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.dnsResolvePeriodSec = this._dnsResolvePeriodSec;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._flushPeriodSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.flushPeriodSec = this._flushPeriodSec;
    }
    if (this._host !== undefined) {
      hasAnyValues = true;
      internalValueResult.host = this._host;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._mtu !== undefined) {
      hasAnyValues = true;
      internalValueResult.mtu = this._mtu;
    }
    if (this._onBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.onBackpressure = this._onBackpressure;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._pqCompress !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqCompress = this._pqCompress;
    }
    if (this._pqControls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqControls = this._pqControls?.internalValue;
    }
    if (this._pqMaxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxFileSize = this._pqMaxFileSize;
    }
    if (this._pqMaxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxSize = this._pqMaxSize;
    }
    if (this._pqMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMode = this._pqMode;
    }
    if (this._pqOnBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqOnBackpressure = this._pqOnBackpressure;
    }
    if (this._pqPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqPath = this._pqPath;
    }
    if (this._protocol !== undefined) {
      hasAnyValues = true;
      internalValueResult.protocol = this._protocol;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._systemFields !== undefined) {
      hasAnyValues = true;
      internalValueResult.systemFields = this._systemFields;
    }
    if (this._throttleRatePerSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.throttleRatePerSec = this._throttleRatePerSec;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._writeTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.writeTimeout = this._writeTimeout;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputStatsdExt | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._connectionTimeout = undefined;
      this._description = undefined;
      this._dnsResolvePeriodSec = undefined;
      this._environment = undefined;
      this._flushPeriodSec = undefined;
      this._host = undefined;
      this._id = undefined;
      this._mtu = undefined;
      this._onBackpressure = undefined;
      this._pipeline = undefined;
      this._port = undefined;
      this._pqCompress = undefined;
      this._pqControls.internalValue = undefined;
      this._pqMaxFileSize = undefined;
      this._pqMaxSize = undefined;
      this._pqMode = undefined;
      this._pqOnBackpressure = undefined;
      this._pqPath = undefined;
      this._protocol = undefined;
      this._streamtags = undefined;
      this._systemFields = undefined;
      this._throttleRatePerSec = undefined;
      this._type = undefined;
      this._writeTimeout = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._connectionTimeout = value.connectionTimeout;
      this._description = value.description;
      this._dnsResolvePeriodSec = value.dnsResolvePeriodSec;
      this._environment = value.environment;
      this._flushPeriodSec = value.flushPeriodSec;
      this._host = value.host;
      this._id = value.id;
      this._mtu = value.mtu;
      this._onBackpressure = value.onBackpressure;
      this._pipeline = value.pipeline;
      this._port = value.port;
      this._pqCompress = value.pqCompress;
      this._pqControls.internalValue = value.pqControls;
      this._pqMaxFileSize = value.pqMaxFileSize;
      this._pqMaxSize = value.pqMaxSize;
      this._pqMode = value.pqMode;
      this._pqOnBackpressure = value.pqOnBackpressure;
      this._pqPath = value.pqPath;
      this._protocol = value.protocol;
      this._streamtags = value.streamtags;
      this._systemFields = value.systemFields;
      this._throttleRatePerSec = value.throttleRatePerSec;
      this._type = value.type;
      this._writeTimeout = value.writeTimeout;
    }
  }

  // connection_timeout - computed: true, optional: true, required: false
  private _connectionTimeout?: number; 
  public get connectionTimeout() {
    return this.getNumberAttribute('connection_timeout');
  }
  public set connectionTimeout(value: number) {
    this._connectionTimeout = value;
  }
  public resetConnectionTimeout() {
    this._connectionTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectionTimeoutInput() {
    return this._connectionTimeout;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // dns_resolve_period_sec - computed: true, optional: true, required: false
  private _dnsResolvePeriodSec?: number; 
  public get dnsResolvePeriodSec() {
    return this.getNumberAttribute('dns_resolve_period_sec');
  }
  public set dnsResolvePeriodSec(value: number) {
    this._dnsResolvePeriodSec = value;
  }
  public resetDnsResolvePeriodSec() {
    this._dnsResolvePeriodSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dnsResolvePeriodSecInput() {
    return this._dnsResolvePeriodSec;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // flush_period_sec - computed: true, optional: true, required: false
  private _flushPeriodSec?: number; 
  public get flushPeriodSec() {
    return this.getNumberAttribute('flush_period_sec');
  }
  public set flushPeriodSec(value: number) {
    this._flushPeriodSec = value;
  }
  public resetFlushPeriodSec() {
    this._flushPeriodSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get flushPeriodSecInput() {
    return this._flushPeriodSec;
  }

  // host - computed: false, optional: false, required: true
  private _host?: string; 
  public get host() {
    return this.getStringAttribute('host');
  }
  public set host(value: string) {
    this._host = value;
  }
  // Temporarily expose input value. Use with caution.
  public get hostInput() {
    return this._host;
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // mtu - computed: true, optional: true, required: false
  private _mtu?: number; 
  public get mtu() {
    return this.getNumberAttribute('mtu');
  }
  public set mtu(value: number) {
    this._mtu = value;
  }
  public resetMtu() {
    this._mtu = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get mtuInput() {
    return this._mtu;
  }

  // on_backpressure - computed: true, optional: true, required: false
  private _onBackpressure?: string; 
  public get onBackpressure() {
    return this.getStringAttribute('on_backpressure');
  }
  public set onBackpressure(value: string) {
    this._onBackpressure = value;
  }
  public resetOnBackpressure() {
    this._onBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get onBackpressureInput() {
    return this._onBackpressure;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // port - computed: true, optional: true, required: false
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // pq_compress - computed: true, optional: true, required: false
  private _pqCompress?: string; 
  public get pqCompress() {
    return this.getStringAttribute('pq_compress');
  }
  public set pqCompress(value: string) {
    this._pqCompress = value;
  }
  public resetPqCompress() {
    this._pqCompress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqCompressInput() {
    return this._pqCompress;
  }

  // pq_controls - computed: false, optional: true, required: false
  private _pqControls = new PackDestinationOutputStatsdExtPqControlsOutputReference(this, "pq_controls");
  public get pqControls() {
    return this._pqControls;
  }
  public putPqControls(value: PackDestinationOutputStatsdExtPqControls) {
    this._pqControls.internalValue = value;
  }
  public resetPqControls() {
    this._pqControls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqControlsInput() {
    return this._pqControls.internalValue;
  }

  // pq_max_file_size - computed: true, optional: true, required: false
  private _pqMaxFileSize?: string; 
  public get pqMaxFileSize() {
    return this.getStringAttribute('pq_max_file_size');
  }
  public set pqMaxFileSize(value: string) {
    this._pqMaxFileSize = value;
  }
  public resetPqMaxFileSize() {
    this._pqMaxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxFileSizeInput() {
    return this._pqMaxFileSize;
  }

  // pq_max_size - computed: true, optional: true, required: false
  private _pqMaxSize?: string; 
  public get pqMaxSize() {
    return this.getStringAttribute('pq_max_size');
  }
  public set pqMaxSize(value: string) {
    this._pqMaxSize = value;
  }
  public resetPqMaxSize() {
    this._pqMaxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxSizeInput() {
    return this._pqMaxSize;
  }

  // pq_mode - computed: true, optional: true, required: false
  private _pqMode?: string; 
  public get pqMode() {
    return this.getStringAttribute('pq_mode');
  }
  public set pqMode(value: string) {
    this._pqMode = value;
  }
  public resetPqMode() {
    this._pqMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqModeInput() {
    return this._pqMode;
  }

  // pq_on_backpressure - computed: true, optional: true, required: false
  private _pqOnBackpressure?: string; 
  public get pqOnBackpressure() {
    return this.getStringAttribute('pq_on_backpressure');
  }
  public set pqOnBackpressure(value: string) {
    this._pqOnBackpressure = value;
  }
  public resetPqOnBackpressure() {
    this._pqOnBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqOnBackpressureInput() {
    return this._pqOnBackpressure;
  }

  // pq_path - computed: true, optional: true, required: false
  private _pqPath?: string; 
  public get pqPath() {
    return this.getStringAttribute('pq_path');
  }
  public set pqPath(value: string) {
    this._pqPath = value;
  }
  public resetPqPath() {
    this._pqPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqPathInput() {
    return this._pqPath;
  }

  // protocol - computed: true, optional: true, required: false
  private _protocol?: string; 
  public get protocol() {
    return this.getStringAttribute('protocol');
  }
  public set protocol(value: string) {
    this._protocol = value;
  }
  public resetProtocol() {
    this._protocol = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get protocolInput() {
    return this._protocol;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // system_fields - computed: true, optional: true, required: false
  private _systemFields?: string[]; 
  public get systemFields() {
    return this.getListAttribute('system_fields');
  }
  public set systemFields(value: string[]) {
    this._systemFields = value;
  }
  public resetSystemFields() {
    this._systemFields = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get systemFieldsInput() {
    return this._systemFields;
  }

  // throttle_rate_per_sec - computed: true, optional: true, required: false
  private _throttleRatePerSec?: string; 
  public get throttleRatePerSec() {
    return this.getStringAttribute('throttle_rate_per_sec');
  }
  public set throttleRatePerSec(value: string) {
    this._throttleRatePerSec = value;
  }
  public resetThrottleRatePerSec() {
    this._throttleRatePerSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get throttleRatePerSecInput() {
    return this._throttleRatePerSec;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // write_timeout - computed: true, optional: true, required: false
  private _writeTimeout?: number; 
  public get writeTimeout() {
    return this.getNumberAttribute('write_timeout');
  }
  public set writeTimeout(value: number) {
    this._writeTimeout = value;
  }
  public resetWriteTimeout() {
    this._writeTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get writeTimeoutInput() {
    return this._writeTimeout;
  }
}
export interface PackDestinationOutputSumoLogicExtraHttpHeaders {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#name PackDestination#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#value PackDestination#value}
  */
  readonly value: string;
}

export function packDestinationOutputSumoLogicExtraHttpHeadersToTerraform(struct?: PackDestinationOutputSumoLogicExtraHttpHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function packDestinationOutputSumoLogicExtraHttpHeadersToHclTerraform(struct?: PackDestinationOutputSumoLogicExtraHttpHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputSumoLogicExtraHttpHeadersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackDestinationOutputSumoLogicExtraHttpHeaders | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputSumoLogicExtraHttpHeaders | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class PackDestinationOutputSumoLogicExtraHttpHeadersList extends cdktf.ComplexList {
  public internalValue? : PackDestinationOutputSumoLogicExtraHttpHeaders[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackDestinationOutputSumoLogicExtraHttpHeadersOutputReference {
    return new PackDestinationOutputSumoLogicExtraHttpHeadersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackDestinationOutputSumoLogicPqControls {
}

export function packDestinationOutputSumoLogicPqControlsToTerraform(struct?: PackDestinationOutputSumoLogicPqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function packDestinationOutputSumoLogicPqControlsToHclTerraform(struct?: PackDestinationOutputSumoLogicPqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class PackDestinationOutputSumoLogicPqControlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackDestinationOutputSumoLogicPqControls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputSumoLogicPqControls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface PackDestinationOutputSumoLogicResponseRetrySettings {
  /**
  * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc. Default: 2
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#backoff_rate PackDestination#backoff_rate}
  */
  readonly backoffRate?: number;
  /**
  * The HTTP response status code that will trigger retries
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#http_status PackDestination#http_status}
  */
  readonly httpStatus: number;
  /**
  * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes). Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#initial_backoff PackDestination#initial_backoff}
  */
  readonly initialBackoff?: number;
  /**
  * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds). Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_backoff PackDestination#max_backoff}
  */
  readonly maxBackoff?: number;
}

export function packDestinationOutputSumoLogicResponseRetrySettingsToTerraform(struct?: PackDestinationOutputSumoLogicResponseRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    backoff_rate: cdktf.numberToTerraform(struct!.backoffRate),
    http_status: cdktf.numberToTerraform(struct!.httpStatus),
    initial_backoff: cdktf.numberToTerraform(struct!.initialBackoff),
    max_backoff: cdktf.numberToTerraform(struct!.maxBackoff),
  }
}


export function packDestinationOutputSumoLogicResponseRetrySettingsToHclTerraform(struct?: PackDestinationOutputSumoLogicResponseRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    backoff_rate: {
      value: cdktf.numberToHclTerraform(struct!.backoffRate),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    http_status: {
      value: cdktf.numberToHclTerraform(struct!.httpStatus),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    initial_backoff: {
      value: cdktf.numberToHclTerraform(struct!.initialBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_backoff: {
      value: cdktf.numberToHclTerraform(struct!.maxBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputSumoLogicResponseRetrySettingsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackDestinationOutputSumoLogicResponseRetrySettings | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._backoffRate !== undefined) {
      hasAnyValues = true;
      internalValueResult.backoffRate = this._backoffRate;
    }
    if (this._httpStatus !== undefined) {
      hasAnyValues = true;
      internalValueResult.httpStatus = this._httpStatus;
    }
    if (this._initialBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.initialBackoff = this._initialBackoff;
    }
    if (this._maxBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBackoff = this._maxBackoff;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputSumoLogicResponseRetrySettings | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._backoffRate = undefined;
      this._httpStatus = undefined;
      this._initialBackoff = undefined;
      this._maxBackoff = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._backoffRate = value.backoffRate;
      this._httpStatus = value.httpStatus;
      this._initialBackoff = value.initialBackoff;
      this._maxBackoff = value.maxBackoff;
    }
  }

  // backoff_rate - computed: true, optional: true, required: false
  private _backoffRate?: number; 
  public get backoffRate() {
    return this.getNumberAttribute('backoff_rate');
  }
  public set backoffRate(value: number) {
    this._backoffRate = value;
  }
  public resetBackoffRate() {
    this._backoffRate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get backoffRateInput() {
    return this._backoffRate;
  }

  // http_status - computed: false, optional: false, required: true
  private _httpStatus?: number; 
  public get httpStatus() {
    return this.getNumberAttribute('http_status');
  }
  public set httpStatus(value: number) {
    this._httpStatus = value;
  }
  // Temporarily expose input value. Use with caution.
  public get httpStatusInput() {
    return this._httpStatus;
  }

  // initial_backoff - computed: true, optional: true, required: false
  private _initialBackoff?: number; 
  public get initialBackoff() {
    return this.getNumberAttribute('initial_backoff');
  }
  public set initialBackoff(value: number) {
    this._initialBackoff = value;
  }
  public resetInitialBackoff() {
    this._initialBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get initialBackoffInput() {
    return this._initialBackoff;
  }

  // max_backoff - computed: true, optional: true, required: false
  private _maxBackoff?: number; 
  public get maxBackoff() {
    return this.getNumberAttribute('max_backoff');
  }
  public set maxBackoff(value: number) {
    this._maxBackoff = value;
  }
  public resetMaxBackoff() {
    this._maxBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBackoffInput() {
    return this._maxBackoff;
  }
}

export class PackDestinationOutputSumoLogicResponseRetrySettingsList extends cdktf.ComplexList {
  public internalValue? : PackDestinationOutputSumoLogicResponseRetrySettings[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackDestinationOutputSumoLogicResponseRetrySettingsOutputReference {
    return new PackDestinationOutputSumoLogicResponseRetrySettingsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackDestinationOutputSumoLogicTimeoutRetrySettings {
  /**
  * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc. Default: 2
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#backoff_rate PackDestination#backoff_rate}
  */
  readonly backoffRate?: number;
  /**
  * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes). Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#initial_backoff PackDestination#initial_backoff}
  */
  readonly initialBackoff?: number;
  /**
  * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds). Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_backoff PackDestination#max_backoff}
  */
  readonly maxBackoff?: number;
  /**
  * Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#timeout_retry PackDestination#timeout_retry}
  */
  readonly timeoutRetry?: boolean | cdktf.IResolvable;
}

export function packDestinationOutputSumoLogicTimeoutRetrySettingsToTerraform(struct?: PackDestinationOutputSumoLogicTimeoutRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    backoff_rate: cdktf.numberToTerraform(struct!.backoffRate),
    initial_backoff: cdktf.numberToTerraform(struct!.initialBackoff),
    max_backoff: cdktf.numberToTerraform(struct!.maxBackoff),
    timeout_retry: cdktf.booleanToTerraform(struct!.timeoutRetry),
  }
}


export function packDestinationOutputSumoLogicTimeoutRetrySettingsToHclTerraform(struct?: PackDestinationOutputSumoLogicTimeoutRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    backoff_rate: {
      value: cdktf.numberToHclTerraform(struct!.backoffRate),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    initial_backoff: {
      value: cdktf.numberToHclTerraform(struct!.initialBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_backoff: {
      value: cdktf.numberToHclTerraform(struct!.maxBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    timeout_retry: {
      value: cdktf.booleanToHclTerraform(struct!.timeoutRetry),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputSumoLogicTimeoutRetrySettingsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackDestinationOutputSumoLogicTimeoutRetrySettings | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._backoffRate !== undefined) {
      hasAnyValues = true;
      internalValueResult.backoffRate = this._backoffRate;
    }
    if (this._initialBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.initialBackoff = this._initialBackoff;
    }
    if (this._maxBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBackoff = this._maxBackoff;
    }
    if (this._timeoutRetry !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutRetry = this._timeoutRetry;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputSumoLogicTimeoutRetrySettings | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._backoffRate = undefined;
      this._initialBackoff = undefined;
      this._maxBackoff = undefined;
      this._timeoutRetry = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._backoffRate = value.backoffRate;
      this._initialBackoff = value.initialBackoff;
      this._maxBackoff = value.maxBackoff;
      this._timeoutRetry = value.timeoutRetry;
    }
  }

  // backoff_rate - computed: true, optional: true, required: false
  private _backoffRate?: number; 
  public get backoffRate() {
    return this.getNumberAttribute('backoff_rate');
  }
  public set backoffRate(value: number) {
    this._backoffRate = value;
  }
  public resetBackoffRate() {
    this._backoffRate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get backoffRateInput() {
    return this._backoffRate;
  }

  // initial_backoff - computed: true, optional: true, required: false
  private _initialBackoff?: number; 
  public get initialBackoff() {
    return this.getNumberAttribute('initial_backoff');
  }
  public set initialBackoff(value: number) {
    this._initialBackoff = value;
  }
  public resetInitialBackoff() {
    this._initialBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get initialBackoffInput() {
    return this._initialBackoff;
  }

  // max_backoff - computed: true, optional: true, required: false
  private _maxBackoff?: number; 
  public get maxBackoff() {
    return this.getNumberAttribute('max_backoff');
  }
  public set maxBackoff(value: number) {
    this._maxBackoff = value;
  }
  public resetMaxBackoff() {
    this._maxBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBackoffInput() {
    return this._maxBackoff;
  }

  // timeout_retry - computed: true, optional: true, required: false
  private _timeoutRetry?: boolean | cdktf.IResolvable; 
  public get timeoutRetry() {
    return this.getBooleanAttribute('timeout_retry');
  }
  public set timeoutRetry(value: boolean | cdktf.IResolvable) {
    this._timeoutRetry = value;
  }
  public resetTimeoutRetry() {
    this._timeoutRetry = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutRetryInput() {
    return this._timeoutRetry;
  }
}
export interface PackDestinationOutputSumoLogic {
  /**
  * Compress the payload body before sending. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#compress PackDestination#compress}
  */
  readonly compress?: boolean | cdktf.IResolvable;
  /**
  * Maximum number of ongoing requests before blocking. Default: 5
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#concurrency PackDestination#concurrency}
  */
  readonly concurrency?: number;
  /**
  * Override the source category configured on the Sumo Logic HTTP collector. This can also be overridden at the event level with the __sourceCategory field.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#custom_category PackDestination#custom_category}
  */
  readonly customCategory?: string;
  /**
  * Override the source name configured on the Sumo Logic HTTP collector. This can also be overridden at the event level with the __sourceName field.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#custom_source PackDestination#custom_source}
  */
  readonly customSource?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#description PackDestination#description}
  */
  readonly description?: string;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#environment PackDestination#environment}
  */
  readonly environment?: string;
  /**
  * Headers to add to all events
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#extra_http_headers PackDestination#extra_http_headers}
  */
  readonly extraHttpHeaders?: PackDestinationOutputSumoLogicExtraHttpHeaders[] | cdktf.IResolvable;
  /**
  * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below. Default: "none"; must be one of ["payload", "payloadAndHeaders", "none"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#failed_request_logging_mode PackDestination#failed_request_logging_mode}
  */
  readonly failedRequestLoggingMode?: string;
  /**
  * Maximum time between requests. Small values could cause the payload size to be smaller than the configured Body size limit. Default: 1
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#flush_period_sec PackDestination#flush_period_sec}
  */
  readonly flushPeriodSec?: number;
  /**
  * Preserve the raw event format instead of JSONifying it. Default: "json"; must be one of ["json", "raw"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#format PackDestination#format}
  */
  readonly format?: string;
  /**
  * Unique ID for this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#id PackDestination#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * Maximum number of events to include in the request body. Default is 0 (unlimited). Default: 0
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_payload_events PackDestination#max_payload_events}
  */
  readonly maxPayloadEvents?: number;
  /**
  * Maximum size, in KB, of the request body. Default: 1024
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_payload_size_kb PackDestination#max_payload_size_kb}
  */
  readonly maxPayloadSizeKb?: number;
  /**
  * How to handle events when all receivers are exerting backpressure. Default: "block"; must be one of ["block", "drop", "queue"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#on_backpressure PackDestination#on_backpressure}
  */
  readonly onBackpressure?: string;
  /**
  * Pipeline to process data before sending out to this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pipeline PackDestination#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_compress PackDestination#pq_compress}
  */
  readonly pqCompress?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_controls PackDestination#pq_controls}
  */
  readonly pqControls?: PackDestinationOutputSumoLogicPqControls;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.). Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_max_file_size PackDestination#pq_max_file_size}
  */
  readonly pqMaxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_max_size PackDestination#pq_max_size}
  */
  readonly pqMaxSize?: string;
  /**
  * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem. Default: "error"; must be one of ["error", "backpressure", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_mode PackDestination#pq_mode}
  */
  readonly pqMode?: string;
  /**
  * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged. Default: "block"; must be one of ["block", "drop"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_on_backpressure PackDestination#pq_on_backpressure}
  */
  readonly pqOnBackpressure?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_path PackDestination#pq_path}
  */
  readonly pqPath?: string;
  /**
  * Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's). 
  *         Enabled by default. When this setting is also present in TLS Settings (Client Side), 
  *         that value will take precedence.
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#reject_unauthorized PackDestination#reject_unauthorized}
  */
  readonly rejectUnauthorized?: boolean | cdktf.IResolvable;
  /**
  * Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#response_honor_retry_after_header PackDestination#response_honor_retry_after_header}
  */
  readonly responseHonorRetryAfterHeader?: boolean | cdktf.IResolvable;
  /**
  * Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#response_retry_settings PackDestination#response_retry_settings}
  */
  readonly responseRetrySettings?: PackDestinationOutputSumoLogicResponseRetrySettings[] | cdktf.IResolvable;
  /**
  * List of headers that are safe to log in plain text. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#safe_headers PackDestination#safe_headers}
  */
  readonly safeHeaders?: string[];
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#streamtags PackDestination#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Fields to automatically add to events, such as cribl_pipe. Supports wildcards. Default: ["cribl_pipe"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#system_fields PackDestination#system_fields}
  */
  readonly systemFields?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#timeout_retry_settings PackDestination#timeout_retry_settings}
  */
  readonly timeoutRetrySettings?: PackDestinationOutputSumoLogicTimeoutRetrySettings;
  /**
  * Amount of time, in seconds, to wait for a request to complete before canceling it. Default: 30
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#timeout_sec PackDestination#timeout_sec}
  */
  readonly timeoutSec?: number;
  /**
  * Maximum total size of the batches waiting to be sent. If left blank, defaults to 5 times the max body size (if set). If 0, no limit is enforced.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#total_memory_limit_kb PackDestination#total_memory_limit_kb}
  */
  readonly totalMemoryLimitKb?: number;
  /**
  * must be "sumo_logic"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#type PackDestination#type}
  */
  readonly type: string;
  /**
  * Sumo Logic HTTP collector URL to which events should be sent
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#url PackDestination#url}
  */
  readonly url: string;
  /**
  * Enable round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. For optimal performance, consider enabling this setting for non-load balanced destinations. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#use_round_robin_dns PackDestination#use_round_robin_dns}
  */
  readonly useRoundRobinDns?: boolean | cdktf.IResolvable;
}

export function packDestinationOutputSumoLogicToTerraform(struct?: PackDestinationOutputSumoLogic | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    compress: cdktf.booleanToTerraform(struct!.compress),
    concurrency: cdktf.numberToTerraform(struct!.concurrency),
    custom_category: cdktf.stringToTerraform(struct!.customCategory),
    custom_source: cdktf.stringToTerraform(struct!.customSource),
    description: cdktf.stringToTerraform(struct!.description),
    environment: cdktf.stringToTerraform(struct!.environment),
    extra_http_headers: cdktf.listMapper(packDestinationOutputSumoLogicExtraHttpHeadersToTerraform, false)(struct!.extraHttpHeaders),
    failed_request_logging_mode: cdktf.stringToTerraform(struct!.failedRequestLoggingMode),
    flush_period_sec: cdktf.numberToTerraform(struct!.flushPeriodSec),
    format: cdktf.stringToTerraform(struct!.format),
    id: cdktf.stringToTerraform(struct!.id),
    max_payload_events: cdktf.numberToTerraform(struct!.maxPayloadEvents),
    max_payload_size_kb: cdktf.numberToTerraform(struct!.maxPayloadSizeKb),
    on_backpressure: cdktf.stringToTerraform(struct!.onBackpressure),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    pq_compress: cdktf.stringToTerraform(struct!.pqCompress),
    pq_controls: packDestinationOutputSumoLogicPqControlsToTerraform(struct!.pqControls),
    pq_max_file_size: cdktf.stringToTerraform(struct!.pqMaxFileSize),
    pq_max_size: cdktf.stringToTerraform(struct!.pqMaxSize),
    pq_mode: cdktf.stringToTerraform(struct!.pqMode),
    pq_on_backpressure: cdktf.stringToTerraform(struct!.pqOnBackpressure),
    pq_path: cdktf.stringToTerraform(struct!.pqPath),
    reject_unauthorized: cdktf.booleanToTerraform(struct!.rejectUnauthorized),
    response_honor_retry_after_header: cdktf.booleanToTerraform(struct!.responseHonorRetryAfterHeader),
    response_retry_settings: cdktf.listMapper(packDestinationOutputSumoLogicResponseRetrySettingsToTerraform, false)(struct!.responseRetrySettings),
    safe_headers: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.safeHeaders),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    system_fields: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.systemFields),
    timeout_retry_settings: packDestinationOutputSumoLogicTimeoutRetrySettingsToTerraform(struct!.timeoutRetrySettings),
    timeout_sec: cdktf.numberToTerraform(struct!.timeoutSec),
    total_memory_limit_kb: cdktf.numberToTerraform(struct!.totalMemoryLimitKb),
    type: cdktf.stringToTerraform(struct!.type),
    url: cdktf.stringToTerraform(struct!.url),
    use_round_robin_dns: cdktf.booleanToTerraform(struct!.useRoundRobinDns),
  }
}


export function packDestinationOutputSumoLogicToHclTerraform(struct?: PackDestinationOutputSumoLogic | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    compress: {
      value: cdktf.booleanToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    concurrency: {
      value: cdktf.numberToHclTerraform(struct!.concurrency),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    custom_category: {
      value: cdktf.stringToHclTerraform(struct!.customCategory),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    custom_source: {
      value: cdktf.stringToHclTerraform(struct!.customSource),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    extra_http_headers: {
      value: cdktf.listMapperHcl(packDestinationOutputSumoLogicExtraHttpHeadersToHclTerraform, false)(struct!.extraHttpHeaders),
      isBlock: true,
      type: "list",
      storageClassType: "PackDestinationOutputSumoLogicExtraHttpHeadersList",
    },
    failed_request_logging_mode: {
      value: cdktf.stringToHclTerraform(struct!.failedRequestLoggingMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    flush_period_sec: {
      value: cdktf.numberToHclTerraform(struct!.flushPeriodSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    format: {
      value: cdktf.stringToHclTerraform(struct!.format),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_payload_events: {
      value: cdktf.numberToHclTerraform(struct!.maxPayloadEvents),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_payload_size_kb: {
      value: cdktf.numberToHclTerraform(struct!.maxPayloadSizeKb),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.onBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_compress: {
      value: cdktf.stringToHclTerraform(struct!.pqCompress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_controls: {
      value: packDestinationOutputSumoLogicPqControlsToHclTerraform(struct!.pqControls),
      isBlock: true,
      type: "struct",
      storageClassType: "PackDestinationOutputSumoLogicPqControls",
    },
    pq_max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_max_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_mode: {
      value: cdktf.stringToHclTerraform(struct!.pqMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.pqOnBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_path: {
      value: cdktf.stringToHclTerraform(struct!.pqPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reject_unauthorized: {
      value: cdktf.booleanToHclTerraform(struct!.rejectUnauthorized),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    response_honor_retry_after_header: {
      value: cdktf.booleanToHclTerraform(struct!.responseHonorRetryAfterHeader),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    response_retry_settings: {
      value: cdktf.listMapperHcl(packDestinationOutputSumoLogicResponseRetrySettingsToHclTerraform, false)(struct!.responseRetrySettings),
      isBlock: true,
      type: "list",
      storageClassType: "PackDestinationOutputSumoLogicResponseRetrySettingsList",
    },
    safe_headers: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.safeHeaders),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    system_fields: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.systemFields),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    timeout_retry_settings: {
      value: packDestinationOutputSumoLogicTimeoutRetrySettingsToHclTerraform(struct!.timeoutRetrySettings),
      isBlock: true,
      type: "struct",
      storageClassType: "PackDestinationOutputSumoLogicTimeoutRetrySettings",
    },
    timeout_sec: {
      value: cdktf.numberToHclTerraform(struct!.timeoutSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    total_memory_limit_kb: {
      value: cdktf.numberToHclTerraform(struct!.totalMemoryLimitKb),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    url: {
      value: cdktf.stringToHclTerraform(struct!.url),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    use_round_robin_dns: {
      value: cdktf.booleanToHclTerraform(struct!.useRoundRobinDns),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputSumoLogicOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackDestinationOutputSumoLogic | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._concurrency !== undefined) {
      hasAnyValues = true;
      internalValueResult.concurrency = this._concurrency;
    }
    if (this._customCategory !== undefined) {
      hasAnyValues = true;
      internalValueResult.customCategory = this._customCategory;
    }
    if (this._customSource !== undefined) {
      hasAnyValues = true;
      internalValueResult.customSource = this._customSource;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._extraHttpHeaders?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.extraHttpHeaders = this._extraHttpHeaders?.internalValue;
    }
    if (this._failedRequestLoggingMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.failedRequestLoggingMode = this._failedRequestLoggingMode;
    }
    if (this._flushPeriodSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.flushPeriodSec = this._flushPeriodSec;
    }
    if (this._format !== undefined) {
      hasAnyValues = true;
      internalValueResult.format = this._format;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._maxPayloadEvents !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxPayloadEvents = this._maxPayloadEvents;
    }
    if (this._maxPayloadSizeKb !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxPayloadSizeKb = this._maxPayloadSizeKb;
    }
    if (this._onBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.onBackpressure = this._onBackpressure;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._pqCompress !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqCompress = this._pqCompress;
    }
    if (this._pqControls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqControls = this._pqControls?.internalValue;
    }
    if (this._pqMaxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxFileSize = this._pqMaxFileSize;
    }
    if (this._pqMaxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxSize = this._pqMaxSize;
    }
    if (this._pqMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMode = this._pqMode;
    }
    if (this._pqOnBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqOnBackpressure = this._pqOnBackpressure;
    }
    if (this._pqPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqPath = this._pqPath;
    }
    if (this._rejectUnauthorized !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectUnauthorized = this._rejectUnauthorized;
    }
    if (this._responseHonorRetryAfterHeader !== undefined) {
      hasAnyValues = true;
      internalValueResult.responseHonorRetryAfterHeader = this._responseHonorRetryAfterHeader;
    }
    if (this._responseRetrySettings?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.responseRetrySettings = this._responseRetrySettings?.internalValue;
    }
    if (this._safeHeaders !== undefined) {
      hasAnyValues = true;
      internalValueResult.safeHeaders = this._safeHeaders;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._systemFields !== undefined) {
      hasAnyValues = true;
      internalValueResult.systemFields = this._systemFields;
    }
    if (this._timeoutRetrySettings?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutRetrySettings = this._timeoutRetrySettings?.internalValue;
    }
    if (this._timeoutSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutSec = this._timeoutSec;
    }
    if (this._totalMemoryLimitKb !== undefined) {
      hasAnyValues = true;
      internalValueResult.totalMemoryLimitKb = this._totalMemoryLimitKb;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._url !== undefined) {
      hasAnyValues = true;
      internalValueResult.url = this._url;
    }
    if (this._useRoundRobinDns !== undefined) {
      hasAnyValues = true;
      internalValueResult.useRoundRobinDns = this._useRoundRobinDns;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputSumoLogic | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._compress = undefined;
      this._concurrency = undefined;
      this._customCategory = undefined;
      this._customSource = undefined;
      this._description = undefined;
      this._environment = undefined;
      this._extraHttpHeaders.internalValue = undefined;
      this._failedRequestLoggingMode = undefined;
      this._flushPeriodSec = undefined;
      this._format = undefined;
      this._id = undefined;
      this._maxPayloadEvents = undefined;
      this._maxPayloadSizeKb = undefined;
      this._onBackpressure = undefined;
      this._pipeline = undefined;
      this._pqCompress = undefined;
      this._pqControls.internalValue = undefined;
      this._pqMaxFileSize = undefined;
      this._pqMaxSize = undefined;
      this._pqMode = undefined;
      this._pqOnBackpressure = undefined;
      this._pqPath = undefined;
      this._rejectUnauthorized = undefined;
      this._responseHonorRetryAfterHeader = undefined;
      this._responseRetrySettings.internalValue = undefined;
      this._safeHeaders = undefined;
      this._streamtags = undefined;
      this._systemFields = undefined;
      this._timeoutRetrySettings.internalValue = undefined;
      this._timeoutSec = undefined;
      this._totalMemoryLimitKb = undefined;
      this._type = undefined;
      this._url = undefined;
      this._useRoundRobinDns = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._compress = value.compress;
      this._concurrency = value.concurrency;
      this._customCategory = value.customCategory;
      this._customSource = value.customSource;
      this._description = value.description;
      this._environment = value.environment;
      this._extraHttpHeaders.internalValue = value.extraHttpHeaders;
      this._failedRequestLoggingMode = value.failedRequestLoggingMode;
      this._flushPeriodSec = value.flushPeriodSec;
      this._format = value.format;
      this._id = value.id;
      this._maxPayloadEvents = value.maxPayloadEvents;
      this._maxPayloadSizeKb = value.maxPayloadSizeKb;
      this._onBackpressure = value.onBackpressure;
      this._pipeline = value.pipeline;
      this._pqCompress = value.pqCompress;
      this._pqControls.internalValue = value.pqControls;
      this._pqMaxFileSize = value.pqMaxFileSize;
      this._pqMaxSize = value.pqMaxSize;
      this._pqMode = value.pqMode;
      this._pqOnBackpressure = value.pqOnBackpressure;
      this._pqPath = value.pqPath;
      this._rejectUnauthorized = value.rejectUnauthorized;
      this._responseHonorRetryAfterHeader = value.responseHonorRetryAfterHeader;
      this._responseRetrySettings.internalValue = value.responseRetrySettings;
      this._safeHeaders = value.safeHeaders;
      this._streamtags = value.streamtags;
      this._systemFields = value.systemFields;
      this._timeoutRetrySettings.internalValue = value.timeoutRetrySettings;
      this._timeoutSec = value.timeoutSec;
      this._totalMemoryLimitKb = value.totalMemoryLimitKb;
      this._type = value.type;
      this._url = value.url;
      this._useRoundRobinDns = value.useRoundRobinDns;
    }
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: boolean | cdktf.IResolvable; 
  public get compress() {
    return this.getBooleanAttribute('compress');
  }
  public set compress(value: boolean | cdktf.IResolvable) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // concurrency - computed: true, optional: true, required: false
  private _concurrency?: number; 
  public get concurrency() {
    return this.getNumberAttribute('concurrency');
  }
  public set concurrency(value: number) {
    this._concurrency = value;
  }
  public resetConcurrency() {
    this._concurrency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get concurrencyInput() {
    return this._concurrency;
  }

  // custom_category - computed: false, optional: true, required: false
  private _customCategory?: string; 
  public get customCategory() {
    return this.getStringAttribute('custom_category');
  }
  public set customCategory(value: string) {
    this._customCategory = value;
  }
  public resetCustomCategory() {
    this._customCategory = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get customCategoryInput() {
    return this._customCategory;
  }

  // custom_source - computed: false, optional: true, required: false
  private _customSource?: string; 
  public get customSource() {
    return this.getStringAttribute('custom_source');
  }
  public set customSource(value: string) {
    this._customSource = value;
  }
  public resetCustomSource() {
    this._customSource = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get customSourceInput() {
    return this._customSource;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // extra_http_headers - computed: false, optional: true, required: false
  private _extraHttpHeaders = new PackDestinationOutputSumoLogicExtraHttpHeadersList(this, "extra_http_headers", false);
  public get extraHttpHeaders() {
    return this._extraHttpHeaders;
  }
  public putExtraHttpHeaders(value: PackDestinationOutputSumoLogicExtraHttpHeaders[] | cdktf.IResolvable) {
    this._extraHttpHeaders.internalValue = value;
  }
  public resetExtraHttpHeaders() {
    this._extraHttpHeaders.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get extraHttpHeadersInput() {
    return this._extraHttpHeaders.internalValue;
  }

  // failed_request_logging_mode - computed: true, optional: true, required: false
  private _failedRequestLoggingMode?: string; 
  public get failedRequestLoggingMode() {
    return this.getStringAttribute('failed_request_logging_mode');
  }
  public set failedRequestLoggingMode(value: string) {
    this._failedRequestLoggingMode = value;
  }
  public resetFailedRequestLoggingMode() {
    this._failedRequestLoggingMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get failedRequestLoggingModeInput() {
    return this._failedRequestLoggingMode;
  }

  // flush_period_sec - computed: true, optional: true, required: false
  private _flushPeriodSec?: number; 
  public get flushPeriodSec() {
    return this.getNumberAttribute('flush_period_sec');
  }
  public set flushPeriodSec(value: number) {
    this._flushPeriodSec = value;
  }
  public resetFlushPeriodSec() {
    this._flushPeriodSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get flushPeriodSecInput() {
    return this._flushPeriodSec;
  }

  // format - computed: true, optional: true, required: false
  private _format?: string; 
  public get format() {
    return this.getStringAttribute('format');
  }
  public set format(value: string) {
    this._format = value;
  }
  public resetFormat() {
    this._format = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get formatInput() {
    return this._format;
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // max_payload_events - computed: true, optional: true, required: false
  private _maxPayloadEvents?: number; 
  public get maxPayloadEvents() {
    return this.getNumberAttribute('max_payload_events');
  }
  public set maxPayloadEvents(value: number) {
    this._maxPayloadEvents = value;
  }
  public resetMaxPayloadEvents() {
    this._maxPayloadEvents = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxPayloadEventsInput() {
    return this._maxPayloadEvents;
  }

  // max_payload_size_kb - computed: true, optional: true, required: false
  private _maxPayloadSizeKb?: number; 
  public get maxPayloadSizeKb() {
    return this.getNumberAttribute('max_payload_size_kb');
  }
  public set maxPayloadSizeKb(value: number) {
    this._maxPayloadSizeKb = value;
  }
  public resetMaxPayloadSizeKb() {
    this._maxPayloadSizeKb = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxPayloadSizeKbInput() {
    return this._maxPayloadSizeKb;
  }

  // on_backpressure - computed: true, optional: true, required: false
  private _onBackpressure?: string; 
  public get onBackpressure() {
    return this.getStringAttribute('on_backpressure');
  }
  public set onBackpressure(value: string) {
    this._onBackpressure = value;
  }
  public resetOnBackpressure() {
    this._onBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get onBackpressureInput() {
    return this._onBackpressure;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // pq_compress - computed: true, optional: true, required: false
  private _pqCompress?: string; 
  public get pqCompress() {
    return this.getStringAttribute('pq_compress');
  }
  public set pqCompress(value: string) {
    this._pqCompress = value;
  }
  public resetPqCompress() {
    this._pqCompress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqCompressInput() {
    return this._pqCompress;
  }

  // pq_controls - computed: false, optional: true, required: false
  private _pqControls = new PackDestinationOutputSumoLogicPqControlsOutputReference(this, "pq_controls");
  public get pqControls() {
    return this._pqControls;
  }
  public putPqControls(value: PackDestinationOutputSumoLogicPqControls) {
    this._pqControls.internalValue = value;
  }
  public resetPqControls() {
    this._pqControls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqControlsInput() {
    return this._pqControls.internalValue;
  }

  // pq_max_file_size - computed: true, optional: true, required: false
  private _pqMaxFileSize?: string; 
  public get pqMaxFileSize() {
    return this.getStringAttribute('pq_max_file_size');
  }
  public set pqMaxFileSize(value: string) {
    this._pqMaxFileSize = value;
  }
  public resetPqMaxFileSize() {
    this._pqMaxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxFileSizeInput() {
    return this._pqMaxFileSize;
  }

  // pq_max_size - computed: true, optional: true, required: false
  private _pqMaxSize?: string; 
  public get pqMaxSize() {
    return this.getStringAttribute('pq_max_size');
  }
  public set pqMaxSize(value: string) {
    this._pqMaxSize = value;
  }
  public resetPqMaxSize() {
    this._pqMaxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxSizeInput() {
    return this._pqMaxSize;
  }

  // pq_mode - computed: true, optional: true, required: false
  private _pqMode?: string; 
  public get pqMode() {
    return this.getStringAttribute('pq_mode');
  }
  public set pqMode(value: string) {
    this._pqMode = value;
  }
  public resetPqMode() {
    this._pqMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqModeInput() {
    return this._pqMode;
  }

  // pq_on_backpressure - computed: true, optional: true, required: false
  private _pqOnBackpressure?: string; 
  public get pqOnBackpressure() {
    return this.getStringAttribute('pq_on_backpressure');
  }
  public set pqOnBackpressure(value: string) {
    this._pqOnBackpressure = value;
  }
  public resetPqOnBackpressure() {
    this._pqOnBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqOnBackpressureInput() {
    return this._pqOnBackpressure;
  }

  // pq_path - computed: true, optional: true, required: false
  private _pqPath?: string; 
  public get pqPath() {
    return this.getStringAttribute('pq_path');
  }
  public set pqPath(value: string) {
    this._pqPath = value;
  }
  public resetPqPath() {
    this._pqPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqPathInput() {
    return this._pqPath;
  }

  // reject_unauthorized - computed: true, optional: true, required: false
  private _rejectUnauthorized?: boolean | cdktf.IResolvable; 
  public get rejectUnauthorized() {
    return this.getBooleanAttribute('reject_unauthorized');
  }
  public set rejectUnauthorized(value: boolean | cdktf.IResolvable) {
    this._rejectUnauthorized = value;
  }
  public resetRejectUnauthorized() {
    this._rejectUnauthorized = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectUnauthorizedInput() {
    return this._rejectUnauthorized;
  }

  // response_honor_retry_after_header - computed: true, optional: true, required: false
  private _responseHonorRetryAfterHeader?: boolean | cdktf.IResolvable; 
  public get responseHonorRetryAfterHeader() {
    return this.getBooleanAttribute('response_honor_retry_after_header');
  }
  public set responseHonorRetryAfterHeader(value: boolean | cdktf.IResolvable) {
    this._responseHonorRetryAfterHeader = value;
  }
  public resetResponseHonorRetryAfterHeader() {
    this._responseHonorRetryAfterHeader = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get responseHonorRetryAfterHeaderInput() {
    return this._responseHonorRetryAfterHeader;
  }

  // response_retry_settings - computed: false, optional: true, required: false
  private _responseRetrySettings = new PackDestinationOutputSumoLogicResponseRetrySettingsList(this, "response_retry_settings", false);
  public get responseRetrySettings() {
    return this._responseRetrySettings;
  }
  public putResponseRetrySettings(value: PackDestinationOutputSumoLogicResponseRetrySettings[] | cdktf.IResolvable) {
    this._responseRetrySettings.internalValue = value;
  }
  public resetResponseRetrySettings() {
    this._responseRetrySettings.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get responseRetrySettingsInput() {
    return this._responseRetrySettings.internalValue;
  }

  // safe_headers - computed: true, optional: true, required: false
  private _safeHeaders?: string[]; 
  public get safeHeaders() {
    return this.getListAttribute('safe_headers');
  }
  public set safeHeaders(value: string[]) {
    this._safeHeaders = value;
  }
  public resetSafeHeaders() {
    this._safeHeaders = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get safeHeadersInput() {
    return this._safeHeaders;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // system_fields - computed: true, optional: true, required: false
  private _systemFields?: string[]; 
  public get systemFields() {
    return this.getListAttribute('system_fields');
  }
  public set systemFields(value: string[]) {
    this._systemFields = value;
  }
  public resetSystemFields() {
    this._systemFields = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get systemFieldsInput() {
    return this._systemFields;
  }

  // timeout_retry_settings - computed: false, optional: true, required: false
  private _timeoutRetrySettings = new PackDestinationOutputSumoLogicTimeoutRetrySettingsOutputReference(this, "timeout_retry_settings");
  public get timeoutRetrySettings() {
    return this._timeoutRetrySettings;
  }
  public putTimeoutRetrySettings(value: PackDestinationOutputSumoLogicTimeoutRetrySettings) {
    this._timeoutRetrySettings.internalValue = value;
  }
  public resetTimeoutRetrySettings() {
    this._timeoutRetrySettings.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutRetrySettingsInput() {
    return this._timeoutRetrySettings.internalValue;
  }

  // timeout_sec - computed: true, optional: true, required: false
  private _timeoutSec?: number; 
  public get timeoutSec() {
    return this.getNumberAttribute('timeout_sec');
  }
  public set timeoutSec(value: number) {
    this._timeoutSec = value;
  }
  public resetTimeoutSec() {
    this._timeoutSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutSecInput() {
    return this._timeoutSec;
  }

  // total_memory_limit_kb - computed: false, optional: true, required: false
  private _totalMemoryLimitKb?: number; 
  public get totalMemoryLimitKb() {
    return this.getNumberAttribute('total_memory_limit_kb');
  }
  public set totalMemoryLimitKb(value: number) {
    this._totalMemoryLimitKb = value;
  }
  public resetTotalMemoryLimitKb() {
    this._totalMemoryLimitKb = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get totalMemoryLimitKbInput() {
    return this._totalMemoryLimitKb;
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // url - computed: false, optional: false, required: true
  private _url?: string; 
  public get url() {
    return this.getStringAttribute('url');
  }
  public set url(value: string) {
    this._url = value;
  }
  // Temporarily expose input value. Use with caution.
  public get urlInput() {
    return this._url;
  }

  // use_round_robin_dns - computed: true, optional: true, required: false
  private _useRoundRobinDns?: boolean | cdktf.IResolvable; 
  public get useRoundRobinDns() {
    return this.getBooleanAttribute('use_round_robin_dns');
  }
  public set useRoundRobinDns(value: boolean | cdktf.IResolvable) {
    this._useRoundRobinDns = value;
  }
  public resetUseRoundRobinDns() {
    this._useRoundRobinDns = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get useRoundRobinDnsInput() {
    return this._useRoundRobinDns;
  }
}
export interface PackDestinationOutputSyslogPqControls {
}

export function packDestinationOutputSyslogPqControlsToTerraform(struct?: PackDestinationOutputSyslogPqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function packDestinationOutputSyslogPqControlsToHclTerraform(struct?: PackDestinationOutputSyslogPqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class PackDestinationOutputSyslogPqControlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackDestinationOutputSyslogPqControls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputSyslogPqControls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface PackDestinationOutputSyslogTls {
  /**
  * Path on client in which to find CA certificates to verify the server's cert. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#ca_path PackDestination#ca_path}
  */
  readonly caPath?: string;
  /**
  * Path on client in which to find certificates to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#cert_path PackDestination#cert_path}
  */
  readonly certPath?: string;
  /**
  * The name of the predefined certificate
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#certificate_name PackDestination#certificate_name}
  */
  readonly certificateName?: string;
  /**
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#disabled PackDestination#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_version PackDestination#max_version}
  */
  readonly maxVersion?: string;
  /**
  * must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#min_version PackDestination#min_version}
  */
  readonly minVersion?: string;
  /**
  * Passphrase to use to decrypt private key
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#passphrase PackDestination#passphrase}
  */
  readonly passphrase?: string;
  /**
  * Path on client in which to find the private key to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#priv_key_path PackDestination#priv_key_path}
  */
  readonly privKeyPath?: string;
  /**
  * Reject certificates that are not authorized by a CA in the CA certificate path, or by another 
  *                     trusted CA (such as the system's). Defaults to Enabled. Overrides the toggle from Advanced Settings, when also present.
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#reject_unauthorized PackDestination#reject_unauthorized}
  */
  readonly rejectUnauthorized?: boolean | cdktf.IResolvable;
  /**
  * Server name for the SNI (Server Name Indication) TLS extension. It must be a host name, and not an IP address.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#servername PackDestination#servername}
  */
  readonly servername?: string;
}

export function packDestinationOutputSyslogTlsToTerraform(struct?: PackDestinationOutputSyslogTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ca_path: cdktf.stringToTerraform(struct!.caPath),
    cert_path: cdktf.stringToTerraform(struct!.certPath),
    certificate_name: cdktf.stringToTerraform(struct!.certificateName),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    max_version: cdktf.stringToTerraform(struct!.maxVersion),
    min_version: cdktf.stringToTerraform(struct!.minVersion),
    passphrase: cdktf.stringToTerraform(struct!.passphrase),
    priv_key_path: cdktf.stringToTerraform(struct!.privKeyPath),
    reject_unauthorized: cdktf.booleanToTerraform(struct!.rejectUnauthorized),
    servername: cdktf.stringToTerraform(struct!.servername),
  }
}


export function packDestinationOutputSyslogTlsToHclTerraform(struct?: PackDestinationOutputSyslogTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ca_path: {
      value: cdktf.stringToHclTerraform(struct!.caPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    cert_path: {
      value: cdktf.stringToHclTerraform(struct!.certPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    certificate_name: {
      value: cdktf.stringToHclTerraform(struct!.certificateName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    max_version: {
      value: cdktf.stringToHclTerraform(struct!.maxVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    min_version: {
      value: cdktf.stringToHclTerraform(struct!.minVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    passphrase: {
      value: cdktf.stringToHclTerraform(struct!.passphrase),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    priv_key_path: {
      value: cdktf.stringToHclTerraform(struct!.privKeyPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reject_unauthorized: {
      value: cdktf.booleanToHclTerraform(struct!.rejectUnauthorized),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    servername: {
      value: cdktf.stringToHclTerraform(struct!.servername),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputSyslogTlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackDestinationOutputSyslogTls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._caPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.caPath = this._caPath;
    }
    if (this._certPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.certPath = this._certPath;
    }
    if (this._certificateName !== undefined) {
      hasAnyValues = true;
      internalValueResult.certificateName = this._certificateName;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._maxVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxVersion = this._maxVersion;
    }
    if (this._minVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.minVersion = this._minVersion;
    }
    if (this._passphrase !== undefined) {
      hasAnyValues = true;
      internalValueResult.passphrase = this._passphrase;
    }
    if (this._privKeyPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.privKeyPath = this._privKeyPath;
    }
    if (this._rejectUnauthorized !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectUnauthorized = this._rejectUnauthorized;
    }
    if (this._servername !== undefined) {
      hasAnyValues = true;
      internalValueResult.servername = this._servername;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputSyslogTls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._caPath = undefined;
      this._certPath = undefined;
      this._certificateName = undefined;
      this._disabled = undefined;
      this._maxVersion = undefined;
      this._minVersion = undefined;
      this._passphrase = undefined;
      this._privKeyPath = undefined;
      this._rejectUnauthorized = undefined;
      this._servername = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._caPath = value.caPath;
      this._certPath = value.certPath;
      this._certificateName = value.certificateName;
      this._disabled = value.disabled;
      this._maxVersion = value.maxVersion;
      this._minVersion = value.minVersion;
      this._passphrase = value.passphrase;
      this._privKeyPath = value.privKeyPath;
      this._rejectUnauthorized = value.rejectUnauthorized;
      this._servername = value.servername;
    }
  }

  // ca_path - computed: false, optional: true, required: false
  private _caPath?: string; 
  public get caPath() {
    return this.getStringAttribute('ca_path');
  }
  public set caPath(value: string) {
    this._caPath = value;
  }
  public resetCaPath() {
    this._caPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get caPathInput() {
    return this._caPath;
  }

  // cert_path - computed: false, optional: true, required: false
  private _certPath?: string; 
  public get certPath() {
    return this.getStringAttribute('cert_path');
  }
  public set certPath(value: string) {
    this._certPath = value;
  }
  public resetCertPath() {
    this._certPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certPathInput() {
    return this._certPath;
  }

  // certificate_name - computed: false, optional: true, required: false
  private _certificateName?: string; 
  public get certificateName() {
    return this.getStringAttribute('certificate_name');
  }
  public set certificateName(value: string) {
    this._certificateName = value;
  }
  public resetCertificateName() {
    this._certificateName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certificateNameInput() {
    return this._certificateName;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // max_version - computed: false, optional: true, required: false
  private _maxVersion?: string; 
  public get maxVersion() {
    return this.getStringAttribute('max_version');
  }
  public set maxVersion(value: string) {
    this._maxVersion = value;
  }
  public resetMaxVersion() {
    this._maxVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxVersionInput() {
    return this._maxVersion;
  }

  // min_version - computed: false, optional: true, required: false
  private _minVersion?: string; 
  public get minVersion() {
    return this.getStringAttribute('min_version');
  }
  public set minVersion(value: string) {
    this._minVersion = value;
  }
  public resetMinVersion() {
    this._minVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get minVersionInput() {
    return this._minVersion;
  }

  // passphrase - computed: false, optional: true, required: false
  private _passphrase?: string; 
  public get passphrase() {
    return this.getStringAttribute('passphrase');
  }
  public set passphrase(value: string) {
    this._passphrase = value;
  }
  public resetPassphrase() {
    this._passphrase = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passphraseInput() {
    return this._passphrase;
  }

  // priv_key_path - computed: false, optional: true, required: false
  private _privKeyPath?: string; 
  public get privKeyPath() {
    return this.getStringAttribute('priv_key_path');
  }
  public set privKeyPath(value: string) {
    this._privKeyPath = value;
  }
  public resetPrivKeyPath() {
    this._privKeyPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get privKeyPathInput() {
    return this._privKeyPath;
  }

  // reject_unauthorized - computed: true, optional: true, required: false
  private _rejectUnauthorized?: boolean | cdktf.IResolvable; 
  public get rejectUnauthorized() {
    return this.getBooleanAttribute('reject_unauthorized');
  }
  public set rejectUnauthorized(value: boolean | cdktf.IResolvable) {
    this._rejectUnauthorized = value;
  }
  public resetRejectUnauthorized() {
    this._rejectUnauthorized = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectUnauthorizedInput() {
    return this._rejectUnauthorized;
  }

  // servername - computed: false, optional: true, required: false
  private _servername?: string; 
  public get servername() {
    return this.getStringAttribute('servername');
  }
  public set servername(value: string) {
    this._servername = value;
  }
  public resetServername() {
    this._servername = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get servernameInput() {
    return this._servername;
  }
}
export interface PackDestinationOutputSyslog {
  /**
  * Default name for device or application that originated the message. Defaults to Cribl, but will be overwritten by value of __appname if set. Default: "Cribl"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#app_name PackDestination#app_name}
  */
  readonly appName?: string;
  /**
  * Amount of time (milliseconds) to wait for the connection to establish before retrying. Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#connection_timeout PackDestination#connection_timeout}
  */
  readonly connectionTimeout?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#description PackDestination#description}
  */
  readonly description?: string;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#environment PackDestination#environment}
  */
  readonly environment?: string;
  /**
  * Default value for message facility. Will be overwritten by value of __facility if set. Defaults to user. Default: 1; must be one of ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "20", "21"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#facility PackDestination#facility}
  */
  readonly facility?: number;
  /**
  * The hostname of the receiver
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#host PackDestination#host}
  */
  readonly host?: string;
  /**
  * Unique ID for this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#id PackDestination#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id: string;
  /**
  * For optimal performance, enable load balancing even if you have one hostname, as it can expand to multiple IPs.  If this setting is disabled, consider enabling round-robin DNS. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#load_balanced PackDestination#load_balanced}
  */
  readonly loadBalanced?: boolean | cdktf.IResolvable;
  /**
  * Use to troubleshoot issues with sending data. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#log_failed_requests PackDestination#log_failed_requests}
  */
  readonly logFailedRequests?: boolean | cdktf.IResolvable;
  /**
  * Maximum size of syslog messages. Make sure this value is less than or equal to the MTU to avoid UDP packet fragmentation. Default: 1500
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_record_size PackDestination#max_record_size}
  */
  readonly maxRecordSize?: number;
  /**
  * The syslog message format depending on the receiver's support. Default: "rfc3164"; must be one of ["rfc3164", "rfc5424"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#message_format PackDestination#message_format}
  */
  readonly messageFormat?: string;
  /**
  * Prefix messages with the byte count of the message. If disabled, no prefix will be set, and the message will be appended with a \n.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#octet_count_framing PackDestination#octet_count_framing}
  */
  readonly octetCountFraming?: boolean | cdktf.IResolvable;
  /**
  * How to handle events when all receivers are exerting backpressure. Default: "block"; must be one of ["block", "drop", "queue"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#on_backpressure PackDestination#on_backpressure}
  */
  readonly onBackpressure?: string;
  /**
  * Pipeline to process data before sending out to this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pipeline PackDestination#pipeline}
  */
  readonly pipeline?: string;
  /**
  * The port to connect to on the provided host
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#port PackDestination#port}
  */
  readonly port?: number;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_compress PackDestination#pq_compress}
  */
  readonly pqCompress?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_controls PackDestination#pq_controls}
  */
  readonly pqControls?: PackDestinationOutputSyslogPqControls;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.). Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_max_file_size PackDestination#pq_max_file_size}
  */
  readonly pqMaxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_max_size PackDestination#pq_max_size}
  */
  readonly pqMaxSize?: string;
  /**
  * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem. Default: "error"; must be one of ["error", "backpressure", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_mode PackDestination#pq_mode}
  */
  readonly pqMode?: string;
  /**
  * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged. Default: "block"; must be one of ["block", "drop"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_on_backpressure PackDestination#pq_on_backpressure}
  */
  readonly pqOnBackpressure?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_path PackDestination#pq_path}
  */
  readonly pqPath?: string;
  /**
  * The network protocol to use for sending out syslog messages. Default: "tcp"; must be one of ["tcp", "udp"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#protocol PackDestination#protocol}
  */
  readonly protocol?: string;
  /**
  * Default value for message severity. Will be overwritten by value of __severity if set. Defaults to notice. Default: 5; must be one of ["0", "1", "2", "3", "4", "5", "6", "7"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#severity PackDestination#severity}
  */
  readonly severity?: number;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#streamtags PackDestination#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Fields to automatically add to events, such as cribl_pipe. Supports wildcards. Default: ["cribl_pipe"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#system_fields PackDestination#system_fields}
  */
  readonly systemFields?: string[];
  /**
  * Rate (in bytes per second) to throttle while writing to an output. Accepts values with multiple-byte units, such as KB, MB, and GB. (Example: 42 MB) Default value of 0 specifies no throttling. Default: "0"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#throttle_rate_per_sec PackDestination#throttle_rate_per_sec}
  */
  readonly throttleRatePerSec?: string;
  /**
  * Timestamp format to use when serializing event's time field. Default: "syslog"; must be one of ["syslog", "iso8601"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#timestamp_format PackDestination#timestamp_format}
  */
  readonly timestampFormat?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#tls PackDestination#tls}
  */
  readonly tls?: PackDestinationOutputSyslogTls;
  /**
  * must be "syslog"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#type PackDestination#type}
  */
  readonly type: string;
  /**
  * How often to resolve the destination hostname to an IP address. Ignored if the destination is an IP address. A value of 0 means every message sent will incur a DNS lookup. Default: 0
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#udp_dns_resolve_period_sec PackDestination#udp_dns_resolve_period_sec}
  */
  readonly udpDnsResolvePeriodSec?: number;
  /**
  * Amount of time (milliseconds) to wait for a write to complete before assuming connection is dead. Default: 60000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#write_timeout PackDestination#write_timeout}
  */
  readonly writeTimeout?: number;
}

export function packDestinationOutputSyslogToTerraform(struct?: PackDestinationOutputSyslog | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    app_name: cdktf.stringToTerraform(struct!.appName),
    connection_timeout: cdktf.numberToTerraform(struct!.connectionTimeout),
    description: cdktf.stringToTerraform(struct!.description),
    environment: cdktf.stringToTerraform(struct!.environment),
    facility: cdktf.numberToTerraform(struct!.facility),
    host: cdktf.stringToTerraform(struct!.host),
    id: cdktf.stringToTerraform(struct!.id),
    load_balanced: cdktf.booleanToTerraform(struct!.loadBalanced),
    log_failed_requests: cdktf.booleanToTerraform(struct!.logFailedRequests),
    max_record_size: cdktf.numberToTerraform(struct!.maxRecordSize),
    message_format: cdktf.stringToTerraform(struct!.messageFormat),
    octet_count_framing: cdktf.booleanToTerraform(struct!.octetCountFraming),
    on_backpressure: cdktf.stringToTerraform(struct!.onBackpressure),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    port: cdktf.numberToTerraform(struct!.port),
    pq_compress: cdktf.stringToTerraform(struct!.pqCompress),
    pq_controls: packDestinationOutputSyslogPqControlsToTerraform(struct!.pqControls),
    pq_max_file_size: cdktf.stringToTerraform(struct!.pqMaxFileSize),
    pq_max_size: cdktf.stringToTerraform(struct!.pqMaxSize),
    pq_mode: cdktf.stringToTerraform(struct!.pqMode),
    pq_on_backpressure: cdktf.stringToTerraform(struct!.pqOnBackpressure),
    pq_path: cdktf.stringToTerraform(struct!.pqPath),
    protocol: cdktf.stringToTerraform(struct!.protocol),
    severity: cdktf.numberToTerraform(struct!.severity),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    system_fields: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.systemFields),
    throttle_rate_per_sec: cdktf.stringToTerraform(struct!.throttleRatePerSec),
    timestamp_format: cdktf.stringToTerraform(struct!.timestampFormat),
    tls: packDestinationOutputSyslogTlsToTerraform(struct!.tls),
    type: cdktf.stringToTerraform(struct!.type),
    udp_dns_resolve_period_sec: cdktf.numberToTerraform(struct!.udpDnsResolvePeriodSec),
    write_timeout: cdktf.numberToTerraform(struct!.writeTimeout),
  }
}


export function packDestinationOutputSyslogToHclTerraform(struct?: PackDestinationOutputSyslog | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    app_name: {
      value: cdktf.stringToHclTerraform(struct!.appName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    connection_timeout: {
      value: cdktf.numberToHclTerraform(struct!.connectionTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    facility: {
      value: cdktf.numberToHclTerraform(struct!.facility),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    host: {
      value: cdktf.stringToHclTerraform(struct!.host),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    load_balanced: {
      value: cdktf.booleanToHclTerraform(struct!.loadBalanced),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    log_failed_requests: {
      value: cdktf.booleanToHclTerraform(struct!.logFailedRequests),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    max_record_size: {
      value: cdktf.numberToHclTerraform(struct!.maxRecordSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    message_format: {
      value: cdktf.stringToHclTerraform(struct!.messageFormat),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    octet_count_framing: {
      value: cdktf.booleanToHclTerraform(struct!.octetCountFraming),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.onBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    pq_compress: {
      value: cdktf.stringToHclTerraform(struct!.pqCompress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_controls: {
      value: packDestinationOutputSyslogPqControlsToHclTerraform(struct!.pqControls),
      isBlock: true,
      type: "struct",
      storageClassType: "PackDestinationOutputSyslogPqControls",
    },
    pq_max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_max_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_mode: {
      value: cdktf.stringToHclTerraform(struct!.pqMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.pqOnBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_path: {
      value: cdktf.stringToHclTerraform(struct!.pqPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    protocol: {
      value: cdktf.stringToHclTerraform(struct!.protocol),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    severity: {
      value: cdktf.numberToHclTerraform(struct!.severity),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    system_fields: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.systemFields),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    throttle_rate_per_sec: {
      value: cdktf.stringToHclTerraform(struct!.throttleRatePerSec),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    timestamp_format: {
      value: cdktf.stringToHclTerraform(struct!.timestampFormat),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tls: {
      value: packDestinationOutputSyslogTlsToHclTerraform(struct!.tls),
      isBlock: true,
      type: "struct",
      storageClassType: "PackDestinationOutputSyslogTls",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    udp_dns_resolve_period_sec: {
      value: cdktf.numberToHclTerraform(struct!.udpDnsResolvePeriodSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    write_timeout: {
      value: cdktf.numberToHclTerraform(struct!.writeTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputSyslogOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackDestinationOutputSyslog | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._appName !== undefined) {
      hasAnyValues = true;
      internalValueResult.appName = this._appName;
    }
    if (this._connectionTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.connectionTimeout = this._connectionTimeout;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._facility !== undefined) {
      hasAnyValues = true;
      internalValueResult.facility = this._facility;
    }
    if (this._host !== undefined) {
      hasAnyValues = true;
      internalValueResult.host = this._host;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._loadBalanced !== undefined) {
      hasAnyValues = true;
      internalValueResult.loadBalanced = this._loadBalanced;
    }
    if (this._logFailedRequests !== undefined) {
      hasAnyValues = true;
      internalValueResult.logFailedRequests = this._logFailedRequests;
    }
    if (this._maxRecordSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxRecordSize = this._maxRecordSize;
    }
    if (this._messageFormat !== undefined) {
      hasAnyValues = true;
      internalValueResult.messageFormat = this._messageFormat;
    }
    if (this._octetCountFraming !== undefined) {
      hasAnyValues = true;
      internalValueResult.octetCountFraming = this._octetCountFraming;
    }
    if (this._onBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.onBackpressure = this._onBackpressure;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._pqCompress !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqCompress = this._pqCompress;
    }
    if (this._pqControls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqControls = this._pqControls?.internalValue;
    }
    if (this._pqMaxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxFileSize = this._pqMaxFileSize;
    }
    if (this._pqMaxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxSize = this._pqMaxSize;
    }
    if (this._pqMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMode = this._pqMode;
    }
    if (this._pqOnBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqOnBackpressure = this._pqOnBackpressure;
    }
    if (this._pqPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqPath = this._pqPath;
    }
    if (this._protocol !== undefined) {
      hasAnyValues = true;
      internalValueResult.protocol = this._protocol;
    }
    if (this._severity !== undefined) {
      hasAnyValues = true;
      internalValueResult.severity = this._severity;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._systemFields !== undefined) {
      hasAnyValues = true;
      internalValueResult.systemFields = this._systemFields;
    }
    if (this._throttleRatePerSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.throttleRatePerSec = this._throttleRatePerSec;
    }
    if (this._timestampFormat !== undefined) {
      hasAnyValues = true;
      internalValueResult.timestampFormat = this._timestampFormat;
    }
    if (this._tls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tls = this._tls?.internalValue;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._udpDnsResolvePeriodSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.udpDnsResolvePeriodSec = this._udpDnsResolvePeriodSec;
    }
    if (this._writeTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.writeTimeout = this._writeTimeout;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputSyslog | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._appName = undefined;
      this._connectionTimeout = undefined;
      this._description = undefined;
      this._environment = undefined;
      this._facility = undefined;
      this._host = undefined;
      this._id = undefined;
      this._loadBalanced = undefined;
      this._logFailedRequests = undefined;
      this._maxRecordSize = undefined;
      this._messageFormat = undefined;
      this._octetCountFraming = undefined;
      this._onBackpressure = undefined;
      this._pipeline = undefined;
      this._port = undefined;
      this._pqCompress = undefined;
      this._pqControls.internalValue = undefined;
      this._pqMaxFileSize = undefined;
      this._pqMaxSize = undefined;
      this._pqMode = undefined;
      this._pqOnBackpressure = undefined;
      this._pqPath = undefined;
      this._protocol = undefined;
      this._severity = undefined;
      this._streamtags = undefined;
      this._systemFields = undefined;
      this._throttleRatePerSec = undefined;
      this._timestampFormat = undefined;
      this._tls.internalValue = undefined;
      this._type = undefined;
      this._udpDnsResolvePeriodSec = undefined;
      this._writeTimeout = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._appName = value.appName;
      this._connectionTimeout = value.connectionTimeout;
      this._description = value.description;
      this._environment = value.environment;
      this._facility = value.facility;
      this._host = value.host;
      this._id = value.id;
      this._loadBalanced = value.loadBalanced;
      this._logFailedRequests = value.logFailedRequests;
      this._maxRecordSize = value.maxRecordSize;
      this._messageFormat = value.messageFormat;
      this._octetCountFraming = value.octetCountFraming;
      this._onBackpressure = value.onBackpressure;
      this._pipeline = value.pipeline;
      this._port = value.port;
      this._pqCompress = value.pqCompress;
      this._pqControls.internalValue = value.pqControls;
      this._pqMaxFileSize = value.pqMaxFileSize;
      this._pqMaxSize = value.pqMaxSize;
      this._pqMode = value.pqMode;
      this._pqOnBackpressure = value.pqOnBackpressure;
      this._pqPath = value.pqPath;
      this._protocol = value.protocol;
      this._severity = value.severity;
      this._streamtags = value.streamtags;
      this._systemFields = value.systemFields;
      this._throttleRatePerSec = value.throttleRatePerSec;
      this._timestampFormat = value.timestampFormat;
      this._tls.internalValue = value.tls;
      this._type = value.type;
      this._udpDnsResolvePeriodSec = value.udpDnsResolvePeriodSec;
      this._writeTimeout = value.writeTimeout;
    }
  }

  // app_name - computed: true, optional: true, required: false
  private _appName?: string; 
  public get appName() {
    return this.getStringAttribute('app_name');
  }
  public set appName(value: string) {
    this._appName = value;
  }
  public resetAppName() {
    this._appName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get appNameInput() {
    return this._appName;
  }

  // connection_timeout - computed: true, optional: true, required: false
  private _connectionTimeout?: number; 
  public get connectionTimeout() {
    return this.getNumberAttribute('connection_timeout');
  }
  public set connectionTimeout(value: number) {
    this._connectionTimeout = value;
  }
  public resetConnectionTimeout() {
    this._connectionTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectionTimeoutInput() {
    return this._connectionTimeout;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // facility - computed: true, optional: true, required: false
  private _facility?: number; 
  public get facility() {
    return this.getNumberAttribute('facility');
  }
  public set facility(value: number) {
    this._facility = value;
  }
  public resetFacility() {
    this._facility = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get facilityInput() {
    return this._facility;
  }

  // host - computed: false, optional: true, required: false
  private _host?: string; 
  public get host() {
    return this.getStringAttribute('host');
  }
  public set host(value: string) {
    this._host = value;
  }
  public resetHost() {
    this._host = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostInput() {
    return this._host;
  }

  // id - computed: false, optional: false, required: true
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // load_balanced - computed: true, optional: true, required: false
  private _loadBalanced?: boolean | cdktf.IResolvable; 
  public get loadBalanced() {
    return this.getBooleanAttribute('load_balanced');
  }
  public set loadBalanced(value: boolean | cdktf.IResolvable) {
    this._loadBalanced = value;
  }
  public resetLoadBalanced() {
    this._loadBalanced = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get loadBalancedInput() {
    return this._loadBalanced;
  }

  // log_failed_requests - computed: true, optional: true, required: false
  private _logFailedRequests?: boolean | cdktf.IResolvable; 
  public get logFailedRequests() {
    return this.getBooleanAttribute('log_failed_requests');
  }
  public set logFailedRequests(value: boolean | cdktf.IResolvable) {
    this._logFailedRequests = value;
  }
  public resetLogFailedRequests() {
    this._logFailedRequests = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get logFailedRequestsInput() {
    return this._logFailedRequests;
  }

  // max_record_size - computed: true, optional: true, required: false
  private _maxRecordSize?: number; 
  public get maxRecordSize() {
    return this.getNumberAttribute('max_record_size');
  }
  public set maxRecordSize(value: number) {
    this._maxRecordSize = value;
  }
  public resetMaxRecordSize() {
    this._maxRecordSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxRecordSizeInput() {
    return this._maxRecordSize;
  }

  // message_format - computed: true, optional: true, required: false
  private _messageFormat?: string; 
  public get messageFormat() {
    return this.getStringAttribute('message_format');
  }
  public set messageFormat(value: string) {
    this._messageFormat = value;
  }
  public resetMessageFormat() {
    this._messageFormat = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get messageFormatInput() {
    return this._messageFormat;
  }

  // octet_count_framing - computed: false, optional: true, required: false
  private _octetCountFraming?: boolean | cdktf.IResolvable; 
  public get octetCountFraming() {
    return this.getBooleanAttribute('octet_count_framing');
  }
  public set octetCountFraming(value: boolean | cdktf.IResolvable) {
    this._octetCountFraming = value;
  }
  public resetOctetCountFraming() {
    this._octetCountFraming = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get octetCountFramingInput() {
    return this._octetCountFraming;
  }

  // on_backpressure - computed: true, optional: true, required: false
  private _onBackpressure?: string; 
  public get onBackpressure() {
    return this.getStringAttribute('on_backpressure');
  }
  public set onBackpressure(value: string) {
    this._onBackpressure = value;
  }
  public resetOnBackpressure() {
    this._onBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get onBackpressureInput() {
    return this._onBackpressure;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // port - computed: false, optional: true, required: false
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // pq_compress - computed: true, optional: true, required: false
  private _pqCompress?: string; 
  public get pqCompress() {
    return this.getStringAttribute('pq_compress');
  }
  public set pqCompress(value: string) {
    this._pqCompress = value;
  }
  public resetPqCompress() {
    this._pqCompress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqCompressInput() {
    return this._pqCompress;
  }

  // pq_controls - computed: false, optional: true, required: false
  private _pqControls = new PackDestinationOutputSyslogPqControlsOutputReference(this, "pq_controls");
  public get pqControls() {
    return this._pqControls;
  }
  public putPqControls(value: PackDestinationOutputSyslogPqControls) {
    this._pqControls.internalValue = value;
  }
  public resetPqControls() {
    this._pqControls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqControlsInput() {
    return this._pqControls.internalValue;
  }

  // pq_max_file_size - computed: true, optional: true, required: false
  private _pqMaxFileSize?: string; 
  public get pqMaxFileSize() {
    return this.getStringAttribute('pq_max_file_size');
  }
  public set pqMaxFileSize(value: string) {
    this._pqMaxFileSize = value;
  }
  public resetPqMaxFileSize() {
    this._pqMaxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxFileSizeInput() {
    return this._pqMaxFileSize;
  }

  // pq_max_size - computed: true, optional: true, required: false
  private _pqMaxSize?: string; 
  public get pqMaxSize() {
    return this.getStringAttribute('pq_max_size');
  }
  public set pqMaxSize(value: string) {
    this._pqMaxSize = value;
  }
  public resetPqMaxSize() {
    this._pqMaxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxSizeInput() {
    return this._pqMaxSize;
  }

  // pq_mode - computed: true, optional: true, required: false
  private _pqMode?: string; 
  public get pqMode() {
    return this.getStringAttribute('pq_mode');
  }
  public set pqMode(value: string) {
    this._pqMode = value;
  }
  public resetPqMode() {
    this._pqMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqModeInput() {
    return this._pqMode;
  }

  // pq_on_backpressure - computed: true, optional: true, required: false
  private _pqOnBackpressure?: string; 
  public get pqOnBackpressure() {
    return this.getStringAttribute('pq_on_backpressure');
  }
  public set pqOnBackpressure(value: string) {
    this._pqOnBackpressure = value;
  }
  public resetPqOnBackpressure() {
    this._pqOnBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqOnBackpressureInput() {
    return this._pqOnBackpressure;
  }

  // pq_path - computed: true, optional: true, required: false
  private _pqPath?: string; 
  public get pqPath() {
    return this.getStringAttribute('pq_path');
  }
  public set pqPath(value: string) {
    this._pqPath = value;
  }
  public resetPqPath() {
    this._pqPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqPathInput() {
    return this._pqPath;
  }

  // protocol - computed: true, optional: true, required: false
  private _protocol?: string; 
  public get protocol() {
    return this.getStringAttribute('protocol');
  }
  public set protocol(value: string) {
    this._protocol = value;
  }
  public resetProtocol() {
    this._protocol = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get protocolInput() {
    return this._protocol;
  }

  // severity - computed: true, optional: true, required: false
  private _severity?: number; 
  public get severity() {
    return this.getNumberAttribute('severity');
  }
  public set severity(value: number) {
    this._severity = value;
  }
  public resetSeverity() {
    this._severity = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get severityInput() {
    return this._severity;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // system_fields - computed: true, optional: true, required: false
  private _systemFields?: string[]; 
  public get systemFields() {
    return this.getListAttribute('system_fields');
  }
  public set systemFields(value: string[]) {
    this._systemFields = value;
  }
  public resetSystemFields() {
    this._systemFields = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get systemFieldsInput() {
    return this._systemFields;
  }

  // throttle_rate_per_sec - computed: true, optional: true, required: false
  private _throttleRatePerSec?: string; 
  public get throttleRatePerSec() {
    return this.getStringAttribute('throttle_rate_per_sec');
  }
  public set throttleRatePerSec(value: string) {
    this._throttleRatePerSec = value;
  }
  public resetThrottleRatePerSec() {
    this._throttleRatePerSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get throttleRatePerSecInput() {
    return this._throttleRatePerSec;
  }

  // timestamp_format - computed: true, optional: true, required: false
  private _timestampFormat?: string; 
  public get timestampFormat() {
    return this.getStringAttribute('timestamp_format');
  }
  public set timestampFormat(value: string) {
    this._timestampFormat = value;
  }
  public resetTimestampFormat() {
    this._timestampFormat = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timestampFormatInput() {
    return this._timestampFormat;
  }

  // tls - computed: false, optional: true, required: false
  private _tls = new PackDestinationOutputSyslogTlsOutputReference(this, "tls");
  public get tls() {
    return this._tls;
  }
  public putTls(value: PackDestinationOutputSyslogTls) {
    this._tls.internalValue = value;
  }
  public resetTls() {
    this._tls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsInput() {
    return this._tls.internalValue;
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // udp_dns_resolve_period_sec - computed: true, optional: true, required: false
  private _udpDnsResolvePeriodSec?: number; 
  public get udpDnsResolvePeriodSec() {
    return this.getNumberAttribute('udp_dns_resolve_period_sec');
  }
  public set udpDnsResolvePeriodSec(value: number) {
    this._udpDnsResolvePeriodSec = value;
  }
  public resetUdpDnsResolvePeriodSec() {
    this._udpDnsResolvePeriodSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get udpDnsResolvePeriodSecInput() {
    return this._udpDnsResolvePeriodSec;
  }

  // write_timeout - computed: true, optional: true, required: false
  private _writeTimeout?: number; 
  public get writeTimeout() {
    return this.getNumberAttribute('write_timeout');
  }
  public set writeTimeout(value: number) {
    this._writeTimeout = value;
  }
  public resetWriteTimeout() {
    this._writeTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get writeTimeoutInput() {
    return this._writeTimeout;
  }
}
export interface PackDestinationOutputTcpjsonHosts {
  /**
  * The hostname of the receiver
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#host PackDestination#host}
  */
  readonly host: string;
  /**
  * The port to connect to on the provided host
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#port PackDestination#port}
  */
  readonly port: number;
  /**
  * Servername to use if establishing a TLS connection. If not specified, defaults to connection host (if not an IP); otherwise, uses the global TLS settings.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#servername PackDestination#servername}
  */
  readonly servername?: string;
  /**
  * Whether to inherit TLS configs from group setting or disable TLS. Default: "inherit"; must be one of ["inherit", "off"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#tls PackDestination#tls}
  */
  readonly tls?: string;
  /**
  * Assign a weight (>0) to each endpoint to indicate its traffic-handling capability. Default: 1
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#weight PackDestination#weight}
  */
  readonly weight?: number;
}

export function packDestinationOutputTcpjsonHostsToTerraform(struct?: PackDestinationOutputTcpjsonHosts | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    host: cdktf.stringToTerraform(struct!.host),
    port: cdktf.numberToTerraform(struct!.port),
    servername: cdktf.stringToTerraform(struct!.servername),
    tls: cdktf.stringToTerraform(struct!.tls),
    weight: cdktf.numberToTerraform(struct!.weight),
  }
}


export function packDestinationOutputTcpjsonHostsToHclTerraform(struct?: PackDestinationOutputTcpjsonHosts | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    host: {
      value: cdktf.stringToHclTerraform(struct!.host),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    servername: {
      value: cdktf.stringToHclTerraform(struct!.servername),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tls: {
      value: cdktf.stringToHclTerraform(struct!.tls),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    weight: {
      value: cdktf.numberToHclTerraform(struct!.weight),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputTcpjsonHostsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackDestinationOutputTcpjsonHosts | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._host !== undefined) {
      hasAnyValues = true;
      internalValueResult.host = this._host;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._servername !== undefined) {
      hasAnyValues = true;
      internalValueResult.servername = this._servername;
    }
    if (this._tls !== undefined) {
      hasAnyValues = true;
      internalValueResult.tls = this._tls;
    }
    if (this._weight !== undefined) {
      hasAnyValues = true;
      internalValueResult.weight = this._weight;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputTcpjsonHosts | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._host = undefined;
      this._port = undefined;
      this._servername = undefined;
      this._tls = undefined;
      this._weight = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._host = value.host;
      this._port = value.port;
      this._servername = value.servername;
      this._tls = value.tls;
      this._weight = value.weight;
    }
  }

  // host - computed: false, optional: false, required: true
  private _host?: string; 
  public get host() {
    return this.getStringAttribute('host');
  }
  public set host(value: string) {
    this._host = value;
  }
  // Temporarily expose input value. Use with caution.
  public get hostInput() {
    return this._host;
  }

  // port - computed: false, optional: false, required: true
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // servername - computed: false, optional: true, required: false
  private _servername?: string; 
  public get servername() {
    return this.getStringAttribute('servername');
  }
  public set servername(value: string) {
    this._servername = value;
  }
  public resetServername() {
    this._servername = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get servernameInput() {
    return this._servername;
  }

  // tls - computed: true, optional: true, required: false
  private _tls?: string; 
  public get tls() {
    return this.getStringAttribute('tls');
  }
  public set tls(value: string) {
    this._tls = value;
  }
  public resetTls() {
    this._tls = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsInput() {
    return this._tls;
  }

  // weight - computed: true, optional: true, required: false
  private _weight?: number; 
  public get weight() {
    return this.getNumberAttribute('weight');
  }
  public set weight(value: number) {
    this._weight = value;
  }
  public resetWeight() {
    this._weight = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get weightInput() {
    return this._weight;
  }
}

export class PackDestinationOutputTcpjsonHostsList extends cdktf.ComplexList {
  public internalValue? : PackDestinationOutputTcpjsonHosts[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackDestinationOutputTcpjsonHostsOutputReference {
    return new PackDestinationOutputTcpjsonHostsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackDestinationOutputTcpjsonPqControls {
}

export function packDestinationOutputTcpjsonPqControlsToTerraform(struct?: PackDestinationOutputTcpjsonPqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function packDestinationOutputTcpjsonPqControlsToHclTerraform(struct?: PackDestinationOutputTcpjsonPqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class PackDestinationOutputTcpjsonPqControlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackDestinationOutputTcpjsonPqControls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputTcpjsonPqControls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface PackDestinationOutputTcpjsonTls {
  /**
  * Path on client in which to find CA certificates to verify the server's cert. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#ca_path PackDestination#ca_path}
  */
  readonly caPath?: string;
  /**
  * Path on client in which to find certificates to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#cert_path PackDestination#cert_path}
  */
  readonly certPath?: string;
  /**
  * The name of the predefined certificate
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#certificate_name PackDestination#certificate_name}
  */
  readonly certificateName?: string;
  /**
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#disabled PackDestination#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_version PackDestination#max_version}
  */
  readonly maxVersion?: string;
  /**
  * must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#min_version PackDestination#min_version}
  */
  readonly minVersion?: string;
  /**
  * Passphrase to use to decrypt private key
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#passphrase PackDestination#passphrase}
  */
  readonly passphrase?: string;
  /**
  * Path on client in which to find the private key to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#priv_key_path PackDestination#priv_key_path}
  */
  readonly privKeyPath?: string;
  /**
  * Reject certificates that are not authorized by a CA in the CA certificate path, or by another 
  *                     trusted CA (such as the system's). Defaults to Enabled. Overrides the toggle from Advanced Settings, when also present.
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#reject_unauthorized PackDestination#reject_unauthorized}
  */
  readonly rejectUnauthorized?: boolean | cdktf.IResolvable;
  /**
  * Server name for the SNI (Server Name Indication) TLS extension. It must be a host name, and not an IP address.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#servername PackDestination#servername}
  */
  readonly servername?: string;
}

export function packDestinationOutputTcpjsonTlsToTerraform(struct?: PackDestinationOutputTcpjsonTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ca_path: cdktf.stringToTerraform(struct!.caPath),
    cert_path: cdktf.stringToTerraform(struct!.certPath),
    certificate_name: cdktf.stringToTerraform(struct!.certificateName),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    max_version: cdktf.stringToTerraform(struct!.maxVersion),
    min_version: cdktf.stringToTerraform(struct!.minVersion),
    passphrase: cdktf.stringToTerraform(struct!.passphrase),
    priv_key_path: cdktf.stringToTerraform(struct!.privKeyPath),
    reject_unauthorized: cdktf.booleanToTerraform(struct!.rejectUnauthorized),
    servername: cdktf.stringToTerraform(struct!.servername),
  }
}


export function packDestinationOutputTcpjsonTlsToHclTerraform(struct?: PackDestinationOutputTcpjsonTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ca_path: {
      value: cdktf.stringToHclTerraform(struct!.caPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    cert_path: {
      value: cdktf.stringToHclTerraform(struct!.certPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    certificate_name: {
      value: cdktf.stringToHclTerraform(struct!.certificateName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    max_version: {
      value: cdktf.stringToHclTerraform(struct!.maxVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    min_version: {
      value: cdktf.stringToHclTerraform(struct!.minVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    passphrase: {
      value: cdktf.stringToHclTerraform(struct!.passphrase),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    priv_key_path: {
      value: cdktf.stringToHclTerraform(struct!.privKeyPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reject_unauthorized: {
      value: cdktf.booleanToHclTerraform(struct!.rejectUnauthorized),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    servername: {
      value: cdktf.stringToHclTerraform(struct!.servername),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputTcpjsonTlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackDestinationOutputTcpjsonTls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._caPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.caPath = this._caPath;
    }
    if (this._certPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.certPath = this._certPath;
    }
    if (this._certificateName !== undefined) {
      hasAnyValues = true;
      internalValueResult.certificateName = this._certificateName;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._maxVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxVersion = this._maxVersion;
    }
    if (this._minVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.minVersion = this._minVersion;
    }
    if (this._passphrase !== undefined) {
      hasAnyValues = true;
      internalValueResult.passphrase = this._passphrase;
    }
    if (this._privKeyPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.privKeyPath = this._privKeyPath;
    }
    if (this._rejectUnauthorized !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectUnauthorized = this._rejectUnauthorized;
    }
    if (this._servername !== undefined) {
      hasAnyValues = true;
      internalValueResult.servername = this._servername;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputTcpjsonTls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._caPath = undefined;
      this._certPath = undefined;
      this._certificateName = undefined;
      this._disabled = undefined;
      this._maxVersion = undefined;
      this._minVersion = undefined;
      this._passphrase = undefined;
      this._privKeyPath = undefined;
      this._rejectUnauthorized = undefined;
      this._servername = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._caPath = value.caPath;
      this._certPath = value.certPath;
      this._certificateName = value.certificateName;
      this._disabled = value.disabled;
      this._maxVersion = value.maxVersion;
      this._minVersion = value.minVersion;
      this._passphrase = value.passphrase;
      this._privKeyPath = value.privKeyPath;
      this._rejectUnauthorized = value.rejectUnauthorized;
      this._servername = value.servername;
    }
  }

  // ca_path - computed: false, optional: true, required: false
  private _caPath?: string; 
  public get caPath() {
    return this.getStringAttribute('ca_path');
  }
  public set caPath(value: string) {
    this._caPath = value;
  }
  public resetCaPath() {
    this._caPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get caPathInput() {
    return this._caPath;
  }

  // cert_path - computed: false, optional: true, required: false
  private _certPath?: string; 
  public get certPath() {
    return this.getStringAttribute('cert_path');
  }
  public set certPath(value: string) {
    this._certPath = value;
  }
  public resetCertPath() {
    this._certPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certPathInput() {
    return this._certPath;
  }

  // certificate_name - computed: false, optional: true, required: false
  private _certificateName?: string; 
  public get certificateName() {
    return this.getStringAttribute('certificate_name');
  }
  public set certificateName(value: string) {
    this._certificateName = value;
  }
  public resetCertificateName() {
    this._certificateName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certificateNameInput() {
    return this._certificateName;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // max_version - computed: false, optional: true, required: false
  private _maxVersion?: string; 
  public get maxVersion() {
    return this.getStringAttribute('max_version');
  }
  public set maxVersion(value: string) {
    this._maxVersion = value;
  }
  public resetMaxVersion() {
    this._maxVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxVersionInput() {
    return this._maxVersion;
  }

  // min_version - computed: false, optional: true, required: false
  private _minVersion?: string; 
  public get minVersion() {
    return this.getStringAttribute('min_version');
  }
  public set minVersion(value: string) {
    this._minVersion = value;
  }
  public resetMinVersion() {
    this._minVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get minVersionInput() {
    return this._minVersion;
  }

  // passphrase - computed: false, optional: true, required: false
  private _passphrase?: string; 
  public get passphrase() {
    return this.getStringAttribute('passphrase');
  }
  public set passphrase(value: string) {
    this._passphrase = value;
  }
  public resetPassphrase() {
    this._passphrase = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passphraseInput() {
    return this._passphrase;
  }

  // priv_key_path - computed: false, optional: true, required: false
  private _privKeyPath?: string; 
  public get privKeyPath() {
    return this.getStringAttribute('priv_key_path');
  }
  public set privKeyPath(value: string) {
    this._privKeyPath = value;
  }
  public resetPrivKeyPath() {
    this._privKeyPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get privKeyPathInput() {
    return this._privKeyPath;
  }

  // reject_unauthorized - computed: true, optional: true, required: false
  private _rejectUnauthorized?: boolean | cdktf.IResolvable; 
  public get rejectUnauthorized() {
    return this.getBooleanAttribute('reject_unauthorized');
  }
  public set rejectUnauthorized(value: boolean | cdktf.IResolvable) {
    this._rejectUnauthorized = value;
  }
  public resetRejectUnauthorized() {
    this._rejectUnauthorized = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectUnauthorizedInput() {
    return this._rejectUnauthorized;
  }

  // servername - computed: false, optional: true, required: false
  private _servername?: string; 
  public get servername() {
    return this.getStringAttribute('servername');
  }
  public set servername(value: string) {
    this._servername = value;
  }
  public resetServername() {
    this._servername = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get servernameInput() {
    return this._servername;
  }
}
export interface PackDestinationOutputTcpjson {
  /**
  * Optional authentication token to include as part of the connection header. Default: ""
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#auth_token PackDestination#auth_token}
  */
  readonly authToken?: string;
  /**
  * Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate. Default: "manual"; must be one of ["manual", "secret"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#auth_type PackDestination#auth_type}
  */
  readonly authType?: string;
  /**
  * Codec to use to compress the data before sending. Default: "gzip"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#compression PackDestination#compression}
  */
  readonly compression?: string;
  /**
  * Amount of time (milliseconds) to wait for the connection to establish before retrying. Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#connection_timeout PackDestination#connection_timeout}
  */
  readonly connectionTimeout?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#description PackDestination#description}
  */
  readonly description?: string;
  /**
  * The interval in which to re-resolve any hostnames and pick up destinations from A records. Default: 600
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#dns_resolve_period_sec PackDestination#dns_resolve_period_sec}
  */
  readonly dnsResolvePeriodSec?: number;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#environment PackDestination#environment}
  */
  readonly environment?: string;
  /**
  * Exclude all IPs of the current host from the list of any resolved hostnames. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#exclude_self PackDestination#exclude_self}
  */
  readonly excludeSelf?: boolean | cdktf.IResolvable;
  /**
  * The hostname of the receiver
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#host PackDestination#host}
  */
  readonly host?: string;
  /**
  * Set of hosts to load-balance data to
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#hosts PackDestination#hosts}
  */
  readonly hosts?: PackDestinationOutputTcpjsonHosts[] | cdktf.IResolvable;
  /**
  * Unique ID for this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#id PackDestination#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id: string;
  /**
  * How far back in time to keep traffic stats for load balancing purposes. Default: 300
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#load_balance_stats_period_sec PackDestination#load_balance_stats_period_sec}
  */
  readonly loadBalanceStatsPeriodSec?: number;
  /**
  * Use load-balanced destinations. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#load_balanced PackDestination#load_balanced}
  */
  readonly loadBalanced?: boolean | cdktf.IResolvable;
  /**
  * Use to troubleshoot issues with sending data. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#log_failed_requests PackDestination#log_failed_requests}
  */
  readonly logFailedRequests?: boolean | cdktf.IResolvable;
  /**
  * Maximum number of concurrent connections (per Worker Process). A random set of IPs will be picked on every DNS resolution period. Use 0 for unlimited. Default: 0
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_concurrent_senders PackDestination#max_concurrent_senders}
  */
  readonly maxConcurrentSenders?: number;
  /**
  * How to handle events when all receivers are exerting backpressure. Default: "block"; must be one of ["block", "drop", "queue"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#on_backpressure PackDestination#on_backpressure}
  */
  readonly onBackpressure?: string;
  /**
  * Pipeline to process data before sending out to this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pipeline PackDestination#pipeline}
  */
  readonly pipeline?: string;
  /**
  * The port to connect to on the provided host
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#port PackDestination#port}
  */
  readonly port?: number;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_compress PackDestination#pq_compress}
  */
  readonly pqCompress?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_controls PackDestination#pq_controls}
  */
  readonly pqControls?: PackDestinationOutputTcpjsonPqControls;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.). Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_max_file_size PackDestination#pq_max_file_size}
  */
  readonly pqMaxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_max_size PackDestination#pq_max_size}
  */
  readonly pqMaxSize?: string;
  /**
  * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem. Default: "error"; must be one of ["error", "backpressure", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_mode PackDestination#pq_mode}
  */
  readonly pqMode?: string;
  /**
  * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged. Default: "block"; must be one of ["block", "drop"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_on_backpressure PackDestination#pq_on_backpressure}
  */
  readonly pqOnBackpressure?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_path PackDestination#pq_path}
  */
  readonly pqPath?: string;
  /**
  * Upon connection, send a header-like record containing the auth token and other metadata.This record will not contain an actual event – only subsequent records will. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#send_header PackDestination#send_header}
  */
  readonly sendHeader?: boolean | cdktf.IResolvable;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#streamtags PackDestination#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Fields to automatically add to events, such as cribl_pipe. Supports wildcards. Default: ["cribl_pipe"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#system_fields PackDestination#system_fields}
  */
  readonly systemFields?: string[];
  /**
  * Select or create a stored text secret
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#text_secret PackDestination#text_secret}
  */
  readonly textSecret?: string;
  /**
  * Rate (in bytes per second) to throttle while writing to an output. Accepts values with multiple-byte units, such as KB, MB, and GB. (Example: 42 MB) Default value of 0 specifies no throttling. Default: "0"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#throttle_rate_per_sec PackDestination#throttle_rate_per_sec}
  */
  readonly throttleRatePerSec?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#tls PackDestination#tls}
  */
  readonly tls?: PackDestinationOutputTcpjsonTls;
  /**
  * The number of minutes before the internally generated authentication token expires, valid values between 1 and 60. Default: 60
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#token_ttl_minutes PackDestination#token_ttl_minutes}
  */
  readonly tokenTtlMinutes?: number;
  /**
  * must be "tcpjson"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#type PackDestination#type}
  */
  readonly type: string;
  /**
  * Amount of time (milliseconds) to wait for a write to complete before assuming connection is dead. Default: 60000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#write_timeout PackDestination#write_timeout}
  */
  readonly writeTimeout?: number;
}

export function packDestinationOutputTcpjsonToTerraform(struct?: PackDestinationOutputTcpjson | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    auth_token: cdktf.stringToTerraform(struct!.authToken),
    auth_type: cdktf.stringToTerraform(struct!.authType),
    compression: cdktf.stringToTerraform(struct!.compression),
    connection_timeout: cdktf.numberToTerraform(struct!.connectionTimeout),
    description: cdktf.stringToTerraform(struct!.description),
    dns_resolve_period_sec: cdktf.numberToTerraform(struct!.dnsResolvePeriodSec),
    environment: cdktf.stringToTerraform(struct!.environment),
    exclude_self: cdktf.booleanToTerraform(struct!.excludeSelf),
    host: cdktf.stringToTerraform(struct!.host),
    hosts: cdktf.listMapper(packDestinationOutputTcpjsonHostsToTerraform, false)(struct!.hosts),
    id: cdktf.stringToTerraform(struct!.id),
    load_balance_stats_period_sec: cdktf.numberToTerraform(struct!.loadBalanceStatsPeriodSec),
    load_balanced: cdktf.booleanToTerraform(struct!.loadBalanced),
    log_failed_requests: cdktf.booleanToTerraform(struct!.logFailedRequests),
    max_concurrent_senders: cdktf.numberToTerraform(struct!.maxConcurrentSenders),
    on_backpressure: cdktf.stringToTerraform(struct!.onBackpressure),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    port: cdktf.numberToTerraform(struct!.port),
    pq_compress: cdktf.stringToTerraform(struct!.pqCompress),
    pq_controls: packDestinationOutputTcpjsonPqControlsToTerraform(struct!.pqControls),
    pq_max_file_size: cdktf.stringToTerraform(struct!.pqMaxFileSize),
    pq_max_size: cdktf.stringToTerraform(struct!.pqMaxSize),
    pq_mode: cdktf.stringToTerraform(struct!.pqMode),
    pq_on_backpressure: cdktf.stringToTerraform(struct!.pqOnBackpressure),
    pq_path: cdktf.stringToTerraform(struct!.pqPath),
    send_header: cdktf.booleanToTerraform(struct!.sendHeader),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    system_fields: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.systemFields),
    text_secret: cdktf.stringToTerraform(struct!.textSecret),
    throttle_rate_per_sec: cdktf.stringToTerraform(struct!.throttleRatePerSec),
    tls: packDestinationOutputTcpjsonTlsToTerraform(struct!.tls),
    token_ttl_minutes: cdktf.numberToTerraform(struct!.tokenTtlMinutes),
    type: cdktf.stringToTerraform(struct!.type),
    write_timeout: cdktf.numberToTerraform(struct!.writeTimeout),
  }
}


export function packDestinationOutputTcpjsonToHclTerraform(struct?: PackDestinationOutputTcpjson | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    auth_token: {
      value: cdktf.stringToHclTerraform(struct!.authToken),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    auth_type: {
      value: cdktf.stringToHclTerraform(struct!.authType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    compression: {
      value: cdktf.stringToHclTerraform(struct!.compression),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    connection_timeout: {
      value: cdktf.numberToHclTerraform(struct!.connectionTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    dns_resolve_period_sec: {
      value: cdktf.numberToHclTerraform(struct!.dnsResolvePeriodSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    exclude_self: {
      value: cdktf.booleanToHclTerraform(struct!.excludeSelf),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    host: {
      value: cdktf.stringToHclTerraform(struct!.host),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    hosts: {
      value: cdktf.listMapperHcl(packDestinationOutputTcpjsonHostsToHclTerraform, false)(struct!.hosts),
      isBlock: true,
      type: "list",
      storageClassType: "PackDestinationOutputTcpjsonHostsList",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    load_balance_stats_period_sec: {
      value: cdktf.numberToHclTerraform(struct!.loadBalanceStatsPeriodSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    load_balanced: {
      value: cdktf.booleanToHclTerraform(struct!.loadBalanced),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    log_failed_requests: {
      value: cdktf.booleanToHclTerraform(struct!.logFailedRequests),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    max_concurrent_senders: {
      value: cdktf.numberToHclTerraform(struct!.maxConcurrentSenders),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.onBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    pq_compress: {
      value: cdktf.stringToHclTerraform(struct!.pqCompress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_controls: {
      value: packDestinationOutputTcpjsonPqControlsToHclTerraform(struct!.pqControls),
      isBlock: true,
      type: "struct",
      storageClassType: "PackDestinationOutputTcpjsonPqControls",
    },
    pq_max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_max_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_mode: {
      value: cdktf.stringToHclTerraform(struct!.pqMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.pqOnBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_path: {
      value: cdktf.stringToHclTerraform(struct!.pqPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    send_header: {
      value: cdktf.booleanToHclTerraform(struct!.sendHeader),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    system_fields: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.systemFields),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    text_secret: {
      value: cdktf.stringToHclTerraform(struct!.textSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    throttle_rate_per_sec: {
      value: cdktf.stringToHclTerraform(struct!.throttleRatePerSec),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tls: {
      value: packDestinationOutputTcpjsonTlsToHclTerraform(struct!.tls),
      isBlock: true,
      type: "struct",
      storageClassType: "PackDestinationOutputTcpjsonTls",
    },
    token_ttl_minutes: {
      value: cdktf.numberToHclTerraform(struct!.tokenTtlMinutes),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    write_timeout: {
      value: cdktf.numberToHclTerraform(struct!.writeTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputTcpjsonOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackDestinationOutputTcpjson | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._authToken !== undefined) {
      hasAnyValues = true;
      internalValueResult.authToken = this._authToken;
    }
    if (this._authType !== undefined) {
      hasAnyValues = true;
      internalValueResult.authType = this._authType;
    }
    if (this._compression !== undefined) {
      hasAnyValues = true;
      internalValueResult.compression = this._compression;
    }
    if (this._connectionTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.connectionTimeout = this._connectionTimeout;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._dnsResolvePeriodSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.dnsResolvePeriodSec = this._dnsResolvePeriodSec;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._excludeSelf !== undefined) {
      hasAnyValues = true;
      internalValueResult.excludeSelf = this._excludeSelf;
    }
    if (this._host !== undefined) {
      hasAnyValues = true;
      internalValueResult.host = this._host;
    }
    if (this._hosts?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.hosts = this._hosts?.internalValue;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._loadBalanceStatsPeriodSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.loadBalanceStatsPeriodSec = this._loadBalanceStatsPeriodSec;
    }
    if (this._loadBalanced !== undefined) {
      hasAnyValues = true;
      internalValueResult.loadBalanced = this._loadBalanced;
    }
    if (this._logFailedRequests !== undefined) {
      hasAnyValues = true;
      internalValueResult.logFailedRequests = this._logFailedRequests;
    }
    if (this._maxConcurrentSenders !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxConcurrentSenders = this._maxConcurrentSenders;
    }
    if (this._onBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.onBackpressure = this._onBackpressure;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._pqCompress !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqCompress = this._pqCompress;
    }
    if (this._pqControls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqControls = this._pqControls?.internalValue;
    }
    if (this._pqMaxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxFileSize = this._pqMaxFileSize;
    }
    if (this._pqMaxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxSize = this._pqMaxSize;
    }
    if (this._pqMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMode = this._pqMode;
    }
    if (this._pqOnBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqOnBackpressure = this._pqOnBackpressure;
    }
    if (this._pqPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqPath = this._pqPath;
    }
    if (this._sendHeader !== undefined) {
      hasAnyValues = true;
      internalValueResult.sendHeader = this._sendHeader;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._systemFields !== undefined) {
      hasAnyValues = true;
      internalValueResult.systemFields = this._systemFields;
    }
    if (this._textSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.textSecret = this._textSecret;
    }
    if (this._throttleRatePerSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.throttleRatePerSec = this._throttleRatePerSec;
    }
    if (this._tls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tls = this._tls?.internalValue;
    }
    if (this._tokenTtlMinutes !== undefined) {
      hasAnyValues = true;
      internalValueResult.tokenTtlMinutes = this._tokenTtlMinutes;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._writeTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.writeTimeout = this._writeTimeout;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputTcpjson | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._authToken = undefined;
      this._authType = undefined;
      this._compression = undefined;
      this._connectionTimeout = undefined;
      this._description = undefined;
      this._dnsResolvePeriodSec = undefined;
      this._environment = undefined;
      this._excludeSelf = undefined;
      this._host = undefined;
      this._hosts.internalValue = undefined;
      this._id = undefined;
      this._loadBalanceStatsPeriodSec = undefined;
      this._loadBalanced = undefined;
      this._logFailedRequests = undefined;
      this._maxConcurrentSenders = undefined;
      this._onBackpressure = undefined;
      this._pipeline = undefined;
      this._port = undefined;
      this._pqCompress = undefined;
      this._pqControls.internalValue = undefined;
      this._pqMaxFileSize = undefined;
      this._pqMaxSize = undefined;
      this._pqMode = undefined;
      this._pqOnBackpressure = undefined;
      this._pqPath = undefined;
      this._sendHeader = undefined;
      this._streamtags = undefined;
      this._systemFields = undefined;
      this._textSecret = undefined;
      this._throttleRatePerSec = undefined;
      this._tls.internalValue = undefined;
      this._tokenTtlMinutes = undefined;
      this._type = undefined;
      this._writeTimeout = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._authToken = value.authToken;
      this._authType = value.authType;
      this._compression = value.compression;
      this._connectionTimeout = value.connectionTimeout;
      this._description = value.description;
      this._dnsResolvePeriodSec = value.dnsResolvePeriodSec;
      this._environment = value.environment;
      this._excludeSelf = value.excludeSelf;
      this._host = value.host;
      this._hosts.internalValue = value.hosts;
      this._id = value.id;
      this._loadBalanceStatsPeriodSec = value.loadBalanceStatsPeriodSec;
      this._loadBalanced = value.loadBalanced;
      this._logFailedRequests = value.logFailedRequests;
      this._maxConcurrentSenders = value.maxConcurrentSenders;
      this._onBackpressure = value.onBackpressure;
      this._pipeline = value.pipeline;
      this._port = value.port;
      this._pqCompress = value.pqCompress;
      this._pqControls.internalValue = value.pqControls;
      this._pqMaxFileSize = value.pqMaxFileSize;
      this._pqMaxSize = value.pqMaxSize;
      this._pqMode = value.pqMode;
      this._pqOnBackpressure = value.pqOnBackpressure;
      this._pqPath = value.pqPath;
      this._sendHeader = value.sendHeader;
      this._streamtags = value.streamtags;
      this._systemFields = value.systemFields;
      this._textSecret = value.textSecret;
      this._throttleRatePerSec = value.throttleRatePerSec;
      this._tls.internalValue = value.tls;
      this._tokenTtlMinutes = value.tokenTtlMinutes;
      this._type = value.type;
      this._writeTimeout = value.writeTimeout;
    }
  }

  // auth_token - computed: true, optional: true, required: false
  private _authToken?: string; 
  public get authToken() {
    return this.getStringAttribute('auth_token');
  }
  public set authToken(value: string) {
    this._authToken = value;
  }
  public resetAuthToken() {
    this._authToken = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authTokenInput() {
    return this._authToken;
  }

  // auth_type - computed: true, optional: true, required: false
  private _authType?: string; 
  public get authType() {
    return this.getStringAttribute('auth_type');
  }
  public set authType(value: string) {
    this._authType = value;
  }
  public resetAuthType() {
    this._authType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authTypeInput() {
    return this._authType;
  }

  // compression - computed: true, optional: true, required: false
  private _compression?: string; 
  public get compression() {
    return this.getStringAttribute('compression');
  }
  public set compression(value: string) {
    this._compression = value;
  }
  public resetCompression() {
    this._compression = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressionInput() {
    return this._compression;
  }

  // connection_timeout - computed: true, optional: true, required: false
  private _connectionTimeout?: number; 
  public get connectionTimeout() {
    return this.getNumberAttribute('connection_timeout');
  }
  public set connectionTimeout(value: number) {
    this._connectionTimeout = value;
  }
  public resetConnectionTimeout() {
    this._connectionTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectionTimeoutInput() {
    return this._connectionTimeout;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // dns_resolve_period_sec - computed: true, optional: true, required: false
  private _dnsResolvePeriodSec?: number; 
  public get dnsResolvePeriodSec() {
    return this.getNumberAttribute('dns_resolve_period_sec');
  }
  public set dnsResolvePeriodSec(value: number) {
    this._dnsResolvePeriodSec = value;
  }
  public resetDnsResolvePeriodSec() {
    this._dnsResolvePeriodSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dnsResolvePeriodSecInput() {
    return this._dnsResolvePeriodSec;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // exclude_self - computed: true, optional: true, required: false
  private _excludeSelf?: boolean | cdktf.IResolvable; 
  public get excludeSelf() {
    return this.getBooleanAttribute('exclude_self');
  }
  public set excludeSelf(value: boolean | cdktf.IResolvable) {
    this._excludeSelf = value;
  }
  public resetExcludeSelf() {
    this._excludeSelf = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get excludeSelfInput() {
    return this._excludeSelf;
  }

  // host - computed: false, optional: true, required: false
  private _host?: string; 
  public get host() {
    return this.getStringAttribute('host');
  }
  public set host(value: string) {
    this._host = value;
  }
  public resetHost() {
    this._host = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostInput() {
    return this._host;
  }

  // hosts - computed: false, optional: true, required: false
  private _hosts = new PackDestinationOutputTcpjsonHostsList(this, "hosts", false);
  public get hosts() {
    return this._hosts;
  }
  public putHosts(value: PackDestinationOutputTcpjsonHosts[] | cdktf.IResolvable) {
    this._hosts.internalValue = value;
  }
  public resetHosts() {
    this._hosts.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostsInput() {
    return this._hosts.internalValue;
  }

  // id - computed: false, optional: false, required: true
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // load_balance_stats_period_sec - computed: true, optional: true, required: false
  private _loadBalanceStatsPeriodSec?: number; 
  public get loadBalanceStatsPeriodSec() {
    return this.getNumberAttribute('load_balance_stats_period_sec');
  }
  public set loadBalanceStatsPeriodSec(value: number) {
    this._loadBalanceStatsPeriodSec = value;
  }
  public resetLoadBalanceStatsPeriodSec() {
    this._loadBalanceStatsPeriodSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get loadBalanceStatsPeriodSecInput() {
    return this._loadBalanceStatsPeriodSec;
  }

  // load_balanced - computed: true, optional: true, required: false
  private _loadBalanced?: boolean | cdktf.IResolvable; 
  public get loadBalanced() {
    return this.getBooleanAttribute('load_balanced');
  }
  public set loadBalanced(value: boolean | cdktf.IResolvable) {
    this._loadBalanced = value;
  }
  public resetLoadBalanced() {
    this._loadBalanced = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get loadBalancedInput() {
    return this._loadBalanced;
  }

  // log_failed_requests - computed: true, optional: true, required: false
  private _logFailedRequests?: boolean | cdktf.IResolvable; 
  public get logFailedRequests() {
    return this.getBooleanAttribute('log_failed_requests');
  }
  public set logFailedRequests(value: boolean | cdktf.IResolvable) {
    this._logFailedRequests = value;
  }
  public resetLogFailedRequests() {
    this._logFailedRequests = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get logFailedRequestsInput() {
    return this._logFailedRequests;
  }

  // max_concurrent_senders - computed: true, optional: true, required: false
  private _maxConcurrentSenders?: number; 
  public get maxConcurrentSenders() {
    return this.getNumberAttribute('max_concurrent_senders');
  }
  public set maxConcurrentSenders(value: number) {
    this._maxConcurrentSenders = value;
  }
  public resetMaxConcurrentSenders() {
    this._maxConcurrentSenders = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxConcurrentSendersInput() {
    return this._maxConcurrentSenders;
  }

  // on_backpressure - computed: true, optional: true, required: false
  private _onBackpressure?: string; 
  public get onBackpressure() {
    return this.getStringAttribute('on_backpressure');
  }
  public set onBackpressure(value: string) {
    this._onBackpressure = value;
  }
  public resetOnBackpressure() {
    this._onBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get onBackpressureInput() {
    return this._onBackpressure;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // port - computed: false, optional: true, required: false
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // pq_compress - computed: true, optional: true, required: false
  private _pqCompress?: string; 
  public get pqCompress() {
    return this.getStringAttribute('pq_compress');
  }
  public set pqCompress(value: string) {
    this._pqCompress = value;
  }
  public resetPqCompress() {
    this._pqCompress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqCompressInput() {
    return this._pqCompress;
  }

  // pq_controls - computed: false, optional: true, required: false
  private _pqControls = new PackDestinationOutputTcpjsonPqControlsOutputReference(this, "pq_controls");
  public get pqControls() {
    return this._pqControls;
  }
  public putPqControls(value: PackDestinationOutputTcpjsonPqControls) {
    this._pqControls.internalValue = value;
  }
  public resetPqControls() {
    this._pqControls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqControlsInput() {
    return this._pqControls.internalValue;
  }

  // pq_max_file_size - computed: true, optional: true, required: false
  private _pqMaxFileSize?: string; 
  public get pqMaxFileSize() {
    return this.getStringAttribute('pq_max_file_size');
  }
  public set pqMaxFileSize(value: string) {
    this._pqMaxFileSize = value;
  }
  public resetPqMaxFileSize() {
    this._pqMaxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxFileSizeInput() {
    return this._pqMaxFileSize;
  }

  // pq_max_size - computed: true, optional: true, required: false
  private _pqMaxSize?: string; 
  public get pqMaxSize() {
    return this.getStringAttribute('pq_max_size');
  }
  public set pqMaxSize(value: string) {
    this._pqMaxSize = value;
  }
  public resetPqMaxSize() {
    this._pqMaxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxSizeInput() {
    return this._pqMaxSize;
  }

  // pq_mode - computed: true, optional: true, required: false
  private _pqMode?: string; 
  public get pqMode() {
    return this.getStringAttribute('pq_mode');
  }
  public set pqMode(value: string) {
    this._pqMode = value;
  }
  public resetPqMode() {
    this._pqMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqModeInput() {
    return this._pqMode;
  }

  // pq_on_backpressure - computed: true, optional: true, required: false
  private _pqOnBackpressure?: string; 
  public get pqOnBackpressure() {
    return this.getStringAttribute('pq_on_backpressure');
  }
  public set pqOnBackpressure(value: string) {
    this._pqOnBackpressure = value;
  }
  public resetPqOnBackpressure() {
    this._pqOnBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqOnBackpressureInput() {
    return this._pqOnBackpressure;
  }

  // pq_path - computed: true, optional: true, required: false
  private _pqPath?: string; 
  public get pqPath() {
    return this.getStringAttribute('pq_path');
  }
  public set pqPath(value: string) {
    this._pqPath = value;
  }
  public resetPqPath() {
    this._pqPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqPathInput() {
    return this._pqPath;
  }

  // send_header - computed: true, optional: true, required: false
  private _sendHeader?: boolean | cdktf.IResolvable; 
  public get sendHeader() {
    return this.getBooleanAttribute('send_header');
  }
  public set sendHeader(value: boolean | cdktf.IResolvable) {
    this._sendHeader = value;
  }
  public resetSendHeader() {
    this._sendHeader = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sendHeaderInput() {
    return this._sendHeader;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // system_fields - computed: true, optional: true, required: false
  private _systemFields?: string[]; 
  public get systemFields() {
    return this.getListAttribute('system_fields');
  }
  public set systemFields(value: string[]) {
    this._systemFields = value;
  }
  public resetSystemFields() {
    this._systemFields = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get systemFieldsInput() {
    return this._systemFields;
  }

  // text_secret - computed: false, optional: true, required: false
  private _textSecret?: string; 
  public get textSecret() {
    return this.getStringAttribute('text_secret');
  }
  public set textSecret(value: string) {
    this._textSecret = value;
  }
  public resetTextSecret() {
    this._textSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get textSecretInput() {
    return this._textSecret;
  }

  // throttle_rate_per_sec - computed: true, optional: true, required: false
  private _throttleRatePerSec?: string; 
  public get throttleRatePerSec() {
    return this.getStringAttribute('throttle_rate_per_sec');
  }
  public set throttleRatePerSec(value: string) {
    this._throttleRatePerSec = value;
  }
  public resetThrottleRatePerSec() {
    this._throttleRatePerSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get throttleRatePerSecInput() {
    return this._throttleRatePerSec;
  }

  // tls - computed: false, optional: true, required: false
  private _tls = new PackDestinationOutputTcpjsonTlsOutputReference(this, "tls");
  public get tls() {
    return this._tls;
  }
  public putTls(value: PackDestinationOutputTcpjsonTls) {
    this._tls.internalValue = value;
  }
  public resetTls() {
    this._tls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsInput() {
    return this._tls.internalValue;
  }

  // token_ttl_minutes - computed: true, optional: true, required: false
  private _tokenTtlMinutes?: number; 
  public get tokenTtlMinutes() {
    return this.getNumberAttribute('token_ttl_minutes');
  }
  public set tokenTtlMinutes(value: number) {
    this._tokenTtlMinutes = value;
  }
  public resetTokenTtlMinutes() {
    this._tokenTtlMinutes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tokenTtlMinutesInput() {
    return this._tokenTtlMinutes;
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // write_timeout - computed: true, optional: true, required: false
  private _writeTimeout?: number; 
  public get writeTimeout() {
    return this.getNumberAttribute('write_timeout');
  }
  public set writeTimeout(value: number) {
    this._writeTimeout = value;
  }
  public resetWriteTimeout() {
    this._writeTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get writeTimeoutInput() {
    return this._writeTimeout;
  }
}
export interface PackDestinationOutputWavefrontExtraHttpHeaders {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#name PackDestination#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#value PackDestination#value}
  */
  readonly value: string;
}

export function packDestinationOutputWavefrontExtraHttpHeadersToTerraform(struct?: PackDestinationOutputWavefrontExtraHttpHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function packDestinationOutputWavefrontExtraHttpHeadersToHclTerraform(struct?: PackDestinationOutputWavefrontExtraHttpHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputWavefrontExtraHttpHeadersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackDestinationOutputWavefrontExtraHttpHeaders | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputWavefrontExtraHttpHeaders | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class PackDestinationOutputWavefrontExtraHttpHeadersList extends cdktf.ComplexList {
  public internalValue? : PackDestinationOutputWavefrontExtraHttpHeaders[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackDestinationOutputWavefrontExtraHttpHeadersOutputReference {
    return new PackDestinationOutputWavefrontExtraHttpHeadersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackDestinationOutputWavefrontPqControls {
}

export function packDestinationOutputWavefrontPqControlsToTerraform(struct?: PackDestinationOutputWavefrontPqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function packDestinationOutputWavefrontPqControlsToHclTerraform(struct?: PackDestinationOutputWavefrontPqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class PackDestinationOutputWavefrontPqControlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackDestinationOutputWavefrontPqControls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputWavefrontPqControls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface PackDestinationOutputWavefrontResponseRetrySettings {
  /**
  * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc. Default: 2
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#backoff_rate PackDestination#backoff_rate}
  */
  readonly backoffRate?: number;
  /**
  * The HTTP response status code that will trigger retries
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#http_status PackDestination#http_status}
  */
  readonly httpStatus: number;
  /**
  * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes). Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#initial_backoff PackDestination#initial_backoff}
  */
  readonly initialBackoff?: number;
  /**
  * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds). Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_backoff PackDestination#max_backoff}
  */
  readonly maxBackoff?: number;
}

export function packDestinationOutputWavefrontResponseRetrySettingsToTerraform(struct?: PackDestinationOutputWavefrontResponseRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    backoff_rate: cdktf.numberToTerraform(struct!.backoffRate),
    http_status: cdktf.numberToTerraform(struct!.httpStatus),
    initial_backoff: cdktf.numberToTerraform(struct!.initialBackoff),
    max_backoff: cdktf.numberToTerraform(struct!.maxBackoff),
  }
}


export function packDestinationOutputWavefrontResponseRetrySettingsToHclTerraform(struct?: PackDestinationOutputWavefrontResponseRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    backoff_rate: {
      value: cdktf.numberToHclTerraform(struct!.backoffRate),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    http_status: {
      value: cdktf.numberToHclTerraform(struct!.httpStatus),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    initial_backoff: {
      value: cdktf.numberToHclTerraform(struct!.initialBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_backoff: {
      value: cdktf.numberToHclTerraform(struct!.maxBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputWavefrontResponseRetrySettingsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackDestinationOutputWavefrontResponseRetrySettings | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._backoffRate !== undefined) {
      hasAnyValues = true;
      internalValueResult.backoffRate = this._backoffRate;
    }
    if (this._httpStatus !== undefined) {
      hasAnyValues = true;
      internalValueResult.httpStatus = this._httpStatus;
    }
    if (this._initialBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.initialBackoff = this._initialBackoff;
    }
    if (this._maxBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBackoff = this._maxBackoff;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputWavefrontResponseRetrySettings | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._backoffRate = undefined;
      this._httpStatus = undefined;
      this._initialBackoff = undefined;
      this._maxBackoff = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._backoffRate = value.backoffRate;
      this._httpStatus = value.httpStatus;
      this._initialBackoff = value.initialBackoff;
      this._maxBackoff = value.maxBackoff;
    }
  }

  // backoff_rate - computed: true, optional: true, required: false
  private _backoffRate?: number; 
  public get backoffRate() {
    return this.getNumberAttribute('backoff_rate');
  }
  public set backoffRate(value: number) {
    this._backoffRate = value;
  }
  public resetBackoffRate() {
    this._backoffRate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get backoffRateInput() {
    return this._backoffRate;
  }

  // http_status - computed: false, optional: false, required: true
  private _httpStatus?: number; 
  public get httpStatus() {
    return this.getNumberAttribute('http_status');
  }
  public set httpStatus(value: number) {
    this._httpStatus = value;
  }
  // Temporarily expose input value. Use with caution.
  public get httpStatusInput() {
    return this._httpStatus;
  }

  // initial_backoff - computed: true, optional: true, required: false
  private _initialBackoff?: number; 
  public get initialBackoff() {
    return this.getNumberAttribute('initial_backoff');
  }
  public set initialBackoff(value: number) {
    this._initialBackoff = value;
  }
  public resetInitialBackoff() {
    this._initialBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get initialBackoffInput() {
    return this._initialBackoff;
  }

  // max_backoff - computed: true, optional: true, required: false
  private _maxBackoff?: number; 
  public get maxBackoff() {
    return this.getNumberAttribute('max_backoff');
  }
  public set maxBackoff(value: number) {
    this._maxBackoff = value;
  }
  public resetMaxBackoff() {
    this._maxBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBackoffInput() {
    return this._maxBackoff;
  }
}

export class PackDestinationOutputWavefrontResponseRetrySettingsList extends cdktf.ComplexList {
  public internalValue? : PackDestinationOutputWavefrontResponseRetrySettings[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackDestinationOutputWavefrontResponseRetrySettingsOutputReference {
    return new PackDestinationOutputWavefrontResponseRetrySettingsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackDestinationOutputWavefrontTimeoutRetrySettings {
  /**
  * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc. Default: 2
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#backoff_rate PackDestination#backoff_rate}
  */
  readonly backoffRate?: number;
  /**
  * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes). Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#initial_backoff PackDestination#initial_backoff}
  */
  readonly initialBackoff?: number;
  /**
  * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds). Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_backoff PackDestination#max_backoff}
  */
  readonly maxBackoff?: number;
  /**
  * Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#timeout_retry PackDestination#timeout_retry}
  */
  readonly timeoutRetry?: boolean | cdktf.IResolvable;
}

export function packDestinationOutputWavefrontTimeoutRetrySettingsToTerraform(struct?: PackDestinationOutputWavefrontTimeoutRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    backoff_rate: cdktf.numberToTerraform(struct!.backoffRate),
    initial_backoff: cdktf.numberToTerraform(struct!.initialBackoff),
    max_backoff: cdktf.numberToTerraform(struct!.maxBackoff),
    timeout_retry: cdktf.booleanToTerraform(struct!.timeoutRetry),
  }
}


export function packDestinationOutputWavefrontTimeoutRetrySettingsToHclTerraform(struct?: PackDestinationOutputWavefrontTimeoutRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    backoff_rate: {
      value: cdktf.numberToHclTerraform(struct!.backoffRate),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    initial_backoff: {
      value: cdktf.numberToHclTerraform(struct!.initialBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_backoff: {
      value: cdktf.numberToHclTerraform(struct!.maxBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    timeout_retry: {
      value: cdktf.booleanToHclTerraform(struct!.timeoutRetry),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputWavefrontTimeoutRetrySettingsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackDestinationOutputWavefrontTimeoutRetrySettings | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._backoffRate !== undefined) {
      hasAnyValues = true;
      internalValueResult.backoffRate = this._backoffRate;
    }
    if (this._initialBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.initialBackoff = this._initialBackoff;
    }
    if (this._maxBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBackoff = this._maxBackoff;
    }
    if (this._timeoutRetry !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutRetry = this._timeoutRetry;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputWavefrontTimeoutRetrySettings | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._backoffRate = undefined;
      this._initialBackoff = undefined;
      this._maxBackoff = undefined;
      this._timeoutRetry = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._backoffRate = value.backoffRate;
      this._initialBackoff = value.initialBackoff;
      this._maxBackoff = value.maxBackoff;
      this._timeoutRetry = value.timeoutRetry;
    }
  }

  // backoff_rate - computed: true, optional: true, required: false
  private _backoffRate?: number; 
  public get backoffRate() {
    return this.getNumberAttribute('backoff_rate');
  }
  public set backoffRate(value: number) {
    this._backoffRate = value;
  }
  public resetBackoffRate() {
    this._backoffRate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get backoffRateInput() {
    return this._backoffRate;
  }

  // initial_backoff - computed: true, optional: true, required: false
  private _initialBackoff?: number; 
  public get initialBackoff() {
    return this.getNumberAttribute('initial_backoff');
  }
  public set initialBackoff(value: number) {
    this._initialBackoff = value;
  }
  public resetInitialBackoff() {
    this._initialBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get initialBackoffInput() {
    return this._initialBackoff;
  }

  // max_backoff - computed: true, optional: true, required: false
  private _maxBackoff?: number; 
  public get maxBackoff() {
    return this.getNumberAttribute('max_backoff');
  }
  public set maxBackoff(value: number) {
    this._maxBackoff = value;
  }
  public resetMaxBackoff() {
    this._maxBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBackoffInput() {
    return this._maxBackoff;
  }

  // timeout_retry - computed: true, optional: true, required: false
  private _timeoutRetry?: boolean | cdktf.IResolvable; 
  public get timeoutRetry() {
    return this.getBooleanAttribute('timeout_retry');
  }
  public set timeoutRetry(value: boolean | cdktf.IResolvable) {
    this._timeoutRetry = value;
  }
  public resetTimeoutRetry() {
    this._timeoutRetry = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutRetryInput() {
    return this._timeoutRetry;
  }
}
export interface PackDestinationOutputWavefront {
  /**
  * Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate. Default: "manual"; must be one of ["manual", "secret"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#auth_type PackDestination#auth_type}
  */
  readonly authType?: string;
  /**
  * Compress the payload body before sending. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#compress PackDestination#compress}
  */
  readonly compress?: boolean | cdktf.IResolvable;
  /**
  * Maximum number of ongoing requests before blocking. Default: 5
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#concurrency PackDestination#concurrency}
  */
  readonly concurrency?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#description PackDestination#description}
  */
  readonly description?: string;
  /**
  * WaveFront domain name, e.g. "longboard". Default: "longboard"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#domain PackDestination#domain}
  */
  readonly domain?: string;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#environment PackDestination#environment}
  */
  readonly environment?: string;
  /**
  * Headers to add to all events
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#extra_http_headers PackDestination#extra_http_headers}
  */
  readonly extraHttpHeaders?: PackDestinationOutputWavefrontExtraHttpHeaders[] | cdktf.IResolvable;
  /**
  * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below. Default: "none"; must be one of ["payload", "payloadAndHeaders", "none"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#failed_request_logging_mode PackDestination#failed_request_logging_mode}
  */
  readonly failedRequestLoggingMode?: string;
  /**
  * Maximum time between requests. Small values could cause the payload size to be smaller than the configured Body size limit. Default: 1
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#flush_period_sec PackDestination#flush_period_sec}
  */
  readonly flushPeriodSec?: number;
  /**
  * Unique ID for this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#id PackDestination#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * Maximum number of events to include in the request body. Default is 0 (unlimited). Default: 0
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_payload_events PackDestination#max_payload_events}
  */
  readonly maxPayloadEvents?: number;
  /**
  * Maximum size, in KB, of the request body. Default: 4096
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_payload_size_kb PackDestination#max_payload_size_kb}
  */
  readonly maxPayloadSizeKb?: number;
  /**
  * How to handle events when all receivers are exerting backpressure. Default: "block"; must be one of ["block", "drop", "queue"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#on_backpressure PackDestination#on_backpressure}
  */
  readonly onBackpressure?: string;
  /**
  * Pipeline to process data before sending out to this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pipeline PackDestination#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_compress PackDestination#pq_compress}
  */
  readonly pqCompress?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_controls PackDestination#pq_controls}
  */
  readonly pqControls?: PackDestinationOutputWavefrontPqControls;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.). Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_max_file_size PackDestination#pq_max_file_size}
  */
  readonly pqMaxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_max_size PackDestination#pq_max_size}
  */
  readonly pqMaxSize?: string;
  /**
  * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem. Default: "error"; must be one of ["error", "backpressure", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_mode PackDestination#pq_mode}
  */
  readonly pqMode?: string;
  /**
  * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged. Default: "block"; must be one of ["block", "drop"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_on_backpressure PackDestination#pq_on_backpressure}
  */
  readonly pqOnBackpressure?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_path PackDestination#pq_path}
  */
  readonly pqPath?: string;
  /**
  * Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's). 
  *         Enabled by default. When this setting is also present in TLS Settings (Client Side), 
  *         that value will take precedence.
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#reject_unauthorized PackDestination#reject_unauthorized}
  */
  readonly rejectUnauthorized?: boolean | cdktf.IResolvable;
  /**
  * Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#response_honor_retry_after_header PackDestination#response_honor_retry_after_header}
  */
  readonly responseHonorRetryAfterHeader?: boolean | cdktf.IResolvable;
  /**
  * Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#response_retry_settings PackDestination#response_retry_settings}
  */
  readonly responseRetrySettings?: PackDestinationOutputWavefrontResponseRetrySettings[] | cdktf.IResolvable;
  /**
  * List of headers that are safe to log in plain text. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#safe_headers PackDestination#safe_headers}
  */
  readonly safeHeaders?: string[];
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#streamtags PackDestination#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Fields to automatically add to events, such as cribl_pipe. Supports wildcards. Default: ["cribl_pipe"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#system_fields PackDestination#system_fields}
  */
  readonly systemFields?: string[];
  /**
  * Select or create a stored text secret
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#text_secret PackDestination#text_secret}
  */
  readonly textSecret?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#timeout_retry_settings PackDestination#timeout_retry_settings}
  */
  readonly timeoutRetrySettings?: PackDestinationOutputWavefrontTimeoutRetrySettings;
  /**
  * Amount of time, in seconds, to wait for a request to complete before canceling it. Default: 30
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#timeout_sec PackDestination#timeout_sec}
  */
  readonly timeoutSec?: number;
  /**
  * WaveFront API authentication token (see [here](https://docs.wavefront.com/wavefront_api.html#generating-an-api-token))
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#token PackDestination#token}
  */
  readonly token?: string;
  /**
  * must be "wavefront"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#type PackDestination#type}
  */
  readonly type: string;
  /**
  * Enable round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. For optimal performance, consider enabling this setting for non-load balanced destinations. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#use_round_robin_dns PackDestination#use_round_robin_dns}
  */
  readonly useRoundRobinDns?: boolean | cdktf.IResolvable;
}

export function packDestinationOutputWavefrontToTerraform(struct?: PackDestinationOutputWavefront | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    auth_type: cdktf.stringToTerraform(struct!.authType),
    compress: cdktf.booleanToTerraform(struct!.compress),
    concurrency: cdktf.numberToTerraform(struct!.concurrency),
    description: cdktf.stringToTerraform(struct!.description),
    domain: cdktf.stringToTerraform(struct!.domain),
    environment: cdktf.stringToTerraform(struct!.environment),
    extra_http_headers: cdktf.listMapper(packDestinationOutputWavefrontExtraHttpHeadersToTerraform, false)(struct!.extraHttpHeaders),
    failed_request_logging_mode: cdktf.stringToTerraform(struct!.failedRequestLoggingMode),
    flush_period_sec: cdktf.numberToTerraform(struct!.flushPeriodSec),
    id: cdktf.stringToTerraform(struct!.id),
    max_payload_events: cdktf.numberToTerraform(struct!.maxPayloadEvents),
    max_payload_size_kb: cdktf.numberToTerraform(struct!.maxPayloadSizeKb),
    on_backpressure: cdktf.stringToTerraform(struct!.onBackpressure),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    pq_compress: cdktf.stringToTerraform(struct!.pqCompress),
    pq_controls: packDestinationOutputWavefrontPqControlsToTerraform(struct!.pqControls),
    pq_max_file_size: cdktf.stringToTerraform(struct!.pqMaxFileSize),
    pq_max_size: cdktf.stringToTerraform(struct!.pqMaxSize),
    pq_mode: cdktf.stringToTerraform(struct!.pqMode),
    pq_on_backpressure: cdktf.stringToTerraform(struct!.pqOnBackpressure),
    pq_path: cdktf.stringToTerraform(struct!.pqPath),
    reject_unauthorized: cdktf.booleanToTerraform(struct!.rejectUnauthorized),
    response_honor_retry_after_header: cdktf.booleanToTerraform(struct!.responseHonorRetryAfterHeader),
    response_retry_settings: cdktf.listMapper(packDestinationOutputWavefrontResponseRetrySettingsToTerraform, false)(struct!.responseRetrySettings),
    safe_headers: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.safeHeaders),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    system_fields: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.systemFields),
    text_secret: cdktf.stringToTerraform(struct!.textSecret),
    timeout_retry_settings: packDestinationOutputWavefrontTimeoutRetrySettingsToTerraform(struct!.timeoutRetrySettings),
    timeout_sec: cdktf.numberToTerraform(struct!.timeoutSec),
    token: cdktf.stringToTerraform(struct!.token),
    type: cdktf.stringToTerraform(struct!.type),
    use_round_robin_dns: cdktf.booleanToTerraform(struct!.useRoundRobinDns),
  }
}


export function packDestinationOutputWavefrontToHclTerraform(struct?: PackDestinationOutputWavefront | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    auth_type: {
      value: cdktf.stringToHclTerraform(struct!.authType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    compress: {
      value: cdktf.booleanToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    concurrency: {
      value: cdktf.numberToHclTerraform(struct!.concurrency),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    domain: {
      value: cdktf.stringToHclTerraform(struct!.domain),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    extra_http_headers: {
      value: cdktf.listMapperHcl(packDestinationOutputWavefrontExtraHttpHeadersToHclTerraform, false)(struct!.extraHttpHeaders),
      isBlock: true,
      type: "list",
      storageClassType: "PackDestinationOutputWavefrontExtraHttpHeadersList",
    },
    failed_request_logging_mode: {
      value: cdktf.stringToHclTerraform(struct!.failedRequestLoggingMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    flush_period_sec: {
      value: cdktf.numberToHclTerraform(struct!.flushPeriodSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_payload_events: {
      value: cdktf.numberToHclTerraform(struct!.maxPayloadEvents),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_payload_size_kb: {
      value: cdktf.numberToHclTerraform(struct!.maxPayloadSizeKb),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.onBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_compress: {
      value: cdktf.stringToHclTerraform(struct!.pqCompress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_controls: {
      value: packDestinationOutputWavefrontPqControlsToHclTerraform(struct!.pqControls),
      isBlock: true,
      type: "struct",
      storageClassType: "PackDestinationOutputWavefrontPqControls",
    },
    pq_max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_max_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_mode: {
      value: cdktf.stringToHclTerraform(struct!.pqMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.pqOnBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_path: {
      value: cdktf.stringToHclTerraform(struct!.pqPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reject_unauthorized: {
      value: cdktf.booleanToHclTerraform(struct!.rejectUnauthorized),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    response_honor_retry_after_header: {
      value: cdktf.booleanToHclTerraform(struct!.responseHonorRetryAfterHeader),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    response_retry_settings: {
      value: cdktf.listMapperHcl(packDestinationOutputWavefrontResponseRetrySettingsToHclTerraform, false)(struct!.responseRetrySettings),
      isBlock: true,
      type: "list",
      storageClassType: "PackDestinationOutputWavefrontResponseRetrySettingsList",
    },
    safe_headers: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.safeHeaders),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    system_fields: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.systemFields),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    text_secret: {
      value: cdktf.stringToHclTerraform(struct!.textSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    timeout_retry_settings: {
      value: packDestinationOutputWavefrontTimeoutRetrySettingsToHclTerraform(struct!.timeoutRetrySettings),
      isBlock: true,
      type: "struct",
      storageClassType: "PackDestinationOutputWavefrontTimeoutRetrySettings",
    },
    timeout_sec: {
      value: cdktf.numberToHclTerraform(struct!.timeoutSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    token: {
      value: cdktf.stringToHclTerraform(struct!.token),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    use_round_robin_dns: {
      value: cdktf.booleanToHclTerraform(struct!.useRoundRobinDns),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputWavefrontOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackDestinationOutputWavefront | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._authType !== undefined) {
      hasAnyValues = true;
      internalValueResult.authType = this._authType;
    }
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._concurrency !== undefined) {
      hasAnyValues = true;
      internalValueResult.concurrency = this._concurrency;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._domain !== undefined) {
      hasAnyValues = true;
      internalValueResult.domain = this._domain;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._extraHttpHeaders?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.extraHttpHeaders = this._extraHttpHeaders?.internalValue;
    }
    if (this._failedRequestLoggingMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.failedRequestLoggingMode = this._failedRequestLoggingMode;
    }
    if (this._flushPeriodSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.flushPeriodSec = this._flushPeriodSec;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._maxPayloadEvents !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxPayloadEvents = this._maxPayloadEvents;
    }
    if (this._maxPayloadSizeKb !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxPayloadSizeKb = this._maxPayloadSizeKb;
    }
    if (this._onBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.onBackpressure = this._onBackpressure;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._pqCompress !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqCompress = this._pqCompress;
    }
    if (this._pqControls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqControls = this._pqControls?.internalValue;
    }
    if (this._pqMaxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxFileSize = this._pqMaxFileSize;
    }
    if (this._pqMaxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxSize = this._pqMaxSize;
    }
    if (this._pqMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMode = this._pqMode;
    }
    if (this._pqOnBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqOnBackpressure = this._pqOnBackpressure;
    }
    if (this._pqPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqPath = this._pqPath;
    }
    if (this._rejectUnauthorized !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectUnauthorized = this._rejectUnauthorized;
    }
    if (this._responseHonorRetryAfterHeader !== undefined) {
      hasAnyValues = true;
      internalValueResult.responseHonorRetryAfterHeader = this._responseHonorRetryAfterHeader;
    }
    if (this._responseRetrySettings?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.responseRetrySettings = this._responseRetrySettings?.internalValue;
    }
    if (this._safeHeaders !== undefined) {
      hasAnyValues = true;
      internalValueResult.safeHeaders = this._safeHeaders;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._systemFields !== undefined) {
      hasAnyValues = true;
      internalValueResult.systemFields = this._systemFields;
    }
    if (this._textSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.textSecret = this._textSecret;
    }
    if (this._timeoutRetrySettings?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutRetrySettings = this._timeoutRetrySettings?.internalValue;
    }
    if (this._timeoutSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutSec = this._timeoutSec;
    }
    if (this._token !== undefined) {
      hasAnyValues = true;
      internalValueResult.token = this._token;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._useRoundRobinDns !== undefined) {
      hasAnyValues = true;
      internalValueResult.useRoundRobinDns = this._useRoundRobinDns;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputWavefront | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._authType = undefined;
      this._compress = undefined;
      this._concurrency = undefined;
      this._description = undefined;
      this._domain = undefined;
      this._environment = undefined;
      this._extraHttpHeaders.internalValue = undefined;
      this._failedRequestLoggingMode = undefined;
      this._flushPeriodSec = undefined;
      this._id = undefined;
      this._maxPayloadEvents = undefined;
      this._maxPayloadSizeKb = undefined;
      this._onBackpressure = undefined;
      this._pipeline = undefined;
      this._pqCompress = undefined;
      this._pqControls.internalValue = undefined;
      this._pqMaxFileSize = undefined;
      this._pqMaxSize = undefined;
      this._pqMode = undefined;
      this._pqOnBackpressure = undefined;
      this._pqPath = undefined;
      this._rejectUnauthorized = undefined;
      this._responseHonorRetryAfterHeader = undefined;
      this._responseRetrySettings.internalValue = undefined;
      this._safeHeaders = undefined;
      this._streamtags = undefined;
      this._systemFields = undefined;
      this._textSecret = undefined;
      this._timeoutRetrySettings.internalValue = undefined;
      this._timeoutSec = undefined;
      this._token = undefined;
      this._type = undefined;
      this._useRoundRobinDns = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._authType = value.authType;
      this._compress = value.compress;
      this._concurrency = value.concurrency;
      this._description = value.description;
      this._domain = value.domain;
      this._environment = value.environment;
      this._extraHttpHeaders.internalValue = value.extraHttpHeaders;
      this._failedRequestLoggingMode = value.failedRequestLoggingMode;
      this._flushPeriodSec = value.flushPeriodSec;
      this._id = value.id;
      this._maxPayloadEvents = value.maxPayloadEvents;
      this._maxPayloadSizeKb = value.maxPayloadSizeKb;
      this._onBackpressure = value.onBackpressure;
      this._pipeline = value.pipeline;
      this._pqCompress = value.pqCompress;
      this._pqControls.internalValue = value.pqControls;
      this._pqMaxFileSize = value.pqMaxFileSize;
      this._pqMaxSize = value.pqMaxSize;
      this._pqMode = value.pqMode;
      this._pqOnBackpressure = value.pqOnBackpressure;
      this._pqPath = value.pqPath;
      this._rejectUnauthorized = value.rejectUnauthorized;
      this._responseHonorRetryAfterHeader = value.responseHonorRetryAfterHeader;
      this._responseRetrySettings.internalValue = value.responseRetrySettings;
      this._safeHeaders = value.safeHeaders;
      this._streamtags = value.streamtags;
      this._systemFields = value.systemFields;
      this._textSecret = value.textSecret;
      this._timeoutRetrySettings.internalValue = value.timeoutRetrySettings;
      this._timeoutSec = value.timeoutSec;
      this._token = value.token;
      this._type = value.type;
      this._useRoundRobinDns = value.useRoundRobinDns;
    }
  }

  // auth_type - computed: true, optional: true, required: false
  private _authType?: string; 
  public get authType() {
    return this.getStringAttribute('auth_type');
  }
  public set authType(value: string) {
    this._authType = value;
  }
  public resetAuthType() {
    this._authType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authTypeInput() {
    return this._authType;
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: boolean | cdktf.IResolvable; 
  public get compress() {
    return this.getBooleanAttribute('compress');
  }
  public set compress(value: boolean | cdktf.IResolvable) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // concurrency - computed: true, optional: true, required: false
  private _concurrency?: number; 
  public get concurrency() {
    return this.getNumberAttribute('concurrency');
  }
  public set concurrency(value: number) {
    this._concurrency = value;
  }
  public resetConcurrency() {
    this._concurrency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get concurrencyInput() {
    return this._concurrency;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // domain - computed: true, optional: true, required: false
  private _domain?: string; 
  public get domain() {
    return this.getStringAttribute('domain');
  }
  public set domain(value: string) {
    this._domain = value;
  }
  public resetDomain() {
    this._domain = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get domainInput() {
    return this._domain;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // extra_http_headers - computed: false, optional: true, required: false
  private _extraHttpHeaders = new PackDestinationOutputWavefrontExtraHttpHeadersList(this, "extra_http_headers", false);
  public get extraHttpHeaders() {
    return this._extraHttpHeaders;
  }
  public putExtraHttpHeaders(value: PackDestinationOutputWavefrontExtraHttpHeaders[] | cdktf.IResolvable) {
    this._extraHttpHeaders.internalValue = value;
  }
  public resetExtraHttpHeaders() {
    this._extraHttpHeaders.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get extraHttpHeadersInput() {
    return this._extraHttpHeaders.internalValue;
  }

  // failed_request_logging_mode - computed: true, optional: true, required: false
  private _failedRequestLoggingMode?: string; 
  public get failedRequestLoggingMode() {
    return this.getStringAttribute('failed_request_logging_mode');
  }
  public set failedRequestLoggingMode(value: string) {
    this._failedRequestLoggingMode = value;
  }
  public resetFailedRequestLoggingMode() {
    this._failedRequestLoggingMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get failedRequestLoggingModeInput() {
    return this._failedRequestLoggingMode;
  }

  // flush_period_sec - computed: true, optional: true, required: false
  private _flushPeriodSec?: number; 
  public get flushPeriodSec() {
    return this.getNumberAttribute('flush_period_sec');
  }
  public set flushPeriodSec(value: number) {
    this._flushPeriodSec = value;
  }
  public resetFlushPeriodSec() {
    this._flushPeriodSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get flushPeriodSecInput() {
    return this._flushPeriodSec;
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // max_payload_events - computed: true, optional: true, required: false
  private _maxPayloadEvents?: number; 
  public get maxPayloadEvents() {
    return this.getNumberAttribute('max_payload_events');
  }
  public set maxPayloadEvents(value: number) {
    this._maxPayloadEvents = value;
  }
  public resetMaxPayloadEvents() {
    this._maxPayloadEvents = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxPayloadEventsInput() {
    return this._maxPayloadEvents;
  }

  // max_payload_size_kb - computed: true, optional: true, required: false
  private _maxPayloadSizeKb?: number; 
  public get maxPayloadSizeKb() {
    return this.getNumberAttribute('max_payload_size_kb');
  }
  public set maxPayloadSizeKb(value: number) {
    this._maxPayloadSizeKb = value;
  }
  public resetMaxPayloadSizeKb() {
    this._maxPayloadSizeKb = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxPayloadSizeKbInput() {
    return this._maxPayloadSizeKb;
  }

  // on_backpressure - computed: true, optional: true, required: false
  private _onBackpressure?: string; 
  public get onBackpressure() {
    return this.getStringAttribute('on_backpressure');
  }
  public set onBackpressure(value: string) {
    this._onBackpressure = value;
  }
  public resetOnBackpressure() {
    this._onBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get onBackpressureInput() {
    return this._onBackpressure;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // pq_compress - computed: true, optional: true, required: false
  private _pqCompress?: string; 
  public get pqCompress() {
    return this.getStringAttribute('pq_compress');
  }
  public set pqCompress(value: string) {
    this._pqCompress = value;
  }
  public resetPqCompress() {
    this._pqCompress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqCompressInput() {
    return this._pqCompress;
  }

  // pq_controls - computed: false, optional: true, required: false
  private _pqControls = new PackDestinationOutputWavefrontPqControlsOutputReference(this, "pq_controls");
  public get pqControls() {
    return this._pqControls;
  }
  public putPqControls(value: PackDestinationOutputWavefrontPqControls) {
    this._pqControls.internalValue = value;
  }
  public resetPqControls() {
    this._pqControls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqControlsInput() {
    return this._pqControls.internalValue;
  }

  // pq_max_file_size - computed: true, optional: true, required: false
  private _pqMaxFileSize?: string; 
  public get pqMaxFileSize() {
    return this.getStringAttribute('pq_max_file_size');
  }
  public set pqMaxFileSize(value: string) {
    this._pqMaxFileSize = value;
  }
  public resetPqMaxFileSize() {
    this._pqMaxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxFileSizeInput() {
    return this._pqMaxFileSize;
  }

  // pq_max_size - computed: true, optional: true, required: false
  private _pqMaxSize?: string; 
  public get pqMaxSize() {
    return this.getStringAttribute('pq_max_size');
  }
  public set pqMaxSize(value: string) {
    this._pqMaxSize = value;
  }
  public resetPqMaxSize() {
    this._pqMaxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxSizeInput() {
    return this._pqMaxSize;
  }

  // pq_mode - computed: true, optional: true, required: false
  private _pqMode?: string; 
  public get pqMode() {
    return this.getStringAttribute('pq_mode');
  }
  public set pqMode(value: string) {
    this._pqMode = value;
  }
  public resetPqMode() {
    this._pqMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqModeInput() {
    return this._pqMode;
  }

  // pq_on_backpressure - computed: true, optional: true, required: false
  private _pqOnBackpressure?: string; 
  public get pqOnBackpressure() {
    return this.getStringAttribute('pq_on_backpressure');
  }
  public set pqOnBackpressure(value: string) {
    this._pqOnBackpressure = value;
  }
  public resetPqOnBackpressure() {
    this._pqOnBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqOnBackpressureInput() {
    return this._pqOnBackpressure;
  }

  // pq_path - computed: true, optional: true, required: false
  private _pqPath?: string; 
  public get pqPath() {
    return this.getStringAttribute('pq_path');
  }
  public set pqPath(value: string) {
    this._pqPath = value;
  }
  public resetPqPath() {
    this._pqPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqPathInput() {
    return this._pqPath;
  }

  // reject_unauthorized - computed: true, optional: true, required: false
  private _rejectUnauthorized?: boolean | cdktf.IResolvable; 
  public get rejectUnauthorized() {
    return this.getBooleanAttribute('reject_unauthorized');
  }
  public set rejectUnauthorized(value: boolean | cdktf.IResolvable) {
    this._rejectUnauthorized = value;
  }
  public resetRejectUnauthorized() {
    this._rejectUnauthorized = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectUnauthorizedInput() {
    return this._rejectUnauthorized;
  }

  // response_honor_retry_after_header - computed: true, optional: true, required: false
  private _responseHonorRetryAfterHeader?: boolean | cdktf.IResolvable; 
  public get responseHonorRetryAfterHeader() {
    return this.getBooleanAttribute('response_honor_retry_after_header');
  }
  public set responseHonorRetryAfterHeader(value: boolean | cdktf.IResolvable) {
    this._responseHonorRetryAfterHeader = value;
  }
  public resetResponseHonorRetryAfterHeader() {
    this._responseHonorRetryAfterHeader = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get responseHonorRetryAfterHeaderInput() {
    return this._responseHonorRetryAfterHeader;
  }

  // response_retry_settings - computed: false, optional: true, required: false
  private _responseRetrySettings = new PackDestinationOutputWavefrontResponseRetrySettingsList(this, "response_retry_settings", false);
  public get responseRetrySettings() {
    return this._responseRetrySettings;
  }
  public putResponseRetrySettings(value: PackDestinationOutputWavefrontResponseRetrySettings[] | cdktf.IResolvable) {
    this._responseRetrySettings.internalValue = value;
  }
  public resetResponseRetrySettings() {
    this._responseRetrySettings.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get responseRetrySettingsInput() {
    return this._responseRetrySettings.internalValue;
  }

  // safe_headers - computed: true, optional: true, required: false
  private _safeHeaders?: string[]; 
  public get safeHeaders() {
    return this.getListAttribute('safe_headers');
  }
  public set safeHeaders(value: string[]) {
    this._safeHeaders = value;
  }
  public resetSafeHeaders() {
    this._safeHeaders = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get safeHeadersInput() {
    return this._safeHeaders;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // system_fields - computed: true, optional: true, required: false
  private _systemFields?: string[]; 
  public get systemFields() {
    return this.getListAttribute('system_fields');
  }
  public set systemFields(value: string[]) {
    this._systemFields = value;
  }
  public resetSystemFields() {
    this._systemFields = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get systemFieldsInput() {
    return this._systemFields;
  }

  // text_secret - computed: false, optional: true, required: false
  private _textSecret?: string; 
  public get textSecret() {
    return this.getStringAttribute('text_secret');
  }
  public set textSecret(value: string) {
    this._textSecret = value;
  }
  public resetTextSecret() {
    this._textSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get textSecretInput() {
    return this._textSecret;
  }

  // timeout_retry_settings - computed: false, optional: true, required: false
  private _timeoutRetrySettings = new PackDestinationOutputWavefrontTimeoutRetrySettingsOutputReference(this, "timeout_retry_settings");
  public get timeoutRetrySettings() {
    return this._timeoutRetrySettings;
  }
  public putTimeoutRetrySettings(value: PackDestinationOutputWavefrontTimeoutRetrySettings) {
    this._timeoutRetrySettings.internalValue = value;
  }
  public resetTimeoutRetrySettings() {
    this._timeoutRetrySettings.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutRetrySettingsInput() {
    return this._timeoutRetrySettings.internalValue;
  }

  // timeout_sec - computed: true, optional: true, required: false
  private _timeoutSec?: number; 
  public get timeoutSec() {
    return this.getNumberAttribute('timeout_sec');
  }
  public set timeoutSec(value: number) {
    this._timeoutSec = value;
  }
  public resetTimeoutSec() {
    this._timeoutSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutSecInput() {
    return this._timeoutSec;
  }

  // token - computed: false, optional: true, required: false
  private _token?: string; 
  public get token() {
    return this.getStringAttribute('token');
  }
  public set token(value: string) {
    this._token = value;
  }
  public resetToken() {
    this._token = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tokenInput() {
    return this._token;
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // use_round_robin_dns - computed: true, optional: true, required: false
  private _useRoundRobinDns?: boolean | cdktf.IResolvable; 
  public get useRoundRobinDns() {
    return this.getBooleanAttribute('use_round_robin_dns');
  }
  public set useRoundRobinDns(value: boolean | cdktf.IResolvable) {
    this._useRoundRobinDns = value;
  }
  public resetUseRoundRobinDns() {
    this._useRoundRobinDns = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get useRoundRobinDnsInput() {
    return this._useRoundRobinDns;
  }
}
export interface PackDestinationOutputWebhookExtraHttpHeaders {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#name PackDestination#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#value PackDestination#value}
  */
  readonly value: string;
}

export function packDestinationOutputWebhookExtraHttpHeadersToTerraform(struct?: PackDestinationOutputWebhookExtraHttpHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function packDestinationOutputWebhookExtraHttpHeadersToHclTerraform(struct?: PackDestinationOutputWebhookExtraHttpHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputWebhookExtraHttpHeadersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackDestinationOutputWebhookExtraHttpHeaders | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputWebhookExtraHttpHeaders | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class PackDestinationOutputWebhookExtraHttpHeadersList extends cdktf.ComplexList {
  public internalValue? : PackDestinationOutputWebhookExtraHttpHeaders[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackDestinationOutputWebhookExtraHttpHeadersOutputReference {
    return new PackDestinationOutputWebhookExtraHttpHeadersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackDestinationOutputWebhookOauthHeaders {
  /**
  * OAuth header name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#name PackDestination#name}
  */
  readonly name: string;
  /**
  * OAuth header value
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#value PackDestination#value}
  */
  readonly value: string;
}

export function packDestinationOutputWebhookOauthHeadersToTerraform(struct?: PackDestinationOutputWebhookOauthHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function packDestinationOutputWebhookOauthHeadersToHclTerraform(struct?: PackDestinationOutputWebhookOauthHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputWebhookOauthHeadersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackDestinationOutputWebhookOauthHeaders | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputWebhookOauthHeaders | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class PackDestinationOutputWebhookOauthHeadersList extends cdktf.ComplexList {
  public internalValue? : PackDestinationOutputWebhookOauthHeaders[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackDestinationOutputWebhookOauthHeadersOutputReference {
    return new PackDestinationOutputWebhookOauthHeadersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackDestinationOutputWebhookOauthParams {
  /**
  * OAuth parameter name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#name PackDestination#name}
  */
  readonly name: string;
  /**
  * OAuth parameter value
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#value PackDestination#value}
  */
  readonly value: string;
}

export function packDestinationOutputWebhookOauthParamsToTerraform(struct?: PackDestinationOutputWebhookOauthParams | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function packDestinationOutputWebhookOauthParamsToHclTerraform(struct?: PackDestinationOutputWebhookOauthParams | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputWebhookOauthParamsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackDestinationOutputWebhookOauthParams | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputWebhookOauthParams | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class PackDestinationOutputWebhookOauthParamsList extends cdktf.ComplexList {
  public internalValue? : PackDestinationOutputWebhookOauthParams[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackDestinationOutputWebhookOauthParamsOutputReference {
    return new PackDestinationOutputWebhookOauthParamsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackDestinationOutputWebhookPqControls {
}

export function packDestinationOutputWebhookPqControlsToTerraform(struct?: PackDestinationOutputWebhookPqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function packDestinationOutputWebhookPqControlsToHclTerraform(struct?: PackDestinationOutputWebhookPqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class PackDestinationOutputWebhookPqControlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackDestinationOutputWebhookPqControls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputWebhookPqControls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface PackDestinationOutputWebhookResponseRetrySettings {
  /**
  * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc. Default: 2
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#backoff_rate PackDestination#backoff_rate}
  */
  readonly backoffRate?: number;
  /**
  * The HTTP response status code that will trigger retries
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#http_status PackDestination#http_status}
  */
  readonly httpStatus: number;
  /**
  * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes). Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#initial_backoff PackDestination#initial_backoff}
  */
  readonly initialBackoff?: number;
  /**
  * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds). Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_backoff PackDestination#max_backoff}
  */
  readonly maxBackoff?: number;
}

export function packDestinationOutputWebhookResponseRetrySettingsToTerraform(struct?: PackDestinationOutputWebhookResponseRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    backoff_rate: cdktf.numberToTerraform(struct!.backoffRate),
    http_status: cdktf.numberToTerraform(struct!.httpStatus),
    initial_backoff: cdktf.numberToTerraform(struct!.initialBackoff),
    max_backoff: cdktf.numberToTerraform(struct!.maxBackoff),
  }
}


export function packDestinationOutputWebhookResponseRetrySettingsToHclTerraform(struct?: PackDestinationOutputWebhookResponseRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    backoff_rate: {
      value: cdktf.numberToHclTerraform(struct!.backoffRate),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    http_status: {
      value: cdktf.numberToHclTerraform(struct!.httpStatus),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    initial_backoff: {
      value: cdktf.numberToHclTerraform(struct!.initialBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_backoff: {
      value: cdktf.numberToHclTerraform(struct!.maxBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputWebhookResponseRetrySettingsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackDestinationOutputWebhookResponseRetrySettings | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._backoffRate !== undefined) {
      hasAnyValues = true;
      internalValueResult.backoffRate = this._backoffRate;
    }
    if (this._httpStatus !== undefined) {
      hasAnyValues = true;
      internalValueResult.httpStatus = this._httpStatus;
    }
    if (this._initialBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.initialBackoff = this._initialBackoff;
    }
    if (this._maxBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBackoff = this._maxBackoff;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputWebhookResponseRetrySettings | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._backoffRate = undefined;
      this._httpStatus = undefined;
      this._initialBackoff = undefined;
      this._maxBackoff = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._backoffRate = value.backoffRate;
      this._httpStatus = value.httpStatus;
      this._initialBackoff = value.initialBackoff;
      this._maxBackoff = value.maxBackoff;
    }
  }

  // backoff_rate - computed: true, optional: true, required: false
  private _backoffRate?: number; 
  public get backoffRate() {
    return this.getNumberAttribute('backoff_rate');
  }
  public set backoffRate(value: number) {
    this._backoffRate = value;
  }
  public resetBackoffRate() {
    this._backoffRate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get backoffRateInput() {
    return this._backoffRate;
  }

  // http_status - computed: false, optional: false, required: true
  private _httpStatus?: number; 
  public get httpStatus() {
    return this.getNumberAttribute('http_status');
  }
  public set httpStatus(value: number) {
    this._httpStatus = value;
  }
  // Temporarily expose input value. Use with caution.
  public get httpStatusInput() {
    return this._httpStatus;
  }

  // initial_backoff - computed: true, optional: true, required: false
  private _initialBackoff?: number; 
  public get initialBackoff() {
    return this.getNumberAttribute('initial_backoff');
  }
  public set initialBackoff(value: number) {
    this._initialBackoff = value;
  }
  public resetInitialBackoff() {
    this._initialBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get initialBackoffInput() {
    return this._initialBackoff;
  }

  // max_backoff - computed: true, optional: true, required: false
  private _maxBackoff?: number; 
  public get maxBackoff() {
    return this.getNumberAttribute('max_backoff');
  }
  public set maxBackoff(value: number) {
    this._maxBackoff = value;
  }
  public resetMaxBackoff() {
    this._maxBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBackoffInput() {
    return this._maxBackoff;
  }
}

export class PackDestinationOutputWebhookResponseRetrySettingsList extends cdktf.ComplexList {
  public internalValue? : PackDestinationOutputWebhookResponseRetrySettings[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackDestinationOutputWebhookResponseRetrySettingsOutputReference {
    return new PackDestinationOutputWebhookResponseRetrySettingsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackDestinationOutputWebhookTimeoutRetrySettings {
  /**
  * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc. Default: 2
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#backoff_rate PackDestination#backoff_rate}
  */
  readonly backoffRate?: number;
  /**
  * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes). Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#initial_backoff PackDestination#initial_backoff}
  */
  readonly initialBackoff?: number;
  /**
  * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds). Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_backoff PackDestination#max_backoff}
  */
  readonly maxBackoff?: number;
  /**
  * Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#timeout_retry PackDestination#timeout_retry}
  */
  readonly timeoutRetry?: boolean | cdktf.IResolvable;
}

export function packDestinationOutputWebhookTimeoutRetrySettingsToTerraform(struct?: PackDestinationOutputWebhookTimeoutRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    backoff_rate: cdktf.numberToTerraform(struct!.backoffRate),
    initial_backoff: cdktf.numberToTerraform(struct!.initialBackoff),
    max_backoff: cdktf.numberToTerraform(struct!.maxBackoff),
    timeout_retry: cdktf.booleanToTerraform(struct!.timeoutRetry),
  }
}


export function packDestinationOutputWebhookTimeoutRetrySettingsToHclTerraform(struct?: PackDestinationOutputWebhookTimeoutRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    backoff_rate: {
      value: cdktf.numberToHclTerraform(struct!.backoffRate),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    initial_backoff: {
      value: cdktf.numberToHclTerraform(struct!.initialBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_backoff: {
      value: cdktf.numberToHclTerraform(struct!.maxBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    timeout_retry: {
      value: cdktf.booleanToHclTerraform(struct!.timeoutRetry),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputWebhookTimeoutRetrySettingsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackDestinationOutputWebhookTimeoutRetrySettings | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._backoffRate !== undefined) {
      hasAnyValues = true;
      internalValueResult.backoffRate = this._backoffRate;
    }
    if (this._initialBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.initialBackoff = this._initialBackoff;
    }
    if (this._maxBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBackoff = this._maxBackoff;
    }
    if (this._timeoutRetry !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutRetry = this._timeoutRetry;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputWebhookTimeoutRetrySettings | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._backoffRate = undefined;
      this._initialBackoff = undefined;
      this._maxBackoff = undefined;
      this._timeoutRetry = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._backoffRate = value.backoffRate;
      this._initialBackoff = value.initialBackoff;
      this._maxBackoff = value.maxBackoff;
      this._timeoutRetry = value.timeoutRetry;
    }
  }

  // backoff_rate - computed: true, optional: true, required: false
  private _backoffRate?: number; 
  public get backoffRate() {
    return this.getNumberAttribute('backoff_rate');
  }
  public set backoffRate(value: number) {
    this._backoffRate = value;
  }
  public resetBackoffRate() {
    this._backoffRate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get backoffRateInput() {
    return this._backoffRate;
  }

  // initial_backoff - computed: true, optional: true, required: false
  private _initialBackoff?: number; 
  public get initialBackoff() {
    return this.getNumberAttribute('initial_backoff');
  }
  public set initialBackoff(value: number) {
    this._initialBackoff = value;
  }
  public resetInitialBackoff() {
    this._initialBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get initialBackoffInput() {
    return this._initialBackoff;
  }

  // max_backoff - computed: true, optional: true, required: false
  private _maxBackoff?: number; 
  public get maxBackoff() {
    return this.getNumberAttribute('max_backoff');
  }
  public set maxBackoff(value: number) {
    this._maxBackoff = value;
  }
  public resetMaxBackoff() {
    this._maxBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBackoffInput() {
    return this._maxBackoff;
  }

  // timeout_retry - computed: true, optional: true, required: false
  private _timeoutRetry?: boolean | cdktf.IResolvable; 
  public get timeoutRetry() {
    return this.getBooleanAttribute('timeout_retry');
  }
  public set timeoutRetry(value: boolean | cdktf.IResolvable) {
    this._timeoutRetry = value;
  }
  public resetTimeoutRetry() {
    this._timeoutRetry = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutRetryInput() {
    return this._timeoutRetry;
  }
}
export interface PackDestinationOutputWebhookTls {
  /**
  * Path on client in which to find CA certificates to verify the server's cert. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#ca_path PackDestination#ca_path}
  */
  readonly caPath?: string;
  /**
  * Path on client in which to find certificates to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#cert_path PackDestination#cert_path}
  */
  readonly certPath?: string;
  /**
  * The name of the predefined certificate
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#certificate_name PackDestination#certificate_name}
  */
  readonly certificateName?: string;
  /**
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#disabled PackDestination#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_version PackDestination#max_version}
  */
  readonly maxVersion?: string;
  /**
  * must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#min_version PackDestination#min_version}
  */
  readonly minVersion?: string;
  /**
  * Passphrase to use to decrypt private key
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#passphrase PackDestination#passphrase}
  */
  readonly passphrase?: string;
  /**
  * Path on client in which to find the private key to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#priv_key_path PackDestination#priv_key_path}
  */
  readonly privKeyPath?: string;
  /**
  * Server name for the SNI (Server Name Indication) TLS extension. It must be a host name, and not an IP address.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#servername PackDestination#servername}
  */
  readonly servername?: string;
}

export function packDestinationOutputWebhookTlsToTerraform(struct?: PackDestinationOutputWebhookTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ca_path: cdktf.stringToTerraform(struct!.caPath),
    cert_path: cdktf.stringToTerraform(struct!.certPath),
    certificate_name: cdktf.stringToTerraform(struct!.certificateName),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    max_version: cdktf.stringToTerraform(struct!.maxVersion),
    min_version: cdktf.stringToTerraform(struct!.minVersion),
    passphrase: cdktf.stringToTerraform(struct!.passphrase),
    priv_key_path: cdktf.stringToTerraform(struct!.privKeyPath),
    servername: cdktf.stringToTerraform(struct!.servername),
  }
}


export function packDestinationOutputWebhookTlsToHclTerraform(struct?: PackDestinationOutputWebhookTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ca_path: {
      value: cdktf.stringToHclTerraform(struct!.caPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    cert_path: {
      value: cdktf.stringToHclTerraform(struct!.certPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    certificate_name: {
      value: cdktf.stringToHclTerraform(struct!.certificateName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    max_version: {
      value: cdktf.stringToHclTerraform(struct!.maxVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    min_version: {
      value: cdktf.stringToHclTerraform(struct!.minVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    passphrase: {
      value: cdktf.stringToHclTerraform(struct!.passphrase),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    priv_key_path: {
      value: cdktf.stringToHclTerraform(struct!.privKeyPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    servername: {
      value: cdktf.stringToHclTerraform(struct!.servername),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputWebhookTlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackDestinationOutputWebhookTls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._caPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.caPath = this._caPath;
    }
    if (this._certPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.certPath = this._certPath;
    }
    if (this._certificateName !== undefined) {
      hasAnyValues = true;
      internalValueResult.certificateName = this._certificateName;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._maxVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxVersion = this._maxVersion;
    }
    if (this._minVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.minVersion = this._minVersion;
    }
    if (this._passphrase !== undefined) {
      hasAnyValues = true;
      internalValueResult.passphrase = this._passphrase;
    }
    if (this._privKeyPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.privKeyPath = this._privKeyPath;
    }
    if (this._servername !== undefined) {
      hasAnyValues = true;
      internalValueResult.servername = this._servername;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputWebhookTls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._caPath = undefined;
      this._certPath = undefined;
      this._certificateName = undefined;
      this._disabled = undefined;
      this._maxVersion = undefined;
      this._minVersion = undefined;
      this._passphrase = undefined;
      this._privKeyPath = undefined;
      this._servername = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._caPath = value.caPath;
      this._certPath = value.certPath;
      this._certificateName = value.certificateName;
      this._disabled = value.disabled;
      this._maxVersion = value.maxVersion;
      this._minVersion = value.minVersion;
      this._passphrase = value.passphrase;
      this._privKeyPath = value.privKeyPath;
      this._servername = value.servername;
    }
  }

  // ca_path - computed: false, optional: true, required: false
  private _caPath?: string; 
  public get caPath() {
    return this.getStringAttribute('ca_path');
  }
  public set caPath(value: string) {
    this._caPath = value;
  }
  public resetCaPath() {
    this._caPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get caPathInput() {
    return this._caPath;
  }

  // cert_path - computed: false, optional: true, required: false
  private _certPath?: string; 
  public get certPath() {
    return this.getStringAttribute('cert_path');
  }
  public set certPath(value: string) {
    this._certPath = value;
  }
  public resetCertPath() {
    this._certPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certPathInput() {
    return this._certPath;
  }

  // certificate_name - computed: false, optional: true, required: false
  private _certificateName?: string; 
  public get certificateName() {
    return this.getStringAttribute('certificate_name');
  }
  public set certificateName(value: string) {
    this._certificateName = value;
  }
  public resetCertificateName() {
    this._certificateName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certificateNameInput() {
    return this._certificateName;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // max_version - computed: false, optional: true, required: false
  private _maxVersion?: string; 
  public get maxVersion() {
    return this.getStringAttribute('max_version');
  }
  public set maxVersion(value: string) {
    this._maxVersion = value;
  }
  public resetMaxVersion() {
    this._maxVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxVersionInput() {
    return this._maxVersion;
  }

  // min_version - computed: false, optional: true, required: false
  private _minVersion?: string; 
  public get minVersion() {
    return this.getStringAttribute('min_version');
  }
  public set minVersion(value: string) {
    this._minVersion = value;
  }
  public resetMinVersion() {
    this._minVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get minVersionInput() {
    return this._minVersion;
  }

  // passphrase - computed: false, optional: true, required: false
  private _passphrase?: string; 
  public get passphrase() {
    return this.getStringAttribute('passphrase');
  }
  public set passphrase(value: string) {
    this._passphrase = value;
  }
  public resetPassphrase() {
    this._passphrase = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passphraseInput() {
    return this._passphrase;
  }

  // priv_key_path - computed: false, optional: true, required: false
  private _privKeyPath?: string; 
  public get privKeyPath() {
    return this.getStringAttribute('priv_key_path');
  }
  public set privKeyPath(value: string) {
    this._privKeyPath = value;
  }
  public resetPrivKeyPath() {
    this._privKeyPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get privKeyPathInput() {
    return this._privKeyPath;
  }

  // servername - computed: false, optional: true, required: false
  private _servername?: string; 
  public get servername() {
    return this.getStringAttribute('servername');
  }
  public set servername(value: string) {
    this._servername = value;
  }
  public resetServername() {
    this._servername = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get servernameInput() {
    return this._servername;
  }
}
export interface PackDestinationOutputWebhookUrls {
  /**
  * URL of a webhook endpoint to send events to, such as http://localhost:10200
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#url PackDestination#url}
  */
  readonly url: string;
  /**
  * Assign a weight (>0) to each endpoint to indicate its traffic-handling capability. Default: 1
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#weight PackDestination#weight}
  */
  readonly weight?: number;
}

export function packDestinationOutputWebhookUrlsToTerraform(struct?: PackDestinationOutputWebhookUrls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    url: cdktf.stringToTerraform(struct!.url),
    weight: cdktf.numberToTerraform(struct!.weight),
  }
}


export function packDestinationOutputWebhookUrlsToHclTerraform(struct?: PackDestinationOutputWebhookUrls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    url: {
      value: cdktf.stringToHclTerraform(struct!.url),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    weight: {
      value: cdktf.numberToHclTerraform(struct!.weight),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputWebhookUrlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackDestinationOutputWebhookUrls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._url !== undefined) {
      hasAnyValues = true;
      internalValueResult.url = this._url;
    }
    if (this._weight !== undefined) {
      hasAnyValues = true;
      internalValueResult.weight = this._weight;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputWebhookUrls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._url = undefined;
      this._weight = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._url = value.url;
      this._weight = value.weight;
    }
  }

  // url - computed: false, optional: false, required: true
  private _url?: string; 
  public get url() {
    return this.getStringAttribute('url');
  }
  public set url(value: string) {
    this._url = value;
  }
  // Temporarily expose input value. Use with caution.
  public get urlInput() {
    return this._url;
  }

  // weight - computed: true, optional: true, required: false
  private _weight?: number; 
  public get weight() {
    return this.getNumberAttribute('weight');
  }
  public set weight(value: number) {
    this._weight = value;
  }
  public resetWeight() {
    this._weight = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get weightInput() {
    return this._weight;
  }
}

export class PackDestinationOutputWebhookUrlsList extends cdktf.ComplexList {
  public internalValue? : PackDestinationOutputWebhookUrls[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackDestinationOutputWebhookUrlsOutputReference {
    return new PackDestinationOutputWebhookUrlsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackDestinationOutputWebhook {
  /**
  * HTTP content-type header value. Default: "application/json"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#advanced_content_type PackDestination#advanced_content_type}
  */
  readonly advancedContentType?: string;
  /**
  * JavaScript expression to compute the Authorization header value to pass in requests. The value `${token}` is used to reference the token obtained from authentication, e.g.: `Bearer ${token}`. Default: "`Bearer ${token}`"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#auth_header_expr PackDestination#auth_header_expr}
  */
  readonly authHeaderExpr?: string;
  /**
  * Authentication method to use for the HTTP request. Default: "none"; must be one of ["none", "basic", "credentialsSecret", "token", "textSecret", "oauth"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#auth_type PackDestination#auth_type}
  */
  readonly authType?: string;
  /**
  * Compress the payload body before sending. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#compress PackDestination#compress}
  */
  readonly compress?: boolean | cdktf.IResolvable;
  /**
  * Maximum number of ongoing requests before blocking. Default: 5
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#concurrency PackDestination#concurrency}
  */
  readonly concurrency?: number;
  /**
  * Select or create a secret that references your credentials
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#credentials_secret PackDestination#credentials_secret}
  */
  readonly credentialsSecret?: string;
  /**
  * Content type to use for request. Defaults to application/x-ndjson. Any content types set in Advanced Settings > Extra HTTP headers will override this entry. Default: "application/x-ndjson"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#custom_content_type PackDestination#custom_content_type}
  */
  readonly customContentType?: string;
  /**
  * Whether to drop events when the source expression evaluates to null. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#custom_drop_when_null PackDestination#custom_drop_when_null}
  */
  readonly customDropWhenNull?: boolean | cdktf.IResolvable;
  /**
  * Delimiter string to insert between individual events. Defaults to newline character. Default: "\n"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#custom_event_delimiter PackDestination#custom_event_delimiter}
  */
  readonly customEventDelimiter?: string;
  /**
  * Expression specifying how to format the payload for each batch. To reference the events to send, use the `${events}` variable. Example expression: `{ "items" : [${events}] }` would send the batch inside a JSON object. Default: "`${events}`"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#custom_payload_expression PackDestination#custom_payload_expression}
  */
  readonly customPayloadExpression?: string;
  /**
  * Expression to evaluate on events to generate output. Example: `raw=${_raw}`. See [Cribl Docs](https://docs.cribl.io/stream/destinations-webhook#custom-format) for other examples. If empty, the full event is sent as stringified JSON. Default: "__httpOut"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#custom_source_expression PackDestination#custom_source_expression}
  */
  readonly customSourceExpression?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#description PackDestination#description}
  */
  readonly description?: string;
  /**
  * The interval in which to re-resolve any hostnames and pick up destinations from A records. Default: 600
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#dns_resolve_period_sec PackDestination#dns_resolve_period_sec}
  */
  readonly dnsResolvePeriodSec?: number;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#environment PackDestination#environment}
  */
  readonly environment?: string;
  /**
  * Exclude all IPs of the current host from the list of any resolved hostnames. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#exclude_self PackDestination#exclude_self}
  */
  readonly excludeSelf?: boolean | cdktf.IResolvable;
  /**
  * Headers to add to all events. You can also add headers dynamically on a per-event basis in the __headers field, as explained in [Cribl Docs](https://docs.cribl.io/stream/destinations-webhook/#internal-fields).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#extra_http_headers PackDestination#extra_http_headers}
  */
  readonly extraHttpHeaders?: PackDestinationOutputWebhookExtraHttpHeaders[] | cdktf.IResolvable;
  /**
  * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below. Default: "none"; must be one of ["payload", "payloadAndHeaders", "none"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#failed_request_logging_mode PackDestination#failed_request_logging_mode}
  */
  readonly failedRequestLoggingMode?: string;
  /**
  * Maximum time between requests. Small values could cause the payload size to be smaller than the configured Body size limit. Default: 1
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#flush_period_sec PackDestination#flush_period_sec}
  */
  readonly flushPeriodSec?: number;
  /**
  * How to format events before sending out. Default: "ndjson"; must be one of ["ndjson", "json_array", "custom", "advanced"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#format PackDestination#format}
  */
  readonly format?: string;
  /**
  * Custom JavaScript code to format incoming event data accessible through the __e variable. The formatted content is added to (__e['__eventOut']) if available. Otherwise, the original event is serialized as JSON. Caution: This function is evaluated in an unprotected context, allowing you to execute almost any JavaScript code.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#format_event_code PackDestination#format_event_code}
  */
  readonly formatEventCode?: string;
  /**
  * Optional JavaScript code to format the payload sent to the Destination. The payload, containing a batch of formatted events, is accessible through the __e['payload'] variable. The formatted payload is returned in the __e['__payloadOut'] variable. Caution: This function is evaluated in an unprotected context, allowing you to execute almost any JavaScript code.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#format_payload_code PackDestination#format_payload_code}
  */
  readonly formatPayloadCode?: string;
  /**
  * Unique ID for this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#id PackDestination#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id: string;
  /**
  * Disable to close the connection immediately after sending the outgoing request. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#keep_alive PackDestination#keep_alive}
  */
  readonly keepAlive?: boolean | cdktf.IResolvable;
  /**
  * How far back in time to keep traffic stats for load balancing purposes. Default: 300
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#load_balance_stats_period_sec PackDestination#load_balance_stats_period_sec}
  */
  readonly loadBalanceStatsPeriodSec?: number;
  /**
  * Enable for optimal performance. Even if you have one hostname, it can expand to multiple IPs. If disabled, consider enabling round-robin DNS. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#load_balanced PackDestination#load_balanced}
  */
  readonly loadBalanced?: boolean | cdktf.IResolvable;
  /**
  * URL for OAuth
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#login_url PackDestination#login_url}
  */
  readonly loginUrl?: string;
  /**
  * Maximum number of events to include in the request body. Default is 0 (unlimited). Default: 0
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_payload_events PackDestination#max_payload_events}
  */
  readonly maxPayloadEvents?: number;
  /**
  * Maximum size, in KB, of the request body. Default: 4096
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_payload_size_kb PackDestination#max_payload_size_kb}
  */
  readonly maxPayloadSizeKb?: number;
  /**
  * The method to use when sending events. Default: "POST"; must be one of ["POST", "PUT", "PATCH"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#method PackDestination#method}
  */
  readonly method?: string;
  /**
  * Additional headers to send in the OAuth login request. @{product} will automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#oauth_headers PackDestination#oauth_headers}
  */
  readonly oauthHeaders?: PackDestinationOutputWebhookOauthHeaders[] | cdktf.IResolvable;
  /**
  * Additional parameters to send in the OAuth login request. @{product} will combine the secret with these parameters, and will send the URL-encoded result in a POST request to the endpoint specified in the 'Login URL'. We'll automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#oauth_params PackDestination#oauth_params}
  */
  readonly oauthParams?: PackDestinationOutputWebhookOauthParams[] | cdktf.IResolvable;
  /**
  * How to handle events when all receivers are exerting backpressure. Default: "block"; must be one of ["block", "drop", "queue"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#on_backpressure PackDestination#on_backpressure}
  */
  readonly onBackpressure?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#password PackDestination#password}
  */
  readonly password?: string;
  /**
  * Pipeline to process data before sending out to this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pipeline PackDestination#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_compress PackDestination#pq_compress}
  */
  readonly pqCompress?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_controls PackDestination#pq_controls}
  */
  readonly pqControls?: PackDestinationOutputWebhookPqControls;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.). Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_max_file_size PackDestination#pq_max_file_size}
  */
  readonly pqMaxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_max_size PackDestination#pq_max_size}
  */
  readonly pqMaxSize?: string;
  /**
  * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem. Default: "error"; must be one of ["error", "backpressure", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_mode PackDestination#pq_mode}
  */
  readonly pqMode?: string;
  /**
  * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged. Default: "block"; must be one of ["block", "drop"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_on_backpressure PackDestination#pq_on_backpressure}
  */
  readonly pqOnBackpressure?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_path PackDestination#pq_path}
  */
  readonly pqPath?: string;
  /**
  * Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's). 
  *         Enabled by default. When this setting is also present in TLS Settings (Client Side), 
  *         that value will take precedence.
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#reject_unauthorized PackDestination#reject_unauthorized}
  */
  readonly rejectUnauthorized?: boolean | cdktf.IResolvable;
  /**
  * Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#response_honor_retry_after_header PackDestination#response_honor_retry_after_header}
  */
  readonly responseHonorRetryAfterHeader?: boolean | cdktf.IResolvable;
  /**
  * Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#response_retry_settings PackDestination#response_retry_settings}
  */
  readonly responseRetrySettings?: PackDestinationOutputWebhookResponseRetrySettings[] | cdktf.IResolvable;
  /**
  * List of headers that are safe to log in plain text. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#safe_headers PackDestination#safe_headers}
  */
  readonly safeHeaders?: string[];
  /**
  * Secret parameter value to pass in request body
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#secret PackDestination#secret}
  */
  readonly secret?: string;
  /**
  * Secret parameter name to pass in request body
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#secret_param_name PackDestination#secret_param_name}
  */
  readonly secretParamName?: string;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#streamtags PackDestination#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Fields to automatically add to events, such as cribl_pipe. Supports wildcards. Default: ["cribl_pipe"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#system_fields PackDestination#system_fields}
  */
  readonly systemFields?: string[];
  /**
  * Select or create a stored text secret
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#text_secret PackDestination#text_secret}
  */
  readonly textSecret?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#timeout_retry_settings PackDestination#timeout_retry_settings}
  */
  readonly timeoutRetrySettings?: PackDestinationOutputWebhookTimeoutRetrySettings;
  /**
  * Amount of time, in seconds, to wait for a request to complete before canceling it. Default: 30
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#timeout_sec PackDestination#timeout_sec}
  */
  readonly timeoutSec?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#tls PackDestination#tls}
  */
  readonly tls?: PackDestinationOutputWebhookTls;
  /**
  * Bearer token to include in the authorization header
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#token PackDestination#token}
  */
  readonly token?: string;
  /**
  * Name of the auth token attribute in the OAuth response. Can be top-level (e.g., 'token'); or nested, using a period (e.g., 'data.token').
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#token_attribute_name PackDestination#token_attribute_name}
  */
  readonly tokenAttributeName?: string;
  /**
  * How often the OAuth token should be refreshed. Default: 3600
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#token_timeout_secs PackDestination#token_timeout_secs}
  */
  readonly tokenTimeoutSecs?: number;
  /**
  * Maximum total size of the batches waiting to be sent. If left blank, defaults to 5 times the max body size (if set). If 0, no limit is enforced.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#total_memory_limit_kb PackDestination#total_memory_limit_kb}
  */
  readonly totalMemoryLimitKb?: number;
  /**
  * must be "webhook"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#type PackDestination#type}
  */
  readonly type: string;
  /**
  * URL of a webhook endpoint to send events to, such as http://localhost:10200
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#url PackDestination#url}
  */
  readonly url?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#urls PackDestination#urls}
  */
  readonly urls?: PackDestinationOutputWebhookUrls[] | cdktf.IResolvable;
  /**
  * Enable round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. For optimal performance, consider enabling this setting for non-load balanced destinations. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#use_round_robin_dns PackDestination#use_round_robin_dns}
  */
  readonly useRoundRobinDns?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#username PackDestination#username}
  */
  readonly username?: string;
}

export function packDestinationOutputWebhookToTerraform(struct?: PackDestinationOutputWebhook | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    advanced_content_type: cdktf.stringToTerraform(struct!.advancedContentType),
    auth_header_expr: cdktf.stringToTerraform(struct!.authHeaderExpr),
    auth_type: cdktf.stringToTerraform(struct!.authType),
    compress: cdktf.booleanToTerraform(struct!.compress),
    concurrency: cdktf.numberToTerraform(struct!.concurrency),
    credentials_secret: cdktf.stringToTerraform(struct!.credentialsSecret),
    custom_content_type: cdktf.stringToTerraform(struct!.customContentType),
    custom_drop_when_null: cdktf.booleanToTerraform(struct!.customDropWhenNull),
    custom_event_delimiter: cdktf.stringToTerraform(struct!.customEventDelimiter),
    custom_payload_expression: cdktf.stringToTerraform(struct!.customPayloadExpression),
    custom_source_expression: cdktf.stringToTerraform(struct!.customSourceExpression),
    description: cdktf.stringToTerraform(struct!.description),
    dns_resolve_period_sec: cdktf.numberToTerraform(struct!.dnsResolvePeriodSec),
    environment: cdktf.stringToTerraform(struct!.environment),
    exclude_self: cdktf.booleanToTerraform(struct!.excludeSelf),
    extra_http_headers: cdktf.listMapper(packDestinationOutputWebhookExtraHttpHeadersToTerraform, false)(struct!.extraHttpHeaders),
    failed_request_logging_mode: cdktf.stringToTerraform(struct!.failedRequestLoggingMode),
    flush_period_sec: cdktf.numberToTerraform(struct!.flushPeriodSec),
    format: cdktf.stringToTerraform(struct!.format),
    format_event_code: cdktf.stringToTerraform(struct!.formatEventCode),
    format_payload_code: cdktf.stringToTerraform(struct!.formatPayloadCode),
    id: cdktf.stringToTerraform(struct!.id),
    keep_alive: cdktf.booleanToTerraform(struct!.keepAlive),
    load_balance_stats_period_sec: cdktf.numberToTerraform(struct!.loadBalanceStatsPeriodSec),
    load_balanced: cdktf.booleanToTerraform(struct!.loadBalanced),
    login_url: cdktf.stringToTerraform(struct!.loginUrl),
    max_payload_events: cdktf.numberToTerraform(struct!.maxPayloadEvents),
    max_payload_size_kb: cdktf.numberToTerraform(struct!.maxPayloadSizeKb),
    method: cdktf.stringToTerraform(struct!.method),
    oauth_headers: cdktf.listMapper(packDestinationOutputWebhookOauthHeadersToTerraform, false)(struct!.oauthHeaders),
    oauth_params: cdktf.listMapper(packDestinationOutputWebhookOauthParamsToTerraform, false)(struct!.oauthParams),
    on_backpressure: cdktf.stringToTerraform(struct!.onBackpressure),
    password: cdktf.stringToTerraform(struct!.password),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    pq_compress: cdktf.stringToTerraform(struct!.pqCompress),
    pq_controls: packDestinationOutputWebhookPqControlsToTerraform(struct!.pqControls),
    pq_max_file_size: cdktf.stringToTerraform(struct!.pqMaxFileSize),
    pq_max_size: cdktf.stringToTerraform(struct!.pqMaxSize),
    pq_mode: cdktf.stringToTerraform(struct!.pqMode),
    pq_on_backpressure: cdktf.stringToTerraform(struct!.pqOnBackpressure),
    pq_path: cdktf.stringToTerraform(struct!.pqPath),
    reject_unauthorized: cdktf.booleanToTerraform(struct!.rejectUnauthorized),
    response_honor_retry_after_header: cdktf.booleanToTerraform(struct!.responseHonorRetryAfterHeader),
    response_retry_settings: cdktf.listMapper(packDestinationOutputWebhookResponseRetrySettingsToTerraform, false)(struct!.responseRetrySettings),
    safe_headers: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.safeHeaders),
    secret: cdktf.stringToTerraform(struct!.secret),
    secret_param_name: cdktf.stringToTerraform(struct!.secretParamName),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    system_fields: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.systemFields),
    text_secret: cdktf.stringToTerraform(struct!.textSecret),
    timeout_retry_settings: packDestinationOutputWebhookTimeoutRetrySettingsToTerraform(struct!.timeoutRetrySettings),
    timeout_sec: cdktf.numberToTerraform(struct!.timeoutSec),
    tls: packDestinationOutputWebhookTlsToTerraform(struct!.tls),
    token: cdktf.stringToTerraform(struct!.token),
    token_attribute_name: cdktf.stringToTerraform(struct!.tokenAttributeName),
    token_timeout_secs: cdktf.numberToTerraform(struct!.tokenTimeoutSecs),
    total_memory_limit_kb: cdktf.numberToTerraform(struct!.totalMemoryLimitKb),
    type: cdktf.stringToTerraform(struct!.type),
    url: cdktf.stringToTerraform(struct!.url),
    urls: cdktf.listMapper(packDestinationOutputWebhookUrlsToTerraform, false)(struct!.urls),
    use_round_robin_dns: cdktf.booleanToTerraform(struct!.useRoundRobinDns),
    username: cdktf.stringToTerraform(struct!.username),
  }
}


export function packDestinationOutputWebhookToHclTerraform(struct?: PackDestinationOutputWebhook | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    advanced_content_type: {
      value: cdktf.stringToHclTerraform(struct!.advancedContentType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    auth_header_expr: {
      value: cdktf.stringToHclTerraform(struct!.authHeaderExpr),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    auth_type: {
      value: cdktf.stringToHclTerraform(struct!.authType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    compress: {
      value: cdktf.booleanToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    concurrency: {
      value: cdktf.numberToHclTerraform(struct!.concurrency),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    credentials_secret: {
      value: cdktf.stringToHclTerraform(struct!.credentialsSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    custom_content_type: {
      value: cdktf.stringToHclTerraform(struct!.customContentType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    custom_drop_when_null: {
      value: cdktf.booleanToHclTerraform(struct!.customDropWhenNull),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    custom_event_delimiter: {
      value: cdktf.stringToHclTerraform(struct!.customEventDelimiter),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    custom_payload_expression: {
      value: cdktf.stringToHclTerraform(struct!.customPayloadExpression),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    custom_source_expression: {
      value: cdktf.stringToHclTerraform(struct!.customSourceExpression),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    dns_resolve_period_sec: {
      value: cdktf.numberToHclTerraform(struct!.dnsResolvePeriodSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    exclude_self: {
      value: cdktf.booleanToHclTerraform(struct!.excludeSelf),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    extra_http_headers: {
      value: cdktf.listMapperHcl(packDestinationOutputWebhookExtraHttpHeadersToHclTerraform, false)(struct!.extraHttpHeaders),
      isBlock: true,
      type: "list",
      storageClassType: "PackDestinationOutputWebhookExtraHttpHeadersList",
    },
    failed_request_logging_mode: {
      value: cdktf.stringToHclTerraform(struct!.failedRequestLoggingMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    flush_period_sec: {
      value: cdktf.numberToHclTerraform(struct!.flushPeriodSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    format: {
      value: cdktf.stringToHclTerraform(struct!.format),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    format_event_code: {
      value: cdktf.stringToHclTerraform(struct!.formatEventCode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    format_payload_code: {
      value: cdktf.stringToHclTerraform(struct!.formatPayloadCode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    keep_alive: {
      value: cdktf.booleanToHclTerraform(struct!.keepAlive),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    load_balance_stats_period_sec: {
      value: cdktf.numberToHclTerraform(struct!.loadBalanceStatsPeriodSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    load_balanced: {
      value: cdktf.booleanToHclTerraform(struct!.loadBalanced),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    login_url: {
      value: cdktf.stringToHclTerraform(struct!.loginUrl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_payload_events: {
      value: cdktf.numberToHclTerraform(struct!.maxPayloadEvents),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_payload_size_kb: {
      value: cdktf.numberToHclTerraform(struct!.maxPayloadSizeKb),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    method: {
      value: cdktf.stringToHclTerraform(struct!.method),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    oauth_headers: {
      value: cdktf.listMapperHcl(packDestinationOutputWebhookOauthHeadersToHclTerraform, false)(struct!.oauthHeaders),
      isBlock: true,
      type: "list",
      storageClassType: "PackDestinationOutputWebhookOauthHeadersList",
    },
    oauth_params: {
      value: cdktf.listMapperHcl(packDestinationOutputWebhookOauthParamsToHclTerraform, false)(struct!.oauthParams),
      isBlock: true,
      type: "list",
      storageClassType: "PackDestinationOutputWebhookOauthParamsList",
    },
    on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.onBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    password: {
      value: cdktf.stringToHclTerraform(struct!.password),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_compress: {
      value: cdktf.stringToHclTerraform(struct!.pqCompress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_controls: {
      value: packDestinationOutputWebhookPqControlsToHclTerraform(struct!.pqControls),
      isBlock: true,
      type: "struct",
      storageClassType: "PackDestinationOutputWebhookPqControls",
    },
    pq_max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_max_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_mode: {
      value: cdktf.stringToHclTerraform(struct!.pqMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.pqOnBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_path: {
      value: cdktf.stringToHclTerraform(struct!.pqPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reject_unauthorized: {
      value: cdktf.booleanToHclTerraform(struct!.rejectUnauthorized),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    response_honor_retry_after_header: {
      value: cdktf.booleanToHclTerraform(struct!.responseHonorRetryAfterHeader),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    response_retry_settings: {
      value: cdktf.listMapperHcl(packDestinationOutputWebhookResponseRetrySettingsToHclTerraform, false)(struct!.responseRetrySettings),
      isBlock: true,
      type: "list",
      storageClassType: "PackDestinationOutputWebhookResponseRetrySettingsList",
    },
    safe_headers: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.safeHeaders),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    secret: {
      value: cdktf.stringToHclTerraform(struct!.secret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_param_name: {
      value: cdktf.stringToHclTerraform(struct!.secretParamName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    system_fields: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.systemFields),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    text_secret: {
      value: cdktf.stringToHclTerraform(struct!.textSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    timeout_retry_settings: {
      value: packDestinationOutputWebhookTimeoutRetrySettingsToHclTerraform(struct!.timeoutRetrySettings),
      isBlock: true,
      type: "struct",
      storageClassType: "PackDestinationOutputWebhookTimeoutRetrySettings",
    },
    timeout_sec: {
      value: cdktf.numberToHclTerraform(struct!.timeoutSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    tls: {
      value: packDestinationOutputWebhookTlsToHclTerraform(struct!.tls),
      isBlock: true,
      type: "struct",
      storageClassType: "PackDestinationOutputWebhookTls",
    },
    token: {
      value: cdktf.stringToHclTerraform(struct!.token),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    token_attribute_name: {
      value: cdktf.stringToHclTerraform(struct!.tokenAttributeName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    token_timeout_secs: {
      value: cdktf.numberToHclTerraform(struct!.tokenTimeoutSecs),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    total_memory_limit_kb: {
      value: cdktf.numberToHclTerraform(struct!.totalMemoryLimitKb),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    url: {
      value: cdktf.stringToHclTerraform(struct!.url),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    urls: {
      value: cdktf.listMapperHcl(packDestinationOutputWebhookUrlsToHclTerraform, false)(struct!.urls),
      isBlock: true,
      type: "list",
      storageClassType: "PackDestinationOutputWebhookUrlsList",
    },
    use_round_robin_dns: {
      value: cdktf.booleanToHclTerraform(struct!.useRoundRobinDns),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    username: {
      value: cdktf.stringToHclTerraform(struct!.username),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputWebhookOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackDestinationOutputWebhook | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._advancedContentType !== undefined) {
      hasAnyValues = true;
      internalValueResult.advancedContentType = this._advancedContentType;
    }
    if (this._authHeaderExpr !== undefined) {
      hasAnyValues = true;
      internalValueResult.authHeaderExpr = this._authHeaderExpr;
    }
    if (this._authType !== undefined) {
      hasAnyValues = true;
      internalValueResult.authType = this._authType;
    }
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._concurrency !== undefined) {
      hasAnyValues = true;
      internalValueResult.concurrency = this._concurrency;
    }
    if (this._credentialsSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.credentialsSecret = this._credentialsSecret;
    }
    if (this._customContentType !== undefined) {
      hasAnyValues = true;
      internalValueResult.customContentType = this._customContentType;
    }
    if (this._customDropWhenNull !== undefined) {
      hasAnyValues = true;
      internalValueResult.customDropWhenNull = this._customDropWhenNull;
    }
    if (this._customEventDelimiter !== undefined) {
      hasAnyValues = true;
      internalValueResult.customEventDelimiter = this._customEventDelimiter;
    }
    if (this._customPayloadExpression !== undefined) {
      hasAnyValues = true;
      internalValueResult.customPayloadExpression = this._customPayloadExpression;
    }
    if (this._customSourceExpression !== undefined) {
      hasAnyValues = true;
      internalValueResult.customSourceExpression = this._customSourceExpression;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._dnsResolvePeriodSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.dnsResolvePeriodSec = this._dnsResolvePeriodSec;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._excludeSelf !== undefined) {
      hasAnyValues = true;
      internalValueResult.excludeSelf = this._excludeSelf;
    }
    if (this._extraHttpHeaders?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.extraHttpHeaders = this._extraHttpHeaders?.internalValue;
    }
    if (this._failedRequestLoggingMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.failedRequestLoggingMode = this._failedRequestLoggingMode;
    }
    if (this._flushPeriodSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.flushPeriodSec = this._flushPeriodSec;
    }
    if (this._format !== undefined) {
      hasAnyValues = true;
      internalValueResult.format = this._format;
    }
    if (this._formatEventCode !== undefined) {
      hasAnyValues = true;
      internalValueResult.formatEventCode = this._formatEventCode;
    }
    if (this._formatPayloadCode !== undefined) {
      hasAnyValues = true;
      internalValueResult.formatPayloadCode = this._formatPayloadCode;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._keepAlive !== undefined) {
      hasAnyValues = true;
      internalValueResult.keepAlive = this._keepAlive;
    }
    if (this._loadBalanceStatsPeriodSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.loadBalanceStatsPeriodSec = this._loadBalanceStatsPeriodSec;
    }
    if (this._loadBalanced !== undefined) {
      hasAnyValues = true;
      internalValueResult.loadBalanced = this._loadBalanced;
    }
    if (this._loginUrl !== undefined) {
      hasAnyValues = true;
      internalValueResult.loginUrl = this._loginUrl;
    }
    if (this._maxPayloadEvents !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxPayloadEvents = this._maxPayloadEvents;
    }
    if (this._maxPayloadSizeKb !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxPayloadSizeKb = this._maxPayloadSizeKb;
    }
    if (this._method !== undefined) {
      hasAnyValues = true;
      internalValueResult.method = this._method;
    }
    if (this._oauthHeaders?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.oauthHeaders = this._oauthHeaders?.internalValue;
    }
    if (this._oauthParams?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.oauthParams = this._oauthParams?.internalValue;
    }
    if (this._onBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.onBackpressure = this._onBackpressure;
    }
    if (this._password !== undefined) {
      hasAnyValues = true;
      internalValueResult.password = this._password;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._pqCompress !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqCompress = this._pqCompress;
    }
    if (this._pqControls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqControls = this._pqControls?.internalValue;
    }
    if (this._pqMaxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxFileSize = this._pqMaxFileSize;
    }
    if (this._pqMaxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxSize = this._pqMaxSize;
    }
    if (this._pqMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMode = this._pqMode;
    }
    if (this._pqOnBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqOnBackpressure = this._pqOnBackpressure;
    }
    if (this._pqPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqPath = this._pqPath;
    }
    if (this._rejectUnauthorized !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectUnauthorized = this._rejectUnauthorized;
    }
    if (this._responseHonorRetryAfterHeader !== undefined) {
      hasAnyValues = true;
      internalValueResult.responseHonorRetryAfterHeader = this._responseHonorRetryAfterHeader;
    }
    if (this._responseRetrySettings?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.responseRetrySettings = this._responseRetrySettings?.internalValue;
    }
    if (this._safeHeaders !== undefined) {
      hasAnyValues = true;
      internalValueResult.safeHeaders = this._safeHeaders;
    }
    if (this._secret !== undefined) {
      hasAnyValues = true;
      internalValueResult.secret = this._secret;
    }
    if (this._secretParamName !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretParamName = this._secretParamName;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._systemFields !== undefined) {
      hasAnyValues = true;
      internalValueResult.systemFields = this._systemFields;
    }
    if (this._textSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.textSecret = this._textSecret;
    }
    if (this._timeoutRetrySettings?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutRetrySettings = this._timeoutRetrySettings?.internalValue;
    }
    if (this._timeoutSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutSec = this._timeoutSec;
    }
    if (this._tls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tls = this._tls?.internalValue;
    }
    if (this._token !== undefined) {
      hasAnyValues = true;
      internalValueResult.token = this._token;
    }
    if (this._tokenAttributeName !== undefined) {
      hasAnyValues = true;
      internalValueResult.tokenAttributeName = this._tokenAttributeName;
    }
    if (this._tokenTimeoutSecs !== undefined) {
      hasAnyValues = true;
      internalValueResult.tokenTimeoutSecs = this._tokenTimeoutSecs;
    }
    if (this._totalMemoryLimitKb !== undefined) {
      hasAnyValues = true;
      internalValueResult.totalMemoryLimitKb = this._totalMemoryLimitKb;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._url !== undefined) {
      hasAnyValues = true;
      internalValueResult.url = this._url;
    }
    if (this._urls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.urls = this._urls?.internalValue;
    }
    if (this._useRoundRobinDns !== undefined) {
      hasAnyValues = true;
      internalValueResult.useRoundRobinDns = this._useRoundRobinDns;
    }
    if (this._username !== undefined) {
      hasAnyValues = true;
      internalValueResult.username = this._username;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputWebhook | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._advancedContentType = undefined;
      this._authHeaderExpr = undefined;
      this._authType = undefined;
      this._compress = undefined;
      this._concurrency = undefined;
      this._credentialsSecret = undefined;
      this._customContentType = undefined;
      this._customDropWhenNull = undefined;
      this._customEventDelimiter = undefined;
      this._customPayloadExpression = undefined;
      this._customSourceExpression = undefined;
      this._description = undefined;
      this._dnsResolvePeriodSec = undefined;
      this._environment = undefined;
      this._excludeSelf = undefined;
      this._extraHttpHeaders.internalValue = undefined;
      this._failedRequestLoggingMode = undefined;
      this._flushPeriodSec = undefined;
      this._format = undefined;
      this._formatEventCode = undefined;
      this._formatPayloadCode = undefined;
      this._id = undefined;
      this._keepAlive = undefined;
      this._loadBalanceStatsPeriodSec = undefined;
      this._loadBalanced = undefined;
      this._loginUrl = undefined;
      this._maxPayloadEvents = undefined;
      this._maxPayloadSizeKb = undefined;
      this._method = undefined;
      this._oauthHeaders.internalValue = undefined;
      this._oauthParams.internalValue = undefined;
      this._onBackpressure = undefined;
      this._password = undefined;
      this._pipeline = undefined;
      this._pqCompress = undefined;
      this._pqControls.internalValue = undefined;
      this._pqMaxFileSize = undefined;
      this._pqMaxSize = undefined;
      this._pqMode = undefined;
      this._pqOnBackpressure = undefined;
      this._pqPath = undefined;
      this._rejectUnauthorized = undefined;
      this._responseHonorRetryAfterHeader = undefined;
      this._responseRetrySettings.internalValue = undefined;
      this._safeHeaders = undefined;
      this._secret = undefined;
      this._secretParamName = undefined;
      this._streamtags = undefined;
      this._systemFields = undefined;
      this._textSecret = undefined;
      this._timeoutRetrySettings.internalValue = undefined;
      this._timeoutSec = undefined;
      this._tls.internalValue = undefined;
      this._token = undefined;
      this._tokenAttributeName = undefined;
      this._tokenTimeoutSecs = undefined;
      this._totalMemoryLimitKb = undefined;
      this._type = undefined;
      this._url = undefined;
      this._urls.internalValue = undefined;
      this._useRoundRobinDns = undefined;
      this._username = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._advancedContentType = value.advancedContentType;
      this._authHeaderExpr = value.authHeaderExpr;
      this._authType = value.authType;
      this._compress = value.compress;
      this._concurrency = value.concurrency;
      this._credentialsSecret = value.credentialsSecret;
      this._customContentType = value.customContentType;
      this._customDropWhenNull = value.customDropWhenNull;
      this._customEventDelimiter = value.customEventDelimiter;
      this._customPayloadExpression = value.customPayloadExpression;
      this._customSourceExpression = value.customSourceExpression;
      this._description = value.description;
      this._dnsResolvePeriodSec = value.dnsResolvePeriodSec;
      this._environment = value.environment;
      this._excludeSelf = value.excludeSelf;
      this._extraHttpHeaders.internalValue = value.extraHttpHeaders;
      this._failedRequestLoggingMode = value.failedRequestLoggingMode;
      this._flushPeriodSec = value.flushPeriodSec;
      this._format = value.format;
      this._formatEventCode = value.formatEventCode;
      this._formatPayloadCode = value.formatPayloadCode;
      this._id = value.id;
      this._keepAlive = value.keepAlive;
      this._loadBalanceStatsPeriodSec = value.loadBalanceStatsPeriodSec;
      this._loadBalanced = value.loadBalanced;
      this._loginUrl = value.loginUrl;
      this._maxPayloadEvents = value.maxPayloadEvents;
      this._maxPayloadSizeKb = value.maxPayloadSizeKb;
      this._method = value.method;
      this._oauthHeaders.internalValue = value.oauthHeaders;
      this._oauthParams.internalValue = value.oauthParams;
      this._onBackpressure = value.onBackpressure;
      this._password = value.password;
      this._pipeline = value.pipeline;
      this._pqCompress = value.pqCompress;
      this._pqControls.internalValue = value.pqControls;
      this._pqMaxFileSize = value.pqMaxFileSize;
      this._pqMaxSize = value.pqMaxSize;
      this._pqMode = value.pqMode;
      this._pqOnBackpressure = value.pqOnBackpressure;
      this._pqPath = value.pqPath;
      this._rejectUnauthorized = value.rejectUnauthorized;
      this._responseHonorRetryAfterHeader = value.responseHonorRetryAfterHeader;
      this._responseRetrySettings.internalValue = value.responseRetrySettings;
      this._safeHeaders = value.safeHeaders;
      this._secret = value.secret;
      this._secretParamName = value.secretParamName;
      this._streamtags = value.streamtags;
      this._systemFields = value.systemFields;
      this._textSecret = value.textSecret;
      this._timeoutRetrySettings.internalValue = value.timeoutRetrySettings;
      this._timeoutSec = value.timeoutSec;
      this._tls.internalValue = value.tls;
      this._token = value.token;
      this._tokenAttributeName = value.tokenAttributeName;
      this._tokenTimeoutSecs = value.tokenTimeoutSecs;
      this._totalMemoryLimitKb = value.totalMemoryLimitKb;
      this._type = value.type;
      this._url = value.url;
      this._urls.internalValue = value.urls;
      this._useRoundRobinDns = value.useRoundRobinDns;
      this._username = value.username;
    }
  }

  // advanced_content_type - computed: true, optional: true, required: false
  private _advancedContentType?: string; 
  public get advancedContentType() {
    return this.getStringAttribute('advanced_content_type');
  }
  public set advancedContentType(value: string) {
    this._advancedContentType = value;
  }
  public resetAdvancedContentType() {
    this._advancedContentType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get advancedContentTypeInput() {
    return this._advancedContentType;
  }

  // auth_header_expr - computed: true, optional: true, required: false
  private _authHeaderExpr?: string; 
  public get authHeaderExpr() {
    return this.getStringAttribute('auth_header_expr');
  }
  public set authHeaderExpr(value: string) {
    this._authHeaderExpr = value;
  }
  public resetAuthHeaderExpr() {
    this._authHeaderExpr = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authHeaderExprInput() {
    return this._authHeaderExpr;
  }

  // auth_type - computed: true, optional: true, required: false
  private _authType?: string; 
  public get authType() {
    return this.getStringAttribute('auth_type');
  }
  public set authType(value: string) {
    this._authType = value;
  }
  public resetAuthType() {
    this._authType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authTypeInput() {
    return this._authType;
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: boolean | cdktf.IResolvable; 
  public get compress() {
    return this.getBooleanAttribute('compress');
  }
  public set compress(value: boolean | cdktf.IResolvable) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // concurrency - computed: true, optional: true, required: false
  private _concurrency?: number; 
  public get concurrency() {
    return this.getNumberAttribute('concurrency');
  }
  public set concurrency(value: number) {
    this._concurrency = value;
  }
  public resetConcurrency() {
    this._concurrency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get concurrencyInput() {
    return this._concurrency;
  }

  // credentials_secret - computed: false, optional: true, required: false
  private _credentialsSecret?: string; 
  public get credentialsSecret() {
    return this.getStringAttribute('credentials_secret');
  }
  public set credentialsSecret(value: string) {
    this._credentialsSecret = value;
  }
  public resetCredentialsSecret() {
    this._credentialsSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get credentialsSecretInput() {
    return this._credentialsSecret;
  }

  // custom_content_type - computed: true, optional: true, required: false
  private _customContentType?: string; 
  public get customContentType() {
    return this.getStringAttribute('custom_content_type');
  }
  public set customContentType(value: string) {
    this._customContentType = value;
  }
  public resetCustomContentType() {
    this._customContentType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get customContentTypeInput() {
    return this._customContentType;
  }

  // custom_drop_when_null - computed: true, optional: true, required: false
  private _customDropWhenNull?: boolean | cdktf.IResolvable; 
  public get customDropWhenNull() {
    return this.getBooleanAttribute('custom_drop_when_null');
  }
  public set customDropWhenNull(value: boolean | cdktf.IResolvable) {
    this._customDropWhenNull = value;
  }
  public resetCustomDropWhenNull() {
    this._customDropWhenNull = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get customDropWhenNullInput() {
    return this._customDropWhenNull;
  }

  // custom_event_delimiter - computed: true, optional: true, required: false
  private _customEventDelimiter?: string; 
  public get customEventDelimiter() {
    return this.getStringAttribute('custom_event_delimiter');
  }
  public set customEventDelimiter(value: string) {
    this._customEventDelimiter = value;
  }
  public resetCustomEventDelimiter() {
    this._customEventDelimiter = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get customEventDelimiterInput() {
    return this._customEventDelimiter;
  }

  // custom_payload_expression - computed: true, optional: true, required: false
  private _customPayloadExpression?: string; 
  public get customPayloadExpression() {
    return this.getStringAttribute('custom_payload_expression');
  }
  public set customPayloadExpression(value: string) {
    this._customPayloadExpression = value;
  }
  public resetCustomPayloadExpression() {
    this._customPayloadExpression = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get customPayloadExpressionInput() {
    return this._customPayloadExpression;
  }

  // custom_source_expression - computed: true, optional: true, required: false
  private _customSourceExpression?: string; 
  public get customSourceExpression() {
    return this.getStringAttribute('custom_source_expression');
  }
  public set customSourceExpression(value: string) {
    this._customSourceExpression = value;
  }
  public resetCustomSourceExpression() {
    this._customSourceExpression = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get customSourceExpressionInput() {
    return this._customSourceExpression;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // dns_resolve_period_sec - computed: true, optional: true, required: false
  private _dnsResolvePeriodSec?: number; 
  public get dnsResolvePeriodSec() {
    return this.getNumberAttribute('dns_resolve_period_sec');
  }
  public set dnsResolvePeriodSec(value: number) {
    this._dnsResolvePeriodSec = value;
  }
  public resetDnsResolvePeriodSec() {
    this._dnsResolvePeriodSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dnsResolvePeriodSecInput() {
    return this._dnsResolvePeriodSec;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // exclude_self - computed: true, optional: true, required: false
  private _excludeSelf?: boolean | cdktf.IResolvable; 
  public get excludeSelf() {
    return this.getBooleanAttribute('exclude_self');
  }
  public set excludeSelf(value: boolean | cdktf.IResolvable) {
    this._excludeSelf = value;
  }
  public resetExcludeSelf() {
    this._excludeSelf = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get excludeSelfInput() {
    return this._excludeSelf;
  }

  // extra_http_headers - computed: false, optional: true, required: false
  private _extraHttpHeaders = new PackDestinationOutputWebhookExtraHttpHeadersList(this, "extra_http_headers", false);
  public get extraHttpHeaders() {
    return this._extraHttpHeaders;
  }
  public putExtraHttpHeaders(value: PackDestinationOutputWebhookExtraHttpHeaders[] | cdktf.IResolvable) {
    this._extraHttpHeaders.internalValue = value;
  }
  public resetExtraHttpHeaders() {
    this._extraHttpHeaders.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get extraHttpHeadersInput() {
    return this._extraHttpHeaders.internalValue;
  }

  // failed_request_logging_mode - computed: true, optional: true, required: false
  private _failedRequestLoggingMode?: string; 
  public get failedRequestLoggingMode() {
    return this.getStringAttribute('failed_request_logging_mode');
  }
  public set failedRequestLoggingMode(value: string) {
    this._failedRequestLoggingMode = value;
  }
  public resetFailedRequestLoggingMode() {
    this._failedRequestLoggingMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get failedRequestLoggingModeInput() {
    return this._failedRequestLoggingMode;
  }

  // flush_period_sec - computed: true, optional: true, required: false
  private _flushPeriodSec?: number; 
  public get flushPeriodSec() {
    return this.getNumberAttribute('flush_period_sec');
  }
  public set flushPeriodSec(value: number) {
    this._flushPeriodSec = value;
  }
  public resetFlushPeriodSec() {
    this._flushPeriodSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get flushPeriodSecInput() {
    return this._flushPeriodSec;
  }

  // format - computed: true, optional: true, required: false
  private _format?: string; 
  public get format() {
    return this.getStringAttribute('format');
  }
  public set format(value: string) {
    this._format = value;
  }
  public resetFormat() {
    this._format = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get formatInput() {
    return this._format;
  }

  // format_event_code - computed: false, optional: true, required: false
  private _formatEventCode?: string; 
  public get formatEventCode() {
    return this.getStringAttribute('format_event_code');
  }
  public set formatEventCode(value: string) {
    this._formatEventCode = value;
  }
  public resetFormatEventCode() {
    this._formatEventCode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get formatEventCodeInput() {
    return this._formatEventCode;
  }

  // format_payload_code - computed: false, optional: true, required: false
  private _formatPayloadCode?: string; 
  public get formatPayloadCode() {
    return this.getStringAttribute('format_payload_code');
  }
  public set formatPayloadCode(value: string) {
    this._formatPayloadCode = value;
  }
  public resetFormatPayloadCode() {
    this._formatPayloadCode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get formatPayloadCodeInput() {
    return this._formatPayloadCode;
  }

  // id - computed: false, optional: false, required: true
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // keep_alive - computed: true, optional: true, required: false
  private _keepAlive?: boolean | cdktf.IResolvable; 
  public get keepAlive() {
    return this.getBooleanAttribute('keep_alive');
  }
  public set keepAlive(value: boolean | cdktf.IResolvable) {
    this._keepAlive = value;
  }
  public resetKeepAlive() {
    this._keepAlive = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keepAliveInput() {
    return this._keepAlive;
  }

  // load_balance_stats_period_sec - computed: true, optional: true, required: false
  private _loadBalanceStatsPeriodSec?: number; 
  public get loadBalanceStatsPeriodSec() {
    return this.getNumberAttribute('load_balance_stats_period_sec');
  }
  public set loadBalanceStatsPeriodSec(value: number) {
    this._loadBalanceStatsPeriodSec = value;
  }
  public resetLoadBalanceStatsPeriodSec() {
    this._loadBalanceStatsPeriodSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get loadBalanceStatsPeriodSecInput() {
    return this._loadBalanceStatsPeriodSec;
  }

  // load_balanced - computed: true, optional: true, required: false
  private _loadBalanced?: boolean | cdktf.IResolvable; 
  public get loadBalanced() {
    return this.getBooleanAttribute('load_balanced');
  }
  public set loadBalanced(value: boolean | cdktf.IResolvable) {
    this._loadBalanced = value;
  }
  public resetLoadBalanced() {
    this._loadBalanced = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get loadBalancedInput() {
    return this._loadBalanced;
  }

  // login_url - computed: false, optional: true, required: false
  private _loginUrl?: string; 
  public get loginUrl() {
    return this.getStringAttribute('login_url');
  }
  public set loginUrl(value: string) {
    this._loginUrl = value;
  }
  public resetLoginUrl() {
    this._loginUrl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get loginUrlInput() {
    return this._loginUrl;
  }

  // max_payload_events - computed: true, optional: true, required: false
  private _maxPayloadEvents?: number; 
  public get maxPayloadEvents() {
    return this.getNumberAttribute('max_payload_events');
  }
  public set maxPayloadEvents(value: number) {
    this._maxPayloadEvents = value;
  }
  public resetMaxPayloadEvents() {
    this._maxPayloadEvents = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxPayloadEventsInput() {
    return this._maxPayloadEvents;
  }

  // max_payload_size_kb - computed: true, optional: true, required: false
  private _maxPayloadSizeKb?: number; 
  public get maxPayloadSizeKb() {
    return this.getNumberAttribute('max_payload_size_kb');
  }
  public set maxPayloadSizeKb(value: number) {
    this._maxPayloadSizeKb = value;
  }
  public resetMaxPayloadSizeKb() {
    this._maxPayloadSizeKb = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxPayloadSizeKbInput() {
    return this._maxPayloadSizeKb;
  }

  // method - computed: true, optional: true, required: false
  private _method?: string; 
  public get method() {
    return this.getStringAttribute('method');
  }
  public set method(value: string) {
    this._method = value;
  }
  public resetMethod() {
    this._method = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get methodInput() {
    return this._method;
  }

  // oauth_headers - computed: false, optional: true, required: false
  private _oauthHeaders = new PackDestinationOutputWebhookOauthHeadersList(this, "oauth_headers", false);
  public get oauthHeaders() {
    return this._oauthHeaders;
  }
  public putOauthHeaders(value: PackDestinationOutputWebhookOauthHeaders[] | cdktf.IResolvable) {
    this._oauthHeaders.internalValue = value;
  }
  public resetOauthHeaders() {
    this._oauthHeaders.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get oauthHeadersInput() {
    return this._oauthHeaders.internalValue;
  }

  // oauth_params - computed: false, optional: true, required: false
  private _oauthParams = new PackDestinationOutputWebhookOauthParamsList(this, "oauth_params", false);
  public get oauthParams() {
    return this._oauthParams;
  }
  public putOauthParams(value: PackDestinationOutputWebhookOauthParams[] | cdktf.IResolvable) {
    this._oauthParams.internalValue = value;
  }
  public resetOauthParams() {
    this._oauthParams.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get oauthParamsInput() {
    return this._oauthParams.internalValue;
  }

  // on_backpressure - computed: true, optional: true, required: false
  private _onBackpressure?: string; 
  public get onBackpressure() {
    return this.getStringAttribute('on_backpressure');
  }
  public set onBackpressure(value: string) {
    this._onBackpressure = value;
  }
  public resetOnBackpressure() {
    this._onBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get onBackpressureInput() {
    return this._onBackpressure;
  }

  // password - computed: false, optional: true, required: false
  private _password?: string; 
  public get password() {
    return this.getStringAttribute('password');
  }
  public set password(value: string) {
    this._password = value;
  }
  public resetPassword() {
    this._password = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passwordInput() {
    return this._password;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // pq_compress - computed: true, optional: true, required: false
  private _pqCompress?: string; 
  public get pqCompress() {
    return this.getStringAttribute('pq_compress');
  }
  public set pqCompress(value: string) {
    this._pqCompress = value;
  }
  public resetPqCompress() {
    this._pqCompress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqCompressInput() {
    return this._pqCompress;
  }

  // pq_controls - computed: false, optional: true, required: false
  private _pqControls = new PackDestinationOutputWebhookPqControlsOutputReference(this, "pq_controls");
  public get pqControls() {
    return this._pqControls;
  }
  public putPqControls(value: PackDestinationOutputWebhookPqControls) {
    this._pqControls.internalValue = value;
  }
  public resetPqControls() {
    this._pqControls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqControlsInput() {
    return this._pqControls.internalValue;
  }

  // pq_max_file_size - computed: true, optional: true, required: false
  private _pqMaxFileSize?: string; 
  public get pqMaxFileSize() {
    return this.getStringAttribute('pq_max_file_size');
  }
  public set pqMaxFileSize(value: string) {
    this._pqMaxFileSize = value;
  }
  public resetPqMaxFileSize() {
    this._pqMaxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxFileSizeInput() {
    return this._pqMaxFileSize;
  }

  // pq_max_size - computed: true, optional: true, required: false
  private _pqMaxSize?: string; 
  public get pqMaxSize() {
    return this.getStringAttribute('pq_max_size');
  }
  public set pqMaxSize(value: string) {
    this._pqMaxSize = value;
  }
  public resetPqMaxSize() {
    this._pqMaxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxSizeInput() {
    return this._pqMaxSize;
  }

  // pq_mode - computed: true, optional: true, required: false
  private _pqMode?: string; 
  public get pqMode() {
    return this.getStringAttribute('pq_mode');
  }
  public set pqMode(value: string) {
    this._pqMode = value;
  }
  public resetPqMode() {
    this._pqMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqModeInput() {
    return this._pqMode;
  }

  // pq_on_backpressure - computed: true, optional: true, required: false
  private _pqOnBackpressure?: string; 
  public get pqOnBackpressure() {
    return this.getStringAttribute('pq_on_backpressure');
  }
  public set pqOnBackpressure(value: string) {
    this._pqOnBackpressure = value;
  }
  public resetPqOnBackpressure() {
    this._pqOnBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqOnBackpressureInput() {
    return this._pqOnBackpressure;
  }

  // pq_path - computed: true, optional: true, required: false
  private _pqPath?: string; 
  public get pqPath() {
    return this.getStringAttribute('pq_path');
  }
  public set pqPath(value: string) {
    this._pqPath = value;
  }
  public resetPqPath() {
    this._pqPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqPathInput() {
    return this._pqPath;
  }

  // reject_unauthorized - computed: true, optional: true, required: false
  private _rejectUnauthorized?: boolean | cdktf.IResolvable; 
  public get rejectUnauthorized() {
    return this.getBooleanAttribute('reject_unauthorized');
  }
  public set rejectUnauthorized(value: boolean | cdktf.IResolvable) {
    this._rejectUnauthorized = value;
  }
  public resetRejectUnauthorized() {
    this._rejectUnauthorized = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectUnauthorizedInput() {
    return this._rejectUnauthorized;
  }

  // response_honor_retry_after_header - computed: true, optional: true, required: false
  private _responseHonorRetryAfterHeader?: boolean | cdktf.IResolvable; 
  public get responseHonorRetryAfterHeader() {
    return this.getBooleanAttribute('response_honor_retry_after_header');
  }
  public set responseHonorRetryAfterHeader(value: boolean | cdktf.IResolvable) {
    this._responseHonorRetryAfterHeader = value;
  }
  public resetResponseHonorRetryAfterHeader() {
    this._responseHonorRetryAfterHeader = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get responseHonorRetryAfterHeaderInput() {
    return this._responseHonorRetryAfterHeader;
  }

  // response_retry_settings - computed: false, optional: true, required: false
  private _responseRetrySettings = new PackDestinationOutputWebhookResponseRetrySettingsList(this, "response_retry_settings", false);
  public get responseRetrySettings() {
    return this._responseRetrySettings;
  }
  public putResponseRetrySettings(value: PackDestinationOutputWebhookResponseRetrySettings[] | cdktf.IResolvable) {
    this._responseRetrySettings.internalValue = value;
  }
  public resetResponseRetrySettings() {
    this._responseRetrySettings.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get responseRetrySettingsInput() {
    return this._responseRetrySettings.internalValue;
  }

  // safe_headers - computed: true, optional: true, required: false
  private _safeHeaders?: string[]; 
  public get safeHeaders() {
    return this.getListAttribute('safe_headers');
  }
  public set safeHeaders(value: string[]) {
    this._safeHeaders = value;
  }
  public resetSafeHeaders() {
    this._safeHeaders = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get safeHeadersInput() {
    return this._safeHeaders;
  }

  // secret - computed: false, optional: true, required: false
  private _secret?: string; 
  public get secret() {
    return this.getStringAttribute('secret');
  }
  public set secret(value: string) {
    this._secret = value;
  }
  public resetSecret() {
    this._secret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretInput() {
    return this._secret;
  }

  // secret_param_name - computed: false, optional: true, required: false
  private _secretParamName?: string; 
  public get secretParamName() {
    return this.getStringAttribute('secret_param_name');
  }
  public set secretParamName(value: string) {
    this._secretParamName = value;
  }
  public resetSecretParamName() {
    this._secretParamName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretParamNameInput() {
    return this._secretParamName;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // system_fields - computed: true, optional: true, required: false
  private _systemFields?: string[]; 
  public get systemFields() {
    return this.getListAttribute('system_fields');
  }
  public set systemFields(value: string[]) {
    this._systemFields = value;
  }
  public resetSystemFields() {
    this._systemFields = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get systemFieldsInput() {
    return this._systemFields;
  }

  // text_secret - computed: false, optional: true, required: false
  private _textSecret?: string; 
  public get textSecret() {
    return this.getStringAttribute('text_secret');
  }
  public set textSecret(value: string) {
    this._textSecret = value;
  }
  public resetTextSecret() {
    this._textSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get textSecretInput() {
    return this._textSecret;
  }

  // timeout_retry_settings - computed: false, optional: true, required: false
  private _timeoutRetrySettings = new PackDestinationOutputWebhookTimeoutRetrySettingsOutputReference(this, "timeout_retry_settings");
  public get timeoutRetrySettings() {
    return this._timeoutRetrySettings;
  }
  public putTimeoutRetrySettings(value: PackDestinationOutputWebhookTimeoutRetrySettings) {
    this._timeoutRetrySettings.internalValue = value;
  }
  public resetTimeoutRetrySettings() {
    this._timeoutRetrySettings.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutRetrySettingsInput() {
    return this._timeoutRetrySettings.internalValue;
  }

  // timeout_sec - computed: true, optional: true, required: false
  private _timeoutSec?: number; 
  public get timeoutSec() {
    return this.getNumberAttribute('timeout_sec');
  }
  public set timeoutSec(value: number) {
    this._timeoutSec = value;
  }
  public resetTimeoutSec() {
    this._timeoutSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutSecInput() {
    return this._timeoutSec;
  }

  // tls - computed: false, optional: true, required: false
  private _tls = new PackDestinationOutputWebhookTlsOutputReference(this, "tls");
  public get tls() {
    return this._tls;
  }
  public putTls(value: PackDestinationOutputWebhookTls) {
    this._tls.internalValue = value;
  }
  public resetTls() {
    this._tls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsInput() {
    return this._tls.internalValue;
  }

  // token - computed: false, optional: true, required: false
  private _token?: string; 
  public get token() {
    return this.getStringAttribute('token');
  }
  public set token(value: string) {
    this._token = value;
  }
  public resetToken() {
    this._token = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tokenInput() {
    return this._token;
  }

  // token_attribute_name - computed: false, optional: true, required: false
  private _tokenAttributeName?: string; 
  public get tokenAttributeName() {
    return this.getStringAttribute('token_attribute_name');
  }
  public set tokenAttributeName(value: string) {
    this._tokenAttributeName = value;
  }
  public resetTokenAttributeName() {
    this._tokenAttributeName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tokenAttributeNameInput() {
    return this._tokenAttributeName;
  }

  // token_timeout_secs - computed: true, optional: true, required: false
  private _tokenTimeoutSecs?: number; 
  public get tokenTimeoutSecs() {
    return this.getNumberAttribute('token_timeout_secs');
  }
  public set tokenTimeoutSecs(value: number) {
    this._tokenTimeoutSecs = value;
  }
  public resetTokenTimeoutSecs() {
    this._tokenTimeoutSecs = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tokenTimeoutSecsInput() {
    return this._tokenTimeoutSecs;
  }

  // total_memory_limit_kb - computed: false, optional: true, required: false
  private _totalMemoryLimitKb?: number; 
  public get totalMemoryLimitKb() {
    return this.getNumberAttribute('total_memory_limit_kb');
  }
  public set totalMemoryLimitKb(value: number) {
    this._totalMemoryLimitKb = value;
  }
  public resetTotalMemoryLimitKb() {
    this._totalMemoryLimitKb = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get totalMemoryLimitKbInput() {
    return this._totalMemoryLimitKb;
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // url - computed: false, optional: true, required: false
  private _url?: string; 
  public get url() {
    return this.getStringAttribute('url');
  }
  public set url(value: string) {
    this._url = value;
  }
  public resetUrl() {
    this._url = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get urlInput() {
    return this._url;
  }

  // urls - computed: false, optional: true, required: false
  private _urls = new PackDestinationOutputWebhookUrlsList(this, "urls", false);
  public get urls() {
    return this._urls;
  }
  public putUrls(value: PackDestinationOutputWebhookUrls[] | cdktf.IResolvable) {
    this._urls.internalValue = value;
  }
  public resetUrls() {
    this._urls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get urlsInput() {
    return this._urls.internalValue;
  }

  // use_round_robin_dns - computed: true, optional: true, required: false
  private _useRoundRobinDns?: boolean | cdktf.IResolvable; 
  public get useRoundRobinDns() {
    return this.getBooleanAttribute('use_round_robin_dns');
  }
  public set useRoundRobinDns(value: boolean | cdktf.IResolvable) {
    this._useRoundRobinDns = value;
  }
  public resetUseRoundRobinDns() {
    this._useRoundRobinDns = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get useRoundRobinDnsInput() {
    return this._useRoundRobinDns;
  }

  // username - computed: false, optional: true, required: false
  private _username?: string; 
  public get username() {
    return this.getStringAttribute('username');
  }
  public set username(value: string) {
    this._username = value;
  }
  public resetUsername() {
    this._username = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usernameInput() {
    return this._username;
  }
}
export interface PackDestinationOutputXsiamExtraHttpHeaders {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#name PackDestination#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#value PackDestination#value}
  */
  readonly value: string;
}

export function packDestinationOutputXsiamExtraHttpHeadersToTerraform(struct?: PackDestinationOutputXsiamExtraHttpHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function packDestinationOutputXsiamExtraHttpHeadersToHclTerraform(struct?: PackDestinationOutputXsiamExtraHttpHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputXsiamExtraHttpHeadersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackDestinationOutputXsiamExtraHttpHeaders | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputXsiamExtraHttpHeaders | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class PackDestinationOutputXsiamExtraHttpHeadersList extends cdktf.ComplexList {
  public internalValue? : PackDestinationOutputXsiamExtraHttpHeaders[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackDestinationOutputXsiamExtraHttpHeadersOutputReference {
    return new PackDestinationOutputXsiamExtraHttpHeadersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackDestinationOutputXsiamPqControls {
}

export function packDestinationOutputXsiamPqControlsToTerraform(struct?: PackDestinationOutputXsiamPqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function packDestinationOutputXsiamPqControlsToHclTerraform(struct?: PackDestinationOutputXsiamPqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class PackDestinationOutputXsiamPqControlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackDestinationOutputXsiamPqControls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputXsiamPqControls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface PackDestinationOutputXsiamResponseRetrySettings {
  /**
  * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc. Default: 2
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#backoff_rate PackDestination#backoff_rate}
  */
  readonly backoffRate?: number;
  /**
  * The HTTP response status code that will trigger retries
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#http_status PackDestination#http_status}
  */
  readonly httpStatus: number;
  /**
  * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes). Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#initial_backoff PackDestination#initial_backoff}
  */
  readonly initialBackoff?: number;
  /**
  * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds). Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_backoff PackDestination#max_backoff}
  */
  readonly maxBackoff?: number;
}

export function packDestinationOutputXsiamResponseRetrySettingsToTerraform(struct?: PackDestinationOutputXsiamResponseRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    backoff_rate: cdktf.numberToTerraform(struct!.backoffRate),
    http_status: cdktf.numberToTerraform(struct!.httpStatus),
    initial_backoff: cdktf.numberToTerraform(struct!.initialBackoff),
    max_backoff: cdktf.numberToTerraform(struct!.maxBackoff),
  }
}


export function packDestinationOutputXsiamResponseRetrySettingsToHclTerraform(struct?: PackDestinationOutputXsiamResponseRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    backoff_rate: {
      value: cdktf.numberToHclTerraform(struct!.backoffRate),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    http_status: {
      value: cdktf.numberToHclTerraform(struct!.httpStatus),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    initial_backoff: {
      value: cdktf.numberToHclTerraform(struct!.initialBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_backoff: {
      value: cdktf.numberToHclTerraform(struct!.maxBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputXsiamResponseRetrySettingsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackDestinationOutputXsiamResponseRetrySettings | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._backoffRate !== undefined) {
      hasAnyValues = true;
      internalValueResult.backoffRate = this._backoffRate;
    }
    if (this._httpStatus !== undefined) {
      hasAnyValues = true;
      internalValueResult.httpStatus = this._httpStatus;
    }
    if (this._initialBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.initialBackoff = this._initialBackoff;
    }
    if (this._maxBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBackoff = this._maxBackoff;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputXsiamResponseRetrySettings | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._backoffRate = undefined;
      this._httpStatus = undefined;
      this._initialBackoff = undefined;
      this._maxBackoff = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._backoffRate = value.backoffRate;
      this._httpStatus = value.httpStatus;
      this._initialBackoff = value.initialBackoff;
      this._maxBackoff = value.maxBackoff;
    }
  }

  // backoff_rate - computed: true, optional: true, required: false
  private _backoffRate?: number; 
  public get backoffRate() {
    return this.getNumberAttribute('backoff_rate');
  }
  public set backoffRate(value: number) {
    this._backoffRate = value;
  }
  public resetBackoffRate() {
    this._backoffRate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get backoffRateInput() {
    return this._backoffRate;
  }

  // http_status - computed: false, optional: false, required: true
  private _httpStatus?: number; 
  public get httpStatus() {
    return this.getNumberAttribute('http_status');
  }
  public set httpStatus(value: number) {
    this._httpStatus = value;
  }
  // Temporarily expose input value. Use with caution.
  public get httpStatusInput() {
    return this._httpStatus;
  }

  // initial_backoff - computed: true, optional: true, required: false
  private _initialBackoff?: number; 
  public get initialBackoff() {
    return this.getNumberAttribute('initial_backoff');
  }
  public set initialBackoff(value: number) {
    this._initialBackoff = value;
  }
  public resetInitialBackoff() {
    this._initialBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get initialBackoffInput() {
    return this._initialBackoff;
  }

  // max_backoff - computed: true, optional: true, required: false
  private _maxBackoff?: number; 
  public get maxBackoff() {
    return this.getNumberAttribute('max_backoff');
  }
  public set maxBackoff(value: number) {
    this._maxBackoff = value;
  }
  public resetMaxBackoff() {
    this._maxBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBackoffInput() {
    return this._maxBackoff;
  }
}

export class PackDestinationOutputXsiamResponseRetrySettingsList extends cdktf.ComplexList {
  public internalValue? : PackDestinationOutputXsiamResponseRetrySettings[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackDestinationOutputXsiamResponseRetrySettingsOutputReference {
    return new PackDestinationOutputXsiamResponseRetrySettingsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackDestinationOutputXsiamTimeoutRetrySettings {
  /**
  * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc. Default: 2
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#backoff_rate PackDestination#backoff_rate}
  */
  readonly backoffRate?: number;
  /**
  * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes). Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#initial_backoff PackDestination#initial_backoff}
  */
  readonly initialBackoff?: number;
  /**
  * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds). Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_backoff PackDestination#max_backoff}
  */
  readonly maxBackoff?: number;
  /**
  * Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#timeout_retry PackDestination#timeout_retry}
  */
  readonly timeoutRetry?: boolean | cdktf.IResolvable;
}

export function packDestinationOutputXsiamTimeoutRetrySettingsToTerraform(struct?: PackDestinationOutputXsiamTimeoutRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    backoff_rate: cdktf.numberToTerraform(struct!.backoffRate),
    initial_backoff: cdktf.numberToTerraform(struct!.initialBackoff),
    max_backoff: cdktf.numberToTerraform(struct!.maxBackoff),
    timeout_retry: cdktf.booleanToTerraform(struct!.timeoutRetry),
  }
}


export function packDestinationOutputXsiamTimeoutRetrySettingsToHclTerraform(struct?: PackDestinationOutputXsiamTimeoutRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    backoff_rate: {
      value: cdktf.numberToHclTerraform(struct!.backoffRate),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    initial_backoff: {
      value: cdktf.numberToHclTerraform(struct!.initialBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_backoff: {
      value: cdktf.numberToHclTerraform(struct!.maxBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    timeout_retry: {
      value: cdktf.booleanToHclTerraform(struct!.timeoutRetry),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputXsiamTimeoutRetrySettingsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackDestinationOutputXsiamTimeoutRetrySettings | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._backoffRate !== undefined) {
      hasAnyValues = true;
      internalValueResult.backoffRate = this._backoffRate;
    }
    if (this._initialBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.initialBackoff = this._initialBackoff;
    }
    if (this._maxBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBackoff = this._maxBackoff;
    }
    if (this._timeoutRetry !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutRetry = this._timeoutRetry;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputXsiamTimeoutRetrySettings | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._backoffRate = undefined;
      this._initialBackoff = undefined;
      this._maxBackoff = undefined;
      this._timeoutRetry = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._backoffRate = value.backoffRate;
      this._initialBackoff = value.initialBackoff;
      this._maxBackoff = value.maxBackoff;
      this._timeoutRetry = value.timeoutRetry;
    }
  }

  // backoff_rate - computed: true, optional: true, required: false
  private _backoffRate?: number; 
  public get backoffRate() {
    return this.getNumberAttribute('backoff_rate');
  }
  public set backoffRate(value: number) {
    this._backoffRate = value;
  }
  public resetBackoffRate() {
    this._backoffRate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get backoffRateInput() {
    return this._backoffRate;
  }

  // initial_backoff - computed: true, optional: true, required: false
  private _initialBackoff?: number; 
  public get initialBackoff() {
    return this.getNumberAttribute('initial_backoff');
  }
  public set initialBackoff(value: number) {
    this._initialBackoff = value;
  }
  public resetInitialBackoff() {
    this._initialBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get initialBackoffInput() {
    return this._initialBackoff;
  }

  // max_backoff - computed: true, optional: true, required: false
  private _maxBackoff?: number; 
  public get maxBackoff() {
    return this.getNumberAttribute('max_backoff');
  }
  public set maxBackoff(value: number) {
    this._maxBackoff = value;
  }
  public resetMaxBackoff() {
    this._maxBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBackoffInput() {
    return this._maxBackoff;
  }

  // timeout_retry - computed: true, optional: true, required: false
  private _timeoutRetry?: boolean | cdktf.IResolvable; 
  public get timeoutRetry() {
    return this.getBooleanAttribute('timeout_retry');
  }
  public set timeoutRetry(value: boolean | cdktf.IResolvable) {
    this._timeoutRetry = value;
  }
  public resetTimeoutRetry() {
    this._timeoutRetry = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutRetryInput() {
    return this._timeoutRetry;
  }
}
export interface PackDestinationOutputXsiamUrls {
  /**
  * Parsed as JSON.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#url PackDestination#url}
  */
  readonly url: string;
  /**
  * Assign a weight (>0) to each endpoint to indicate its traffic-handling capability. Default: 1
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#weight PackDestination#weight}
  */
  readonly weight?: number;
}

export function packDestinationOutputXsiamUrlsToTerraform(struct?: PackDestinationOutputXsiamUrls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    url: cdktf.stringToTerraform(struct!.url),
    weight: cdktf.numberToTerraform(struct!.weight),
  }
}


export function packDestinationOutputXsiamUrlsToHclTerraform(struct?: PackDestinationOutputXsiamUrls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    url: {
      value: cdktf.stringToHclTerraform(struct!.url),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    weight: {
      value: cdktf.numberToHclTerraform(struct!.weight),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputXsiamUrlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackDestinationOutputXsiamUrls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._url !== undefined) {
      hasAnyValues = true;
      internalValueResult.url = this._url;
    }
    if (this._weight !== undefined) {
      hasAnyValues = true;
      internalValueResult.weight = this._weight;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputXsiamUrls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._url = undefined;
      this._weight = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._url = value.url;
      this._weight = value.weight;
    }
  }

  // url - computed: false, optional: false, required: true
  private _url?: string; 
  public get url() {
    return this.getStringAttribute('url');
  }
  public set url(value: string) {
    this._url = value;
  }
  // Temporarily expose input value. Use with caution.
  public get urlInput() {
    return this._url;
  }

  // weight - computed: true, optional: true, required: false
  private _weight?: number; 
  public get weight() {
    return this.getNumberAttribute('weight');
  }
  public set weight(value: number) {
    this._weight = value;
  }
  public resetWeight() {
    this._weight = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get weightInput() {
    return this._weight;
  }
}

export class PackDestinationOutputXsiamUrlsList extends cdktf.ComplexList {
  public internalValue? : PackDestinationOutputXsiamUrls[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackDestinationOutputXsiamUrlsOutputReference {
    return new PackDestinationOutputXsiamUrlsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackDestinationOutputXsiam {
  /**
  * Enter a token directly, or provide a secret referencing a token. Default: "token"; must be one of ["token", "secret"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#auth_type PackDestination#auth_type}
  */
  readonly authType?: string;
  /**
  * Maximum number of ongoing requests before blocking. Default: 5
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#concurrency PackDestination#concurrency}
  */
  readonly concurrency?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#description PackDestination#description}
  */
  readonly description?: string;
  /**
  * The interval in which to re-resolve any hostnames and pick up destinations from A records. Default: 600
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#dns_resolve_period_sec PackDestination#dns_resolve_period_sec}
  */
  readonly dnsResolvePeriodSec?: number;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#environment PackDestination#environment}
  */
  readonly environment?: string;
  /**
  * Exclude all IPs of the current host from the list of any resolved hostnames. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#exclude_self PackDestination#exclude_self}
  */
  readonly excludeSelf?: boolean | cdktf.IResolvable;
  /**
  * Headers to add to all events
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#extra_http_headers PackDestination#extra_http_headers}
  */
  readonly extraHttpHeaders?: PackDestinationOutputXsiamExtraHttpHeaders[] | cdktf.IResolvable;
  /**
  * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below. Default: "none"; must be one of ["payload", "payloadAndHeaders", "none"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#failed_request_logging_mode PackDestination#failed_request_logging_mode}
  */
  readonly failedRequestLoggingMode?: string;
  /**
  * Maximum time between requests. Small values could cause the payload size to be smaller than the configured Body size limit. Default: 1
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#flush_period_sec PackDestination#flush_period_sec}
  */
  readonly flushPeriodSec?: number;
  /**
  * Unique ID for this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#id PackDestination#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id: string;
  /**
  * How far back in time to keep traffic stats for load balancing purposes. Default: 300
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#load_balance_stats_period_sec PackDestination#load_balance_stats_period_sec}
  */
  readonly loadBalanceStatsPeriodSec?: number;
  /**
  * Enable for optimal performance. Even if you have one hostname, it can expand to multiple IPs. If disabled, consider enabling round-robin DNS. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#load_balanced PackDestination#load_balanced}
  */
  readonly loadBalanced?: boolean | cdktf.IResolvable;
  /**
  * Maximum number of events to include in the request body. Default is 0 (unlimited). Default: 0
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_payload_events PackDestination#max_payload_events}
  */
  readonly maxPayloadEvents?: number;
  /**
  * Maximum size, in KB, of the request body. Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_payload_size_kb PackDestination#max_payload_size_kb}
  */
  readonly maxPayloadSizeKb?: number;
  /**
  * How to handle events when all receivers are exerting backpressure. Default: "block"; must be one of ["block", "drop", "queue"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#on_backpressure PackDestination#on_backpressure}
  */
  readonly onBackpressure?: string;
  /**
  * Pipeline to process data before sending out to this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pipeline PackDestination#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_compress PackDestination#pq_compress}
  */
  readonly pqCompress?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_controls PackDestination#pq_controls}
  */
  readonly pqControls?: PackDestinationOutputXsiamPqControls;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.). Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_max_file_size PackDestination#pq_max_file_size}
  */
  readonly pqMaxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_max_size PackDestination#pq_max_size}
  */
  readonly pqMaxSize?: string;
  /**
  * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem. Default: "error"; must be one of ["error", "backpressure", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_mode PackDestination#pq_mode}
  */
  readonly pqMode?: string;
  /**
  * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged. Default: "block"; must be one of ["block", "drop"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_on_backpressure PackDestination#pq_on_backpressure}
  */
  readonly pqOnBackpressure?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_path PackDestination#pq_path}
  */
  readonly pqPath?: string;
  /**
  * Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's). 
  *         Enabled by default. When this setting is also present in TLS Settings (Client Side), 
  *         that value will take precedence.
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#reject_unauthorized PackDestination#reject_unauthorized}
  */
  readonly rejectUnauthorized?: boolean | cdktf.IResolvable;
  /**
  * Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#response_honor_retry_after_header PackDestination#response_honor_retry_after_header}
  */
  readonly responseHonorRetryAfterHeader?: boolean | cdktf.IResolvable;
  /**
  * Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#response_retry_settings PackDestination#response_retry_settings}
  */
  readonly responseRetrySettings?: PackDestinationOutputXsiamResponseRetrySettings[] | cdktf.IResolvable;
  /**
  * List of headers that are safe to log in plain text. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#safe_headers PackDestination#safe_headers}
  */
  readonly safeHeaders?: string[];
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#streamtags PackDestination#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Fields to automatically add to events, such as cribl_pipe. Supports wildcards. Default: ["cribl_pipe"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#system_fields PackDestination#system_fields}
  */
  readonly systemFields?: string[];
  /**
  * Select or create a stored text secret
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#text_secret PackDestination#text_secret}
  */
  readonly textSecret?: string;
  /**
  * Maximum number of requests to limit to per second. Default: 400
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#throttle_rate_req_per_sec PackDestination#throttle_rate_req_per_sec}
  */
  readonly throttleRateReqPerSec?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#timeout_retry_settings PackDestination#timeout_retry_settings}
  */
  readonly timeoutRetrySettings?: PackDestinationOutputXsiamTimeoutRetrySettings;
  /**
  * Amount of time, in seconds, to wait for a request to complete before canceling it. Default: 30
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#timeout_sec PackDestination#timeout_sec}
  */
  readonly timeoutSec?: number;
  /**
  * XSIAM authentication token
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#token PackDestination#token}
  */
  readonly token?: string;
  /**
  * Maximum total size of the batches waiting to be sent. If left blank, defaults to 5 times the max body size (if set). If 0, no limit is enforced.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#total_memory_limit_kb PackDestination#total_memory_limit_kb}
  */
  readonly totalMemoryLimitKb?: number;
  /**
  * must be "xsiam"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#type PackDestination#type}
  */
  readonly type: string;
  /**
  * XSIAM endpoint URL to send events to, such as https://api-{tenant external URL}/logs/v1/event. Default: "http://localhost:8088/logs/v1/event"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#url PackDestination#url}
  */
  readonly url?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#urls PackDestination#urls}
  */
  readonly urls?: PackDestinationOutputXsiamUrls[] | cdktf.IResolvable;
  /**
  * Enable round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. For optimal performance, consider enabling this setting for non-load balanced destinations. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#use_round_robin_dns PackDestination#use_round_robin_dns}
  */
  readonly useRoundRobinDns?: boolean | cdktf.IResolvable;
}

export function packDestinationOutputXsiamToTerraform(struct?: PackDestinationOutputXsiam | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    auth_type: cdktf.stringToTerraform(struct!.authType),
    concurrency: cdktf.numberToTerraform(struct!.concurrency),
    description: cdktf.stringToTerraform(struct!.description),
    dns_resolve_period_sec: cdktf.numberToTerraform(struct!.dnsResolvePeriodSec),
    environment: cdktf.stringToTerraform(struct!.environment),
    exclude_self: cdktf.booleanToTerraform(struct!.excludeSelf),
    extra_http_headers: cdktf.listMapper(packDestinationOutputXsiamExtraHttpHeadersToTerraform, false)(struct!.extraHttpHeaders),
    failed_request_logging_mode: cdktf.stringToTerraform(struct!.failedRequestLoggingMode),
    flush_period_sec: cdktf.numberToTerraform(struct!.flushPeriodSec),
    id: cdktf.stringToTerraform(struct!.id),
    load_balance_stats_period_sec: cdktf.numberToTerraform(struct!.loadBalanceStatsPeriodSec),
    load_balanced: cdktf.booleanToTerraform(struct!.loadBalanced),
    max_payload_events: cdktf.numberToTerraform(struct!.maxPayloadEvents),
    max_payload_size_kb: cdktf.numberToTerraform(struct!.maxPayloadSizeKb),
    on_backpressure: cdktf.stringToTerraform(struct!.onBackpressure),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    pq_compress: cdktf.stringToTerraform(struct!.pqCompress),
    pq_controls: packDestinationOutputXsiamPqControlsToTerraform(struct!.pqControls),
    pq_max_file_size: cdktf.stringToTerraform(struct!.pqMaxFileSize),
    pq_max_size: cdktf.stringToTerraform(struct!.pqMaxSize),
    pq_mode: cdktf.stringToTerraform(struct!.pqMode),
    pq_on_backpressure: cdktf.stringToTerraform(struct!.pqOnBackpressure),
    pq_path: cdktf.stringToTerraform(struct!.pqPath),
    reject_unauthorized: cdktf.booleanToTerraform(struct!.rejectUnauthorized),
    response_honor_retry_after_header: cdktf.booleanToTerraform(struct!.responseHonorRetryAfterHeader),
    response_retry_settings: cdktf.listMapper(packDestinationOutputXsiamResponseRetrySettingsToTerraform, false)(struct!.responseRetrySettings),
    safe_headers: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.safeHeaders),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    system_fields: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.systemFields),
    text_secret: cdktf.stringToTerraform(struct!.textSecret),
    throttle_rate_req_per_sec: cdktf.numberToTerraform(struct!.throttleRateReqPerSec),
    timeout_retry_settings: packDestinationOutputXsiamTimeoutRetrySettingsToTerraform(struct!.timeoutRetrySettings),
    timeout_sec: cdktf.numberToTerraform(struct!.timeoutSec),
    token: cdktf.stringToTerraform(struct!.token),
    total_memory_limit_kb: cdktf.numberToTerraform(struct!.totalMemoryLimitKb),
    type: cdktf.stringToTerraform(struct!.type),
    url: cdktf.stringToTerraform(struct!.url),
    urls: cdktf.listMapper(packDestinationOutputXsiamUrlsToTerraform, false)(struct!.urls),
    use_round_robin_dns: cdktf.booleanToTerraform(struct!.useRoundRobinDns),
  }
}


export function packDestinationOutputXsiamToHclTerraform(struct?: PackDestinationOutputXsiam | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    auth_type: {
      value: cdktf.stringToHclTerraform(struct!.authType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    concurrency: {
      value: cdktf.numberToHclTerraform(struct!.concurrency),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    dns_resolve_period_sec: {
      value: cdktf.numberToHclTerraform(struct!.dnsResolvePeriodSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    exclude_self: {
      value: cdktf.booleanToHclTerraform(struct!.excludeSelf),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    extra_http_headers: {
      value: cdktf.listMapperHcl(packDestinationOutputXsiamExtraHttpHeadersToHclTerraform, false)(struct!.extraHttpHeaders),
      isBlock: true,
      type: "list",
      storageClassType: "PackDestinationOutputXsiamExtraHttpHeadersList",
    },
    failed_request_logging_mode: {
      value: cdktf.stringToHclTerraform(struct!.failedRequestLoggingMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    flush_period_sec: {
      value: cdktf.numberToHclTerraform(struct!.flushPeriodSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    load_balance_stats_period_sec: {
      value: cdktf.numberToHclTerraform(struct!.loadBalanceStatsPeriodSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    load_balanced: {
      value: cdktf.booleanToHclTerraform(struct!.loadBalanced),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    max_payload_events: {
      value: cdktf.numberToHclTerraform(struct!.maxPayloadEvents),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_payload_size_kb: {
      value: cdktf.numberToHclTerraform(struct!.maxPayloadSizeKb),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.onBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_compress: {
      value: cdktf.stringToHclTerraform(struct!.pqCompress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_controls: {
      value: packDestinationOutputXsiamPqControlsToHclTerraform(struct!.pqControls),
      isBlock: true,
      type: "struct",
      storageClassType: "PackDestinationOutputXsiamPqControls",
    },
    pq_max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_max_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_mode: {
      value: cdktf.stringToHclTerraform(struct!.pqMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.pqOnBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_path: {
      value: cdktf.stringToHclTerraform(struct!.pqPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reject_unauthorized: {
      value: cdktf.booleanToHclTerraform(struct!.rejectUnauthorized),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    response_honor_retry_after_header: {
      value: cdktf.booleanToHclTerraform(struct!.responseHonorRetryAfterHeader),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    response_retry_settings: {
      value: cdktf.listMapperHcl(packDestinationOutputXsiamResponseRetrySettingsToHclTerraform, false)(struct!.responseRetrySettings),
      isBlock: true,
      type: "list",
      storageClassType: "PackDestinationOutputXsiamResponseRetrySettingsList",
    },
    safe_headers: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.safeHeaders),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    system_fields: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.systemFields),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    text_secret: {
      value: cdktf.stringToHclTerraform(struct!.textSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    throttle_rate_req_per_sec: {
      value: cdktf.numberToHclTerraform(struct!.throttleRateReqPerSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    timeout_retry_settings: {
      value: packDestinationOutputXsiamTimeoutRetrySettingsToHclTerraform(struct!.timeoutRetrySettings),
      isBlock: true,
      type: "struct",
      storageClassType: "PackDestinationOutputXsiamTimeoutRetrySettings",
    },
    timeout_sec: {
      value: cdktf.numberToHclTerraform(struct!.timeoutSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    token: {
      value: cdktf.stringToHclTerraform(struct!.token),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    total_memory_limit_kb: {
      value: cdktf.numberToHclTerraform(struct!.totalMemoryLimitKb),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    url: {
      value: cdktf.stringToHclTerraform(struct!.url),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    urls: {
      value: cdktf.listMapperHcl(packDestinationOutputXsiamUrlsToHclTerraform, false)(struct!.urls),
      isBlock: true,
      type: "list",
      storageClassType: "PackDestinationOutputXsiamUrlsList",
    },
    use_round_robin_dns: {
      value: cdktf.booleanToHclTerraform(struct!.useRoundRobinDns),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputXsiamOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackDestinationOutputXsiam | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._authType !== undefined) {
      hasAnyValues = true;
      internalValueResult.authType = this._authType;
    }
    if (this._concurrency !== undefined) {
      hasAnyValues = true;
      internalValueResult.concurrency = this._concurrency;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._dnsResolvePeriodSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.dnsResolvePeriodSec = this._dnsResolvePeriodSec;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._excludeSelf !== undefined) {
      hasAnyValues = true;
      internalValueResult.excludeSelf = this._excludeSelf;
    }
    if (this._extraHttpHeaders?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.extraHttpHeaders = this._extraHttpHeaders?.internalValue;
    }
    if (this._failedRequestLoggingMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.failedRequestLoggingMode = this._failedRequestLoggingMode;
    }
    if (this._flushPeriodSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.flushPeriodSec = this._flushPeriodSec;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._loadBalanceStatsPeriodSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.loadBalanceStatsPeriodSec = this._loadBalanceStatsPeriodSec;
    }
    if (this._loadBalanced !== undefined) {
      hasAnyValues = true;
      internalValueResult.loadBalanced = this._loadBalanced;
    }
    if (this._maxPayloadEvents !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxPayloadEvents = this._maxPayloadEvents;
    }
    if (this._maxPayloadSizeKb !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxPayloadSizeKb = this._maxPayloadSizeKb;
    }
    if (this._onBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.onBackpressure = this._onBackpressure;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._pqCompress !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqCompress = this._pqCompress;
    }
    if (this._pqControls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqControls = this._pqControls?.internalValue;
    }
    if (this._pqMaxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxFileSize = this._pqMaxFileSize;
    }
    if (this._pqMaxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxSize = this._pqMaxSize;
    }
    if (this._pqMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMode = this._pqMode;
    }
    if (this._pqOnBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqOnBackpressure = this._pqOnBackpressure;
    }
    if (this._pqPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqPath = this._pqPath;
    }
    if (this._rejectUnauthorized !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectUnauthorized = this._rejectUnauthorized;
    }
    if (this._responseHonorRetryAfterHeader !== undefined) {
      hasAnyValues = true;
      internalValueResult.responseHonorRetryAfterHeader = this._responseHonorRetryAfterHeader;
    }
    if (this._responseRetrySettings?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.responseRetrySettings = this._responseRetrySettings?.internalValue;
    }
    if (this._safeHeaders !== undefined) {
      hasAnyValues = true;
      internalValueResult.safeHeaders = this._safeHeaders;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._systemFields !== undefined) {
      hasAnyValues = true;
      internalValueResult.systemFields = this._systemFields;
    }
    if (this._textSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.textSecret = this._textSecret;
    }
    if (this._throttleRateReqPerSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.throttleRateReqPerSec = this._throttleRateReqPerSec;
    }
    if (this._timeoutRetrySettings?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutRetrySettings = this._timeoutRetrySettings?.internalValue;
    }
    if (this._timeoutSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutSec = this._timeoutSec;
    }
    if (this._token !== undefined) {
      hasAnyValues = true;
      internalValueResult.token = this._token;
    }
    if (this._totalMemoryLimitKb !== undefined) {
      hasAnyValues = true;
      internalValueResult.totalMemoryLimitKb = this._totalMemoryLimitKb;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._url !== undefined) {
      hasAnyValues = true;
      internalValueResult.url = this._url;
    }
    if (this._urls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.urls = this._urls?.internalValue;
    }
    if (this._useRoundRobinDns !== undefined) {
      hasAnyValues = true;
      internalValueResult.useRoundRobinDns = this._useRoundRobinDns;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputXsiam | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._authType = undefined;
      this._concurrency = undefined;
      this._description = undefined;
      this._dnsResolvePeriodSec = undefined;
      this._environment = undefined;
      this._excludeSelf = undefined;
      this._extraHttpHeaders.internalValue = undefined;
      this._failedRequestLoggingMode = undefined;
      this._flushPeriodSec = undefined;
      this._id = undefined;
      this._loadBalanceStatsPeriodSec = undefined;
      this._loadBalanced = undefined;
      this._maxPayloadEvents = undefined;
      this._maxPayloadSizeKb = undefined;
      this._onBackpressure = undefined;
      this._pipeline = undefined;
      this._pqCompress = undefined;
      this._pqControls.internalValue = undefined;
      this._pqMaxFileSize = undefined;
      this._pqMaxSize = undefined;
      this._pqMode = undefined;
      this._pqOnBackpressure = undefined;
      this._pqPath = undefined;
      this._rejectUnauthorized = undefined;
      this._responseHonorRetryAfterHeader = undefined;
      this._responseRetrySettings.internalValue = undefined;
      this._safeHeaders = undefined;
      this._streamtags = undefined;
      this._systemFields = undefined;
      this._textSecret = undefined;
      this._throttleRateReqPerSec = undefined;
      this._timeoutRetrySettings.internalValue = undefined;
      this._timeoutSec = undefined;
      this._token = undefined;
      this._totalMemoryLimitKb = undefined;
      this._type = undefined;
      this._url = undefined;
      this._urls.internalValue = undefined;
      this._useRoundRobinDns = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._authType = value.authType;
      this._concurrency = value.concurrency;
      this._description = value.description;
      this._dnsResolvePeriodSec = value.dnsResolvePeriodSec;
      this._environment = value.environment;
      this._excludeSelf = value.excludeSelf;
      this._extraHttpHeaders.internalValue = value.extraHttpHeaders;
      this._failedRequestLoggingMode = value.failedRequestLoggingMode;
      this._flushPeriodSec = value.flushPeriodSec;
      this._id = value.id;
      this._loadBalanceStatsPeriodSec = value.loadBalanceStatsPeriodSec;
      this._loadBalanced = value.loadBalanced;
      this._maxPayloadEvents = value.maxPayloadEvents;
      this._maxPayloadSizeKb = value.maxPayloadSizeKb;
      this._onBackpressure = value.onBackpressure;
      this._pipeline = value.pipeline;
      this._pqCompress = value.pqCompress;
      this._pqControls.internalValue = value.pqControls;
      this._pqMaxFileSize = value.pqMaxFileSize;
      this._pqMaxSize = value.pqMaxSize;
      this._pqMode = value.pqMode;
      this._pqOnBackpressure = value.pqOnBackpressure;
      this._pqPath = value.pqPath;
      this._rejectUnauthorized = value.rejectUnauthorized;
      this._responseHonorRetryAfterHeader = value.responseHonorRetryAfterHeader;
      this._responseRetrySettings.internalValue = value.responseRetrySettings;
      this._safeHeaders = value.safeHeaders;
      this._streamtags = value.streamtags;
      this._systemFields = value.systemFields;
      this._textSecret = value.textSecret;
      this._throttleRateReqPerSec = value.throttleRateReqPerSec;
      this._timeoutRetrySettings.internalValue = value.timeoutRetrySettings;
      this._timeoutSec = value.timeoutSec;
      this._token = value.token;
      this._totalMemoryLimitKb = value.totalMemoryLimitKb;
      this._type = value.type;
      this._url = value.url;
      this._urls.internalValue = value.urls;
      this._useRoundRobinDns = value.useRoundRobinDns;
    }
  }

  // auth_type - computed: true, optional: true, required: false
  private _authType?: string; 
  public get authType() {
    return this.getStringAttribute('auth_type');
  }
  public set authType(value: string) {
    this._authType = value;
  }
  public resetAuthType() {
    this._authType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authTypeInput() {
    return this._authType;
  }

  // concurrency - computed: true, optional: true, required: false
  private _concurrency?: number; 
  public get concurrency() {
    return this.getNumberAttribute('concurrency');
  }
  public set concurrency(value: number) {
    this._concurrency = value;
  }
  public resetConcurrency() {
    this._concurrency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get concurrencyInput() {
    return this._concurrency;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // dns_resolve_period_sec - computed: true, optional: true, required: false
  private _dnsResolvePeriodSec?: number; 
  public get dnsResolvePeriodSec() {
    return this.getNumberAttribute('dns_resolve_period_sec');
  }
  public set dnsResolvePeriodSec(value: number) {
    this._dnsResolvePeriodSec = value;
  }
  public resetDnsResolvePeriodSec() {
    this._dnsResolvePeriodSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dnsResolvePeriodSecInput() {
    return this._dnsResolvePeriodSec;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // exclude_self - computed: true, optional: true, required: false
  private _excludeSelf?: boolean | cdktf.IResolvable; 
  public get excludeSelf() {
    return this.getBooleanAttribute('exclude_self');
  }
  public set excludeSelf(value: boolean | cdktf.IResolvable) {
    this._excludeSelf = value;
  }
  public resetExcludeSelf() {
    this._excludeSelf = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get excludeSelfInput() {
    return this._excludeSelf;
  }

  // extra_http_headers - computed: false, optional: true, required: false
  private _extraHttpHeaders = new PackDestinationOutputXsiamExtraHttpHeadersList(this, "extra_http_headers", false);
  public get extraHttpHeaders() {
    return this._extraHttpHeaders;
  }
  public putExtraHttpHeaders(value: PackDestinationOutputXsiamExtraHttpHeaders[] | cdktf.IResolvable) {
    this._extraHttpHeaders.internalValue = value;
  }
  public resetExtraHttpHeaders() {
    this._extraHttpHeaders.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get extraHttpHeadersInput() {
    return this._extraHttpHeaders.internalValue;
  }

  // failed_request_logging_mode - computed: true, optional: true, required: false
  private _failedRequestLoggingMode?: string; 
  public get failedRequestLoggingMode() {
    return this.getStringAttribute('failed_request_logging_mode');
  }
  public set failedRequestLoggingMode(value: string) {
    this._failedRequestLoggingMode = value;
  }
  public resetFailedRequestLoggingMode() {
    this._failedRequestLoggingMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get failedRequestLoggingModeInput() {
    return this._failedRequestLoggingMode;
  }

  // flush_period_sec - computed: true, optional: true, required: false
  private _flushPeriodSec?: number; 
  public get flushPeriodSec() {
    return this.getNumberAttribute('flush_period_sec');
  }
  public set flushPeriodSec(value: number) {
    this._flushPeriodSec = value;
  }
  public resetFlushPeriodSec() {
    this._flushPeriodSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get flushPeriodSecInput() {
    return this._flushPeriodSec;
  }

  // id - computed: false, optional: false, required: true
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // load_balance_stats_period_sec - computed: true, optional: true, required: false
  private _loadBalanceStatsPeriodSec?: number; 
  public get loadBalanceStatsPeriodSec() {
    return this.getNumberAttribute('load_balance_stats_period_sec');
  }
  public set loadBalanceStatsPeriodSec(value: number) {
    this._loadBalanceStatsPeriodSec = value;
  }
  public resetLoadBalanceStatsPeriodSec() {
    this._loadBalanceStatsPeriodSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get loadBalanceStatsPeriodSecInput() {
    return this._loadBalanceStatsPeriodSec;
  }

  // load_balanced - computed: true, optional: true, required: false
  private _loadBalanced?: boolean | cdktf.IResolvable; 
  public get loadBalanced() {
    return this.getBooleanAttribute('load_balanced');
  }
  public set loadBalanced(value: boolean | cdktf.IResolvable) {
    this._loadBalanced = value;
  }
  public resetLoadBalanced() {
    this._loadBalanced = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get loadBalancedInput() {
    return this._loadBalanced;
  }

  // max_payload_events - computed: true, optional: true, required: false
  private _maxPayloadEvents?: number; 
  public get maxPayloadEvents() {
    return this.getNumberAttribute('max_payload_events');
  }
  public set maxPayloadEvents(value: number) {
    this._maxPayloadEvents = value;
  }
  public resetMaxPayloadEvents() {
    this._maxPayloadEvents = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxPayloadEventsInput() {
    return this._maxPayloadEvents;
  }

  // max_payload_size_kb - computed: true, optional: true, required: false
  private _maxPayloadSizeKb?: number; 
  public get maxPayloadSizeKb() {
    return this.getNumberAttribute('max_payload_size_kb');
  }
  public set maxPayloadSizeKb(value: number) {
    this._maxPayloadSizeKb = value;
  }
  public resetMaxPayloadSizeKb() {
    this._maxPayloadSizeKb = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxPayloadSizeKbInput() {
    return this._maxPayloadSizeKb;
  }

  // on_backpressure - computed: true, optional: true, required: false
  private _onBackpressure?: string; 
  public get onBackpressure() {
    return this.getStringAttribute('on_backpressure');
  }
  public set onBackpressure(value: string) {
    this._onBackpressure = value;
  }
  public resetOnBackpressure() {
    this._onBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get onBackpressureInput() {
    return this._onBackpressure;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // pq_compress - computed: true, optional: true, required: false
  private _pqCompress?: string; 
  public get pqCompress() {
    return this.getStringAttribute('pq_compress');
  }
  public set pqCompress(value: string) {
    this._pqCompress = value;
  }
  public resetPqCompress() {
    this._pqCompress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqCompressInput() {
    return this._pqCompress;
  }

  // pq_controls - computed: false, optional: true, required: false
  private _pqControls = new PackDestinationOutputXsiamPqControlsOutputReference(this, "pq_controls");
  public get pqControls() {
    return this._pqControls;
  }
  public putPqControls(value: PackDestinationOutputXsiamPqControls) {
    this._pqControls.internalValue = value;
  }
  public resetPqControls() {
    this._pqControls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqControlsInput() {
    return this._pqControls.internalValue;
  }

  // pq_max_file_size - computed: true, optional: true, required: false
  private _pqMaxFileSize?: string; 
  public get pqMaxFileSize() {
    return this.getStringAttribute('pq_max_file_size');
  }
  public set pqMaxFileSize(value: string) {
    this._pqMaxFileSize = value;
  }
  public resetPqMaxFileSize() {
    this._pqMaxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxFileSizeInput() {
    return this._pqMaxFileSize;
  }

  // pq_max_size - computed: true, optional: true, required: false
  private _pqMaxSize?: string; 
  public get pqMaxSize() {
    return this.getStringAttribute('pq_max_size');
  }
  public set pqMaxSize(value: string) {
    this._pqMaxSize = value;
  }
  public resetPqMaxSize() {
    this._pqMaxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxSizeInput() {
    return this._pqMaxSize;
  }

  // pq_mode - computed: true, optional: true, required: false
  private _pqMode?: string; 
  public get pqMode() {
    return this.getStringAttribute('pq_mode');
  }
  public set pqMode(value: string) {
    this._pqMode = value;
  }
  public resetPqMode() {
    this._pqMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqModeInput() {
    return this._pqMode;
  }

  // pq_on_backpressure - computed: true, optional: true, required: false
  private _pqOnBackpressure?: string; 
  public get pqOnBackpressure() {
    return this.getStringAttribute('pq_on_backpressure');
  }
  public set pqOnBackpressure(value: string) {
    this._pqOnBackpressure = value;
  }
  public resetPqOnBackpressure() {
    this._pqOnBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqOnBackpressureInput() {
    return this._pqOnBackpressure;
  }

  // pq_path - computed: true, optional: true, required: false
  private _pqPath?: string; 
  public get pqPath() {
    return this.getStringAttribute('pq_path');
  }
  public set pqPath(value: string) {
    this._pqPath = value;
  }
  public resetPqPath() {
    this._pqPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqPathInput() {
    return this._pqPath;
  }

  // reject_unauthorized - computed: true, optional: true, required: false
  private _rejectUnauthorized?: boolean | cdktf.IResolvable; 
  public get rejectUnauthorized() {
    return this.getBooleanAttribute('reject_unauthorized');
  }
  public set rejectUnauthorized(value: boolean | cdktf.IResolvable) {
    this._rejectUnauthorized = value;
  }
  public resetRejectUnauthorized() {
    this._rejectUnauthorized = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectUnauthorizedInput() {
    return this._rejectUnauthorized;
  }

  // response_honor_retry_after_header - computed: true, optional: true, required: false
  private _responseHonorRetryAfterHeader?: boolean | cdktf.IResolvable; 
  public get responseHonorRetryAfterHeader() {
    return this.getBooleanAttribute('response_honor_retry_after_header');
  }
  public set responseHonorRetryAfterHeader(value: boolean | cdktf.IResolvable) {
    this._responseHonorRetryAfterHeader = value;
  }
  public resetResponseHonorRetryAfterHeader() {
    this._responseHonorRetryAfterHeader = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get responseHonorRetryAfterHeaderInput() {
    return this._responseHonorRetryAfterHeader;
  }

  // response_retry_settings - computed: false, optional: true, required: false
  private _responseRetrySettings = new PackDestinationOutputXsiamResponseRetrySettingsList(this, "response_retry_settings", false);
  public get responseRetrySettings() {
    return this._responseRetrySettings;
  }
  public putResponseRetrySettings(value: PackDestinationOutputXsiamResponseRetrySettings[] | cdktf.IResolvable) {
    this._responseRetrySettings.internalValue = value;
  }
  public resetResponseRetrySettings() {
    this._responseRetrySettings.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get responseRetrySettingsInput() {
    return this._responseRetrySettings.internalValue;
  }

  // safe_headers - computed: true, optional: true, required: false
  private _safeHeaders?: string[]; 
  public get safeHeaders() {
    return this.getListAttribute('safe_headers');
  }
  public set safeHeaders(value: string[]) {
    this._safeHeaders = value;
  }
  public resetSafeHeaders() {
    this._safeHeaders = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get safeHeadersInput() {
    return this._safeHeaders;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // system_fields - computed: true, optional: true, required: false
  private _systemFields?: string[]; 
  public get systemFields() {
    return this.getListAttribute('system_fields');
  }
  public set systemFields(value: string[]) {
    this._systemFields = value;
  }
  public resetSystemFields() {
    this._systemFields = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get systemFieldsInput() {
    return this._systemFields;
  }

  // text_secret - computed: false, optional: true, required: false
  private _textSecret?: string; 
  public get textSecret() {
    return this.getStringAttribute('text_secret');
  }
  public set textSecret(value: string) {
    this._textSecret = value;
  }
  public resetTextSecret() {
    this._textSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get textSecretInput() {
    return this._textSecret;
  }

  // throttle_rate_req_per_sec - computed: true, optional: true, required: false
  private _throttleRateReqPerSec?: number; 
  public get throttleRateReqPerSec() {
    return this.getNumberAttribute('throttle_rate_req_per_sec');
  }
  public set throttleRateReqPerSec(value: number) {
    this._throttleRateReqPerSec = value;
  }
  public resetThrottleRateReqPerSec() {
    this._throttleRateReqPerSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get throttleRateReqPerSecInput() {
    return this._throttleRateReqPerSec;
  }

  // timeout_retry_settings - computed: false, optional: true, required: false
  private _timeoutRetrySettings = new PackDestinationOutputXsiamTimeoutRetrySettingsOutputReference(this, "timeout_retry_settings");
  public get timeoutRetrySettings() {
    return this._timeoutRetrySettings;
  }
  public putTimeoutRetrySettings(value: PackDestinationOutputXsiamTimeoutRetrySettings) {
    this._timeoutRetrySettings.internalValue = value;
  }
  public resetTimeoutRetrySettings() {
    this._timeoutRetrySettings.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutRetrySettingsInput() {
    return this._timeoutRetrySettings.internalValue;
  }

  // timeout_sec - computed: true, optional: true, required: false
  private _timeoutSec?: number; 
  public get timeoutSec() {
    return this.getNumberAttribute('timeout_sec');
  }
  public set timeoutSec(value: number) {
    this._timeoutSec = value;
  }
  public resetTimeoutSec() {
    this._timeoutSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutSecInput() {
    return this._timeoutSec;
  }

  // token - computed: false, optional: true, required: false
  private _token?: string; 
  public get token() {
    return this.getStringAttribute('token');
  }
  public set token(value: string) {
    this._token = value;
  }
  public resetToken() {
    this._token = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tokenInput() {
    return this._token;
  }

  // total_memory_limit_kb - computed: false, optional: true, required: false
  private _totalMemoryLimitKb?: number; 
  public get totalMemoryLimitKb() {
    return this.getNumberAttribute('total_memory_limit_kb');
  }
  public set totalMemoryLimitKb(value: number) {
    this._totalMemoryLimitKb = value;
  }
  public resetTotalMemoryLimitKb() {
    this._totalMemoryLimitKb = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get totalMemoryLimitKbInput() {
    return this._totalMemoryLimitKb;
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // url - computed: true, optional: true, required: false
  private _url?: string; 
  public get url() {
    return this.getStringAttribute('url');
  }
  public set url(value: string) {
    this._url = value;
  }
  public resetUrl() {
    this._url = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get urlInput() {
    return this._url;
  }

  // urls - computed: false, optional: true, required: false
  private _urls = new PackDestinationOutputXsiamUrlsList(this, "urls", false);
  public get urls() {
    return this._urls;
  }
  public putUrls(value: PackDestinationOutputXsiamUrls[] | cdktf.IResolvable) {
    this._urls.internalValue = value;
  }
  public resetUrls() {
    this._urls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get urlsInput() {
    return this._urls.internalValue;
  }

  // use_round_robin_dns - computed: true, optional: true, required: false
  private _useRoundRobinDns?: boolean | cdktf.IResolvable; 
  public get useRoundRobinDns() {
    return this.getBooleanAttribute('use_round_robin_dns');
  }
  public set useRoundRobinDns(value: boolean | cdktf.IResolvable) {
    this._useRoundRobinDns = value;
  }
  public resetUseRoundRobinDns() {
    this._useRoundRobinDns = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get useRoundRobinDnsInput() {
    return this._useRoundRobinDns;
  }
}
