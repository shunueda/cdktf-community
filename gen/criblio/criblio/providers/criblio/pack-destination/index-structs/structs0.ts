import * as cdktf from 'cdktf';
export interface PackDestinationOutputAzureBlobCertificate {
  /**
  * The certificate you registered as credentials for your app in the Azure portal
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#certificate_name PackDestination#certificate_name}
  */
  readonly certificateName: string;
}

export function packDestinationOutputAzureBlobCertificateToTerraform(struct?: PackDestinationOutputAzureBlobCertificate | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    certificate_name: cdktf.stringToTerraform(struct!.certificateName),
  }
}


export function packDestinationOutputAzureBlobCertificateToHclTerraform(struct?: PackDestinationOutputAzureBlobCertificate | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    certificate_name: {
      value: cdktf.stringToHclTerraform(struct!.certificateName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputAzureBlobCertificateOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackDestinationOutputAzureBlobCertificate | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._certificateName !== undefined) {
      hasAnyValues = true;
      internalValueResult.certificateName = this._certificateName;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputAzureBlobCertificate | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._certificateName = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._certificateName = value.certificateName;
    }
  }

  // certificate_name - computed: false, optional: false, required: true
  private _certificateName?: string; 
  public get certificateName() {
    return this.getStringAttribute('certificate_name');
  }
  public set certificateName(value: string) {
    this._certificateName = value;
  }
  // Temporarily expose input value. Use with caution.
  public get certificateNameInput() {
    return this._certificateName;
  }
}
export interface PackDestinationOutputAzureBlobKeyValueMetadata {
  /**
  * Default: ""
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#key PackDestination#key}
  */
  readonly key?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#value PackDestination#value}
  */
  readonly value: string;
}

export function packDestinationOutputAzureBlobKeyValueMetadataToTerraform(struct?: PackDestinationOutputAzureBlobKeyValueMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function packDestinationOutputAzureBlobKeyValueMetadataToHclTerraform(struct?: PackDestinationOutputAzureBlobKeyValueMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputAzureBlobKeyValueMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackDestinationOutputAzureBlobKeyValueMetadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputAzureBlobKeyValueMetadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._value = value.value;
    }
  }

  // key - computed: true, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class PackDestinationOutputAzureBlobKeyValueMetadataList extends cdktf.ComplexList {
  public internalValue? : PackDestinationOutputAzureBlobKeyValueMetadata[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackDestinationOutputAzureBlobKeyValueMetadataOutputReference {
    return new PackDestinationOutputAzureBlobKeyValueMetadataOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackDestinationOutputAzureBlob {
  /**
  * Add the Output ID value to staging location. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#add_id_to_stage_path PackDestination#add_id_to_stage_path}
  */
  readonly addIdToStagePath?: boolean | cdktf.IResolvable;
  /**
  * Default: "manual"; must be one of ["manual", "secret", "clientSecret", "clientCert"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#auth_type PackDestination#auth_type}
  */
  readonly authType?: string;
  /**
  * Automatically calculate the schema based on the events of each Parquet file generated. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#automatic_schema PackDestination#automatic_schema}
  */
  readonly automaticSchema?: boolean | cdktf.IResolvable;
  /**
  * The Azure cloud to use. Defaults to Azure Public Cloud.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#azure_cloud PackDestination#azure_cloud}
  */
  readonly azureCloud?: string;
  /**
  * JavaScript expression to define the output filename prefix (can be constant). Default: "`CriblOut`"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#base_file_name PackDestination#base_file_name}
  */
  readonly baseFileName?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#certificate PackDestination#certificate}
  */
  readonly certificate?: PackDestinationOutputAzureBlobCertificate;
  /**
  * The service principal's client ID
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#client_id PackDestination#client_id}
  */
  readonly clientId?: string;
  /**
  * Select or create a stored text secret
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#client_text_secret PackDestination#client_text_secret}
  */
  readonly clientTextSecret?: string;
  /**
  * Data compression format to apply to HTTP content before it is delivered. Default: "gzip"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#compress PackDestination#compress}
  */
  readonly compress?: string;
  /**
  * Compression level to apply before moving files to final destination. Default: "best_speed"; must be one of ["best_speed", "normal", "best_compression"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#compression_level PackDestination#compression_level}
  */
  readonly compressionLevel?: string;
  /**
  * Enter your Azure Storage account connection string. If left blank, Stream will fall back to env.AZURE_STORAGE_CONNECTION_STRING.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#connection_string PackDestination#connection_string}
  */
  readonly connectionString?: string;
  /**
  * The Azure Blob Storage container name. Name can include only lowercase letters, numbers, and hyphens. For dynamic container names, enter a JavaScript expression within quotes or backtickss, to be evaluated at initialization. The expression can evaluate to a constant value and can reference Global Variables, such as `myContainer-${C.env["CRIBL_WORKER_ID"]}`.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#container_name PackDestination#container_name}
  */
  readonly containerName: string;
  /**
  * Create the configured container in Azure Blob Storage if it does not already exist. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#create_container PackDestination#create_container}
  */
  readonly createContainer?: boolean | cdktf.IResolvable;
  /**
  * If a file fails to move to its final destination after the maximum number of retries, move it to a designated directory to prevent further errors. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#deadletter_enabled PackDestination#deadletter_enabled}
  */
  readonly deadletterEnabled?: boolean | cdktf.IResolvable;
  /**
  * Storage location for files that fail to reach their final destination after maximum retries are exceeded. Default: "$CRIBL_HOME/state/outputs/dead-letter"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#deadletter_path PackDestination#deadletter_path}
  */
  readonly deadletterPath?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#description PackDestination#description}
  */
  readonly description?: string;
  /**
  * Root directory prepended to path before uploading. Value can be a JavaScript expression enclosed in quotes or backticks, to be evaluated at initialization. The expression can evaluate to a constant value and can reference Global Variables, such as `myBlobPrefix-${C.env["CRIBL_WORKER_ID"]}`.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#dest_path PackDestination#dest_path}
  */
  readonly destPath?: string;
  /**
  * How frequently, in seconds, to clean up empty directories. Default: 300
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#empty_dir_cleanup_sec PackDestination#empty_dir_cleanup_sec}
  */
  readonly emptyDirCleanupSec?: number;
  /**
  * Parquet tools can use the checksum of a Parquet page to verify data integrity. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#enable_page_checksum PackDestination#enable_page_checksum}
  */
  readonly enablePageChecksum?: boolean | cdktf.IResolvable;
  /**
  * Statistics profile an entire file in terms of minimum/maximum values within data, numbers of nulls, etc. You can use Parquet tools to view statistics. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#enable_statistics PackDestination#enable_statistics}
  */
  readonly enableStatistics?: boolean | cdktf.IResolvable;
  /**
  * One page index contains statistics for one data page. Parquet readers use statistics to enable page skipping. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#enable_write_page_index PackDestination#enable_write_page_index}
  */
  readonly enableWritePageIndex?: boolean | cdktf.IResolvable;
  /**
  * Endpoint suffix for the service URL. Takes precedence over the Azure Cloud setting. Defaults to core.windows.net.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#endpoint_suffix PackDestination#endpoint_suffix}
  */
  readonly endpointSuffix?: string;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#environment PackDestination#environment}
  */
  readonly environment?: string;
  /**
  * JavaScript expression to define the output filename suffix (can be constant).  The `__format` variable refers to the value of the `Data format` field (`json` or `raw`).  The `__compression` field refers to the kind of compression being used (`none` or `gzip`). Default: "`.${C.env[\"CRIBL_WORKER_ID\"]}.${__format}${__compression === \"gzip\" ? \".gz\" : \"\"}`"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#file_name_suffix PackDestination#file_name_suffix}
  */
  readonly fileNameSuffix?: string;
  /**
  * Format of the output data. Default: "json"; must be one of ["json", "raw", "parquet"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#format PackDestination#format}
  */
  readonly format?: string;
  /**
  * If set, this line will be written to the beginning of each output file. Default: ""
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#header_line PackDestination#header_line}
  */
  readonly headerLine?: string;
  /**
  * Unique ID for this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#id PackDestination#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * The metadata of files the Destination writes will include the properties you add here as key-value pairs. Useful for tagging. Examples: "key":"OCSF Event Class", "value":"9001"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#key_value_metadata PackDestination#key_value_metadata}
  */
  readonly keyValueMetadata?: PackDestinationOutputAzureBlobKeyValueMetadata[] | cdktf.IResolvable;
  /**
  * Maximum number of parts to upload in parallel per file. Default: 1
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_concurrent_file_parts PackDestination#max_concurrent_file_parts}
  */
  readonly maxConcurrentFileParts?: number;
  /**
  * Maximum amount of time to keep inactive files open. Files open for longer than this will be closed and moved to final output location. Default: 30
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_file_idle_time_sec PackDestination#max_file_idle_time_sec}
  */
  readonly maxFileIdleTimeSec?: number;
  /**
  * Maximum amount of time to write to a file. Files open for longer than this will be closed and moved to final output location. Default: 300
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_file_open_time_sec PackDestination#max_file_open_time_sec}
  */
  readonly maxFileOpenTimeSec?: number;
  /**
  * Maximum uncompressed output file size. Files of this size will be closed and moved to final output location. Default: 32
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_file_size_mb PackDestination#max_file_size_mb}
  */
  readonly maxFileSizeMb?: number;
  /**
  * Maximum number of files to keep open concurrently. When exceeded, @{product} will close the oldest open files and move them to the final output location. Default: 100
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_open_files PackDestination#max_open_files}
  */
  readonly maxOpenFiles?: number;
  /**
  * The maximum number of times a file will attempt to move to its final destination before being dead-lettered. Default: 20
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_retry_num PackDestination#max_retry_num}
  */
  readonly maxRetryNum?: number;
  /**
  * How to handle events when all receivers are exerting backpressure. Default: "block"; must be one of ["block", "drop"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#on_backpressure PackDestination#on_backpressure}
  */
  readonly onBackpressure?: string;
  /**
  * How to handle events when disk space is below the global 'Min free disk space' limit. Default: "block"; must be one of ["block", "drop"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#on_disk_full_backpressure PackDestination#on_disk_full_backpressure}
  */
  readonly onDiskFullBackpressure?: string;
  /**
  * Serialization format of data pages. Note that some reader implementations use Data page V2's attributes to work more efficiently, while others ignore it. Default: "DATA_PAGE_V2"; must be one of ["DATA_PAGE_V1", "DATA_PAGE_V2"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#parquet_data_page_version PackDestination#parquet_data_page_version}
  */
  readonly parquetDataPageVersion?: string;
  /**
  * Target memory size for page segments, such as 1MB or 128MB. Generally, lower values improve reading speed, while higher values improve compression. Default: "1MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#parquet_page_size PackDestination#parquet_page_size}
  */
  readonly parquetPageSize?: string;
  /**
  * The number of rows that every group will contain. The final group can contain a smaller number of rows. Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#parquet_row_group_length PackDestination#parquet_row_group_length}
  */
  readonly parquetRowGroupLength?: number;
  /**
  * Determines which data types are supported and how they are represented. Default: "PARQUET_2_6"; must be one of ["PARQUET_1_0", "PARQUET_2_4", "PARQUET_2_6"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#parquet_version PackDestination#parquet_version}
  */
  readonly parquetVersion?: string;
  /**
  * JavaScript expression defining how files are partitioned and organized. Default is date-based. If blank, Stream will fall back to the event's __partition field value – if present – otherwise to each location's root directory. Default: "C.Time.strftime(_time ? _time : Date.now()/1000, '%Y/%m/%d')"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#partition_expr PackDestination#partition_expr}
  */
  readonly partitionExpr?: string;
  /**
  * Pipeline to process data before sending out to this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pipeline PackDestination#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Remove empty staging directories after moving files. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#remove_empty_dirs PackDestination#remove_empty_dirs}
  */
  readonly removeEmptyDirs?: boolean | cdktf.IResolvable;
  /**
  * Log up to 3 rows that @{product} skips due to data mismatch
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#should_log_invalid_rows PackDestination#should_log_invalid_rows}
  */
  readonly shouldLogInvalidRows?: boolean | cdktf.IResolvable;
  /**
  * Filesystem location in which to buffer files before compressing and moving to final destination. Use performant and stable storage. Default: "$CRIBL_HOME/state/outputs/staging"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#stage_path PackDestination#stage_path}
  */
  readonly stagePath?: string;
  /**
  * The name of your Azure storage account
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#storage_account_name PackDestination#storage_account_name}
  */
  readonly storageAccountName?: string;
  /**
  * Default: "Inferred"; must be one of ["Inferred", "Hot", "Cool", "Cold", "Archive"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#storage_class PackDestination#storage_class}
  */
  readonly storageClass?: string;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#streamtags PackDestination#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Fields to automatically add to events, such as cribl_pipe. Supports wildcards. Default: ["cribl_pipe"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#system_fields PackDestination#system_fields}
  */
  readonly systemFields?: string[];
  /**
  * The service principal's tenant ID
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#tenant_id PackDestination#tenant_id}
  */
  readonly tenantId?: string;
  /**
  * Select or create a stored text secret
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#text_secret PackDestination#text_secret}
  */
  readonly textSecret?: string;
  /**
  * must be "azure_blob"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#type PackDestination#type}
  */
  readonly type?: string;
  /**
  * Buffer size used to write to a file. Default: 64
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#write_high_water_mark PackDestination#write_high_water_mark}
  */
  readonly writeHighWaterMark?: number;
}

export function packDestinationOutputAzureBlobToTerraform(struct?: PackDestinationOutputAzureBlob | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    add_id_to_stage_path: cdktf.booleanToTerraform(struct!.addIdToStagePath),
    auth_type: cdktf.stringToTerraform(struct!.authType),
    automatic_schema: cdktf.booleanToTerraform(struct!.automaticSchema),
    azure_cloud: cdktf.stringToTerraform(struct!.azureCloud),
    base_file_name: cdktf.stringToTerraform(struct!.baseFileName),
    certificate: packDestinationOutputAzureBlobCertificateToTerraform(struct!.certificate),
    client_id: cdktf.stringToTerraform(struct!.clientId),
    client_text_secret: cdktf.stringToTerraform(struct!.clientTextSecret),
    compress: cdktf.stringToTerraform(struct!.compress),
    compression_level: cdktf.stringToTerraform(struct!.compressionLevel),
    connection_string: cdktf.stringToTerraform(struct!.connectionString),
    container_name: cdktf.stringToTerraform(struct!.containerName),
    create_container: cdktf.booleanToTerraform(struct!.createContainer),
    deadletter_enabled: cdktf.booleanToTerraform(struct!.deadletterEnabled),
    deadletter_path: cdktf.stringToTerraform(struct!.deadletterPath),
    description: cdktf.stringToTerraform(struct!.description),
    dest_path: cdktf.stringToTerraform(struct!.destPath),
    empty_dir_cleanup_sec: cdktf.numberToTerraform(struct!.emptyDirCleanupSec),
    enable_page_checksum: cdktf.booleanToTerraform(struct!.enablePageChecksum),
    enable_statistics: cdktf.booleanToTerraform(struct!.enableStatistics),
    enable_write_page_index: cdktf.booleanToTerraform(struct!.enableWritePageIndex),
    endpoint_suffix: cdktf.stringToTerraform(struct!.endpointSuffix),
    environment: cdktf.stringToTerraform(struct!.environment),
    file_name_suffix: cdktf.stringToTerraform(struct!.fileNameSuffix),
    format: cdktf.stringToTerraform(struct!.format),
    header_line: cdktf.stringToTerraform(struct!.headerLine),
    id: cdktf.stringToTerraform(struct!.id),
    key_value_metadata: cdktf.listMapper(packDestinationOutputAzureBlobKeyValueMetadataToTerraform, false)(struct!.keyValueMetadata),
    max_concurrent_file_parts: cdktf.numberToTerraform(struct!.maxConcurrentFileParts),
    max_file_idle_time_sec: cdktf.numberToTerraform(struct!.maxFileIdleTimeSec),
    max_file_open_time_sec: cdktf.numberToTerraform(struct!.maxFileOpenTimeSec),
    max_file_size_mb: cdktf.numberToTerraform(struct!.maxFileSizeMb),
    max_open_files: cdktf.numberToTerraform(struct!.maxOpenFiles),
    max_retry_num: cdktf.numberToTerraform(struct!.maxRetryNum),
    on_backpressure: cdktf.stringToTerraform(struct!.onBackpressure),
    on_disk_full_backpressure: cdktf.stringToTerraform(struct!.onDiskFullBackpressure),
    parquet_data_page_version: cdktf.stringToTerraform(struct!.parquetDataPageVersion),
    parquet_page_size: cdktf.stringToTerraform(struct!.parquetPageSize),
    parquet_row_group_length: cdktf.numberToTerraform(struct!.parquetRowGroupLength),
    parquet_version: cdktf.stringToTerraform(struct!.parquetVersion),
    partition_expr: cdktf.stringToTerraform(struct!.partitionExpr),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    remove_empty_dirs: cdktf.booleanToTerraform(struct!.removeEmptyDirs),
    should_log_invalid_rows: cdktf.booleanToTerraform(struct!.shouldLogInvalidRows),
    stage_path: cdktf.stringToTerraform(struct!.stagePath),
    storage_account_name: cdktf.stringToTerraform(struct!.storageAccountName),
    storage_class: cdktf.stringToTerraform(struct!.storageClass),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    system_fields: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.systemFields),
    tenant_id: cdktf.stringToTerraform(struct!.tenantId),
    text_secret: cdktf.stringToTerraform(struct!.textSecret),
    type: cdktf.stringToTerraform(struct!.type),
    write_high_water_mark: cdktf.numberToTerraform(struct!.writeHighWaterMark),
  }
}


export function packDestinationOutputAzureBlobToHclTerraform(struct?: PackDestinationOutputAzureBlob | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    add_id_to_stage_path: {
      value: cdktf.booleanToHclTerraform(struct!.addIdToStagePath),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    auth_type: {
      value: cdktf.stringToHclTerraform(struct!.authType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    automatic_schema: {
      value: cdktf.booleanToHclTerraform(struct!.automaticSchema),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    azure_cloud: {
      value: cdktf.stringToHclTerraform(struct!.azureCloud),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    base_file_name: {
      value: cdktf.stringToHclTerraform(struct!.baseFileName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    certificate: {
      value: packDestinationOutputAzureBlobCertificateToHclTerraform(struct!.certificate),
      isBlock: true,
      type: "struct",
      storageClassType: "PackDestinationOutputAzureBlobCertificate",
    },
    client_id: {
      value: cdktf.stringToHclTerraform(struct!.clientId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    client_text_secret: {
      value: cdktf.stringToHclTerraform(struct!.clientTextSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    compress: {
      value: cdktf.stringToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    compression_level: {
      value: cdktf.stringToHclTerraform(struct!.compressionLevel),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    connection_string: {
      value: cdktf.stringToHclTerraform(struct!.connectionString),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    container_name: {
      value: cdktf.stringToHclTerraform(struct!.containerName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    create_container: {
      value: cdktf.booleanToHclTerraform(struct!.createContainer),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    deadletter_enabled: {
      value: cdktf.booleanToHclTerraform(struct!.deadletterEnabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    deadletter_path: {
      value: cdktf.stringToHclTerraform(struct!.deadletterPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    dest_path: {
      value: cdktf.stringToHclTerraform(struct!.destPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    empty_dir_cleanup_sec: {
      value: cdktf.numberToHclTerraform(struct!.emptyDirCleanupSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    enable_page_checksum: {
      value: cdktf.booleanToHclTerraform(struct!.enablePageChecksum),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    enable_statistics: {
      value: cdktf.booleanToHclTerraform(struct!.enableStatistics),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    enable_write_page_index: {
      value: cdktf.booleanToHclTerraform(struct!.enableWritePageIndex),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    endpoint_suffix: {
      value: cdktf.stringToHclTerraform(struct!.endpointSuffix),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    file_name_suffix: {
      value: cdktf.stringToHclTerraform(struct!.fileNameSuffix),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    format: {
      value: cdktf.stringToHclTerraform(struct!.format),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    header_line: {
      value: cdktf.stringToHclTerraform(struct!.headerLine),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    key_value_metadata: {
      value: cdktf.listMapperHcl(packDestinationOutputAzureBlobKeyValueMetadataToHclTerraform, false)(struct!.keyValueMetadata),
      isBlock: true,
      type: "list",
      storageClassType: "PackDestinationOutputAzureBlobKeyValueMetadataList",
    },
    max_concurrent_file_parts: {
      value: cdktf.numberToHclTerraform(struct!.maxConcurrentFileParts),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_file_idle_time_sec: {
      value: cdktf.numberToHclTerraform(struct!.maxFileIdleTimeSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_file_open_time_sec: {
      value: cdktf.numberToHclTerraform(struct!.maxFileOpenTimeSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_file_size_mb: {
      value: cdktf.numberToHclTerraform(struct!.maxFileSizeMb),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_open_files: {
      value: cdktf.numberToHclTerraform(struct!.maxOpenFiles),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_retry_num: {
      value: cdktf.numberToHclTerraform(struct!.maxRetryNum),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.onBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    on_disk_full_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.onDiskFullBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    parquet_data_page_version: {
      value: cdktf.stringToHclTerraform(struct!.parquetDataPageVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    parquet_page_size: {
      value: cdktf.stringToHclTerraform(struct!.parquetPageSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    parquet_row_group_length: {
      value: cdktf.numberToHclTerraform(struct!.parquetRowGroupLength),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    parquet_version: {
      value: cdktf.stringToHclTerraform(struct!.parquetVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    partition_expr: {
      value: cdktf.stringToHclTerraform(struct!.partitionExpr),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    remove_empty_dirs: {
      value: cdktf.booleanToHclTerraform(struct!.removeEmptyDirs),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    should_log_invalid_rows: {
      value: cdktf.booleanToHclTerraform(struct!.shouldLogInvalidRows),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    stage_path: {
      value: cdktf.stringToHclTerraform(struct!.stagePath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    storage_account_name: {
      value: cdktf.stringToHclTerraform(struct!.storageAccountName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    storage_class: {
      value: cdktf.stringToHclTerraform(struct!.storageClass),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    system_fields: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.systemFields),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    tenant_id: {
      value: cdktf.stringToHclTerraform(struct!.tenantId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    text_secret: {
      value: cdktf.stringToHclTerraform(struct!.textSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    write_high_water_mark: {
      value: cdktf.numberToHclTerraform(struct!.writeHighWaterMark),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputAzureBlobOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackDestinationOutputAzureBlob | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._addIdToStagePath !== undefined) {
      hasAnyValues = true;
      internalValueResult.addIdToStagePath = this._addIdToStagePath;
    }
    if (this._authType !== undefined) {
      hasAnyValues = true;
      internalValueResult.authType = this._authType;
    }
    if (this._automaticSchema !== undefined) {
      hasAnyValues = true;
      internalValueResult.automaticSchema = this._automaticSchema;
    }
    if (this._azureCloud !== undefined) {
      hasAnyValues = true;
      internalValueResult.azureCloud = this._azureCloud;
    }
    if (this._baseFileName !== undefined) {
      hasAnyValues = true;
      internalValueResult.baseFileName = this._baseFileName;
    }
    if (this._certificate?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.certificate = this._certificate?.internalValue;
    }
    if (this._clientId !== undefined) {
      hasAnyValues = true;
      internalValueResult.clientId = this._clientId;
    }
    if (this._clientTextSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.clientTextSecret = this._clientTextSecret;
    }
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._compressionLevel !== undefined) {
      hasAnyValues = true;
      internalValueResult.compressionLevel = this._compressionLevel;
    }
    if (this._connectionString !== undefined) {
      hasAnyValues = true;
      internalValueResult.connectionString = this._connectionString;
    }
    if (this._containerName !== undefined) {
      hasAnyValues = true;
      internalValueResult.containerName = this._containerName;
    }
    if (this._createContainer !== undefined) {
      hasAnyValues = true;
      internalValueResult.createContainer = this._createContainer;
    }
    if (this._deadletterEnabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.deadletterEnabled = this._deadletterEnabled;
    }
    if (this._deadletterPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.deadletterPath = this._deadletterPath;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._destPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.destPath = this._destPath;
    }
    if (this._emptyDirCleanupSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.emptyDirCleanupSec = this._emptyDirCleanupSec;
    }
    if (this._enablePageChecksum !== undefined) {
      hasAnyValues = true;
      internalValueResult.enablePageChecksum = this._enablePageChecksum;
    }
    if (this._enableStatistics !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableStatistics = this._enableStatistics;
    }
    if (this._enableWritePageIndex !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableWritePageIndex = this._enableWritePageIndex;
    }
    if (this._endpointSuffix !== undefined) {
      hasAnyValues = true;
      internalValueResult.endpointSuffix = this._endpointSuffix;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._fileNameSuffix !== undefined) {
      hasAnyValues = true;
      internalValueResult.fileNameSuffix = this._fileNameSuffix;
    }
    if (this._format !== undefined) {
      hasAnyValues = true;
      internalValueResult.format = this._format;
    }
    if (this._headerLine !== undefined) {
      hasAnyValues = true;
      internalValueResult.headerLine = this._headerLine;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._keyValueMetadata?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.keyValueMetadata = this._keyValueMetadata?.internalValue;
    }
    if (this._maxConcurrentFileParts !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxConcurrentFileParts = this._maxConcurrentFileParts;
    }
    if (this._maxFileIdleTimeSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxFileIdleTimeSec = this._maxFileIdleTimeSec;
    }
    if (this._maxFileOpenTimeSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxFileOpenTimeSec = this._maxFileOpenTimeSec;
    }
    if (this._maxFileSizeMb !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxFileSizeMb = this._maxFileSizeMb;
    }
    if (this._maxOpenFiles !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxOpenFiles = this._maxOpenFiles;
    }
    if (this._maxRetryNum !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxRetryNum = this._maxRetryNum;
    }
    if (this._onBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.onBackpressure = this._onBackpressure;
    }
    if (this._onDiskFullBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.onDiskFullBackpressure = this._onDiskFullBackpressure;
    }
    if (this._parquetDataPageVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.parquetDataPageVersion = this._parquetDataPageVersion;
    }
    if (this._parquetPageSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.parquetPageSize = this._parquetPageSize;
    }
    if (this._parquetRowGroupLength !== undefined) {
      hasAnyValues = true;
      internalValueResult.parquetRowGroupLength = this._parquetRowGroupLength;
    }
    if (this._parquetVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.parquetVersion = this._parquetVersion;
    }
    if (this._partitionExpr !== undefined) {
      hasAnyValues = true;
      internalValueResult.partitionExpr = this._partitionExpr;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._removeEmptyDirs !== undefined) {
      hasAnyValues = true;
      internalValueResult.removeEmptyDirs = this._removeEmptyDirs;
    }
    if (this._shouldLogInvalidRows !== undefined) {
      hasAnyValues = true;
      internalValueResult.shouldLogInvalidRows = this._shouldLogInvalidRows;
    }
    if (this._stagePath !== undefined) {
      hasAnyValues = true;
      internalValueResult.stagePath = this._stagePath;
    }
    if (this._storageAccountName !== undefined) {
      hasAnyValues = true;
      internalValueResult.storageAccountName = this._storageAccountName;
    }
    if (this._storageClass !== undefined) {
      hasAnyValues = true;
      internalValueResult.storageClass = this._storageClass;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._systemFields !== undefined) {
      hasAnyValues = true;
      internalValueResult.systemFields = this._systemFields;
    }
    if (this._tenantId !== undefined) {
      hasAnyValues = true;
      internalValueResult.tenantId = this._tenantId;
    }
    if (this._textSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.textSecret = this._textSecret;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._writeHighWaterMark !== undefined) {
      hasAnyValues = true;
      internalValueResult.writeHighWaterMark = this._writeHighWaterMark;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputAzureBlob | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._addIdToStagePath = undefined;
      this._authType = undefined;
      this._automaticSchema = undefined;
      this._azureCloud = undefined;
      this._baseFileName = undefined;
      this._certificate.internalValue = undefined;
      this._clientId = undefined;
      this._clientTextSecret = undefined;
      this._compress = undefined;
      this._compressionLevel = undefined;
      this._connectionString = undefined;
      this._containerName = undefined;
      this._createContainer = undefined;
      this._deadletterEnabled = undefined;
      this._deadletterPath = undefined;
      this._description = undefined;
      this._destPath = undefined;
      this._emptyDirCleanupSec = undefined;
      this._enablePageChecksum = undefined;
      this._enableStatistics = undefined;
      this._enableWritePageIndex = undefined;
      this._endpointSuffix = undefined;
      this._environment = undefined;
      this._fileNameSuffix = undefined;
      this._format = undefined;
      this._headerLine = undefined;
      this._id = undefined;
      this._keyValueMetadata.internalValue = undefined;
      this._maxConcurrentFileParts = undefined;
      this._maxFileIdleTimeSec = undefined;
      this._maxFileOpenTimeSec = undefined;
      this._maxFileSizeMb = undefined;
      this._maxOpenFiles = undefined;
      this._maxRetryNum = undefined;
      this._onBackpressure = undefined;
      this._onDiskFullBackpressure = undefined;
      this._parquetDataPageVersion = undefined;
      this._parquetPageSize = undefined;
      this._parquetRowGroupLength = undefined;
      this._parquetVersion = undefined;
      this._partitionExpr = undefined;
      this._pipeline = undefined;
      this._removeEmptyDirs = undefined;
      this._shouldLogInvalidRows = undefined;
      this._stagePath = undefined;
      this._storageAccountName = undefined;
      this._storageClass = undefined;
      this._streamtags = undefined;
      this._systemFields = undefined;
      this._tenantId = undefined;
      this._textSecret = undefined;
      this._type = undefined;
      this._writeHighWaterMark = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._addIdToStagePath = value.addIdToStagePath;
      this._authType = value.authType;
      this._automaticSchema = value.automaticSchema;
      this._azureCloud = value.azureCloud;
      this._baseFileName = value.baseFileName;
      this._certificate.internalValue = value.certificate;
      this._clientId = value.clientId;
      this._clientTextSecret = value.clientTextSecret;
      this._compress = value.compress;
      this._compressionLevel = value.compressionLevel;
      this._connectionString = value.connectionString;
      this._containerName = value.containerName;
      this._createContainer = value.createContainer;
      this._deadletterEnabled = value.deadletterEnabled;
      this._deadletterPath = value.deadletterPath;
      this._description = value.description;
      this._destPath = value.destPath;
      this._emptyDirCleanupSec = value.emptyDirCleanupSec;
      this._enablePageChecksum = value.enablePageChecksum;
      this._enableStatistics = value.enableStatistics;
      this._enableWritePageIndex = value.enableWritePageIndex;
      this._endpointSuffix = value.endpointSuffix;
      this._environment = value.environment;
      this._fileNameSuffix = value.fileNameSuffix;
      this._format = value.format;
      this._headerLine = value.headerLine;
      this._id = value.id;
      this._keyValueMetadata.internalValue = value.keyValueMetadata;
      this._maxConcurrentFileParts = value.maxConcurrentFileParts;
      this._maxFileIdleTimeSec = value.maxFileIdleTimeSec;
      this._maxFileOpenTimeSec = value.maxFileOpenTimeSec;
      this._maxFileSizeMb = value.maxFileSizeMb;
      this._maxOpenFiles = value.maxOpenFiles;
      this._maxRetryNum = value.maxRetryNum;
      this._onBackpressure = value.onBackpressure;
      this._onDiskFullBackpressure = value.onDiskFullBackpressure;
      this._parquetDataPageVersion = value.parquetDataPageVersion;
      this._parquetPageSize = value.parquetPageSize;
      this._parquetRowGroupLength = value.parquetRowGroupLength;
      this._parquetVersion = value.parquetVersion;
      this._partitionExpr = value.partitionExpr;
      this._pipeline = value.pipeline;
      this._removeEmptyDirs = value.removeEmptyDirs;
      this._shouldLogInvalidRows = value.shouldLogInvalidRows;
      this._stagePath = value.stagePath;
      this._storageAccountName = value.storageAccountName;
      this._storageClass = value.storageClass;
      this._streamtags = value.streamtags;
      this._systemFields = value.systemFields;
      this._tenantId = value.tenantId;
      this._textSecret = value.textSecret;
      this._type = value.type;
      this._writeHighWaterMark = value.writeHighWaterMark;
    }
  }

  // add_id_to_stage_path - computed: true, optional: true, required: false
  private _addIdToStagePath?: boolean | cdktf.IResolvable; 
  public get addIdToStagePath() {
    return this.getBooleanAttribute('add_id_to_stage_path');
  }
  public set addIdToStagePath(value: boolean | cdktf.IResolvable) {
    this._addIdToStagePath = value;
  }
  public resetAddIdToStagePath() {
    this._addIdToStagePath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addIdToStagePathInput() {
    return this._addIdToStagePath;
  }

  // auth_type - computed: true, optional: true, required: false
  private _authType?: string; 
  public get authType() {
    return this.getStringAttribute('auth_type');
  }
  public set authType(value: string) {
    this._authType = value;
  }
  public resetAuthType() {
    this._authType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authTypeInput() {
    return this._authType;
  }

  // automatic_schema - computed: true, optional: true, required: false
  private _automaticSchema?: boolean | cdktf.IResolvable; 
  public get automaticSchema() {
    return this.getBooleanAttribute('automatic_schema');
  }
  public set automaticSchema(value: boolean | cdktf.IResolvable) {
    this._automaticSchema = value;
  }
  public resetAutomaticSchema() {
    this._automaticSchema = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get automaticSchemaInput() {
    return this._automaticSchema;
  }

  // azure_cloud - computed: false, optional: true, required: false
  private _azureCloud?: string; 
  public get azureCloud() {
    return this.getStringAttribute('azure_cloud');
  }
  public set azureCloud(value: string) {
    this._azureCloud = value;
  }
  public resetAzureCloud() {
    this._azureCloud = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get azureCloudInput() {
    return this._azureCloud;
  }

  // base_file_name - computed: true, optional: true, required: false
  private _baseFileName?: string; 
  public get baseFileName() {
    return this.getStringAttribute('base_file_name');
  }
  public set baseFileName(value: string) {
    this._baseFileName = value;
  }
  public resetBaseFileName() {
    this._baseFileName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get baseFileNameInput() {
    return this._baseFileName;
  }

  // certificate - computed: false, optional: true, required: false
  private _certificate = new PackDestinationOutputAzureBlobCertificateOutputReference(this, "certificate");
  public get certificate() {
    return this._certificate;
  }
  public putCertificate(value: PackDestinationOutputAzureBlobCertificate) {
    this._certificate.internalValue = value;
  }
  public resetCertificate() {
    this._certificate.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certificateInput() {
    return this._certificate.internalValue;
  }

  // client_id - computed: false, optional: true, required: false
  private _clientId?: string; 
  public get clientId() {
    return this.getStringAttribute('client_id');
  }
  public set clientId(value: string) {
    this._clientId = value;
  }
  public resetClientId() {
    this._clientId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clientIdInput() {
    return this._clientId;
  }

  // client_text_secret - computed: false, optional: true, required: false
  private _clientTextSecret?: string; 
  public get clientTextSecret() {
    return this.getStringAttribute('client_text_secret');
  }
  public set clientTextSecret(value: string) {
    this._clientTextSecret = value;
  }
  public resetClientTextSecret() {
    this._clientTextSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clientTextSecretInput() {
    return this._clientTextSecret;
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: string; 
  public get compress() {
    return this.getStringAttribute('compress');
  }
  public set compress(value: string) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // compression_level - computed: true, optional: true, required: false
  private _compressionLevel?: string; 
  public get compressionLevel() {
    return this.getStringAttribute('compression_level');
  }
  public set compressionLevel(value: string) {
    this._compressionLevel = value;
  }
  public resetCompressionLevel() {
    this._compressionLevel = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressionLevelInput() {
    return this._compressionLevel;
  }

  // connection_string - computed: false, optional: true, required: false
  private _connectionString?: string; 
  public get connectionString() {
    return this.getStringAttribute('connection_string');
  }
  public set connectionString(value: string) {
    this._connectionString = value;
  }
  public resetConnectionString() {
    this._connectionString = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectionStringInput() {
    return this._connectionString;
  }

  // container_name - computed: false, optional: false, required: true
  private _containerName?: string; 
  public get containerName() {
    return this.getStringAttribute('container_name');
  }
  public set containerName(value: string) {
    this._containerName = value;
  }
  // Temporarily expose input value. Use with caution.
  public get containerNameInput() {
    return this._containerName;
  }

  // create_container - computed: true, optional: true, required: false
  private _createContainer?: boolean | cdktf.IResolvable; 
  public get createContainer() {
    return this.getBooleanAttribute('create_container');
  }
  public set createContainer(value: boolean | cdktf.IResolvable) {
    this._createContainer = value;
  }
  public resetCreateContainer() {
    this._createContainer = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get createContainerInput() {
    return this._createContainer;
  }

  // deadletter_enabled - computed: true, optional: true, required: false
  private _deadletterEnabled?: boolean | cdktf.IResolvable; 
  public get deadletterEnabled() {
    return this.getBooleanAttribute('deadletter_enabled');
  }
  public set deadletterEnabled(value: boolean | cdktf.IResolvable) {
    this._deadletterEnabled = value;
  }
  public resetDeadletterEnabled() {
    this._deadletterEnabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get deadletterEnabledInput() {
    return this._deadletterEnabled;
  }

  // deadletter_path - computed: true, optional: true, required: false
  private _deadletterPath?: string; 
  public get deadletterPath() {
    return this.getStringAttribute('deadletter_path');
  }
  public set deadletterPath(value: string) {
    this._deadletterPath = value;
  }
  public resetDeadletterPath() {
    this._deadletterPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get deadletterPathInput() {
    return this._deadletterPath;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // dest_path - computed: false, optional: true, required: false
  private _destPath?: string; 
  public get destPath() {
    return this.getStringAttribute('dest_path');
  }
  public set destPath(value: string) {
    this._destPath = value;
  }
  public resetDestPath() {
    this._destPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get destPathInput() {
    return this._destPath;
  }

  // empty_dir_cleanup_sec - computed: true, optional: true, required: false
  private _emptyDirCleanupSec?: number; 
  public get emptyDirCleanupSec() {
    return this.getNumberAttribute('empty_dir_cleanup_sec');
  }
  public set emptyDirCleanupSec(value: number) {
    this._emptyDirCleanupSec = value;
  }
  public resetEmptyDirCleanupSec() {
    this._emptyDirCleanupSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get emptyDirCleanupSecInput() {
    return this._emptyDirCleanupSec;
  }

  // enable_page_checksum - computed: true, optional: true, required: false
  private _enablePageChecksum?: boolean | cdktf.IResolvable; 
  public get enablePageChecksum() {
    return this.getBooleanAttribute('enable_page_checksum');
  }
  public set enablePageChecksum(value: boolean | cdktf.IResolvable) {
    this._enablePageChecksum = value;
  }
  public resetEnablePageChecksum() {
    this._enablePageChecksum = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enablePageChecksumInput() {
    return this._enablePageChecksum;
  }

  // enable_statistics - computed: true, optional: true, required: false
  private _enableStatistics?: boolean | cdktf.IResolvable; 
  public get enableStatistics() {
    return this.getBooleanAttribute('enable_statistics');
  }
  public set enableStatistics(value: boolean | cdktf.IResolvable) {
    this._enableStatistics = value;
  }
  public resetEnableStatistics() {
    this._enableStatistics = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableStatisticsInput() {
    return this._enableStatistics;
  }

  // enable_write_page_index - computed: true, optional: true, required: false
  private _enableWritePageIndex?: boolean | cdktf.IResolvable; 
  public get enableWritePageIndex() {
    return this.getBooleanAttribute('enable_write_page_index');
  }
  public set enableWritePageIndex(value: boolean | cdktf.IResolvable) {
    this._enableWritePageIndex = value;
  }
  public resetEnableWritePageIndex() {
    this._enableWritePageIndex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableWritePageIndexInput() {
    return this._enableWritePageIndex;
  }

  // endpoint_suffix - computed: false, optional: true, required: false
  private _endpointSuffix?: string; 
  public get endpointSuffix() {
    return this.getStringAttribute('endpoint_suffix');
  }
  public set endpointSuffix(value: string) {
    this._endpointSuffix = value;
  }
  public resetEndpointSuffix() {
    this._endpointSuffix = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get endpointSuffixInput() {
    return this._endpointSuffix;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // file_name_suffix - computed: true, optional: true, required: false
  private _fileNameSuffix?: string; 
  public get fileNameSuffix() {
    return this.getStringAttribute('file_name_suffix');
  }
  public set fileNameSuffix(value: string) {
    this._fileNameSuffix = value;
  }
  public resetFileNameSuffix() {
    this._fileNameSuffix = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fileNameSuffixInput() {
    return this._fileNameSuffix;
  }

  // format - computed: true, optional: true, required: false
  private _format?: string; 
  public get format() {
    return this.getStringAttribute('format');
  }
  public set format(value: string) {
    this._format = value;
  }
  public resetFormat() {
    this._format = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get formatInput() {
    return this._format;
  }

  // header_line - computed: true, optional: true, required: false
  private _headerLine?: string; 
  public get headerLine() {
    return this.getStringAttribute('header_line');
  }
  public set headerLine(value: string) {
    this._headerLine = value;
  }
  public resetHeaderLine() {
    this._headerLine = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get headerLineInput() {
    return this._headerLine;
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // key_value_metadata - computed: false, optional: true, required: false
  private _keyValueMetadata = new PackDestinationOutputAzureBlobKeyValueMetadataList(this, "key_value_metadata", false);
  public get keyValueMetadata() {
    return this._keyValueMetadata;
  }
  public putKeyValueMetadata(value: PackDestinationOutputAzureBlobKeyValueMetadata[] | cdktf.IResolvable) {
    this._keyValueMetadata.internalValue = value;
  }
  public resetKeyValueMetadata() {
    this._keyValueMetadata.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyValueMetadataInput() {
    return this._keyValueMetadata.internalValue;
  }

  // max_concurrent_file_parts - computed: true, optional: true, required: false
  private _maxConcurrentFileParts?: number; 
  public get maxConcurrentFileParts() {
    return this.getNumberAttribute('max_concurrent_file_parts');
  }
  public set maxConcurrentFileParts(value: number) {
    this._maxConcurrentFileParts = value;
  }
  public resetMaxConcurrentFileParts() {
    this._maxConcurrentFileParts = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxConcurrentFilePartsInput() {
    return this._maxConcurrentFileParts;
  }

  // max_file_idle_time_sec - computed: true, optional: true, required: false
  private _maxFileIdleTimeSec?: number; 
  public get maxFileIdleTimeSec() {
    return this.getNumberAttribute('max_file_idle_time_sec');
  }
  public set maxFileIdleTimeSec(value: number) {
    this._maxFileIdleTimeSec = value;
  }
  public resetMaxFileIdleTimeSec() {
    this._maxFileIdleTimeSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxFileIdleTimeSecInput() {
    return this._maxFileIdleTimeSec;
  }

  // max_file_open_time_sec - computed: true, optional: true, required: false
  private _maxFileOpenTimeSec?: number; 
  public get maxFileOpenTimeSec() {
    return this.getNumberAttribute('max_file_open_time_sec');
  }
  public set maxFileOpenTimeSec(value: number) {
    this._maxFileOpenTimeSec = value;
  }
  public resetMaxFileOpenTimeSec() {
    this._maxFileOpenTimeSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxFileOpenTimeSecInput() {
    return this._maxFileOpenTimeSec;
  }

  // max_file_size_mb - computed: true, optional: true, required: false
  private _maxFileSizeMb?: number; 
  public get maxFileSizeMb() {
    return this.getNumberAttribute('max_file_size_mb');
  }
  public set maxFileSizeMb(value: number) {
    this._maxFileSizeMb = value;
  }
  public resetMaxFileSizeMb() {
    this._maxFileSizeMb = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxFileSizeMbInput() {
    return this._maxFileSizeMb;
  }

  // max_open_files - computed: true, optional: true, required: false
  private _maxOpenFiles?: number; 
  public get maxOpenFiles() {
    return this.getNumberAttribute('max_open_files');
  }
  public set maxOpenFiles(value: number) {
    this._maxOpenFiles = value;
  }
  public resetMaxOpenFiles() {
    this._maxOpenFiles = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxOpenFilesInput() {
    return this._maxOpenFiles;
  }

  // max_retry_num - computed: true, optional: true, required: false
  private _maxRetryNum?: number; 
  public get maxRetryNum() {
    return this.getNumberAttribute('max_retry_num');
  }
  public set maxRetryNum(value: number) {
    this._maxRetryNum = value;
  }
  public resetMaxRetryNum() {
    this._maxRetryNum = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxRetryNumInput() {
    return this._maxRetryNum;
  }

  // on_backpressure - computed: true, optional: true, required: false
  private _onBackpressure?: string; 
  public get onBackpressure() {
    return this.getStringAttribute('on_backpressure');
  }
  public set onBackpressure(value: string) {
    this._onBackpressure = value;
  }
  public resetOnBackpressure() {
    this._onBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get onBackpressureInput() {
    return this._onBackpressure;
  }

  // on_disk_full_backpressure - computed: true, optional: true, required: false
  private _onDiskFullBackpressure?: string; 
  public get onDiskFullBackpressure() {
    return this.getStringAttribute('on_disk_full_backpressure');
  }
  public set onDiskFullBackpressure(value: string) {
    this._onDiskFullBackpressure = value;
  }
  public resetOnDiskFullBackpressure() {
    this._onDiskFullBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get onDiskFullBackpressureInput() {
    return this._onDiskFullBackpressure;
  }

  // parquet_data_page_version - computed: true, optional: true, required: false
  private _parquetDataPageVersion?: string; 
  public get parquetDataPageVersion() {
    return this.getStringAttribute('parquet_data_page_version');
  }
  public set parquetDataPageVersion(value: string) {
    this._parquetDataPageVersion = value;
  }
  public resetParquetDataPageVersion() {
    this._parquetDataPageVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get parquetDataPageVersionInput() {
    return this._parquetDataPageVersion;
  }

  // parquet_page_size - computed: true, optional: true, required: false
  private _parquetPageSize?: string; 
  public get parquetPageSize() {
    return this.getStringAttribute('parquet_page_size');
  }
  public set parquetPageSize(value: string) {
    this._parquetPageSize = value;
  }
  public resetParquetPageSize() {
    this._parquetPageSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get parquetPageSizeInput() {
    return this._parquetPageSize;
  }

  // parquet_row_group_length - computed: true, optional: true, required: false
  private _parquetRowGroupLength?: number; 
  public get parquetRowGroupLength() {
    return this.getNumberAttribute('parquet_row_group_length');
  }
  public set parquetRowGroupLength(value: number) {
    this._parquetRowGroupLength = value;
  }
  public resetParquetRowGroupLength() {
    this._parquetRowGroupLength = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get parquetRowGroupLengthInput() {
    return this._parquetRowGroupLength;
  }

  // parquet_version - computed: true, optional: true, required: false
  private _parquetVersion?: string; 
  public get parquetVersion() {
    return this.getStringAttribute('parquet_version');
  }
  public set parquetVersion(value: string) {
    this._parquetVersion = value;
  }
  public resetParquetVersion() {
    this._parquetVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get parquetVersionInput() {
    return this._parquetVersion;
  }

  // partition_expr - computed: true, optional: true, required: false
  private _partitionExpr?: string; 
  public get partitionExpr() {
    return this.getStringAttribute('partition_expr');
  }
  public set partitionExpr(value: string) {
    this._partitionExpr = value;
  }
  public resetPartitionExpr() {
    this._partitionExpr = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get partitionExprInput() {
    return this._partitionExpr;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // remove_empty_dirs - computed: true, optional: true, required: false
  private _removeEmptyDirs?: boolean | cdktf.IResolvable; 
  public get removeEmptyDirs() {
    return this.getBooleanAttribute('remove_empty_dirs');
  }
  public set removeEmptyDirs(value: boolean | cdktf.IResolvable) {
    this._removeEmptyDirs = value;
  }
  public resetRemoveEmptyDirs() {
    this._removeEmptyDirs = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get removeEmptyDirsInput() {
    return this._removeEmptyDirs;
  }

  // should_log_invalid_rows - computed: false, optional: true, required: false
  private _shouldLogInvalidRows?: boolean | cdktf.IResolvable; 
  public get shouldLogInvalidRows() {
    return this.getBooleanAttribute('should_log_invalid_rows');
  }
  public set shouldLogInvalidRows(value: boolean | cdktf.IResolvable) {
    this._shouldLogInvalidRows = value;
  }
  public resetShouldLogInvalidRows() {
    this._shouldLogInvalidRows = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get shouldLogInvalidRowsInput() {
    return this._shouldLogInvalidRows;
  }

  // stage_path - computed: true, optional: true, required: false
  private _stagePath?: string; 
  public get stagePath() {
    return this.getStringAttribute('stage_path');
  }
  public set stagePath(value: string) {
    this._stagePath = value;
  }
  public resetStagePath() {
    this._stagePath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get stagePathInput() {
    return this._stagePath;
  }

  // storage_account_name - computed: false, optional: true, required: false
  private _storageAccountName?: string; 
  public get storageAccountName() {
    return this.getStringAttribute('storage_account_name');
  }
  public set storageAccountName(value: string) {
    this._storageAccountName = value;
  }
  public resetStorageAccountName() {
    this._storageAccountName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get storageAccountNameInput() {
    return this._storageAccountName;
  }

  // storage_class - computed: true, optional: true, required: false
  private _storageClass?: string; 
  public get storageClass() {
    return this.getStringAttribute('storage_class');
  }
  public set storageClass(value: string) {
    this._storageClass = value;
  }
  public resetStorageClass() {
    this._storageClass = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get storageClassInput() {
    return this._storageClass;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // system_fields - computed: true, optional: true, required: false
  private _systemFields?: string[]; 
  public get systemFields() {
    return this.getListAttribute('system_fields');
  }
  public set systemFields(value: string[]) {
    this._systemFields = value;
  }
  public resetSystemFields() {
    this._systemFields = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get systemFieldsInput() {
    return this._systemFields;
  }

  // tenant_id - computed: false, optional: true, required: false
  private _tenantId?: string; 
  public get tenantId() {
    return this.getStringAttribute('tenant_id');
  }
  public set tenantId(value: string) {
    this._tenantId = value;
  }
  public resetTenantId() {
    this._tenantId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tenantIdInput() {
    return this._tenantId;
  }

  // text_secret - computed: false, optional: true, required: false
  private _textSecret?: string; 
  public get textSecret() {
    return this.getStringAttribute('text_secret');
  }
  public set textSecret(value: string) {
    this._textSecret = value;
  }
  public resetTextSecret() {
    this._textSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get textSecretInput() {
    return this._textSecret;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // write_high_water_mark - computed: true, optional: true, required: false
  private _writeHighWaterMark?: number; 
  public get writeHighWaterMark() {
    return this.getNumberAttribute('write_high_water_mark');
  }
  public set writeHighWaterMark(value: number) {
    this._writeHighWaterMark = value;
  }
  public resetWriteHighWaterMark() {
    this._writeHighWaterMark = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get writeHighWaterMarkInput() {
    return this._writeHighWaterMark;
  }
}
export interface PackDestinationOutputAzureDataExplorerAdditionalProperties {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#key PackDestination#key}
  */
  readonly key: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#value PackDestination#value}
  */
  readonly value: string;
}

export function packDestinationOutputAzureDataExplorerAdditionalPropertiesToTerraform(struct?: PackDestinationOutputAzureDataExplorerAdditionalProperties | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function packDestinationOutputAzureDataExplorerAdditionalPropertiesToHclTerraform(struct?: PackDestinationOutputAzureDataExplorerAdditionalProperties | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputAzureDataExplorerAdditionalPropertiesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackDestinationOutputAzureDataExplorerAdditionalProperties | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputAzureDataExplorerAdditionalProperties | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._value = value.value;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class PackDestinationOutputAzureDataExplorerAdditionalPropertiesList extends cdktf.ComplexList {
  public internalValue? : PackDestinationOutputAzureDataExplorerAdditionalProperties[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackDestinationOutputAzureDataExplorerAdditionalPropertiesOutputReference {
    return new PackDestinationOutputAzureDataExplorerAdditionalPropertiesOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackDestinationOutputAzureDataExplorerCertificate {
  /**
  * The certificate you registered as credentials for your app in the Azure portal
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#certificate_name PackDestination#certificate_name}
  */
  readonly certificateName?: string;
}

export function packDestinationOutputAzureDataExplorerCertificateToTerraform(struct?: PackDestinationOutputAzureDataExplorerCertificate | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    certificate_name: cdktf.stringToTerraform(struct!.certificateName),
  }
}


export function packDestinationOutputAzureDataExplorerCertificateToHclTerraform(struct?: PackDestinationOutputAzureDataExplorerCertificate | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    certificate_name: {
      value: cdktf.stringToHclTerraform(struct!.certificateName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputAzureDataExplorerCertificateOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackDestinationOutputAzureDataExplorerCertificate | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._certificateName !== undefined) {
      hasAnyValues = true;
      internalValueResult.certificateName = this._certificateName;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputAzureDataExplorerCertificate | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._certificateName = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._certificateName = value.certificateName;
    }
  }

  // certificate_name - computed: false, optional: true, required: false
  private _certificateName?: string; 
  public get certificateName() {
    return this.getStringAttribute('certificate_name');
  }
  public set certificateName(value: string) {
    this._certificateName = value;
  }
  public resetCertificateName() {
    this._certificateName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certificateNameInput() {
    return this._certificateName;
  }
}
export interface PackDestinationOutputAzureDataExplorerExtentTags {
  /**
  * must be one of ["dropBy", "ingestBy"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#prefix PackDestination#prefix}
  */
  readonly prefix?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#value PackDestination#value}
  */
  readonly value: string;
}

export function packDestinationOutputAzureDataExplorerExtentTagsToTerraform(struct?: PackDestinationOutputAzureDataExplorerExtentTags | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    prefix: cdktf.stringToTerraform(struct!.prefix),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function packDestinationOutputAzureDataExplorerExtentTagsToHclTerraform(struct?: PackDestinationOutputAzureDataExplorerExtentTags | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    prefix: {
      value: cdktf.stringToHclTerraform(struct!.prefix),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputAzureDataExplorerExtentTagsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackDestinationOutputAzureDataExplorerExtentTags | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._prefix !== undefined) {
      hasAnyValues = true;
      internalValueResult.prefix = this._prefix;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputAzureDataExplorerExtentTags | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._prefix = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._prefix = value.prefix;
      this._value = value.value;
    }
  }

  // prefix - computed: false, optional: true, required: false
  private _prefix?: string; 
  public get prefix() {
    return this.getStringAttribute('prefix');
  }
  public set prefix(value: string) {
    this._prefix = value;
  }
  public resetPrefix() {
    this._prefix = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get prefixInput() {
    return this._prefix;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class PackDestinationOutputAzureDataExplorerExtentTagsList extends cdktf.ComplexList {
  public internalValue? : PackDestinationOutputAzureDataExplorerExtentTags[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackDestinationOutputAzureDataExplorerExtentTagsOutputReference {
    return new PackDestinationOutputAzureDataExplorerExtentTagsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackDestinationOutputAzureDataExplorerIngestIfNotExists {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#value PackDestination#value}
  */
  readonly value: string;
}

export function packDestinationOutputAzureDataExplorerIngestIfNotExistsToTerraform(struct?: PackDestinationOutputAzureDataExplorerIngestIfNotExists | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function packDestinationOutputAzureDataExplorerIngestIfNotExistsToHclTerraform(struct?: PackDestinationOutputAzureDataExplorerIngestIfNotExists | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputAzureDataExplorerIngestIfNotExistsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackDestinationOutputAzureDataExplorerIngestIfNotExists | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputAzureDataExplorerIngestIfNotExists | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._value = value.value;
    }
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class PackDestinationOutputAzureDataExplorerIngestIfNotExistsList extends cdktf.ComplexList {
  public internalValue? : PackDestinationOutputAzureDataExplorerIngestIfNotExists[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackDestinationOutputAzureDataExplorerIngestIfNotExistsOutputReference {
    return new PackDestinationOutputAzureDataExplorerIngestIfNotExistsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackDestinationOutputAzureDataExplorerPqControls {
}

export function packDestinationOutputAzureDataExplorerPqControlsToTerraform(struct?: PackDestinationOutputAzureDataExplorerPqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function packDestinationOutputAzureDataExplorerPqControlsToHclTerraform(struct?: PackDestinationOutputAzureDataExplorerPqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class PackDestinationOutputAzureDataExplorerPqControlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackDestinationOutputAzureDataExplorerPqControls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputAzureDataExplorerPqControls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface PackDestinationOutputAzureDataExplorerResponseRetrySettings {
  /**
  * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc. Default: 2
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#backoff_rate PackDestination#backoff_rate}
  */
  readonly backoffRate?: number;
  /**
  * The HTTP response status code that will trigger retries
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#http_status PackDestination#http_status}
  */
  readonly httpStatus: number;
  /**
  * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes). Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#initial_backoff PackDestination#initial_backoff}
  */
  readonly initialBackoff?: number;
  /**
  * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds). Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_backoff PackDestination#max_backoff}
  */
  readonly maxBackoff?: number;
}

export function packDestinationOutputAzureDataExplorerResponseRetrySettingsToTerraform(struct?: PackDestinationOutputAzureDataExplorerResponseRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    backoff_rate: cdktf.numberToTerraform(struct!.backoffRate),
    http_status: cdktf.numberToTerraform(struct!.httpStatus),
    initial_backoff: cdktf.numberToTerraform(struct!.initialBackoff),
    max_backoff: cdktf.numberToTerraform(struct!.maxBackoff),
  }
}


export function packDestinationOutputAzureDataExplorerResponseRetrySettingsToHclTerraform(struct?: PackDestinationOutputAzureDataExplorerResponseRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    backoff_rate: {
      value: cdktf.numberToHclTerraform(struct!.backoffRate),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    http_status: {
      value: cdktf.numberToHclTerraform(struct!.httpStatus),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    initial_backoff: {
      value: cdktf.numberToHclTerraform(struct!.initialBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_backoff: {
      value: cdktf.numberToHclTerraform(struct!.maxBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputAzureDataExplorerResponseRetrySettingsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackDestinationOutputAzureDataExplorerResponseRetrySettings | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._backoffRate !== undefined) {
      hasAnyValues = true;
      internalValueResult.backoffRate = this._backoffRate;
    }
    if (this._httpStatus !== undefined) {
      hasAnyValues = true;
      internalValueResult.httpStatus = this._httpStatus;
    }
    if (this._initialBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.initialBackoff = this._initialBackoff;
    }
    if (this._maxBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBackoff = this._maxBackoff;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputAzureDataExplorerResponseRetrySettings | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._backoffRate = undefined;
      this._httpStatus = undefined;
      this._initialBackoff = undefined;
      this._maxBackoff = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._backoffRate = value.backoffRate;
      this._httpStatus = value.httpStatus;
      this._initialBackoff = value.initialBackoff;
      this._maxBackoff = value.maxBackoff;
    }
  }

  // backoff_rate - computed: true, optional: true, required: false
  private _backoffRate?: number; 
  public get backoffRate() {
    return this.getNumberAttribute('backoff_rate');
  }
  public set backoffRate(value: number) {
    this._backoffRate = value;
  }
  public resetBackoffRate() {
    this._backoffRate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get backoffRateInput() {
    return this._backoffRate;
  }

  // http_status - computed: false, optional: false, required: true
  private _httpStatus?: number; 
  public get httpStatus() {
    return this.getNumberAttribute('http_status');
  }
  public set httpStatus(value: number) {
    this._httpStatus = value;
  }
  // Temporarily expose input value. Use with caution.
  public get httpStatusInput() {
    return this._httpStatus;
  }

  // initial_backoff - computed: true, optional: true, required: false
  private _initialBackoff?: number; 
  public get initialBackoff() {
    return this.getNumberAttribute('initial_backoff');
  }
  public set initialBackoff(value: number) {
    this._initialBackoff = value;
  }
  public resetInitialBackoff() {
    this._initialBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get initialBackoffInput() {
    return this._initialBackoff;
  }

  // max_backoff - computed: true, optional: true, required: false
  private _maxBackoff?: number; 
  public get maxBackoff() {
    return this.getNumberAttribute('max_backoff');
  }
  public set maxBackoff(value: number) {
    this._maxBackoff = value;
  }
  public resetMaxBackoff() {
    this._maxBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBackoffInput() {
    return this._maxBackoff;
  }
}

export class PackDestinationOutputAzureDataExplorerResponseRetrySettingsList extends cdktf.ComplexList {
  public internalValue? : PackDestinationOutputAzureDataExplorerResponseRetrySettings[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackDestinationOutputAzureDataExplorerResponseRetrySettingsOutputReference {
    return new PackDestinationOutputAzureDataExplorerResponseRetrySettingsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackDestinationOutputAzureDataExplorerTimeoutRetrySettings {
  /**
  * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc. Default: 2
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#backoff_rate PackDestination#backoff_rate}
  */
  readonly backoffRate?: number;
  /**
  * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes). Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#initial_backoff PackDestination#initial_backoff}
  */
  readonly initialBackoff?: number;
  /**
  * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds). Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_backoff PackDestination#max_backoff}
  */
  readonly maxBackoff?: number;
  /**
  * Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#timeout_retry PackDestination#timeout_retry}
  */
  readonly timeoutRetry?: boolean | cdktf.IResolvable;
}

export function packDestinationOutputAzureDataExplorerTimeoutRetrySettingsToTerraform(struct?: PackDestinationOutputAzureDataExplorerTimeoutRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    backoff_rate: cdktf.numberToTerraform(struct!.backoffRate),
    initial_backoff: cdktf.numberToTerraform(struct!.initialBackoff),
    max_backoff: cdktf.numberToTerraform(struct!.maxBackoff),
    timeout_retry: cdktf.booleanToTerraform(struct!.timeoutRetry),
  }
}


export function packDestinationOutputAzureDataExplorerTimeoutRetrySettingsToHclTerraform(struct?: PackDestinationOutputAzureDataExplorerTimeoutRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    backoff_rate: {
      value: cdktf.numberToHclTerraform(struct!.backoffRate),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    initial_backoff: {
      value: cdktf.numberToHclTerraform(struct!.initialBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_backoff: {
      value: cdktf.numberToHclTerraform(struct!.maxBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    timeout_retry: {
      value: cdktf.booleanToHclTerraform(struct!.timeoutRetry),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputAzureDataExplorerTimeoutRetrySettingsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackDestinationOutputAzureDataExplorerTimeoutRetrySettings | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._backoffRate !== undefined) {
      hasAnyValues = true;
      internalValueResult.backoffRate = this._backoffRate;
    }
    if (this._initialBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.initialBackoff = this._initialBackoff;
    }
    if (this._maxBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBackoff = this._maxBackoff;
    }
    if (this._timeoutRetry !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutRetry = this._timeoutRetry;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputAzureDataExplorerTimeoutRetrySettings | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._backoffRate = undefined;
      this._initialBackoff = undefined;
      this._maxBackoff = undefined;
      this._timeoutRetry = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._backoffRate = value.backoffRate;
      this._initialBackoff = value.initialBackoff;
      this._maxBackoff = value.maxBackoff;
      this._timeoutRetry = value.timeoutRetry;
    }
  }

  // backoff_rate - computed: true, optional: true, required: false
  private _backoffRate?: number; 
  public get backoffRate() {
    return this.getNumberAttribute('backoff_rate');
  }
  public set backoffRate(value: number) {
    this._backoffRate = value;
  }
  public resetBackoffRate() {
    this._backoffRate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get backoffRateInput() {
    return this._backoffRate;
  }

  // initial_backoff - computed: true, optional: true, required: false
  private _initialBackoff?: number; 
  public get initialBackoff() {
    return this.getNumberAttribute('initial_backoff');
  }
  public set initialBackoff(value: number) {
    this._initialBackoff = value;
  }
  public resetInitialBackoff() {
    this._initialBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get initialBackoffInput() {
    return this._initialBackoff;
  }

  // max_backoff - computed: true, optional: true, required: false
  private _maxBackoff?: number; 
  public get maxBackoff() {
    return this.getNumberAttribute('max_backoff');
  }
  public set maxBackoff(value: number) {
    this._maxBackoff = value;
  }
  public resetMaxBackoff() {
    this._maxBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBackoffInput() {
    return this._maxBackoff;
  }

  // timeout_retry - computed: true, optional: true, required: false
  private _timeoutRetry?: boolean | cdktf.IResolvable; 
  public get timeoutRetry() {
    return this.getBooleanAttribute('timeout_retry');
  }
  public set timeoutRetry(value: boolean | cdktf.IResolvable) {
    this._timeoutRetry = value;
  }
  public resetTimeoutRetry() {
    this._timeoutRetry = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutRetryInput() {
    return this._timeoutRetry;
  }
}
export interface PackDestinationOutputAzureDataExplorer {
  /**
  * Add the Output ID value to staging location. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#add_id_to_stage_path PackDestination#add_id_to_stage_path}
  */
  readonly addIdToStagePath?: boolean | cdktf.IResolvable;
  /**
  * Optionally, enter additional configuration properties to send to the ingestion service
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#additional_properties PackDestination#additional_properties}
  */
  readonly additionalProperties?: PackDestinationOutputAzureDataExplorerAdditionalProperties[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#certificate PackDestination#certificate}
  */
  readonly certificate?: PackDestinationOutputAzureDataExplorerCertificate;
  /**
  * client_id to pass in the OAuth request parameter
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#client_id PackDestination#client_id}
  */
  readonly clientId: string;
  /**
  * The client secret that you generated for your app in the Azure portal
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#client_secret PackDestination#client_secret}
  */
  readonly clientSecret?: string;
  /**
  * The base URI for your cluster. Typically, `https://<cluster>.<region>.kusto.windows.net`.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#cluster_url PackDestination#cluster_url}
  */
  readonly clusterUrl: string;
  /**
  * Data compression format to apply to HTTP content before it is delivered. Default: "gzip"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#compress PackDestination#compress}
  */
  readonly compress?: string;
  /**
  * Maximum number of ongoing requests before blocking. Default: 5
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#concurrency PackDestination#concurrency}
  */
  readonly concurrency?: number;
  /**
  * Name of the database containing the table where data will be ingested
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#database PackDestination#database}
  */
  readonly database: string;
  /**
  * If a file fails to move to its final destination after the maximum number of retries, move it to a designated directory to prevent further errors. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#deadletter_enabled PackDestination#deadletter_enabled}
  */
  readonly deadletterEnabled?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#description PackDestination#description}
  */
  readonly description?: string;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#environment PackDestination#environment}
  */
  readonly environment?: string;
  /**
  * Strings or tags associated with the extent (ingested data shard)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#extent_tags PackDestination#extent_tags}
  */
  readonly extentTags?: PackDestinationOutputAzureDataExplorerExtentTags[] | cdktf.IResolvable;
  /**
  * JavaScript expression to define the output filename suffix (can be constant).  The `__format` variable refers to the value of the `Data format` field (`json` or `raw`).  The `__compression` field refers to the kind of compression being used (`none` or `gzip`). Default: "`.${C.env[\"CRIBL_WORKER_ID\"]}.${__format}${__compression === \"gzip\" ? \".gz\" : \"\"}`"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#file_name_suffix PackDestination#file_name_suffix}
  */
  readonly fileNameSuffix?: string;
  /**
  * Bypass the data management service's aggregation mechanism. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#flush_immediately PackDestination#flush_immediately}
  */
  readonly flushImmediately?: boolean | cdktf.IResolvable;
  /**
  * Maximum time between requests. Small values could cause the payload size to be smaller than the configured Body size limit. Default: 1
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#flush_period_sec PackDestination#flush_period_sec}
  */
  readonly flushPeriodSec?: number;
  /**
  * Format of the output data. Default: "json"; must be one of ["json", "raw", "parquet"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#format PackDestination#format}
  */
  readonly format?: string;
  /**
  * Unique ID for this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#id PackDestination#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * Prevents duplicate ingestion by verifying whether an extent with the specified ingest-by tag already exists
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#ingest_if_not_exists PackDestination#ingest_if_not_exists}
  */
  readonly ingestIfNotExists?: PackDestinationOutputAzureDataExplorerIngestIfNotExists[] | cdktf.IResolvable;
  /**
  * Default: "batching"; must be one of ["batching", "streaming"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#ingest_mode PackDestination#ingest_mode}
  */
  readonly ingestMode?: string;
  /**
  * The ingestion service URI for your cluster. Typically, `https://ingest-<cluster>.<region>.kusto.windows.net`.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#ingest_url PackDestination#ingest_url}
  */
  readonly ingestUrl?: string;
  /**
  * Send a JSON mapping object instead of specifying an existing named data mapping. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#is_mapping_obj PackDestination#is_mapping_obj}
  */
  readonly isMappingObj?: boolean | cdktf.IResolvable;
  /**
  * Disable to close the connection immediately after sending the outgoing request. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#keep_alive PackDestination#keep_alive}
  */
  readonly keepAlive?: boolean | cdktf.IResolvable;
  /**
  * Enter the name of a data mapping associated with your target table. Or, if incoming event and target table fields match exactly, you can leave the field empty.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#mapping_ref PackDestination#mapping_ref}
  */
  readonly mappingRef?: string;
  /**
  * Maximum number of parts to upload in parallel per file. Default: 1
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_concurrent_file_parts PackDestination#max_concurrent_file_parts}
  */
  readonly maxConcurrentFileParts?: number;
  /**
  * Maximum amount of time to keep inactive files open. Files open for longer than this will be closed and moved to final output location. Default: 30
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_file_idle_time_sec PackDestination#max_file_idle_time_sec}
  */
  readonly maxFileIdleTimeSec?: number;
  /**
  * Maximum amount of time to write to a file. Files open for longer than this will be closed and moved to final output location. Default: 300
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_file_open_time_sec PackDestination#max_file_open_time_sec}
  */
  readonly maxFileOpenTimeSec?: number;
  /**
  * Maximum uncompressed output file size. Files of this size will be closed and moved to final output location. Default: 32
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_file_size_mb PackDestination#max_file_size_mb}
  */
  readonly maxFileSizeMb?: number;
  /**
  * Maximum number of files to keep open concurrently. When exceeded, @{product} will close the oldest open files and move them to the final output location. Default: 100
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_open_files PackDestination#max_open_files}
  */
  readonly maxOpenFiles?: number;
  /**
  * Maximum number of events to include in the request body. Default is 0 (unlimited). Default: 0
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_payload_events PackDestination#max_payload_events}
  */
  readonly maxPayloadEvents?: number;
  /**
  * Maximum size, in KB, of the request body. Default: 4096
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_payload_size_kb PackDestination#max_payload_size_kb}
  */
  readonly maxPayloadSizeKb?: number;
  /**
  * Endpoint used to acquire authentication tokens from Azure. Default: "https://login.microsoftonline.com"; must be one of ["https://login.microsoftonline.com", "https://login.microsoftonline.us", "https://login.partner.microsoftonline.cn"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#oauth_endpoint PackDestination#oauth_endpoint}
  */
  readonly oauthEndpoint?: string;
  /**
  * The type of OAuth 2.0 client credentials grant flow to use. Default: "clientSecret"; must be one of ["clientSecret", "clientTextSecret", "certificate"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#oauth_type PackDestination#oauth_type}
  */
  readonly oauthType?: string;
  /**
  * How to handle events when all receivers are exerting backpressure. Default: "block"; must be one of ["block", "drop", "queue"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#on_backpressure PackDestination#on_backpressure}
  */
  readonly onBackpressure?: string;
  /**
  * How to handle events when disk space is below the global 'Min free disk space' limit. Default: "block"; must be one of ["block", "drop"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#on_disk_full_backpressure PackDestination#on_disk_full_backpressure}
  */
  readonly onDiskFullBackpressure?: string;
  /**
  * Pipeline to process data before sending out to this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pipeline PackDestination#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_compress PackDestination#pq_compress}
  */
  readonly pqCompress?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_controls PackDestination#pq_controls}
  */
  readonly pqControls?: PackDestinationOutputAzureDataExplorerPqControls;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.). Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_max_file_size PackDestination#pq_max_file_size}
  */
  readonly pqMaxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_max_size PackDestination#pq_max_size}
  */
  readonly pqMaxSize?: string;
  /**
  * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem. Default: "error"; must be one of ["error", "backpressure", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_mode PackDestination#pq_mode}
  */
  readonly pqMode?: string;
  /**
  * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged. Default: "block"; must be one of ["block", "drop"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_on_backpressure PackDestination#pq_on_backpressure}
  */
  readonly pqOnBackpressure?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_path PackDestination#pq_path}
  */
  readonly pqPath?: string;
  /**
  * Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's).
  * 
  * 
  *         Enabled by default. When this setting is also present in TLS Settings (Client Side),
  *         that value will take precedence.
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#reject_unauthorized PackDestination#reject_unauthorized}
  */
  readonly rejectUnauthorized?: boolean | cdktf.IResolvable;
  /**
  * Remove empty staging directories after moving files. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#remove_empty_dirs PackDestination#remove_empty_dirs}
  */
  readonly removeEmptyDirs?: boolean | cdktf.IResolvable;
  /**
  * Level of ingestion status reporting. Defaults to FailuresOnly. Default: "failuresOnly"; must be one of ["failuresOnly", "doNotReport", "failuresAndSuccesses"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#report_level PackDestination#report_level}
  */
  readonly reportLevel?: string;
  /**
  * Target of the ingestion status reporting. Defaults to Queue. Default: "queue"; must be one of ["queue", "table", "queueAndTable"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#report_method PackDestination#report_method}
  */
  readonly reportMethod?: string;
  /**
  * Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#response_honor_retry_after_header PackDestination#response_honor_retry_after_header}
  */
  readonly responseHonorRetryAfterHeader?: boolean | cdktf.IResolvable;
  /**
  * Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#response_retry_settings PackDestination#response_retry_settings}
  */
  readonly responseRetrySettings?: PackDestinationOutputAzureDataExplorerResponseRetrySettings[] | cdktf.IResolvable;
  /**
  * Prevent blob deletion after ingestion is complete. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#retain_blob_on_success PackDestination#retain_blob_on_success}
  */
  readonly retainBlobOnSuccess?: boolean | cdktf.IResolvable;
  /**
  * Scope to pass in the OAuth request parameter
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#scope PackDestination#scope}
  */
  readonly scope: string;
  /**
  * Filesystem location in which to buffer files before compressing and moving to final destination. Use performant and stable storage. Default: "$CRIBL_HOME/state/outputs/staging"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#stage_path PackDestination#stage_path}
  */
  readonly stagePath?: string;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#streamtags PackDestination#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Fields to automatically add to events, such as cribl_pipe. Supports wildcards. Default: ["cribl_pipe"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#system_fields PackDestination#system_fields}
  */
  readonly systemFields?: string[];
  /**
  * Name of the table to ingest data into
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#table PackDestination#table}
  */
  readonly table: string;
  /**
  * Directory ID (tenant identifier) in Azure Active Directory
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#tenant_id PackDestination#tenant_id}
  */
  readonly tenantId: string;
  /**
  * Select or create a stored text secret
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#text_secret PackDestination#text_secret}
  */
  readonly textSecret?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#timeout_retry_settings PackDestination#timeout_retry_settings}
  */
  readonly timeoutRetrySettings?: PackDestinationOutputAzureDataExplorerTimeoutRetrySettings;
  /**
  * Amount of time, in seconds, to wait for a request to complete before canceling it. Default: 30
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#timeout_sec PackDestination#timeout_sec}
  */
  readonly timeoutSec?: number;
  /**
  * must be "azure_data_explorer"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#type PackDestination#type}
  */
  readonly type?: string;
  /**
  * Enable round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. For optimal performance, consider enabling this setting for non-load balanced destinations. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#use_round_robin_dns PackDestination#use_round_robin_dns}
  */
  readonly useRoundRobinDns?: boolean | cdktf.IResolvable;
  /**
  * When saving or starting the Destination, validate the database name and credentials; also validate table name, except when creating a new table. Disable if your Azure app does not have both the Database Viewer and the Table Viewer role. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#validate_database_settings PackDestination#validate_database_settings}
  */
  readonly validateDatabaseSettings?: boolean | cdktf.IResolvable;
}

export function packDestinationOutputAzureDataExplorerToTerraform(struct?: PackDestinationOutputAzureDataExplorer | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    add_id_to_stage_path: cdktf.booleanToTerraform(struct!.addIdToStagePath),
    additional_properties: cdktf.listMapper(packDestinationOutputAzureDataExplorerAdditionalPropertiesToTerraform, false)(struct!.additionalProperties),
    certificate: packDestinationOutputAzureDataExplorerCertificateToTerraform(struct!.certificate),
    client_id: cdktf.stringToTerraform(struct!.clientId),
    client_secret: cdktf.stringToTerraform(struct!.clientSecret),
    cluster_url: cdktf.stringToTerraform(struct!.clusterUrl),
    compress: cdktf.stringToTerraform(struct!.compress),
    concurrency: cdktf.numberToTerraform(struct!.concurrency),
    database: cdktf.stringToTerraform(struct!.database),
    deadletter_enabled: cdktf.booleanToTerraform(struct!.deadletterEnabled),
    description: cdktf.stringToTerraform(struct!.description),
    environment: cdktf.stringToTerraform(struct!.environment),
    extent_tags: cdktf.listMapper(packDestinationOutputAzureDataExplorerExtentTagsToTerraform, false)(struct!.extentTags),
    file_name_suffix: cdktf.stringToTerraform(struct!.fileNameSuffix),
    flush_immediately: cdktf.booleanToTerraform(struct!.flushImmediately),
    flush_period_sec: cdktf.numberToTerraform(struct!.flushPeriodSec),
    format: cdktf.stringToTerraform(struct!.format),
    id: cdktf.stringToTerraform(struct!.id),
    ingest_if_not_exists: cdktf.listMapper(packDestinationOutputAzureDataExplorerIngestIfNotExistsToTerraform, false)(struct!.ingestIfNotExists),
    ingest_mode: cdktf.stringToTerraform(struct!.ingestMode),
    ingest_url: cdktf.stringToTerraform(struct!.ingestUrl),
    is_mapping_obj: cdktf.booleanToTerraform(struct!.isMappingObj),
    keep_alive: cdktf.booleanToTerraform(struct!.keepAlive),
    mapping_ref: cdktf.stringToTerraform(struct!.mappingRef),
    max_concurrent_file_parts: cdktf.numberToTerraform(struct!.maxConcurrentFileParts),
    max_file_idle_time_sec: cdktf.numberToTerraform(struct!.maxFileIdleTimeSec),
    max_file_open_time_sec: cdktf.numberToTerraform(struct!.maxFileOpenTimeSec),
    max_file_size_mb: cdktf.numberToTerraform(struct!.maxFileSizeMb),
    max_open_files: cdktf.numberToTerraform(struct!.maxOpenFiles),
    max_payload_events: cdktf.numberToTerraform(struct!.maxPayloadEvents),
    max_payload_size_kb: cdktf.numberToTerraform(struct!.maxPayloadSizeKb),
    oauth_endpoint: cdktf.stringToTerraform(struct!.oauthEndpoint),
    oauth_type: cdktf.stringToTerraform(struct!.oauthType),
    on_backpressure: cdktf.stringToTerraform(struct!.onBackpressure),
    on_disk_full_backpressure: cdktf.stringToTerraform(struct!.onDiskFullBackpressure),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    pq_compress: cdktf.stringToTerraform(struct!.pqCompress),
    pq_controls: packDestinationOutputAzureDataExplorerPqControlsToTerraform(struct!.pqControls),
    pq_max_file_size: cdktf.stringToTerraform(struct!.pqMaxFileSize),
    pq_max_size: cdktf.stringToTerraform(struct!.pqMaxSize),
    pq_mode: cdktf.stringToTerraform(struct!.pqMode),
    pq_on_backpressure: cdktf.stringToTerraform(struct!.pqOnBackpressure),
    pq_path: cdktf.stringToTerraform(struct!.pqPath),
    reject_unauthorized: cdktf.booleanToTerraform(struct!.rejectUnauthorized),
    remove_empty_dirs: cdktf.booleanToTerraform(struct!.removeEmptyDirs),
    report_level: cdktf.stringToTerraform(struct!.reportLevel),
    report_method: cdktf.stringToTerraform(struct!.reportMethod),
    response_honor_retry_after_header: cdktf.booleanToTerraform(struct!.responseHonorRetryAfterHeader),
    response_retry_settings: cdktf.listMapper(packDestinationOutputAzureDataExplorerResponseRetrySettingsToTerraform, false)(struct!.responseRetrySettings),
    retain_blob_on_success: cdktf.booleanToTerraform(struct!.retainBlobOnSuccess),
    scope: cdktf.stringToTerraform(struct!.scope),
    stage_path: cdktf.stringToTerraform(struct!.stagePath),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    system_fields: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.systemFields),
    table: cdktf.stringToTerraform(struct!.table),
    tenant_id: cdktf.stringToTerraform(struct!.tenantId),
    text_secret: cdktf.stringToTerraform(struct!.textSecret),
    timeout_retry_settings: packDestinationOutputAzureDataExplorerTimeoutRetrySettingsToTerraform(struct!.timeoutRetrySettings),
    timeout_sec: cdktf.numberToTerraform(struct!.timeoutSec),
    type: cdktf.stringToTerraform(struct!.type),
    use_round_robin_dns: cdktf.booleanToTerraform(struct!.useRoundRobinDns),
    validate_database_settings: cdktf.booleanToTerraform(struct!.validateDatabaseSettings),
  }
}


export function packDestinationOutputAzureDataExplorerToHclTerraform(struct?: PackDestinationOutputAzureDataExplorer | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    add_id_to_stage_path: {
      value: cdktf.booleanToHclTerraform(struct!.addIdToStagePath),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    additional_properties: {
      value: cdktf.listMapperHcl(packDestinationOutputAzureDataExplorerAdditionalPropertiesToHclTerraform, false)(struct!.additionalProperties),
      isBlock: true,
      type: "list",
      storageClassType: "PackDestinationOutputAzureDataExplorerAdditionalPropertiesList",
    },
    certificate: {
      value: packDestinationOutputAzureDataExplorerCertificateToHclTerraform(struct!.certificate),
      isBlock: true,
      type: "struct",
      storageClassType: "PackDestinationOutputAzureDataExplorerCertificate",
    },
    client_id: {
      value: cdktf.stringToHclTerraform(struct!.clientId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    client_secret: {
      value: cdktf.stringToHclTerraform(struct!.clientSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    cluster_url: {
      value: cdktf.stringToHclTerraform(struct!.clusterUrl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    compress: {
      value: cdktf.stringToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    concurrency: {
      value: cdktf.numberToHclTerraform(struct!.concurrency),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    database: {
      value: cdktf.stringToHclTerraform(struct!.database),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    deadletter_enabled: {
      value: cdktf.booleanToHclTerraform(struct!.deadletterEnabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    extent_tags: {
      value: cdktf.listMapperHcl(packDestinationOutputAzureDataExplorerExtentTagsToHclTerraform, false)(struct!.extentTags),
      isBlock: true,
      type: "list",
      storageClassType: "PackDestinationOutputAzureDataExplorerExtentTagsList",
    },
    file_name_suffix: {
      value: cdktf.stringToHclTerraform(struct!.fileNameSuffix),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    flush_immediately: {
      value: cdktf.booleanToHclTerraform(struct!.flushImmediately),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    flush_period_sec: {
      value: cdktf.numberToHclTerraform(struct!.flushPeriodSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    format: {
      value: cdktf.stringToHclTerraform(struct!.format),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ingest_if_not_exists: {
      value: cdktf.listMapperHcl(packDestinationOutputAzureDataExplorerIngestIfNotExistsToHclTerraform, false)(struct!.ingestIfNotExists),
      isBlock: true,
      type: "list",
      storageClassType: "PackDestinationOutputAzureDataExplorerIngestIfNotExistsList",
    },
    ingest_mode: {
      value: cdktf.stringToHclTerraform(struct!.ingestMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ingest_url: {
      value: cdktf.stringToHclTerraform(struct!.ingestUrl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    is_mapping_obj: {
      value: cdktf.booleanToHclTerraform(struct!.isMappingObj),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    keep_alive: {
      value: cdktf.booleanToHclTerraform(struct!.keepAlive),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    mapping_ref: {
      value: cdktf.stringToHclTerraform(struct!.mappingRef),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_concurrent_file_parts: {
      value: cdktf.numberToHclTerraform(struct!.maxConcurrentFileParts),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_file_idle_time_sec: {
      value: cdktf.numberToHclTerraform(struct!.maxFileIdleTimeSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_file_open_time_sec: {
      value: cdktf.numberToHclTerraform(struct!.maxFileOpenTimeSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_file_size_mb: {
      value: cdktf.numberToHclTerraform(struct!.maxFileSizeMb),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_open_files: {
      value: cdktf.numberToHclTerraform(struct!.maxOpenFiles),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_payload_events: {
      value: cdktf.numberToHclTerraform(struct!.maxPayloadEvents),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_payload_size_kb: {
      value: cdktf.numberToHclTerraform(struct!.maxPayloadSizeKb),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    oauth_endpoint: {
      value: cdktf.stringToHclTerraform(struct!.oauthEndpoint),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    oauth_type: {
      value: cdktf.stringToHclTerraform(struct!.oauthType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.onBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    on_disk_full_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.onDiskFullBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_compress: {
      value: cdktf.stringToHclTerraform(struct!.pqCompress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_controls: {
      value: packDestinationOutputAzureDataExplorerPqControlsToHclTerraform(struct!.pqControls),
      isBlock: true,
      type: "struct",
      storageClassType: "PackDestinationOutputAzureDataExplorerPqControls",
    },
    pq_max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_max_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_mode: {
      value: cdktf.stringToHclTerraform(struct!.pqMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.pqOnBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_path: {
      value: cdktf.stringToHclTerraform(struct!.pqPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reject_unauthorized: {
      value: cdktf.booleanToHclTerraform(struct!.rejectUnauthorized),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    remove_empty_dirs: {
      value: cdktf.booleanToHclTerraform(struct!.removeEmptyDirs),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    report_level: {
      value: cdktf.stringToHclTerraform(struct!.reportLevel),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    report_method: {
      value: cdktf.stringToHclTerraform(struct!.reportMethod),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    response_honor_retry_after_header: {
      value: cdktf.booleanToHclTerraform(struct!.responseHonorRetryAfterHeader),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    response_retry_settings: {
      value: cdktf.listMapperHcl(packDestinationOutputAzureDataExplorerResponseRetrySettingsToHclTerraform, false)(struct!.responseRetrySettings),
      isBlock: true,
      type: "list",
      storageClassType: "PackDestinationOutputAzureDataExplorerResponseRetrySettingsList",
    },
    retain_blob_on_success: {
      value: cdktf.booleanToHclTerraform(struct!.retainBlobOnSuccess),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    scope: {
      value: cdktf.stringToHclTerraform(struct!.scope),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    stage_path: {
      value: cdktf.stringToHclTerraform(struct!.stagePath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    system_fields: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.systemFields),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    table: {
      value: cdktf.stringToHclTerraform(struct!.table),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tenant_id: {
      value: cdktf.stringToHclTerraform(struct!.tenantId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    text_secret: {
      value: cdktf.stringToHclTerraform(struct!.textSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    timeout_retry_settings: {
      value: packDestinationOutputAzureDataExplorerTimeoutRetrySettingsToHclTerraform(struct!.timeoutRetrySettings),
      isBlock: true,
      type: "struct",
      storageClassType: "PackDestinationOutputAzureDataExplorerTimeoutRetrySettings",
    },
    timeout_sec: {
      value: cdktf.numberToHclTerraform(struct!.timeoutSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    use_round_robin_dns: {
      value: cdktf.booleanToHclTerraform(struct!.useRoundRobinDns),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    validate_database_settings: {
      value: cdktf.booleanToHclTerraform(struct!.validateDatabaseSettings),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputAzureDataExplorerOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackDestinationOutputAzureDataExplorer | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._addIdToStagePath !== undefined) {
      hasAnyValues = true;
      internalValueResult.addIdToStagePath = this._addIdToStagePath;
    }
    if (this._additionalProperties?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.additionalProperties = this._additionalProperties?.internalValue;
    }
    if (this._certificate?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.certificate = this._certificate?.internalValue;
    }
    if (this._clientId !== undefined) {
      hasAnyValues = true;
      internalValueResult.clientId = this._clientId;
    }
    if (this._clientSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.clientSecret = this._clientSecret;
    }
    if (this._clusterUrl !== undefined) {
      hasAnyValues = true;
      internalValueResult.clusterUrl = this._clusterUrl;
    }
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._concurrency !== undefined) {
      hasAnyValues = true;
      internalValueResult.concurrency = this._concurrency;
    }
    if (this._database !== undefined) {
      hasAnyValues = true;
      internalValueResult.database = this._database;
    }
    if (this._deadletterEnabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.deadletterEnabled = this._deadletterEnabled;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._extentTags?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.extentTags = this._extentTags?.internalValue;
    }
    if (this._fileNameSuffix !== undefined) {
      hasAnyValues = true;
      internalValueResult.fileNameSuffix = this._fileNameSuffix;
    }
    if (this._flushImmediately !== undefined) {
      hasAnyValues = true;
      internalValueResult.flushImmediately = this._flushImmediately;
    }
    if (this._flushPeriodSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.flushPeriodSec = this._flushPeriodSec;
    }
    if (this._format !== undefined) {
      hasAnyValues = true;
      internalValueResult.format = this._format;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._ingestIfNotExists?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.ingestIfNotExists = this._ingestIfNotExists?.internalValue;
    }
    if (this._ingestMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.ingestMode = this._ingestMode;
    }
    if (this._ingestUrl !== undefined) {
      hasAnyValues = true;
      internalValueResult.ingestUrl = this._ingestUrl;
    }
    if (this._isMappingObj !== undefined) {
      hasAnyValues = true;
      internalValueResult.isMappingObj = this._isMappingObj;
    }
    if (this._keepAlive !== undefined) {
      hasAnyValues = true;
      internalValueResult.keepAlive = this._keepAlive;
    }
    if (this._mappingRef !== undefined) {
      hasAnyValues = true;
      internalValueResult.mappingRef = this._mappingRef;
    }
    if (this._maxConcurrentFileParts !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxConcurrentFileParts = this._maxConcurrentFileParts;
    }
    if (this._maxFileIdleTimeSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxFileIdleTimeSec = this._maxFileIdleTimeSec;
    }
    if (this._maxFileOpenTimeSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxFileOpenTimeSec = this._maxFileOpenTimeSec;
    }
    if (this._maxFileSizeMb !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxFileSizeMb = this._maxFileSizeMb;
    }
    if (this._maxOpenFiles !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxOpenFiles = this._maxOpenFiles;
    }
    if (this._maxPayloadEvents !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxPayloadEvents = this._maxPayloadEvents;
    }
    if (this._maxPayloadSizeKb !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxPayloadSizeKb = this._maxPayloadSizeKb;
    }
    if (this._oauthEndpoint !== undefined) {
      hasAnyValues = true;
      internalValueResult.oauthEndpoint = this._oauthEndpoint;
    }
    if (this._oauthType !== undefined) {
      hasAnyValues = true;
      internalValueResult.oauthType = this._oauthType;
    }
    if (this._onBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.onBackpressure = this._onBackpressure;
    }
    if (this._onDiskFullBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.onDiskFullBackpressure = this._onDiskFullBackpressure;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._pqCompress !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqCompress = this._pqCompress;
    }
    if (this._pqControls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqControls = this._pqControls?.internalValue;
    }
    if (this._pqMaxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxFileSize = this._pqMaxFileSize;
    }
    if (this._pqMaxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxSize = this._pqMaxSize;
    }
    if (this._pqMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMode = this._pqMode;
    }
    if (this._pqOnBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqOnBackpressure = this._pqOnBackpressure;
    }
    if (this._pqPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqPath = this._pqPath;
    }
    if (this._rejectUnauthorized !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectUnauthorized = this._rejectUnauthorized;
    }
    if (this._removeEmptyDirs !== undefined) {
      hasAnyValues = true;
      internalValueResult.removeEmptyDirs = this._removeEmptyDirs;
    }
    if (this._reportLevel !== undefined) {
      hasAnyValues = true;
      internalValueResult.reportLevel = this._reportLevel;
    }
    if (this._reportMethod !== undefined) {
      hasAnyValues = true;
      internalValueResult.reportMethod = this._reportMethod;
    }
    if (this._responseHonorRetryAfterHeader !== undefined) {
      hasAnyValues = true;
      internalValueResult.responseHonorRetryAfterHeader = this._responseHonorRetryAfterHeader;
    }
    if (this._responseRetrySettings?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.responseRetrySettings = this._responseRetrySettings?.internalValue;
    }
    if (this._retainBlobOnSuccess !== undefined) {
      hasAnyValues = true;
      internalValueResult.retainBlobOnSuccess = this._retainBlobOnSuccess;
    }
    if (this._scope !== undefined) {
      hasAnyValues = true;
      internalValueResult.scope = this._scope;
    }
    if (this._stagePath !== undefined) {
      hasAnyValues = true;
      internalValueResult.stagePath = this._stagePath;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._systemFields !== undefined) {
      hasAnyValues = true;
      internalValueResult.systemFields = this._systemFields;
    }
    if (this._table !== undefined) {
      hasAnyValues = true;
      internalValueResult.table = this._table;
    }
    if (this._tenantId !== undefined) {
      hasAnyValues = true;
      internalValueResult.tenantId = this._tenantId;
    }
    if (this._textSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.textSecret = this._textSecret;
    }
    if (this._timeoutRetrySettings?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutRetrySettings = this._timeoutRetrySettings?.internalValue;
    }
    if (this._timeoutSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutSec = this._timeoutSec;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._useRoundRobinDns !== undefined) {
      hasAnyValues = true;
      internalValueResult.useRoundRobinDns = this._useRoundRobinDns;
    }
    if (this._validateDatabaseSettings !== undefined) {
      hasAnyValues = true;
      internalValueResult.validateDatabaseSettings = this._validateDatabaseSettings;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputAzureDataExplorer | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._addIdToStagePath = undefined;
      this._additionalProperties.internalValue = undefined;
      this._certificate.internalValue = undefined;
      this._clientId = undefined;
      this._clientSecret = undefined;
      this._clusterUrl = undefined;
      this._compress = undefined;
      this._concurrency = undefined;
      this._database = undefined;
      this._deadletterEnabled = undefined;
      this._description = undefined;
      this._environment = undefined;
      this._extentTags.internalValue = undefined;
      this._fileNameSuffix = undefined;
      this._flushImmediately = undefined;
      this._flushPeriodSec = undefined;
      this._format = undefined;
      this._id = undefined;
      this._ingestIfNotExists.internalValue = undefined;
      this._ingestMode = undefined;
      this._ingestUrl = undefined;
      this._isMappingObj = undefined;
      this._keepAlive = undefined;
      this._mappingRef = undefined;
      this._maxConcurrentFileParts = undefined;
      this._maxFileIdleTimeSec = undefined;
      this._maxFileOpenTimeSec = undefined;
      this._maxFileSizeMb = undefined;
      this._maxOpenFiles = undefined;
      this._maxPayloadEvents = undefined;
      this._maxPayloadSizeKb = undefined;
      this._oauthEndpoint = undefined;
      this._oauthType = undefined;
      this._onBackpressure = undefined;
      this._onDiskFullBackpressure = undefined;
      this._pipeline = undefined;
      this._pqCompress = undefined;
      this._pqControls.internalValue = undefined;
      this._pqMaxFileSize = undefined;
      this._pqMaxSize = undefined;
      this._pqMode = undefined;
      this._pqOnBackpressure = undefined;
      this._pqPath = undefined;
      this._rejectUnauthorized = undefined;
      this._removeEmptyDirs = undefined;
      this._reportLevel = undefined;
      this._reportMethod = undefined;
      this._responseHonorRetryAfterHeader = undefined;
      this._responseRetrySettings.internalValue = undefined;
      this._retainBlobOnSuccess = undefined;
      this._scope = undefined;
      this._stagePath = undefined;
      this._streamtags = undefined;
      this._systemFields = undefined;
      this._table = undefined;
      this._tenantId = undefined;
      this._textSecret = undefined;
      this._timeoutRetrySettings.internalValue = undefined;
      this._timeoutSec = undefined;
      this._type = undefined;
      this._useRoundRobinDns = undefined;
      this._validateDatabaseSettings = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._addIdToStagePath = value.addIdToStagePath;
      this._additionalProperties.internalValue = value.additionalProperties;
      this._certificate.internalValue = value.certificate;
      this._clientId = value.clientId;
      this._clientSecret = value.clientSecret;
      this._clusterUrl = value.clusterUrl;
      this._compress = value.compress;
      this._concurrency = value.concurrency;
      this._database = value.database;
      this._deadletterEnabled = value.deadletterEnabled;
      this._description = value.description;
      this._environment = value.environment;
      this._extentTags.internalValue = value.extentTags;
      this._fileNameSuffix = value.fileNameSuffix;
      this._flushImmediately = value.flushImmediately;
      this._flushPeriodSec = value.flushPeriodSec;
      this._format = value.format;
      this._id = value.id;
      this._ingestIfNotExists.internalValue = value.ingestIfNotExists;
      this._ingestMode = value.ingestMode;
      this._ingestUrl = value.ingestUrl;
      this._isMappingObj = value.isMappingObj;
      this._keepAlive = value.keepAlive;
      this._mappingRef = value.mappingRef;
      this._maxConcurrentFileParts = value.maxConcurrentFileParts;
      this._maxFileIdleTimeSec = value.maxFileIdleTimeSec;
      this._maxFileOpenTimeSec = value.maxFileOpenTimeSec;
      this._maxFileSizeMb = value.maxFileSizeMb;
      this._maxOpenFiles = value.maxOpenFiles;
      this._maxPayloadEvents = value.maxPayloadEvents;
      this._maxPayloadSizeKb = value.maxPayloadSizeKb;
      this._oauthEndpoint = value.oauthEndpoint;
      this._oauthType = value.oauthType;
      this._onBackpressure = value.onBackpressure;
      this._onDiskFullBackpressure = value.onDiskFullBackpressure;
      this._pipeline = value.pipeline;
      this._pqCompress = value.pqCompress;
      this._pqControls.internalValue = value.pqControls;
      this._pqMaxFileSize = value.pqMaxFileSize;
      this._pqMaxSize = value.pqMaxSize;
      this._pqMode = value.pqMode;
      this._pqOnBackpressure = value.pqOnBackpressure;
      this._pqPath = value.pqPath;
      this._rejectUnauthorized = value.rejectUnauthorized;
      this._removeEmptyDirs = value.removeEmptyDirs;
      this._reportLevel = value.reportLevel;
      this._reportMethod = value.reportMethod;
      this._responseHonorRetryAfterHeader = value.responseHonorRetryAfterHeader;
      this._responseRetrySettings.internalValue = value.responseRetrySettings;
      this._retainBlobOnSuccess = value.retainBlobOnSuccess;
      this._scope = value.scope;
      this._stagePath = value.stagePath;
      this._streamtags = value.streamtags;
      this._systemFields = value.systemFields;
      this._table = value.table;
      this._tenantId = value.tenantId;
      this._textSecret = value.textSecret;
      this._timeoutRetrySettings.internalValue = value.timeoutRetrySettings;
      this._timeoutSec = value.timeoutSec;
      this._type = value.type;
      this._useRoundRobinDns = value.useRoundRobinDns;
      this._validateDatabaseSettings = value.validateDatabaseSettings;
    }
  }

  // add_id_to_stage_path - computed: true, optional: true, required: false
  private _addIdToStagePath?: boolean | cdktf.IResolvable; 
  public get addIdToStagePath() {
    return this.getBooleanAttribute('add_id_to_stage_path');
  }
  public set addIdToStagePath(value: boolean | cdktf.IResolvable) {
    this._addIdToStagePath = value;
  }
  public resetAddIdToStagePath() {
    this._addIdToStagePath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addIdToStagePathInput() {
    return this._addIdToStagePath;
  }

  // additional_properties - computed: false, optional: true, required: false
  private _additionalProperties = new PackDestinationOutputAzureDataExplorerAdditionalPropertiesList(this, "additional_properties", false);
  public get additionalProperties() {
    return this._additionalProperties;
  }
  public putAdditionalProperties(value: PackDestinationOutputAzureDataExplorerAdditionalProperties[] | cdktf.IResolvable) {
    this._additionalProperties.internalValue = value;
  }
  public resetAdditionalProperties() {
    this._additionalProperties.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get additionalPropertiesInput() {
    return this._additionalProperties.internalValue;
  }

  // certificate - computed: false, optional: true, required: false
  private _certificate = new PackDestinationOutputAzureDataExplorerCertificateOutputReference(this, "certificate");
  public get certificate() {
    return this._certificate;
  }
  public putCertificate(value: PackDestinationOutputAzureDataExplorerCertificate) {
    this._certificate.internalValue = value;
  }
  public resetCertificate() {
    this._certificate.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certificateInput() {
    return this._certificate.internalValue;
  }

  // client_id - computed: false, optional: false, required: true
  private _clientId?: string; 
  public get clientId() {
    return this.getStringAttribute('client_id');
  }
  public set clientId(value: string) {
    this._clientId = value;
  }
  // Temporarily expose input value. Use with caution.
  public get clientIdInput() {
    return this._clientId;
  }

  // client_secret - computed: false, optional: true, required: false
  private _clientSecret?: string; 
  public get clientSecret() {
    return this.getStringAttribute('client_secret');
  }
  public set clientSecret(value: string) {
    this._clientSecret = value;
  }
  public resetClientSecret() {
    this._clientSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clientSecretInput() {
    return this._clientSecret;
  }

  // cluster_url - computed: false, optional: false, required: true
  private _clusterUrl?: string; 
  public get clusterUrl() {
    return this.getStringAttribute('cluster_url');
  }
  public set clusterUrl(value: string) {
    this._clusterUrl = value;
  }
  // Temporarily expose input value. Use with caution.
  public get clusterUrlInput() {
    return this._clusterUrl;
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: string; 
  public get compress() {
    return this.getStringAttribute('compress');
  }
  public set compress(value: string) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // concurrency - computed: true, optional: true, required: false
  private _concurrency?: number; 
  public get concurrency() {
    return this.getNumberAttribute('concurrency');
  }
  public set concurrency(value: number) {
    this._concurrency = value;
  }
  public resetConcurrency() {
    this._concurrency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get concurrencyInput() {
    return this._concurrency;
  }

  // database - computed: false, optional: false, required: true
  private _database?: string; 
  public get database() {
    return this.getStringAttribute('database');
  }
  public set database(value: string) {
    this._database = value;
  }
  // Temporarily expose input value. Use with caution.
  public get databaseInput() {
    return this._database;
  }

  // deadletter_enabled - computed: true, optional: true, required: false
  private _deadletterEnabled?: boolean | cdktf.IResolvable; 
  public get deadletterEnabled() {
    return this.getBooleanAttribute('deadletter_enabled');
  }
  public set deadletterEnabled(value: boolean | cdktf.IResolvable) {
    this._deadletterEnabled = value;
  }
  public resetDeadletterEnabled() {
    this._deadletterEnabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get deadletterEnabledInput() {
    return this._deadletterEnabled;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // extent_tags - computed: false, optional: true, required: false
  private _extentTags = new PackDestinationOutputAzureDataExplorerExtentTagsList(this, "extent_tags", false);
  public get extentTags() {
    return this._extentTags;
  }
  public putExtentTags(value: PackDestinationOutputAzureDataExplorerExtentTags[] | cdktf.IResolvable) {
    this._extentTags.internalValue = value;
  }
  public resetExtentTags() {
    this._extentTags.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get extentTagsInput() {
    return this._extentTags.internalValue;
  }

  // file_name_suffix - computed: true, optional: true, required: false
  private _fileNameSuffix?: string; 
  public get fileNameSuffix() {
    return this.getStringAttribute('file_name_suffix');
  }
  public set fileNameSuffix(value: string) {
    this._fileNameSuffix = value;
  }
  public resetFileNameSuffix() {
    this._fileNameSuffix = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fileNameSuffixInput() {
    return this._fileNameSuffix;
  }

  // flush_immediately - computed: true, optional: true, required: false
  private _flushImmediately?: boolean | cdktf.IResolvable; 
  public get flushImmediately() {
    return this.getBooleanAttribute('flush_immediately');
  }
  public set flushImmediately(value: boolean | cdktf.IResolvable) {
    this._flushImmediately = value;
  }
  public resetFlushImmediately() {
    this._flushImmediately = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get flushImmediatelyInput() {
    return this._flushImmediately;
  }

  // flush_period_sec - computed: true, optional: true, required: false
  private _flushPeriodSec?: number; 
  public get flushPeriodSec() {
    return this.getNumberAttribute('flush_period_sec');
  }
  public set flushPeriodSec(value: number) {
    this._flushPeriodSec = value;
  }
  public resetFlushPeriodSec() {
    this._flushPeriodSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get flushPeriodSecInput() {
    return this._flushPeriodSec;
  }

  // format - computed: true, optional: true, required: false
  private _format?: string; 
  public get format() {
    return this.getStringAttribute('format');
  }
  public set format(value: string) {
    this._format = value;
  }
  public resetFormat() {
    this._format = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get formatInput() {
    return this._format;
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // ingest_if_not_exists - computed: false, optional: true, required: false
  private _ingestIfNotExists = new PackDestinationOutputAzureDataExplorerIngestIfNotExistsList(this, "ingest_if_not_exists", false);
  public get ingestIfNotExists() {
    return this._ingestIfNotExists;
  }
  public putIngestIfNotExists(value: PackDestinationOutputAzureDataExplorerIngestIfNotExists[] | cdktf.IResolvable) {
    this._ingestIfNotExists.internalValue = value;
  }
  public resetIngestIfNotExists() {
    this._ingestIfNotExists.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ingestIfNotExistsInput() {
    return this._ingestIfNotExists.internalValue;
  }

  // ingest_mode - computed: true, optional: true, required: false
  private _ingestMode?: string; 
  public get ingestMode() {
    return this.getStringAttribute('ingest_mode');
  }
  public set ingestMode(value: string) {
    this._ingestMode = value;
  }
  public resetIngestMode() {
    this._ingestMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ingestModeInput() {
    return this._ingestMode;
  }

  // ingest_url - computed: false, optional: true, required: false
  private _ingestUrl?: string; 
  public get ingestUrl() {
    return this.getStringAttribute('ingest_url');
  }
  public set ingestUrl(value: string) {
    this._ingestUrl = value;
  }
  public resetIngestUrl() {
    this._ingestUrl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ingestUrlInput() {
    return this._ingestUrl;
  }

  // is_mapping_obj - computed: true, optional: true, required: false
  private _isMappingObj?: boolean | cdktf.IResolvable; 
  public get isMappingObj() {
    return this.getBooleanAttribute('is_mapping_obj');
  }
  public set isMappingObj(value: boolean | cdktf.IResolvable) {
    this._isMappingObj = value;
  }
  public resetIsMappingObj() {
    this._isMappingObj = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get isMappingObjInput() {
    return this._isMappingObj;
  }

  // keep_alive - computed: true, optional: true, required: false
  private _keepAlive?: boolean | cdktf.IResolvable; 
  public get keepAlive() {
    return this.getBooleanAttribute('keep_alive');
  }
  public set keepAlive(value: boolean | cdktf.IResolvable) {
    this._keepAlive = value;
  }
  public resetKeepAlive() {
    this._keepAlive = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keepAliveInput() {
    return this._keepAlive;
  }

  // mapping_ref - computed: false, optional: true, required: false
  private _mappingRef?: string; 
  public get mappingRef() {
    return this.getStringAttribute('mapping_ref');
  }
  public set mappingRef(value: string) {
    this._mappingRef = value;
  }
  public resetMappingRef() {
    this._mappingRef = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get mappingRefInput() {
    return this._mappingRef;
  }

  // max_concurrent_file_parts - computed: true, optional: true, required: false
  private _maxConcurrentFileParts?: number; 
  public get maxConcurrentFileParts() {
    return this.getNumberAttribute('max_concurrent_file_parts');
  }
  public set maxConcurrentFileParts(value: number) {
    this._maxConcurrentFileParts = value;
  }
  public resetMaxConcurrentFileParts() {
    this._maxConcurrentFileParts = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxConcurrentFilePartsInput() {
    return this._maxConcurrentFileParts;
  }

  // max_file_idle_time_sec - computed: true, optional: true, required: false
  private _maxFileIdleTimeSec?: number; 
  public get maxFileIdleTimeSec() {
    return this.getNumberAttribute('max_file_idle_time_sec');
  }
  public set maxFileIdleTimeSec(value: number) {
    this._maxFileIdleTimeSec = value;
  }
  public resetMaxFileIdleTimeSec() {
    this._maxFileIdleTimeSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxFileIdleTimeSecInput() {
    return this._maxFileIdleTimeSec;
  }

  // max_file_open_time_sec - computed: true, optional: true, required: false
  private _maxFileOpenTimeSec?: number; 
  public get maxFileOpenTimeSec() {
    return this.getNumberAttribute('max_file_open_time_sec');
  }
  public set maxFileOpenTimeSec(value: number) {
    this._maxFileOpenTimeSec = value;
  }
  public resetMaxFileOpenTimeSec() {
    this._maxFileOpenTimeSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxFileOpenTimeSecInput() {
    return this._maxFileOpenTimeSec;
  }

  // max_file_size_mb - computed: true, optional: true, required: false
  private _maxFileSizeMb?: number; 
  public get maxFileSizeMb() {
    return this.getNumberAttribute('max_file_size_mb');
  }
  public set maxFileSizeMb(value: number) {
    this._maxFileSizeMb = value;
  }
  public resetMaxFileSizeMb() {
    this._maxFileSizeMb = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxFileSizeMbInput() {
    return this._maxFileSizeMb;
  }

  // max_open_files - computed: true, optional: true, required: false
  private _maxOpenFiles?: number; 
  public get maxOpenFiles() {
    return this.getNumberAttribute('max_open_files');
  }
  public set maxOpenFiles(value: number) {
    this._maxOpenFiles = value;
  }
  public resetMaxOpenFiles() {
    this._maxOpenFiles = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxOpenFilesInput() {
    return this._maxOpenFiles;
  }

  // max_payload_events - computed: true, optional: true, required: false
  private _maxPayloadEvents?: number; 
  public get maxPayloadEvents() {
    return this.getNumberAttribute('max_payload_events');
  }
  public set maxPayloadEvents(value: number) {
    this._maxPayloadEvents = value;
  }
  public resetMaxPayloadEvents() {
    this._maxPayloadEvents = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxPayloadEventsInput() {
    return this._maxPayloadEvents;
  }

  // max_payload_size_kb - computed: true, optional: true, required: false
  private _maxPayloadSizeKb?: number; 
  public get maxPayloadSizeKb() {
    return this.getNumberAttribute('max_payload_size_kb');
  }
  public set maxPayloadSizeKb(value: number) {
    this._maxPayloadSizeKb = value;
  }
  public resetMaxPayloadSizeKb() {
    this._maxPayloadSizeKb = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxPayloadSizeKbInput() {
    return this._maxPayloadSizeKb;
  }

  // oauth_endpoint - computed: true, optional: true, required: false
  private _oauthEndpoint?: string; 
  public get oauthEndpoint() {
    return this.getStringAttribute('oauth_endpoint');
  }
  public set oauthEndpoint(value: string) {
    this._oauthEndpoint = value;
  }
  public resetOauthEndpoint() {
    this._oauthEndpoint = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get oauthEndpointInput() {
    return this._oauthEndpoint;
  }

  // oauth_type - computed: true, optional: true, required: false
  private _oauthType?: string; 
  public get oauthType() {
    return this.getStringAttribute('oauth_type');
  }
  public set oauthType(value: string) {
    this._oauthType = value;
  }
  public resetOauthType() {
    this._oauthType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get oauthTypeInput() {
    return this._oauthType;
  }

  // on_backpressure - computed: true, optional: true, required: false
  private _onBackpressure?: string; 
  public get onBackpressure() {
    return this.getStringAttribute('on_backpressure');
  }
  public set onBackpressure(value: string) {
    this._onBackpressure = value;
  }
  public resetOnBackpressure() {
    this._onBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get onBackpressureInput() {
    return this._onBackpressure;
  }

  // on_disk_full_backpressure - computed: true, optional: true, required: false
  private _onDiskFullBackpressure?: string; 
  public get onDiskFullBackpressure() {
    return this.getStringAttribute('on_disk_full_backpressure');
  }
  public set onDiskFullBackpressure(value: string) {
    this._onDiskFullBackpressure = value;
  }
  public resetOnDiskFullBackpressure() {
    this._onDiskFullBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get onDiskFullBackpressureInput() {
    return this._onDiskFullBackpressure;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // pq_compress - computed: true, optional: true, required: false
  private _pqCompress?: string; 
  public get pqCompress() {
    return this.getStringAttribute('pq_compress');
  }
  public set pqCompress(value: string) {
    this._pqCompress = value;
  }
  public resetPqCompress() {
    this._pqCompress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqCompressInput() {
    return this._pqCompress;
  }

  // pq_controls - computed: false, optional: true, required: false
  private _pqControls = new PackDestinationOutputAzureDataExplorerPqControlsOutputReference(this, "pq_controls");
  public get pqControls() {
    return this._pqControls;
  }
  public putPqControls(value: PackDestinationOutputAzureDataExplorerPqControls) {
    this._pqControls.internalValue = value;
  }
  public resetPqControls() {
    this._pqControls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqControlsInput() {
    return this._pqControls.internalValue;
  }

  // pq_max_file_size - computed: true, optional: true, required: false
  private _pqMaxFileSize?: string; 
  public get pqMaxFileSize() {
    return this.getStringAttribute('pq_max_file_size');
  }
  public set pqMaxFileSize(value: string) {
    this._pqMaxFileSize = value;
  }
  public resetPqMaxFileSize() {
    this._pqMaxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxFileSizeInput() {
    return this._pqMaxFileSize;
  }

  // pq_max_size - computed: true, optional: true, required: false
  private _pqMaxSize?: string; 
  public get pqMaxSize() {
    return this.getStringAttribute('pq_max_size');
  }
  public set pqMaxSize(value: string) {
    this._pqMaxSize = value;
  }
  public resetPqMaxSize() {
    this._pqMaxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxSizeInput() {
    return this._pqMaxSize;
  }

  // pq_mode - computed: true, optional: true, required: false
  private _pqMode?: string; 
  public get pqMode() {
    return this.getStringAttribute('pq_mode');
  }
  public set pqMode(value: string) {
    this._pqMode = value;
  }
  public resetPqMode() {
    this._pqMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqModeInput() {
    return this._pqMode;
  }

  // pq_on_backpressure - computed: true, optional: true, required: false
  private _pqOnBackpressure?: string; 
  public get pqOnBackpressure() {
    return this.getStringAttribute('pq_on_backpressure');
  }
  public set pqOnBackpressure(value: string) {
    this._pqOnBackpressure = value;
  }
  public resetPqOnBackpressure() {
    this._pqOnBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqOnBackpressureInput() {
    return this._pqOnBackpressure;
  }

  // pq_path - computed: true, optional: true, required: false
  private _pqPath?: string; 
  public get pqPath() {
    return this.getStringAttribute('pq_path');
  }
  public set pqPath(value: string) {
    this._pqPath = value;
  }
  public resetPqPath() {
    this._pqPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqPathInput() {
    return this._pqPath;
  }

  // reject_unauthorized - computed: true, optional: true, required: false
  private _rejectUnauthorized?: boolean | cdktf.IResolvable; 
  public get rejectUnauthorized() {
    return this.getBooleanAttribute('reject_unauthorized');
  }
  public set rejectUnauthorized(value: boolean | cdktf.IResolvable) {
    this._rejectUnauthorized = value;
  }
  public resetRejectUnauthorized() {
    this._rejectUnauthorized = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectUnauthorizedInput() {
    return this._rejectUnauthorized;
  }

  // remove_empty_dirs - computed: true, optional: true, required: false
  private _removeEmptyDirs?: boolean | cdktf.IResolvable; 
  public get removeEmptyDirs() {
    return this.getBooleanAttribute('remove_empty_dirs');
  }
  public set removeEmptyDirs(value: boolean | cdktf.IResolvable) {
    this._removeEmptyDirs = value;
  }
  public resetRemoveEmptyDirs() {
    this._removeEmptyDirs = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get removeEmptyDirsInput() {
    return this._removeEmptyDirs;
  }

  // report_level - computed: true, optional: true, required: false
  private _reportLevel?: string; 
  public get reportLevel() {
    return this.getStringAttribute('report_level');
  }
  public set reportLevel(value: string) {
    this._reportLevel = value;
  }
  public resetReportLevel() {
    this._reportLevel = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get reportLevelInput() {
    return this._reportLevel;
  }

  // report_method - computed: true, optional: true, required: false
  private _reportMethod?: string; 
  public get reportMethod() {
    return this.getStringAttribute('report_method');
  }
  public set reportMethod(value: string) {
    this._reportMethod = value;
  }
  public resetReportMethod() {
    this._reportMethod = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get reportMethodInput() {
    return this._reportMethod;
  }

  // response_honor_retry_after_header - computed: true, optional: true, required: false
  private _responseHonorRetryAfterHeader?: boolean | cdktf.IResolvable; 
  public get responseHonorRetryAfterHeader() {
    return this.getBooleanAttribute('response_honor_retry_after_header');
  }
  public set responseHonorRetryAfterHeader(value: boolean | cdktf.IResolvable) {
    this._responseHonorRetryAfterHeader = value;
  }
  public resetResponseHonorRetryAfterHeader() {
    this._responseHonorRetryAfterHeader = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get responseHonorRetryAfterHeaderInput() {
    return this._responseHonorRetryAfterHeader;
  }

  // response_retry_settings - computed: false, optional: true, required: false
  private _responseRetrySettings = new PackDestinationOutputAzureDataExplorerResponseRetrySettingsList(this, "response_retry_settings", false);
  public get responseRetrySettings() {
    return this._responseRetrySettings;
  }
  public putResponseRetrySettings(value: PackDestinationOutputAzureDataExplorerResponseRetrySettings[] | cdktf.IResolvable) {
    this._responseRetrySettings.internalValue = value;
  }
  public resetResponseRetrySettings() {
    this._responseRetrySettings.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get responseRetrySettingsInput() {
    return this._responseRetrySettings.internalValue;
  }

  // retain_blob_on_success - computed: true, optional: true, required: false
  private _retainBlobOnSuccess?: boolean | cdktf.IResolvable; 
  public get retainBlobOnSuccess() {
    return this.getBooleanAttribute('retain_blob_on_success');
  }
  public set retainBlobOnSuccess(value: boolean | cdktf.IResolvable) {
    this._retainBlobOnSuccess = value;
  }
  public resetRetainBlobOnSuccess() {
    this._retainBlobOnSuccess = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get retainBlobOnSuccessInput() {
    return this._retainBlobOnSuccess;
  }

  // scope - computed: false, optional: false, required: true
  private _scope?: string; 
  public get scope() {
    return this.getStringAttribute('scope');
  }
  public set scope(value: string) {
    this._scope = value;
  }
  // Temporarily expose input value. Use with caution.
  public get scopeInput() {
    return this._scope;
  }

  // stage_path - computed: true, optional: true, required: false
  private _stagePath?: string; 
  public get stagePath() {
    return this.getStringAttribute('stage_path');
  }
  public set stagePath(value: string) {
    this._stagePath = value;
  }
  public resetStagePath() {
    this._stagePath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get stagePathInput() {
    return this._stagePath;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // system_fields - computed: true, optional: true, required: false
  private _systemFields?: string[]; 
  public get systemFields() {
    return this.getListAttribute('system_fields');
  }
  public set systemFields(value: string[]) {
    this._systemFields = value;
  }
  public resetSystemFields() {
    this._systemFields = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get systemFieldsInput() {
    return this._systemFields;
  }

  // table - computed: false, optional: false, required: true
  private _table?: string; 
  public get table() {
    return this.getStringAttribute('table');
  }
  public set table(value: string) {
    this._table = value;
  }
  // Temporarily expose input value. Use with caution.
  public get tableInput() {
    return this._table;
  }

  // tenant_id - computed: false, optional: false, required: true
  private _tenantId?: string; 
  public get tenantId() {
    return this.getStringAttribute('tenant_id');
  }
  public set tenantId(value: string) {
    this._tenantId = value;
  }
  // Temporarily expose input value. Use with caution.
  public get tenantIdInput() {
    return this._tenantId;
  }

  // text_secret - computed: false, optional: true, required: false
  private _textSecret?: string; 
  public get textSecret() {
    return this.getStringAttribute('text_secret');
  }
  public set textSecret(value: string) {
    this._textSecret = value;
  }
  public resetTextSecret() {
    this._textSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get textSecretInput() {
    return this._textSecret;
  }

  // timeout_retry_settings - computed: false, optional: true, required: false
  private _timeoutRetrySettings = new PackDestinationOutputAzureDataExplorerTimeoutRetrySettingsOutputReference(this, "timeout_retry_settings");
  public get timeoutRetrySettings() {
    return this._timeoutRetrySettings;
  }
  public putTimeoutRetrySettings(value: PackDestinationOutputAzureDataExplorerTimeoutRetrySettings) {
    this._timeoutRetrySettings.internalValue = value;
  }
  public resetTimeoutRetrySettings() {
    this._timeoutRetrySettings.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutRetrySettingsInput() {
    return this._timeoutRetrySettings.internalValue;
  }

  // timeout_sec - computed: true, optional: true, required: false
  private _timeoutSec?: number; 
  public get timeoutSec() {
    return this.getNumberAttribute('timeout_sec');
  }
  public set timeoutSec(value: number) {
    this._timeoutSec = value;
  }
  public resetTimeoutSec() {
    this._timeoutSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutSecInput() {
    return this._timeoutSec;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // use_round_robin_dns - computed: true, optional: true, required: false
  private _useRoundRobinDns?: boolean | cdktf.IResolvable; 
  public get useRoundRobinDns() {
    return this.getBooleanAttribute('use_round_robin_dns');
  }
  public set useRoundRobinDns(value: boolean | cdktf.IResolvable) {
    this._useRoundRobinDns = value;
  }
  public resetUseRoundRobinDns() {
    this._useRoundRobinDns = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get useRoundRobinDnsInput() {
    return this._useRoundRobinDns;
  }

  // validate_database_settings - computed: true, optional: true, required: false
  private _validateDatabaseSettings?: boolean | cdktf.IResolvable; 
  public get validateDatabaseSettings() {
    return this.getBooleanAttribute('validate_database_settings');
  }
  public set validateDatabaseSettings(value: boolean | cdktf.IResolvable) {
    this._validateDatabaseSettings = value;
  }
  public resetValidateDatabaseSettings() {
    this._validateDatabaseSettings = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get validateDatabaseSettingsInput() {
    return this._validateDatabaseSettings;
  }
}
export interface PackDestinationOutputAzureEventhubPqControls {
}

export function packDestinationOutputAzureEventhubPqControlsToTerraform(struct?: PackDestinationOutputAzureEventhubPqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function packDestinationOutputAzureEventhubPqControlsToHclTerraform(struct?: PackDestinationOutputAzureEventhubPqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class PackDestinationOutputAzureEventhubPqControlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackDestinationOutputAzureEventhubPqControls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputAzureEventhubPqControls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface PackDestinationOutputAzureEventhubSasl {
  /**
  * Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#disabled PackDestination#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * Default: "plain"; must be one of ["plain", "oauthbearer"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#mechanism PackDestination#mechanism}
  */
  readonly mechanism?: string;
}

export function packDestinationOutputAzureEventhubSaslToTerraform(struct?: PackDestinationOutputAzureEventhubSasl | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    mechanism: cdktf.stringToTerraform(struct!.mechanism),
  }
}


export function packDestinationOutputAzureEventhubSaslToHclTerraform(struct?: PackDestinationOutputAzureEventhubSasl | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    mechanism: {
      value: cdktf.stringToHclTerraform(struct!.mechanism),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputAzureEventhubSaslOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackDestinationOutputAzureEventhubSasl | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._mechanism !== undefined) {
      hasAnyValues = true;
      internalValueResult.mechanism = this._mechanism;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputAzureEventhubSasl | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._disabled = undefined;
      this._mechanism = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._disabled = value.disabled;
      this._mechanism = value.mechanism;
    }
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // mechanism - computed: true, optional: true, required: false
  private _mechanism?: string; 
  public get mechanism() {
    return this.getStringAttribute('mechanism');
  }
  public set mechanism(value: string) {
    this._mechanism = value;
  }
  public resetMechanism() {
    this._mechanism = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get mechanismInput() {
    return this._mechanism;
  }
}
export interface PackDestinationOutputAzureEventhubTls {
  /**
  * Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#disabled PackDestination#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * Reject certificates that are not authorized by a CA in the CA certificate path, or by another trusted CA (such as the system's). Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#reject_unauthorized PackDestination#reject_unauthorized}
  */
  readonly rejectUnauthorized?: boolean | cdktf.IResolvable;
}

export function packDestinationOutputAzureEventhubTlsToTerraform(struct?: PackDestinationOutputAzureEventhubTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    reject_unauthorized: cdktf.booleanToTerraform(struct!.rejectUnauthorized),
  }
}


export function packDestinationOutputAzureEventhubTlsToHclTerraform(struct?: PackDestinationOutputAzureEventhubTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    reject_unauthorized: {
      value: cdktf.booleanToHclTerraform(struct!.rejectUnauthorized),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputAzureEventhubTlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackDestinationOutputAzureEventhubTls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._rejectUnauthorized !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectUnauthorized = this._rejectUnauthorized;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputAzureEventhubTls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._disabled = undefined;
      this._rejectUnauthorized = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._disabled = value.disabled;
      this._rejectUnauthorized = value.rejectUnauthorized;
    }
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // reject_unauthorized - computed: true, optional: true, required: false
  private _rejectUnauthorized?: boolean | cdktf.IResolvable; 
  public get rejectUnauthorized() {
    return this.getBooleanAttribute('reject_unauthorized');
  }
  public set rejectUnauthorized(value: boolean | cdktf.IResolvable) {
    this._rejectUnauthorized = value;
  }
  public resetRejectUnauthorized() {
    this._rejectUnauthorized = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectUnauthorizedInput() {
    return this._rejectUnauthorized;
  }
}
export interface PackDestinationOutputAzureEventhub {
  /**
  * Control the number of required acknowledgments. Default: 1; must be one of ["1", "0", "-1"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#ack PackDestination#ack}
  */
  readonly ack?: number;
  /**
  * Maximum time to wait for Kafka to respond to an authentication request. Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#authentication_timeout PackDestination#authentication_timeout}
  */
  readonly authenticationTimeout?: number;
  /**
  * Set the backoff multiplier (2-20) to control the retry frequency for failed messages. For faster retries, use a lower multiplier. For slower retries with more delay between attempts, use a higher multiplier. The multiplier is used in an exponential backoff formula; see the Kafka [documentation](https://kafka.js.org/docs/retry-detailed) for details. Default: 2
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#backoff_rate PackDestination#backoff_rate}
  */
  readonly backoffRate?: number;
  /**
  * List of Event Hubs Kafka brokers to connect to, eg. yourdomain.servicebus.windows.net:9093. The hostname can be found in the host portion of the primary or secondary connection string in Shared Access Policies.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#brokers PackDestination#brokers}
  */
  readonly brokers: string[];
  /**
  * Maximum time to wait for a connection to complete successfully. Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#connection_timeout PackDestination#connection_timeout}
  */
  readonly connectionTimeout?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#description PackDestination#description}
  */
  readonly description?: string;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#environment PackDestination#environment}
  */
  readonly environment?: string;
  /**
  * Maximum number of events in a batch before forcing a flush. Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#flush_event_count PackDestination#flush_event_count}
  */
  readonly flushEventCount?: number;
  /**
  * Maximum time between requests. Small values could cause the payload size to be smaller than the configured Max record size. Default: 1
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#flush_period_sec PackDestination#flush_period_sec}
  */
  readonly flushPeriodSec?: number;
  /**
  * Format to use to serialize events before writing to the Event Hubs Kafka brokers. Default: "json"; must be one of ["json", "raw"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#format PackDestination#format}
  */
  readonly format?: string;
  /**
  * Unique ID for this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#id PackDestination#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * Initial value used to calculate the retry, in milliseconds. Maximum is 600,000 ms (10 minutes). Default: 300
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#initial_backoff PackDestination#initial_backoff}
  */
  readonly initialBackoff?: number;
  /**
  * The maximum wait time for a retry, in milliseconds. Default (and minimum) is 30,000 ms (30 seconds); maximum is 180,000 ms (180 seconds). Default: 30000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_back_off PackDestination#max_back_off}
  */
  readonly maxBackOff?: number;
  /**
  * Maximum size of each record batch before compression. Setting should be < message.max.bytes settings in Event Hubs brokers. Default: 768
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_record_size_kb PackDestination#max_record_size_kb}
  */
  readonly maxRecordSizeKb?: number;
  /**
  * If messages are failing, you can set the maximum number of retries as high as 100 to prevent loss of data. Default: 5
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_retries PackDestination#max_retries}
  */
  readonly maxRetries?: number;
  /**
  * How to handle events when all receivers are exerting backpressure. Default: "block"; must be one of ["block", "drop", "queue"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#on_backpressure PackDestination#on_backpressure}
  */
  readonly onBackpressure?: string;
  /**
  * Pipeline to process data before sending out to this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pipeline PackDestination#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_compress PackDestination#pq_compress}
  */
  readonly pqCompress?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_controls PackDestination#pq_controls}
  */
  readonly pqControls?: PackDestinationOutputAzureEventhubPqControls;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.). Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_max_file_size PackDestination#pq_max_file_size}
  */
  readonly pqMaxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_max_size PackDestination#pq_max_size}
  */
  readonly pqMaxSize?: string;
  /**
  * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem. Default: "error"; must be one of ["error", "backpressure", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_mode PackDestination#pq_mode}
  */
  readonly pqMode?: string;
  /**
  * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged. Default: "block"; must be one of ["block", "drop"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_on_backpressure PackDestination#pq_on_backpressure}
  */
  readonly pqOnBackpressure?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_path PackDestination#pq_path}
  */
  readonly pqPath?: string;
  /**
  * Specifies a time window during which @{product} can reauthenticate if needed. Creates the window measuring backward from the moment when credentials are set to expire. Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#reauthentication_threshold PackDestination#reauthentication_threshold}
  */
  readonly reauthenticationThreshold?: number;
  /**
  * Maximum time to wait for Kafka to respond to a request. Default: 60000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#request_timeout PackDestination#request_timeout}
  */
  readonly requestTimeout?: number;
  /**
  * Authentication parameters to use when connecting to brokers. Using TLS is highly recommended.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#sasl PackDestination#sasl}
  */
  readonly sasl?: PackDestinationOutputAzureEventhubSasl;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#streamtags PackDestination#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Fields to automatically add to events, such as cribl_pipe. Supports wildcards. Default: ["cribl_pipe"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#system_fields PackDestination#system_fields}
  */
  readonly systemFields?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#tls PackDestination#tls}
  */
  readonly tls?: PackDestinationOutputAzureEventhubTls;
  /**
  * The name of the Event Hub (Kafka Topic) to publish events. Can be overwritten using field __topicOut.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#topic PackDestination#topic}
  */
  readonly topic: string;
  /**
  * must be "azure_eventhub"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#type PackDestination#type}
  */
  readonly type?: string;
}

export function packDestinationOutputAzureEventhubToTerraform(struct?: PackDestinationOutputAzureEventhub | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ack: cdktf.numberToTerraform(struct!.ack),
    authentication_timeout: cdktf.numberToTerraform(struct!.authenticationTimeout),
    backoff_rate: cdktf.numberToTerraform(struct!.backoffRate),
    brokers: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.brokers),
    connection_timeout: cdktf.numberToTerraform(struct!.connectionTimeout),
    description: cdktf.stringToTerraform(struct!.description),
    environment: cdktf.stringToTerraform(struct!.environment),
    flush_event_count: cdktf.numberToTerraform(struct!.flushEventCount),
    flush_period_sec: cdktf.numberToTerraform(struct!.flushPeriodSec),
    format: cdktf.stringToTerraform(struct!.format),
    id: cdktf.stringToTerraform(struct!.id),
    initial_backoff: cdktf.numberToTerraform(struct!.initialBackoff),
    max_back_off: cdktf.numberToTerraform(struct!.maxBackOff),
    max_record_size_kb: cdktf.numberToTerraform(struct!.maxRecordSizeKb),
    max_retries: cdktf.numberToTerraform(struct!.maxRetries),
    on_backpressure: cdktf.stringToTerraform(struct!.onBackpressure),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    pq_compress: cdktf.stringToTerraform(struct!.pqCompress),
    pq_controls: packDestinationOutputAzureEventhubPqControlsToTerraform(struct!.pqControls),
    pq_max_file_size: cdktf.stringToTerraform(struct!.pqMaxFileSize),
    pq_max_size: cdktf.stringToTerraform(struct!.pqMaxSize),
    pq_mode: cdktf.stringToTerraform(struct!.pqMode),
    pq_on_backpressure: cdktf.stringToTerraform(struct!.pqOnBackpressure),
    pq_path: cdktf.stringToTerraform(struct!.pqPath),
    reauthentication_threshold: cdktf.numberToTerraform(struct!.reauthenticationThreshold),
    request_timeout: cdktf.numberToTerraform(struct!.requestTimeout),
    sasl: packDestinationOutputAzureEventhubSaslToTerraform(struct!.sasl),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    system_fields: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.systemFields),
    tls: packDestinationOutputAzureEventhubTlsToTerraform(struct!.tls),
    topic: cdktf.stringToTerraform(struct!.topic),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function packDestinationOutputAzureEventhubToHclTerraform(struct?: PackDestinationOutputAzureEventhub | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ack: {
      value: cdktf.numberToHclTerraform(struct!.ack),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    authentication_timeout: {
      value: cdktf.numberToHclTerraform(struct!.authenticationTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    backoff_rate: {
      value: cdktf.numberToHclTerraform(struct!.backoffRate),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    brokers: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.brokers),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    connection_timeout: {
      value: cdktf.numberToHclTerraform(struct!.connectionTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    flush_event_count: {
      value: cdktf.numberToHclTerraform(struct!.flushEventCount),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    flush_period_sec: {
      value: cdktf.numberToHclTerraform(struct!.flushPeriodSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    format: {
      value: cdktf.stringToHclTerraform(struct!.format),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    initial_backoff: {
      value: cdktf.numberToHclTerraform(struct!.initialBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_back_off: {
      value: cdktf.numberToHclTerraform(struct!.maxBackOff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_record_size_kb: {
      value: cdktf.numberToHclTerraform(struct!.maxRecordSizeKb),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_retries: {
      value: cdktf.numberToHclTerraform(struct!.maxRetries),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.onBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_compress: {
      value: cdktf.stringToHclTerraform(struct!.pqCompress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_controls: {
      value: packDestinationOutputAzureEventhubPqControlsToHclTerraform(struct!.pqControls),
      isBlock: true,
      type: "struct",
      storageClassType: "PackDestinationOutputAzureEventhubPqControls",
    },
    pq_max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_max_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_mode: {
      value: cdktf.stringToHclTerraform(struct!.pqMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.pqOnBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_path: {
      value: cdktf.stringToHclTerraform(struct!.pqPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reauthentication_threshold: {
      value: cdktf.numberToHclTerraform(struct!.reauthenticationThreshold),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    request_timeout: {
      value: cdktf.numberToHclTerraform(struct!.requestTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    sasl: {
      value: packDestinationOutputAzureEventhubSaslToHclTerraform(struct!.sasl),
      isBlock: true,
      type: "struct",
      storageClassType: "PackDestinationOutputAzureEventhubSasl",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    system_fields: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.systemFields),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    tls: {
      value: packDestinationOutputAzureEventhubTlsToHclTerraform(struct!.tls),
      isBlock: true,
      type: "struct",
      storageClassType: "PackDestinationOutputAzureEventhubTls",
    },
    topic: {
      value: cdktf.stringToHclTerraform(struct!.topic),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputAzureEventhubOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackDestinationOutputAzureEventhub | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._ack !== undefined) {
      hasAnyValues = true;
      internalValueResult.ack = this._ack;
    }
    if (this._authenticationTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.authenticationTimeout = this._authenticationTimeout;
    }
    if (this._backoffRate !== undefined) {
      hasAnyValues = true;
      internalValueResult.backoffRate = this._backoffRate;
    }
    if (this._brokers !== undefined) {
      hasAnyValues = true;
      internalValueResult.brokers = this._brokers;
    }
    if (this._connectionTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.connectionTimeout = this._connectionTimeout;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._flushEventCount !== undefined) {
      hasAnyValues = true;
      internalValueResult.flushEventCount = this._flushEventCount;
    }
    if (this._flushPeriodSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.flushPeriodSec = this._flushPeriodSec;
    }
    if (this._format !== undefined) {
      hasAnyValues = true;
      internalValueResult.format = this._format;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._initialBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.initialBackoff = this._initialBackoff;
    }
    if (this._maxBackOff !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBackOff = this._maxBackOff;
    }
    if (this._maxRecordSizeKb !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxRecordSizeKb = this._maxRecordSizeKb;
    }
    if (this._maxRetries !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxRetries = this._maxRetries;
    }
    if (this._onBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.onBackpressure = this._onBackpressure;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._pqCompress !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqCompress = this._pqCompress;
    }
    if (this._pqControls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqControls = this._pqControls?.internalValue;
    }
    if (this._pqMaxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxFileSize = this._pqMaxFileSize;
    }
    if (this._pqMaxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxSize = this._pqMaxSize;
    }
    if (this._pqMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMode = this._pqMode;
    }
    if (this._pqOnBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqOnBackpressure = this._pqOnBackpressure;
    }
    if (this._pqPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqPath = this._pqPath;
    }
    if (this._reauthenticationThreshold !== undefined) {
      hasAnyValues = true;
      internalValueResult.reauthenticationThreshold = this._reauthenticationThreshold;
    }
    if (this._requestTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.requestTimeout = this._requestTimeout;
    }
    if (this._sasl?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.sasl = this._sasl?.internalValue;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._systemFields !== undefined) {
      hasAnyValues = true;
      internalValueResult.systemFields = this._systemFields;
    }
    if (this._tls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tls = this._tls?.internalValue;
    }
    if (this._topic !== undefined) {
      hasAnyValues = true;
      internalValueResult.topic = this._topic;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputAzureEventhub | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._ack = undefined;
      this._authenticationTimeout = undefined;
      this._backoffRate = undefined;
      this._brokers = undefined;
      this._connectionTimeout = undefined;
      this._description = undefined;
      this._environment = undefined;
      this._flushEventCount = undefined;
      this._flushPeriodSec = undefined;
      this._format = undefined;
      this._id = undefined;
      this._initialBackoff = undefined;
      this._maxBackOff = undefined;
      this._maxRecordSizeKb = undefined;
      this._maxRetries = undefined;
      this._onBackpressure = undefined;
      this._pipeline = undefined;
      this._pqCompress = undefined;
      this._pqControls.internalValue = undefined;
      this._pqMaxFileSize = undefined;
      this._pqMaxSize = undefined;
      this._pqMode = undefined;
      this._pqOnBackpressure = undefined;
      this._pqPath = undefined;
      this._reauthenticationThreshold = undefined;
      this._requestTimeout = undefined;
      this._sasl.internalValue = undefined;
      this._streamtags = undefined;
      this._systemFields = undefined;
      this._tls.internalValue = undefined;
      this._topic = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._ack = value.ack;
      this._authenticationTimeout = value.authenticationTimeout;
      this._backoffRate = value.backoffRate;
      this._brokers = value.brokers;
      this._connectionTimeout = value.connectionTimeout;
      this._description = value.description;
      this._environment = value.environment;
      this._flushEventCount = value.flushEventCount;
      this._flushPeriodSec = value.flushPeriodSec;
      this._format = value.format;
      this._id = value.id;
      this._initialBackoff = value.initialBackoff;
      this._maxBackOff = value.maxBackOff;
      this._maxRecordSizeKb = value.maxRecordSizeKb;
      this._maxRetries = value.maxRetries;
      this._onBackpressure = value.onBackpressure;
      this._pipeline = value.pipeline;
      this._pqCompress = value.pqCompress;
      this._pqControls.internalValue = value.pqControls;
      this._pqMaxFileSize = value.pqMaxFileSize;
      this._pqMaxSize = value.pqMaxSize;
      this._pqMode = value.pqMode;
      this._pqOnBackpressure = value.pqOnBackpressure;
      this._pqPath = value.pqPath;
      this._reauthenticationThreshold = value.reauthenticationThreshold;
      this._requestTimeout = value.requestTimeout;
      this._sasl.internalValue = value.sasl;
      this._streamtags = value.streamtags;
      this._systemFields = value.systemFields;
      this._tls.internalValue = value.tls;
      this._topic = value.topic;
      this._type = value.type;
    }
  }

  // ack - computed: true, optional: true, required: false
  private _ack?: number; 
  public get ack() {
    return this.getNumberAttribute('ack');
  }
  public set ack(value: number) {
    this._ack = value;
  }
  public resetAck() {
    this._ack = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ackInput() {
    return this._ack;
  }

  // authentication_timeout - computed: true, optional: true, required: false
  private _authenticationTimeout?: number; 
  public get authenticationTimeout() {
    return this.getNumberAttribute('authentication_timeout');
  }
  public set authenticationTimeout(value: number) {
    this._authenticationTimeout = value;
  }
  public resetAuthenticationTimeout() {
    this._authenticationTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authenticationTimeoutInput() {
    return this._authenticationTimeout;
  }

  // backoff_rate - computed: true, optional: true, required: false
  private _backoffRate?: number; 
  public get backoffRate() {
    return this.getNumberAttribute('backoff_rate');
  }
  public set backoffRate(value: number) {
    this._backoffRate = value;
  }
  public resetBackoffRate() {
    this._backoffRate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get backoffRateInput() {
    return this._backoffRate;
  }

  // brokers - computed: false, optional: false, required: true
  private _brokers?: string[]; 
  public get brokers() {
    return this.getListAttribute('brokers');
  }
  public set brokers(value: string[]) {
    this._brokers = value;
  }
  // Temporarily expose input value. Use with caution.
  public get brokersInput() {
    return this._brokers;
  }

  // connection_timeout - computed: true, optional: true, required: false
  private _connectionTimeout?: number; 
  public get connectionTimeout() {
    return this.getNumberAttribute('connection_timeout');
  }
  public set connectionTimeout(value: number) {
    this._connectionTimeout = value;
  }
  public resetConnectionTimeout() {
    this._connectionTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectionTimeoutInput() {
    return this._connectionTimeout;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // flush_event_count - computed: true, optional: true, required: false
  private _flushEventCount?: number; 
  public get flushEventCount() {
    return this.getNumberAttribute('flush_event_count');
  }
  public set flushEventCount(value: number) {
    this._flushEventCount = value;
  }
  public resetFlushEventCount() {
    this._flushEventCount = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get flushEventCountInput() {
    return this._flushEventCount;
  }

  // flush_period_sec - computed: true, optional: true, required: false
  private _flushPeriodSec?: number; 
  public get flushPeriodSec() {
    return this.getNumberAttribute('flush_period_sec');
  }
  public set flushPeriodSec(value: number) {
    this._flushPeriodSec = value;
  }
  public resetFlushPeriodSec() {
    this._flushPeriodSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get flushPeriodSecInput() {
    return this._flushPeriodSec;
  }

  // format - computed: true, optional: true, required: false
  private _format?: string; 
  public get format() {
    return this.getStringAttribute('format');
  }
  public set format(value: string) {
    this._format = value;
  }
  public resetFormat() {
    this._format = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get formatInput() {
    return this._format;
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // initial_backoff - computed: true, optional: true, required: false
  private _initialBackoff?: number; 
  public get initialBackoff() {
    return this.getNumberAttribute('initial_backoff');
  }
  public set initialBackoff(value: number) {
    this._initialBackoff = value;
  }
  public resetInitialBackoff() {
    this._initialBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get initialBackoffInput() {
    return this._initialBackoff;
  }

  // max_back_off - computed: true, optional: true, required: false
  private _maxBackOff?: number; 
  public get maxBackOff() {
    return this.getNumberAttribute('max_back_off');
  }
  public set maxBackOff(value: number) {
    this._maxBackOff = value;
  }
  public resetMaxBackOff() {
    this._maxBackOff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBackOffInput() {
    return this._maxBackOff;
  }

  // max_record_size_kb - computed: true, optional: true, required: false
  private _maxRecordSizeKb?: number; 
  public get maxRecordSizeKb() {
    return this.getNumberAttribute('max_record_size_kb');
  }
  public set maxRecordSizeKb(value: number) {
    this._maxRecordSizeKb = value;
  }
  public resetMaxRecordSizeKb() {
    this._maxRecordSizeKb = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxRecordSizeKbInput() {
    return this._maxRecordSizeKb;
  }

  // max_retries - computed: true, optional: true, required: false
  private _maxRetries?: number; 
  public get maxRetries() {
    return this.getNumberAttribute('max_retries');
  }
  public set maxRetries(value: number) {
    this._maxRetries = value;
  }
  public resetMaxRetries() {
    this._maxRetries = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxRetriesInput() {
    return this._maxRetries;
  }

  // on_backpressure - computed: true, optional: true, required: false
  private _onBackpressure?: string; 
  public get onBackpressure() {
    return this.getStringAttribute('on_backpressure');
  }
  public set onBackpressure(value: string) {
    this._onBackpressure = value;
  }
  public resetOnBackpressure() {
    this._onBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get onBackpressureInput() {
    return this._onBackpressure;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // pq_compress - computed: true, optional: true, required: false
  private _pqCompress?: string; 
  public get pqCompress() {
    return this.getStringAttribute('pq_compress');
  }
  public set pqCompress(value: string) {
    this._pqCompress = value;
  }
  public resetPqCompress() {
    this._pqCompress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqCompressInput() {
    return this._pqCompress;
  }

  // pq_controls - computed: false, optional: true, required: false
  private _pqControls = new PackDestinationOutputAzureEventhubPqControlsOutputReference(this, "pq_controls");
  public get pqControls() {
    return this._pqControls;
  }
  public putPqControls(value: PackDestinationOutputAzureEventhubPqControls) {
    this._pqControls.internalValue = value;
  }
  public resetPqControls() {
    this._pqControls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqControlsInput() {
    return this._pqControls.internalValue;
  }

  // pq_max_file_size - computed: true, optional: true, required: false
  private _pqMaxFileSize?: string; 
  public get pqMaxFileSize() {
    return this.getStringAttribute('pq_max_file_size');
  }
  public set pqMaxFileSize(value: string) {
    this._pqMaxFileSize = value;
  }
  public resetPqMaxFileSize() {
    this._pqMaxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxFileSizeInput() {
    return this._pqMaxFileSize;
  }

  // pq_max_size - computed: true, optional: true, required: false
  private _pqMaxSize?: string; 
  public get pqMaxSize() {
    return this.getStringAttribute('pq_max_size');
  }
  public set pqMaxSize(value: string) {
    this._pqMaxSize = value;
  }
  public resetPqMaxSize() {
    this._pqMaxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxSizeInput() {
    return this._pqMaxSize;
  }

  // pq_mode - computed: true, optional: true, required: false
  private _pqMode?: string; 
  public get pqMode() {
    return this.getStringAttribute('pq_mode');
  }
  public set pqMode(value: string) {
    this._pqMode = value;
  }
  public resetPqMode() {
    this._pqMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqModeInput() {
    return this._pqMode;
  }

  // pq_on_backpressure - computed: true, optional: true, required: false
  private _pqOnBackpressure?: string; 
  public get pqOnBackpressure() {
    return this.getStringAttribute('pq_on_backpressure');
  }
  public set pqOnBackpressure(value: string) {
    this._pqOnBackpressure = value;
  }
  public resetPqOnBackpressure() {
    this._pqOnBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqOnBackpressureInput() {
    return this._pqOnBackpressure;
  }

  // pq_path - computed: true, optional: true, required: false
  private _pqPath?: string; 
  public get pqPath() {
    return this.getStringAttribute('pq_path');
  }
  public set pqPath(value: string) {
    this._pqPath = value;
  }
  public resetPqPath() {
    this._pqPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqPathInput() {
    return this._pqPath;
  }

  // reauthentication_threshold - computed: true, optional: true, required: false
  private _reauthenticationThreshold?: number; 
  public get reauthenticationThreshold() {
    return this.getNumberAttribute('reauthentication_threshold');
  }
  public set reauthenticationThreshold(value: number) {
    this._reauthenticationThreshold = value;
  }
  public resetReauthenticationThreshold() {
    this._reauthenticationThreshold = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get reauthenticationThresholdInput() {
    return this._reauthenticationThreshold;
  }

  // request_timeout - computed: true, optional: true, required: false
  private _requestTimeout?: number; 
  public get requestTimeout() {
    return this.getNumberAttribute('request_timeout');
  }
  public set requestTimeout(value: number) {
    this._requestTimeout = value;
  }
  public resetRequestTimeout() {
    this._requestTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestTimeoutInput() {
    return this._requestTimeout;
  }

  // sasl - computed: false, optional: true, required: false
  private _sasl = new PackDestinationOutputAzureEventhubSaslOutputReference(this, "sasl");
  public get sasl() {
    return this._sasl;
  }
  public putSasl(value: PackDestinationOutputAzureEventhubSasl) {
    this._sasl.internalValue = value;
  }
  public resetSasl() {
    this._sasl.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get saslInput() {
    return this._sasl.internalValue;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // system_fields - computed: true, optional: true, required: false
  private _systemFields?: string[]; 
  public get systemFields() {
    return this.getListAttribute('system_fields');
  }
  public set systemFields(value: string[]) {
    this._systemFields = value;
  }
  public resetSystemFields() {
    this._systemFields = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get systemFieldsInput() {
    return this._systemFields;
  }

  // tls - computed: false, optional: true, required: false
  private _tls = new PackDestinationOutputAzureEventhubTlsOutputReference(this, "tls");
  public get tls() {
    return this._tls;
  }
  public putTls(value: PackDestinationOutputAzureEventhubTls) {
    this._tls.internalValue = value;
  }
  public resetTls() {
    this._tls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsInput() {
    return this._tls.internalValue;
  }

  // topic - computed: false, optional: false, required: true
  private _topic?: string; 
  public get topic() {
    return this.getStringAttribute('topic');
  }
  public set topic(value: string) {
    this._topic = value;
  }
  // Temporarily expose input value. Use with caution.
  public get topicInput() {
    return this._topic;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface PackDestinationOutputAzureLogsExtraHttpHeaders {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#name PackDestination#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#value PackDestination#value}
  */
  readonly value: string;
}

export function packDestinationOutputAzureLogsExtraHttpHeadersToTerraform(struct?: PackDestinationOutputAzureLogsExtraHttpHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function packDestinationOutputAzureLogsExtraHttpHeadersToHclTerraform(struct?: PackDestinationOutputAzureLogsExtraHttpHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputAzureLogsExtraHttpHeadersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackDestinationOutputAzureLogsExtraHttpHeaders | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputAzureLogsExtraHttpHeaders | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class PackDestinationOutputAzureLogsExtraHttpHeadersList extends cdktf.ComplexList {
  public internalValue? : PackDestinationOutputAzureLogsExtraHttpHeaders[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackDestinationOutputAzureLogsExtraHttpHeadersOutputReference {
    return new PackDestinationOutputAzureLogsExtraHttpHeadersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackDestinationOutputAzureLogsPqControls {
}

export function packDestinationOutputAzureLogsPqControlsToTerraform(struct?: PackDestinationOutputAzureLogsPqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function packDestinationOutputAzureLogsPqControlsToHclTerraform(struct?: PackDestinationOutputAzureLogsPqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class PackDestinationOutputAzureLogsPqControlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackDestinationOutputAzureLogsPqControls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputAzureLogsPqControls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface PackDestinationOutputAzureLogsResponseRetrySettings {
  /**
  * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc. Default: 2
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#backoff_rate PackDestination#backoff_rate}
  */
  readonly backoffRate?: number;
  /**
  * The HTTP response status code that will trigger retries
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#http_status PackDestination#http_status}
  */
  readonly httpStatus: number;
  /**
  * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes). Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#initial_backoff PackDestination#initial_backoff}
  */
  readonly initialBackoff?: number;
  /**
  * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds). Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_backoff PackDestination#max_backoff}
  */
  readonly maxBackoff?: number;
}

export function packDestinationOutputAzureLogsResponseRetrySettingsToTerraform(struct?: PackDestinationOutputAzureLogsResponseRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    backoff_rate: cdktf.numberToTerraform(struct!.backoffRate),
    http_status: cdktf.numberToTerraform(struct!.httpStatus),
    initial_backoff: cdktf.numberToTerraform(struct!.initialBackoff),
    max_backoff: cdktf.numberToTerraform(struct!.maxBackoff),
  }
}


export function packDestinationOutputAzureLogsResponseRetrySettingsToHclTerraform(struct?: PackDestinationOutputAzureLogsResponseRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    backoff_rate: {
      value: cdktf.numberToHclTerraform(struct!.backoffRate),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    http_status: {
      value: cdktf.numberToHclTerraform(struct!.httpStatus),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    initial_backoff: {
      value: cdktf.numberToHclTerraform(struct!.initialBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_backoff: {
      value: cdktf.numberToHclTerraform(struct!.maxBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputAzureLogsResponseRetrySettingsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackDestinationOutputAzureLogsResponseRetrySettings | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._backoffRate !== undefined) {
      hasAnyValues = true;
      internalValueResult.backoffRate = this._backoffRate;
    }
    if (this._httpStatus !== undefined) {
      hasAnyValues = true;
      internalValueResult.httpStatus = this._httpStatus;
    }
    if (this._initialBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.initialBackoff = this._initialBackoff;
    }
    if (this._maxBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBackoff = this._maxBackoff;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputAzureLogsResponseRetrySettings | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._backoffRate = undefined;
      this._httpStatus = undefined;
      this._initialBackoff = undefined;
      this._maxBackoff = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._backoffRate = value.backoffRate;
      this._httpStatus = value.httpStatus;
      this._initialBackoff = value.initialBackoff;
      this._maxBackoff = value.maxBackoff;
    }
  }

  // backoff_rate - computed: true, optional: true, required: false
  private _backoffRate?: number; 
  public get backoffRate() {
    return this.getNumberAttribute('backoff_rate');
  }
  public set backoffRate(value: number) {
    this._backoffRate = value;
  }
  public resetBackoffRate() {
    this._backoffRate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get backoffRateInput() {
    return this._backoffRate;
  }

  // http_status - computed: false, optional: false, required: true
  private _httpStatus?: number; 
  public get httpStatus() {
    return this.getNumberAttribute('http_status');
  }
  public set httpStatus(value: number) {
    this._httpStatus = value;
  }
  // Temporarily expose input value. Use with caution.
  public get httpStatusInput() {
    return this._httpStatus;
  }

  // initial_backoff - computed: true, optional: true, required: false
  private _initialBackoff?: number; 
  public get initialBackoff() {
    return this.getNumberAttribute('initial_backoff');
  }
  public set initialBackoff(value: number) {
    this._initialBackoff = value;
  }
  public resetInitialBackoff() {
    this._initialBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get initialBackoffInput() {
    return this._initialBackoff;
  }

  // max_backoff - computed: true, optional: true, required: false
  private _maxBackoff?: number; 
  public get maxBackoff() {
    return this.getNumberAttribute('max_backoff');
  }
  public set maxBackoff(value: number) {
    this._maxBackoff = value;
  }
  public resetMaxBackoff() {
    this._maxBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBackoffInput() {
    return this._maxBackoff;
  }
}

export class PackDestinationOutputAzureLogsResponseRetrySettingsList extends cdktf.ComplexList {
  public internalValue? : PackDestinationOutputAzureLogsResponseRetrySettings[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackDestinationOutputAzureLogsResponseRetrySettingsOutputReference {
    return new PackDestinationOutputAzureLogsResponseRetrySettingsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackDestinationOutputAzureLogsTimeoutRetrySettings {
  /**
  * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc. Default: 2
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#backoff_rate PackDestination#backoff_rate}
  */
  readonly backoffRate?: number;
  /**
  * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes). Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#initial_backoff PackDestination#initial_backoff}
  */
  readonly initialBackoff?: number;
  /**
  * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds). Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_backoff PackDestination#max_backoff}
  */
  readonly maxBackoff?: number;
  /**
  * Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#timeout_retry PackDestination#timeout_retry}
  */
  readonly timeoutRetry?: boolean | cdktf.IResolvable;
}

export function packDestinationOutputAzureLogsTimeoutRetrySettingsToTerraform(struct?: PackDestinationOutputAzureLogsTimeoutRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    backoff_rate: cdktf.numberToTerraform(struct!.backoffRate),
    initial_backoff: cdktf.numberToTerraform(struct!.initialBackoff),
    max_backoff: cdktf.numberToTerraform(struct!.maxBackoff),
    timeout_retry: cdktf.booleanToTerraform(struct!.timeoutRetry),
  }
}


export function packDestinationOutputAzureLogsTimeoutRetrySettingsToHclTerraform(struct?: PackDestinationOutputAzureLogsTimeoutRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    backoff_rate: {
      value: cdktf.numberToHclTerraform(struct!.backoffRate),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    initial_backoff: {
      value: cdktf.numberToHclTerraform(struct!.initialBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_backoff: {
      value: cdktf.numberToHclTerraform(struct!.maxBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    timeout_retry: {
      value: cdktf.booleanToHclTerraform(struct!.timeoutRetry),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputAzureLogsTimeoutRetrySettingsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackDestinationOutputAzureLogsTimeoutRetrySettings | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._backoffRate !== undefined) {
      hasAnyValues = true;
      internalValueResult.backoffRate = this._backoffRate;
    }
    if (this._initialBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.initialBackoff = this._initialBackoff;
    }
    if (this._maxBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBackoff = this._maxBackoff;
    }
    if (this._timeoutRetry !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutRetry = this._timeoutRetry;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputAzureLogsTimeoutRetrySettings | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._backoffRate = undefined;
      this._initialBackoff = undefined;
      this._maxBackoff = undefined;
      this._timeoutRetry = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._backoffRate = value.backoffRate;
      this._initialBackoff = value.initialBackoff;
      this._maxBackoff = value.maxBackoff;
      this._timeoutRetry = value.timeoutRetry;
    }
  }

  // backoff_rate - computed: true, optional: true, required: false
  private _backoffRate?: number; 
  public get backoffRate() {
    return this.getNumberAttribute('backoff_rate');
  }
  public set backoffRate(value: number) {
    this._backoffRate = value;
  }
  public resetBackoffRate() {
    this._backoffRate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get backoffRateInput() {
    return this._backoffRate;
  }

  // initial_backoff - computed: true, optional: true, required: false
  private _initialBackoff?: number; 
  public get initialBackoff() {
    return this.getNumberAttribute('initial_backoff');
  }
  public set initialBackoff(value: number) {
    this._initialBackoff = value;
  }
  public resetInitialBackoff() {
    this._initialBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get initialBackoffInput() {
    return this._initialBackoff;
  }

  // max_backoff - computed: true, optional: true, required: false
  private _maxBackoff?: number; 
  public get maxBackoff() {
    return this.getNumberAttribute('max_backoff');
  }
  public set maxBackoff(value: number) {
    this._maxBackoff = value;
  }
  public resetMaxBackoff() {
    this._maxBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBackoffInput() {
    return this._maxBackoff;
  }

  // timeout_retry - computed: true, optional: true, required: false
  private _timeoutRetry?: boolean | cdktf.IResolvable; 
  public get timeoutRetry() {
    return this.getBooleanAttribute('timeout_retry');
  }
  public set timeoutRetry(value: boolean | cdktf.IResolvable) {
    this._timeoutRetry = value;
  }
  public resetTimeoutRetry() {
    this._timeoutRetry = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutRetryInput() {
    return this._timeoutRetry;
  }
}
export interface PackDestinationOutputAzureLogs {
  /**
  * The DNS name of the Log API endpoint that sends log data to a Log Analytics workspace in Azure Monitor. Defaults to .ods.opinsights.azure.com. @{product} will add a prefix and suffix to construct a URI in this format: <https://<Workspace_ID><your_DNS_name>/api/logs?api-version=<API version>. Default: ".ods.opinsights.azure.com"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#api_url PackDestination#api_url}
  */
  readonly apiUrl?: string;
  /**
  * Enter workspace ID and workspace key directly, or select a stored secret. Default: "manual"; must be one of ["manual", "secret"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#auth_type PackDestination#auth_type}
  */
  readonly authType?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#compress PackDestination#compress}
  */
  readonly compress?: boolean | cdktf.IResolvable;
  /**
  * Maximum number of ongoing requests before blocking. Default: 5
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#concurrency PackDestination#concurrency}
  */
  readonly concurrency?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#description PackDestination#description}
  */
  readonly description?: string;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#environment PackDestination#environment}
  */
  readonly environment?: string;
  /**
  * Headers to add to all events
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#extra_http_headers PackDestination#extra_http_headers}
  */
  readonly extraHttpHeaders?: PackDestinationOutputAzureLogsExtraHttpHeaders[] | cdktf.IResolvable;
  /**
  * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below. Default: "none"; must be one of ["payload", "payloadAndHeaders", "none"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#failed_request_logging_mode PackDestination#failed_request_logging_mode}
  */
  readonly failedRequestLoggingMode?: string;
  /**
  * Maximum time between requests. Small values could cause the payload size to be smaller than the configured Body size limit. Default: 1
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#flush_period_sec PackDestination#flush_period_sec}
  */
  readonly flushPeriodSec?: number;
  /**
  * Unique ID for this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#id PackDestination#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * Select or create a stored secret that references your access key and secret key
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#keypair_secret PackDestination#keypair_secret}
  */
  readonly keypairSecret?: string;
  /**
  * The Log Type of events sent to this LogAnalytics workspace. Defaults to `Cribl`. Use only letters, numbers, and `_` characters, and can't exceed 100 characters. Can be overwritten by event field __logType. Default: "Cribl"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#log_type PackDestination#log_type}
  */
  readonly logType?: string;
  /**
  * Maximum number of events to include in the request body. Default is 0 (unlimited). Default: 0
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_payload_events PackDestination#max_payload_events}
  */
  readonly maxPayloadEvents?: number;
  /**
  * Maximum size, in KB, of the request body. Default: 1024
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_payload_size_kb PackDestination#max_payload_size_kb}
  */
  readonly maxPayloadSizeKb?: number;
  /**
  * How to handle events when all receivers are exerting backpressure. Default: "block"; must be one of ["block", "drop", "queue"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#on_backpressure PackDestination#on_backpressure}
  */
  readonly onBackpressure?: string;
  /**
  * Pipeline to process data before sending out to this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pipeline PackDestination#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_compress PackDestination#pq_compress}
  */
  readonly pqCompress?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_controls PackDestination#pq_controls}
  */
  readonly pqControls?: PackDestinationOutputAzureLogsPqControls;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.). Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_max_file_size PackDestination#pq_max_file_size}
  */
  readonly pqMaxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_max_size PackDestination#pq_max_size}
  */
  readonly pqMaxSize?: string;
  /**
  * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem. Default: "error"; must be one of ["error", "backpressure", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_mode PackDestination#pq_mode}
  */
  readonly pqMode?: string;
  /**
  * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged. Default: "block"; must be one of ["block", "drop"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_on_backpressure PackDestination#pq_on_backpressure}
  */
  readonly pqOnBackpressure?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_path PackDestination#pq_path}
  */
  readonly pqPath?: string;
  /**
  * Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's). 
  *         Enabled by default. When this setting is also present in TLS Settings (Client Side), 
  *         that value will take precedence.
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#reject_unauthorized PackDestination#reject_unauthorized}
  */
  readonly rejectUnauthorized?: boolean | cdktf.IResolvable;
  /**
  * Optional Resource ID of the Azure resource to associate the data with. Can be overridden by the __resourceId event field. This ID populates the _ResourceId property, allowing the data to be included in resource-centric queries. If the ID is neither specified nor overridden, resource-centric queries will omit the data.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#resource_id PackDestination#resource_id}
  */
  readonly resourceId?: string;
  /**
  * Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#response_honor_retry_after_header PackDestination#response_honor_retry_after_header}
  */
  readonly responseHonorRetryAfterHeader?: boolean | cdktf.IResolvable;
  /**
  * Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#response_retry_settings PackDestination#response_retry_settings}
  */
  readonly responseRetrySettings?: PackDestinationOutputAzureLogsResponseRetrySettings[] | cdktf.IResolvable;
  /**
  * List of headers that are safe to log in plain text. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#safe_headers PackDestination#safe_headers}
  */
  readonly safeHeaders?: string[];
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#streamtags PackDestination#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Fields to automatically add to events, such as cribl_pipe. Supports wildcards. Default: ["cribl_pipe"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#system_fields PackDestination#system_fields}
  */
  readonly systemFields?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#timeout_retry_settings PackDestination#timeout_retry_settings}
  */
  readonly timeoutRetrySettings?: PackDestinationOutputAzureLogsTimeoutRetrySettings;
  /**
  * Amount of time, in seconds, to wait for a request to complete before canceling it. Default: 30
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#timeout_sec PackDestination#timeout_sec}
  */
  readonly timeoutSec?: number;
  /**
  * must be "azure_logs"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#type PackDestination#type}
  */
  readonly type: string;
  /**
  * Enable round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. For optimal performance, consider enabling this setting for non-load balanced destinations. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#use_round_robin_dns PackDestination#use_round_robin_dns}
  */
  readonly useRoundRobinDns?: boolean | cdktf.IResolvable;
  /**
  * Azure Log Analytics Workspace ID. See Azure Dashboard Workspace > Advanced settings.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#workspace_id PackDestination#workspace_id}
  */
  readonly workspaceId?: string;
  /**
  * Azure Log Analytics Workspace Primary or Secondary Shared Key. See Azure Dashboard Workspace > Advanced settings.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#workspace_key PackDestination#workspace_key}
  */
  readonly workspaceKey?: string;
}

export function packDestinationOutputAzureLogsToTerraform(struct?: PackDestinationOutputAzureLogs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    api_url: cdktf.stringToTerraform(struct!.apiUrl),
    auth_type: cdktf.stringToTerraform(struct!.authType),
    compress: cdktf.booleanToTerraform(struct!.compress),
    concurrency: cdktf.numberToTerraform(struct!.concurrency),
    description: cdktf.stringToTerraform(struct!.description),
    environment: cdktf.stringToTerraform(struct!.environment),
    extra_http_headers: cdktf.listMapper(packDestinationOutputAzureLogsExtraHttpHeadersToTerraform, false)(struct!.extraHttpHeaders),
    failed_request_logging_mode: cdktf.stringToTerraform(struct!.failedRequestLoggingMode),
    flush_period_sec: cdktf.numberToTerraform(struct!.flushPeriodSec),
    id: cdktf.stringToTerraform(struct!.id),
    keypair_secret: cdktf.stringToTerraform(struct!.keypairSecret),
    log_type: cdktf.stringToTerraform(struct!.logType),
    max_payload_events: cdktf.numberToTerraform(struct!.maxPayloadEvents),
    max_payload_size_kb: cdktf.numberToTerraform(struct!.maxPayloadSizeKb),
    on_backpressure: cdktf.stringToTerraform(struct!.onBackpressure),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    pq_compress: cdktf.stringToTerraform(struct!.pqCompress),
    pq_controls: packDestinationOutputAzureLogsPqControlsToTerraform(struct!.pqControls),
    pq_max_file_size: cdktf.stringToTerraform(struct!.pqMaxFileSize),
    pq_max_size: cdktf.stringToTerraform(struct!.pqMaxSize),
    pq_mode: cdktf.stringToTerraform(struct!.pqMode),
    pq_on_backpressure: cdktf.stringToTerraform(struct!.pqOnBackpressure),
    pq_path: cdktf.stringToTerraform(struct!.pqPath),
    reject_unauthorized: cdktf.booleanToTerraform(struct!.rejectUnauthorized),
    resource_id: cdktf.stringToTerraform(struct!.resourceId),
    response_honor_retry_after_header: cdktf.booleanToTerraform(struct!.responseHonorRetryAfterHeader),
    response_retry_settings: cdktf.listMapper(packDestinationOutputAzureLogsResponseRetrySettingsToTerraform, false)(struct!.responseRetrySettings),
    safe_headers: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.safeHeaders),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    system_fields: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.systemFields),
    timeout_retry_settings: packDestinationOutputAzureLogsTimeoutRetrySettingsToTerraform(struct!.timeoutRetrySettings),
    timeout_sec: cdktf.numberToTerraform(struct!.timeoutSec),
    type: cdktf.stringToTerraform(struct!.type),
    use_round_robin_dns: cdktf.booleanToTerraform(struct!.useRoundRobinDns),
    workspace_id: cdktf.stringToTerraform(struct!.workspaceId),
    workspace_key: cdktf.stringToTerraform(struct!.workspaceKey),
  }
}


export function packDestinationOutputAzureLogsToHclTerraform(struct?: PackDestinationOutputAzureLogs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    api_url: {
      value: cdktf.stringToHclTerraform(struct!.apiUrl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    auth_type: {
      value: cdktf.stringToHclTerraform(struct!.authType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    compress: {
      value: cdktf.booleanToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    concurrency: {
      value: cdktf.numberToHclTerraform(struct!.concurrency),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    extra_http_headers: {
      value: cdktf.listMapperHcl(packDestinationOutputAzureLogsExtraHttpHeadersToHclTerraform, false)(struct!.extraHttpHeaders),
      isBlock: true,
      type: "list",
      storageClassType: "PackDestinationOutputAzureLogsExtraHttpHeadersList",
    },
    failed_request_logging_mode: {
      value: cdktf.stringToHclTerraform(struct!.failedRequestLoggingMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    flush_period_sec: {
      value: cdktf.numberToHclTerraform(struct!.flushPeriodSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    keypair_secret: {
      value: cdktf.stringToHclTerraform(struct!.keypairSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    log_type: {
      value: cdktf.stringToHclTerraform(struct!.logType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_payload_events: {
      value: cdktf.numberToHclTerraform(struct!.maxPayloadEvents),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_payload_size_kb: {
      value: cdktf.numberToHclTerraform(struct!.maxPayloadSizeKb),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.onBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_compress: {
      value: cdktf.stringToHclTerraform(struct!.pqCompress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_controls: {
      value: packDestinationOutputAzureLogsPqControlsToHclTerraform(struct!.pqControls),
      isBlock: true,
      type: "struct",
      storageClassType: "PackDestinationOutputAzureLogsPqControls",
    },
    pq_max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_max_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_mode: {
      value: cdktf.stringToHclTerraform(struct!.pqMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.pqOnBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_path: {
      value: cdktf.stringToHclTerraform(struct!.pqPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reject_unauthorized: {
      value: cdktf.booleanToHclTerraform(struct!.rejectUnauthorized),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    resource_id: {
      value: cdktf.stringToHclTerraform(struct!.resourceId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    response_honor_retry_after_header: {
      value: cdktf.booleanToHclTerraform(struct!.responseHonorRetryAfterHeader),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    response_retry_settings: {
      value: cdktf.listMapperHcl(packDestinationOutputAzureLogsResponseRetrySettingsToHclTerraform, false)(struct!.responseRetrySettings),
      isBlock: true,
      type: "list",
      storageClassType: "PackDestinationOutputAzureLogsResponseRetrySettingsList",
    },
    safe_headers: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.safeHeaders),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    system_fields: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.systemFields),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    timeout_retry_settings: {
      value: packDestinationOutputAzureLogsTimeoutRetrySettingsToHclTerraform(struct!.timeoutRetrySettings),
      isBlock: true,
      type: "struct",
      storageClassType: "PackDestinationOutputAzureLogsTimeoutRetrySettings",
    },
    timeout_sec: {
      value: cdktf.numberToHclTerraform(struct!.timeoutSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    use_round_robin_dns: {
      value: cdktf.booleanToHclTerraform(struct!.useRoundRobinDns),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    workspace_id: {
      value: cdktf.stringToHclTerraform(struct!.workspaceId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    workspace_key: {
      value: cdktf.stringToHclTerraform(struct!.workspaceKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputAzureLogsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackDestinationOutputAzureLogs | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._apiUrl !== undefined) {
      hasAnyValues = true;
      internalValueResult.apiUrl = this._apiUrl;
    }
    if (this._authType !== undefined) {
      hasAnyValues = true;
      internalValueResult.authType = this._authType;
    }
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._concurrency !== undefined) {
      hasAnyValues = true;
      internalValueResult.concurrency = this._concurrency;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._extraHttpHeaders?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.extraHttpHeaders = this._extraHttpHeaders?.internalValue;
    }
    if (this._failedRequestLoggingMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.failedRequestLoggingMode = this._failedRequestLoggingMode;
    }
    if (this._flushPeriodSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.flushPeriodSec = this._flushPeriodSec;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._keypairSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.keypairSecret = this._keypairSecret;
    }
    if (this._logType !== undefined) {
      hasAnyValues = true;
      internalValueResult.logType = this._logType;
    }
    if (this._maxPayloadEvents !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxPayloadEvents = this._maxPayloadEvents;
    }
    if (this._maxPayloadSizeKb !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxPayloadSizeKb = this._maxPayloadSizeKb;
    }
    if (this._onBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.onBackpressure = this._onBackpressure;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._pqCompress !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqCompress = this._pqCompress;
    }
    if (this._pqControls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqControls = this._pqControls?.internalValue;
    }
    if (this._pqMaxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxFileSize = this._pqMaxFileSize;
    }
    if (this._pqMaxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxSize = this._pqMaxSize;
    }
    if (this._pqMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMode = this._pqMode;
    }
    if (this._pqOnBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqOnBackpressure = this._pqOnBackpressure;
    }
    if (this._pqPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqPath = this._pqPath;
    }
    if (this._rejectUnauthorized !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectUnauthorized = this._rejectUnauthorized;
    }
    if (this._resourceId !== undefined) {
      hasAnyValues = true;
      internalValueResult.resourceId = this._resourceId;
    }
    if (this._responseHonorRetryAfterHeader !== undefined) {
      hasAnyValues = true;
      internalValueResult.responseHonorRetryAfterHeader = this._responseHonorRetryAfterHeader;
    }
    if (this._responseRetrySettings?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.responseRetrySettings = this._responseRetrySettings?.internalValue;
    }
    if (this._safeHeaders !== undefined) {
      hasAnyValues = true;
      internalValueResult.safeHeaders = this._safeHeaders;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._systemFields !== undefined) {
      hasAnyValues = true;
      internalValueResult.systemFields = this._systemFields;
    }
    if (this._timeoutRetrySettings?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutRetrySettings = this._timeoutRetrySettings?.internalValue;
    }
    if (this._timeoutSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutSec = this._timeoutSec;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._useRoundRobinDns !== undefined) {
      hasAnyValues = true;
      internalValueResult.useRoundRobinDns = this._useRoundRobinDns;
    }
    if (this._workspaceId !== undefined) {
      hasAnyValues = true;
      internalValueResult.workspaceId = this._workspaceId;
    }
    if (this._workspaceKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.workspaceKey = this._workspaceKey;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputAzureLogs | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._apiUrl = undefined;
      this._authType = undefined;
      this._compress = undefined;
      this._concurrency = undefined;
      this._description = undefined;
      this._environment = undefined;
      this._extraHttpHeaders.internalValue = undefined;
      this._failedRequestLoggingMode = undefined;
      this._flushPeriodSec = undefined;
      this._id = undefined;
      this._keypairSecret = undefined;
      this._logType = undefined;
      this._maxPayloadEvents = undefined;
      this._maxPayloadSizeKb = undefined;
      this._onBackpressure = undefined;
      this._pipeline = undefined;
      this._pqCompress = undefined;
      this._pqControls.internalValue = undefined;
      this._pqMaxFileSize = undefined;
      this._pqMaxSize = undefined;
      this._pqMode = undefined;
      this._pqOnBackpressure = undefined;
      this._pqPath = undefined;
      this._rejectUnauthorized = undefined;
      this._resourceId = undefined;
      this._responseHonorRetryAfterHeader = undefined;
      this._responseRetrySettings.internalValue = undefined;
      this._safeHeaders = undefined;
      this._streamtags = undefined;
      this._systemFields = undefined;
      this._timeoutRetrySettings.internalValue = undefined;
      this._timeoutSec = undefined;
      this._type = undefined;
      this._useRoundRobinDns = undefined;
      this._workspaceId = undefined;
      this._workspaceKey = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._apiUrl = value.apiUrl;
      this._authType = value.authType;
      this._compress = value.compress;
      this._concurrency = value.concurrency;
      this._description = value.description;
      this._environment = value.environment;
      this._extraHttpHeaders.internalValue = value.extraHttpHeaders;
      this._failedRequestLoggingMode = value.failedRequestLoggingMode;
      this._flushPeriodSec = value.flushPeriodSec;
      this._id = value.id;
      this._keypairSecret = value.keypairSecret;
      this._logType = value.logType;
      this._maxPayloadEvents = value.maxPayloadEvents;
      this._maxPayloadSizeKb = value.maxPayloadSizeKb;
      this._onBackpressure = value.onBackpressure;
      this._pipeline = value.pipeline;
      this._pqCompress = value.pqCompress;
      this._pqControls.internalValue = value.pqControls;
      this._pqMaxFileSize = value.pqMaxFileSize;
      this._pqMaxSize = value.pqMaxSize;
      this._pqMode = value.pqMode;
      this._pqOnBackpressure = value.pqOnBackpressure;
      this._pqPath = value.pqPath;
      this._rejectUnauthorized = value.rejectUnauthorized;
      this._resourceId = value.resourceId;
      this._responseHonorRetryAfterHeader = value.responseHonorRetryAfterHeader;
      this._responseRetrySettings.internalValue = value.responseRetrySettings;
      this._safeHeaders = value.safeHeaders;
      this._streamtags = value.streamtags;
      this._systemFields = value.systemFields;
      this._timeoutRetrySettings.internalValue = value.timeoutRetrySettings;
      this._timeoutSec = value.timeoutSec;
      this._type = value.type;
      this._useRoundRobinDns = value.useRoundRobinDns;
      this._workspaceId = value.workspaceId;
      this._workspaceKey = value.workspaceKey;
    }
  }

  // api_url - computed: true, optional: true, required: false
  private _apiUrl?: string; 
  public get apiUrl() {
    return this.getStringAttribute('api_url');
  }
  public set apiUrl(value: string) {
    this._apiUrl = value;
  }
  public resetApiUrl() {
    this._apiUrl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get apiUrlInput() {
    return this._apiUrl;
  }

  // auth_type - computed: true, optional: true, required: false
  private _authType?: string; 
  public get authType() {
    return this.getStringAttribute('auth_type');
  }
  public set authType(value: string) {
    this._authType = value;
  }
  public resetAuthType() {
    this._authType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authTypeInput() {
    return this._authType;
  }

  // compress - computed: false, optional: true, required: false
  private _compress?: boolean | cdktf.IResolvable; 
  public get compress() {
    return this.getBooleanAttribute('compress');
  }
  public set compress(value: boolean | cdktf.IResolvable) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // concurrency - computed: true, optional: true, required: false
  private _concurrency?: number; 
  public get concurrency() {
    return this.getNumberAttribute('concurrency');
  }
  public set concurrency(value: number) {
    this._concurrency = value;
  }
  public resetConcurrency() {
    this._concurrency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get concurrencyInput() {
    return this._concurrency;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // extra_http_headers - computed: false, optional: true, required: false
  private _extraHttpHeaders = new PackDestinationOutputAzureLogsExtraHttpHeadersList(this, "extra_http_headers", false);
  public get extraHttpHeaders() {
    return this._extraHttpHeaders;
  }
  public putExtraHttpHeaders(value: PackDestinationOutputAzureLogsExtraHttpHeaders[] | cdktf.IResolvable) {
    this._extraHttpHeaders.internalValue = value;
  }
  public resetExtraHttpHeaders() {
    this._extraHttpHeaders.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get extraHttpHeadersInput() {
    return this._extraHttpHeaders.internalValue;
  }

  // failed_request_logging_mode - computed: true, optional: true, required: false
  private _failedRequestLoggingMode?: string; 
  public get failedRequestLoggingMode() {
    return this.getStringAttribute('failed_request_logging_mode');
  }
  public set failedRequestLoggingMode(value: string) {
    this._failedRequestLoggingMode = value;
  }
  public resetFailedRequestLoggingMode() {
    this._failedRequestLoggingMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get failedRequestLoggingModeInput() {
    return this._failedRequestLoggingMode;
  }

  // flush_period_sec - computed: true, optional: true, required: false
  private _flushPeriodSec?: number; 
  public get flushPeriodSec() {
    return this.getNumberAttribute('flush_period_sec');
  }
  public set flushPeriodSec(value: number) {
    this._flushPeriodSec = value;
  }
  public resetFlushPeriodSec() {
    this._flushPeriodSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get flushPeriodSecInput() {
    return this._flushPeriodSec;
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // keypair_secret - computed: false, optional: true, required: false
  private _keypairSecret?: string; 
  public get keypairSecret() {
    return this.getStringAttribute('keypair_secret');
  }
  public set keypairSecret(value: string) {
    this._keypairSecret = value;
  }
  public resetKeypairSecret() {
    this._keypairSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keypairSecretInput() {
    return this._keypairSecret;
  }

  // log_type - computed: true, optional: true, required: false
  private _logType?: string; 
  public get logType() {
    return this.getStringAttribute('log_type');
  }
  public set logType(value: string) {
    this._logType = value;
  }
  public resetLogType() {
    this._logType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get logTypeInput() {
    return this._logType;
  }

  // max_payload_events - computed: true, optional: true, required: false
  private _maxPayloadEvents?: number; 
  public get maxPayloadEvents() {
    return this.getNumberAttribute('max_payload_events');
  }
  public set maxPayloadEvents(value: number) {
    this._maxPayloadEvents = value;
  }
  public resetMaxPayloadEvents() {
    this._maxPayloadEvents = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxPayloadEventsInput() {
    return this._maxPayloadEvents;
  }

  // max_payload_size_kb - computed: true, optional: true, required: false
  private _maxPayloadSizeKb?: number; 
  public get maxPayloadSizeKb() {
    return this.getNumberAttribute('max_payload_size_kb');
  }
  public set maxPayloadSizeKb(value: number) {
    this._maxPayloadSizeKb = value;
  }
  public resetMaxPayloadSizeKb() {
    this._maxPayloadSizeKb = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxPayloadSizeKbInput() {
    return this._maxPayloadSizeKb;
  }

  // on_backpressure - computed: true, optional: true, required: false
  private _onBackpressure?: string; 
  public get onBackpressure() {
    return this.getStringAttribute('on_backpressure');
  }
  public set onBackpressure(value: string) {
    this._onBackpressure = value;
  }
  public resetOnBackpressure() {
    this._onBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get onBackpressureInput() {
    return this._onBackpressure;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // pq_compress - computed: true, optional: true, required: false
  private _pqCompress?: string; 
  public get pqCompress() {
    return this.getStringAttribute('pq_compress');
  }
  public set pqCompress(value: string) {
    this._pqCompress = value;
  }
  public resetPqCompress() {
    this._pqCompress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqCompressInput() {
    return this._pqCompress;
  }

  // pq_controls - computed: false, optional: true, required: false
  private _pqControls = new PackDestinationOutputAzureLogsPqControlsOutputReference(this, "pq_controls");
  public get pqControls() {
    return this._pqControls;
  }
  public putPqControls(value: PackDestinationOutputAzureLogsPqControls) {
    this._pqControls.internalValue = value;
  }
  public resetPqControls() {
    this._pqControls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqControlsInput() {
    return this._pqControls.internalValue;
  }

  // pq_max_file_size - computed: true, optional: true, required: false
  private _pqMaxFileSize?: string; 
  public get pqMaxFileSize() {
    return this.getStringAttribute('pq_max_file_size');
  }
  public set pqMaxFileSize(value: string) {
    this._pqMaxFileSize = value;
  }
  public resetPqMaxFileSize() {
    this._pqMaxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxFileSizeInput() {
    return this._pqMaxFileSize;
  }

  // pq_max_size - computed: true, optional: true, required: false
  private _pqMaxSize?: string; 
  public get pqMaxSize() {
    return this.getStringAttribute('pq_max_size');
  }
  public set pqMaxSize(value: string) {
    this._pqMaxSize = value;
  }
  public resetPqMaxSize() {
    this._pqMaxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxSizeInput() {
    return this._pqMaxSize;
  }

  // pq_mode - computed: true, optional: true, required: false
  private _pqMode?: string; 
  public get pqMode() {
    return this.getStringAttribute('pq_mode');
  }
  public set pqMode(value: string) {
    this._pqMode = value;
  }
  public resetPqMode() {
    this._pqMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqModeInput() {
    return this._pqMode;
  }

  // pq_on_backpressure - computed: true, optional: true, required: false
  private _pqOnBackpressure?: string; 
  public get pqOnBackpressure() {
    return this.getStringAttribute('pq_on_backpressure');
  }
  public set pqOnBackpressure(value: string) {
    this._pqOnBackpressure = value;
  }
  public resetPqOnBackpressure() {
    this._pqOnBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqOnBackpressureInput() {
    return this._pqOnBackpressure;
  }

  // pq_path - computed: true, optional: true, required: false
  private _pqPath?: string; 
  public get pqPath() {
    return this.getStringAttribute('pq_path');
  }
  public set pqPath(value: string) {
    this._pqPath = value;
  }
  public resetPqPath() {
    this._pqPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqPathInput() {
    return this._pqPath;
  }

  // reject_unauthorized - computed: true, optional: true, required: false
  private _rejectUnauthorized?: boolean | cdktf.IResolvable; 
  public get rejectUnauthorized() {
    return this.getBooleanAttribute('reject_unauthorized');
  }
  public set rejectUnauthorized(value: boolean | cdktf.IResolvable) {
    this._rejectUnauthorized = value;
  }
  public resetRejectUnauthorized() {
    this._rejectUnauthorized = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectUnauthorizedInput() {
    return this._rejectUnauthorized;
  }

  // resource_id - computed: false, optional: true, required: false
  private _resourceId?: string; 
  public get resourceId() {
    return this.getStringAttribute('resource_id');
  }
  public set resourceId(value: string) {
    this._resourceId = value;
  }
  public resetResourceId() {
    this._resourceId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get resourceIdInput() {
    return this._resourceId;
  }

  // response_honor_retry_after_header - computed: true, optional: true, required: false
  private _responseHonorRetryAfterHeader?: boolean | cdktf.IResolvable; 
  public get responseHonorRetryAfterHeader() {
    return this.getBooleanAttribute('response_honor_retry_after_header');
  }
  public set responseHonorRetryAfterHeader(value: boolean | cdktf.IResolvable) {
    this._responseHonorRetryAfterHeader = value;
  }
  public resetResponseHonorRetryAfterHeader() {
    this._responseHonorRetryAfterHeader = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get responseHonorRetryAfterHeaderInput() {
    return this._responseHonorRetryAfterHeader;
  }

  // response_retry_settings - computed: false, optional: true, required: false
  private _responseRetrySettings = new PackDestinationOutputAzureLogsResponseRetrySettingsList(this, "response_retry_settings", false);
  public get responseRetrySettings() {
    return this._responseRetrySettings;
  }
  public putResponseRetrySettings(value: PackDestinationOutputAzureLogsResponseRetrySettings[] | cdktf.IResolvable) {
    this._responseRetrySettings.internalValue = value;
  }
  public resetResponseRetrySettings() {
    this._responseRetrySettings.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get responseRetrySettingsInput() {
    return this._responseRetrySettings.internalValue;
  }

  // safe_headers - computed: true, optional: true, required: false
  private _safeHeaders?: string[]; 
  public get safeHeaders() {
    return this.getListAttribute('safe_headers');
  }
  public set safeHeaders(value: string[]) {
    this._safeHeaders = value;
  }
  public resetSafeHeaders() {
    this._safeHeaders = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get safeHeadersInput() {
    return this._safeHeaders;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // system_fields - computed: true, optional: true, required: false
  private _systemFields?: string[]; 
  public get systemFields() {
    return this.getListAttribute('system_fields');
  }
  public set systemFields(value: string[]) {
    this._systemFields = value;
  }
  public resetSystemFields() {
    this._systemFields = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get systemFieldsInput() {
    return this._systemFields;
  }

  // timeout_retry_settings - computed: false, optional: true, required: false
  private _timeoutRetrySettings = new PackDestinationOutputAzureLogsTimeoutRetrySettingsOutputReference(this, "timeout_retry_settings");
  public get timeoutRetrySettings() {
    return this._timeoutRetrySettings;
  }
  public putTimeoutRetrySettings(value: PackDestinationOutputAzureLogsTimeoutRetrySettings) {
    this._timeoutRetrySettings.internalValue = value;
  }
  public resetTimeoutRetrySettings() {
    this._timeoutRetrySettings.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutRetrySettingsInput() {
    return this._timeoutRetrySettings.internalValue;
  }

  // timeout_sec - computed: true, optional: true, required: false
  private _timeoutSec?: number; 
  public get timeoutSec() {
    return this.getNumberAttribute('timeout_sec');
  }
  public set timeoutSec(value: number) {
    this._timeoutSec = value;
  }
  public resetTimeoutSec() {
    this._timeoutSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutSecInput() {
    return this._timeoutSec;
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // use_round_robin_dns - computed: true, optional: true, required: false
  private _useRoundRobinDns?: boolean | cdktf.IResolvable; 
  public get useRoundRobinDns() {
    return this.getBooleanAttribute('use_round_robin_dns');
  }
  public set useRoundRobinDns(value: boolean | cdktf.IResolvable) {
    this._useRoundRobinDns = value;
  }
  public resetUseRoundRobinDns() {
    this._useRoundRobinDns = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get useRoundRobinDnsInput() {
    return this._useRoundRobinDns;
  }

  // workspace_id - computed: false, optional: true, required: false
  private _workspaceId?: string; 
  public get workspaceId() {
    return this.getStringAttribute('workspace_id');
  }
  public set workspaceId(value: string) {
    this._workspaceId = value;
  }
  public resetWorkspaceId() {
    this._workspaceId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get workspaceIdInput() {
    return this._workspaceId;
  }

  // workspace_key - computed: false, optional: true, required: false
  private _workspaceKey?: string; 
  public get workspaceKey() {
    return this.getStringAttribute('workspace_key');
  }
  public set workspaceKey(value: string) {
    this._workspaceKey = value;
  }
  public resetWorkspaceKey() {
    this._workspaceKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get workspaceKeyInput() {
    return this._workspaceKey;
  }
}
export interface PackDestinationOutputClickHouseColumnMappings {
  /**
  * Name of the column in ClickHouse that will store field value
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#column_name PackDestination#column_name}
  */
  readonly columnName: string;
  /**
  * Type of the column in the ClickHouse database
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#column_type PackDestination#column_type}
  */
  readonly columnType?: string;
  /**
  * JavaScript expression to compute value to be inserted into ClickHouse table
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#column_value_expression PackDestination#column_value_expression}
  */
  readonly columnValueExpression: string;
}

export function packDestinationOutputClickHouseColumnMappingsToTerraform(struct?: PackDestinationOutputClickHouseColumnMappings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    column_name: cdktf.stringToTerraform(struct!.columnName),
    column_type: cdktf.stringToTerraform(struct!.columnType),
    column_value_expression: cdktf.stringToTerraform(struct!.columnValueExpression),
  }
}


export function packDestinationOutputClickHouseColumnMappingsToHclTerraform(struct?: PackDestinationOutputClickHouseColumnMappings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    column_name: {
      value: cdktf.stringToHclTerraform(struct!.columnName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    column_type: {
      value: cdktf.stringToHclTerraform(struct!.columnType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    column_value_expression: {
      value: cdktf.stringToHclTerraform(struct!.columnValueExpression),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputClickHouseColumnMappingsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackDestinationOutputClickHouseColumnMappings | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._columnName !== undefined) {
      hasAnyValues = true;
      internalValueResult.columnName = this._columnName;
    }
    if (this._columnType !== undefined) {
      hasAnyValues = true;
      internalValueResult.columnType = this._columnType;
    }
    if (this._columnValueExpression !== undefined) {
      hasAnyValues = true;
      internalValueResult.columnValueExpression = this._columnValueExpression;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputClickHouseColumnMappings | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._columnName = undefined;
      this._columnType = undefined;
      this._columnValueExpression = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._columnName = value.columnName;
      this._columnType = value.columnType;
      this._columnValueExpression = value.columnValueExpression;
    }
  }

  // column_name - computed: false, optional: false, required: true
  private _columnName?: string; 
  public get columnName() {
    return this.getStringAttribute('column_name');
  }
  public set columnName(value: string) {
    this._columnName = value;
  }
  // Temporarily expose input value. Use with caution.
  public get columnNameInput() {
    return this._columnName;
  }

  // column_type - computed: false, optional: true, required: false
  private _columnType?: string; 
  public get columnType() {
    return this.getStringAttribute('column_type');
  }
  public set columnType(value: string) {
    this._columnType = value;
  }
  public resetColumnType() {
    this._columnType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get columnTypeInput() {
    return this._columnType;
  }

  // column_value_expression - computed: false, optional: false, required: true
  private _columnValueExpression?: string; 
  public get columnValueExpression() {
    return this.getStringAttribute('column_value_expression');
  }
  public set columnValueExpression(value: string) {
    this._columnValueExpression = value;
  }
  // Temporarily expose input value. Use with caution.
  public get columnValueExpressionInput() {
    return this._columnValueExpression;
  }
}

export class PackDestinationOutputClickHouseColumnMappingsList extends cdktf.ComplexList {
  public internalValue? : PackDestinationOutputClickHouseColumnMappings[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackDestinationOutputClickHouseColumnMappingsOutputReference {
    return new PackDestinationOutputClickHouseColumnMappingsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackDestinationOutputClickHouseExtraHttpHeaders {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#name PackDestination#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#value PackDestination#value}
  */
  readonly value: string;
}

export function packDestinationOutputClickHouseExtraHttpHeadersToTerraform(struct?: PackDestinationOutputClickHouseExtraHttpHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function packDestinationOutputClickHouseExtraHttpHeadersToHclTerraform(struct?: PackDestinationOutputClickHouseExtraHttpHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputClickHouseExtraHttpHeadersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackDestinationOutputClickHouseExtraHttpHeaders | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputClickHouseExtraHttpHeaders | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class PackDestinationOutputClickHouseExtraHttpHeadersList extends cdktf.ComplexList {
  public internalValue? : PackDestinationOutputClickHouseExtraHttpHeaders[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackDestinationOutputClickHouseExtraHttpHeadersOutputReference {
    return new PackDestinationOutputClickHouseExtraHttpHeadersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackDestinationOutputClickHouseOauthHeaders {
  /**
  * OAuth header name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#name PackDestination#name}
  */
  readonly name: string;
  /**
  * OAuth header value
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#value PackDestination#value}
  */
  readonly value: string;
}

export function packDestinationOutputClickHouseOauthHeadersToTerraform(struct?: PackDestinationOutputClickHouseOauthHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function packDestinationOutputClickHouseOauthHeadersToHclTerraform(struct?: PackDestinationOutputClickHouseOauthHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputClickHouseOauthHeadersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackDestinationOutputClickHouseOauthHeaders | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputClickHouseOauthHeaders | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class PackDestinationOutputClickHouseOauthHeadersList extends cdktf.ComplexList {
  public internalValue? : PackDestinationOutputClickHouseOauthHeaders[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackDestinationOutputClickHouseOauthHeadersOutputReference {
    return new PackDestinationOutputClickHouseOauthHeadersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackDestinationOutputClickHouseOauthParams {
  /**
  * OAuth parameter name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#name PackDestination#name}
  */
  readonly name: string;
  /**
  * OAuth parameter value
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#value PackDestination#value}
  */
  readonly value: string;
}

export function packDestinationOutputClickHouseOauthParamsToTerraform(struct?: PackDestinationOutputClickHouseOauthParams | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function packDestinationOutputClickHouseOauthParamsToHclTerraform(struct?: PackDestinationOutputClickHouseOauthParams | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputClickHouseOauthParamsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackDestinationOutputClickHouseOauthParams | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputClickHouseOauthParams | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class PackDestinationOutputClickHouseOauthParamsList extends cdktf.ComplexList {
  public internalValue? : PackDestinationOutputClickHouseOauthParams[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackDestinationOutputClickHouseOauthParamsOutputReference {
    return new PackDestinationOutputClickHouseOauthParamsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackDestinationOutputClickHousePqControls {
}

export function packDestinationOutputClickHousePqControlsToTerraform(struct?: PackDestinationOutputClickHousePqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function packDestinationOutputClickHousePqControlsToHclTerraform(struct?: PackDestinationOutputClickHousePqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class PackDestinationOutputClickHousePqControlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackDestinationOutputClickHousePqControls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputClickHousePqControls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface PackDestinationOutputClickHouseResponseRetrySettings {
  /**
  * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc. Default: 2
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#backoff_rate PackDestination#backoff_rate}
  */
  readonly backoffRate?: number;
  /**
  * The HTTP response status code that will trigger retries
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#http_status PackDestination#http_status}
  */
  readonly httpStatus: number;
  /**
  * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes). Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#initial_backoff PackDestination#initial_backoff}
  */
  readonly initialBackoff?: number;
  /**
  * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds). Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_backoff PackDestination#max_backoff}
  */
  readonly maxBackoff?: number;
}

export function packDestinationOutputClickHouseResponseRetrySettingsToTerraform(struct?: PackDestinationOutputClickHouseResponseRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    backoff_rate: cdktf.numberToTerraform(struct!.backoffRate),
    http_status: cdktf.numberToTerraform(struct!.httpStatus),
    initial_backoff: cdktf.numberToTerraform(struct!.initialBackoff),
    max_backoff: cdktf.numberToTerraform(struct!.maxBackoff),
  }
}


export function packDestinationOutputClickHouseResponseRetrySettingsToHclTerraform(struct?: PackDestinationOutputClickHouseResponseRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    backoff_rate: {
      value: cdktf.numberToHclTerraform(struct!.backoffRate),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    http_status: {
      value: cdktf.numberToHclTerraform(struct!.httpStatus),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    initial_backoff: {
      value: cdktf.numberToHclTerraform(struct!.initialBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_backoff: {
      value: cdktf.numberToHclTerraform(struct!.maxBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputClickHouseResponseRetrySettingsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackDestinationOutputClickHouseResponseRetrySettings | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._backoffRate !== undefined) {
      hasAnyValues = true;
      internalValueResult.backoffRate = this._backoffRate;
    }
    if (this._httpStatus !== undefined) {
      hasAnyValues = true;
      internalValueResult.httpStatus = this._httpStatus;
    }
    if (this._initialBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.initialBackoff = this._initialBackoff;
    }
    if (this._maxBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBackoff = this._maxBackoff;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputClickHouseResponseRetrySettings | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._backoffRate = undefined;
      this._httpStatus = undefined;
      this._initialBackoff = undefined;
      this._maxBackoff = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._backoffRate = value.backoffRate;
      this._httpStatus = value.httpStatus;
      this._initialBackoff = value.initialBackoff;
      this._maxBackoff = value.maxBackoff;
    }
  }

  // backoff_rate - computed: true, optional: true, required: false
  private _backoffRate?: number; 
  public get backoffRate() {
    return this.getNumberAttribute('backoff_rate');
  }
  public set backoffRate(value: number) {
    this._backoffRate = value;
  }
  public resetBackoffRate() {
    this._backoffRate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get backoffRateInput() {
    return this._backoffRate;
  }

  // http_status - computed: false, optional: false, required: true
  private _httpStatus?: number; 
  public get httpStatus() {
    return this.getNumberAttribute('http_status');
  }
  public set httpStatus(value: number) {
    this._httpStatus = value;
  }
  // Temporarily expose input value. Use with caution.
  public get httpStatusInput() {
    return this._httpStatus;
  }

  // initial_backoff - computed: true, optional: true, required: false
  private _initialBackoff?: number; 
  public get initialBackoff() {
    return this.getNumberAttribute('initial_backoff');
  }
  public set initialBackoff(value: number) {
    this._initialBackoff = value;
  }
  public resetInitialBackoff() {
    this._initialBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get initialBackoffInput() {
    return this._initialBackoff;
  }

  // max_backoff - computed: true, optional: true, required: false
  private _maxBackoff?: number; 
  public get maxBackoff() {
    return this.getNumberAttribute('max_backoff');
  }
  public set maxBackoff(value: number) {
    this._maxBackoff = value;
  }
  public resetMaxBackoff() {
    this._maxBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBackoffInput() {
    return this._maxBackoff;
  }
}

export class PackDestinationOutputClickHouseResponseRetrySettingsList extends cdktf.ComplexList {
  public internalValue? : PackDestinationOutputClickHouseResponseRetrySettings[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackDestinationOutputClickHouseResponseRetrySettingsOutputReference {
    return new PackDestinationOutputClickHouseResponseRetrySettingsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackDestinationOutputClickHouseTimeoutRetrySettings {
  /**
  * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc. Default: 2
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#backoff_rate PackDestination#backoff_rate}
  */
  readonly backoffRate?: number;
  /**
  * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes). Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#initial_backoff PackDestination#initial_backoff}
  */
  readonly initialBackoff?: number;
  /**
  * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds). Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_backoff PackDestination#max_backoff}
  */
  readonly maxBackoff?: number;
  /**
  * Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#timeout_retry PackDestination#timeout_retry}
  */
  readonly timeoutRetry?: boolean | cdktf.IResolvable;
}

export function packDestinationOutputClickHouseTimeoutRetrySettingsToTerraform(struct?: PackDestinationOutputClickHouseTimeoutRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    backoff_rate: cdktf.numberToTerraform(struct!.backoffRate),
    initial_backoff: cdktf.numberToTerraform(struct!.initialBackoff),
    max_backoff: cdktf.numberToTerraform(struct!.maxBackoff),
    timeout_retry: cdktf.booleanToTerraform(struct!.timeoutRetry),
  }
}


export function packDestinationOutputClickHouseTimeoutRetrySettingsToHclTerraform(struct?: PackDestinationOutputClickHouseTimeoutRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    backoff_rate: {
      value: cdktf.numberToHclTerraform(struct!.backoffRate),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    initial_backoff: {
      value: cdktf.numberToHclTerraform(struct!.initialBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_backoff: {
      value: cdktf.numberToHclTerraform(struct!.maxBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    timeout_retry: {
      value: cdktf.booleanToHclTerraform(struct!.timeoutRetry),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputClickHouseTimeoutRetrySettingsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackDestinationOutputClickHouseTimeoutRetrySettings | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._backoffRate !== undefined) {
      hasAnyValues = true;
      internalValueResult.backoffRate = this._backoffRate;
    }
    if (this._initialBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.initialBackoff = this._initialBackoff;
    }
    if (this._maxBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBackoff = this._maxBackoff;
    }
    if (this._timeoutRetry !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutRetry = this._timeoutRetry;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputClickHouseTimeoutRetrySettings | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._backoffRate = undefined;
      this._initialBackoff = undefined;
      this._maxBackoff = undefined;
      this._timeoutRetry = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._backoffRate = value.backoffRate;
      this._initialBackoff = value.initialBackoff;
      this._maxBackoff = value.maxBackoff;
      this._timeoutRetry = value.timeoutRetry;
    }
  }

  // backoff_rate - computed: true, optional: true, required: false
  private _backoffRate?: number; 
  public get backoffRate() {
    return this.getNumberAttribute('backoff_rate');
  }
  public set backoffRate(value: number) {
    this._backoffRate = value;
  }
  public resetBackoffRate() {
    this._backoffRate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get backoffRateInput() {
    return this._backoffRate;
  }

  // initial_backoff - computed: true, optional: true, required: false
  private _initialBackoff?: number; 
  public get initialBackoff() {
    return this.getNumberAttribute('initial_backoff');
  }
  public set initialBackoff(value: number) {
    this._initialBackoff = value;
  }
  public resetInitialBackoff() {
    this._initialBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get initialBackoffInput() {
    return this._initialBackoff;
  }

  // max_backoff - computed: true, optional: true, required: false
  private _maxBackoff?: number; 
  public get maxBackoff() {
    return this.getNumberAttribute('max_backoff');
  }
  public set maxBackoff(value: number) {
    this._maxBackoff = value;
  }
  public resetMaxBackoff() {
    this._maxBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBackoffInput() {
    return this._maxBackoff;
  }

  // timeout_retry - computed: true, optional: true, required: false
  private _timeoutRetry?: boolean | cdktf.IResolvable; 
  public get timeoutRetry() {
    return this.getBooleanAttribute('timeout_retry');
  }
  public set timeoutRetry(value: boolean | cdktf.IResolvable) {
    this._timeoutRetry = value;
  }
  public resetTimeoutRetry() {
    this._timeoutRetry = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutRetryInput() {
    return this._timeoutRetry;
  }
}
export interface PackDestinationOutputClickHouseTls {
  /**
  * Path on client in which to find CA certificates to verify the server's cert. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#ca_path PackDestination#ca_path}
  */
  readonly caPath?: string;
  /**
  * Path on client in which to find certificates to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#cert_path PackDestination#cert_path}
  */
  readonly certPath?: string;
  /**
  * The name of the predefined certificate
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#certificate_name PackDestination#certificate_name}
  */
  readonly certificateName?: string;
  /**
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#disabled PackDestination#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_version PackDestination#max_version}
  */
  readonly maxVersion?: string;
  /**
  * must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#min_version PackDestination#min_version}
  */
  readonly minVersion?: string;
  /**
  * Passphrase to use to decrypt private key
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#passphrase PackDestination#passphrase}
  */
  readonly passphrase?: string;
  /**
  * Path on client in which to find the private key to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#priv_key_path PackDestination#priv_key_path}
  */
  readonly privKeyPath?: string;
  /**
  * Server name for the SNI (Server Name Indication) TLS extension. It must be a host name, and not an IP address.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#servername PackDestination#servername}
  */
  readonly servername?: string;
}

export function packDestinationOutputClickHouseTlsToTerraform(struct?: PackDestinationOutputClickHouseTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ca_path: cdktf.stringToTerraform(struct!.caPath),
    cert_path: cdktf.stringToTerraform(struct!.certPath),
    certificate_name: cdktf.stringToTerraform(struct!.certificateName),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    max_version: cdktf.stringToTerraform(struct!.maxVersion),
    min_version: cdktf.stringToTerraform(struct!.minVersion),
    passphrase: cdktf.stringToTerraform(struct!.passphrase),
    priv_key_path: cdktf.stringToTerraform(struct!.privKeyPath),
    servername: cdktf.stringToTerraform(struct!.servername),
  }
}


export function packDestinationOutputClickHouseTlsToHclTerraform(struct?: PackDestinationOutputClickHouseTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ca_path: {
      value: cdktf.stringToHclTerraform(struct!.caPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    cert_path: {
      value: cdktf.stringToHclTerraform(struct!.certPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    certificate_name: {
      value: cdktf.stringToHclTerraform(struct!.certificateName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    max_version: {
      value: cdktf.stringToHclTerraform(struct!.maxVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    min_version: {
      value: cdktf.stringToHclTerraform(struct!.minVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    passphrase: {
      value: cdktf.stringToHclTerraform(struct!.passphrase),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    priv_key_path: {
      value: cdktf.stringToHclTerraform(struct!.privKeyPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    servername: {
      value: cdktf.stringToHclTerraform(struct!.servername),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputClickHouseTlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackDestinationOutputClickHouseTls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._caPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.caPath = this._caPath;
    }
    if (this._certPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.certPath = this._certPath;
    }
    if (this._certificateName !== undefined) {
      hasAnyValues = true;
      internalValueResult.certificateName = this._certificateName;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._maxVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxVersion = this._maxVersion;
    }
    if (this._minVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.minVersion = this._minVersion;
    }
    if (this._passphrase !== undefined) {
      hasAnyValues = true;
      internalValueResult.passphrase = this._passphrase;
    }
    if (this._privKeyPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.privKeyPath = this._privKeyPath;
    }
    if (this._servername !== undefined) {
      hasAnyValues = true;
      internalValueResult.servername = this._servername;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputClickHouseTls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._caPath = undefined;
      this._certPath = undefined;
      this._certificateName = undefined;
      this._disabled = undefined;
      this._maxVersion = undefined;
      this._minVersion = undefined;
      this._passphrase = undefined;
      this._privKeyPath = undefined;
      this._servername = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._caPath = value.caPath;
      this._certPath = value.certPath;
      this._certificateName = value.certificateName;
      this._disabled = value.disabled;
      this._maxVersion = value.maxVersion;
      this._minVersion = value.minVersion;
      this._passphrase = value.passphrase;
      this._privKeyPath = value.privKeyPath;
      this._servername = value.servername;
    }
  }

  // ca_path - computed: false, optional: true, required: false
  private _caPath?: string; 
  public get caPath() {
    return this.getStringAttribute('ca_path');
  }
  public set caPath(value: string) {
    this._caPath = value;
  }
  public resetCaPath() {
    this._caPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get caPathInput() {
    return this._caPath;
  }

  // cert_path - computed: false, optional: true, required: false
  private _certPath?: string; 
  public get certPath() {
    return this.getStringAttribute('cert_path');
  }
  public set certPath(value: string) {
    this._certPath = value;
  }
  public resetCertPath() {
    this._certPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certPathInput() {
    return this._certPath;
  }

  // certificate_name - computed: false, optional: true, required: false
  private _certificateName?: string; 
  public get certificateName() {
    return this.getStringAttribute('certificate_name');
  }
  public set certificateName(value: string) {
    this._certificateName = value;
  }
  public resetCertificateName() {
    this._certificateName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certificateNameInput() {
    return this._certificateName;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // max_version - computed: false, optional: true, required: false
  private _maxVersion?: string; 
  public get maxVersion() {
    return this.getStringAttribute('max_version');
  }
  public set maxVersion(value: string) {
    this._maxVersion = value;
  }
  public resetMaxVersion() {
    this._maxVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxVersionInput() {
    return this._maxVersion;
  }

  // min_version - computed: false, optional: true, required: false
  private _minVersion?: string; 
  public get minVersion() {
    return this.getStringAttribute('min_version');
  }
  public set minVersion(value: string) {
    this._minVersion = value;
  }
  public resetMinVersion() {
    this._minVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get minVersionInput() {
    return this._minVersion;
  }

  // passphrase - computed: false, optional: true, required: false
  private _passphrase?: string; 
  public get passphrase() {
    return this.getStringAttribute('passphrase');
  }
  public set passphrase(value: string) {
    this._passphrase = value;
  }
  public resetPassphrase() {
    this._passphrase = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passphraseInput() {
    return this._passphrase;
  }

  // priv_key_path - computed: false, optional: true, required: false
  private _privKeyPath?: string; 
  public get privKeyPath() {
    return this.getStringAttribute('priv_key_path');
  }
  public set privKeyPath(value: string) {
    this._privKeyPath = value;
  }
  public resetPrivKeyPath() {
    this._privKeyPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get privKeyPathInput() {
    return this._privKeyPath;
  }

  // servername - computed: false, optional: true, required: false
  private _servername?: string; 
  public get servername() {
    return this.getStringAttribute('servername');
  }
  public set servername(value: string) {
    this._servername = value;
  }
  public resetServername() {
    this._servername = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get servernameInput() {
    return this._servername;
  }
}
export interface PackDestinationOutputClickHouse {
  /**
  * Collect data into batches for later processing. Disable to write to a ClickHouse table immediately. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#async_inserts PackDestination#async_inserts}
  */
  readonly asyncInserts?: boolean | cdktf.IResolvable;
  /**
  * JavaScript expression to compute the Authorization header value to pass in requests. The value `${token}` is used to reference the token obtained from authentication, e.g.: `Bearer ${token}`. Default: "`Bearer ${token}`"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#auth_header_expr PackDestination#auth_header_expr}
  */
  readonly authHeaderExpr?: string;
  /**
  * Default: "none"; must be one of ["none", "basic", "credentialsSecret", "sslUserCertificate", "token", "textSecret", "oauth"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#auth_type PackDestination#auth_type}
  */
  readonly authType?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#column_mappings PackDestination#column_mappings}
  */
  readonly columnMappings?: PackDestinationOutputClickHouseColumnMappings[] | cdktf.IResolvable;
  /**
  * Compress the payload body before sending. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#compress PackDestination#compress}
  */
  readonly compress?: boolean | cdktf.IResolvable;
  /**
  * Maximum number of ongoing requests before blocking. Default: 5
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#concurrency PackDestination#concurrency}
  */
  readonly concurrency?: number;
  /**
  * Select or create a secret that references your credentials
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#credentials_secret PackDestination#credentials_secret}
  */
  readonly credentialsSecret?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#database PackDestination#database}
  */
  readonly database: string;
  /**
  * Retrieves the table schema from ClickHouse and populates the Column Mapping table
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#describe_table PackDestination#describe_table}
  */
  readonly describeTable?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#description PackDestination#description}
  */
  readonly description?: string;
  /**
  * Log the most recent event that fails to match the table schema. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#dump_format_errors_to_disk PackDestination#dump_format_errors_to_disk}
  */
  readonly dumpFormatErrorsToDisk?: boolean | cdktf.IResolvable;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#environment PackDestination#environment}
  */
  readonly environment?: string;
  /**
  * Fields to exclude from sending to ClickHouse. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#exclude_mapping_fields PackDestination#exclude_mapping_fields}
  */
  readonly excludeMappingFields?: string[];
  /**
  * Headers to add to all events
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#extra_http_headers PackDestination#extra_http_headers}
  */
  readonly extraHttpHeaders?: PackDestinationOutputClickHouseExtraHttpHeaders[] | cdktf.IResolvable;
  /**
  * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below. Default: "none"; must be one of ["payload", "payloadAndHeaders", "none"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#failed_request_logging_mode PackDestination#failed_request_logging_mode}
  */
  readonly failedRequestLoggingMode?: string;
  /**
  * Maximum time between requests. Small values could cause the payload size to be smaller than the configured Body size limit. Default: 1
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#flush_period_sec PackDestination#flush_period_sec}
  */
  readonly flushPeriodSec?: number;
  /**
  * Data format to use when sending data to ClickHouse. Defaults to JSON Compact. Default: "json-compact-each-row-with-names"; must be one of ["json-compact-each-row-with-names", "json-each-row"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#format PackDestination#format}
  */
  readonly format?: string;
  /**
  * Unique ID for this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#id PackDestination#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * URL for OAuth
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#login_url PackDestination#login_url}
  */
  readonly loginUrl?: string;
  /**
  * How event fields are mapped to ClickHouse columns. Default: "automatic"; must be one of ["automatic", "custom"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#mapping_type PackDestination#mapping_type}
  */
  readonly mappingType?: string;
  /**
  * Maximum number of events to include in the request body. Default is 0 (unlimited). Default: 0
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_payload_events PackDestination#max_payload_events}
  */
  readonly maxPayloadEvents?: number;
  /**
  * Maximum size, in KB, of the request body. Default: 4096
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_payload_size_kb PackDestination#max_payload_size_kb}
  */
  readonly maxPayloadSizeKb?: number;
  /**
  * Additional headers to send in the OAuth login request. @{product} will automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#oauth_headers PackDestination#oauth_headers}
  */
  readonly oauthHeaders?: PackDestinationOutputClickHouseOauthHeaders[] | cdktf.IResolvable;
  /**
  * Additional parameters to send in the OAuth login request. @{product} will combine the secret with these parameters, and will send the URL-encoded result in a POST request to the endpoint specified in the 'Login URL'. We'll automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#oauth_params PackDestination#oauth_params}
  */
  readonly oauthParams?: PackDestinationOutputClickHouseOauthParams[] | cdktf.IResolvable;
  /**
  * How to handle events when all receivers are exerting backpressure. Default: "block"; must be one of ["block", "drop", "queue"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#on_backpressure PackDestination#on_backpressure}
  */
  readonly onBackpressure?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#password PackDestination#password}
  */
  readonly password?: string;
  /**
  * Pipeline to process data before sending out to this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pipeline PackDestination#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_compress PackDestination#pq_compress}
  */
  readonly pqCompress?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_controls PackDestination#pq_controls}
  */
  readonly pqControls?: PackDestinationOutputClickHousePqControls;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.). Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_max_file_size PackDestination#pq_max_file_size}
  */
  readonly pqMaxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_max_size PackDestination#pq_max_size}
  */
  readonly pqMaxSize?: string;
  /**
  * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem. Default: "error"; must be one of ["error", "backpressure", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_mode PackDestination#pq_mode}
  */
  readonly pqMode?: string;
  /**
  * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged. Default: "block"; must be one of ["block", "drop"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_on_backpressure PackDestination#pq_on_backpressure}
  */
  readonly pqOnBackpressure?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_path PackDestination#pq_path}
  */
  readonly pqPath?: string;
  /**
  * Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's).
  * 
  * 
  *         Enabled by default. When this setting is also present in TLS Settings (Client Side),
  *         that value will take precedence.
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#reject_unauthorized PackDestination#reject_unauthorized}
  */
  readonly rejectUnauthorized?: boolean | cdktf.IResolvable;
  /**
  * Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#response_honor_retry_after_header PackDestination#response_honor_retry_after_header}
  */
  readonly responseHonorRetryAfterHeader?: boolean | cdktf.IResolvable;
  /**
  * Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#response_retry_settings PackDestination#response_retry_settings}
  */
  readonly responseRetrySettings?: PackDestinationOutputClickHouseResponseRetrySettings[] | cdktf.IResolvable;
  /**
  * List of headers that are safe to log in plain text. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#safe_headers PackDestination#safe_headers}
  */
  readonly safeHeaders?: string[];
  /**
  * Secret parameter value to pass in request body
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#secret PackDestination#secret}
  */
  readonly secret?: string;
  /**
  * Secret parameter name to pass in request body
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#secret_param_name PackDestination#secret_param_name}
  */
  readonly secretParamName?: string;
  /**
  * Username for certificate authentication
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#sql_username PackDestination#sql_username}
  */
  readonly sqlUsername?: string;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#streamtags PackDestination#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Fields to automatically add to events, such as cribl_pipe. Supports wildcards. Default: ["cribl_pipe"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#system_fields PackDestination#system_fields}
  */
  readonly systemFields?: string[];
  /**
  * Name of the ClickHouse table where data will be inserted. Name can contain letters (A-Z, a-z), numbers (0-9), and the character "_", and must start with either a letter or the character "_".
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#table_name PackDestination#table_name}
  */
  readonly tableName: string;
  /**
  * Select or create a stored text secret
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#text_secret PackDestination#text_secret}
  */
  readonly textSecret?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#timeout_retry_settings PackDestination#timeout_retry_settings}
  */
  readonly timeoutRetrySettings?: PackDestinationOutputClickHouseTimeoutRetrySettings;
  /**
  * Amount of time, in seconds, to wait for a request to complete before canceling it. Default: 30
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#timeout_sec PackDestination#timeout_sec}
  */
  readonly timeoutSec?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#tls PackDestination#tls}
  */
  readonly tls?: PackDestinationOutputClickHouseTls;
  /**
  * Bearer token to include in the authorization header
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#token PackDestination#token}
  */
  readonly token?: string;
  /**
  * Name of the auth token attribute in the OAuth response. Can be top-level (e.g., 'token'); or nested, using a period (e.g., 'data.token').
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#token_attribute_name PackDestination#token_attribute_name}
  */
  readonly tokenAttributeName?: string;
  /**
  * How often the OAuth token should be refreshed. Default: 3600
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#token_timeout_secs PackDestination#token_timeout_secs}
  */
  readonly tokenTimeoutSecs?: number;
  /**
  * must be "click_house"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#type PackDestination#type}
  */
  readonly type?: string;
  /**
  * URL of the ClickHouse instance. Example: http://localhost:8123/
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#url PackDestination#url}
  */
  readonly url: string;
  /**
  * Enable round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. For optimal performance, consider enabling this setting for non-load balanced destinations. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#use_round_robin_dns PackDestination#use_round_robin_dns}
  */
  readonly useRoundRobinDns?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#username PackDestination#username}
  */
  readonly username?: string;
  /**
  * Cribl will wait for confirmation that data has been fully inserted into the ClickHouse database before proceeding. Disabling this option can increase throughput, but Cribl won’t be able to verify data has been completely inserted. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#wait_for_async_inserts PackDestination#wait_for_async_inserts}
  */
  readonly waitForAsyncInserts?: boolean | cdktf.IResolvable;
}

export function packDestinationOutputClickHouseToTerraform(struct?: PackDestinationOutputClickHouse | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    async_inserts: cdktf.booleanToTerraform(struct!.asyncInserts),
    auth_header_expr: cdktf.stringToTerraform(struct!.authHeaderExpr),
    auth_type: cdktf.stringToTerraform(struct!.authType),
    column_mappings: cdktf.listMapper(packDestinationOutputClickHouseColumnMappingsToTerraform, false)(struct!.columnMappings),
    compress: cdktf.booleanToTerraform(struct!.compress),
    concurrency: cdktf.numberToTerraform(struct!.concurrency),
    credentials_secret: cdktf.stringToTerraform(struct!.credentialsSecret),
    database: cdktf.stringToTerraform(struct!.database),
    describe_table: cdktf.stringToTerraform(struct!.describeTable),
    description: cdktf.stringToTerraform(struct!.description),
    dump_format_errors_to_disk: cdktf.booleanToTerraform(struct!.dumpFormatErrorsToDisk),
    environment: cdktf.stringToTerraform(struct!.environment),
    exclude_mapping_fields: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.excludeMappingFields),
    extra_http_headers: cdktf.listMapper(packDestinationOutputClickHouseExtraHttpHeadersToTerraform, false)(struct!.extraHttpHeaders),
    failed_request_logging_mode: cdktf.stringToTerraform(struct!.failedRequestLoggingMode),
    flush_period_sec: cdktf.numberToTerraform(struct!.flushPeriodSec),
    format: cdktf.stringToTerraform(struct!.format),
    id: cdktf.stringToTerraform(struct!.id),
    login_url: cdktf.stringToTerraform(struct!.loginUrl),
    mapping_type: cdktf.stringToTerraform(struct!.mappingType),
    max_payload_events: cdktf.numberToTerraform(struct!.maxPayloadEvents),
    max_payload_size_kb: cdktf.numberToTerraform(struct!.maxPayloadSizeKb),
    oauth_headers: cdktf.listMapper(packDestinationOutputClickHouseOauthHeadersToTerraform, false)(struct!.oauthHeaders),
    oauth_params: cdktf.listMapper(packDestinationOutputClickHouseOauthParamsToTerraform, false)(struct!.oauthParams),
    on_backpressure: cdktf.stringToTerraform(struct!.onBackpressure),
    password: cdktf.stringToTerraform(struct!.password),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    pq_compress: cdktf.stringToTerraform(struct!.pqCompress),
    pq_controls: packDestinationOutputClickHousePqControlsToTerraform(struct!.pqControls),
    pq_max_file_size: cdktf.stringToTerraform(struct!.pqMaxFileSize),
    pq_max_size: cdktf.stringToTerraform(struct!.pqMaxSize),
    pq_mode: cdktf.stringToTerraform(struct!.pqMode),
    pq_on_backpressure: cdktf.stringToTerraform(struct!.pqOnBackpressure),
    pq_path: cdktf.stringToTerraform(struct!.pqPath),
    reject_unauthorized: cdktf.booleanToTerraform(struct!.rejectUnauthorized),
    response_honor_retry_after_header: cdktf.booleanToTerraform(struct!.responseHonorRetryAfterHeader),
    response_retry_settings: cdktf.listMapper(packDestinationOutputClickHouseResponseRetrySettingsToTerraform, false)(struct!.responseRetrySettings),
    safe_headers: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.safeHeaders),
    secret: cdktf.stringToTerraform(struct!.secret),
    secret_param_name: cdktf.stringToTerraform(struct!.secretParamName),
    sql_username: cdktf.stringToTerraform(struct!.sqlUsername),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    system_fields: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.systemFields),
    table_name: cdktf.stringToTerraform(struct!.tableName),
    text_secret: cdktf.stringToTerraform(struct!.textSecret),
    timeout_retry_settings: packDestinationOutputClickHouseTimeoutRetrySettingsToTerraform(struct!.timeoutRetrySettings),
    timeout_sec: cdktf.numberToTerraform(struct!.timeoutSec),
    tls: packDestinationOutputClickHouseTlsToTerraform(struct!.tls),
    token: cdktf.stringToTerraform(struct!.token),
    token_attribute_name: cdktf.stringToTerraform(struct!.tokenAttributeName),
    token_timeout_secs: cdktf.numberToTerraform(struct!.tokenTimeoutSecs),
    type: cdktf.stringToTerraform(struct!.type),
    url: cdktf.stringToTerraform(struct!.url),
    use_round_robin_dns: cdktf.booleanToTerraform(struct!.useRoundRobinDns),
    username: cdktf.stringToTerraform(struct!.username),
    wait_for_async_inserts: cdktf.booleanToTerraform(struct!.waitForAsyncInserts),
  }
}


export function packDestinationOutputClickHouseToHclTerraform(struct?: PackDestinationOutputClickHouse | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    async_inserts: {
      value: cdktf.booleanToHclTerraform(struct!.asyncInserts),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    auth_header_expr: {
      value: cdktf.stringToHclTerraform(struct!.authHeaderExpr),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    auth_type: {
      value: cdktf.stringToHclTerraform(struct!.authType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    column_mappings: {
      value: cdktf.listMapperHcl(packDestinationOutputClickHouseColumnMappingsToHclTerraform, false)(struct!.columnMappings),
      isBlock: true,
      type: "list",
      storageClassType: "PackDestinationOutputClickHouseColumnMappingsList",
    },
    compress: {
      value: cdktf.booleanToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    concurrency: {
      value: cdktf.numberToHclTerraform(struct!.concurrency),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    credentials_secret: {
      value: cdktf.stringToHclTerraform(struct!.credentialsSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    database: {
      value: cdktf.stringToHclTerraform(struct!.database),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    describe_table: {
      value: cdktf.stringToHclTerraform(struct!.describeTable),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    dump_format_errors_to_disk: {
      value: cdktf.booleanToHclTerraform(struct!.dumpFormatErrorsToDisk),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    exclude_mapping_fields: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.excludeMappingFields),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    extra_http_headers: {
      value: cdktf.listMapperHcl(packDestinationOutputClickHouseExtraHttpHeadersToHclTerraform, false)(struct!.extraHttpHeaders),
      isBlock: true,
      type: "list",
      storageClassType: "PackDestinationOutputClickHouseExtraHttpHeadersList",
    },
    failed_request_logging_mode: {
      value: cdktf.stringToHclTerraform(struct!.failedRequestLoggingMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    flush_period_sec: {
      value: cdktf.numberToHclTerraform(struct!.flushPeriodSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    format: {
      value: cdktf.stringToHclTerraform(struct!.format),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    login_url: {
      value: cdktf.stringToHclTerraform(struct!.loginUrl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    mapping_type: {
      value: cdktf.stringToHclTerraform(struct!.mappingType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_payload_events: {
      value: cdktf.numberToHclTerraform(struct!.maxPayloadEvents),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_payload_size_kb: {
      value: cdktf.numberToHclTerraform(struct!.maxPayloadSizeKb),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    oauth_headers: {
      value: cdktf.listMapperHcl(packDestinationOutputClickHouseOauthHeadersToHclTerraform, false)(struct!.oauthHeaders),
      isBlock: true,
      type: "list",
      storageClassType: "PackDestinationOutputClickHouseOauthHeadersList",
    },
    oauth_params: {
      value: cdktf.listMapperHcl(packDestinationOutputClickHouseOauthParamsToHclTerraform, false)(struct!.oauthParams),
      isBlock: true,
      type: "list",
      storageClassType: "PackDestinationOutputClickHouseOauthParamsList",
    },
    on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.onBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    password: {
      value: cdktf.stringToHclTerraform(struct!.password),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_compress: {
      value: cdktf.stringToHclTerraform(struct!.pqCompress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_controls: {
      value: packDestinationOutputClickHousePqControlsToHclTerraform(struct!.pqControls),
      isBlock: true,
      type: "struct",
      storageClassType: "PackDestinationOutputClickHousePqControls",
    },
    pq_max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_max_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_mode: {
      value: cdktf.stringToHclTerraform(struct!.pqMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.pqOnBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_path: {
      value: cdktf.stringToHclTerraform(struct!.pqPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reject_unauthorized: {
      value: cdktf.booleanToHclTerraform(struct!.rejectUnauthorized),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    response_honor_retry_after_header: {
      value: cdktf.booleanToHclTerraform(struct!.responseHonorRetryAfterHeader),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    response_retry_settings: {
      value: cdktf.listMapperHcl(packDestinationOutputClickHouseResponseRetrySettingsToHclTerraform, false)(struct!.responseRetrySettings),
      isBlock: true,
      type: "list",
      storageClassType: "PackDestinationOutputClickHouseResponseRetrySettingsList",
    },
    safe_headers: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.safeHeaders),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    secret: {
      value: cdktf.stringToHclTerraform(struct!.secret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_param_name: {
      value: cdktf.stringToHclTerraform(struct!.secretParamName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    sql_username: {
      value: cdktf.stringToHclTerraform(struct!.sqlUsername),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    system_fields: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.systemFields),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    table_name: {
      value: cdktf.stringToHclTerraform(struct!.tableName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    text_secret: {
      value: cdktf.stringToHclTerraform(struct!.textSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    timeout_retry_settings: {
      value: packDestinationOutputClickHouseTimeoutRetrySettingsToHclTerraform(struct!.timeoutRetrySettings),
      isBlock: true,
      type: "struct",
      storageClassType: "PackDestinationOutputClickHouseTimeoutRetrySettings",
    },
    timeout_sec: {
      value: cdktf.numberToHclTerraform(struct!.timeoutSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    tls: {
      value: packDestinationOutputClickHouseTlsToHclTerraform(struct!.tls),
      isBlock: true,
      type: "struct",
      storageClassType: "PackDestinationOutputClickHouseTls",
    },
    token: {
      value: cdktf.stringToHclTerraform(struct!.token),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    token_attribute_name: {
      value: cdktf.stringToHclTerraform(struct!.tokenAttributeName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    token_timeout_secs: {
      value: cdktf.numberToHclTerraform(struct!.tokenTimeoutSecs),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    url: {
      value: cdktf.stringToHclTerraform(struct!.url),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    use_round_robin_dns: {
      value: cdktf.booleanToHclTerraform(struct!.useRoundRobinDns),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    username: {
      value: cdktf.stringToHclTerraform(struct!.username),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    wait_for_async_inserts: {
      value: cdktf.booleanToHclTerraform(struct!.waitForAsyncInserts),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputClickHouseOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackDestinationOutputClickHouse | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._asyncInserts !== undefined) {
      hasAnyValues = true;
      internalValueResult.asyncInserts = this._asyncInserts;
    }
    if (this._authHeaderExpr !== undefined) {
      hasAnyValues = true;
      internalValueResult.authHeaderExpr = this._authHeaderExpr;
    }
    if (this._authType !== undefined) {
      hasAnyValues = true;
      internalValueResult.authType = this._authType;
    }
    if (this._columnMappings?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.columnMappings = this._columnMappings?.internalValue;
    }
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._concurrency !== undefined) {
      hasAnyValues = true;
      internalValueResult.concurrency = this._concurrency;
    }
    if (this._credentialsSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.credentialsSecret = this._credentialsSecret;
    }
    if (this._database !== undefined) {
      hasAnyValues = true;
      internalValueResult.database = this._database;
    }
    if (this._describeTable !== undefined) {
      hasAnyValues = true;
      internalValueResult.describeTable = this._describeTable;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._dumpFormatErrorsToDisk !== undefined) {
      hasAnyValues = true;
      internalValueResult.dumpFormatErrorsToDisk = this._dumpFormatErrorsToDisk;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._excludeMappingFields !== undefined) {
      hasAnyValues = true;
      internalValueResult.excludeMappingFields = this._excludeMappingFields;
    }
    if (this._extraHttpHeaders?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.extraHttpHeaders = this._extraHttpHeaders?.internalValue;
    }
    if (this._failedRequestLoggingMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.failedRequestLoggingMode = this._failedRequestLoggingMode;
    }
    if (this._flushPeriodSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.flushPeriodSec = this._flushPeriodSec;
    }
    if (this._format !== undefined) {
      hasAnyValues = true;
      internalValueResult.format = this._format;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._loginUrl !== undefined) {
      hasAnyValues = true;
      internalValueResult.loginUrl = this._loginUrl;
    }
    if (this._mappingType !== undefined) {
      hasAnyValues = true;
      internalValueResult.mappingType = this._mappingType;
    }
    if (this._maxPayloadEvents !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxPayloadEvents = this._maxPayloadEvents;
    }
    if (this._maxPayloadSizeKb !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxPayloadSizeKb = this._maxPayloadSizeKb;
    }
    if (this._oauthHeaders?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.oauthHeaders = this._oauthHeaders?.internalValue;
    }
    if (this._oauthParams?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.oauthParams = this._oauthParams?.internalValue;
    }
    if (this._onBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.onBackpressure = this._onBackpressure;
    }
    if (this._password !== undefined) {
      hasAnyValues = true;
      internalValueResult.password = this._password;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._pqCompress !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqCompress = this._pqCompress;
    }
    if (this._pqControls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqControls = this._pqControls?.internalValue;
    }
    if (this._pqMaxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxFileSize = this._pqMaxFileSize;
    }
    if (this._pqMaxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxSize = this._pqMaxSize;
    }
    if (this._pqMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMode = this._pqMode;
    }
    if (this._pqOnBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqOnBackpressure = this._pqOnBackpressure;
    }
    if (this._pqPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqPath = this._pqPath;
    }
    if (this._rejectUnauthorized !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectUnauthorized = this._rejectUnauthorized;
    }
    if (this._responseHonorRetryAfterHeader !== undefined) {
      hasAnyValues = true;
      internalValueResult.responseHonorRetryAfterHeader = this._responseHonorRetryAfterHeader;
    }
    if (this._responseRetrySettings?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.responseRetrySettings = this._responseRetrySettings?.internalValue;
    }
    if (this._safeHeaders !== undefined) {
      hasAnyValues = true;
      internalValueResult.safeHeaders = this._safeHeaders;
    }
    if (this._secret !== undefined) {
      hasAnyValues = true;
      internalValueResult.secret = this._secret;
    }
    if (this._secretParamName !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretParamName = this._secretParamName;
    }
    if (this._sqlUsername !== undefined) {
      hasAnyValues = true;
      internalValueResult.sqlUsername = this._sqlUsername;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._systemFields !== undefined) {
      hasAnyValues = true;
      internalValueResult.systemFields = this._systemFields;
    }
    if (this._tableName !== undefined) {
      hasAnyValues = true;
      internalValueResult.tableName = this._tableName;
    }
    if (this._textSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.textSecret = this._textSecret;
    }
    if (this._timeoutRetrySettings?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutRetrySettings = this._timeoutRetrySettings?.internalValue;
    }
    if (this._timeoutSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutSec = this._timeoutSec;
    }
    if (this._tls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tls = this._tls?.internalValue;
    }
    if (this._token !== undefined) {
      hasAnyValues = true;
      internalValueResult.token = this._token;
    }
    if (this._tokenAttributeName !== undefined) {
      hasAnyValues = true;
      internalValueResult.tokenAttributeName = this._tokenAttributeName;
    }
    if (this._tokenTimeoutSecs !== undefined) {
      hasAnyValues = true;
      internalValueResult.tokenTimeoutSecs = this._tokenTimeoutSecs;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._url !== undefined) {
      hasAnyValues = true;
      internalValueResult.url = this._url;
    }
    if (this._useRoundRobinDns !== undefined) {
      hasAnyValues = true;
      internalValueResult.useRoundRobinDns = this._useRoundRobinDns;
    }
    if (this._username !== undefined) {
      hasAnyValues = true;
      internalValueResult.username = this._username;
    }
    if (this._waitForAsyncInserts !== undefined) {
      hasAnyValues = true;
      internalValueResult.waitForAsyncInserts = this._waitForAsyncInserts;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputClickHouse | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._asyncInserts = undefined;
      this._authHeaderExpr = undefined;
      this._authType = undefined;
      this._columnMappings.internalValue = undefined;
      this._compress = undefined;
      this._concurrency = undefined;
      this._credentialsSecret = undefined;
      this._database = undefined;
      this._describeTable = undefined;
      this._description = undefined;
      this._dumpFormatErrorsToDisk = undefined;
      this._environment = undefined;
      this._excludeMappingFields = undefined;
      this._extraHttpHeaders.internalValue = undefined;
      this._failedRequestLoggingMode = undefined;
      this._flushPeriodSec = undefined;
      this._format = undefined;
      this._id = undefined;
      this._loginUrl = undefined;
      this._mappingType = undefined;
      this._maxPayloadEvents = undefined;
      this._maxPayloadSizeKb = undefined;
      this._oauthHeaders.internalValue = undefined;
      this._oauthParams.internalValue = undefined;
      this._onBackpressure = undefined;
      this._password = undefined;
      this._pipeline = undefined;
      this._pqCompress = undefined;
      this._pqControls.internalValue = undefined;
      this._pqMaxFileSize = undefined;
      this._pqMaxSize = undefined;
      this._pqMode = undefined;
      this._pqOnBackpressure = undefined;
      this._pqPath = undefined;
      this._rejectUnauthorized = undefined;
      this._responseHonorRetryAfterHeader = undefined;
      this._responseRetrySettings.internalValue = undefined;
      this._safeHeaders = undefined;
      this._secret = undefined;
      this._secretParamName = undefined;
      this._sqlUsername = undefined;
      this._streamtags = undefined;
      this._systemFields = undefined;
      this._tableName = undefined;
      this._textSecret = undefined;
      this._timeoutRetrySettings.internalValue = undefined;
      this._timeoutSec = undefined;
      this._tls.internalValue = undefined;
      this._token = undefined;
      this._tokenAttributeName = undefined;
      this._tokenTimeoutSecs = undefined;
      this._type = undefined;
      this._url = undefined;
      this._useRoundRobinDns = undefined;
      this._username = undefined;
      this._waitForAsyncInserts = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._asyncInserts = value.asyncInserts;
      this._authHeaderExpr = value.authHeaderExpr;
      this._authType = value.authType;
      this._columnMappings.internalValue = value.columnMappings;
      this._compress = value.compress;
      this._concurrency = value.concurrency;
      this._credentialsSecret = value.credentialsSecret;
      this._database = value.database;
      this._describeTable = value.describeTable;
      this._description = value.description;
      this._dumpFormatErrorsToDisk = value.dumpFormatErrorsToDisk;
      this._environment = value.environment;
      this._excludeMappingFields = value.excludeMappingFields;
      this._extraHttpHeaders.internalValue = value.extraHttpHeaders;
      this._failedRequestLoggingMode = value.failedRequestLoggingMode;
      this._flushPeriodSec = value.flushPeriodSec;
      this._format = value.format;
      this._id = value.id;
      this._loginUrl = value.loginUrl;
      this._mappingType = value.mappingType;
      this._maxPayloadEvents = value.maxPayloadEvents;
      this._maxPayloadSizeKb = value.maxPayloadSizeKb;
      this._oauthHeaders.internalValue = value.oauthHeaders;
      this._oauthParams.internalValue = value.oauthParams;
      this._onBackpressure = value.onBackpressure;
      this._password = value.password;
      this._pipeline = value.pipeline;
      this._pqCompress = value.pqCompress;
      this._pqControls.internalValue = value.pqControls;
      this._pqMaxFileSize = value.pqMaxFileSize;
      this._pqMaxSize = value.pqMaxSize;
      this._pqMode = value.pqMode;
      this._pqOnBackpressure = value.pqOnBackpressure;
      this._pqPath = value.pqPath;
      this._rejectUnauthorized = value.rejectUnauthorized;
      this._responseHonorRetryAfterHeader = value.responseHonorRetryAfterHeader;
      this._responseRetrySettings.internalValue = value.responseRetrySettings;
      this._safeHeaders = value.safeHeaders;
      this._secret = value.secret;
      this._secretParamName = value.secretParamName;
      this._sqlUsername = value.sqlUsername;
      this._streamtags = value.streamtags;
      this._systemFields = value.systemFields;
      this._tableName = value.tableName;
      this._textSecret = value.textSecret;
      this._timeoutRetrySettings.internalValue = value.timeoutRetrySettings;
      this._timeoutSec = value.timeoutSec;
      this._tls.internalValue = value.tls;
      this._token = value.token;
      this._tokenAttributeName = value.tokenAttributeName;
      this._tokenTimeoutSecs = value.tokenTimeoutSecs;
      this._type = value.type;
      this._url = value.url;
      this._useRoundRobinDns = value.useRoundRobinDns;
      this._username = value.username;
      this._waitForAsyncInserts = value.waitForAsyncInserts;
    }
  }

  // async_inserts - computed: true, optional: true, required: false
  private _asyncInserts?: boolean | cdktf.IResolvable; 
  public get asyncInserts() {
    return this.getBooleanAttribute('async_inserts');
  }
  public set asyncInserts(value: boolean | cdktf.IResolvable) {
    this._asyncInserts = value;
  }
  public resetAsyncInserts() {
    this._asyncInserts = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get asyncInsertsInput() {
    return this._asyncInserts;
  }

  // auth_header_expr - computed: true, optional: true, required: false
  private _authHeaderExpr?: string; 
  public get authHeaderExpr() {
    return this.getStringAttribute('auth_header_expr');
  }
  public set authHeaderExpr(value: string) {
    this._authHeaderExpr = value;
  }
  public resetAuthHeaderExpr() {
    this._authHeaderExpr = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authHeaderExprInput() {
    return this._authHeaderExpr;
  }

  // auth_type - computed: true, optional: true, required: false
  private _authType?: string; 
  public get authType() {
    return this.getStringAttribute('auth_type');
  }
  public set authType(value: string) {
    this._authType = value;
  }
  public resetAuthType() {
    this._authType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authTypeInput() {
    return this._authType;
  }

  // column_mappings - computed: false, optional: true, required: false
  private _columnMappings = new PackDestinationOutputClickHouseColumnMappingsList(this, "column_mappings", false);
  public get columnMappings() {
    return this._columnMappings;
  }
  public putColumnMappings(value: PackDestinationOutputClickHouseColumnMappings[] | cdktf.IResolvable) {
    this._columnMappings.internalValue = value;
  }
  public resetColumnMappings() {
    this._columnMappings.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get columnMappingsInput() {
    return this._columnMappings.internalValue;
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: boolean | cdktf.IResolvable; 
  public get compress() {
    return this.getBooleanAttribute('compress');
  }
  public set compress(value: boolean | cdktf.IResolvable) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // concurrency - computed: true, optional: true, required: false
  private _concurrency?: number; 
  public get concurrency() {
    return this.getNumberAttribute('concurrency');
  }
  public set concurrency(value: number) {
    this._concurrency = value;
  }
  public resetConcurrency() {
    this._concurrency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get concurrencyInput() {
    return this._concurrency;
  }

  // credentials_secret - computed: false, optional: true, required: false
  private _credentialsSecret?: string; 
  public get credentialsSecret() {
    return this.getStringAttribute('credentials_secret');
  }
  public set credentialsSecret(value: string) {
    this._credentialsSecret = value;
  }
  public resetCredentialsSecret() {
    this._credentialsSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get credentialsSecretInput() {
    return this._credentialsSecret;
  }

  // database - computed: false, optional: false, required: true
  private _database?: string; 
  public get database() {
    return this.getStringAttribute('database');
  }
  public set database(value: string) {
    this._database = value;
  }
  // Temporarily expose input value. Use with caution.
  public get databaseInput() {
    return this._database;
  }

  // describe_table - computed: false, optional: true, required: false
  private _describeTable?: string; 
  public get describeTable() {
    return this.getStringAttribute('describe_table');
  }
  public set describeTable(value: string) {
    this._describeTable = value;
  }
  public resetDescribeTable() {
    this._describeTable = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get describeTableInput() {
    return this._describeTable;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // dump_format_errors_to_disk - computed: true, optional: true, required: false
  private _dumpFormatErrorsToDisk?: boolean | cdktf.IResolvable; 
  public get dumpFormatErrorsToDisk() {
    return this.getBooleanAttribute('dump_format_errors_to_disk');
  }
  public set dumpFormatErrorsToDisk(value: boolean | cdktf.IResolvable) {
    this._dumpFormatErrorsToDisk = value;
  }
  public resetDumpFormatErrorsToDisk() {
    this._dumpFormatErrorsToDisk = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dumpFormatErrorsToDiskInput() {
    return this._dumpFormatErrorsToDisk;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // exclude_mapping_fields - computed: true, optional: true, required: false
  private _excludeMappingFields?: string[]; 
  public get excludeMappingFields() {
    return this.getListAttribute('exclude_mapping_fields');
  }
  public set excludeMappingFields(value: string[]) {
    this._excludeMappingFields = value;
  }
  public resetExcludeMappingFields() {
    this._excludeMappingFields = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get excludeMappingFieldsInput() {
    return this._excludeMappingFields;
  }

  // extra_http_headers - computed: false, optional: true, required: false
  private _extraHttpHeaders = new PackDestinationOutputClickHouseExtraHttpHeadersList(this, "extra_http_headers", false);
  public get extraHttpHeaders() {
    return this._extraHttpHeaders;
  }
  public putExtraHttpHeaders(value: PackDestinationOutputClickHouseExtraHttpHeaders[] | cdktf.IResolvable) {
    this._extraHttpHeaders.internalValue = value;
  }
  public resetExtraHttpHeaders() {
    this._extraHttpHeaders.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get extraHttpHeadersInput() {
    return this._extraHttpHeaders.internalValue;
  }

  // failed_request_logging_mode - computed: true, optional: true, required: false
  private _failedRequestLoggingMode?: string; 
  public get failedRequestLoggingMode() {
    return this.getStringAttribute('failed_request_logging_mode');
  }
  public set failedRequestLoggingMode(value: string) {
    this._failedRequestLoggingMode = value;
  }
  public resetFailedRequestLoggingMode() {
    this._failedRequestLoggingMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get failedRequestLoggingModeInput() {
    return this._failedRequestLoggingMode;
  }

  // flush_period_sec - computed: true, optional: true, required: false
  private _flushPeriodSec?: number; 
  public get flushPeriodSec() {
    return this.getNumberAttribute('flush_period_sec');
  }
  public set flushPeriodSec(value: number) {
    this._flushPeriodSec = value;
  }
  public resetFlushPeriodSec() {
    this._flushPeriodSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get flushPeriodSecInput() {
    return this._flushPeriodSec;
  }

  // format - computed: true, optional: true, required: false
  private _format?: string; 
  public get format() {
    return this.getStringAttribute('format');
  }
  public set format(value: string) {
    this._format = value;
  }
  public resetFormat() {
    this._format = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get formatInput() {
    return this._format;
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // login_url - computed: false, optional: true, required: false
  private _loginUrl?: string; 
  public get loginUrl() {
    return this.getStringAttribute('login_url');
  }
  public set loginUrl(value: string) {
    this._loginUrl = value;
  }
  public resetLoginUrl() {
    this._loginUrl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get loginUrlInput() {
    return this._loginUrl;
  }

  // mapping_type - computed: true, optional: true, required: false
  private _mappingType?: string; 
  public get mappingType() {
    return this.getStringAttribute('mapping_type');
  }
  public set mappingType(value: string) {
    this._mappingType = value;
  }
  public resetMappingType() {
    this._mappingType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get mappingTypeInput() {
    return this._mappingType;
  }

  // max_payload_events - computed: true, optional: true, required: false
  private _maxPayloadEvents?: number; 
  public get maxPayloadEvents() {
    return this.getNumberAttribute('max_payload_events');
  }
  public set maxPayloadEvents(value: number) {
    this._maxPayloadEvents = value;
  }
  public resetMaxPayloadEvents() {
    this._maxPayloadEvents = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxPayloadEventsInput() {
    return this._maxPayloadEvents;
  }

  // max_payload_size_kb - computed: true, optional: true, required: false
  private _maxPayloadSizeKb?: number; 
  public get maxPayloadSizeKb() {
    return this.getNumberAttribute('max_payload_size_kb');
  }
  public set maxPayloadSizeKb(value: number) {
    this._maxPayloadSizeKb = value;
  }
  public resetMaxPayloadSizeKb() {
    this._maxPayloadSizeKb = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxPayloadSizeKbInput() {
    return this._maxPayloadSizeKb;
  }

  // oauth_headers - computed: false, optional: true, required: false
  private _oauthHeaders = new PackDestinationOutputClickHouseOauthHeadersList(this, "oauth_headers", false);
  public get oauthHeaders() {
    return this._oauthHeaders;
  }
  public putOauthHeaders(value: PackDestinationOutputClickHouseOauthHeaders[] | cdktf.IResolvable) {
    this._oauthHeaders.internalValue = value;
  }
  public resetOauthHeaders() {
    this._oauthHeaders.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get oauthHeadersInput() {
    return this._oauthHeaders.internalValue;
  }

  // oauth_params - computed: false, optional: true, required: false
  private _oauthParams = new PackDestinationOutputClickHouseOauthParamsList(this, "oauth_params", false);
  public get oauthParams() {
    return this._oauthParams;
  }
  public putOauthParams(value: PackDestinationOutputClickHouseOauthParams[] | cdktf.IResolvable) {
    this._oauthParams.internalValue = value;
  }
  public resetOauthParams() {
    this._oauthParams.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get oauthParamsInput() {
    return this._oauthParams.internalValue;
  }

  // on_backpressure - computed: true, optional: true, required: false
  private _onBackpressure?: string; 
  public get onBackpressure() {
    return this.getStringAttribute('on_backpressure');
  }
  public set onBackpressure(value: string) {
    this._onBackpressure = value;
  }
  public resetOnBackpressure() {
    this._onBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get onBackpressureInput() {
    return this._onBackpressure;
  }

  // password - computed: false, optional: true, required: false
  private _password?: string; 
  public get password() {
    return this.getStringAttribute('password');
  }
  public set password(value: string) {
    this._password = value;
  }
  public resetPassword() {
    this._password = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passwordInput() {
    return this._password;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // pq_compress - computed: true, optional: true, required: false
  private _pqCompress?: string; 
  public get pqCompress() {
    return this.getStringAttribute('pq_compress');
  }
  public set pqCompress(value: string) {
    this._pqCompress = value;
  }
  public resetPqCompress() {
    this._pqCompress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqCompressInput() {
    return this._pqCompress;
  }

  // pq_controls - computed: false, optional: true, required: false
  private _pqControls = new PackDestinationOutputClickHousePqControlsOutputReference(this, "pq_controls");
  public get pqControls() {
    return this._pqControls;
  }
  public putPqControls(value: PackDestinationOutputClickHousePqControls) {
    this._pqControls.internalValue = value;
  }
  public resetPqControls() {
    this._pqControls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqControlsInput() {
    return this._pqControls.internalValue;
  }

  // pq_max_file_size - computed: true, optional: true, required: false
  private _pqMaxFileSize?: string; 
  public get pqMaxFileSize() {
    return this.getStringAttribute('pq_max_file_size');
  }
  public set pqMaxFileSize(value: string) {
    this._pqMaxFileSize = value;
  }
  public resetPqMaxFileSize() {
    this._pqMaxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxFileSizeInput() {
    return this._pqMaxFileSize;
  }

  // pq_max_size - computed: true, optional: true, required: false
  private _pqMaxSize?: string; 
  public get pqMaxSize() {
    return this.getStringAttribute('pq_max_size');
  }
  public set pqMaxSize(value: string) {
    this._pqMaxSize = value;
  }
  public resetPqMaxSize() {
    this._pqMaxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxSizeInput() {
    return this._pqMaxSize;
  }

  // pq_mode - computed: true, optional: true, required: false
  private _pqMode?: string; 
  public get pqMode() {
    return this.getStringAttribute('pq_mode');
  }
  public set pqMode(value: string) {
    this._pqMode = value;
  }
  public resetPqMode() {
    this._pqMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqModeInput() {
    return this._pqMode;
  }

  // pq_on_backpressure - computed: true, optional: true, required: false
  private _pqOnBackpressure?: string; 
  public get pqOnBackpressure() {
    return this.getStringAttribute('pq_on_backpressure');
  }
  public set pqOnBackpressure(value: string) {
    this._pqOnBackpressure = value;
  }
  public resetPqOnBackpressure() {
    this._pqOnBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqOnBackpressureInput() {
    return this._pqOnBackpressure;
  }

  // pq_path - computed: true, optional: true, required: false
  private _pqPath?: string; 
  public get pqPath() {
    return this.getStringAttribute('pq_path');
  }
  public set pqPath(value: string) {
    this._pqPath = value;
  }
  public resetPqPath() {
    this._pqPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqPathInput() {
    return this._pqPath;
  }

  // reject_unauthorized - computed: true, optional: true, required: false
  private _rejectUnauthorized?: boolean | cdktf.IResolvable; 
  public get rejectUnauthorized() {
    return this.getBooleanAttribute('reject_unauthorized');
  }
  public set rejectUnauthorized(value: boolean | cdktf.IResolvable) {
    this._rejectUnauthorized = value;
  }
  public resetRejectUnauthorized() {
    this._rejectUnauthorized = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectUnauthorizedInput() {
    return this._rejectUnauthorized;
  }

  // response_honor_retry_after_header - computed: true, optional: true, required: false
  private _responseHonorRetryAfterHeader?: boolean | cdktf.IResolvable; 
  public get responseHonorRetryAfterHeader() {
    return this.getBooleanAttribute('response_honor_retry_after_header');
  }
  public set responseHonorRetryAfterHeader(value: boolean | cdktf.IResolvable) {
    this._responseHonorRetryAfterHeader = value;
  }
  public resetResponseHonorRetryAfterHeader() {
    this._responseHonorRetryAfterHeader = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get responseHonorRetryAfterHeaderInput() {
    return this._responseHonorRetryAfterHeader;
  }

  // response_retry_settings - computed: false, optional: true, required: false
  private _responseRetrySettings = new PackDestinationOutputClickHouseResponseRetrySettingsList(this, "response_retry_settings", false);
  public get responseRetrySettings() {
    return this._responseRetrySettings;
  }
  public putResponseRetrySettings(value: PackDestinationOutputClickHouseResponseRetrySettings[] | cdktf.IResolvable) {
    this._responseRetrySettings.internalValue = value;
  }
  public resetResponseRetrySettings() {
    this._responseRetrySettings.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get responseRetrySettingsInput() {
    return this._responseRetrySettings.internalValue;
  }

  // safe_headers - computed: true, optional: true, required: false
  private _safeHeaders?: string[]; 
  public get safeHeaders() {
    return this.getListAttribute('safe_headers');
  }
  public set safeHeaders(value: string[]) {
    this._safeHeaders = value;
  }
  public resetSafeHeaders() {
    this._safeHeaders = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get safeHeadersInput() {
    return this._safeHeaders;
  }

  // secret - computed: false, optional: true, required: false
  private _secret?: string; 
  public get secret() {
    return this.getStringAttribute('secret');
  }
  public set secret(value: string) {
    this._secret = value;
  }
  public resetSecret() {
    this._secret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretInput() {
    return this._secret;
  }

  // secret_param_name - computed: false, optional: true, required: false
  private _secretParamName?: string; 
  public get secretParamName() {
    return this.getStringAttribute('secret_param_name');
  }
  public set secretParamName(value: string) {
    this._secretParamName = value;
  }
  public resetSecretParamName() {
    this._secretParamName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretParamNameInput() {
    return this._secretParamName;
  }

  // sql_username - computed: false, optional: true, required: false
  private _sqlUsername?: string; 
  public get sqlUsername() {
    return this.getStringAttribute('sql_username');
  }
  public set sqlUsername(value: string) {
    this._sqlUsername = value;
  }
  public resetSqlUsername() {
    this._sqlUsername = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sqlUsernameInput() {
    return this._sqlUsername;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // system_fields - computed: true, optional: true, required: false
  private _systemFields?: string[]; 
  public get systemFields() {
    return this.getListAttribute('system_fields');
  }
  public set systemFields(value: string[]) {
    this._systemFields = value;
  }
  public resetSystemFields() {
    this._systemFields = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get systemFieldsInput() {
    return this._systemFields;
  }

  // table_name - computed: false, optional: false, required: true
  private _tableName?: string; 
  public get tableName() {
    return this.getStringAttribute('table_name');
  }
  public set tableName(value: string) {
    this._tableName = value;
  }
  // Temporarily expose input value. Use with caution.
  public get tableNameInput() {
    return this._tableName;
  }

  // text_secret - computed: false, optional: true, required: false
  private _textSecret?: string; 
  public get textSecret() {
    return this.getStringAttribute('text_secret');
  }
  public set textSecret(value: string) {
    this._textSecret = value;
  }
  public resetTextSecret() {
    this._textSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get textSecretInput() {
    return this._textSecret;
  }

  // timeout_retry_settings - computed: false, optional: true, required: false
  private _timeoutRetrySettings = new PackDestinationOutputClickHouseTimeoutRetrySettingsOutputReference(this, "timeout_retry_settings");
  public get timeoutRetrySettings() {
    return this._timeoutRetrySettings;
  }
  public putTimeoutRetrySettings(value: PackDestinationOutputClickHouseTimeoutRetrySettings) {
    this._timeoutRetrySettings.internalValue = value;
  }
  public resetTimeoutRetrySettings() {
    this._timeoutRetrySettings.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutRetrySettingsInput() {
    return this._timeoutRetrySettings.internalValue;
  }

  // timeout_sec - computed: true, optional: true, required: false
  private _timeoutSec?: number; 
  public get timeoutSec() {
    return this.getNumberAttribute('timeout_sec');
  }
  public set timeoutSec(value: number) {
    this._timeoutSec = value;
  }
  public resetTimeoutSec() {
    this._timeoutSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutSecInput() {
    return this._timeoutSec;
  }

  // tls - computed: false, optional: true, required: false
  private _tls = new PackDestinationOutputClickHouseTlsOutputReference(this, "tls");
  public get tls() {
    return this._tls;
  }
  public putTls(value: PackDestinationOutputClickHouseTls) {
    this._tls.internalValue = value;
  }
  public resetTls() {
    this._tls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsInput() {
    return this._tls.internalValue;
  }

  // token - computed: false, optional: true, required: false
  private _token?: string; 
  public get token() {
    return this.getStringAttribute('token');
  }
  public set token(value: string) {
    this._token = value;
  }
  public resetToken() {
    this._token = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tokenInput() {
    return this._token;
  }

  // token_attribute_name - computed: false, optional: true, required: false
  private _tokenAttributeName?: string; 
  public get tokenAttributeName() {
    return this.getStringAttribute('token_attribute_name');
  }
  public set tokenAttributeName(value: string) {
    this._tokenAttributeName = value;
  }
  public resetTokenAttributeName() {
    this._tokenAttributeName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tokenAttributeNameInput() {
    return this._tokenAttributeName;
  }

  // token_timeout_secs - computed: true, optional: true, required: false
  private _tokenTimeoutSecs?: number; 
  public get tokenTimeoutSecs() {
    return this.getNumberAttribute('token_timeout_secs');
  }
  public set tokenTimeoutSecs(value: number) {
    this._tokenTimeoutSecs = value;
  }
  public resetTokenTimeoutSecs() {
    this._tokenTimeoutSecs = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tokenTimeoutSecsInput() {
    return this._tokenTimeoutSecs;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // url - computed: false, optional: false, required: true
  private _url?: string; 
  public get url() {
    return this.getStringAttribute('url');
  }
  public set url(value: string) {
    this._url = value;
  }
  // Temporarily expose input value. Use with caution.
  public get urlInput() {
    return this._url;
  }

  // use_round_robin_dns - computed: true, optional: true, required: false
  private _useRoundRobinDns?: boolean | cdktf.IResolvable; 
  public get useRoundRobinDns() {
    return this.getBooleanAttribute('use_round_robin_dns');
  }
  public set useRoundRobinDns(value: boolean | cdktf.IResolvable) {
    this._useRoundRobinDns = value;
  }
  public resetUseRoundRobinDns() {
    this._useRoundRobinDns = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get useRoundRobinDnsInput() {
    return this._useRoundRobinDns;
  }

  // username - computed: false, optional: true, required: false
  private _username?: string; 
  public get username() {
    return this.getStringAttribute('username');
  }
  public set username(value: string) {
    this._username = value;
  }
  public resetUsername() {
    this._username = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usernameInput() {
    return this._username;
  }

  // wait_for_async_inserts - computed: true, optional: true, required: false
  private _waitForAsyncInserts?: boolean | cdktf.IResolvable; 
  public get waitForAsyncInserts() {
    return this.getBooleanAttribute('wait_for_async_inserts');
  }
  public set waitForAsyncInserts(value: boolean | cdktf.IResolvable) {
    this._waitForAsyncInserts = value;
  }
  public resetWaitForAsyncInserts() {
    this._waitForAsyncInserts = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get waitForAsyncInsertsInput() {
    return this._waitForAsyncInserts;
  }
}
export interface PackDestinationOutputCloudwatchPqControls {
}

export function packDestinationOutputCloudwatchPqControlsToTerraform(struct?: PackDestinationOutputCloudwatchPqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function packDestinationOutputCloudwatchPqControlsToHclTerraform(struct?: PackDestinationOutputCloudwatchPqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class PackDestinationOutputCloudwatchPqControlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackDestinationOutputCloudwatchPqControls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputCloudwatchPqControls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface PackDestinationOutputCloudwatch {
  /**
  * Amazon Resource Name (ARN) of the role to assume
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#assume_role_arn PackDestination#assume_role_arn}
  */
  readonly assumeRoleArn?: string;
  /**
  * External ID to use when assuming role
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#assume_role_external_id PackDestination#assume_role_external_id}
  */
  readonly assumeRoleExternalId?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#aws_api_key PackDestination#aws_api_key}
  */
  readonly awsApiKey?: string;
  /**
  * AWS authentication method. Choose Auto to use IAM roles. Default: "auto"; must be one of ["auto", "manual", "secret"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#aws_authentication_method PackDestination#aws_authentication_method}
  */
  readonly awsAuthenticationMethod?: string;
  /**
  * Select or create a stored secret that references your access key and secret key
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#aws_secret PackDestination#aws_secret}
  */
  readonly awsSecret?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#aws_secret_key PackDestination#aws_secret_key}
  */
  readonly awsSecretKey?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#description PackDestination#description}
  */
  readonly description?: string;
  /**
  * Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours). Default: 3600
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#duration_seconds PackDestination#duration_seconds}
  */
  readonly durationSeconds?: number;
  /**
  * Use Assume Role credentials to access CloudWatchLogs. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#enable_assume_role PackDestination#enable_assume_role}
  */
  readonly enableAssumeRole?: boolean | cdktf.IResolvable;
  /**
  * CloudWatchLogs service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to CloudWatchLogs-compatible endpoint.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#endpoint PackDestination#endpoint}
  */
  readonly endpoint?: string;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#environment PackDestination#environment}
  */
  readonly environment?: string;
  /**
  * Maximum time between requests. Small values could cause the payload size to be smaller than the configured Max record size. Default: 1
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#flush_period_sec PackDestination#flush_period_sec}
  */
  readonly flushPeriodSec?: number;
  /**
  * Unique ID for this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#id PackDestination#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * CloudWatch log group to associate events with
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#log_group_name PackDestination#log_group_name}
  */
  readonly logGroupName: string;
  /**
  * Prefix for CloudWatch log stream name. This prefix will be used to generate a unique log stream name per cribl instance, for example: myStream_myHost_myOutputId
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#log_stream_name PackDestination#log_stream_name}
  */
  readonly logStreamName: string;
  /**
  * Maximum number of queued batches before blocking. Default: 5
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_queue_size PackDestination#max_queue_size}
  */
  readonly maxQueueSize?: number;
  /**
  * Maximum size (KB) of each individual record before compression. For non compressible data 1MB is the max recommended size. Default: 1024
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_record_size_kb PackDestination#max_record_size_kb}
  */
  readonly maxRecordSizeKb?: number;
  /**
  * How to handle events when all receivers are exerting backpressure. Default: "block"; must be one of ["block", "drop", "queue"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#on_backpressure PackDestination#on_backpressure}
  */
  readonly onBackpressure?: string;
  /**
  * Pipeline to process data before sending out to this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pipeline PackDestination#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_compress PackDestination#pq_compress}
  */
  readonly pqCompress?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_controls PackDestination#pq_controls}
  */
  readonly pqControls?: PackDestinationOutputCloudwatchPqControls;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.). Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_max_file_size PackDestination#pq_max_file_size}
  */
  readonly pqMaxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_max_size PackDestination#pq_max_size}
  */
  readonly pqMaxSize?: string;
  /**
  * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem. Default: "error"; must be one of ["error", "backpressure", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_mode PackDestination#pq_mode}
  */
  readonly pqMode?: string;
  /**
  * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged. Default: "block"; must be one of ["block", "drop"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_on_backpressure PackDestination#pq_on_backpressure}
  */
  readonly pqOnBackpressure?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_path PackDestination#pq_path}
  */
  readonly pqPath?: string;
  /**
  * Region where the CloudWatchLogs is located
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#region PackDestination#region}
  */
  readonly region: string;
  /**
  * Reject certificates that cannot be verified against a valid CA, such as self-signed certificates. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#reject_unauthorized PackDestination#reject_unauthorized}
  */
  readonly rejectUnauthorized?: boolean | cdktf.IResolvable;
  /**
  * Reuse connections between requests, which can improve performance. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#reuse_connections PackDestination#reuse_connections}
  */
  readonly reuseConnections?: boolean | cdktf.IResolvable;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#streamtags PackDestination#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Fields to automatically add to events, such as cribl_pipe. Supports wildcards. Default: ["cribl_pipe"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#system_fields PackDestination#system_fields}
  */
  readonly systemFields?: string[];
  /**
  * must be "cloudwatch"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#type PackDestination#type}
  */
  readonly type?: string;
}

export function packDestinationOutputCloudwatchToTerraform(struct?: PackDestinationOutputCloudwatch | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    assume_role_arn: cdktf.stringToTerraform(struct!.assumeRoleArn),
    assume_role_external_id: cdktf.stringToTerraform(struct!.assumeRoleExternalId),
    aws_api_key: cdktf.stringToTerraform(struct!.awsApiKey),
    aws_authentication_method: cdktf.stringToTerraform(struct!.awsAuthenticationMethod),
    aws_secret: cdktf.stringToTerraform(struct!.awsSecret),
    aws_secret_key: cdktf.stringToTerraform(struct!.awsSecretKey),
    description: cdktf.stringToTerraform(struct!.description),
    duration_seconds: cdktf.numberToTerraform(struct!.durationSeconds),
    enable_assume_role: cdktf.booleanToTerraform(struct!.enableAssumeRole),
    endpoint: cdktf.stringToTerraform(struct!.endpoint),
    environment: cdktf.stringToTerraform(struct!.environment),
    flush_period_sec: cdktf.numberToTerraform(struct!.flushPeriodSec),
    id: cdktf.stringToTerraform(struct!.id),
    log_group_name: cdktf.stringToTerraform(struct!.logGroupName),
    log_stream_name: cdktf.stringToTerraform(struct!.logStreamName),
    max_queue_size: cdktf.numberToTerraform(struct!.maxQueueSize),
    max_record_size_kb: cdktf.numberToTerraform(struct!.maxRecordSizeKb),
    on_backpressure: cdktf.stringToTerraform(struct!.onBackpressure),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    pq_compress: cdktf.stringToTerraform(struct!.pqCompress),
    pq_controls: packDestinationOutputCloudwatchPqControlsToTerraform(struct!.pqControls),
    pq_max_file_size: cdktf.stringToTerraform(struct!.pqMaxFileSize),
    pq_max_size: cdktf.stringToTerraform(struct!.pqMaxSize),
    pq_mode: cdktf.stringToTerraform(struct!.pqMode),
    pq_on_backpressure: cdktf.stringToTerraform(struct!.pqOnBackpressure),
    pq_path: cdktf.stringToTerraform(struct!.pqPath),
    region: cdktf.stringToTerraform(struct!.region),
    reject_unauthorized: cdktf.booleanToTerraform(struct!.rejectUnauthorized),
    reuse_connections: cdktf.booleanToTerraform(struct!.reuseConnections),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    system_fields: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.systemFields),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function packDestinationOutputCloudwatchToHclTerraform(struct?: PackDestinationOutputCloudwatch | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    assume_role_arn: {
      value: cdktf.stringToHclTerraform(struct!.assumeRoleArn),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    assume_role_external_id: {
      value: cdktf.stringToHclTerraform(struct!.assumeRoleExternalId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    aws_api_key: {
      value: cdktf.stringToHclTerraform(struct!.awsApiKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    aws_authentication_method: {
      value: cdktf.stringToHclTerraform(struct!.awsAuthenticationMethod),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    aws_secret: {
      value: cdktf.stringToHclTerraform(struct!.awsSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    aws_secret_key: {
      value: cdktf.stringToHclTerraform(struct!.awsSecretKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    duration_seconds: {
      value: cdktf.numberToHclTerraform(struct!.durationSeconds),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    enable_assume_role: {
      value: cdktf.booleanToHclTerraform(struct!.enableAssumeRole),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    endpoint: {
      value: cdktf.stringToHclTerraform(struct!.endpoint),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    flush_period_sec: {
      value: cdktf.numberToHclTerraform(struct!.flushPeriodSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    log_group_name: {
      value: cdktf.stringToHclTerraform(struct!.logGroupName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    log_stream_name: {
      value: cdktf.stringToHclTerraform(struct!.logStreamName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_queue_size: {
      value: cdktf.numberToHclTerraform(struct!.maxQueueSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_record_size_kb: {
      value: cdktf.numberToHclTerraform(struct!.maxRecordSizeKb),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.onBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_compress: {
      value: cdktf.stringToHclTerraform(struct!.pqCompress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_controls: {
      value: packDestinationOutputCloudwatchPqControlsToHclTerraform(struct!.pqControls),
      isBlock: true,
      type: "struct",
      storageClassType: "PackDestinationOutputCloudwatchPqControls",
    },
    pq_max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_max_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_mode: {
      value: cdktf.stringToHclTerraform(struct!.pqMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.pqOnBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_path: {
      value: cdktf.stringToHclTerraform(struct!.pqPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    region: {
      value: cdktf.stringToHclTerraform(struct!.region),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reject_unauthorized: {
      value: cdktf.booleanToHclTerraform(struct!.rejectUnauthorized),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    reuse_connections: {
      value: cdktf.booleanToHclTerraform(struct!.reuseConnections),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    system_fields: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.systemFields),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputCloudwatchOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackDestinationOutputCloudwatch | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._assumeRoleArn !== undefined) {
      hasAnyValues = true;
      internalValueResult.assumeRoleArn = this._assumeRoleArn;
    }
    if (this._assumeRoleExternalId !== undefined) {
      hasAnyValues = true;
      internalValueResult.assumeRoleExternalId = this._assumeRoleExternalId;
    }
    if (this._awsApiKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.awsApiKey = this._awsApiKey;
    }
    if (this._awsAuthenticationMethod !== undefined) {
      hasAnyValues = true;
      internalValueResult.awsAuthenticationMethod = this._awsAuthenticationMethod;
    }
    if (this._awsSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.awsSecret = this._awsSecret;
    }
    if (this._awsSecretKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.awsSecretKey = this._awsSecretKey;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._durationSeconds !== undefined) {
      hasAnyValues = true;
      internalValueResult.durationSeconds = this._durationSeconds;
    }
    if (this._enableAssumeRole !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableAssumeRole = this._enableAssumeRole;
    }
    if (this._endpoint !== undefined) {
      hasAnyValues = true;
      internalValueResult.endpoint = this._endpoint;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._flushPeriodSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.flushPeriodSec = this._flushPeriodSec;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._logGroupName !== undefined) {
      hasAnyValues = true;
      internalValueResult.logGroupName = this._logGroupName;
    }
    if (this._logStreamName !== undefined) {
      hasAnyValues = true;
      internalValueResult.logStreamName = this._logStreamName;
    }
    if (this._maxQueueSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxQueueSize = this._maxQueueSize;
    }
    if (this._maxRecordSizeKb !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxRecordSizeKb = this._maxRecordSizeKb;
    }
    if (this._onBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.onBackpressure = this._onBackpressure;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._pqCompress !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqCompress = this._pqCompress;
    }
    if (this._pqControls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqControls = this._pqControls?.internalValue;
    }
    if (this._pqMaxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxFileSize = this._pqMaxFileSize;
    }
    if (this._pqMaxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxSize = this._pqMaxSize;
    }
    if (this._pqMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMode = this._pqMode;
    }
    if (this._pqOnBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqOnBackpressure = this._pqOnBackpressure;
    }
    if (this._pqPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqPath = this._pqPath;
    }
    if (this._region !== undefined) {
      hasAnyValues = true;
      internalValueResult.region = this._region;
    }
    if (this._rejectUnauthorized !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectUnauthorized = this._rejectUnauthorized;
    }
    if (this._reuseConnections !== undefined) {
      hasAnyValues = true;
      internalValueResult.reuseConnections = this._reuseConnections;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._systemFields !== undefined) {
      hasAnyValues = true;
      internalValueResult.systemFields = this._systemFields;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputCloudwatch | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._assumeRoleArn = undefined;
      this._assumeRoleExternalId = undefined;
      this._awsApiKey = undefined;
      this._awsAuthenticationMethod = undefined;
      this._awsSecret = undefined;
      this._awsSecretKey = undefined;
      this._description = undefined;
      this._durationSeconds = undefined;
      this._enableAssumeRole = undefined;
      this._endpoint = undefined;
      this._environment = undefined;
      this._flushPeriodSec = undefined;
      this._id = undefined;
      this._logGroupName = undefined;
      this._logStreamName = undefined;
      this._maxQueueSize = undefined;
      this._maxRecordSizeKb = undefined;
      this._onBackpressure = undefined;
      this._pipeline = undefined;
      this._pqCompress = undefined;
      this._pqControls.internalValue = undefined;
      this._pqMaxFileSize = undefined;
      this._pqMaxSize = undefined;
      this._pqMode = undefined;
      this._pqOnBackpressure = undefined;
      this._pqPath = undefined;
      this._region = undefined;
      this._rejectUnauthorized = undefined;
      this._reuseConnections = undefined;
      this._streamtags = undefined;
      this._systemFields = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._assumeRoleArn = value.assumeRoleArn;
      this._assumeRoleExternalId = value.assumeRoleExternalId;
      this._awsApiKey = value.awsApiKey;
      this._awsAuthenticationMethod = value.awsAuthenticationMethod;
      this._awsSecret = value.awsSecret;
      this._awsSecretKey = value.awsSecretKey;
      this._description = value.description;
      this._durationSeconds = value.durationSeconds;
      this._enableAssumeRole = value.enableAssumeRole;
      this._endpoint = value.endpoint;
      this._environment = value.environment;
      this._flushPeriodSec = value.flushPeriodSec;
      this._id = value.id;
      this._logGroupName = value.logGroupName;
      this._logStreamName = value.logStreamName;
      this._maxQueueSize = value.maxQueueSize;
      this._maxRecordSizeKb = value.maxRecordSizeKb;
      this._onBackpressure = value.onBackpressure;
      this._pipeline = value.pipeline;
      this._pqCompress = value.pqCompress;
      this._pqControls.internalValue = value.pqControls;
      this._pqMaxFileSize = value.pqMaxFileSize;
      this._pqMaxSize = value.pqMaxSize;
      this._pqMode = value.pqMode;
      this._pqOnBackpressure = value.pqOnBackpressure;
      this._pqPath = value.pqPath;
      this._region = value.region;
      this._rejectUnauthorized = value.rejectUnauthorized;
      this._reuseConnections = value.reuseConnections;
      this._streamtags = value.streamtags;
      this._systemFields = value.systemFields;
      this._type = value.type;
    }
  }

  // assume_role_arn - computed: false, optional: true, required: false
  private _assumeRoleArn?: string; 
  public get assumeRoleArn() {
    return this.getStringAttribute('assume_role_arn');
  }
  public set assumeRoleArn(value: string) {
    this._assumeRoleArn = value;
  }
  public resetAssumeRoleArn() {
    this._assumeRoleArn = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get assumeRoleArnInput() {
    return this._assumeRoleArn;
  }

  // assume_role_external_id - computed: false, optional: true, required: false
  private _assumeRoleExternalId?: string; 
  public get assumeRoleExternalId() {
    return this.getStringAttribute('assume_role_external_id');
  }
  public set assumeRoleExternalId(value: string) {
    this._assumeRoleExternalId = value;
  }
  public resetAssumeRoleExternalId() {
    this._assumeRoleExternalId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get assumeRoleExternalIdInput() {
    return this._assumeRoleExternalId;
  }

  // aws_api_key - computed: false, optional: true, required: false
  private _awsApiKey?: string; 
  public get awsApiKey() {
    return this.getStringAttribute('aws_api_key');
  }
  public set awsApiKey(value: string) {
    this._awsApiKey = value;
  }
  public resetAwsApiKey() {
    this._awsApiKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsApiKeyInput() {
    return this._awsApiKey;
  }

  // aws_authentication_method - computed: true, optional: true, required: false
  private _awsAuthenticationMethod?: string; 
  public get awsAuthenticationMethod() {
    return this.getStringAttribute('aws_authentication_method');
  }
  public set awsAuthenticationMethod(value: string) {
    this._awsAuthenticationMethod = value;
  }
  public resetAwsAuthenticationMethod() {
    this._awsAuthenticationMethod = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsAuthenticationMethodInput() {
    return this._awsAuthenticationMethod;
  }

  // aws_secret - computed: false, optional: true, required: false
  private _awsSecret?: string; 
  public get awsSecret() {
    return this.getStringAttribute('aws_secret');
  }
  public set awsSecret(value: string) {
    this._awsSecret = value;
  }
  public resetAwsSecret() {
    this._awsSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsSecretInput() {
    return this._awsSecret;
  }

  // aws_secret_key - computed: false, optional: true, required: false
  private _awsSecretKey?: string; 
  public get awsSecretKey() {
    return this.getStringAttribute('aws_secret_key');
  }
  public set awsSecretKey(value: string) {
    this._awsSecretKey = value;
  }
  public resetAwsSecretKey() {
    this._awsSecretKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsSecretKeyInput() {
    return this._awsSecretKey;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // duration_seconds - computed: true, optional: true, required: false
  private _durationSeconds?: number; 
  public get durationSeconds() {
    return this.getNumberAttribute('duration_seconds');
  }
  public set durationSeconds(value: number) {
    this._durationSeconds = value;
  }
  public resetDurationSeconds() {
    this._durationSeconds = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get durationSecondsInput() {
    return this._durationSeconds;
  }

  // enable_assume_role - computed: true, optional: true, required: false
  private _enableAssumeRole?: boolean | cdktf.IResolvable; 
  public get enableAssumeRole() {
    return this.getBooleanAttribute('enable_assume_role');
  }
  public set enableAssumeRole(value: boolean | cdktf.IResolvable) {
    this._enableAssumeRole = value;
  }
  public resetEnableAssumeRole() {
    this._enableAssumeRole = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableAssumeRoleInput() {
    return this._enableAssumeRole;
  }

  // endpoint - computed: false, optional: true, required: false
  private _endpoint?: string; 
  public get endpoint() {
    return this.getStringAttribute('endpoint');
  }
  public set endpoint(value: string) {
    this._endpoint = value;
  }
  public resetEndpoint() {
    this._endpoint = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get endpointInput() {
    return this._endpoint;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // flush_period_sec - computed: true, optional: true, required: false
  private _flushPeriodSec?: number; 
  public get flushPeriodSec() {
    return this.getNumberAttribute('flush_period_sec');
  }
  public set flushPeriodSec(value: number) {
    this._flushPeriodSec = value;
  }
  public resetFlushPeriodSec() {
    this._flushPeriodSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get flushPeriodSecInput() {
    return this._flushPeriodSec;
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // log_group_name - computed: false, optional: false, required: true
  private _logGroupName?: string; 
  public get logGroupName() {
    return this.getStringAttribute('log_group_name');
  }
  public set logGroupName(value: string) {
    this._logGroupName = value;
  }
  // Temporarily expose input value. Use with caution.
  public get logGroupNameInput() {
    return this._logGroupName;
  }

  // log_stream_name - computed: false, optional: false, required: true
  private _logStreamName?: string; 
  public get logStreamName() {
    return this.getStringAttribute('log_stream_name');
  }
  public set logStreamName(value: string) {
    this._logStreamName = value;
  }
  // Temporarily expose input value. Use with caution.
  public get logStreamNameInput() {
    return this._logStreamName;
  }

  // max_queue_size - computed: true, optional: true, required: false
  private _maxQueueSize?: number; 
  public get maxQueueSize() {
    return this.getNumberAttribute('max_queue_size');
  }
  public set maxQueueSize(value: number) {
    this._maxQueueSize = value;
  }
  public resetMaxQueueSize() {
    this._maxQueueSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxQueueSizeInput() {
    return this._maxQueueSize;
  }

  // max_record_size_kb - computed: true, optional: true, required: false
  private _maxRecordSizeKb?: number; 
  public get maxRecordSizeKb() {
    return this.getNumberAttribute('max_record_size_kb');
  }
  public set maxRecordSizeKb(value: number) {
    this._maxRecordSizeKb = value;
  }
  public resetMaxRecordSizeKb() {
    this._maxRecordSizeKb = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxRecordSizeKbInput() {
    return this._maxRecordSizeKb;
  }

  // on_backpressure - computed: true, optional: true, required: false
  private _onBackpressure?: string; 
  public get onBackpressure() {
    return this.getStringAttribute('on_backpressure');
  }
  public set onBackpressure(value: string) {
    this._onBackpressure = value;
  }
  public resetOnBackpressure() {
    this._onBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get onBackpressureInput() {
    return this._onBackpressure;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // pq_compress - computed: true, optional: true, required: false
  private _pqCompress?: string; 
  public get pqCompress() {
    return this.getStringAttribute('pq_compress');
  }
  public set pqCompress(value: string) {
    this._pqCompress = value;
  }
  public resetPqCompress() {
    this._pqCompress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqCompressInput() {
    return this._pqCompress;
  }

  // pq_controls - computed: false, optional: true, required: false
  private _pqControls = new PackDestinationOutputCloudwatchPqControlsOutputReference(this, "pq_controls");
  public get pqControls() {
    return this._pqControls;
  }
  public putPqControls(value: PackDestinationOutputCloudwatchPqControls) {
    this._pqControls.internalValue = value;
  }
  public resetPqControls() {
    this._pqControls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqControlsInput() {
    return this._pqControls.internalValue;
  }

  // pq_max_file_size - computed: true, optional: true, required: false
  private _pqMaxFileSize?: string; 
  public get pqMaxFileSize() {
    return this.getStringAttribute('pq_max_file_size');
  }
  public set pqMaxFileSize(value: string) {
    this._pqMaxFileSize = value;
  }
  public resetPqMaxFileSize() {
    this._pqMaxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxFileSizeInput() {
    return this._pqMaxFileSize;
  }

  // pq_max_size - computed: true, optional: true, required: false
  private _pqMaxSize?: string; 
  public get pqMaxSize() {
    return this.getStringAttribute('pq_max_size');
  }
  public set pqMaxSize(value: string) {
    this._pqMaxSize = value;
  }
  public resetPqMaxSize() {
    this._pqMaxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxSizeInput() {
    return this._pqMaxSize;
  }

  // pq_mode - computed: true, optional: true, required: false
  private _pqMode?: string; 
  public get pqMode() {
    return this.getStringAttribute('pq_mode');
  }
  public set pqMode(value: string) {
    this._pqMode = value;
  }
  public resetPqMode() {
    this._pqMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqModeInput() {
    return this._pqMode;
  }

  // pq_on_backpressure - computed: true, optional: true, required: false
  private _pqOnBackpressure?: string; 
  public get pqOnBackpressure() {
    return this.getStringAttribute('pq_on_backpressure');
  }
  public set pqOnBackpressure(value: string) {
    this._pqOnBackpressure = value;
  }
  public resetPqOnBackpressure() {
    this._pqOnBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqOnBackpressureInput() {
    return this._pqOnBackpressure;
  }

  // pq_path - computed: true, optional: true, required: false
  private _pqPath?: string; 
  public get pqPath() {
    return this.getStringAttribute('pq_path');
  }
  public set pqPath(value: string) {
    this._pqPath = value;
  }
  public resetPqPath() {
    this._pqPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqPathInput() {
    return this._pqPath;
  }

  // region - computed: false, optional: false, required: true
  private _region?: string; 
  public get region() {
    return this.getStringAttribute('region');
  }
  public set region(value: string) {
    this._region = value;
  }
  // Temporarily expose input value. Use with caution.
  public get regionInput() {
    return this._region;
  }

  // reject_unauthorized - computed: true, optional: true, required: false
  private _rejectUnauthorized?: boolean | cdktf.IResolvable; 
  public get rejectUnauthorized() {
    return this.getBooleanAttribute('reject_unauthorized');
  }
  public set rejectUnauthorized(value: boolean | cdktf.IResolvable) {
    this._rejectUnauthorized = value;
  }
  public resetRejectUnauthorized() {
    this._rejectUnauthorized = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectUnauthorizedInput() {
    return this._rejectUnauthorized;
  }

  // reuse_connections - computed: true, optional: true, required: false
  private _reuseConnections?: boolean | cdktf.IResolvable; 
  public get reuseConnections() {
    return this.getBooleanAttribute('reuse_connections');
  }
  public set reuseConnections(value: boolean | cdktf.IResolvable) {
    this._reuseConnections = value;
  }
  public resetReuseConnections() {
    this._reuseConnections = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get reuseConnectionsInput() {
    return this._reuseConnections;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // system_fields - computed: true, optional: true, required: false
  private _systemFields?: string[]; 
  public get systemFields() {
    return this.getListAttribute('system_fields');
  }
  public set systemFields(value: string[]) {
    this._systemFields = value;
  }
  public resetSystemFields() {
    this._systemFields = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get systemFieldsInput() {
    return this._systemFields;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface PackDestinationOutputConfluentCloudKafkaSchemaRegistryAuth {
  /**
  * Select or create a secret that references your credentials
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#credentials_secret PackDestination#credentials_secret}
  */
  readonly credentialsSecret?: string;
  /**
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#disabled PackDestination#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
}

export function packDestinationOutputConfluentCloudKafkaSchemaRegistryAuthToTerraform(struct?: PackDestinationOutputConfluentCloudKafkaSchemaRegistryAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    credentials_secret: cdktf.stringToTerraform(struct!.credentialsSecret),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
  }
}


export function packDestinationOutputConfluentCloudKafkaSchemaRegistryAuthToHclTerraform(struct?: PackDestinationOutputConfluentCloudKafkaSchemaRegistryAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    credentials_secret: {
      value: cdktf.stringToHclTerraform(struct!.credentialsSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputConfluentCloudKafkaSchemaRegistryAuthOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackDestinationOutputConfluentCloudKafkaSchemaRegistryAuth | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._credentialsSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.credentialsSecret = this._credentialsSecret;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputConfluentCloudKafkaSchemaRegistryAuth | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._credentialsSecret = undefined;
      this._disabled = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._credentialsSecret = value.credentialsSecret;
      this._disabled = value.disabled;
    }
  }

  // credentials_secret - computed: false, optional: true, required: false
  private _credentialsSecret?: string; 
  public get credentialsSecret() {
    return this.getStringAttribute('credentials_secret');
  }
  public set credentialsSecret(value: string) {
    this._credentialsSecret = value;
  }
  public resetCredentialsSecret() {
    this._credentialsSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get credentialsSecretInput() {
    return this._credentialsSecret;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }
}
export interface PackDestinationOutputConfluentCloudKafkaSchemaRegistryTls {
  /**
  * Path on client in which to find CA certificates to verify the server's cert. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#ca_path PackDestination#ca_path}
  */
  readonly caPath?: string;
  /**
  * Path on client in which to find certificates to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#cert_path PackDestination#cert_path}
  */
  readonly certPath?: string;
  /**
  * The name of the predefined certificate
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#certificate_name PackDestination#certificate_name}
  */
  readonly certificateName?: string;
  /**
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#disabled PackDestination#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_version PackDestination#max_version}
  */
  readonly maxVersion?: string;
  /**
  * must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#min_version PackDestination#min_version}
  */
  readonly minVersion?: string;
  /**
  * Passphrase to use to decrypt private key
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#passphrase PackDestination#passphrase}
  */
  readonly passphrase?: string;
  /**
  * Path on client in which to find the private key to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#priv_key_path PackDestination#priv_key_path}
  */
  readonly privKeyPath?: string;
  /**
  * Reject certificates that are not authorized by a CA in the CA certificate path, or by another 
  *                     trusted CA (such as the system's). Defaults to Enabled. Overrides the toggle from Advanced Settings, when also present.
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#reject_unauthorized PackDestination#reject_unauthorized}
  */
  readonly rejectUnauthorized?: boolean | cdktf.IResolvable;
  /**
  * Server name for the SNI (Server Name Indication) TLS extension. It must be a host name, and not an IP address.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#servername PackDestination#servername}
  */
  readonly servername?: string;
}

export function packDestinationOutputConfluentCloudKafkaSchemaRegistryTlsToTerraform(struct?: PackDestinationOutputConfluentCloudKafkaSchemaRegistryTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ca_path: cdktf.stringToTerraform(struct!.caPath),
    cert_path: cdktf.stringToTerraform(struct!.certPath),
    certificate_name: cdktf.stringToTerraform(struct!.certificateName),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    max_version: cdktf.stringToTerraform(struct!.maxVersion),
    min_version: cdktf.stringToTerraform(struct!.minVersion),
    passphrase: cdktf.stringToTerraform(struct!.passphrase),
    priv_key_path: cdktf.stringToTerraform(struct!.privKeyPath),
    reject_unauthorized: cdktf.booleanToTerraform(struct!.rejectUnauthorized),
    servername: cdktf.stringToTerraform(struct!.servername),
  }
}


export function packDestinationOutputConfluentCloudKafkaSchemaRegistryTlsToHclTerraform(struct?: PackDestinationOutputConfluentCloudKafkaSchemaRegistryTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ca_path: {
      value: cdktf.stringToHclTerraform(struct!.caPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    cert_path: {
      value: cdktf.stringToHclTerraform(struct!.certPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    certificate_name: {
      value: cdktf.stringToHclTerraform(struct!.certificateName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    max_version: {
      value: cdktf.stringToHclTerraform(struct!.maxVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    min_version: {
      value: cdktf.stringToHclTerraform(struct!.minVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    passphrase: {
      value: cdktf.stringToHclTerraform(struct!.passphrase),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    priv_key_path: {
      value: cdktf.stringToHclTerraform(struct!.privKeyPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reject_unauthorized: {
      value: cdktf.booleanToHclTerraform(struct!.rejectUnauthorized),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    servername: {
      value: cdktf.stringToHclTerraform(struct!.servername),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputConfluentCloudKafkaSchemaRegistryTlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackDestinationOutputConfluentCloudKafkaSchemaRegistryTls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._caPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.caPath = this._caPath;
    }
    if (this._certPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.certPath = this._certPath;
    }
    if (this._certificateName !== undefined) {
      hasAnyValues = true;
      internalValueResult.certificateName = this._certificateName;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._maxVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxVersion = this._maxVersion;
    }
    if (this._minVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.minVersion = this._minVersion;
    }
    if (this._passphrase !== undefined) {
      hasAnyValues = true;
      internalValueResult.passphrase = this._passphrase;
    }
    if (this._privKeyPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.privKeyPath = this._privKeyPath;
    }
    if (this._rejectUnauthorized !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectUnauthorized = this._rejectUnauthorized;
    }
    if (this._servername !== undefined) {
      hasAnyValues = true;
      internalValueResult.servername = this._servername;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputConfluentCloudKafkaSchemaRegistryTls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._caPath = undefined;
      this._certPath = undefined;
      this._certificateName = undefined;
      this._disabled = undefined;
      this._maxVersion = undefined;
      this._minVersion = undefined;
      this._passphrase = undefined;
      this._privKeyPath = undefined;
      this._rejectUnauthorized = undefined;
      this._servername = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._caPath = value.caPath;
      this._certPath = value.certPath;
      this._certificateName = value.certificateName;
      this._disabled = value.disabled;
      this._maxVersion = value.maxVersion;
      this._minVersion = value.minVersion;
      this._passphrase = value.passphrase;
      this._privKeyPath = value.privKeyPath;
      this._rejectUnauthorized = value.rejectUnauthorized;
      this._servername = value.servername;
    }
  }

  // ca_path - computed: false, optional: true, required: false
  private _caPath?: string; 
  public get caPath() {
    return this.getStringAttribute('ca_path');
  }
  public set caPath(value: string) {
    this._caPath = value;
  }
  public resetCaPath() {
    this._caPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get caPathInput() {
    return this._caPath;
  }

  // cert_path - computed: false, optional: true, required: false
  private _certPath?: string; 
  public get certPath() {
    return this.getStringAttribute('cert_path');
  }
  public set certPath(value: string) {
    this._certPath = value;
  }
  public resetCertPath() {
    this._certPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certPathInput() {
    return this._certPath;
  }

  // certificate_name - computed: false, optional: true, required: false
  private _certificateName?: string; 
  public get certificateName() {
    return this.getStringAttribute('certificate_name');
  }
  public set certificateName(value: string) {
    this._certificateName = value;
  }
  public resetCertificateName() {
    this._certificateName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certificateNameInput() {
    return this._certificateName;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // max_version - computed: false, optional: true, required: false
  private _maxVersion?: string; 
  public get maxVersion() {
    return this.getStringAttribute('max_version');
  }
  public set maxVersion(value: string) {
    this._maxVersion = value;
  }
  public resetMaxVersion() {
    this._maxVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxVersionInput() {
    return this._maxVersion;
  }

  // min_version - computed: false, optional: true, required: false
  private _minVersion?: string; 
  public get minVersion() {
    return this.getStringAttribute('min_version');
  }
  public set minVersion(value: string) {
    this._minVersion = value;
  }
  public resetMinVersion() {
    this._minVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get minVersionInput() {
    return this._minVersion;
  }

  // passphrase - computed: false, optional: true, required: false
  private _passphrase?: string; 
  public get passphrase() {
    return this.getStringAttribute('passphrase');
  }
  public set passphrase(value: string) {
    this._passphrase = value;
  }
  public resetPassphrase() {
    this._passphrase = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passphraseInput() {
    return this._passphrase;
  }

  // priv_key_path - computed: false, optional: true, required: false
  private _privKeyPath?: string; 
  public get privKeyPath() {
    return this.getStringAttribute('priv_key_path');
  }
  public set privKeyPath(value: string) {
    this._privKeyPath = value;
  }
  public resetPrivKeyPath() {
    this._privKeyPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get privKeyPathInput() {
    return this._privKeyPath;
  }

  // reject_unauthorized - computed: true, optional: true, required: false
  private _rejectUnauthorized?: boolean | cdktf.IResolvable; 
  public get rejectUnauthorized() {
    return this.getBooleanAttribute('reject_unauthorized');
  }
  public set rejectUnauthorized(value: boolean | cdktf.IResolvable) {
    this._rejectUnauthorized = value;
  }
  public resetRejectUnauthorized() {
    this._rejectUnauthorized = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectUnauthorizedInput() {
    return this._rejectUnauthorized;
  }

  // servername - computed: false, optional: true, required: false
  private _servername?: string; 
  public get servername() {
    return this.getStringAttribute('servername');
  }
  public set servername(value: string) {
    this._servername = value;
  }
  public resetServername() {
    this._servername = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get servernameInput() {
    return this._servername;
  }
}
export interface PackDestinationOutputConfluentCloudKafkaSchemaRegistry {
  /**
  * Credentials to use when authenticating with the schema registry using basic HTTP authentication
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#auth PackDestination#auth}
  */
  readonly auth?: PackDestinationOutputConfluentCloudKafkaSchemaRegistryAuth;
  /**
  * Maximum time to wait for a Schema Registry connection to complete successfully. Default: 30000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#connection_timeout PackDestination#connection_timeout}
  */
  readonly connectionTimeout?: number;
  /**
  * Used when __keySchemaIdOut is not present, to transform key values, leave blank if key transformation is not required by default.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#default_key_schema_id PackDestination#default_key_schema_id}
  */
  readonly defaultKeySchemaId?: number;
  /**
  * Used when __valueSchemaIdOut is not present, to transform _raw, leave blank if value transformation is not required by default.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#default_value_schema_id PackDestination#default_value_schema_id}
  */
  readonly defaultValueSchemaId?: number;
  /**
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#disabled PackDestination#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * Maximum number of times to try fetching schemas from the Schema Registry. Default: 1
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_retries PackDestination#max_retries}
  */
  readonly maxRetries?: number;
  /**
  * Maximum time to wait for the Schema Registry to respond to a request. Default: 30000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#request_timeout PackDestination#request_timeout}
  */
  readonly requestTimeout?: number;
  /**
  * URL for accessing the Confluent Schema Registry. Example: http://localhost:8081. To connect over TLS, use https instead of http. Default: "http://localhost:8081"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#schema_registry_url PackDestination#schema_registry_url}
  */
  readonly schemaRegistryUrl?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#tls PackDestination#tls}
  */
  readonly tls?: PackDestinationOutputConfluentCloudKafkaSchemaRegistryTls;
}

export function packDestinationOutputConfluentCloudKafkaSchemaRegistryToTerraform(struct?: PackDestinationOutputConfluentCloudKafkaSchemaRegistry | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    auth: packDestinationOutputConfluentCloudKafkaSchemaRegistryAuthToTerraform(struct!.auth),
    connection_timeout: cdktf.numberToTerraform(struct!.connectionTimeout),
    default_key_schema_id: cdktf.numberToTerraform(struct!.defaultKeySchemaId),
    default_value_schema_id: cdktf.numberToTerraform(struct!.defaultValueSchemaId),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    max_retries: cdktf.numberToTerraform(struct!.maxRetries),
    request_timeout: cdktf.numberToTerraform(struct!.requestTimeout),
    schema_registry_url: cdktf.stringToTerraform(struct!.schemaRegistryUrl),
    tls: packDestinationOutputConfluentCloudKafkaSchemaRegistryTlsToTerraform(struct!.tls),
  }
}


export function packDestinationOutputConfluentCloudKafkaSchemaRegistryToHclTerraform(struct?: PackDestinationOutputConfluentCloudKafkaSchemaRegistry | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    auth: {
      value: packDestinationOutputConfluentCloudKafkaSchemaRegistryAuthToHclTerraform(struct!.auth),
      isBlock: true,
      type: "struct",
      storageClassType: "PackDestinationOutputConfluentCloudKafkaSchemaRegistryAuth",
    },
    connection_timeout: {
      value: cdktf.numberToHclTerraform(struct!.connectionTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    default_key_schema_id: {
      value: cdktf.numberToHclTerraform(struct!.defaultKeySchemaId),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    default_value_schema_id: {
      value: cdktf.numberToHclTerraform(struct!.defaultValueSchemaId),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    max_retries: {
      value: cdktf.numberToHclTerraform(struct!.maxRetries),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    request_timeout: {
      value: cdktf.numberToHclTerraform(struct!.requestTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    schema_registry_url: {
      value: cdktf.stringToHclTerraform(struct!.schemaRegistryUrl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tls: {
      value: packDestinationOutputConfluentCloudKafkaSchemaRegistryTlsToHclTerraform(struct!.tls),
      isBlock: true,
      type: "struct",
      storageClassType: "PackDestinationOutputConfluentCloudKafkaSchemaRegistryTls",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputConfluentCloudKafkaSchemaRegistryOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackDestinationOutputConfluentCloudKafkaSchemaRegistry | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._auth?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.auth = this._auth?.internalValue;
    }
    if (this._connectionTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.connectionTimeout = this._connectionTimeout;
    }
    if (this._defaultKeySchemaId !== undefined) {
      hasAnyValues = true;
      internalValueResult.defaultKeySchemaId = this._defaultKeySchemaId;
    }
    if (this._defaultValueSchemaId !== undefined) {
      hasAnyValues = true;
      internalValueResult.defaultValueSchemaId = this._defaultValueSchemaId;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._maxRetries !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxRetries = this._maxRetries;
    }
    if (this._requestTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.requestTimeout = this._requestTimeout;
    }
    if (this._schemaRegistryUrl !== undefined) {
      hasAnyValues = true;
      internalValueResult.schemaRegistryUrl = this._schemaRegistryUrl;
    }
    if (this._tls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tls = this._tls?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputConfluentCloudKafkaSchemaRegistry | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._auth.internalValue = undefined;
      this._connectionTimeout = undefined;
      this._defaultKeySchemaId = undefined;
      this._defaultValueSchemaId = undefined;
      this._disabled = undefined;
      this._maxRetries = undefined;
      this._requestTimeout = undefined;
      this._schemaRegistryUrl = undefined;
      this._tls.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._auth.internalValue = value.auth;
      this._connectionTimeout = value.connectionTimeout;
      this._defaultKeySchemaId = value.defaultKeySchemaId;
      this._defaultValueSchemaId = value.defaultValueSchemaId;
      this._disabled = value.disabled;
      this._maxRetries = value.maxRetries;
      this._requestTimeout = value.requestTimeout;
      this._schemaRegistryUrl = value.schemaRegistryUrl;
      this._tls.internalValue = value.tls;
    }
  }

  // auth - computed: false, optional: true, required: false
  private _auth = new PackDestinationOutputConfluentCloudKafkaSchemaRegistryAuthOutputReference(this, "auth");
  public get auth() {
    return this._auth;
  }
  public putAuth(value: PackDestinationOutputConfluentCloudKafkaSchemaRegistryAuth) {
    this._auth.internalValue = value;
  }
  public resetAuth() {
    this._auth.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authInput() {
    return this._auth.internalValue;
  }

  // connection_timeout - computed: true, optional: true, required: false
  private _connectionTimeout?: number; 
  public get connectionTimeout() {
    return this.getNumberAttribute('connection_timeout');
  }
  public set connectionTimeout(value: number) {
    this._connectionTimeout = value;
  }
  public resetConnectionTimeout() {
    this._connectionTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectionTimeoutInput() {
    return this._connectionTimeout;
  }

  // default_key_schema_id - computed: false, optional: true, required: false
  private _defaultKeySchemaId?: number; 
  public get defaultKeySchemaId() {
    return this.getNumberAttribute('default_key_schema_id');
  }
  public set defaultKeySchemaId(value: number) {
    this._defaultKeySchemaId = value;
  }
  public resetDefaultKeySchemaId() {
    this._defaultKeySchemaId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get defaultKeySchemaIdInput() {
    return this._defaultKeySchemaId;
  }

  // default_value_schema_id - computed: false, optional: true, required: false
  private _defaultValueSchemaId?: number; 
  public get defaultValueSchemaId() {
    return this.getNumberAttribute('default_value_schema_id');
  }
  public set defaultValueSchemaId(value: number) {
    this._defaultValueSchemaId = value;
  }
  public resetDefaultValueSchemaId() {
    this._defaultValueSchemaId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get defaultValueSchemaIdInput() {
    return this._defaultValueSchemaId;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // max_retries - computed: true, optional: true, required: false
  private _maxRetries?: number; 
  public get maxRetries() {
    return this.getNumberAttribute('max_retries');
  }
  public set maxRetries(value: number) {
    this._maxRetries = value;
  }
  public resetMaxRetries() {
    this._maxRetries = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxRetriesInput() {
    return this._maxRetries;
  }

  // request_timeout - computed: true, optional: true, required: false
  private _requestTimeout?: number; 
  public get requestTimeout() {
    return this.getNumberAttribute('request_timeout');
  }
  public set requestTimeout(value: number) {
    this._requestTimeout = value;
  }
  public resetRequestTimeout() {
    this._requestTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestTimeoutInput() {
    return this._requestTimeout;
  }

  // schema_registry_url - computed: true, optional: true, required: false
  private _schemaRegistryUrl?: string; 
  public get schemaRegistryUrl() {
    return this.getStringAttribute('schema_registry_url');
  }
  public set schemaRegistryUrl(value: string) {
    this._schemaRegistryUrl = value;
  }
  public resetSchemaRegistryUrl() {
    this._schemaRegistryUrl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get schemaRegistryUrlInput() {
    return this._schemaRegistryUrl;
  }

  // tls - computed: false, optional: true, required: false
  private _tls = new PackDestinationOutputConfluentCloudKafkaSchemaRegistryTlsOutputReference(this, "tls");
  public get tls() {
    return this._tls;
  }
  public putTls(value: PackDestinationOutputConfluentCloudKafkaSchemaRegistryTls) {
    this._tls.internalValue = value;
  }
  public resetTls() {
    this._tls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsInput() {
    return this._tls.internalValue;
  }
}
export interface PackDestinationOutputConfluentCloudPqControls {
}

export function packDestinationOutputConfluentCloudPqControlsToTerraform(struct?: PackDestinationOutputConfluentCloudPqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function packDestinationOutputConfluentCloudPqControlsToHclTerraform(struct?: PackDestinationOutputConfluentCloudPqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class PackDestinationOutputConfluentCloudPqControlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackDestinationOutputConfluentCloudPqControls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputConfluentCloudPqControls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface PackDestinationOutputConfluentCloudSasl {
  /**
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#disabled PackDestination#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * Default: "plain"; must be one of ["plain", "scram-sha-256", "scram-sha-512", "kerberos"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#mechanism PackDestination#mechanism}
  */
  readonly mechanism?: string;
}

export function packDestinationOutputConfluentCloudSaslToTerraform(struct?: PackDestinationOutputConfluentCloudSasl | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    mechanism: cdktf.stringToTerraform(struct!.mechanism),
  }
}


export function packDestinationOutputConfluentCloudSaslToHclTerraform(struct?: PackDestinationOutputConfluentCloudSasl | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    mechanism: {
      value: cdktf.stringToHclTerraform(struct!.mechanism),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputConfluentCloudSaslOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackDestinationOutputConfluentCloudSasl | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._mechanism !== undefined) {
      hasAnyValues = true;
      internalValueResult.mechanism = this._mechanism;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputConfluentCloudSasl | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._disabled = undefined;
      this._mechanism = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._disabled = value.disabled;
      this._mechanism = value.mechanism;
    }
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // mechanism - computed: true, optional: true, required: false
  private _mechanism?: string; 
  public get mechanism() {
    return this.getStringAttribute('mechanism');
  }
  public set mechanism(value: string) {
    this._mechanism = value;
  }
  public resetMechanism() {
    this._mechanism = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get mechanismInput() {
    return this._mechanism;
  }
}
export interface PackDestinationOutputConfluentCloudTls {
  /**
  * Path on client in which to find CA certificates to verify the server's cert. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#ca_path PackDestination#ca_path}
  */
  readonly caPath?: string;
  /**
  * Path on client in which to find certificates to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#cert_path PackDestination#cert_path}
  */
  readonly certPath?: string;
  /**
  * The name of the predefined certificate
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#certificate_name PackDestination#certificate_name}
  */
  readonly certificateName?: string;
  /**
  * Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#disabled PackDestination#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_version PackDestination#max_version}
  */
  readonly maxVersion?: string;
  /**
  * must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#min_version PackDestination#min_version}
  */
  readonly minVersion?: string;
  /**
  * Passphrase to use to decrypt private key
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#passphrase PackDestination#passphrase}
  */
  readonly passphrase?: string;
  /**
  * Path on client in which to find the private key to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#priv_key_path PackDestination#priv_key_path}
  */
  readonly privKeyPath?: string;
  /**
  * Reject certificates that are not authorized by a CA in the CA certificate path, or by another 
  *                     trusted CA (such as the system's). Defaults to Enabled. Overrides the toggle from Advanced Settings, when also present.
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#reject_unauthorized PackDestination#reject_unauthorized}
  */
  readonly rejectUnauthorized?: boolean | cdktf.IResolvable;
  /**
  * Server name for the SNI (Server Name Indication) TLS extension. It must be a host name, and not an IP address.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#servername PackDestination#servername}
  */
  readonly servername?: string;
}

export function packDestinationOutputConfluentCloudTlsToTerraform(struct?: PackDestinationOutputConfluentCloudTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ca_path: cdktf.stringToTerraform(struct!.caPath),
    cert_path: cdktf.stringToTerraform(struct!.certPath),
    certificate_name: cdktf.stringToTerraform(struct!.certificateName),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    max_version: cdktf.stringToTerraform(struct!.maxVersion),
    min_version: cdktf.stringToTerraform(struct!.minVersion),
    passphrase: cdktf.stringToTerraform(struct!.passphrase),
    priv_key_path: cdktf.stringToTerraform(struct!.privKeyPath),
    reject_unauthorized: cdktf.booleanToTerraform(struct!.rejectUnauthorized),
    servername: cdktf.stringToTerraform(struct!.servername),
  }
}


export function packDestinationOutputConfluentCloudTlsToHclTerraform(struct?: PackDestinationOutputConfluentCloudTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ca_path: {
      value: cdktf.stringToHclTerraform(struct!.caPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    cert_path: {
      value: cdktf.stringToHclTerraform(struct!.certPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    certificate_name: {
      value: cdktf.stringToHclTerraform(struct!.certificateName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    max_version: {
      value: cdktf.stringToHclTerraform(struct!.maxVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    min_version: {
      value: cdktf.stringToHclTerraform(struct!.minVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    passphrase: {
      value: cdktf.stringToHclTerraform(struct!.passphrase),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    priv_key_path: {
      value: cdktf.stringToHclTerraform(struct!.privKeyPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reject_unauthorized: {
      value: cdktf.booleanToHclTerraform(struct!.rejectUnauthorized),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    servername: {
      value: cdktf.stringToHclTerraform(struct!.servername),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputConfluentCloudTlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackDestinationOutputConfluentCloudTls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._caPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.caPath = this._caPath;
    }
    if (this._certPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.certPath = this._certPath;
    }
    if (this._certificateName !== undefined) {
      hasAnyValues = true;
      internalValueResult.certificateName = this._certificateName;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._maxVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxVersion = this._maxVersion;
    }
    if (this._minVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.minVersion = this._minVersion;
    }
    if (this._passphrase !== undefined) {
      hasAnyValues = true;
      internalValueResult.passphrase = this._passphrase;
    }
    if (this._privKeyPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.privKeyPath = this._privKeyPath;
    }
    if (this._rejectUnauthorized !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectUnauthorized = this._rejectUnauthorized;
    }
    if (this._servername !== undefined) {
      hasAnyValues = true;
      internalValueResult.servername = this._servername;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputConfluentCloudTls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._caPath = undefined;
      this._certPath = undefined;
      this._certificateName = undefined;
      this._disabled = undefined;
      this._maxVersion = undefined;
      this._minVersion = undefined;
      this._passphrase = undefined;
      this._privKeyPath = undefined;
      this._rejectUnauthorized = undefined;
      this._servername = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._caPath = value.caPath;
      this._certPath = value.certPath;
      this._certificateName = value.certificateName;
      this._disabled = value.disabled;
      this._maxVersion = value.maxVersion;
      this._minVersion = value.minVersion;
      this._passphrase = value.passphrase;
      this._privKeyPath = value.privKeyPath;
      this._rejectUnauthorized = value.rejectUnauthorized;
      this._servername = value.servername;
    }
  }

  // ca_path - computed: false, optional: true, required: false
  private _caPath?: string; 
  public get caPath() {
    return this.getStringAttribute('ca_path');
  }
  public set caPath(value: string) {
    this._caPath = value;
  }
  public resetCaPath() {
    this._caPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get caPathInput() {
    return this._caPath;
  }

  // cert_path - computed: false, optional: true, required: false
  private _certPath?: string; 
  public get certPath() {
    return this.getStringAttribute('cert_path');
  }
  public set certPath(value: string) {
    this._certPath = value;
  }
  public resetCertPath() {
    this._certPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certPathInput() {
    return this._certPath;
  }

  // certificate_name - computed: false, optional: true, required: false
  private _certificateName?: string; 
  public get certificateName() {
    return this.getStringAttribute('certificate_name');
  }
  public set certificateName(value: string) {
    this._certificateName = value;
  }
  public resetCertificateName() {
    this._certificateName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certificateNameInput() {
    return this._certificateName;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // max_version - computed: false, optional: true, required: false
  private _maxVersion?: string; 
  public get maxVersion() {
    return this.getStringAttribute('max_version');
  }
  public set maxVersion(value: string) {
    this._maxVersion = value;
  }
  public resetMaxVersion() {
    this._maxVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxVersionInput() {
    return this._maxVersion;
  }

  // min_version - computed: false, optional: true, required: false
  private _minVersion?: string; 
  public get minVersion() {
    return this.getStringAttribute('min_version');
  }
  public set minVersion(value: string) {
    this._minVersion = value;
  }
  public resetMinVersion() {
    this._minVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get minVersionInput() {
    return this._minVersion;
  }

  // passphrase - computed: false, optional: true, required: false
  private _passphrase?: string; 
  public get passphrase() {
    return this.getStringAttribute('passphrase');
  }
  public set passphrase(value: string) {
    this._passphrase = value;
  }
  public resetPassphrase() {
    this._passphrase = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passphraseInput() {
    return this._passphrase;
  }

  // priv_key_path - computed: false, optional: true, required: false
  private _privKeyPath?: string; 
  public get privKeyPath() {
    return this.getStringAttribute('priv_key_path');
  }
  public set privKeyPath(value: string) {
    this._privKeyPath = value;
  }
  public resetPrivKeyPath() {
    this._privKeyPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get privKeyPathInput() {
    return this._privKeyPath;
  }

  // reject_unauthorized - computed: true, optional: true, required: false
  private _rejectUnauthorized?: boolean | cdktf.IResolvable; 
  public get rejectUnauthorized() {
    return this.getBooleanAttribute('reject_unauthorized');
  }
  public set rejectUnauthorized(value: boolean | cdktf.IResolvable) {
    this._rejectUnauthorized = value;
  }
  public resetRejectUnauthorized() {
    this._rejectUnauthorized = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectUnauthorizedInput() {
    return this._rejectUnauthorized;
  }

  // servername - computed: false, optional: true, required: false
  private _servername?: string; 
  public get servername() {
    return this.getStringAttribute('servername');
  }
  public set servername(value: string) {
    this._servername = value;
  }
  public resetServername() {
    this._servername = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get servernameInput() {
    return this._servername;
  }
}
export interface PackDestinationOutputConfluentCloud {
  /**
  * Control the number of required acknowledgments. Default: 1; must be one of ["1", "0", "-1"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#ack PackDestination#ack}
  */
  readonly ack?: number;
  /**
  * Maximum time to wait for Kafka to respond to an authentication request. Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#authentication_timeout PackDestination#authentication_timeout}
  */
  readonly authenticationTimeout?: number;
  /**
  * Set the backoff multiplier (2-20) to control the retry frequency for failed messages. For faster retries, use a lower multiplier. For slower retries with more delay between attempts, use a higher multiplier. The multiplier is used in an exponential backoff formula; see the Kafka [documentation](https://kafka.js.org/docs/retry-detailed) for details. Default: 2
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#backoff_rate PackDestination#backoff_rate}
  */
  readonly backoffRate?: number;
  /**
  * List of Confluent Cloud bootstrap servers to use, such as yourAccount.confluent.cloud:9092.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#brokers PackDestination#brokers}
  */
  readonly brokers: string[];
  /**
  * Codec to use to compress the data before sending to Kafka. Default: "gzip"; must be one of ["none", "gzip", "snappy", "lz4"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#compression PackDestination#compression}
  */
  readonly compression?: string;
  /**
  * Maximum time to wait for a connection to complete successfully. Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#connection_timeout PackDestination#connection_timeout}
  */
  readonly connectionTimeout?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#description PackDestination#description}
  */
  readonly description?: string;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#environment PackDestination#environment}
  */
  readonly environment?: string;
  /**
  * The maximum number of events you want the Destination to allow in a batch before forcing a flush. Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#flush_event_count PackDestination#flush_event_count}
  */
  readonly flushEventCount?: number;
  /**
  * The maximum amount of time you want the Destination to wait before forcing a flush. Shorter intervals tend to result in smaller batches being sent. Default: 1
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#flush_period_sec PackDestination#flush_period_sec}
  */
  readonly flushPeriodSec?: number;
  /**
  * Format to use to serialize events before writing to Kafka. Default: "json"; must be one of ["json", "raw", "protobuf"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#format PackDestination#format}
  */
  readonly format?: string;
  /**
  * Unique ID for this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#id PackDestination#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * Initial value used to calculate the retry, in milliseconds. Maximum is 600,000 ms (10 minutes). Default: 300
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#initial_backoff PackDestination#initial_backoff}
  */
  readonly initialBackoff?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#kafka_schema_registry PackDestination#kafka_schema_registry}
  */
  readonly kafkaSchemaRegistry?: PackDestinationOutputConfluentCloudKafkaSchemaRegistry;
  /**
  * The maximum wait time for a retry, in milliseconds. Default (and minimum) is 30,000 ms (30 seconds); maximum is 180,000 ms (180 seconds). Default: 30000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_back_off PackDestination#max_back_off}
  */
  readonly maxBackOff?: number;
  /**
  * Maximum size of each record batch before compression. The value must not exceed the Kafka brokers' message.max.bytes setting. Default: 768
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_record_size_kb PackDestination#max_record_size_kb}
  */
  readonly maxRecordSizeKb?: number;
  /**
  * If messages are failing, you can set the maximum number of retries as high as 100 to prevent loss of data. Default: 5
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_retries PackDestination#max_retries}
  */
  readonly maxRetries?: number;
  /**
  * How to handle events when all receivers are exerting backpressure. Default: "block"; must be one of ["block", "drop", "queue"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#on_backpressure PackDestination#on_backpressure}
  */
  readonly onBackpressure?: string;
  /**
  * Pipeline to process data before sending out to this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pipeline PackDestination#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_compress PackDestination#pq_compress}
  */
  readonly pqCompress?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_controls PackDestination#pq_controls}
  */
  readonly pqControls?: PackDestinationOutputConfluentCloudPqControls;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.). Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_max_file_size PackDestination#pq_max_file_size}
  */
  readonly pqMaxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_max_size PackDestination#pq_max_size}
  */
  readonly pqMaxSize?: string;
  /**
  * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem. Default: "error"; must be one of ["error", "backpressure", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_mode PackDestination#pq_mode}
  */
  readonly pqMode?: string;
  /**
  * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged. Default: "block"; must be one of ["block", "drop"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_on_backpressure PackDestination#pq_on_backpressure}
  */
  readonly pqOnBackpressure?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_path PackDestination#pq_path}
  */
  readonly pqPath?: string;
  /**
  * Select a set of Protobuf definitions for the events you want to send
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#protobuf_library_id PackDestination#protobuf_library_id}
  */
  readonly protobufLibraryId?: string;
  /**
  * Specifies a time window during which @{product} can reauthenticate if needed. Creates the window measuring backward from the moment when credentials are set to expire. Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#reauthentication_threshold PackDestination#reauthentication_threshold}
  */
  readonly reauthenticationThreshold?: number;
  /**
  * Maximum time to wait for Kafka to respond to a request. Default: 60000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#request_timeout PackDestination#request_timeout}
  */
  readonly requestTimeout?: number;
  /**
  * Authentication parameters to use when connecting to brokers. Using TLS is highly recommended.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#sasl PackDestination#sasl}
  */
  readonly sasl?: PackDestinationOutputConfluentCloudSasl;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#streamtags PackDestination#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Fields to automatically add to events, such as cribl_pipe. Supports wildcards. Default: ["cribl_pipe"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#system_fields PackDestination#system_fields}
  */
  readonly systemFields?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#tls PackDestination#tls}
  */
  readonly tls?: PackDestinationOutputConfluentCloudTls;
  /**
  * The topic to publish events to. Can be overridden using the __topicOut field.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#topic PackDestination#topic}
  */
  readonly topic: string;
  /**
  * must be "confluent_cloud"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#type PackDestination#type}
  */
  readonly type?: string;
}

export function packDestinationOutputConfluentCloudToTerraform(struct?: PackDestinationOutputConfluentCloud | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ack: cdktf.numberToTerraform(struct!.ack),
    authentication_timeout: cdktf.numberToTerraform(struct!.authenticationTimeout),
    backoff_rate: cdktf.numberToTerraform(struct!.backoffRate),
    brokers: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.brokers),
    compression: cdktf.stringToTerraform(struct!.compression),
    connection_timeout: cdktf.numberToTerraform(struct!.connectionTimeout),
    description: cdktf.stringToTerraform(struct!.description),
    environment: cdktf.stringToTerraform(struct!.environment),
    flush_event_count: cdktf.numberToTerraform(struct!.flushEventCount),
    flush_period_sec: cdktf.numberToTerraform(struct!.flushPeriodSec),
    format: cdktf.stringToTerraform(struct!.format),
    id: cdktf.stringToTerraform(struct!.id),
    initial_backoff: cdktf.numberToTerraform(struct!.initialBackoff),
    kafka_schema_registry: packDestinationOutputConfluentCloudKafkaSchemaRegistryToTerraform(struct!.kafkaSchemaRegistry),
    max_back_off: cdktf.numberToTerraform(struct!.maxBackOff),
    max_record_size_kb: cdktf.numberToTerraform(struct!.maxRecordSizeKb),
    max_retries: cdktf.numberToTerraform(struct!.maxRetries),
    on_backpressure: cdktf.stringToTerraform(struct!.onBackpressure),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    pq_compress: cdktf.stringToTerraform(struct!.pqCompress),
    pq_controls: packDestinationOutputConfluentCloudPqControlsToTerraform(struct!.pqControls),
    pq_max_file_size: cdktf.stringToTerraform(struct!.pqMaxFileSize),
    pq_max_size: cdktf.stringToTerraform(struct!.pqMaxSize),
    pq_mode: cdktf.stringToTerraform(struct!.pqMode),
    pq_on_backpressure: cdktf.stringToTerraform(struct!.pqOnBackpressure),
    pq_path: cdktf.stringToTerraform(struct!.pqPath),
    protobuf_library_id: cdktf.stringToTerraform(struct!.protobufLibraryId),
    reauthentication_threshold: cdktf.numberToTerraform(struct!.reauthenticationThreshold),
    request_timeout: cdktf.numberToTerraform(struct!.requestTimeout),
    sasl: packDestinationOutputConfluentCloudSaslToTerraform(struct!.sasl),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    system_fields: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.systemFields),
    tls: packDestinationOutputConfluentCloudTlsToTerraform(struct!.tls),
    topic: cdktf.stringToTerraform(struct!.topic),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function packDestinationOutputConfluentCloudToHclTerraform(struct?: PackDestinationOutputConfluentCloud | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ack: {
      value: cdktf.numberToHclTerraform(struct!.ack),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    authentication_timeout: {
      value: cdktf.numberToHclTerraform(struct!.authenticationTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    backoff_rate: {
      value: cdktf.numberToHclTerraform(struct!.backoffRate),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    brokers: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.brokers),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    compression: {
      value: cdktf.stringToHclTerraform(struct!.compression),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    connection_timeout: {
      value: cdktf.numberToHclTerraform(struct!.connectionTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    flush_event_count: {
      value: cdktf.numberToHclTerraform(struct!.flushEventCount),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    flush_period_sec: {
      value: cdktf.numberToHclTerraform(struct!.flushPeriodSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    format: {
      value: cdktf.stringToHclTerraform(struct!.format),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    initial_backoff: {
      value: cdktf.numberToHclTerraform(struct!.initialBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    kafka_schema_registry: {
      value: packDestinationOutputConfluentCloudKafkaSchemaRegistryToHclTerraform(struct!.kafkaSchemaRegistry),
      isBlock: true,
      type: "struct",
      storageClassType: "PackDestinationOutputConfluentCloudKafkaSchemaRegistry",
    },
    max_back_off: {
      value: cdktf.numberToHclTerraform(struct!.maxBackOff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_record_size_kb: {
      value: cdktf.numberToHclTerraform(struct!.maxRecordSizeKb),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_retries: {
      value: cdktf.numberToHclTerraform(struct!.maxRetries),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.onBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_compress: {
      value: cdktf.stringToHclTerraform(struct!.pqCompress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_controls: {
      value: packDestinationOutputConfluentCloudPqControlsToHclTerraform(struct!.pqControls),
      isBlock: true,
      type: "struct",
      storageClassType: "PackDestinationOutputConfluentCloudPqControls",
    },
    pq_max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_max_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_mode: {
      value: cdktf.stringToHclTerraform(struct!.pqMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.pqOnBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_path: {
      value: cdktf.stringToHclTerraform(struct!.pqPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    protobuf_library_id: {
      value: cdktf.stringToHclTerraform(struct!.protobufLibraryId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reauthentication_threshold: {
      value: cdktf.numberToHclTerraform(struct!.reauthenticationThreshold),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    request_timeout: {
      value: cdktf.numberToHclTerraform(struct!.requestTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    sasl: {
      value: packDestinationOutputConfluentCloudSaslToHclTerraform(struct!.sasl),
      isBlock: true,
      type: "struct",
      storageClassType: "PackDestinationOutputConfluentCloudSasl",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    system_fields: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.systemFields),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    tls: {
      value: packDestinationOutputConfluentCloudTlsToHclTerraform(struct!.tls),
      isBlock: true,
      type: "struct",
      storageClassType: "PackDestinationOutputConfluentCloudTls",
    },
    topic: {
      value: cdktf.stringToHclTerraform(struct!.topic),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputConfluentCloudOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackDestinationOutputConfluentCloud | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._ack !== undefined) {
      hasAnyValues = true;
      internalValueResult.ack = this._ack;
    }
    if (this._authenticationTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.authenticationTimeout = this._authenticationTimeout;
    }
    if (this._backoffRate !== undefined) {
      hasAnyValues = true;
      internalValueResult.backoffRate = this._backoffRate;
    }
    if (this._brokers !== undefined) {
      hasAnyValues = true;
      internalValueResult.brokers = this._brokers;
    }
    if (this._compression !== undefined) {
      hasAnyValues = true;
      internalValueResult.compression = this._compression;
    }
    if (this._connectionTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.connectionTimeout = this._connectionTimeout;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._flushEventCount !== undefined) {
      hasAnyValues = true;
      internalValueResult.flushEventCount = this._flushEventCount;
    }
    if (this._flushPeriodSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.flushPeriodSec = this._flushPeriodSec;
    }
    if (this._format !== undefined) {
      hasAnyValues = true;
      internalValueResult.format = this._format;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._initialBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.initialBackoff = this._initialBackoff;
    }
    if (this._kafkaSchemaRegistry?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.kafkaSchemaRegistry = this._kafkaSchemaRegistry?.internalValue;
    }
    if (this._maxBackOff !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBackOff = this._maxBackOff;
    }
    if (this._maxRecordSizeKb !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxRecordSizeKb = this._maxRecordSizeKb;
    }
    if (this._maxRetries !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxRetries = this._maxRetries;
    }
    if (this._onBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.onBackpressure = this._onBackpressure;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._pqCompress !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqCompress = this._pqCompress;
    }
    if (this._pqControls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqControls = this._pqControls?.internalValue;
    }
    if (this._pqMaxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxFileSize = this._pqMaxFileSize;
    }
    if (this._pqMaxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxSize = this._pqMaxSize;
    }
    if (this._pqMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMode = this._pqMode;
    }
    if (this._pqOnBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqOnBackpressure = this._pqOnBackpressure;
    }
    if (this._pqPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqPath = this._pqPath;
    }
    if (this._protobufLibraryId !== undefined) {
      hasAnyValues = true;
      internalValueResult.protobufLibraryId = this._protobufLibraryId;
    }
    if (this._reauthenticationThreshold !== undefined) {
      hasAnyValues = true;
      internalValueResult.reauthenticationThreshold = this._reauthenticationThreshold;
    }
    if (this._requestTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.requestTimeout = this._requestTimeout;
    }
    if (this._sasl?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.sasl = this._sasl?.internalValue;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._systemFields !== undefined) {
      hasAnyValues = true;
      internalValueResult.systemFields = this._systemFields;
    }
    if (this._tls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tls = this._tls?.internalValue;
    }
    if (this._topic !== undefined) {
      hasAnyValues = true;
      internalValueResult.topic = this._topic;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputConfluentCloud | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._ack = undefined;
      this._authenticationTimeout = undefined;
      this._backoffRate = undefined;
      this._brokers = undefined;
      this._compression = undefined;
      this._connectionTimeout = undefined;
      this._description = undefined;
      this._environment = undefined;
      this._flushEventCount = undefined;
      this._flushPeriodSec = undefined;
      this._format = undefined;
      this._id = undefined;
      this._initialBackoff = undefined;
      this._kafkaSchemaRegistry.internalValue = undefined;
      this._maxBackOff = undefined;
      this._maxRecordSizeKb = undefined;
      this._maxRetries = undefined;
      this._onBackpressure = undefined;
      this._pipeline = undefined;
      this._pqCompress = undefined;
      this._pqControls.internalValue = undefined;
      this._pqMaxFileSize = undefined;
      this._pqMaxSize = undefined;
      this._pqMode = undefined;
      this._pqOnBackpressure = undefined;
      this._pqPath = undefined;
      this._protobufLibraryId = undefined;
      this._reauthenticationThreshold = undefined;
      this._requestTimeout = undefined;
      this._sasl.internalValue = undefined;
      this._streamtags = undefined;
      this._systemFields = undefined;
      this._tls.internalValue = undefined;
      this._topic = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._ack = value.ack;
      this._authenticationTimeout = value.authenticationTimeout;
      this._backoffRate = value.backoffRate;
      this._brokers = value.brokers;
      this._compression = value.compression;
      this._connectionTimeout = value.connectionTimeout;
      this._description = value.description;
      this._environment = value.environment;
      this._flushEventCount = value.flushEventCount;
      this._flushPeriodSec = value.flushPeriodSec;
      this._format = value.format;
      this._id = value.id;
      this._initialBackoff = value.initialBackoff;
      this._kafkaSchemaRegistry.internalValue = value.kafkaSchemaRegistry;
      this._maxBackOff = value.maxBackOff;
      this._maxRecordSizeKb = value.maxRecordSizeKb;
      this._maxRetries = value.maxRetries;
      this._onBackpressure = value.onBackpressure;
      this._pipeline = value.pipeline;
      this._pqCompress = value.pqCompress;
      this._pqControls.internalValue = value.pqControls;
      this._pqMaxFileSize = value.pqMaxFileSize;
      this._pqMaxSize = value.pqMaxSize;
      this._pqMode = value.pqMode;
      this._pqOnBackpressure = value.pqOnBackpressure;
      this._pqPath = value.pqPath;
      this._protobufLibraryId = value.protobufLibraryId;
      this._reauthenticationThreshold = value.reauthenticationThreshold;
      this._requestTimeout = value.requestTimeout;
      this._sasl.internalValue = value.sasl;
      this._streamtags = value.streamtags;
      this._systemFields = value.systemFields;
      this._tls.internalValue = value.tls;
      this._topic = value.topic;
      this._type = value.type;
    }
  }

  // ack - computed: true, optional: true, required: false
  private _ack?: number; 
  public get ack() {
    return this.getNumberAttribute('ack');
  }
  public set ack(value: number) {
    this._ack = value;
  }
  public resetAck() {
    this._ack = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ackInput() {
    return this._ack;
  }

  // authentication_timeout - computed: true, optional: true, required: false
  private _authenticationTimeout?: number; 
  public get authenticationTimeout() {
    return this.getNumberAttribute('authentication_timeout');
  }
  public set authenticationTimeout(value: number) {
    this._authenticationTimeout = value;
  }
  public resetAuthenticationTimeout() {
    this._authenticationTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authenticationTimeoutInput() {
    return this._authenticationTimeout;
  }

  // backoff_rate - computed: true, optional: true, required: false
  private _backoffRate?: number; 
  public get backoffRate() {
    return this.getNumberAttribute('backoff_rate');
  }
  public set backoffRate(value: number) {
    this._backoffRate = value;
  }
  public resetBackoffRate() {
    this._backoffRate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get backoffRateInput() {
    return this._backoffRate;
  }

  // brokers - computed: false, optional: false, required: true
  private _brokers?: string[]; 
  public get brokers() {
    return this.getListAttribute('brokers');
  }
  public set brokers(value: string[]) {
    this._brokers = value;
  }
  // Temporarily expose input value. Use with caution.
  public get brokersInput() {
    return this._brokers;
  }

  // compression - computed: true, optional: true, required: false
  private _compression?: string; 
  public get compression() {
    return this.getStringAttribute('compression');
  }
  public set compression(value: string) {
    this._compression = value;
  }
  public resetCompression() {
    this._compression = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressionInput() {
    return this._compression;
  }

  // connection_timeout - computed: true, optional: true, required: false
  private _connectionTimeout?: number; 
  public get connectionTimeout() {
    return this.getNumberAttribute('connection_timeout');
  }
  public set connectionTimeout(value: number) {
    this._connectionTimeout = value;
  }
  public resetConnectionTimeout() {
    this._connectionTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectionTimeoutInput() {
    return this._connectionTimeout;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // flush_event_count - computed: true, optional: true, required: false
  private _flushEventCount?: number; 
  public get flushEventCount() {
    return this.getNumberAttribute('flush_event_count');
  }
  public set flushEventCount(value: number) {
    this._flushEventCount = value;
  }
  public resetFlushEventCount() {
    this._flushEventCount = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get flushEventCountInput() {
    return this._flushEventCount;
  }

  // flush_period_sec - computed: true, optional: true, required: false
  private _flushPeriodSec?: number; 
  public get flushPeriodSec() {
    return this.getNumberAttribute('flush_period_sec');
  }
  public set flushPeriodSec(value: number) {
    this._flushPeriodSec = value;
  }
  public resetFlushPeriodSec() {
    this._flushPeriodSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get flushPeriodSecInput() {
    return this._flushPeriodSec;
  }

  // format - computed: true, optional: true, required: false
  private _format?: string; 
  public get format() {
    return this.getStringAttribute('format');
  }
  public set format(value: string) {
    this._format = value;
  }
  public resetFormat() {
    this._format = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get formatInput() {
    return this._format;
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // initial_backoff - computed: true, optional: true, required: false
  private _initialBackoff?: number; 
  public get initialBackoff() {
    return this.getNumberAttribute('initial_backoff');
  }
  public set initialBackoff(value: number) {
    this._initialBackoff = value;
  }
  public resetInitialBackoff() {
    this._initialBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get initialBackoffInput() {
    return this._initialBackoff;
  }

  // kafka_schema_registry - computed: false, optional: true, required: false
  private _kafkaSchemaRegistry = new PackDestinationOutputConfluentCloudKafkaSchemaRegistryOutputReference(this, "kafka_schema_registry");
  public get kafkaSchemaRegistry() {
    return this._kafkaSchemaRegistry;
  }
  public putKafkaSchemaRegistry(value: PackDestinationOutputConfluentCloudKafkaSchemaRegistry) {
    this._kafkaSchemaRegistry.internalValue = value;
  }
  public resetKafkaSchemaRegistry() {
    this._kafkaSchemaRegistry.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get kafkaSchemaRegistryInput() {
    return this._kafkaSchemaRegistry.internalValue;
  }

  // max_back_off - computed: true, optional: true, required: false
  private _maxBackOff?: number; 
  public get maxBackOff() {
    return this.getNumberAttribute('max_back_off');
  }
  public set maxBackOff(value: number) {
    this._maxBackOff = value;
  }
  public resetMaxBackOff() {
    this._maxBackOff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBackOffInput() {
    return this._maxBackOff;
  }

  // max_record_size_kb - computed: true, optional: true, required: false
  private _maxRecordSizeKb?: number; 
  public get maxRecordSizeKb() {
    return this.getNumberAttribute('max_record_size_kb');
  }
  public set maxRecordSizeKb(value: number) {
    this._maxRecordSizeKb = value;
  }
  public resetMaxRecordSizeKb() {
    this._maxRecordSizeKb = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxRecordSizeKbInput() {
    return this._maxRecordSizeKb;
  }

  // max_retries - computed: true, optional: true, required: false
  private _maxRetries?: number; 
  public get maxRetries() {
    return this.getNumberAttribute('max_retries');
  }
  public set maxRetries(value: number) {
    this._maxRetries = value;
  }
  public resetMaxRetries() {
    this._maxRetries = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxRetriesInput() {
    return this._maxRetries;
  }

  // on_backpressure - computed: true, optional: true, required: false
  private _onBackpressure?: string; 
  public get onBackpressure() {
    return this.getStringAttribute('on_backpressure');
  }
  public set onBackpressure(value: string) {
    this._onBackpressure = value;
  }
  public resetOnBackpressure() {
    this._onBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get onBackpressureInput() {
    return this._onBackpressure;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // pq_compress - computed: true, optional: true, required: false
  private _pqCompress?: string; 
  public get pqCompress() {
    return this.getStringAttribute('pq_compress');
  }
  public set pqCompress(value: string) {
    this._pqCompress = value;
  }
  public resetPqCompress() {
    this._pqCompress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqCompressInput() {
    return this._pqCompress;
  }

  // pq_controls - computed: false, optional: true, required: false
  private _pqControls = new PackDestinationOutputConfluentCloudPqControlsOutputReference(this, "pq_controls");
  public get pqControls() {
    return this._pqControls;
  }
  public putPqControls(value: PackDestinationOutputConfluentCloudPqControls) {
    this._pqControls.internalValue = value;
  }
  public resetPqControls() {
    this._pqControls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqControlsInput() {
    return this._pqControls.internalValue;
  }

  // pq_max_file_size - computed: true, optional: true, required: false
  private _pqMaxFileSize?: string; 
  public get pqMaxFileSize() {
    return this.getStringAttribute('pq_max_file_size');
  }
  public set pqMaxFileSize(value: string) {
    this._pqMaxFileSize = value;
  }
  public resetPqMaxFileSize() {
    this._pqMaxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxFileSizeInput() {
    return this._pqMaxFileSize;
  }

  // pq_max_size - computed: true, optional: true, required: false
  private _pqMaxSize?: string; 
  public get pqMaxSize() {
    return this.getStringAttribute('pq_max_size');
  }
  public set pqMaxSize(value: string) {
    this._pqMaxSize = value;
  }
  public resetPqMaxSize() {
    this._pqMaxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxSizeInput() {
    return this._pqMaxSize;
  }

  // pq_mode - computed: true, optional: true, required: false
  private _pqMode?: string; 
  public get pqMode() {
    return this.getStringAttribute('pq_mode');
  }
  public set pqMode(value: string) {
    this._pqMode = value;
  }
  public resetPqMode() {
    this._pqMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqModeInput() {
    return this._pqMode;
  }

  // pq_on_backpressure - computed: true, optional: true, required: false
  private _pqOnBackpressure?: string; 
  public get pqOnBackpressure() {
    return this.getStringAttribute('pq_on_backpressure');
  }
  public set pqOnBackpressure(value: string) {
    this._pqOnBackpressure = value;
  }
  public resetPqOnBackpressure() {
    this._pqOnBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqOnBackpressureInput() {
    return this._pqOnBackpressure;
  }

  // pq_path - computed: true, optional: true, required: false
  private _pqPath?: string; 
  public get pqPath() {
    return this.getStringAttribute('pq_path');
  }
  public set pqPath(value: string) {
    this._pqPath = value;
  }
  public resetPqPath() {
    this._pqPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqPathInput() {
    return this._pqPath;
  }

  // protobuf_library_id - computed: false, optional: true, required: false
  private _protobufLibraryId?: string; 
  public get protobufLibraryId() {
    return this.getStringAttribute('protobuf_library_id');
  }
  public set protobufLibraryId(value: string) {
    this._protobufLibraryId = value;
  }
  public resetProtobufLibraryId() {
    this._protobufLibraryId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get protobufLibraryIdInput() {
    return this._protobufLibraryId;
  }

  // reauthentication_threshold - computed: true, optional: true, required: false
  private _reauthenticationThreshold?: number; 
  public get reauthenticationThreshold() {
    return this.getNumberAttribute('reauthentication_threshold');
  }
  public set reauthenticationThreshold(value: number) {
    this._reauthenticationThreshold = value;
  }
  public resetReauthenticationThreshold() {
    this._reauthenticationThreshold = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get reauthenticationThresholdInput() {
    return this._reauthenticationThreshold;
  }

  // request_timeout - computed: true, optional: true, required: false
  private _requestTimeout?: number; 
  public get requestTimeout() {
    return this.getNumberAttribute('request_timeout');
  }
  public set requestTimeout(value: number) {
    this._requestTimeout = value;
  }
  public resetRequestTimeout() {
    this._requestTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestTimeoutInput() {
    return this._requestTimeout;
  }

  // sasl - computed: false, optional: true, required: false
  private _sasl = new PackDestinationOutputConfluentCloudSaslOutputReference(this, "sasl");
  public get sasl() {
    return this._sasl;
  }
  public putSasl(value: PackDestinationOutputConfluentCloudSasl) {
    this._sasl.internalValue = value;
  }
  public resetSasl() {
    this._sasl.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get saslInput() {
    return this._sasl.internalValue;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // system_fields - computed: true, optional: true, required: false
  private _systemFields?: string[]; 
  public get systemFields() {
    return this.getListAttribute('system_fields');
  }
  public set systemFields(value: string[]) {
    this._systemFields = value;
  }
  public resetSystemFields() {
    this._systemFields = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get systemFieldsInput() {
    return this._systemFields;
  }

  // tls - computed: false, optional: true, required: false
  private _tls = new PackDestinationOutputConfluentCloudTlsOutputReference(this, "tls");
  public get tls() {
    return this._tls;
  }
  public putTls(value: PackDestinationOutputConfluentCloudTls) {
    this._tls.internalValue = value;
  }
  public resetTls() {
    this._tls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsInput() {
    return this._tls.internalValue;
  }

  // topic - computed: false, optional: false, required: true
  private _topic?: string; 
  public get topic() {
    return this.getStringAttribute('topic');
  }
  public set topic(value: string) {
    this._topic = value;
  }
  // Temporarily expose input value. Use with caution.
  public get topicInput() {
    return this._topic;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface PackDestinationOutputCriblHttpExtraHttpHeaders {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#name PackDestination#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#value PackDestination#value}
  */
  readonly value: string;
}

export function packDestinationOutputCriblHttpExtraHttpHeadersToTerraform(struct?: PackDestinationOutputCriblHttpExtraHttpHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function packDestinationOutputCriblHttpExtraHttpHeadersToHclTerraform(struct?: PackDestinationOutputCriblHttpExtraHttpHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputCriblHttpExtraHttpHeadersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackDestinationOutputCriblHttpExtraHttpHeaders | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputCriblHttpExtraHttpHeaders | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class PackDestinationOutputCriblHttpExtraHttpHeadersList extends cdktf.ComplexList {
  public internalValue? : PackDestinationOutputCriblHttpExtraHttpHeaders[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackDestinationOutputCriblHttpExtraHttpHeadersOutputReference {
    return new PackDestinationOutputCriblHttpExtraHttpHeadersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackDestinationOutputCriblHttpPqControls {
}

export function packDestinationOutputCriblHttpPqControlsToTerraform(struct?: PackDestinationOutputCriblHttpPqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function packDestinationOutputCriblHttpPqControlsToHclTerraform(struct?: PackDestinationOutputCriblHttpPqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class PackDestinationOutputCriblHttpPqControlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackDestinationOutputCriblHttpPqControls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputCriblHttpPqControls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface PackDestinationOutputCriblHttpResponseRetrySettings {
  /**
  * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc. Default: 2
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#backoff_rate PackDestination#backoff_rate}
  */
  readonly backoffRate?: number;
  /**
  * The HTTP response status code that will trigger retries
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#http_status PackDestination#http_status}
  */
  readonly httpStatus: number;
  /**
  * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes). Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#initial_backoff PackDestination#initial_backoff}
  */
  readonly initialBackoff?: number;
  /**
  * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds). Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_backoff PackDestination#max_backoff}
  */
  readonly maxBackoff?: number;
}

export function packDestinationOutputCriblHttpResponseRetrySettingsToTerraform(struct?: PackDestinationOutputCriblHttpResponseRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    backoff_rate: cdktf.numberToTerraform(struct!.backoffRate),
    http_status: cdktf.numberToTerraform(struct!.httpStatus),
    initial_backoff: cdktf.numberToTerraform(struct!.initialBackoff),
    max_backoff: cdktf.numberToTerraform(struct!.maxBackoff),
  }
}


export function packDestinationOutputCriblHttpResponseRetrySettingsToHclTerraform(struct?: PackDestinationOutputCriblHttpResponseRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    backoff_rate: {
      value: cdktf.numberToHclTerraform(struct!.backoffRate),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    http_status: {
      value: cdktf.numberToHclTerraform(struct!.httpStatus),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    initial_backoff: {
      value: cdktf.numberToHclTerraform(struct!.initialBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_backoff: {
      value: cdktf.numberToHclTerraform(struct!.maxBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputCriblHttpResponseRetrySettingsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackDestinationOutputCriblHttpResponseRetrySettings | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._backoffRate !== undefined) {
      hasAnyValues = true;
      internalValueResult.backoffRate = this._backoffRate;
    }
    if (this._httpStatus !== undefined) {
      hasAnyValues = true;
      internalValueResult.httpStatus = this._httpStatus;
    }
    if (this._initialBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.initialBackoff = this._initialBackoff;
    }
    if (this._maxBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBackoff = this._maxBackoff;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputCriblHttpResponseRetrySettings | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._backoffRate = undefined;
      this._httpStatus = undefined;
      this._initialBackoff = undefined;
      this._maxBackoff = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._backoffRate = value.backoffRate;
      this._httpStatus = value.httpStatus;
      this._initialBackoff = value.initialBackoff;
      this._maxBackoff = value.maxBackoff;
    }
  }

  // backoff_rate - computed: true, optional: true, required: false
  private _backoffRate?: number; 
  public get backoffRate() {
    return this.getNumberAttribute('backoff_rate');
  }
  public set backoffRate(value: number) {
    this._backoffRate = value;
  }
  public resetBackoffRate() {
    this._backoffRate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get backoffRateInput() {
    return this._backoffRate;
  }

  // http_status - computed: false, optional: false, required: true
  private _httpStatus?: number; 
  public get httpStatus() {
    return this.getNumberAttribute('http_status');
  }
  public set httpStatus(value: number) {
    this._httpStatus = value;
  }
  // Temporarily expose input value. Use with caution.
  public get httpStatusInput() {
    return this._httpStatus;
  }

  // initial_backoff - computed: true, optional: true, required: false
  private _initialBackoff?: number; 
  public get initialBackoff() {
    return this.getNumberAttribute('initial_backoff');
  }
  public set initialBackoff(value: number) {
    this._initialBackoff = value;
  }
  public resetInitialBackoff() {
    this._initialBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get initialBackoffInput() {
    return this._initialBackoff;
  }

  // max_backoff - computed: true, optional: true, required: false
  private _maxBackoff?: number; 
  public get maxBackoff() {
    return this.getNumberAttribute('max_backoff');
  }
  public set maxBackoff(value: number) {
    this._maxBackoff = value;
  }
  public resetMaxBackoff() {
    this._maxBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBackoffInput() {
    return this._maxBackoff;
  }
}

export class PackDestinationOutputCriblHttpResponseRetrySettingsList extends cdktf.ComplexList {
  public internalValue? : PackDestinationOutputCriblHttpResponseRetrySettings[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackDestinationOutputCriblHttpResponseRetrySettingsOutputReference {
    return new PackDestinationOutputCriblHttpResponseRetrySettingsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackDestinationOutputCriblHttpTimeoutRetrySettings {
  /**
  * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc. Default: 2
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#backoff_rate PackDestination#backoff_rate}
  */
  readonly backoffRate?: number;
  /**
  * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes). Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#initial_backoff PackDestination#initial_backoff}
  */
  readonly initialBackoff?: number;
  /**
  * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds). Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_backoff PackDestination#max_backoff}
  */
  readonly maxBackoff?: number;
  /**
  * Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#timeout_retry PackDestination#timeout_retry}
  */
  readonly timeoutRetry?: boolean | cdktf.IResolvable;
}

export function packDestinationOutputCriblHttpTimeoutRetrySettingsToTerraform(struct?: PackDestinationOutputCriblHttpTimeoutRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    backoff_rate: cdktf.numberToTerraform(struct!.backoffRate),
    initial_backoff: cdktf.numberToTerraform(struct!.initialBackoff),
    max_backoff: cdktf.numberToTerraform(struct!.maxBackoff),
    timeout_retry: cdktf.booleanToTerraform(struct!.timeoutRetry),
  }
}


export function packDestinationOutputCriblHttpTimeoutRetrySettingsToHclTerraform(struct?: PackDestinationOutputCriblHttpTimeoutRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    backoff_rate: {
      value: cdktf.numberToHclTerraform(struct!.backoffRate),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    initial_backoff: {
      value: cdktf.numberToHclTerraform(struct!.initialBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_backoff: {
      value: cdktf.numberToHclTerraform(struct!.maxBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    timeout_retry: {
      value: cdktf.booleanToHclTerraform(struct!.timeoutRetry),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputCriblHttpTimeoutRetrySettingsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackDestinationOutputCriblHttpTimeoutRetrySettings | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._backoffRate !== undefined) {
      hasAnyValues = true;
      internalValueResult.backoffRate = this._backoffRate;
    }
    if (this._initialBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.initialBackoff = this._initialBackoff;
    }
    if (this._maxBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBackoff = this._maxBackoff;
    }
    if (this._timeoutRetry !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutRetry = this._timeoutRetry;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputCriblHttpTimeoutRetrySettings | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._backoffRate = undefined;
      this._initialBackoff = undefined;
      this._maxBackoff = undefined;
      this._timeoutRetry = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._backoffRate = value.backoffRate;
      this._initialBackoff = value.initialBackoff;
      this._maxBackoff = value.maxBackoff;
      this._timeoutRetry = value.timeoutRetry;
    }
  }

  // backoff_rate - computed: true, optional: true, required: false
  private _backoffRate?: number; 
  public get backoffRate() {
    return this.getNumberAttribute('backoff_rate');
  }
  public set backoffRate(value: number) {
    this._backoffRate = value;
  }
  public resetBackoffRate() {
    this._backoffRate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get backoffRateInput() {
    return this._backoffRate;
  }

  // initial_backoff - computed: true, optional: true, required: false
  private _initialBackoff?: number; 
  public get initialBackoff() {
    return this.getNumberAttribute('initial_backoff');
  }
  public set initialBackoff(value: number) {
    this._initialBackoff = value;
  }
  public resetInitialBackoff() {
    this._initialBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get initialBackoffInput() {
    return this._initialBackoff;
  }

  // max_backoff - computed: true, optional: true, required: false
  private _maxBackoff?: number; 
  public get maxBackoff() {
    return this.getNumberAttribute('max_backoff');
  }
  public set maxBackoff(value: number) {
    this._maxBackoff = value;
  }
  public resetMaxBackoff() {
    this._maxBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBackoffInput() {
    return this._maxBackoff;
  }

  // timeout_retry - computed: true, optional: true, required: false
  private _timeoutRetry?: boolean | cdktf.IResolvable; 
  public get timeoutRetry() {
    return this.getBooleanAttribute('timeout_retry');
  }
  public set timeoutRetry(value: boolean | cdktf.IResolvable) {
    this._timeoutRetry = value;
  }
  public resetTimeoutRetry() {
    this._timeoutRetry = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutRetryInput() {
    return this._timeoutRetry;
  }
}
export interface PackDestinationOutputCriblHttpTls {
  /**
  * Path on client in which to find CA certificates to verify the server's cert. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#ca_path PackDestination#ca_path}
  */
  readonly caPath?: string;
  /**
  * Path on client in which to find certificates to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#cert_path PackDestination#cert_path}
  */
  readonly certPath?: string;
  /**
  * The name of the predefined certificate
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#certificate_name PackDestination#certificate_name}
  */
  readonly certificateName?: string;
  /**
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#disabled PackDestination#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_version PackDestination#max_version}
  */
  readonly maxVersion?: string;
  /**
  * must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#min_version PackDestination#min_version}
  */
  readonly minVersion?: string;
  /**
  * Passphrase to use to decrypt private key
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#passphrase PackDestination#passphrase}
  */
  readonly passphrase?: string;
  /**
  * Path on client in which to find the private key to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#priv_key_path PackDestination#priv_key_path}
  */
  readonly privKeyPath?: string;
  /**
  * Reject certificates that are not authorized by a CA in the CA certificate path, or by another 
  *                     trusted CA (such as the system's). Defaults to Enabled. Overrides the toggle from Advanced Settings, when also present.
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#reject_unauthorized PackDestination#reject_unauthorized}
  */
  readonly rejectUnauthorized?: boolean | cdktf.IResolvable;
  /**
  * Server name for the SNI (Server Name Indication) TLS extension. It must be a host name, and not an IP address.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#servername PackDestination#servername}
  */
  readonly servername?: string;
}

export function packDestinationOutputCriblHttpTlsToTerraform(struct?: PackDestinationOutputCriblHttpTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ca_path: cdktf.stringToTerraform(struct!.caPath),
    cert_path: cdktf.stringToTerraform(struct!.certPath),
    certificate_name: cdktf.stringToTerraform(struct!.certificateName),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    max_version: cdktf.stringToTerraform(struct!.maxVersion),
    min_version: cdktf.stringToTerraform(struct!.minVersion),
    passphrase: cdktf.stringToTerraform(struct!.passphrase),
    priv_key_path: cdktf.stringToTerraform(struct!.privKeyPath),
    reject_unauthorized: cdktf.booleanToTerraform(struct!.rejectUnauthorized),
    servername: cdktf.stringToTerraform(struct!.servername),
  }
}


export function packDestinationOutputCriblHttpTlsToHclTerraform(struct?: PackDestinationOutputCriblHttpTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ca_path: {
      value: cdktf.stringToHclTerraform(struct!.caPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    cert_path: {
      value: cdktf.stringToHclTerraform(struct!.certPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    certificate_name: {
      value: cdktf.stringToHclTerraform(struct!.certificateName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    max_version: {
      value: cdktf.stringToHclTerraform(struct!.maxVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    min_version: {
      value: cdktf.stringToHclTerraform(struct!.minVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    passphrase: {
      value: cdktf.stringToHclTerraform(struct!.passphrase),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    priv_key_path: {
      value: cdktf.stringToHclTerraform(struct!.privKeyPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reject_unauthorized: {
      value: cdktf.booleanToHclTerraform(struct!.rejectUnauthorized),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    servername: {
      value: cdktf.stringToHclTerraform(struct!.servername),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputCriblHttpTlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackDestinationOutputCriblHttpTls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._caPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.caPath = this._caPath;
    }
    if (this._certPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.certPath = this._certPath;
    }
    if (this._certificateName !== undefined) {
      hasAnyValues = true;
      internalValueResult.certificateName = this._certificateName;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._maxVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxVersion = this._maxVersion;
    }
    if (this._minVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.minVersion = this._minVersion;
    }
    if (this._passphrase !== undefined) {
      hasAnyValues = true;
      internalValueResult.passphrase = this._passphrase;
    }
    if (this._privKeyPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.privKeyPath = this._privKeyPath;
    }
    if (this._rejectUnauthorized !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectUnauthorized = this._rejectUnauthorized;
    }
    if (this._servername !== undefined) {
      hasAnyValues = true;
      internalValueResult.servername = this._servername;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputCriblHttpTls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._caPath = undefined;
      this._certPath = undefined;
      this._certificateName = undefined;
      this._disabled = undefined;
      this._maxVersion = undefined;
      this._minVersion = undefined;
      this._passphrase = undefined;
      this._privKeyPath = undefined;
      this._rejectUnauthorized = undefined;
      this._servername = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._caPath = value.caPath;
      this._certPath = value.certPath;
      this._certificateName = value.certificateName;
      this._disabled = value.disabled;
      this._maxVersion = value.maxVersion;
      this._minVersion = value.minVersion;
      this._passphrase = value.passphrase;
      this._privKeyPath = value.privKeyPath;
      this._rejectUnauthorized = value.rejectUnauthorized;
      this._servername = value.servername;
    }
  }

  // ca_path - computed: false, optional: true, required: false
  private _caPath?: string; 
  public get caPath() {
    return this.getStringAttribute('ca_path');
  }
  public set caPath(value: string) {
    this._caPath = value;
  }
  public resetCaPath() {
    this._caPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get caPathInput() {
    return this._caPath;
  }

  // cert_path - computed: false, optional: true, required: false
  private _certPath?: string; 
  public get certPath() {
    return this.getStringAttribute('cert_path');
  }
  public set certPath(value: string) {
    this._certPath = value;
  }
  public resetCertPath() {
    this._certPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certPathInput() {
    return this._certPath;
  }

  // certificate_name - computed: false, optional: true, required: false
  private _certificateName?: string; 
  public get certificateName() {
    return this.getStringAttribute('certificate_name');
  }
  public set certificateName(value: string) {
    this._certificateName = value;
  }
  public resetCertificateName() {
    this._certificateName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certificateNameInput() {
    return this._certificateName;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // max_version - computed: false, optional: true, required: false
  private _maxVersion?: string; 
  public get maxVersion() {
    return this.getStringAttribute('max_version');
  }
  public set maxVersion(value: string) {
    this._maxVersion = value;
  }
  public resetMaxVersion() {
    this._maxVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxVersionInput() {
    return this._maxVersion;
  }

  // min_version - computed: false, optional: true, required: false
  private _minVersion?: string; 
  public get minVersion() {
    return this.getStringAttribute('min_version');
  }
  public set minVersion(value: string) {
    this._minVersion = value;
  }
  public resetMinVersion() {
    this._minVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get minVersionInput() {
    return this._minVersion;
  }

  // passphrase - computed: false, optional: true, required: false
  private _passphrase?: string; 
  public get passphrase() {
    return this.getStringAttribute('passphrase');
  }
  public set passphrase(value: string) {
    this._passphrase = value;
  }
  public resetPassphrase() {
    this._passphrase = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passphraseInput() {
    return this._passphrase;
  }

  // priv_key_path - computed: false, optional: true, required: false
  private _privKeyPath?: string; 
  public get privKeyPath() {
    return this.getStringAttribute('priv_key_path');
  }
  public set privKeyPath(value: string) {
    this._privKeyPath = value;
  }
  public resetPrivKeyPath() {
    this._privKeyPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get privKeyPathInput() {
    return this._privKeyPath;
  }

  // reject_unauthorized - computed: true, optional: true, required: false
  private _rejectUnauthorized?: boolean | cdktf.IResolvable; 
  public get rejectUnauthorized() {
    return this.getBooleanAttribute('reject_unauthorized');
  }
  public set rejectUnauthorized(value: boolean | cdktf.IResolvable) {
    this._rejectUnauthorized = value;
  }
  public resetRejectUnauthorized() {
    this._rejectUnauthorized = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectUnauthorizedInput() {
    return this._rejectUnauthorized;
  }

  // servername - computed: false, optional: true, required: false
  private _servername?: string; 
  public get servername() {
    return this.getStringAttribute('servername');
  }
  public set servername(value: string) {
    this._servername = value;
  }
  public resetServername() {
    this._servername = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get servernameInput() {
    return this._servername;
  }
}
export interface PackDestinationOutputCriblHttpUrls {
  /**
  * URL of a Cribl Worker to send events to, such as http://localhost:10200
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#url PackDestination#url}
  */
  readonly url: string;
  /**
  * Assign a weight (>0) to each endpoint to indicate its traffic-handling capability. Default: 1
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#weight PackDestination#weight}
  */
  readonly weight?: number;
}

export function packDestinationOutputCriblHttpUrlsToTerraform(struct?: PackDestinationOutputCriblHttpUrls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    url: cdktf.stringToTerraform(struct!.url),
    weight: cdktf.numberToTerraform(struct!.weight),
  }
}


export function packDestinationOutputCriblHttpUrlsToHclTerraform(struct?: PackDestinationOutputCriblHttpUrls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    url: {
      value: cdktf.stringToHclTerraform(struct!.url),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    weight: {
      value: cdktf.numberToHclTerraform(struct!.weight),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputCriblHttpUrlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackDestinationOutputCriblHttpUrls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._url !== undefined) {
      hasAnyValues = true;
      internalValueResult.url = this._url;
    }
    if (this._weight !== undefined) {
      hasAnyValues = true;
      internalValueResult.weight = this._weight;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputCriblHttpUrls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._url = undefined;
      this._weight = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._url = value.url;
      this._weight = value.weight;
    }
  }

  // url - computed: false, optional: false, required: true
  private _url?: string; 
  public get url() {
    return this.getStringAttribute('url');
  }
  public set url(value: string) {
    this._url = value;
  }
  // Temporarily expose input value. Use with caution.
  public get urlInput() {
    return this._url;
  }

  // weight - computed: true, optional: true, required: false
  private _weight?: number; 
  public get weight() {
    return this.getNumberAttribute('weight');
  }
  public set weight(value: number) {
    this._weight = value;
  }
  public resetWeight() {
    this._weight = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get weightInput() {
    return this._weight;
  }
}

export class PackDestinationOutputCriblHttpUrlsList extends cdktf.ComplexList {
  public internalValue? : PackDestinationOutputCriblHttpUrls[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackDestinationOutputCriblHttpUrlsOutputReference {
    return new PackDestinationOutputCriblHttpUrlsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackDestinationOutputCriblHttp {
  /**
  * Codec to use to compress the data before sending. Default: "gzip"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#compression PackDestination#compression}
  */
  readonly compression?: string;
  /**
  * Maximum number of ongoing requests before blocking. Default: 5
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#concurrency PackDestination#concurrency}
  */
  readonly concurrency?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#description PackDestination#description}
  */
  readonly description?: string;
  /**
  * The interval in which to re-resolve any hostnames and pick up destinations from A records. Default: 600
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#dns_resolve_period_sec PackDestination#dns_resolve_period_sec}
  */
  readonly dnsResolvePeriodSec?: number;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#environment PackDestination#environment}
  */
  readonly environment?: string;
  /**
  * Fields to exclude from the event. By default, all internal fields except `__output` are sent. Example: `cribl_pipe`, `c*`. Wildcards supported. Default: ["__kube_*","__metadata","__winEvent"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#exclude_fields PackDestination#exclude_fields}
  */
  readonly excludeFields?: string[];
  /**
  * Exclude all IPs of the current host from the list of any resolved hostnames. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#exclude_self PackDestination#exclude_self}
  */
  readonly excludeSelf?: boolean | cdktf.IResolvable;
  /**
  * Headers to add to all events
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#extra_http_headers PackDestination#extra_http_headers}
  */
  readonly extraHttpHeaders?: PackDestinationOutputCriblHttpExtraHttpHeaders[] | cdktf.IResolvable;
  /**
  * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below. Default: "none"; must be one of ["payload", "payloadAndHeaders", "none"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#failed_request_logging_mode PackDestination#failed_request_logging_mode}
  */
  readonly failedRequestLoggingMode?: string;
  /**
  * Maximum time between requests. Small values could cause the payload size to be smaller than the configured Body size limit. Default: 1
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#flush_period_sec PackDestination#flush_period_sec}
  */
  readonly flushPeriodSec?: number;
  /**
  * Unique ID for this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#id PackDestination#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id: string;
  /**
  * How far back in time to keep traffic stats for load balancing purposes. Default: 300
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#load_balance_stats_period_sec PackDestination#load_balance_stats_period_sec}
  */
  readonly loadBalanceStatsPeriodSec?: number;
  /**
  * For optimal performance, enable load balancing even if you have one hostname, as it can expand to multiple IPs. If this setting is disabled, consider enabling round-robin DNS. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#load_balanced PackDestination#load_balanced}
  */
  readonly loadBalanced?: boolean | cdktf.IResolvable;
  /**
  * Maximum number of events to include in the request body. Default is 0 (unlimited). Default: 0
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_payload_events PackDestination#max_payload_events}
  */
  readonly maxPayloadEvents?: number;
  /**
  * Maximum size, in KB, of the request body. Default: 4096
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_payload_size_kb PackDestination#max_payload_size_kb}
  */
  readonly maxPayloadSizeKb?: number;
  /**
  * How to handle events when all receivers are exerting backpressure. Default: "block"; must be one of ["block", "drop", "queue"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#on_backpressure PackDestination#on_backpressure}
  */
  readonly onBackpressure?: string;
  /**
  * Pipeline to process data before sending out to this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pipeline PackDestination#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_compress PackDestination#pq_compress}
  */
  readonly pqCompress?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_controls PackDestination#pq_controls}
  */
  readonly pqControls?: PackDestinationOutputCriblHttpPqControls;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.). Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_max_file_size PackDestination#pq_max_file_size}
  */
  readonly pqMaxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_max_size PackDestination#pq_max_size}
  */
  readonly pqMaxSize?: string;
  /**
  * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem. Default: "error"; must be one of ["error", "backpressure", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_mode PackDestination#pq_mode}
  */
  readonly pqMode?: string;
  /**
  * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged. Default: "block"; must be one of ["block", "drop"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_on_backpressure PackDestination#pq_on_backpressure}
  */
  readonly pqOnBackpressure?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_path PackDestination#pq_path}
  */
  readonly pqPath?: string;
  /**
  * Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's). 
  *         Enabled by default. When this setting is also present in TLS Settings (Client Side), 
  *         that value will take precedence.
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#reject_unauthorized PackDestination#reject_unauthorized}
  */
  readonly rejectUnauthorized?: boolean | cdktf.IResolvable;
  /**
  * Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#response_honor_retry_after_header PackDestination#response_honor_retry_after_header}
  */
  readonly responseHonorRetryAfterHeader?: boolean | cdktf.IResolvable;
  /**
  * Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#response_retry_settings PackDestination#response_retry_settings}
  */
  readonly responseRetrySettings?: PackDestinationOutputCriblHttpResponseRetrySettings[] | cdktf.IResolvable;
  /**
  * List of headers that are safe to log in plain text. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#safe_headers PackDestination#safe_headers}
  */
  readonly safeHeaders?: string[];
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#streamtags PackDestination#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Fields to automatically add to events, such as cribl_pipe. Supports wildcards. Default: ["cribl_pipe"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#system_fields PackDestination#system_fields}
  */
  readonly systemFields?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#timeout_retry_settings PackDestination#timeout_retry_settings}
  */
  readonly timeoutRetrySettings?: PackDestinationOutputCriblHttpTimeoutRetrySettings;
  /**
  * Amount of time, in seconds, to wait for a request to complete before canceling it. Default: 30
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#timeout_sec PackDestination#timeout_sec}
  */
  readonly timeoutSec?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#tls PackDestination#tls}
  */
  readonly tls?: PackDestinationOutputCriblHttpTls;
  /**
  * The number of minutes before the internally generated authentication token expires. Valid values are between 1 and 60. Default: 60
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#token_ttl_minutes PackDestination#token_ttl_minutes}
  */
  readonly tokenTtlMinutes?: number;
  /**
  * must be "cribl_http"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#type PackDestination#type}
  */
  readonly type: string;
  /**
  * URL of a Cribl Worker to send events to, such as http://localhost:10200
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#url PackDestination#url}
  */
  readonly url?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#urls PackDestination#urls}
  */
  readonly urls?: PackDestinationOutputCriblHttpUrls[] | cdktf.IResolvable;
  /**
  * Enable round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. For optimal performance, consider enabling this setting for non-load balanced destinations. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#use_round_robin_dns PackDestination#use_round_robin_dns}
  */
  readonly useRoundRobinDns?: boolean | cdktf.IResolvable;
}

export function packDestinationOutputCriblHttpToTerraform(struct?: PackDestinationOutputCriblHttp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    compression: cdktf.stringToTerraform(struct!.compression),
    concurrency: cdktf.numberToTerraform(struct!.concurrency),
    description: cdktf.stringToTerraform(struct!.description),
    dns_resolve_period_sec: cdktf.numberToTerraform(struct!.dnsResolvePeriodSec),
    environment: cdktf.stringToTerraform(struct!.environment),
    exclude_fields: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.excludeFields),
    exclude_self: cdktf.booleanToTerraform(struct!.excludeSelf),
    extra_http_headers: cdktf.listMapper(packDestinationOutputCriblHttpExtraHttpHeadersToTerraform, false)(struct!.extraHttpHeaders),
    failed_request_logging_mode: cdktf.stringToTerraform(struct!.failedRequestLoggingMode),
    flush_period_sec: cdktf.numberToTerraform(struct!.flushPeriodSec),
    id: cdktf.stringToTerraform(struct!.id),
    load_balance_stats_period_sec: cdktf.numberToTerraform(struct!.loadBalanceStatsPeriodSec),
    load_balanced: cdktf.booleanToTerraform(struct!.loadBalanced),
    max_payload_events: cdktf.numberToTerraform(struct!.maxPayloadEvents),
    max_payload_size_kb: cdktf.numberToTerraform(struct!.maxPayloadSizeKb),
    on_backpressure: cdktf.stringToTerraform(struct!.onBackpressure),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    pq_compress: cdktf.stringToTerraform(struct!.pqCompress),
    pq_controls: packDestinationOutputCriblHttpPqControlsToTerraform(struct!.pqControls),
    pq_max_file_size: cdktf.stringToTerraform(struct!.pqMaxFileSize),
    pq_max_size: cdktf.stringToTerraform(struct!.pqMaxSize),
    pq_mode: cdktf.stringToTerraform(struct!.pqMode),
    pq_on_backpressure: cdktf.stringToTerraform(struct!.pqOnBackpressure),
    pq_path: cdktf.stringToTerraform(struct!.pqPath),
    reject_unauthorized: cdktf.booleanToTerraform(struct!.rejectUnauthorized),
    response_honor_retry_after_header: cdktf.booleanToTerraform(struct!.responseHonorRetryAfterHeader),
    response_retry_settings: cdktf.listMapper(packDestinationOutputCriblHttpResponseRetrySettingsToTerraform, false)(struct!.responseRetrySettings),
    safe_headers: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.safeHeaders),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    system_fields: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.systemFields),
    timeout_retry_settings: packDestinationOutputCriblHttpTimeoutRetrySettingsToTerraform(struct!.timeoutRetrySettings),
    timeout_sec: cdktf.numberToTerraform(struct!.timeoutSec),
    tls: packDestinationOutputCriblHttpTlsToTerraform(struct!.tls),
    token_ttl_minutes: cdktf.numberToTerraform(struct!.tokenTtlMinutes),
    type: cdktf.stringToTerraform(struct!.type),
    url: cdktf.stringToTerraform(struct!.url),
    urls: cdktf.listMapper(packDestinationOutputCriblHttpUrlsToTerraform, false)(struct!.urls),
    use_round_robin_dns: cdktf.booleanToTerraform(struct!.useRoundRobinDns),
  }
}


export function packDestinationOutputCriblHttpToHclTerraform(struct?: PackDestinationOutputCriblHttp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    compression: {
      value: cdktf.stringToHclTerraform(struct!.compression),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    concurrency: {
      value: cdktf.numberToHclTerraform(struct!.concurrency),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    dns_resolve_period_sec: {
      value: cdktf.numberToHclTerraform(struct!.dnsResolvePeriodSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    exclude_fields: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.excludeFields),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    exclude_self: {
      value: cdktf.booleanToHclTerraform(struct!.excludeSelf),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    extra_http_headers: {
      value: cdktf.listMapperHcl(packDestinationOutputCriblHttpExtraHttpHeadersToHclTerraform, false)(struct!.extraHttpHeaders),
      isBlock: true,
      type: "list",
      storageClassType: "PackDestinationOutputCriblHttpExtraHttpHeadersList",
    },
    failed_request_logging_mode: {
      value: cdktf.stringToHclTerraform(struct!.failedRequestLoggingMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    flush_period_sec: {
      value: cdktf.numberToHclTerraform(struct!.flushPeriodSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    load_balance_stats_period_sec: {
      value: cdktf.numberToHclTerraform(struct!.loadBalanceStatsPeriodSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    load_balanced: {
      value: cdktf.booleanToHclTerraform(struct!.loadBalanced),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    max_payload_events: {
      value: cdktf.numberToHclTerraform(struct!.maxPayloadEvents),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_payload_size_kb: {
      value: cdktf.numberToHclTerraform(struct!.maxPayloadSizeKb),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.onBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_compress: {
      value: cdktf.stringToHclTerraform(struct!.pqCompress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_controls: {
      value: packDestinationOutputCriblHttpPqControlsToHclTerraform(struct!.pqControls),
      isBlock: true,
      type: "struct",
      storageClassType: "PackDestinationOutputCriblHttpPqControls",
    },
    pq_max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_max_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_mode: {
      value: cdktf.stringToHclTerraform(struct!.pqMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.pqOnBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_path: {
      value: cdktf.stringToHclTerraform(struct!.pqPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reject_unauthorized: {
      value: cdktf.booleanToHclTerraform(struct!.rejectUnauthorized),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    response_honor_retry_after_header: {
      value: cdktf.booleanToHclTerraform(struct!.responseHonorRetryAfterHeader),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    response_retry_settings: {
      value: cdktf.listMapperHcl(packDestinationOutputCriblHttpResponseRetrySettingsToHclTerraform, false)(struct!.responseRetrySettings),
      isBlock: true,
      type: "list",
      storageClassType: "PackDestinationOutputCriblHttpResponseRetrySettingsList",
    },
    safe_headers: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.safeHeaders),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    system_fields: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.systemFields),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    timeout_retry_settings: {
      value: packDestinationOutputCriblHttpTimeoutRetrySettingsToHclTerraform(struct!.timeoutRetrySettings),
      isBlock: true,
      type: "struct",
      storageClassType: "PackDestinationOutputCriblHttpTimeoutRetrySettings",
    },
    timeout_sec: {
      value: cdktf.numberToHclTerraform(struct!.timeoutSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    tls: {
      value: packDestinationOutputCriblHttpTlsToHclTerraform(struct!.tls),
      isBlock: true,
      type: "struct",
      storageClassType: "PackDestinationOutputCriblHttpTls",
    },
    token_ttl_minutes: {
      value: cdktf.numberToHclTerraform(struct!.tokenTtlMinutes),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    url: {
      value: cdktf.stringToHclTerraform(struct!.url),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    urls: {
      value: cdktf.listMapperHcl(packDestinationOutputCriblHttpUrlsToHclTerraform, false)(struct!.urls),
      isBlock: true,
      type: "list",
      storageClassType: "PackDestinationOutputCriblHttpUrlsList",
    },
    use_round_robin_dns: {
      value: cdktf.booleanToHclTerraform(struct!.useRoundRobinDns),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputCriblHttpOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackDestinationOutputCriblHttp | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._compression !== undefined) {
      hasAnyValues = true;
      internalValueResult.compression = this._compression;
    }
    if (this._concurrency !== undefined) {
      hasAnyValues = true;
      internalValueResult.concurrency = this._concurrency;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._dnsResolvePeriodSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.dnsResolvePeriodSec = this._dnsResolvePeriodSec;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._excludeFields !== undefined) {
      hasAnyValues = true;
      internalValueResult.excludeFields = this._excludeFields;
    }
    if (this._excludeSelf !== undefined) {
      hasAnyValues = true;
      internalValueResult.excludeSelf = this._excludeSelf;
    }
    if (this._extraHttpHeaders?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.extraHttpHeaders = this._extraHttpHeaders?.internalValue;
    }
    if (this._failedRequestLoggingMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.failedRequestLoggingMode = this._failedRequestLoggingMode;
    }
    if (this._flushPeriodSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.flushPeriodSec = this._flushPeriodSec;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._loadBalanceStatsPeriodSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.loadBalanceStatsPeriodSec = this._loadBalanceStatsPeriodSec;
    }
    if (this._loadBalanced !== undefined) {
      hasAnyValues = true;
      internalValueResult.loadBalanced = this._loadBalanced;
    }
    if (this._maxPayloadEvents !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxPayloadEvents = this._maxPayloadEvents;
    }
    if (this._maxPayloadSizeKb !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxPayloadSizeKb = this._maxPayloadSizeKb;
    }
    if (this._onBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.onBackpressure = this._onBackpressure;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._pqCompress !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqCompress = this._pqCompress;
    }
    if (this._pqControls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqControls = this._pqControls?.internalValue;
    }
    if (this._pqMaxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxFileSize = this._pqMaxFileSize;
    }
    if (this._pqMaxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxSize = this._pqMaxSize;
    }
    if (this._pqMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMode = this._pqMode;
    }
    if (this._pqOnBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqOnBackpressure = this._pqOnBackpressure;
    }
    if (this._pqPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqPath = this._pqPath;
    }
    if (this._rejectUnauthorized !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectUnauthorized = this._rejectUnauthorized;
    }
    if (this._responseHonorRetryAfterHeader !== undefined) {
      hasAnyValues = true;
      internalValueResult.responseHonorRetryAfterHeader = this._responseHonorRetryAfterHeader;
    }
    if (this._responseRetrySettings?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.responseRetrySettings = this._responseRetrySettings?.internalValue;
    }
    if (this._safeHeaders !== undefined) {
      hasAnyValues = true;
      internalValueResult.safeHeaders = this._safeHeaders;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._systemFields !== undefined) {
      hasAnyValues = true;
      internalValueResult.systemFields = this._systemFields;
    }
    if (this._timeoutRetrySettings?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutRetrySettings = this._timeoutRetrySettings?.internalValue;
    }
    if (this._timeoutSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutSec = this._timeoutSec;
    }
    if (this._tls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tls = this._tls?.internalValue;
    }
    if (this._tokenTtlMinutes !== undefined) {
      hasAnyValues = true;
      internalValueResult.tokenTtlMinutes = this._tokenTtlMinutes;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._url !== undefined) {
      hasAnyValues = true;
      internalValueResult.url = this._url;
    }
    if (this._urls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.urls = this._urls?.internalValue;
    }
    if (this._useRoundRobinDns !== undefined) {
      hasAnyValues = true;
      internalValueResult.useRoundRobinDns = this._useRoundRobinDns;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputCriblHttp | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._compression = undefined;
      this._concurrency = undefined;
      this._description = undefined;
      this._dnsResolvePeriodSec = undefined;
      this._environment = undefined;
      this._excludeFields = undefined;
      this._excludeSelf = undefined;
      this._extraHttpHeaders.internalValue = undefined;
      this._failedRequestLoggingMode = undefined;
      this._flushPeriodSec = undefined;
      this._id = undefined;
      this._loadBalanceStatsPeriodSec = undefined;
      this._loadBalanced = undefined;
      this._maxPayloadEvents = undefined;
      this._maxPayloadSizeKb = undefined;
      this._onBackpressure = undefined;
      this._pipeline = undefined;
      this._pqCompress = undefined;
      this._pqControls.internalValue = undefined;
      this._pqMaxFileSize = undefined;
      this._pqMaxSize = undefined;
      this._pqMode = undefined;
      this._pqOnBackpressure = undefined;
      this._pqPath = undefined;
      this._rejectUnauthorized = undefined;
      this._responseHonorRetryAfterHeader = undefined;
      this._responseRetrySettings.internalValue = undefined;
      this._safeHeaders = undefined;
      this._streamtags = undefined;
      this._systemFields = undefined;
      this._timeoutRetrySettings.internalValue = undefined;
      this._timeoutSec = undefined;
      this._tls.internalValue = undefined;
      this._tokenTtlMinutes = undefined;
      this._type = undefined;
      this._url = undefined;
      this._urls.internalValue = undefined;
      this._useRoundRobinDns = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._compression = value.compression;
      this._concurrency = value.concurrency;
      this._description = value.description;
      this._dnsResolvePeriodSec = value.dnsResolvePeriodSec;
      this._environment = value.environment;
      this._excludeFields = value.excludeFields;
      this._excludeSelf = value.excludeSelf;
      this._extraHttpHeaders.internalValue = value.extraHttpHeaders;
      this._failedRequestLoggingMode = value.failedRequestLoggingMode;
      this._flushPeriodSec = value.flushPeriodSec;
      this._id = value.id;
      this._loadBalanceStatsPeriodSec = value.loadBalanceStatsPeriodSec;
      this._loadBalanced = value.loadBalanced;
      this._maxPayloadEvents = value.maxPayloadEvents;
      this._maxPayloadSizeKb = value.maxPayloadSizeKb;
      this._onBackpressure = value.onBackpressure;
      this._pipeline = value.pipeline;
      this._pqCompress = value.pqCompress;
      this._pqControls.internalValue = value.pqControls;
      this._pqMaxFileSize = value.pqMaxFileSize;
      this._pqMaxSize = value.pqMaxSize;
      this._pqMode = value.pqMode;
      this._pqOnBackpressure = value.pqOnBackpressure;
      this._pqPath = value.pqPath;
      this._rejectUnauthorized = value.rejectUnauthorized;
      this._responseHonorRetryAfterHeader = value.responseHonorRetryAfterHeader;
      this._responseRetrySettings.internalValue = value.responseRetrySettings;
      this._safeHeaders = value.safeHeaders;
      this._streamtags = value.streamtags;
      this._systemFields = value.systemFields;
      this._timeoutRetrySettings.internalValue = value.timeoutRetrySettings;
      this._timeoutSec = value.timeoutSec;
      this._tls.internalValue = value.tls;
      this._tokenTtlMinutes = value.tokenTtlMinutes;
      this._type = value.type;
      this._url = value.url;
      this._urls.internalValue = value.urls;
      this._useRoundRobinDns = value.useRoundRobinDns;
    }
  }

  // compression - computed: true, optional: true, required: false
  private _compression?: string; 
  public get compression() {
    return this.getStringAttribute('compression');
  }
  public set compression(value: string) {
    this._compression = value;
  }
  public resetCompression() {
    this._compression = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressionInput() {
    return this._compression;
  }

  // concurrency - computed: true, optional: true, required: false
  private _concurrency?: number; 
  public get concurrency() {
    return this.getNumberAttribute('concurrency');
  }
  public set concurrency(value: number) {
    this._concurrency = value;
  }
  public resetConcurrency() {
    this._concurrency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get concurrencyInput() {
    return this._concurrency;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // dns_resolve_period_sec - computed: true, optional: true, required: false
  private _dnsResolvePeriodSec?: number; 
  public get dnsResolvePeriodSec() {
    return this.getNumberAttribute('dns_resolve_period_sec');
  }
  public set dnsResolvePeriodSec(value: number) {
    this._dnsResolvePeriodSec = value;
  }
  public resetDnsResolvePeriodSec() {
    this._dnsResolvePeriodSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dnsResolvePeriodSecInput() {
    return this._dnsResolvePeriodSec;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // exclude_fields - computed: true, optional: true, required: false
  private _excludeFields?: string[]; 
  public get excludeFields() {
    return this.getListAttribute('exclude_fields');
  }
  public set excludeFields(value: string[]) {
    this._excludeFields = value;
  }
  public resetExcludeFields() {
    this._excludeFields = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get excludeFieldsInput() {
    return this._excludeFields;
  }

  // exclude_self - computed: true, optional: true, required: false
  private _excludeSelf?: boolean | cdktf.IResolvable; 
  public get excludeSelf() {
    return this.getBooleanAttribute('exclude_self');
  }
  public set excludeSelf(value: boolean | cdktf.IResolvable) {
    this._excludeSelf = value;
  }
  public resetExcludeSelf() {
    this._excludeSelf = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get excludeSelfInput() {
    return this._excludeSelf;
  }

  // extra_http_headers - computed: false, optional: true, required: false
  private _extraHttpHeaders = new PackDestinationOutputCriblHttpExtraHttpHeadersList(this, "extra_http_headers", false);
  public get extraHttpHeaders() {
    return this._extraHttpHeaders;
  }
  public putExtraHttpHeaders(value: PackDestinationOutputCriblHttpExtraHttpHeaders[] | cdktf.IResolvable) {
    this._extraHttpHeaders.internalValue = value;
  }
  public resetExtraHttpHeaders() {
    this._extraHttpHeaders.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get extraHttpHeadersInput() {
    return this._extraHttpHeaders.internalValue;
  }

  // failed_request_logging_mode - computed: true, optional: true, required: false
  private _failedRequestLoggingMode?: string; 
  public get failedRequestLoggingMode() {
    return this.getStringAttribute('failed_request_logging_mode');
  }
  public set failedRequestLoggingMode(value: string) {
    this._failedRequestLoggingMode = value;
  }
  public resetFailedRequestLoggingMode() {
    this._failedRequestLoggingMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get failedRequestLoggingModeInput() {
    return this._failedRequestLoggingMode;
  }

  // flush_period_sec - computed: true, optional: true, required: false
  private _flushPeriodSec?: number; 
  public get flushPeriodSec() {
    return this.getNumberAttribute('flush_period_sec');
  }
  public set flushPeriodSec(value: number) {
    this._flushPeriodSec = value;
  }
  public resetFlushPeriodSec() {
    this._flushPeriodSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get flushPeriodSecInput() {
    return this._flushPeriodSec;
  }

  // id - computed: false, optional: false, required: true
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // load_balance_stats_period_sec - computed: true, optional: true, required: false
  private _loadBalanceStatsPeriodSec?: number; 
  public get loadBalanceStatsPeriodSec() {
    return this.getNumberAttribute('load_balance_stats_period_sec');
  }
  public set loadBalanceStatsPeriodSec(value: number) {
    this._loadBalanceStatsPeriodSec = value;
  }
  public resetLoadBalanceStatsPeriodSec() {
    this._loadBalanceStatsPeriodSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get loadBalanceStatsPeriodSecInput() {
    return this._loadBalanceStatsPeriodSec;
  }

  // load_balanced - computed: true, optional: true, required: false
  private _loadBalanced?: boolean | cdktf.IResolvable; 
  public get loadBalanced() {
    return this.getBooleanAttribute('load_balanced');
  }
  public set loadBalanced(value: boolean | cdktf.IResolvable) {
    this._loadBalanced = value;
  }
  public resetLoadBalanced() {
    this._loadBalanced = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get loadBalancedInput() {
    return this._loadBalanced;
  }

  // max_payload_events - computed: true, optional: true, required: false
  private _maxPayloadEvents?: number; 
  public get maxPayloadEvents() {
    return this.getNumberAttribute('max_payload_events');
  }
  public set maxPayloadEvents(value: number) {
    this._maxPayloadEvents = value;
  }
  public resetMaxPayloadEvents() {
    this._maxPayloadEvents = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxPayloadEventsInput() {
    return this._maxPayloadEvents;
  }

  // max_payload_size_kb - computed: true, optional: true, required: false
  private _maxPayloadSizeKb?: number; 
  public get maxPayloadSizeKb() {
    return this.getNumberAttribute('max_payload_size_kb');
  }
  public set maxPayloadSizeKb(value: number) {
    this._maxPayloadSizeKb = value;
  }
  public resetMaxPayloadSizeKb() {
    this._maxPayloadSizeKb = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxPayloadSizeKbInput() {
    return this._maxPayloadSizeKb;
  }

  // on_backpressure - computed: true, optional: true, required: false
  private _onBackpressure?: string; 
  public get onBackpressure() {
    return this.getStringAttribute('on_backpressure');
  }
  public set onBackpressure(value: string) {
    this._onBackpressure = value;
  }
  public resetOnBackpressure() {
    this._onBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get onBackpressureInput() {
    return this._onBackpressure;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // pq_compress - computed: true, optional: true, required: false
  private _pqCompress?: string; 
  public get pqCompress() {
    return this.getStringAttribute('pq_compress');
  }
  public set pqCompress(value: string) {
    this._pqCompress = value;
  }
  public resetPqCompress() {
    this._pqCompress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqCompressInput() {
    return this._pqCompress;
  }

  // pq_controls - computed: false, optional: true, required: false
  private _pqControls = new PackDestinationOutputCriblHttpPqControlsOutputReference(this, "pq_controls");
  public get pqControls() {
    return this._pqControls;
  }
  public putPqControls(value: PackDestinationOutputCriblHttpPqControls) {
    this._pqControls.internalValue = value;
  }
  public resetPqControls() {
    this._pqControls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqControlsInput() {
    return this._pqControls.internalValue;
  }

  // pq_max_file_size - computed: true, optional: true, required: false
  private _pqMaxFileSize?: string; 
  public get pqMaxFileSize() {
    return this.getStringAttribute('pq_max_file_size');
  }
  public set pqMaxFileSize(value: string) {
    this._pqMaxFileSize = value;
  }
  public resetPqMaxFileSize() {
    this._pqMaxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxFileSizeInput() {
    return this._pqMaxFileSize;
  }

  // pq_max_size - computed: true, optional: true, required: false
  private _pqMaxSize?: string; 
  public get pqMaxSize() {
    return this.getStringAttribute('pq_max_size');
  }
  public set pqMaxSize(value: string) {
    this._pqMaxSize = value;
  }
  public resetPqMaxSize() {
    this._pqMaxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxSizeInput() {
    return this._pqMaxSize;
  }

  // pq_mode - computed: true, optional: true, required: false
  private _pqMode?: string; 
  public get pqMode() {
    return this.getStringAttribute('pq_mode');
  }
  public set pqMode(value: string) {
    this._pqMode = value;
  }
  public resetPqMode() {
    this._pqMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqModeInput() {
    return this._pqMode;
  }

  // pq_on_backpressure - computed: true, optional: true, required: false
  private _pqOnBackpressure?: string; 
  public get pqOnBackpressure() {
    return this.getStringAttribute('pq_on_backpressure');
  }
  public set pqOnBackpressure(value: string) {
    this._pqOnBackpressure = value;
  }
  public resetPqOnBackpressure() {
    this._pqOnBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqOnBackpressureInput() {
    return this._pqOnBackpressure;
  }

  // pq_path - computed: true, optional: true, required: false
  private _pqPath?: string; 
  public get pqPath() {
    return this.getStringAttribute('pq_path');
  }
  public set pqPath(value: string) {
    this._pqPath = value;
  }
  public resetPqPath() {
    this._pqPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqPathInput() {
    return this._pqPath;
  }

  // reject_unauthorized - computed: true, optional: true, required: false
  private _rejectUnauthorized?: boolean | cdktf.IResolvable; 
  public get rejectUnauthorized() {
    return this.getBooleanAttribute('reject_unauthorized');
  }
  public set rejectUnauthorized(value: boolean | cdktf.IResolvable) {
    this._rejectUnauthorized = value;
  }
  public resetRejectUnauthorized() {
    this._rejectUnauthorized = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectUnauthorizedInput() {
    return this._rejectUnauthorized;
  }

  // response_honor_retry_after_header - computed: true, optional: true, required: false
  private _responseHonorRetryAfterHeader?: boolean | cdktf.IResolvable; 
  public get responseHonorRetryAfterHeader() {
    return this.getBooleanAttribute('response_honor_retry_after_header');
  }
  public set responseHonorRetryAfterHeader(value: boolean | cdktf.IResolvable) {
    this._responseHonorRetryAfterHeader = value;
  }
  public resetResponseHonorRetryAfterHeader() {
    this._responseHonorRetryAfterHeader = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get responseHonorRetryAfterHeaderInput() {
    return this._responseHonorRetryAfterHeader;
  }

  // response_retry_settings - computed: false, optional: true, required: false
  private _responseRetrySettings = new PackDestinationOutputCriblHttpResponseRetrySettingsList(this, "response_retry_settings", false);
  public get responseRetrySettings() {
    return this._responseRetrySettings;
  }
  public putResponseRetrySettings(value: PackDestinationOutputCriblHttpResponseRetrySettings[] | cdktf.IResolvable) {
    this._responseRetrySettings.internalValue = value;
  }
  public resetResponseRetrySettings() {
    this._responseRetrySettings.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get responseRetrySettingsInput() {
    return this._responseRetrySettings.internalValue;
  }

  // safe_headers - computed: true, optional: true, required: false
  private _safeHeaders?: string[]; 
  public get safeHeaders() {
    return this.getListAttribute('safe_headers');
  }
  public set safeHeaders(value: string[]) {
    this._safeHeaders = value;
  }
  public resetSafeHeaders() {
    this._safeHeaders = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get safeHeadersInput() {
    return this._safeHeaders;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // system_fields - computed: true, optional: true, required: false
  private _systemFields?: string[]; 
  public get systemFields() {
    return this.getListAttribute('system_fields');
  }
  public set systemFields(value: string[]) {
    this._systemFields = value;
  }
  public resetSystemFields() {
    this._systemFields = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get systemFieldsInput() {
    return this._systemFields;
  }

  // timeout_retry_settings - computed: false, optional: true, required: false
  private _timeoutRetrySettings = new PackDestinationOutputCriblHttpTimeoutRetrySettingsOutputReference(this, "timeout_retry_settings");
  public get timeoutRetrySettings() {
    return this._timeoutRetrySettings;
  }
  public putTimeoutRetrySettings(value: PackDestinationOutputCriblHttpTimeoutRetrySettings) {
    this._timeoutRetrySettings.internalValue = value;
  }
  public resetTimeoutRetrySettings() {
    this._timeoutRetrySettings.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutRetrySettingsInput() {
    return this._timeoutRetrySettings.internalValue;
  }

  // timeout_sec - computed: true, optional: true, required: false
  private _timeoutSec?: number; 
  public get timeoutSec() {
    return this.getNumberAttribute('timeout_sec');
  }
  public set timeoutSec(value: number) {
    this._timeoutSec = value;
  }
  public resetTimeoutSec() {
    this._timeoutSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutSecInput() {
    return this._timeoutSec;
  }

  // tls - computed: false, optional: true, required: false
  private _tls = new PackDestinationOutputCriblHttpTlsOutputReference(this, "tls");
  public get tls() {
    return this._tls;
  }
  public putTls(value: PackDestinationOutputCriblHttpTls) {
    this._tls.internalValue = value;
  }
  public resetTls() {
    this._tls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsInput() {
    return this._tls.internalValue;
  }

  // token_ttl_minutes - computed: true, optional: true, required: false
  private _tokenTtlMinutes?: number; 
  public get tokenTtlMinutes() {
    return this.getNumberAttribute('token_ttl_minutes');
  }
  public set tokenTtlMinutes(value: number) {
    this._tokenTtlMinutes = value;
  }
  public resetTokenTtlMinutes() {
    this._tokenTtlMinutes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tokenTtlMinutesInput() {
    return this._tokenTtlMinutes;
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // url - computed: false, optional: true, required: false
  private _url?: string; 
  public get url() {
    return this.getStringAttribute('url');
  }
  public set url(value: string) {
    this._url = value;
  }
  public resetUrl() {
    this._url = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get urlInput() {
    return this._url;
  }

  // urls - computed: false, optional: true, required: false
  private _urls = new PackDestinationOutputCriblHttpUrlsList(this, "urls", false);
  public get urls() {
    return this._urls;
  }
  public putUrls(value: PackDestinationOutputCriblHttpUrls[] | cdktf.IResolvable) {
    this._urls.internalValue = value;
  }
  public resetUrls() {
    this._urls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get urlsInput() {
    return this._urls.internalValue;
  }

  // use_round_robin_dns - computed: true, optional: true, required: false
  private _useRoundRobinDns?: boolean | cdktf.IResolvable; 
  public get useRoundRobinDns() {
    return this.getBooleanAttribute('use_round_robin_dns');
  }
  public set useRoundRobinDns(value: boolean | cdktf.IResolvable) {
    this._useRoundRobinDns = value;
  }
  public resetUseRoundRobinDns() {
    this._useRoundRobinDns = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get useRoundRobinDnsInput() {
    return this._useRoundRobinDns;
  }
}
export interface PackDestinationOutputCriblLake {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#description PackDestination#description}
  */
  readonly description?: string;
  /**
  * Lake dataset to send the data to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#dest_path PackDestination#dest_path}
  */
  readonly destPath?: string;
  /**
  * Unique ID for this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#id PackDestination#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id: string;
  /**
  * must be "cribl_lake"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#type PackDestination#type}
  */
  readonly type: string;
}

export function packDestinationOutputCriblLakeToTerraform(struct?: PackDestinationOutputCriblLake | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    description: cdktf.stringToTerraform(struct!.description),
    dest_path: cdktf.stringToTerraform(struct!.destPath),
    id: cdktf.stringToTerraform(struct!.id),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function packDestinationOutputCriblLakeToHclTerraform(struct?: PackDestinationOutputCriblLake | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    dest_path: {
      value: cdktf.stringToHclTerraform(struct!.destPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputCriblLakeOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackDestinationOutputCriblLake | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._destPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.destPath = this._destPath;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputCriblLake | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._description = undefined;
      this._destPath = undefined;
      this._id = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._description = value.description;
      this._destPath = value.destPath;
      this._id = value.id;
      this._type = value.type;
    }
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // dest_path - computed: false, optional: true, required: false
  private _destPath?: string; 
  public get destPath() {
    return this.getStringAttribute('dest_path');
  }
  public set destPath(value: string) {
    this._destPath = value;
  }
  public resetDestPath() {
    this._destPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get destPathInput() {
    return this._destPath;
  }

  // id - computed: false, optional: false, required: true
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface PackDestinationOutputCriblTcpHosts {
  /**
  * The hostname of the receiver
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#host PackDestination#host}
  */
  readonly host: string;
  /**
  * The port to connect to on the provided host. Default: 10300
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#port PackDestination#port}
  */
  readonly port?: number;
  /**
  * Servername to use if establishing a TLS connection. If not specified, defaults to connection host (if not an IP); otherwise, uses the global TLS settings.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#servername PackDestination#servername}
  */
  readonly servername?: string;
  /**
  * Whether to inherit TLS configs from group setting or disable TLS. Default: "inherit"; must be one of ["inherit", "off"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#tls PackDestination#tls}
  */
  readonly tls?: string;
  /**
  * Assign a weight (>0) to each endpoint to indicate its traffic-handling capability. Default: 1
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#weight PackDestination#weight}
  */
  readonly weight?: number;
}

export function packDestinationOutputCriblTcpHostsToTerraform(struct?: PackDestinationOutputCriblTcpHosts | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    host: cdktf.stringToTerraform(struct!.host),
    port: cdktf.numberToTerraform(struct!.port),
    servername: cdktf.stringToTerraform(struct!.servername),
    tls: cdktf.stringToTerraform(struct!.tls),
    weight: cdktf.numberToTerraform(struct!.weight),
  }
}


export function packDestinationOutputCriblTcpHostsToHclTerraform(struct?: PackDestinationOutputCriblTcpHosts | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    host: {
      value: cdktf.stringToHclTerraform(struct!.host),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    servername: {
      value: cdktf.stringToHclTerraform(struct!.servername),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tls: {
      value: cdktf.stringToHclTerraform(struct!.tls),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    weight: {
      value: cdktf.numberToHclTerraform(struct!.weight),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputCriblTcpHostsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackDestinationOutputCriblTcpHosts | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._host !== undefined) {
      hasAnyValues = true;
      internalValueResult.host = this._host;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._servername !== undefined) {
      hasAnyValues = true;
      internalValueResult.servername = this._servername;
    }
    if (this._tls !== undefined) {
      hasAnyValues = true;
      internalValueResult.tls = this._tls;
    }
    if (this._weight !== undefined) {
      hasAnyValues = true;
      internalValueResult.weight = this._weight;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputCriblTcpHosts | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._host = undefined;
      this._port = undefined;
      this._servername = undefined;
      this._tls = undefined;
      this._weight = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._host = value.host;
      this._port = value.port;
      this._servername = value.servername;
      this._tls = value.tls;
      this._weight = value.weight;
    }
  }

  // host - computed: false, optional: false, required: true
  private _host?: string; 
  public get host() {
    return this.getStringAttribute('host');
  }
  public set host(value: string) {
    this._host = value;
  }
  // Temporarily expose input value. Use with caution.
  public get hostInput() {
    return this._host;
  }

  // port - computed: true, optional: true, required: false
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // servername - computed: false, optional: true, required: false
  private _servername?: string; 
  public get servername() {
    return this.getStringAttribute('servername');
  }
  public set servername(value: string) {
    this._servername = value;
  }
  public resetServername() {
    this._servername = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get servernameInput() {
    return this._servername;
  }

  // tls - computed: true, optional: true, required: false
  private _tls?: string; 
  public get tls() {
    return this.getStringAttribute('tls');
  }
  public set tls(value: string) {
    this._tls = value;
  }
  public resetTls() {
    this._tls = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsInput() {
    return this._tls;
  }

  // weight - computed: true, optional: true, required: false
  private _weight?: number; 
  public get weight() {
    return this.getNumberAttribute('weight');
  }
  public set weight(value: number) {
    this._weight = value;
  }
  public resetWeight() {
    this._weight = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get weightInput() {
    return this._weight;
  }
}

export class PackDestinationOutputCriblTcpHostsList extends cdktf.ComplexList {
  public internalValue? : PackDestinationOutputCriblTcpHosts[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackDestinationOutputCriblTcpHostsOutputReference {
    return new PackDestinationOutputCriblTcpHostsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackDestinationOutputCriblTcpPqControls {
}

export function packDestinationOutputCriblTcpPqControlsToTerraform(struct?: PackDestinationOutputCriblTcpPqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function packDestinationOutputCriblTcpPqControlsToHclTerraform(struct?: PackDestinationOutputCriblTcpPqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class PackDestinationOutputCriblTcpPqControlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackDestinationOutputCriblTcpPqControls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputCriblTcpPqControls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface PackDestinationOutputCriblTcpTls {
  /**
  * Path on client in which to find CA certificates to verify the server's cert. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#ca_path PackDestination#ca_path}
  */
  readonly caPath?: string;
  /**
  * Path on client in which to find certificates to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#cert_path PackDestination#cert_path}
  */
  readonly certPath?: string;
  /**
  * The name of the predefined certificate
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#certificate_name PackDestination#certificate_name}
  */
  readonly certificateName?: string;
  /**
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#disabled PackDestination#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_version PackDestination#max_version}
  */
  readonly maxVersion?: string;
  /**
  * must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#min_version PackDestination#min_version}
  */
  readonly minVersion?: string;
  /**
  * Passphrase to use to decrypt private key
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#passphrase PackDestination#passphrase}
  */
  readonly passphrase?: string;
  /**
  * Path on client in which to find the private key to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#priv_key_path PackDestination#priv_key_path}
  */
  readonly privKeyPath?: string;
  /**
  * Reject certificates that are not authorized by a CA in the CA certificate path, or by another 
  *                     trusted CA (such as the system's). Defaults to Enabled. Overrides the toggle from Advanced Settings, when also present.
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#reject_unauthorized PackDestination#reject_unauthorized}
  */
  readonly rejectUnauthorized?: boolean | cdktf.IResolvable;
  /**
  * Server name for the SNI (Server Name Indication) TLS extension. It must be a host name, and not an IP address.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#servername PackDestination#servername}
  */
  readonly servername?: string;
}

export function packDestinationOutputCriblTcpTlsToTerraform(struct?: PackDestinationOutputCriblTcpTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ca_path: cdktf.stringToTerraform(struct!.caPath),
    cert_path: cdktf.stringToTerraform(struct!.certPath),
    certificate_name: cdktf.stringToTerraform(struct!.certificateName),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    max_version: cdktf.stringToTerraform(struct!.maxVersion),
    min_version: cdktf.stringToTerraform(struct!.minVersion),
    passphrase: cdktf.stringToTerraform(struct!.passphrase),
    priv_key_path: cdktf.stringToTerraform(struct!.privKeyPath),
    reject_unauthorized: cdktf.booleanToTerraform(struct!.rejectUnauthorized),
    servername: cdktf.stringToTerraform(struct!.servername),
  }
}


export function packDestinationOutputCriblTcpTlsToHclTerraform(struct?: PackDestinationOutputCriblTcpTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ca_path: {
      value: cdktf.stringToHclTerraform(struct!.caPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    cert_path: {
      value: cdktf.stringToHclTerraform(struct!.certPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    certificate_name: {
      value: cdktf.stringToHclTerraform(struct!.certificateName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    max_version: {
      value: cdktf.stringToHclTerraform(struct!.maxVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    min_version: {
      value: cdktf.stringToHclTerraform(struct!.minVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    passphrase: {
      value: cdktf.stringToHclTerraform(struct!.passphrase),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    priv_key_path: {
      value: cdktf.stringToHclTerraform(struct!.privKeyPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reject_unauthorized: {
      value: cdktf.booleanToHclTerraform(struct!.rejectUnauthorized),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    servername: {
      value: cdktf.stringToHclTerraform(struct!.servername),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputCriblTcpTlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackDestinationOutputCriblTcpTls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._caPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.caPath = this._caPath;
    }
    if (this._certPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.certPath = this._certPath;
    }
    if (this._certificateName !== undefined) {
      hasAnyValues = true;
      internalValueResult.certificateName = this._certificateName;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._maxVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxVersion = this._maxVersion;
    }
    if (this._minVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.minVersion = this._minVersion;
    }
    if (this._passphrase !== undefined) {
      hasAnyValues = true;
      internalValueResult.passphrase = this._passphrase;
    }
    if (this._privKeyPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.privKeyPath = this._privKeyPath;
    }
    if (this._rejectUnauthorized !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectUnauthorized = this._rejectUnauthorized;
    }
    if (this._servername !== undefined) {
      hasAnyValues = true;
      internalValueResult.servername = this._servername;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputCriblTcpTls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._caPath = undefined;
      this._certPath = undefined;
      this._certificateName = undefined;
      this._disabled = undefined;
      this._maxVersion = undefined;
      this._minVersion = undefined;
      this._passphrase = undefined;
      this._privKeyPath = undefined;
      this._rejectUnauthorized = undefined;
      this._servername = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._caPath = value.caPath;
      this._certPath = value.certPath;
      this._certificateName = value.certificateName;
      this._disabled = value.disabled;
      this._maxVersion = value.maxVersion;
      this._minVersion = value.minVersion;
      this._passphrase = value.passphrase;
      this._privKeyPath = value.privKeyPath;
      this._rejectUnauthorized = value.rejectUnauthorized;
      this._servername = value.servername;
    }
  }

  // ca_path - computed: false, optional: true, required: false
  private _caPath?: string; 
  public get caPath() {
    return this.getStringAttribute('ca_path');
  }
  public set caPath(value: string) {
    this._caPath = value;
  }
  public resetCaPath() {
    this._caPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get caPathInput() {
    return this._caPath;
  }

  // cert_path - computed: false, optional: true, required: false
  private _certPath?: string; 
  public get certPath() {
    return this.getStringAttribute('cert_path');
  }
  public set certPath(value: string) {
    this._certPath = value;
  }
  public resetCertPath() {
    this._certPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certPathInput() {
    return this._certPath;
  }

  // certificate_name - computed: false, optional: true, required: false
  private _certificateName?: string; 
  public get certificateName() {
    return this.getStringAttribute('certificate_name');
  }
  public set certificateName(value: string) {
    this._certificateName = value;
  }
  public resetCertificateName() {
    this._certificateName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certificateNameInput() {
    return this._certificateName;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // max_version - computed: false, optional: true, required: false
  private _maxVersion?: string; 
  public get maxVersion() {
    return this.getStringAttribute('max_version');
  }
  public set maxVersion(value: string) {
    this._maxVersion = value;
  }
  public resetMaxVersion() {
    this._maxVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxVersionInput() {
    return this._maxVersion;
  }

  // min_version - computed: false, optional: true, required: false
  private _minVersion?: string; 
  public get minVersion() {
    return this.getStringAttribute('min_version');
  }
  public set minVersion(value: string) {
    this._minVersion = value;
  }
  public resetMinVersion() {
    this._minVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get minVersionInput() {
    return this._minVersion;
  }

  // passphrase - computed: false, optional: true, required: false
  private _passphrase?: string; 
  public get passphrase() {
    return this.getStringAttribute('passphrase');
  }
  public set passphrase(value: string) {
    this._passphrase = value;
  }
  public resetPassphrase() {
    this._passphrase = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passphraseInput() {
    return this._passphrase;
  }

  // priv_key_path - computed: false, optional: true, required: false
  private _privKeyPath?: string; 
  public get privKeyPath() {
    return this.getStringAttribute('priv_key_path');
  }
  public set privKeyPath(value: string) {
    this._privKeyPath = value;
  }
  public resetPrivKeyPath() {
    this._privKeyPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get privKeyPathInput() {
    return this._privKeyPath;
  }

  // reject_unauthorized - computed: true, optional: true, required: false
  private _rejectUnauthorized?: boolean | cdktf.IResolvable; 
  public get rejectUnauthorized() {
    return this.getBooleanAttribute('reject_unauthorized');
  }
  public set rejectUnauthorized(value: boolean | cdktf.IResolvable) {
    this._rejectUnauthorized = value;
  }
  public resetRejectUnauthorized() {
    this._rejectUnauthorized = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectUnauthorizedInput() {
    return this._rejectUnauthorized;
  }

  // servername - computed: false, optional: true, required: false
  private _servername?: string; 
  public get servername() {
    return this.getStringAttribute('servername');
  }
  public set servername(value: string) {
    this._servername = value;
  }
  public resetServername() {
    this._servername = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get servernameInput() {
    return this._servername;
  }
}
export interface PackDestinationOutputCriblTcp {
  /**
  * Codec to use to compress the data before sending. Default: "gzip"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#compression PackDestination#compression}
  */
  readonly compression?: string;
  /**
  * Amount of time (milliseconds) to wait for the connection to establish before retrying. Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#connection_timeout PackDestination#connection_timeout}
  */
  readonly connectionTimeout?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#description PackDestination#description}
  */
  readonly description?: string;
  /**
  * The interval in which to re-resolve any hostnames and pick up destinations from A records. Default: 600
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#dns_resolve_period_sec PackDestination#dns_resolve_period_sec}
  */
  readonly dnsResolvePeriodSec?: number;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#environment PackDestination#environment}
  */
  readonly environment?: string;
  /**
  * Fields to exclude from the event. By default, all internal fields except `__output` are sent. Example: `cribl_pipe`, `c*`. Wildcards supported. Default: ["__kube_*","__metadata","__winEvent"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#exclude_fields PackDestination#exclude_fields}
  */
  readonly excludeFields?: string[];
  /**
  * Exclude all IPs of the current host from the list of any resolved hostnames. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#exclude_self PackDestination#exclude_self}
  */
  readonly excludeSelf?: boolean | cdktf.IResolvable;
  /**
  * The hostname of the receiver
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#host PackDestination#host}
  */
  readonly host?: string;
  /**
  * Set of hosts to load-balance data to
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#hosts PackDestination#hosts}
  */
  readonly hosts?: PackDestinationOutputCriblTcpHosts[] | cdktf.IResolvable;
  /**
  * Unique ID for this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#id PackDestination#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id: string;
  /**
  * How far back in time to keep traffic stats for load balancing purposes. Default: 300
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#load_balance_stats_period_sec PackDestination#load_balance_stats_period_sec}
  */
  readonly loadBalanceStatsPeriodSec?: number;
  /**
  * Use load-balanced destinations. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#load_balanced PackDestination#load_balanced}
  */
  readonly loadBalanced?: boolean | cdktf.IResolvable;
  /**
  * Use to troubleshoot issues with sending data. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#log_failed_requests PackDestination#log_failed_requests}
  */
  readonly logFailedRequests?: boolean | cdktf.IResolvable;
  /**
  * Maximum number of concurrent connections (per Worker Process). A random set of IPs will be picked on every DNS resolution period. Use 0 for unlimited. Default: 0
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_concurrent_senders PackDestination#max_concurrent_senders}
  */
  readonly maxConcurrentSenders?: number;
  /**
  * How to handle events when all receivers are exerting backpressure. Default: "block"; must be one of ["block", "drop", "queue"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#on_backpressure PackDestination#on_backpressure}
  */
  readonly onBackpressure?: string;
  /**
  * Pipeline to process data before sending out to this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pipeline PackDestination#pipeline}
  */
  readonly pipeline?: string;
  /**
  * The port to connect to on the provided host. Default: 10300
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#port PackDestination#port}
  */
  readonly port?: number;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_compress PackDestination#pq_compress}
  */
  readonly pqCompress?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_controls PackDestination#pq_controls}
  */
  readonly pqControls?: PackDestinationOutputCriblTcpPqControls;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.). Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_max_file_size PackDestination#pq_max_file_size}
  */
  readonly pqMaxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_max_size PackDestination#pq_max_size}
  */
  readonly pqMaxSize?: string;
  /**
  * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem. Default: "error"; must be one of ["error", "backpressure", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_mode PackDestination#pq_mode}
  */
  readonly pqMode?: string;
  /**
  * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged. Default: "block"; must be one of ["block", "drop"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_on_backpressure PackDestination#pq_on_backpressure}
  */
  readonly pqOnBackpressure?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_path PackDestination#pq_path}
  */
  readonly pqPath?: string;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#streamtags PackDestination#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Fields to automatically add to events, such as cribl_pipe. Supports wildcards. Default: ["cribl_pipe"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#system_fields PackDestination#system_fields}
  */
  readonly systemFields?: string[];
  /**
  * Rate (in bytes per second) to throttle while writing to an output. Accepts values with multiple-byte units, such as KB, MB, and GB. (Example: 42 MB) Default value of 0 specifies no throttling. Default: "0"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#throttle_rate_per_sec PackDestination#throttle_rate_per_sec}
  */
  readonly throttleRatePerSec?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#tls PackDestination#tls}
  */
  readonly tls?: PackDestinationOutputCriblTcpTls;
  /**
  * The number of minutes before the internally generated authentication token expires, valid values between 1 and 60. Default: 60
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#token_ttl_minutes PackDestination#token_ttl_minutes}
  */
  readonly tokenTtlMinutes?: number;
  /**
  * must be "cribl_tcp"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#type PackDestination#type}
  */
  readonly type: string;
  /**
  * Amount of time (milliseconds) to wait for a write to complete before assuming connection is dead. Default: 60000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#write_timeout PackDestination#write_timeout}
  */
  readonly writeTimeout?: number;
}

export function packDestinationOutputCriblTcpToTerraform(struct?: PackDestinationOutputCriblTcp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    compression: cdktf.stringToTerraform(struct!.compression),
    connection_timeout: cdktf.numberToTerraform(struct!.connectionTimeout),
    description: cdktf.stringToTerraform(struct!.description),
    dns_resolve_period_sec: cdktf.numberToTerraform(struct!.dnsResolvePeriodSec),
    environment: cdktf.stringToTerraform(struct!.environment),
    exclude_fields: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.excludeFields),
    exclude_self: cdktf.booleanToTerraform(struct!.excludeSelf),
    host: cdktf.stringToTerraform(struct!.host),
    hosts: cdktf.listMapper(packDestinationOutputCriblTcpHostsToTerraform, false)(struct!.hosts),
    id: cdktf.stringToTerraform(struct!.id),
    load_balance_stats_period_sec: cdktf.numberToTerraform(struct!.loadBalanceStatsPeriodSec),
    load_balanced: cdktf.booleanToTerraform(struct!.loadBalanced),
    log_failed_requests: cdktf.booleanToTerraform(struct!.logFailedRequests),
    max_concurrent_senders: cdktf.numberToTerraform(struct!.maxConcurrentSenders),
    on_backpressure: cdktf.stringToTerraform(struct!.onBackpressure),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    port: cdktf.numberToTerraform(struct!.port),
    pq_compress: cdktf.stringToTerraform(struct!.pqCompress),
    pq_controls: packDestinationOutputCriblTcpPqControlsToTerraform(struct!.pqControls),
    pq_max_file_size: cdktf.stringToTerraform(struct!.pqMaxFileSize),
    pq_max_size: cdktf.stringToTerraform(struct!.pqMaxSize),
    pq_mode: cdktf.stringToTerraform(struct!.pqMode),
    pq_on_backpressure: cdktf.stringToTerraform(struct!.pqOnBackpressure),
    pq_path: cdktf.stringToTerraform(struct!.pqPath),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    system_fields: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.systemFields),
    throttle_rate_per_sec: cdktf.stringToTerraform(struct!.throttleRatePerSec),
    tls: packDestinationOutputCriblTcpTlsToTerraform(struct!.tls),
    token_ttl_minutes: cdktf.numberToTerraform(struct!.tokenTtlMinutes),
    type: cdktf.stringToTerraform(struct!.type),
    write_timeout: cdktf.numberToTerraform(struct!.writeTimeout),
  }
}


export function packDestinationOutputCriblTcpToHclTerraform(struct?: PackDestinationOutputCriblTcp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    compression: {
      value: cdktf.stringToHclTerraform(struct!.compression),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    connection_timeout: {
      value: cdktf.numberToHclTerraform(struct!.connectionTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    dns_resolve_period_sec: {
      value: cdktf.numberToHclTerraform(struct!.dnsResolvePeriodSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    exclude_fields: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.excludeFields),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    exclude_self: {
      value: cdktf.booleanToHclTerraform(struct!.excludeSelf),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    host: {
      value: cdktf.stringToHclTerraform(struct!.host),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    hosts: {
      value: cdktf.listMapperHcl(packDestinationOutputCriblTcpHostsToHclTerraform, false)(struct!.hosts),
      isBlock: true,
      type: "list",
      storageClassType: "PackDestinationOutputCriblTcpHostsList",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    load_balance_stats_period_sec: {
      value: cdktf.numberToHclTerraform(struct!.loadBalanceStatsPeriodSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    load_balanced: {
      value: cdktf.booleanToHclTerraform(struct!.loadBalanced),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    log_failed_requests: {
      value: cdktf.booleanToHclTerraform(struct!.logFailedRequests),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    max_concurrent_senders: {
      value: cdktf.numberToHclTerraform(struct!.maxConcurrentSenders),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.onBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    pq_compress: {
      value: cdktf.stringToHclTerraform(struct!.pqCompress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_controls: {
      value: packDestinationOutputCriblTcpPqControlsToHclTerraform(struct!.pqControls),
      isBlock: true,
      type: "struct",
      storageClassType: "PackDestinationOutputCriblTcpPqControls",
    },
    pq_max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_max_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_mode: {
      value: cdktf.stringToHclTerraform(struct!.pqMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.pqOnBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_path: {
      value: cdktf.stringToHclTerraform(struct!.pqPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    system_fields: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.systemFields),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    throttle_rate_per_sec: {
      value: cdktf.stringToHclTerraform(struct!.throttleRatePerSec),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tls: {
      value: packDestinationOutputCriblTcpTlsToHclTerraform(struct!.tls),
      isBlock: true,
      type: "struct",
      storageClassType: "PackDestinationOutputCriblTcpTls",
    },
    token_ttl_minutes: {
      value: cdktf.numberToHclTerraform(struct!.tokenTtlMinutes),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    write_timeout: {
      value: cdktf.numberToHclTerraform(struct!.writeTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputCriblTcpOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackDestinationOutputCriblTcp | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._compression !== undefined) {
      hasAnyValues = true;
      internalValueResult.compression = this._compression;
    }
    if (this._connectionTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.connectionTimeout = this._connectionTimeout;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._dnsResolvePeriodSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.dnsResolvePeriodSec = this._dnsResolvePeriodSec;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._excludeFields !== undefined) {
      hasAnyValues = true;
      internalValueResult.excludeFields = this._excludeFields;
    }
    if (this._excludeSelf !== undefined) {
      hasAnyValues = true;
      internalValueResult.excludeSelf = this._excludeSelf;
    }
    if (this._host !== undefined) {
      hasAnyValues = true;
      internalValueResult.host = this._host;
    }
    if (this._hosts?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.hosts = this._hosts?.internalValue;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._loadBalanceStatsPeriodSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.loadBalanceStatsPeriodSec = this._loadBalanceStatsPeriodSec;
    }
    if (this._loadBalanced !== undefined) {
      hasAnyValues = true;
      internalValueResult.loadBalanced = this._loadBalanced;
    }
    if (this._logFailedRequests !== undefined) {
      hasAnyValues = true;
      internalValueResult.logFailedRequests = this._logFailedRequests;
    }
    if (this._maxConcurrentSenders !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxConcurrentSenders = this._maxConcurrentSenders;
    }
    if (this._onBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.onBackpressure = this._onBackpressure;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._pqCompress !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqCompress = this._pqCompress;
    }
    if (this._pqControls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqControls = this._pqControls?.internalValue;
    }
    if (this._pqMaxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxFileSize = this._pqMaxFileSize;
    }
    if (this._pqMaxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxSize = this._pqMaxSize;
    }
    if (this._pqMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMode = this._pqMode;
    }
    if (this._pqOnBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqOnBackpressure = this._pqOnBackpressure;
    }
    if (this._pqPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqPath = this._pqPath;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._systemFields !== undefined) {
      hasAnyValues = true;
      internalValueResult.systemFields = this._systemFields;
    }
    if (this._throttleRatePerSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.throttleRatePerSec = this._throttleRatePerSec;
    }
    if (this._tls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tls = this._tls?.internalValue;
    }
    if (this._tokenTtlMinutes !== undefined) {
      hasAnyValues = true;
      internalValueResult.tokenTtlMinutes = this._tokenTtlMinutes;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._writeTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.writeTimeout = this._writeTimeout;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputCriblTcp | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._compression = undefined;
      this._connectionTimeout = undefined;
      this._description = undefined;
      this._dnsResolvePeriodSec = undefined;
      this._environment = undefined;
      this._excludeFields = undefined;
      this._excludeSelf = undefined;
      this._host = undefined;
      this._hosts.internalValue = undefined;
      this._id = undefined;
      this._loadBalanceStatsPeriodSec = undefined;
      this._loadBalanced = undefined;
      this._logFailedRequests = undefined;
      this._maxConcurrentSenders = undefined;
      this._onBackpressure = undefined;
      this._pipeline = undefined;
      this._port = undefined;
      this._pqCompress = undefined;
      this._pqControls.internalValue = undefined;
      this._pqMaxFileSize = undefined;
      this._pqMaxSize = undefined;
      this._pqMode = undefined;
      this._pqOnBackpressure = undefined;
      this._pqPath = undefined;
      this._streamtags = undefined;
      this._systemFields = undefined;
      this._throttleRatePerSec = undefined;
      this._tls.internalValue = undefined;
      this._tokenTtlMinutes = undefined;
      this._type = undefined;
      this._writeTimeout = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._compression = value.compression;
      this._connectionTimeout = value.connectionTimeout;
      this._description = value.description;
      this._dnsResolvePeriodSec = value.dnsResolvePeriodSec;
      this._environment = value.environment;
      this._excludeFields = value.excludeFields;
      this._excludeSelf = value.excludeSelf;
      this._host = value.host;
      this._hosts.internalValue = value.hosts;
      this._id = value.id;
      this._loadBalanceStatsPeriodSec = value.loadBalanceStatsPeriodSec;
      this._loadBalanced = value.loadBalanced;
      this._logFailedRequests = value.logFailedRequests;
      this._maxConcurrentSenders = value.maxConcurrentSenders;
      this._onBackpressure = value.onBackpressure;
      this._pipeline = value.pipeline;
      this._port = value.port;
      this._pqCompress = value.pqCompress;
      this._pqControls.internalValue = value.pqControls;
      this._pqMaxFileSize = value.pqMaxFileSize;
      this._pqMaxSize = value.pqMaxSize;
      this._pqMode = value.pqMode;
      this._pqOnBackpressure = value.pqOnBackpressure;
      this._pqPath = value.pqPath;
      this._streamtags = value.streamtags;
      this._systemFields = value.systemFields;
      this._throttleRatePerSec = value.throttleRatePerSec;
      this._tls.internalValue = value.tls;
      this._tokenTtlMinutes = value.tokenTtlMinutes;
      this._type = value.type;
      this._writeTimeout = value.writeTimeout;
    }
  }

  // compression - computed: true, optional: true, required: false
  private _compression?: string; 
  public get compression() {
    return this.getStringAttribute('compression');
  }
  public set compression(value: string) {
    this._compression = value;
  }
  public resetCompression() {
    this._compression = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressionInput() {
    return this._compression;
  }

  // connection_timeout - computed: true, optional: true, required: false
  private _connectionTimeout?: number; 
  public get connectionTimeout() {
    return this.getNumberAttribute('connection_timeout');
  }
  public set connectionTimeout(value: number) {
    this._connectionTimeout = value;
  }
  public resetConnectionTimeout() {
    this._connectionTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectionTimeoutInput() {
    return this._connectionTimeout;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // dns_resolve_period_sec - computed: true, optional: true, required: false
  private _dnsResolvePeriodSec?: number; 
  public get dnsResolvePeriodSec() {
    return this.getNumberAttribute('dns_resolve_period_sec');
  }
  public set dnsResolvePeriodSec(value: number) {
    this._dnsResolvePeriodSec = value;
  }
  public resetDnsResolvePeriodSec() {
    this._dnsResolvePeriodSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dnsResolvePeriodSecInput() {
    return this._dnsResolvePeriodSec;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // exclude_fields - computed: true, optional: true, required: false
  private _excludeFields?: string[]; 
  public get excludeFields() {
    return this.getListAttribute('exclude_fields');
  }
  public set excludeFields(value: string[]) {
    this._excludeFields = value;
  }
  public resetExcludeFields() {
    this._excludeFields = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get excludeFieldsInput() {
    return this._excludeFields;
  }

  // exclude_self - computed: true, optional: true, required: false
  private _excludeSelf?: boolean | cdktf.IResolvable; 
  public get excludeSelf() {
    return this.getBooleanAttribute('exclude_self');
  }
  public set excludeSelf(value: boolean | cdktf.IResolvable) {
    this._excludeSelf = value;
  }
  public resetExcludeSelf() {
    this._excludeSelf = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get excludeSelfInput() {
    return this._excludeSelf;
  }

  // host - computed: false, optional: true, required: false
  private _host?: string; 
  public get host() {
    return this.getStringAttribute('host');
  }
  public set host(value: string) {
    this._host = value;
  }
  public resetHost() {
    this._host = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostInput() {
    return this._host;
  }

  // hosts - computed: false, optional: true, required: false
  private _hosts = new PackDestinationOutputCriblTcpHostsList(this, "hosts", false);
  public get hosts() {
    return this._hosts;
  }
  public putHosts(value: PackDestinationOutputCriblTcpHosts[] | cdktf.IResolvable) {
    this._hosts.internalValue = value;
  }
  public resetHosts() {
    this._hosts.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostsInput() {
    return this._hosts.internalValue;
  }

  // id - computed: false, optional: false, required: true
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // load_balance_stats_period_sec - computed: true, optional: true, required: false
  private _loadBalanceStatsPeriodSec?: number; 
  public get loadBalanceStatsPeriodSec() {
    return this.getNumberAttribute('load_balance_stats_period_sec');
  }
  public set loadBalanceStatsPeriodSec(value: number) {
    this._loadBalanceStatsPeriodSec = value;
  }
  public resetLoadBalanceStatsPeriodSec() {
    this._loadBalanceStatsPeriodSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get loadBalanceStatsPeriodSecInput() {
    return this._loadBalanceStatsPeriodSec;
  }

  // load_balanced - computed: true, optional: true, required: false
  private _loadBalanced?: boolean | cdktf.IResolvable; 
  public get loadBalanced() {
    return this.getBooleanAttribute('load_balanced');
  }
  public set loadBalanced(value: boolean | cdktf.IResolvable) {
    this._loadBalanced = value;
  }
  public resetLoadBalanced() {
    this._loadBalanced = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get loadBalancedInput() {
    return this._loadBalanced;
  }

  // log_failed_requests - computed: true, optional: true, required: false
  private _logFailedRequests?: boolean | cdktf.IResolvable; 
  public get logFailedRequests() {
    return this.getBooleanAttribute('log_failed_requests');
  }
  public set logFailedRequests(value: boolean | cdktf.IResolvable) {
    this._logFailedRequests = value;
  }
  public resetLogFailedRequests() {
    this._logFailedRequests = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get logFailedRequestsInput() {
    return this._logFailedRequests;
  }

  // max_concurrent_senders - computed: true, optional: true, required: false
  private _maxConcurrentSenders?: number; 
  public get maxConcurrentSenders() {
    return this.getNumberAttribute('max_concurrent_senders');
  }
  public set maxConcurrentSenders(value: number) {
    this._maxConcurrentSenders = value;
  }
  public resetMaxConcurrentSenders() {
    this._maxConcurrentSenders = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxConcurrentSendersInput() {
    return this._maxConcurrentSenders;
  }

  // on_backpressure - computed: true, optional: true, required: false
  private _onBackpressure?: string; 
  public get onBackpressure() {
    return this.getStringAttribute('on_backpressure');
  }
  public set onBackpressure(value: string) {
    this._onBackpressure = value;
  }
  public resetOnBackpressure() {
    this._onBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get onBackpressureInput() {
    return this._onBackpressure;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // port - computed: true, optional: true, required: false
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // pq_compress - computed: true, optional: true, required: false
  private _pqCompress?: string; 
  public get pqCompress() {
    return this.getStringAttribute('pq_compress');
  }
  public set pqCompress(value: string) {
    this._pqCompress = value;
  }
  public resetPqCompress() {
    this._pqCompress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqCompressInput() {
    return this._pqCompress;
  }

  // pq_controls - computed: false, optional: true, required: false
  private _pqControls = new PackDestinationOutputCriblTcpPqControlsOutputReference(this, "pq_controls");
  public get pqControls() {
    return this._pqControls;
  }
  public putPqControls(value: PackDestinationOutputCriblTcpPqControls) {
    this._pqControls.internalValue = value;
  }
  public resetPqControls() {
    this._pqControls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqControlsInput() {
    return this._pqControls.internalValue;
  }

  // pq_max_file_size - computed: true, optional: true, required: false
  private _pqMaxFileSize?: string; 
  public get pqMaxFileSize() {
    return this.getStringAttribute('pq_max_file_size');
  }
  public set pqMaxFileSize(value: string) {
    this._pqMaxFileSize = value;
  }
  public resetPqMaxFileSize() {
    this._pqMaxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxFileSizeInput() {
    return this._pqMaxFileSize;
  }

  // pq_max_size - computed: true, optional: true, required: false
  private _pqMaxSize?: string; 
  public get pqMaxSize() {
    return this.getStringAttribute('pq_max_size');
  }
  public set pqMaxSize(value: string) {
    this._pqMaxSize = value;
  }
  public resetPqMaxSize() {
    this._pqMaxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxSizeInput() {
    return this._pqMaxSize;
  }

  // pq_mode - computed: true, optional: true, required: false
  private _pqMode?: string; 
  public get pqMode() {
    return this.getStringAttribute('pq_mode');
  }
  public set pqMode(value: string) {
    this._pqMode = value;
  }
  public resetPqMode() {
    this._pqMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqModeInput() {
    return this._pqMode;
  }

  // pq_on_backpressure - computed: true, optional: true, required: false
  private _pqOnBackpressure?: string; 
  public get pqOnBackpressure() {
    return this.getStringAttribute('pq_on_backpressure');
  }
  public set pqOnBackpressure(value: string) {
    this._pqOnBackpressure = value;
  }
  public resetPqOnBackpressure() {
    this._pqOnBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqOnBackpressureInput() {
    return this._pqOnBackpressure;
  }

  // pq_path - computed: true, optional: true, required: false
  private _pqPath?: string; 
  public get pqPath() {
    return this.getStringAttribute('pq_path');
  }
  public set pqPath(value: string) {
    this._pqPath = value;
  }
  public resetPqPath() {
    this._pqPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqPathInput() {
    return this._pqPath;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // system_fields - computed: true, optional: true, required: false
  private _systemFields?: string[]; 
  public get systemFields() {
    return this.getListAttribute('system_fields');
  }
  public set systemFields(value: string[]) {
    this._systemFields = value;
  }
  public resetSystemFields() {
    this._systemFields = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get systemFieldsInput() {
    return this._systemFields;
  }

  // throttle_rate_per_sec - computed: true, optional: true, required: false
  private _throttleRatePerSec?: string; 
  public get throttleRatePerSec() {
    return this.getStringAttribute('throttle_rate_per_sec');
  }
  public set throttleRatePerSec(value: string) {
    this._throttleRatePerSec = value;
  }
  public resetThrottleRatePerSec() {
    this._throttleRatePerSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get throttleRatePerSecInput() {
    return this._throttleRatePerSec;
  }

  // tls - computed: false, optional: true, required: false
  private _tls = new PackDestinationOutputCriblTcpTlsOutputReference(this, "tls");
  public get tls() {
    return this._tls;
  }
  public putTls(value: PackDestinationOutputCriblTcpTls) {
    this._tls.internalValue = value;
  }
  public resetTls() {
    this._tls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsInput() {
    return this._tls.internalValue;
  }

  // token_ttl_minutes - computed: true, optional: true, required: false
  private _tokenTtlMinutes?: number; 
  public get tokenTtlMinutes() {
    return this.getNumberAttribute('token_ttl_minutes');
  }
  public set tokenTtlMinutes(value: number) {
    this._tokenTtlMinutes = value;
  }
  public resetTokenTtlMinutes() {
    this._tokenTtlMinutes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tokenTtlMinutesInput() {
    return this._tokenTtlMinutes;
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // write_timeout - computed: true, optional: true, required: false
  private _writeTimeout?: number; 
  public get writeTimeout() {
    return this.getNumberAttribute('write_timeout');
  }
  public set writeTimeout(value: number) {
    this._writeTimeout = value;
  }
  public resetWriteTimeout() {
    this._writeTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get writeTimeoutInput() {
    return this._writeTimeout;
  }
}
export interface PackDestinationOutputCrowdstrikeNextGenSiemExtraHttpHeaders {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#name PackDestination#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#value PackDestination#value}
  */
  readonly value: string;
}

export function packDestinationOutputCrowdstrikeNextGenSiemExtraHttpHeadersToTerraform(struct?: PackDestinationOutputCrowdstrikeNextGenSiemExtraHttpHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function packDestinationOutputCrowdstrikeNextGenSiemExtraHttpHeadersToHclTerraform(struct?: PackDestinationOutputCrowdstrikeNextGenSiemExtraHttpHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputCrowdstrikeNextGenSiemExtraHttpHeadersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackDestinationOutputCrowdstrikeNextGenSiemExtraHttpHeaders | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputCrowdstrikeNextGenSiemExtraHttpHeaders | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class PackDestinationOutputCrowdstrikeNextGenSiemExtraHttpHeadersList extends cdktf.ComplexList {
  public internalValue? : PackDestinationOutputCrowdstrikeNextGenSiemExtraHttpHeaders[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackDestinationOutputCrowdstrikeNextGenSiemExtraHttpHeadersOutputReference {
    return new PackDestinationOutputCrowdstrikeNextGenSiemExtraHttpHeadersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackDestinationOutputCrowdstrikeNextGenSiemPqControls {
}

export function packDestinationOutputCrowdstrikeNextGenSiemPqControlsToTerraform(struct?: PackDestinationOutputCrowdstrikeNextGenSiemPqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function packDestinationOutputCrowdstrikeNextGenSiemPqControlsToHclTerraform(struct?: PackDestinationOutputCrowdstrikeNextGenSiemPqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class PackDestinationOutputCrowdstrikeNextGenSiemPqControlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackDestinationOutputCrowdstrikeNextGenSiemPqControls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputCrowdstrikeNextGenSiemPqControls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface PackDestinationOutputCrowdstrikeNextGenSiemResponseRetrySettings {
  /**
  * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc. Default: 2
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#backoff_rate PackDestination#backoff_rate}
  */
  readonly backoffRate?: number;
  /**
  * The HTTP response status code that will trigger retries
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#http_status PackDestination#http_status}
  */
  readonly httpStatus: number;
  /**
  * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes). Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#initial_backoff PackDestination#initial_backoff}
  */
  readonly initialBackoff?: number;
  /**
  * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds). Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_backoff PackDestination#max_backoff}
  */
  readonly maxBackoff?: number;
}

export function packDestinationOutputCrowdstrikeNextGenSiemResponseRetrySettingsToTerraform(struct?: PackDestinationOutputCrowdstrikeNextGenSiemResponseRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    backoff_rate: cdktf.numberToTerraform(struct!.backoffRate),
    http_status: cdktf.numberToTerraform(struct!.httpStatus),
    initial_backoff: cdktf.numberToTerraform(struct!.initialBackoff),
    max_backoff: cdktf.numberToTerraform(struct!.maxBackoff),
  }
}


export function packDestinationOutputCrowdstrikeNextGenSiemResponseRetrySettingsToHclTerraform(struct?: PackDestinationOutputCrowdstrikeNextGenSiemResponseRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    backoff_rate: {
      value: cdktf.numberToHclTerraform(struct!.backoffRate),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    http_status: {
      value: cdktf.numberToHclTerraform(struct!.httpStatus),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    initial_backoff: {
      value: cdktf.numberToHclTerraform(struct!.initialBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_backoff: {
      value: cdktf.numberToHclTerraform(struct!.maxBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputCrowdstrikeNextGenSiemResponseRetrySettingsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackDestinationOutputCrowdstrikeNextGenSiemResponseRetrySettings | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._backoffRate !== undefined) {
      hasAnyValues = true;
      internalValueResult.backoffRate = this._backoffRate;
    }
    if (this._httpStatus !== undefined) {
      hasAnyValues = true;
      internalValueResult.httpStatus = this._httpStatus;
    }
    if (this._initialBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.initialBackoff = this._initialBackoff;
    }
    if (this._maxBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBackoff = this._maxBackoff;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputCrowdstrikeNextGenSiemResponseRetrySettings | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._backoffRate = undefined;
      this._httpStatus = undefined;
      this._initialBackoff = undefined;
      this._maxBackoff = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._backoffRate = value.backoffRate;
      this._httpStatus = value.httpStatus;
      this._initialBackoff = value.initialBackoff;
      this._maxBackoff = value.maxBackoff;
    }
  }

  // backoff_rate - computed: true, optional: true, required: false
  private _backoffRate?: number; 
  public get backoffRate() {
    return this.getNumberAttribute('backoff_rate');
  }
  public set backoffRate(value: number) {
    this._backoffRate = value;
  }
  public resetBackoffRate() {
    this._backoffRate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get backoffRateInput() {
    return this._backoffRate;
  }

  // http_status - computed: false, optional: false, required: true
  private _httpStatus?: number; 
  public get httpStatus() {
    return this.getNumberAttribute('http_status');
  }
  public set httpStatus(value: number) {
    this._httpStatus = value;
  }
  // Temporarily expose input value. Use with caution.
  public get httpStatusInput() {
    return this._httpStatus;
  }

  // initial_backoff - computed: true, optional: true, required: false
  private _initialBackoff?: number; 
  public get initialBackoff() {
    return this.getNumberAttribute('initial_backoff');
  }
  public set initialBackoff(value: number) {
    this._initialBackoff = value;
  }
  public resetInitialBackoff() {
    this._initialBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get initialBackoffInput() {
    return this._initialBackoff;
  }

  // max_backoff - computed: true, optional: true, required: false
  private _maxBackoff?: number; 
  public get maxBackoff() {
    return this.getNumberAttribute('max_backoff');
  }
  public set maxBackoff(value: number) {
    this._maxBackoff = value;
  }
  public resetMaxBackoff() {
    this._maxBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBackoffInput() {
    return this._maxBackoff;
  }
}

export class PackDestinationOutputCrowdstrikeNextGenSiemResponseRetrySettingsList extends cdktf.ComplexList {
  public internalValue? : PackDestinationOutputCrowdstrikeNextGenSiemResponseRetrySettings[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackDestinationOutputCrowdstrikeNextGenSiemResponseRetrySettingsOutputReference {
    return new PackDestinationOutputCrowdstrikeNextGenSiemResponseRetrySettingsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackDestinationOutputCrowdstrikeNextGenSiemTimeoutRetrySettings {
  /**
  * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc. Default: 2
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#backoff_rate PackDestination#backoff_rate}
  */
  readonly backoffRate?: number;
  /**
  * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes). Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#initial_backoff PackDestination#initial_backoff}
  */
  readonly initialBackoff?: number;
  /**
  * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds). Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_backoff PackDestination#max_backoff}
  */
  readonly maxBackoff?: number;
  /**
  * Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#timeout_retry PackDestination#timeout_retry}
  */
  readonly timeoutRetry?: boolean | cdktf.IResolvable;
}

export function packDestinationOutputCrowdstrikeNextGenSiemTimeoutRetrySettingsToTerraform(struct?: PackDestinationOutputCrowdstrikeNextGenSiemTimeoutRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    backoff_rate: cdktf.numberToTerraform(struct!.backoffRate),
    initial_backoff: cdktf.numberToTerraform(struct!.initialBackoff),
    max_backoff: cdktf.numberToTerraform(struct!.maxBackoff),
    timeout_retry: cdktf.booleanToTerraform(struct!.timeoutRetry),
  }
}


export function packDestinationOutputCrowdstrikeNextGenSiemTimeoutRetrySettingsToHclTerraform(struct?: PackDestinationOutputCrowdstrikeNextGenSiemTimeoutRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    backoff_rate: {
      value: cdktf.numberToHclTerraform(struct!.backoffRate),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    initial_backoff: {
      value: cdktf.numberToHclTerraform(struct!.initialBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_backoff: {
      value: cdktf.numberToHclTerraform(struct!.maxBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    timeout_retry: {
      value: cdktf.booleanToHclTerraform(struct!.timeoutRetry),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputCrowdstrikeNextGenSiemTimeoutRetrySettingsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackDestinationOutputCrowdstrikeNextGenSiemTimeoutRetrySettings | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._backoffRate !== undefined) {
      hasAnyValues = true;
      internalValueResult.backoffRate = this._backoffRate;
    }
    if (this._initialBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.initialBackoff = this._initialBackoff;
    }
    if (this._maxBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBackoff = this._maxBackoff;
    }
    if (this._timeoutRetry !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutRetry = this._timeoutRetry;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputCrowdstrikeNextGenSiemTimeoutRetrySettings | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._backoffRate = undefined;
      this._initialBackoff = undefined;
      this._maxBackoff = undefined;
      this._timeoutRetry = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._backoffRate = value.backoffRate;
      this._initialBackoff = value.initialBackoff;
      this._maxBackoff = value.maxBackoff;
      this._timeoutRetry = value.timeoutRetry;
    }
  }

  // backoff_rate - computed: true, optional: true, required: false
  private _backoffRate?: number; 
  public get backoffRate() {
    return this.getNumberAttribute('backoff_rate');
  }
  public set backoffRate(value: number) {
    this._backoffRate = value;
  }
  public resetBackoffRate() {
    this._backoffRate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get backoffRateInput() {
    return this._backoffRate;
  }

  // initial_backoff - computed: true, optional: true, required: false
  private _initialBackoff?: number; 
  public get initialBackoff() {
    return this.getNumberAttribute('initial_backoff');
  }
  public set initialBackoff(value: number) {
    this._initialBackoff = value;
  }
  public resetInitialBackoff() {
    this._initialBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get initialBackoffInput() {
    return this._initialBackoff;
  }

  // max_backoff - computed: true, optional: true, required: false
  private _maxBackoff?: number; 
  public get maxBackoff() {
    return this.getNumberAttribute('max_backoff');
  }
  public set maxBackoff(value: number) {
    this._maxBackoff = value;
  }
  public resetMaxBackoff() {
    this._maxBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBackoffInput() {
    return this._maxBackoff;
  }

  // timeout_retry - computed: true, optional: true, required: false
  private _timeoutRetry?: boolean | cdktf.IResolvable; 
  public get timeoutRetry() {
    return this.getBooleanAttribute('timeout_retry');
  }
  public set timeoutRetry(value: boolean | cdktf.IResolvable) {
    this._timeoutRetry = value;
  }
  public resetTimeoutRetry() {
    this._timeoutRetry = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutRetryInput() {
    return this._timeoutRetry;
  }
}
export interface PackDestinationOutputCrowdstrikeNextGenSiem {
  /**
  * Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate. Default: "manual"; must be one of ["manual", "secret"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#auth_type PackDestination#auth_type}
  */
  readonly authType?: string;
  /**
  * Compress the payload body before sending. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#compress PackDestination#compress}
  */
  readonly compress?: boolean | cdktf.IResolvable;
  /**
  * Maximum number of ongoing requests before blocking. Default: 5
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#concurrency PackDestination#concurrency}
  */
  readonly concurrency?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#description PackDestination#description}
  */
  readonly description?: string;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#environment PackDestination#environment}
  */
  readonly environment?: string;
  /**
  * Headers to add to all events
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#extra_http_headers PackDestination#extra_http_headers}
  */
  readonly extraHttpHeaders?: PackDestinationOutputCrowdstrikeNextGenSiemExtraHttpHeaders[] | cdktf.IResolvable;
  /**
  * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below. Default: "none"; must be one of ["payload", "payloadAndHeaders", "none"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#failed_request_logging_mode PackDestination#failed_request_logging_mode}
  */
  readonly failedRequestLoggingMode?: string;
  /**
  * Maximum time between requests. Small values could cause the payload size to be smaller than the configured Body size limit. Default: 1
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#flush_period_sec PackDestination#flush_period_sec}
  */
  readonly flushPeriodSec?: number;
  /**
  * When set to JSON, the event is automatically formatted with required fields before sending. When set to Raw, only the event's `_raw` value is sent. Default: "raw"; must be one of ["JSON", "raw"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#format PackDestination#format}
  */
  readonly format?: string;
  /**
  * Unique ID for this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#id PackDestination#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * Maximum number of events to include in the request body. Default is 0 (unlimited). Default: 0
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_payload_events PackDestination#max_payload_events}
  */
  readonly maxPayloadEvents?: number;
  /**
  * Maximum size, in KB, of the request body. Default: 4096
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_payload_size_kb PackDestination#max_payload_size_kb}
  */
  readonly maxPayloadSizeKb?: number;
  /**
  * How to handle events when all receivers are exerting backpressure. Default: "block"; must be one of ["block", "drop", "queue"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#on_backpressure PackDestination#on_backpressure}
  */
  readonly onBackpressure?: string;
  /**
  * Pipeline to process data before sending out to this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pipeline PackDestination#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_compress PackDestination#pq_compress}
  */
  readonly pqCompress?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_controls PackDestination#pq_controls}
  */
  readonly pqControls?: PackDestinationOutputCrowdstrikeNextGenSiemPqControls;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.). Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_max_file_size PackDestination#pq_max_file_size}
  */
  readonly pqMaxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_max_size PackDestination#pq_max_size}
  */
  readonly pqMaxSize?: string;
  /**
  * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem. Default: "error"; must be one of ["error", "backpressure", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_mode PackDestination#pq_mode}
  */
  readonly pqMode?: string;
  /**
  * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged. Default: "block"; must be one of ["block", "drop"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_on_backpressure PackDestination#pq_on_backpressure}
  */
  readonly pqOnBackpressure?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_path PackDestination#pq_path}
  */
  readonly pqPath?: string;
  /**
  * Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's). 
  *         Enabled by default. When this setting is also present in TLS Settings (Client Side), 
  *         that value will take precedence.
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#reject_unauthorized PackDestination#reject_unauthorized}
  */
  readonly rejectUnauthorized?: boolean | cdktf.IResolvable;
  /**
  * Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#response_honor_retry_after_header PackDestination#response_honor_retry_after_header}
  */
  readonly responseHonorRetryAfterHeader?: boolean | cdktf.IResolvable;
  /**
  * Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#response_retry_settings PackDestination#response_retry_settings}
  */
  readonly responseRetrySettings?: PackDestinationOutputCrowdstrikeNextGenSiemResponseRetrySettings[] | cdktf.IResolvable;
  /**
  * List of headers that are safe to log in plain text. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#safe_headers PackDestination#safe_headers}
  */
  readonly safeHeaders?: string[];
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#streamtags PackDestination#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Fields to automatically add to events, such as cribl_pipe. Supports wildcards. Default: ["cribl_pipe"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#system_fields PackDestination#system_fields}
  */
  readonly systemFields?: string[];
  /**
  * Select or create a stored text secret
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#text_secret PackDestination#text_secret}
  */
  readonly textSecret?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#timeout_retry_settings PackDestination#timeout_retry_settings}
  */
  readonly timeoutRetrySettings?: PackDestinationOutputCrowdstrikeNextGenSiemTimeoutRetrySettings;
  /**
  * Amount of time, in seconds, to wait for a request to complete before canceling it. Default: 30
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#timeout_sec PackDestination#timeout_sec}
  */
  readonly timeoutSec?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#token PackDestination#token}
  */
  readonly token?: string;
  /**
  * must be "crowdstrike_next_gen_siem"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#type PackDestination#type}
  */
  readonly type?: string;
  /**
  * URL provided from a CrowdStrike data connector. 
  * Example: https://ingest.<region>.crowdstrike.com/api/ingest/hec/<connection-id>/v1/services/collector
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#url PackDestination#url}
  */
  readonly url: string;
  /**
  * Enable round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. For optimal performance, consider enabling this setting for non-load balanced destinations. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#use_round_robin_dns PackDestination#use_round_robin_dns}
  */
  readonly useRoundRobinDns?: boolean | cdktf.IResolvable;
}

export function packDestinationOutputCrowdstrikeNextGenSiemToTerraform(struct?: PackDestinationOutputCrowdstrikeNextGenSiem | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    auth_type: cdktf.stringToTerraform(struct!.authType),
    compress: cdktf.booleanToTerraform(struct!.compress),
    concurrency: cdktf.numberToTerraform(struct!.concurrency),
    description: cdktf.stringToTerraform(struct!.description),
    environment: cdktf.stringToTerraform(struct!.environment),
    extra_http_headers: cdktf.listMapper(packDestinationOutputCrowdstrikeNextGenSiemExtraHttpHeadersToTerraform, false)(struct!.extraHttpHeaders),
    failed_request_logging_mode: cdktf.stringToTerraform(struct!.failedRequestLoggingMode),
    flush_period_sec: cdktf.numberToTerraform(struct!.flushPeriodSec),
    format: cdktf.stringToTerraform(struct!.format),
    id: cdktf.stringToTerraform(struct!.id),
    max_payload_events: cdktf.numberToTerraform(struct!.maxPayloadEvents),
    max_payload_size_kb: cdktf.numberToTerraform(struct!.maxPayloadSizeKb),
    on_backpressure: cdktf.stringToTerraform(struct!.onBackpressure),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    pq_compress: cdktf.stringToTerraform(struct!.pqCompress),
    pq_controls: packDestinationOutputCrowdstrikeNextGenSiemPqControlsToTerraform(struct!.pqControls),
    pq_max_file_size: cdktf.stringToTerraform(struct!.pqMaxFileSize),
    pq_max_size: cdktf.stringToTerraform(struct!.pqMaxSize),
    pq_mode: cdktf.stringToTerraform(struct!.pqMode),
    pq_on_backpressure: cdktf.stringToTerraform(struct!.pqOnBackpressure),
    pq_path: cdktf.stringToTerraform(struct!.pqPath),
    reject_unauthorized: cdktf.booleanToTerraform(struct!.rejectUnauthorized),
    response_honor_retry_after_header: cdktf.booleanToTerraform(struct!.responseHonorRetryAfterHeader),
    response_retry_settings: cdktf.listMapper(packDestinationOutputCrowdstrikeNextGenSiemResponseRetrySettingsToTerraform, false)(struct!.responseRetrySettings),
    safe_headers: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.safeHeaders),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    system_fields: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.systemFields),
    text_secret: cdktf.stringToTerraform(struct!.textSecret),
    timeout_retry_settings: packDestinationOutputCrowdstrikeNextGenSiemTimeoutRetrySettingsToTerraform(struct!.timeoutRetrySettings),
    timeout_sec: cdktf.numberToTerraform(struct!.timeoutSec),
    token: cdktf.stringToTerraform(struct!.token),
    type: cdktf.stringToTerraform(struct!.type),
    url: cdktf.stringToTerraform(struct!.url),
    use_round_robin_dns: cdktf.booleanToTerraform(struct!.useRoundRobinDns),
  }
}


export function packDestinationOutputCrowdstrikeNextGenSiemToHclTerraform(struct?: PackDestinationOutputCrowdstrikeNextGenSiem | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    auth_type: {
      value: cdktf.stringToHclTerraform(struct!.authType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    compress: {
      value: cdktf.booleanToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    concurrency: {
      value: cdktf.numberToHclTerraform(struct!.concurrency),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    extra_http_headers: {
      value: cdktf.listMapperHcl(packDestinationOutputCrowdstrikeNextGenSiemExtraHttpHeadersToHclTerraform, false)(struct!.extraHttpHeaders),
      isBlock: true,
      type: "list",
      storageClassType: "PackDestinationOutputCrowdstrikeNextGenSiemExtraHttpHeadersList",
    },
    failed_request_logging_mode: {
      value: cdktf.stringToHclTerraform(struct!.failedRequestLoggingMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    flush_period_sec: {
      value: cdktf.numberToHclTerraform(struct!.flushPeriodSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    format: {
      value: cdktf.stringToHclTerraform(struct!.format),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_payload_events: {
      value: cdktf.numberToHclTerraform(struct!.maxPayloadEvents),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_payload_size_kb: {
      value: cdktf.numberToHclTerraform(struct!.maxPayloadSizeKb),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.onBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_compress: {
      value: cdktf.stringToHclTerraform(struct!.pqCompress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_controls: {
      value: packDestinationOutputCrowdstrikeNextGenSiemPqControlsToHclTerraform(struct!.pqControls),
      isBlock: true,
      type: "struct",
      storageClassType: "PackDestinationOutputCrowdstrikeNextGenSiemPqControls",
    },
    pq_max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_max_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_mode: {
      value: cdktf.stringToHclTerraform(struct!.pqMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.pqOnBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_path: {
      value: cdktf.stringToHclTerraform(struct!.pqPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reject_unauthorized: {
      value: cdktf.booleanToHclTerraform(struct!.rejectUnauthorized),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    response_honor_retry_after_header: {
      value: cdktf.booleanToHclTerraform(struct!.responseHonorRetryAfterHeader),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    response_retry_settings: {
      value: cdktf.listMapperHcl(packDestinationOutputCrowdstrikeNextGenSiemResponseRetrySettingsToHclTerraform, false)(struct!.responseRetrySettings),
      isBlock: true,
      type: "list",
      storageClassType: "PackDestinationOutputCrowdstrikeNextGenSiemResponseRetrySettingsList",
    },
    safe_headers: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.safeHeaders),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    system_fields: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.systemFields),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    text_secret: {
      value: cdktf.stringToHclTerraform(struct!.textSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    timeout_retry_settings: {
      value: packDestinationOutputCrowdstrikeNextGenSiemTimeoutRetrySettingsToHclTerraform(struct!.timeoutRetrySettings),
      isBlock: true,
      type: "struct",
      storageClassType: "PackDestinationOutputCrowdstrikeNextGenSiemTimeoutRetrySettings",
    },
    timeout_sec: {
      value: cdktf.numberToHclTerraform(struct!.timeoutSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    token: {
      value: cdktf.stringToHclTerraform(struct!.token),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    url: {
      value: cdktf.stringToHclTerraform(struct!.url),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    use_round_robin_dns: {
      value: cdktf.booleanToHclTerraform(struct!.useRoundRobinDns),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputCrowdstrikeNextGenSiemOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackDestinationOutputCrowdstrikeNextGenSiem | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._authType !== undefined) {
      hasAnyValues = true;
      internalValueResult.authType = this._authType;
    }
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._concurrency !== undefined) {
      hasAnyValues = true;
      internalValueResult.concurrency = this._concurrency;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._extraHttpHeaders?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.extraHttpHeaders = this._extraHttpHeaders?.internalValue;
    }
    if (this._failedRequestLoggingMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.failedRequestLoggingMode = this._failedRequestLoggingMode;
    }
    if (this._flushPeriodSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.flushPeriodSec = this._flushPeriodSec;
    }
    if (this._format !== undefined) {
      hasAnyValues = true;
      internalValueResult.format = this._format;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._maxPayloadEvents !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxPayloadEvents = this._maxPayloadEvents;
    }
    if (this._maxPayloadSizeKb !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxPayloadSizeKb = this._maxPayloadSizeKb;
    }
    if (this._onBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.onBackpressure = this._onBackpressure;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._pqCompress !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqCompress = this._pqCompress;
    }
    if (this._pqControls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqControls = this._pqControls?.internalValue;
    }
    if (this._pqMaxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxFileSize = this._pqMaxFileSize;
    }
    if (this._pqMaxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxSize = this._pqMaxSize;
    }
    if (this._pqMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMode = this._pqMode;
    }
    if (this._pqOnBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqOnBackpressure = this._pqOnBackpressure;
    }
    if (this._pqPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqPath = this._pqPath;
    }
    if (this._rejectUnauthorized !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectUnauthorized = this._rejectUnauthorized;
    }
    if (this._responseHonorRetryAfterHeader !== undefined) {
      hasAnyValues = true;
      internalValueResult.responseHonorRetryAfterHeader = this._responseHonorRetryAfterHeader;
    }
    if (this._responseRetrySettings?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.responseRetrySettings = this._responseRetrySettings?.internalValue;
    }
    if (this._safeHeaders !== undefined) {
      hasAnyValues = true;
      internalValueResult.safeHeaders = this._safeHeaders;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._systemFields !== undefined) {
      hasAnyValues = true;
      internalValueResult.systemFields = this._systemFields;
    }
    if (this._textSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.textSecret = this._textSecret;
    }
    if (this._timeoutRetrySettings?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutRetrySettings = this._timeoutRetrySettings?.internalValue;
    }
    if (this._timeoutSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutSec = this._timeoutSec;
    }
    if (this._token !== undefined) {
      hasAnyValues = true;
      internalValueResult.token = this._token;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._url !== undefined) {
      hasAnyValues = true;
      internalValueResult.url = this._url;
    }
    if (this._useRoundRobinDns !== undefined) {
      hasAnyValues = true;
      internalValueResult.useRoundRobinDns = this._useRoundRobinDns;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputCrowdstrikeNextGenSiem | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._authType = undefined;
      this._compress = undefined;
      this._concurrency = undefined;
      this._description = undefined;
      this._environment = undefined;
      this._extraHttpHeaders.internalValue = undefined;
      this._failedRequestLoggingMode = undefined;
      this._flushPeriodSec = undefined;
      this._format = undefined;
      this._id = undefined;
      this._maxPayloadEvents = undefined;
      this._maxPayloadSizeKb = undefined;
      this._onBackpressure = undefined;
      this._pipeline = undefined;
      this._pqCompress = undefined;
      this._pqControls.internalValue = undefined;
      this._pqMaxFileSize = undefined;
      this._pqMaxSize = undefined;
      this._pqMode = undefined;
      this._pqOnBackpressure = undefined;
      this._pqPath = undefined;
      this._rejectUnauthorized = undefined;
      this._responseHonorRetryAfterHeader = undefined;
      this._responseRetrySettings.internalValue = undefined;
      this._safeHeaders = undefined;
      this._streamtags = undefined;
      this._systemFields = undefined;
      this._textSecret = undefined;
      this._timeoutRetrySettings.internalValue = undefined;
      this._timeoutSec = undefined;
      this._token = undefined;
      this._type = undefined;
      this._url = undefined;
      this._useRoundRobinDns = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._authType = value.authType;
      this._compress = value.compress;
      this._concurrency = value.concurrency;
      this._description = value.description;
      this._environment = value.environment;
      this._extraHttpHeaders.internalValue = value.extraHttpHeaders;
      this._failedRequestLoggingMode = value.failedRequestLoggingMode;
      this._flushPeriodSec = value.flushPeriodSec;
      this._format = value.format;
      this._id = value.id;
      this._maxPayloadEvents = value.maxPayloadEvents;
      this._maxPayloadSizeKb = value.maxPayloadSizeKb;
      this._onBackpressure = value.onBackpressure;
      this._pipeline = value.pipeline;
      this._pqCompress = value.pqCompress;
      this._pqControls.internalValue = value.pqControls;
      this._pqMaxFileSize = value.pqMaxFileSize;
      this._pqMaxSize = value.pqMaxSize;
      this._pqMode = value.pqMode;
      this._pqOnBackpressure = value.pqOnBackpressure;
      this._pqPath = value.pqPath;
      this._rejectUnauthorized = value.rejectUnauthorized;
      this._responseHonorRetryAfterHeader = value.responseHonorRetryAfterHeader;
      this._responseRetrySettings.internalValue = value.responseRetrySettings;
      this._safeHeaders = value.safeHeaders;
      this._streamtags = value.streamtags;
      this._systemFields = value.systemFields;
      this._textSecret = value.textSecret;
      this._timeoutRetrySettings.internalValue = value.timeoutRetrySettings;
      this._timeoutSec = value.timeoutSec;
      this._token = value.token;
      this._type = value.type;
      this._url = value.url;
      this._useRoundRobinDns = value.useRoundRobinDns;
    }
  }

  // auth_type - computed: true, optional: true, required: false
  private _authType?: string; 
  public get authType() {
    return this.getStringAttribute('auth_type');
  }
  public set authType(value: string) {
    this._authType = value;
  }
  public resetAuthType() {
    this._authType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authTypeInput() {
    return this._authType;
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: boolean | cdktf.IResolvable; 
  public get compress() {
    return this.getBooleanAttribute('compress');
  }
  public set compress(value: boolean | cdktf.IResolvable) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // concurrency - computed: true, optional: true, required: false
  private _concurrency?: number; 
  public get concurrency() {
    return this.getNumberAttribute('concurrency');
  }
  public set concurrency(value: number) {
    this._concurrency = value;
  }
  public resetConcurrency() {
    this._concurrency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get concurrencyInput() {
    return this._concurrency;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // extra_http_headers - computed: false, optional: true, required: false
  private _extraHttpHeaders = new PackDestinationOutputCrowdstrikeNextGenSiemExtraHttpHeadersList(this, "extra_http_headers", false);
  public get extraHttpHeaders() {
    return this._extraHttpHeaders;
  }
  public putExtraHttpHeaders(value: PackDestinationOutputCrowdstrikeNextGenSiemExtraHttpHeaders[] | cdktf.IResolvable) {
    this._extraHttpHeaders.internalValue = value;
  }
  public resetExtraHttpHeaders() {
    this._extraHttpHeaders.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get extraHttpHeadersInput() {
    return this._extraHttpHeaders.internalValue;
  }

  // failed_request_logging_mode - computed: true, optional: true, required: false
  private _failedRequestLoggingMode?: string; 
  public get failedRequestLoggingMode() {
    return this.getStringAttribute('failed_request_logging_mode');
  }
  public set failedRequestLoggingMode(value: string) {
    this._failedRequestLoggingMode = value;
  }
  public resetFailedRequestLoggingMode() {
    this._failedRequestLoggingMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get failedRequestLoggingModeInput() {
    return this._failedRequestLoggingMode;
  }

  // flush_period_sec - computed: true, optional: true, required: false
  private _flushPeriodSec?: number; 
  public get flushPeriodSec() {
    return this.getNumberAttribute('flush_period_sec');
  }
  public set flushPeriodSec(value: number) {
    this._flushPeriodSec = value;
  }
  public resetFlushPeriodSec() {
    this._flushPeriodSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get flushPeriodSecInput() {
    return this._flushPeriodSec;
  }

  // format - computed: true, optional: true, required: false
  private _format?: string; 
  public get format() {
    return this.getStringAttribute('format');
  }
  public set format(value: string) {
    this._format = value;
  }
  public resetFormat() {
    this._format = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get formatInput() {
    return this._format;
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // max_payload_events - computed: true, optional: true, required: false
  private _maxPayloadEvents?: number; 
  public get maxPayloadEvents() {
    return this.getNumberAttribute('max_payload_events');
  }
  public set maxPayloadEvents(value: number) {
    this._maxPayloadEvents = value;
  }
  public resetMaxPayloadEvents() {
    this._maxPayloadEvents = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxPayloadEventsInput() {
    return this._maxPayloadEvents;
  }

  // max_payload_size_kb - computed: true, optional: true, required: false
  private _maxPayloadSizeKb?: number; 
  public get maxPayloadSizeKb() {
    return this.getNumberAttribute('max_payload_size_kb');
  }
  public set maxPayloadSizeKb(value: number) {
    this._maxPayloadSizeKb = value;
  }
  public resetMaxPayloadSizeKb() {
    this._maxPayloadSizeKb = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxPayloadSizeKbInput() {
    return this._maxPayloadSizeKb;
  }

  // on_backpressure - computed: true, optional: true, required: false
  private _onBackpressure?: string; 
  public get onBackpressure() {
    return this.getStringAttribute('on_backpressure');
  }
  public set onBackpressure(value: string) {
    this._onBackpressure = value;
  }
  public resetOnBackpressure() {
    this._onBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get onBackpressureInput() {
    return this._onBackpressure;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // pq_compress - computed: true, optional: true, required: false
  private _pqCompress?: string; 
  public get pqCompress() {
    return this.getStringAttribute('pq_compress');
  }
  public set pqCompress(value: string) {
    this._pqCompress = value;
  }
  public resetPqCompress() {
    this._pqCompress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqCompressInput() {
    return this._pqCompress;
  }

  // pq_controls - computed: false, optional: true, required: false
  private _pqControls = new PackDestinationOutputCrowdstrikeNextGenSiemPqControlsOutputReference(this, "pq_controls");
  public get pqControls() {
    return this._pqControls;
  }
  public putPqControls(value: PackDestinationOutputCrowdstrikeNextGenSiemPqControls) {
    this._pqControls.internalValue = value;
  }
  public resetPqControls() {
    this._pqControls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqControlsInput() {
    return this._pqControls.internalValue;
  }

  // pq_max_file_size - computed: true, optional: true, required: false
  private _pqMaxFileSize?: string; 
  public get pqMaxFileSize() {
    return this.getStringAttribute('pq_max_file_size');
  }
  public set pqMaxFileSize(value: string) {
    this._pqMaxFileSize = value;
  }
  public resetPqMaxFileSize() {
    this._pqMaxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxFileSizeInput() {
    return this._pqMaxFileSize;
  }

  // pq_max_size - computed: true, optional: true, required: false
  private _pqMaxSize?: string; 
  public get pqMaxSize() {
    return this.getStringAttribute('pq_max_size');
  }
  public set pqMaxSize(value: string) {
    this._pqMaxSize = value;
  }
  public resetPqMaxSize() {
    this._pqMaxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxSizeInput() {
    return this._pqMaxSize;
  }

  // pq_mode - computed: true, optional: true, required: false
  private _pqMode?: string; 
  public get pqMode() {
    return this.getStringAttribute('pq_mode');
  }
  public set pqMode(value: string) {
    this._pqMode = value;
  }
  public resetPqMode() {
    this._pqMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqModeInput() {
    return this._pqMode;
  }

  // pq_on_backpressure - computed: true, optional: true, required: false
  private _pqOnBackpressure?: string; 
  public get pqOnBackpressure() {
    return this.getStringAttribute('pq_on_backpressure');
  }
  public set pqOnBackpressure(value: string) {
    this._pqOnBackpressure = value;
  }
  public resetPqOnBackpressure() {
    this._pqOnBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqOnBackpressureInput() {
    return this._pqOnBackpressure;
  }

  // pq_path - computed: true, optional: true, required: false
  private _pqPath?: string; 
  public get pqPath() {
    return this.getStringAttribute('pq_path');
  }
  public set pqPath(value: string) {
    this._pqPath = value;
  }
  public resetPqPath() {
    this._pqPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqPathInput() {
    return this._pqPath;
  }

  // reject_unauthorized - computed: true, optional: true, required: false
  private _rejectUnauthorized?: boolean | cdktf.IResolvable; 
  public get rejectUnauthorized() {
    return this.getBooleanAttribute('reject_unauthorized');
  }
  public set rejectUnauthorized(value: boolean | cdktf.IResolvable) {
    this._rejectUnauthorized = value;
  }
  public resetRejectUnauthorized() {
    this._rejectUnauthorized = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectUnauthorizedInput() {
    return this._rejectUnauthorized;
  }

  // response_honor_retry_after_header - computed: true, optional: true, required: false
  private _responseHonorRetryAfterHeader?: boolean | cdktf.IResolvable; 
  public get responseHonorRetryAfterHeader() {
    return this.getBooleanAttribute('response_honor_retry_after_header');
  }
  public set responseHonorRetryAfterHeader(value: boolean | cdktf.IResolvable) {
    this._responseHonorRetryAfterHeader = value;
  }
  public resetResponseHonorRetryAfterHeader() {
    this._responseHonorRetryAfterHeader = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get responseHonorRetryAfterHeaderInput() {
    return this._responseHonorRetryAfterHeader;
  }

  // response_retry_settings - computed: false, optional: true, required: false
  private _responseRetrySettings = new PackDestinationOutputCrowdstrikeNextGenSiemResponseRetrySettingsList(this, "response_retry_settings", false);
  public get responseRetrySettings() {
    return this._responseRetrySettings;
  }
  public putResponseRetrySettings(value: PackDestinationOutputCrowdstrikeNextGenSiemResponseRetrySettings[] | cdktf.IResolvable) {
    this._responseRetrySettings.internalValue = value;
  }
  public resetResponseRetrySettings() {
    this._responseRetrySettings.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get responseRetrySettingsInput() {
    return this._responseRetrySettings.internalValue;
  }

  // safe_headers - computed: true, optional: true, required: false
  private _safeHeaders?: string[]; 
  public get safeHeaders() {
    return this.getListAttribute('safe_headers');
  }
  public set safeHeaders(value: string[]) {
    this._safeHeaders = value;
  }
  public resetSafeHeaders() {
    this._safeHeaders = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get safeHeadersInput() {
    return this._safeHeaders;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // system_fields - computed: true, optional: true, required: false
  private _systemFields?: string[]; 
  public get systemFields() {
    return this.getListAttribute('system_fields');
  }
  public set systemFields(value: string[]) {
    this._systemFields = value;
  }
  public resetSystemFields() {
    this._systemFields = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get systemFieldsInput() {
    return this._systemFields;
  }

  // text_secret - computed: false, optional: true, required: false
  private _textSecret?: string; 
  public get textSecret() {
    return this.getStringAttribute('text_secret');
  }
  public set textSecret(value: string) {
    this._textSecret = value;
  }
  public resetTextSecret() {
    this._textSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get textSecretInput() {
    return this._textSecret;
  }

  // timeout_retry_settings - computed: false, optional: true, required: false
  private _timeoutRetrySettings = new PackDestinationOutputCrowdstrikeNextGenSiemTimeoutRetrySettingsOutputReference(this, "timeout_retry_settings");
  public get timeoutRetrySettings() {
    return this._timeoutRetrySettings;
  }
  public putTimeoutRetrySettings(value: PackDestinationOutputCrowdstrikeNextGenSiemTimeoutRetrySettings) {
    this._timeoutRetrySettings.internalValue = value;
  }
  public resetTimeoutRetrySettings() {
    this._timeoutRetrySettings.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutRetrySettingsInput() {
    return this._timeoutRetrySettings.internalValue;
  }

  // timeout_sec - computed: true, optional: true, required: false
  private _timeoutSec?: number; 
  public get timeoutSec() {
    return this.getNumberAttribute('timeout_sec');
  }
  public set timeoutSec(value: number) {
    this._timeoutSec = value;
  }
  public resetTimeoutSec() {
    this._timeoutSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutSecInput() {
    return this._timeoutSec;
  }

  // token - computed: false, optional: true, required: false
  private _token?: string; 
  public get token() {
    return this.getStringAttribute('token');
  }
  public set token(value: string) {
    this._token = value;
  }
  public resetToken() {
    this._token = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tokenInput() {
    return this._token;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // url - computed: false, optional: false, required: true
  private _url?: string; 
  public get url() {
    return this.getStringAttribute('url');
  }
  public set url(value: string) {
    this._url = value;
  }
  // Temporarily expose input value. Use with caution.
  public get urlInput() {
    return this._url;
  }

  // use_round_robin_dns - computed: true, optional: true, required: false
  private _useRoundRobinDns?: boolean | cdktf.IResolvable; 
  public get useRoundRobinDns() {
    return this.getBooleanAttribute('use_round_robin_dns');
  }
  public set useRoundRobinDns(value: boolean | cdktf.IResolvable) {
    this._useRoundRobinDns = value;
  }
  public resetUseRoundRobinDns() {
    this._useRoundRobinDns = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get useRoundRobinDnsInput() {
    return this._useRoundRobinDns;
  }
}
export interface PackDestinationOutputDatadogExtraHttpHeaders {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#name PackDestination#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#value PackDestination#value}
  */
  readonly value: string;
}

export function packDestinationOutputDatadogExtraHttpHeadersToTerraform(struct?: PackDestinationOutputDatadogExtraHttpHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function packDestinationOutputDatadogExtraHttpHeadersToHclTerraform(struct?: PackDestinationOutputDatadogExtraHttpHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputDatadogExtraHttpHeadersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackDestinationOutputDatadogExtraHttpHeaders | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputDatadogExtraHttpHeaders | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class PackDestinationOutputDatadogExtraHttpHeadersList extends cdktf.ComplexList {
  public internalValue? : PackDestinationOutputDatadogExtraHttpHeaders[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackDestinationOutputDatadogExtraHttpHeadersOutputReference {
    return new PackDestinationOutputDatadogExtraHttpHeadersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackDestinationOutputDatadogPqControls {
}

export function packDestinationOutputDatadogPqControlsToTerraform(struct?: PackDestinationOutputDatadogPqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function packDestinationOutputDatadogPqControlsToHclTerraform(struct?: PackDestinationOutputDatadogPqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class PackDestinationOutputDatadogPqControlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackDestinationOutputDatadogPqControls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputDatadogPqControls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface PackDestinationOutputDatadogResponseRetrySettings {
  /**
  * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc. Default: 2
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#backoff_rate PackDestination#backoff_rate}
  */
  readonly backoffRate?: number;
  /**
  * The HTTP response status code that will trigger retries
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#http_status PackDestination#http_status}
  */
  readonly httpStatus: number;
  /**
  * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes). Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#initial_backoff PackDestination#initial_backoff}
  */
  readonly initialBackoff?: number;
  /**
  * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds). Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_backoff PackDestination#max_backoff}
  */
  readonly maxBackoff?: number;
}

export function packDestinationOutputDatadogResponseRetrySettingsToTerraform(struct?: PackDestinationOutputDatadogResponseRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    backoff_rate: cdktf.numberToTerraform(struct!.backoffRate),
    http_status: cdktf.numberToTerraform(struct!.httpStatus),
    initial_backoff: cdktf.numberToTerraform(struct!.initialBackoff),
    max_backoff: cdktf.numberToTerraform(struct!.maxBackoff),
  }
}


export function packDestinationOutputDatadogResponseRetrySettingsToHclTerraform(struct?: PackDestinationOutputDatadogResponseRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    backoff_rate: {
      value: cdktf.numberToHclTerraform(struct!.backoffRate),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    http_status: {
      value: cdktf.numberToHclTerraform(struct!.httpStatus),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    initial_backoff: {
      value: cdktf.numberToHclTerraform(struct!.initialBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_backoff: {
      value: cdktf.numberToHclTerraform(struct!.maxBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputDatadogResponseRetrySettingsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackDestinationOutputDatadogResponseRetrySettings | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._backoffRate !== undefined) {
      hasAnyValues = true;
      internalValueResult.backoffRate = this._backoffRate;
    }
    if (this._httpStatus !== undefined) {
      hasAnyValues = true;
      internalValueResult.httpStatus = this._httpStatus;
    }
    if (this._initialBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.initialBackoff = this._initialBackoff;
    }
    if (this._maxBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBackoff = this._maxBackoff;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputDatadogResponseRetrySettings | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._backoffRate = undefined;
      this._httpStatus = undefined;
      this._initialBackoff = undefined;
      this._maxBackoff = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._backoffRate = value.backoffRate;
      this._httpStatus = value.httpStatus;
      this._initialBackoff = value.initialBackoff;
      this._maxBackoff = value.maxBackoff;
    }
  }

  // backoff_rate - computed: true, optional: true, required: false
  private _backoffRate?: number; 
  public get backoffRate() {
    return this.getNumberAttribute('backoff_rate');
  }
  public set backoffRate(value: number) {
    this._backoffRate = value;
  }
  public resetBackoffRate() {
    this._backoffRate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get backoffRateInput() {
    return this._backoffRate;
  }

  // http_status - computed: false, optional: false, required: true
  private _httpStatus?: number; 
  public get httpStatus() {
    return this.getNumberAttribute('http_status');
  }
  public set httpStatus(value: number) {
    this._httpStatus = value;
  }
  // Temporarily expose input value. Use with caution.
  public get httpStatusInput() {
    return this._httpStatus;
  }

  // initial_backoff - computed: true, optional: true, required: false
  private _initialBackoff?: number; 
  public get initialBackoff() {
    return this.getNumberAttribute('initial_backoff');
  }
  public set initialBackoff(value: number) {
    this._initialBackoff = value;
  }
  public resetInitialBackoff() {
    this._initialBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get initialBackoffInput() {
    return this._initialBackoff;
  }

  // max_backoff - computed: true, optional: true, required: false
  private _maxBackoff?: number; 
  public get maxBackoff() {
    return this.getNumberAttribute('max_backoff');
  }
  public set maxBackoff(value: number) {
    this._maxBackoff = value;
  }
  public resetMaxBackoff() {
    this._maxBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBackoffInput() {
    return this._maxBackoff;
  }
}

export class PackDestinationOutputDatadogResponseRetrySettingsList extends cdktf.ComplexList {
  public internalValue? : PackDestinationOutputDatadogResponseRetrySettings[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackDestinationOutputDatadogResponseRetrySettingsOutputReference {
    return new PackDestinationOutputDatadogResponseRetrySettingsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackDestinationOutputDatadogTimeoutRetrySettings {
  /**
  * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc. Default: 2
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#backoff_rate PackDestination#backoff_rate}
  */
  readonly backoffRate?: number;
  /**
  * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes). Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#initial_backoff PackDestination#initial_backoff}
  */
  readonly initialBackoff?: number;
  /**
  * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds). Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_backoff PackDestination#max_backoff}
  */
  readonly maxBackoff?: number;
  /**
  * Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#timeout_retry PackDestination#timeout_retry}
  */
  readonly timeoutRetry?: boolean | cdktf.IResolvable;
}

export function packDestinationOutputDatadogTimeoutRetrySettingsToTerraform(struct?: PackDestinationOutputDatadogTimeoutRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    backoff_rate: cdktf.numberToTerraform(struct!.backoffRate),
    initial_backoff: cdktf.numberToTerraform(struct!.initialBackoff),
    max_backoff: cdktf.numberToTerraform(struct!.maxBackoff),
    timeout_retry: cdktf.booleanToTerraform(struct!.timeoutRetry),
  }
}


export function packDestinationOutputDatadogTimeoutRetrySettingsToHclTerraform(struct?: PackDestinationOutputDatadogTimeoutRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    backoff_rate: {
      value: cdktf.numberToHclTerraform(struct!.backoffRate),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    initial_backoff: {
      value: cdktf.numberToHclTerraform(struct!.initialBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_backoff: {
      value: cdktf.numberToHclTerraform(struct!.maxBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    timeout_retry: {
      value: cdktf.booleanToHclTerraform(struct!.timeoutRetry),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputDatadogTimeoutRetrySettingsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackDestinationOutputDatadogTimeoutRetrySettings | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._backoffRate !== undefined) {
      hasAnyValues = true;
      internalValueResult.backoffRate = this._backoffRate;
    }
    if (this._initialBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.initialBackoff = this._initialBackoff;
    }
    if (this._maxBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBackoff = this._maxBackoff;
    }
    if (this._timeoutRetry !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutRetry = this._timeoutRetry;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputDatadogTimeoutRetrySettings | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._backoffRate = undefined;
      this._initialBackoff = undefined;
      this._maxBackoff = undefined;
      this._timeoutRetry = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._backoffRate = value.backoffRate;
      this._initialBackoff = value.initialBackoff;
      this._maxBackoff = value.maxBackoff;
      this._timeoutRetry = value.timeoutRetry;
    }
  }

  // backoff_rate - computed: true, optional: true, required: false
  private _backoffRate?: number; 
  public get backoffRate() {
    return this.getNumberAttribute('backoff_rate');
  }
  public set backoffRate(value: number) {
    this._backoffRate = value;
  }
  public resetBackoffRate() {
    this._backoffRate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get backoffRateInput() {
    return this._backoffRate;
  }

  // initial_backoff - computed: true, optional: true, required: false
  private _initialBackoff?: number; 
  public get initialBackoff() {
    return this.getNumberAttribute('initial_backoff');
  }
  public set initialBackoff(value: number) {
    this._initialBackoff = value;
  }
  public resetInitialBackoff() {
    this._initialBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get initialBackoffInput() {
    return this._initialBackoff;
  }

  // max_backoff - computed: true, optional: true, required: false
  private _maxBackoff?: number; 
  public get maxBackoff() {
    return this.getNumberAttribute('max_backoff');
  }
  public set maxBackoff(value: number) {
    this._maxBackoff = value;
  }
  public resetMaxBackoff() {
    this._maxBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBackoffInput() {
    return this._maxBackoff;
  }

  // timeout_retry - computed: true, optional: true, required: false
  private _timeoutRetry?: boolean | cdktf.IResolvable; 
  public get timeoutRetry() {
    return this.getBooleanAttribute('timeout_retry');
  }
  public set timeoutRetry(value: boolean | cdktf.IResolvable) {
    this._timeoutRetry = value;
  }
  public resetTimeoutRetry() {
    this._timeoutRetry = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutRetryInput() {
    return this._timeoutRetry;
  }
}
export interface PackDestinationOutputDatadog {
  /**
  * Allow API key to be set from the event's '__agent_api_key' field. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#allow_api_key_from_events PackDestination#allow_api_key_from_events}
  */
  readonly allowApiKeyFromEvents?: boolean | cdktf.IResolvable;
  /**
  * Organization's API key in Datadog
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#api_key PackDestination#api_key}
  */
  readonly apiKey?: string;
  /**
  * Enter API key directly, or select a stored secret. Default: "manual"; must be one of ["manual", "secret"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#auth_type PackDestination#auth_type}
  */
  readonly authType?: string;
  /**
  * Batch events by API key and the ddtags field on the event. When disabled, batches events only by API key. If incoming events have high cardinality in the ddtags field, disabling this setting may improve Destination performance. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#batch_by_tags PackDestination#batch_by_tags}
  */
  readonly batchByTags?: boolean | cdktf.IResolvable;
  /**
  * Compress the payload body before sending. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#compress PackDestination#compress}
  */
  readonly compress?: boolean | cdktf.IResolvable;
  /**
  * Maximum number of ongoing requests before blocking. Default: 5
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#concurrency PackDestination#concurrency}
  */
  readonly concurrency?: number;
  /**
  * The content type to use when sending logs. Default: "json"; must be one of ["text", "json"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#content_type PackDestination#content_type}
  */
  readonly contentType?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#custom_url PackDestination#custom_url}
  */
  readonly customUrl?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#description PackDestination#description}
  */
  readonly description?: string;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#environment PackDestination#environment}
  */
  readonly environment?: string;
  /**
  * Headers to add to all events
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#extra_http_headers PackDestination#extra_http_headers}
  */
  readonly extraHttpHeaders?: PackDestinationOutputDatadogExtraHttpHeaders[] | cdktf.IResolvable;
  /**
  * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below. Default: "none"; must be one of ["payload", "payloadAndHeaders", "none"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#failed_request_logging_mode PackDestination#failed_request_logging_mode}
  */
  readonly failedRequestLoggingMode?: string;
  /**
  * Maximum time between requests. Small values could cause the payload size to be smaller than the configured Body size limit. Default: 1
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#flush_period_sec PackDestination#flush_period_sec}
  */
  readonly flushPeriodSec?: number;
  /**
  * Name of the host to send with logs. When you send logs as JSON objects, the event's 'host' field (if set) will override this value.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#host PackDestination#host}
  */
  readonly host?: string;
  /**
  * Unique ID for this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#id PackDestination#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id: string;
  /**
  * Maximum number of events to include in the request body. Default is 0 (unlimited). Default: 0
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_payload_events PackDestination#max_payload_events}
  */
  readonly maxPayloadEvents?: number;
  /**
  * Maximum size, in KB, of the request body. Default: 4096
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_payload_size_kb PackDestination#max_payload_size_kb}
  */
  readonly maxPayloadSizeKb?: number;
  /**
  * Name of the event field that contains the message to send. If not specified, Stream sends a JSON representation of the whole event.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#message PackDestination#message}
  */
  readonly message?: string;
  /**
  * How to handle events when all receivers are exerting backpressure. Default: "block"; must be one of ["block", "drop", "queue"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#on_backpressure PackDestination#on_backpressure}
  */
  readonly onBackpressure?: string;
  /**
  * Pipeline to process data before sending out to this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pipeline PackDestination#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_compress PackDestination#pq_compress}
  */
  readonly pqCompress?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_controls PackDestination#pq_controls}
  */
  readonly pqControls?: PackDestinationOutputDatadogPqControls;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.). Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_max_file_size PackDestination#pq_max_file_size}
  */
  readonly pqMaxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_max_size PackDestination#pq_max_size}
  */
  readonly pqMaxSize?: string;
  /**
  * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem. Default: "error"; must be one of ["error", "backpressure", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_mode PackDestination#pq_mode}
  */
  readonly pqMode?: string;
  /**
  * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged. Default: "block"; must be one of ["block", "drop"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_on_backpressure PackDestination#pq_on_backpressure}
  */
  readonly pqOnBackpressure?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_path PackDestination#pq_path}
  */
  readonly pqPath?: string;
  /**
  * Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's). 
  *         Enabled by default. When this setting is also present in TLS Settings (Client Side), 
  *         that value will take precedence.
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#reject_unauthorized PackDestination#reject_unauthorized}
  */
  readonly rejectUnauthorized?: boolean | cdktf.IResolvable;
  /**
  * Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#response_honor_retry_after_header PackDestination#response_honor_retry_after_header}
  */
  readonly responseHonorRetryAfterHeader?: boolean | cdktf.IResolvable;
  /**
  * Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#response_retry_settings PackDestination#response_retry_settings}
  */
  readonly responseRetrySettings?: PackDestinationOutputDatadogResponseRetrySettings[] | cdktf.IResolvable;
  /**
  * List of headers that are safe to log in plain text. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#safe_headers PackDestination#safe_headers}
  */
  readonly safeHeaders?: string[];
  /**
  * If not enabled, Datadog will transform 'counter' metrics to 'gauge'. [Learn more about Datadog metrics types.](https://docs.datadoghq.com/metrics/types/?tab=count). Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#send_counters_as_count PackDestination#send_counters_as_count}
  */
  readonly sendCountersAsCount?: boolean | cdktf.IResolvable;
  /**
  * Name of the service to send with logs. When you send logs as JSON objects, the event's '__service' field (if set) will override this value.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#service PackDestination#service}
  */
  readonly service?: string;
  /**
  * Default value for message severity. When you send logs as JSON objects, the event's '__severity' field (if set) will override this value. must be one of ["emergency", "alert", "critical", "error", "warning", "notice", "info", "debug"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#severity PackDestination#severity}
  */
  readonly severity?: string;
  /**
  * Datadog site to which events should be sent. Default: "us"; must be one of ["us", "us3", "us5", "eu", "fed1", "ap1", "custom"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#site PackDestination#site}
  */
  readonly site?: string;
  /**
  * Name of the source to send with logs. When you send logs as JSON objects, the event's 'source' field (if set) will override this value.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#source PackDestination#source}
  */
  readonly source?: string;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#streamtags PackDestination#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Fields to automatically add to events, such as cribl_pipe. Supports wildcards. Default: ["cribl_pipe"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#system_fields PackDestination#system_fields}
  */
  readonly systemFields?: string[];
  /**
  * List of tags to send with logs, such as 'env:prod' and 'env_staging:east'. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#tags PackDestination#tags}
  */
  readonly tags?: string[];
  /**
  * Select or create a stored text secret
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#text_secret PackDestination#text_secret}
  */
  readonly textSecret?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#timeout_retry_settings PackDestination#timeout_retry_settings}
  */
  readonly timeoutRetrySettings?: PackDestinationOutputDatadogTimeoutRetrySettings;
  /**
  * Amount of time, in seconds, to wait for a request to complete before canceling it. Default: 30
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#timeout_sec PackDestination#timeout_sec}
  */
  readonly timeoutSec?: number;
  /**
  * Maximum total size of the batches waiting to be sent. If left blank, defaults to 5 times the max body size (if set). If 0, no limit is enforced.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#total_memory_limit_kb PackDestination#total_memory_limit_kb}
  */
  readonly totalMemoryLimitKb?: number;
  /**
  * must be "datadog"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#type PackDestination#type}
  */
  readonly type: string;
  /**
  * Enable round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. For optimal performance, consider enabling this setting for non-load balanced destinations. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#use_round_robin_dns PackDestination#use_round_robin_dns}
  */
  readonly useRoundRobinDns?: boolean | cdktf.IResolvable;
}

export function packDestinationOutputDatadogToTerraform(struct?: PackDestinationOutputDatadog | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    allow_api_key_from_events: cdktf.booleanToTerraform(struct!.allowApiKeyFromEvents),
    api_key: cdktf.stringToTerraform(struct!.apiKey),
    auth_type: cdktf.stringToTerraform(struct!.authType),
    batch_by_tags: cdktf.booleanToTerraform(struct!.batchByTags),
    compress: cdktf.booleanToTerraform(struct!.compress),
    concurrency: cdktf.numberToTerraform(struct!.concurrency),
    content_type: cdktf.stringToTerraform(struct!.contentType),
    custom_url: cdktf.stringToTerraform(struct!.customUrl),
    description: cdktf.stringToTerraform(struct!.description),
    environment: cdktf.stringToTerraform(struct!.environment),
    extra_http_headers: cdktf.listMapper(packDestinationOutputDatadogExtraHttpHeadersToTerraform, false)(struct!.extraHttpHeaders),
    failed_request_logging_mode: cdktf.stringToTerraform(struct!.failedRequestLoggingMode),
    flush_period_sec: cdktf.numberToTerraform(struct!.flushPeriodSec),
    host: cdktf.stringToTerraform(struct!.host),
    id: cdktf.stringToTerraform(struct!.id),
    max_payload_events: cdktf.numberToTerraform(struct!.maxPayloadEvents),
    max_payload_size_kb: cdktf.numberToTerraform(struct!.maxPayloadSizeKb),
    message: cdktf.stringToTerraform(struct!.message),
    on_backpressure: cdktf.stringToTerraform(struct!.onBackpressure),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    pq_compress: cdktf.stringToTerraform(struct!.pqCompress),
    pq_controls: packDestinationOutputDatadogPqControlsToTerraform(struct!.pqControls),
    pq_max_file_size: cdktf.stringToTerraform(struct!.pqMaxFileSize),
    pq_max_size: cdktf.stringToTerraform(struct!.pqMaxSize),
    pq_mode: cdktf.stringToTerraform(struct!.pqMode),
    pq_on_backpressure: cdktf.stringToTerraform(struct!.pqOnBackpressure),
    pq_path: cdktf.stringToTerraform(struct!.pqPath),
    reject_unauthorized: cdktf.booleanToTerraform(struct!.rejectUnauthorized),
    response_honor_retry_after_header: cdktf.booleanToTerraform(struct!.responseHonorRetryAfterHeader),
    response_retry_settings: cdktf.listMapper(packDestinationOutputDatadogResponseRetrySettingsToTerraform, false)(struct!.responseRetrySettings),
    safe_headers: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.safeHeaders),
    send_counters_as_count: cdktf.booleanToTerraform(struct!.sendCountersAsCount),
    service: cdktf.stringToTerraform(struct!.service),
    severity: cdktf.stringToTerraform(struct!.severity),
    site: cdktf.stringToTerraform(struct!.site),
    source: cdktf.stringToTerraform(struct!.source),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    system_fields: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.systemFields),
    tags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.tags),
    text_secret: cdktf.stringToTerraform(struct!.textSecret),
    timeout_retry_settings: packDestinationOutputDatadogTimeoutRetrySettingsToTerraform(struct!.timeoutRetrySettings),
    timeout_sec: cdktf.numberToTerraform(struct!.timeoutSec),
    total_memory_limit_kb: cdktf.numberToTerraform(struct!.totalMemoryLimitKb),
    type: cdktf.stringToTerraform(struct!.type),
    use_round_robin_dns: cdktf.booleanToTerraform(struct!.useRoundRobinDns),
  }
}


export function packDestinationOutputDatadogToHclTerraform(struct?: PackDestinationOutputDatadog | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    allow_api_key_from_events: {
      value: cdktf.booleanToHclTerraform(struct!.allowApiKeyFromEvents),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    api_key: {
      value: cdktf.stringToHclTerraform(struct!.apiKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    auth_type: {
      value: cdktf.stringToHclTerraform(struct!.authType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    batch_by_tags: {
      value: cdktf.booleanToHclTerraform(struct!.batchByTags),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    compress: {
      value: cdktf.booleanToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    concurrency: {
      value: cdktf.numberToHclTerraform(struct!.concurrency),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    content_type: {
      value: cdktf.stringToHclTerraform(struct!.contentType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    custom_url: {
      value: cdktf.stringToHclTerraform(struct!.customUrl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    extra_http_headers: {
      value: cdktf.listMapperHcl(packDestinationOutputDatadogExtraHttpHeadersToHclTerraform, false)(struct!.extraHttpHeaders),
      isBlock: true,
      type: "list",
      storageClassType: "PackDestinationOutputDatadogExtraHttpHeadersList",
    },
    failed_request_logging_mode: {
      value: cdktf.stringToHclTerraform(struct!.failedRequestLoggingMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    flush_period_sec: {
      value: cdktf.numberToHclTerraform(struct!.flushPeriodSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    host: {
      value: cdktf.stringToHclTerraform(struct!.host),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_payload_events: {
      value: cdktf.numberToHclTerraform(struct!.maxPayloadEvents),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_payload_size_kb: {
      value: cdktf.numberToHclTerraform(struct!.maxPayloadSizeKb),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    message: {
      value: cdktf.stringToHclTerraform(struct!.message),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.onBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_compress: {
      value: cdktf.stringToHclTerraform(struct!.pqCompress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_controls: {
      value: packDestinationOutputDatadogPqControlsToHclTerraform(struct!.pqControls),
      isBlock: true,
      type: "struct",
      storageClassType: "PackDestinationOutputDatadogPqControls",
    },
    pq_max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_max_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_mode: {
      value: cdktf.stringToHclTerraform(struct!.pqMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.pqOnBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_path: {
      value: cdktf.stringToHclTerraform(struct!.pqPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reject_unauthorized: {
      value: cdktf.booleanToHclTerraform(struct!.rejectUnauthorized),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    response_honor_retry_after_header: {
      value: cdktf.booleanToHclTerraform(struct!.responseHonorRetryAfterHeader),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    response_retry_settings: {
      value: cdktf.listMapperHcl(packDestinationOutputDatadogResponseRetrySettingsToHclTerraform, false)(struct!.responseRetrySettings),
      isBlock: true,
      type: "list",
      storageClassType: "PackDestinationOutputDatadogResponseRetrySettingsList",
    },
    safe_headers: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.safeHeaders),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    send_counters_as_count: {
      value: cdktf.booleanToHclTerraform(struct!.sendCountersAsCount),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    service: {
      value: cdktf.stringToHclTerraform(struct!.service),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    severity: {
      value: cdktf.stringToHclTerraform(struct!.severity),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    site: {
      value: cdktf.stringToHclTerraform(struct!.site),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    source: {
      value: cdktf.stringToHclTerraform(struct!.source),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    system_fields: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.systemFields),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    tags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.tags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    text_secret: {
      value: cdktf.stringToHclTerraform(struct!.textSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    timeout_retry_settings: {
      value: packDestinationOutputDatadogTimeoutRetrySettingsToHclTerraform(struct!.timeoutRetrySettings),
      isBlock: true,
      type: "struct",
      storageClassType: "PackDestinationOutputDatadogTimeoutRetrySettings",
    },
    timeout_sec: {
      value: cdktf.numberToHclTerraform(struct!.timeoutSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    total_memory_limit_kb: {
      value: cdktf.numberToHclTerraform(struct!.totalMemoryLimitKb),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    use_round_robin_dns: {
      value: cdktf.booleanToHclTerraform(struct!.useRoundRobinDns),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputDatadogOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackDestinationOutputDatadog | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._allowApiKeyFromEvents !== undefined) {
      hasAnyValues = true;
      internalValueResult.allowApiKeyFromEvents = this._allowApiKeyFromEvents;
    }
    if (this._apiKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.apiKey = this._apiKey;
    }
    if (this._authType !== undefined) {
      hasAnyValues = true;
      internalValueResult.authType = this._authType;
    }
    if (this._batchByTags !== undefined) {
      hasAnyValues = true;
      internalValueResult.batchByTags = this._batchByTags;
    }
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._concurrency !== undefined) {
      hasAnyValues = true;
      internalValueResult.concurrency = this._concurrency;
    }
    if (this._contentType !== undefined) {
      hasAnyValues = true;
      internalValueResult.contentType = this._contentType;
    }
    if (this._customUrl !== undefined) {
      hasAnyValues = true;
      internalValueResult.customUrl = this._customUrl;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._extraHttpHeaders?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.extraHttpHeaders = this._extraHttpHeaders?.internalValue;
    }
    if (this._failedRequestLoggingMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.failedRequestLoggingMode = this._failedRequestLoggingMode;
    }
    if (this._flushPeriodSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.flushPeriodSec = this._flushPeriodSec;
    }
    if (this._host !== undefined) {
      hasAnyValues = true;
      internalValueResult.host = this._host;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._maxPayloadEvents !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxPayloadEvents = this._maxPayloadEvents;
    }
    if (this._maxPayloadSizeKb !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxPayloadSizeKb = this._maxPayloadSizeKb;
    }
    if (this._message !== undefined) {
      hasAnyValues = true;
      internalValueResult.message = this._message;
    }
    if (this._onBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.onBackpressure = this._onBackpressure;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._pqCompress !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqCompress = this._pqCompress;
    }
    if (this._pqControls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqControls = this._pqControls?.internalValue;
    }
    if (this._pqMaxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxFileSize = this._pqMaxFileSize;
    }
    if (this._pqMaxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxSize = this._pqMaxSize;
    }
    if (this._pqMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMode = this._pqMode;
    }
    if (this._pqOnBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqOnBackpressure = this._pqOnBackpressure;
    }
    if (this._pqPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqPath = this._pqPath;
    }
    if (this._rejectUnauthorized !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectUnauthorized = this._rejectUnauthorized;
    }
    if (this._responseHonorRetryAfterHeader !== undefined) {
      hasAnyValues = true;
      internalValueResult.responseHonorRetryAfterHeader = this._responseHonorRetryAfterHeader;
    }
    if (this._responseRetrySettings?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.responseRetrySettings = this._responseRetrySettings?.internalValue;
    }
    if (this._safeHeaders !== undefined) {
      hasAnyValues = true;
      internalValueResult.safeHeaders = this._safeHeaders;
    }
    if (this._sendCountersAsCount !== undefined) {
      hasAnyValues = true;
      internalValueResult.sendCountersAsCount = this._sendCountersAsCount;
    }
    if (this._service !== undefined) {
      hasAnyValues = true;
      internalValueResult.service = this._service;
    }
    if (this._severity !== undefined) {
      hasAnyValues = true;
      internalValueResult.severity = this._severity;
    }
    if (this._site !== undefined) {
      hasAnyValues = true;
      internalValueResult.site = this._site;
    }
    if (this._source !== undefined) {
      hasAnyValues = true;
      internalValueResult.source = this._source;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._systemFields !== undefined) {
      hasAnyValues = true;
      internalValueResult.systemFields = this._systemFields;
    }
    if (this._tags !== undefined) {
      hasAnyValues = true;
      internalValueResult.tags = this._tags;
    }
    if (this._textSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.textSecret = this._textSecret;
    }
    if (this._timeoutRetrySettings?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutRetrySettings = this._timeoutRetrySettings?.internalValue;
    }
    if (this._timeoutSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutSec = this._timeoutSec;
    }
    if (this._totalMemoryLimitKb !== undefined) {
      hasAnyValues = true;
      internalValueResult.totalMemoryLimitKb = this._totalMemoryLimitKb;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._useRoundRobinDns !== undefined) {
      hasAnyValues = true;
      internalValueResult.useRoundRobinDns = this._useRoundRobinDns;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputDatadog | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._allowApiKeyFromEvents = undefined;
      this._apiKey = undefined;
      this._authType = undefined;
      this._batchByTags = undefined;
      this._compress = undefined;
      this._concurrency = undefined;
      this._contentType = undefined;
      this._customUrl = undefined;
      this._description = undefined;
      this._environment = undefined;
      this._extraHttpHeaders.internalValue = undefined;
      this._failedRequestLoggingMode = undefined;
      this._flushPeriodSec = undefined;
      this._host = undefined;
      this._id = undefined;
      this._maxPayloadEvents = undefined;
      this._maxPayloadSizeKb = undefined;
      this._message = undefined;
      this._onBackpressure = undefined;
      this._pipeline = undefined;
      this._pqCompress = undefined;
      this._pqControls.internalValue = undefined;
      this._pqMaxFileSize = undefined;
      this._pqMaxSize = undefined;
      this._pqMode = undefined;
      this._pqOnBackpressure = undefined;
      this._pqPath = undefined;
      this._rejectUnauthorized = undefined;
      this._responseHonorRetryAfterHeader = undefined;
      this._responseRetrySettings.internalValue = undefined;
      this._safeHeaders = undefined;
      this._sendCountersAsCount = undefined;
      this._service = undefined;
      this._severity = undefined;
      this._site = undefined;
      this._source = undefined;
      this._streamtags = undefined;
      this._systemFields = undefined;
      this._tags = undefined;
      this._textSecret = undefined;
      this._timeoutRetrySettings.internalValue = undefined;
      this._timeoutSec = undefined;
      this._totalMemoryLimitKb = undefined;
      this._type = undefined;
      this._useRoundRobinDns = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._allowApiKeyFromEvents = value.allowApiKeyFromEvents;
      this._apiKey = value.apiKey;
      this._authType = value.authType;
      this._batchByTags = value.batchByTags;
      this._compress = value.compress;
      this._concurrency = value.concurrency;
      this._contentType = value.contentType;
      this._customUrl = value.customUrl;
      this._description = value.description;
      this._environment = value.environment;
      this._extraHttpHeaders.internalValue = value.extraHttpHeaders;
      this._failedRequestLoggingMode = value.failedRequestLoggingMode;
      this._flushPeriodSec = value.flushPeriodSec;
      this._host = value.host;
      this._id = value.id;
      this._maxPayloadEvents = value.maxPayloadEvents;
      this._maxPayloadSizeKb = value.maxPayloadSizeKb;
      this._message = value.message;
      this._onBackpressure = value.onBackpressure;
      this._pipeline = value.pipeline;
      this._pqCompress = value.pqCompress;
      this._pqControls.internalValue = value.pqControls;
      this._pqMaxFileSize = value.pqMaxFileSize;
      this._pqMaxSize = value.pqMaxSize;
      this._pqMode = value.pqMode;
      this._pqOnBackpressure = value.pqOnBackpressure;
      this._pqPath = value.pqPath;
      this._rejectUnauthorized = value.rejectUnauthorized;
      this._responseHonorRetryAfterHeader = value.responseHonorRetryAfterHeader;
      this._responseRetrySettings.internalValue = value.responseRetrySettings;
      this._safeHeaders = value.safeHeaders;
      this._sendCountersAsCount = value.sendCountersAsCount;
      this._service = value.service;
      this._severity = value.severity;
      this._site = value.site;
      this._source = value.source;
      this._streamtags = value.streamtags;
      this._systemFields = value.systemFields;
      this._tags = value.tags;
      this._textSecret = value.textSecret;
      this._timeoutRetrySettings.internalValue = value.timeoutRetrySettings;
      this._timeoutSec = value.timeoutSec;
      this._totalMemoryLimitKb = value.totalMemoryLimitKb;
      this._type = value.type;
      this._useRoundRobinDns = value.useRoundRobinDns;
    }
  }

  // allow_api_key_from_events - computed: true, optional: true, required: false
  private _allowApiKeyFromEvents?: boolean | cdktf.IResolvable; 
  public get allowApiKeyFromEvents() {
    return this.getBooleanAttribute('allow_api_key_from_events');
  }
  public set allowApiKeyFromEvents(value: boolean | cdktf.IResolvable) {
    this._allowApiKeyFromEvents = value;
  }
  public resetAllowApiKeyFromEvents() {
    this._allowApiKeyFromEvents = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get allowApiKeyFromEventsInput() {
    return this._allowApiKeyFromEvents;
  }

  // api_key - computed: false, optional: true, required: false
  private _apiKey?: string; 
  public get apiKey() {
    return this.getStringAttribute('api_key');
  }
  public set apiKey(value: string) {
    this._apiKey = value;
  }
  public resetApiKey() {
    this._apiKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get apiKeyInput() {
    return this._apiKey;
  }

  // auth_type - computed: true, optional: true, required: false
  private _authType?: string; 
  public get authType() {
    return this.getStringAttribute('auth_type');
  }
  public set authType(value: string) {
    this._authType = value;
  }
  public resetAuthType() {
    this._authType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authTypeInput() {
    return this._authType;
  }

  // batch_by_tags - computed: true, optional: true, required: false
  private _batchByTags?: boolean | cdktf.IResolvable; 
  public get batchByTags() {
    return this.getBooleanAttribute('batch_by_tags');
  }
  public set batchByTags(value: boolean | cdktf.IResolvable) {
    this._batchByTags = value;
  }
  public resetBatchByTags() {
    this._batchByTags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get batchByTagsInput() {
    return this._batchByTags;
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: boolean | cdktf.IResolvable; 
  public get compress() {
    return this.getBooleanAttribute('compress');
  }
  public set compress(value: boolean | cdktf.IResolvable) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // concurrency - computed: true, optional: true, required: false
  private _concurrency?: number; 
  public get concurrency() {
    return this.getNumberAttribute('concurrency');
  }
  public set concurrency(value: number) {
    this._concurrency = value;
  }
  public resetConcurrency() {
    this._concurrency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get concurrencyInput() {
    return this._concurrency;
  }

  // content_type - computed: true, optional: true, required: false
  private _contentType?: string; 
  public get contentType() {
    return this.getStringAttribute('content_type');
  }
  public set contentType(value: string) {
    this._contentType = value;
  }
  public resetContentType() {
    this._contentType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get contentTypeInput() {
    return this._contentType;
  }

  // custom_url - computed: false, optional: true, required: false
  private _customUrl?: string; 
  public get customUrl() {
    return this.getStringAttribute('custom_url');
  }
  public set customUrl(value: string) {
    this._customUrl = value;
  }
  public resetCustomUrl() {
    this._customUrl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get customUrlInput() {
    return this._customUrl;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // extra_http_headers - computed: false, optional: true, required: false
  private _extraHttpHeaders = new PackDestinationOutputDatadogExtraHttpHeadersList(this, "extra_http_headers", false);
  public get extraHttpHeaders() {
    return this._extraHttpHeaders;
  }
  public putExtraHttpHeaders(value: PackDestinationOutputDatadogExtraHttpHeaders[] | cdktf.IResolvable) {
    this._extraHttpHeaders.internalValue = value;
  }
  public resetExtraHttpHeaders() {
    this._extraHttpHeaders.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get extraHttpHeadersInput() {
    return this._extraHttpHeaders.internalValue;
  }

  // failed_request_logging_mode - computed: true, optional: true, required: false
  private _failedRequestLoggingMode?: string; 
  public get failedRequestLoggingMode() {
    return this.getStringAttribute('failed_request_logging_mode');
  }
  public set failedRequestLoggingMode(value: string) {
    this._failedRequestLoggingMode = value;
  }
  public resetFailedRequestLoggingMode() {
    this._failedRequestLoggingMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get failedRequestLoggingModeInput() {
    return this._failedRequestLoggingMode;
  }

  // flush_period_sec - computed: true, optional: true, required: false
  private _flushPeriodSec?: number; 
  public get flushPeriodSec() {
    return this.getNumberAttribute('flush_period_sec');
  }
  public set flushPeriodSec(value: number) {
    this._flushPeriodSec = value;
  }
  public resetFlushPeriodSec() {
    this._flushPeriodSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get flushPeriodSecInput() {
    return this._flushPeriodSec;
  }

  // host - computed: false, optional: true, required: false
  private _host?: string; 
  public get host() {
    return this.getStringAttribute('host');
  }
  public set host(value: string) {
    this._host = value;
  }
  public resetHost() {
    this._host = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostInput() {
    return this._host;
  }

  // id - computed: false, optional: false, required: true
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // max_payload_events - computed: true, optional: true, required: false
  private _maxPayloadEvents?: number; 
  public get maxPayloadEvents() {
    return this.getNumberAttribute('max_payload_events');
  }
  public set maxPayloadEvents(value: number) {
    this._maxPayloadEvents = value;
  }
  public resetMaxPayloadEvents() {
    this._maxPayloadEvents = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxPayloadEventsInput() {
    return this._maxPayloadEvents;
  }

  // max_payload_size_kb - computed: true, optional: true, required: false
  private _maxPayloadSizeKb?: number; 
  public get maxPayloadSizeKb() {
    return this.getNumberAttribute('max_payload_size_kb');
  }
  public set maxPayloadSizeKb(value: number) {
    this._maxPayloadSizeKb = value;
  }
  public resetMaxPayloadSizeKb() {
    this._maxPayloadSizeKb = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxPayloadSizeKbInput() {
    return this._maxPayloadSizeKb;
  }

  // message - computed: false, optional: true, required: false
  private _message?: string; 
  public get message() {
    return this.getStringAttribute('message');
  }
  public set message(value: string) {
    this._message = value;
  }
  public resetMessage() {
    this._message = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get messageInput() {
    return this._message;
  }

  // on_backpressure - computed: true, optional: true, required: false
  private _onBackpressure?: string; 
  public get onBackpressure() {
    return this.getStringAttribute('on_backpressure');
  }
  public set onBackpressure(value: string) {
    this._onBackpressure = value;
  }
  public resetOnBackpressure() {
    this._onBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get onBackpressureInput() {
    return this._onBackpressure;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // pq_compress - computed: true, optional: true, required: false
  private _pqCompress?: string; 
  public get pqCompress() {
    return this.getStringAttribute('pq_compress');
  }
  public set pqCompress(value: string) {
    this._pqCompress = value;
  }
  public resetPqCompress() {
    this._pqCompress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqCompressInput() {
    return this._pqCompress;
  }

  // pq_controls - computed: false, optional: true, required: false
  private _pqControls = new PackDestinationOutputDatadogPqControlsOutputReference(this, "pq_controls");
  public get pqControls() {
    return this._pqControls;
  }
  public putPqControls(value: PackDestinationOutputDatadogPqControls) {
    this._pqControls.internalValue = value;
  }
  public resetPqControls() {
    this._pqControls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqControlsInput() {
    return this._pqControls.internalValue;
  }

  // pq_max_file_size - computed: true, optional: true, required: false
  private _pqMaxFileSize?: string; 
  public get pqMaxFileSize() {
    return this.getStringAttribute('pq_max_file_size');
  }
  public set pqMaxFileSize(value: string) {
    this._pqMaxFileSize = value;
  }
  public resetPqMaxFileSize() {
    this._pqMaxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxFileSizeInput() {
    return this._pqMaxFileSize;
  }

  // pq_max_size - computed: true, optional: true, required: false
  private _pqMaxSize?: string; 
  public get pqMaxSize() {
    return this.getStringAttribute('pq_max_size');
  }
  public set pqMaxSize(value: string) {
    this._pqMaxSize = value;
  }
  public resetPqMaxSize() {
    this._pqMaxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxSizeInput() {
    return this._pqMaxSize;
  }

  // pq_mode - computed: true, optional: true, required: false
  private _pqMode?: string; 
  public get pqMode() {
    return this.getStringAttribute('pq_mode');
  }
  public set pqMode(value: string) {
    this._pqMode = value;
  }
  public resetPqMode() {
    this._pqMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqModeInput() {
    return this._pqMode;
  }

  // pq_on_backpressure - computed: true, optional: true, required: false
  private _pqOnBackpressure?: string; 
  public get pqOnBackpressure() {
    return this.getStringAttribute('pq_on_backpressure');
  }
  public set pqOnBackpressure(value: string) {
    this._pqOnBackpressure = value;
  }
  public resetPqOnBackpressure() {
    this._pqOnBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqOnBackpressureInput() {
    return this._pqOnBackpressure;
  }

  // pq_path - computed: true, optional: true, required: false
  private _pqPath?: string; 
  public get pqPath() {
    return this.getStringAttribute('pq_path');
  }
  public set pqPath(value: string) {
    this._pqPath = value;
  }
  public resetPqPath() {
    this._pqPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqPathInput() {
    return this._pqPath;
  }

  // reject_unauthorized - computed: true, optional: true, required: false
  private _rejectUnauthorized?: boolean | cdktf.IResolvable; 
  public get rejectUnauthorized() {
    return this.getBooleanAttribute('reject_unauthorized');
  }
  public set rejectUnauthorized(value: boolean | cdktf.IResolvable) {
    this._rejectUnauthorized = value;
  }
  public resetRejectUnauthorized() {
    this._rejectUnauthorized = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectUnauthorizedInput() {
    return this._rejectUnauthorized;
  }

  // response_honor_retry_after_header - computed: true, optional: true, required: false
  private _responseHonorRetryAfterHeader?: boolean | cdktf.IResolvable; 
  public get responseHonorRetryAfterHeader() {
    return this.getBooleanAttribute('response_honor_retry_after_header');
  }
  public set responseHonorRetryAfterHeader(value: boolean | cdktf.IResolvable) {
    this._responseHonorRetryAfterHeader = value;
  }
  public resetResponseHonorRetryAfterHeader() {
    this._responseHonorRetryAfterHeader = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get responseHonorRetryAfterHeaderInput() {
    return this._responseHonorRetryAfterHeader;
  }

  // response_retry_settings - computed: false, optional: true, required: false
  private _responseRetrySettings = new PackDestinationOutputDatadogResponseRetrySettingsList(this, "response_retry_settings", false);
  public get responseRetrySettings() {
    return this._responseRetrySettings;
  }
  public putResponseRetrySettings(value: PackDestinationOutputDatadogResponseRetrySettings[] | cdktf.IResolvable) {
    this._responseRetrySettings.internalValue = value;
  }
  public resetResponseRetrySettings() {
    this._responseRetrySettings.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get responseRetrySettingsInput() {
    return this._responseRetrySettings.internalValue;
  }

  // safe_headers - computed: true, optional: true, required: false
  private _safeHeaders?: string[]; 
  public get safeHeaders() {
    return this.getListAttribute('safe_headers');
  }
  public set safeHeaders(value: string[]) {
    this._safeHeaders = value;
  }
  public resetSafeHeaders() {
    this._safeHeaders = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get safeHeadersInput() {
    return this._safeHeaders;
  }

  // send_counters_as_count - computed: true, optional: true, required: false
  private _sendCountersAsCount?: boolean | cdktf.IResolvable; 
  public get sendCountersAsCount() {
    return this.getBooleanAttribute('send_counters_as_count');
  }
  public set sendCountersAsCount(value: boolean | cdktf.IResolvable) {
    this._sendCountersAsCount = value;
  }
  public resetSendCountersAsCount() {
    this._sendCountersAsCount = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sendCountersAsCountInput() {
    return this._sendCountersAsCount;
  }

  // service - computed: false, optional: true, required: false
  private _service?: string; 
  public get service() {
    return this.getStringAttribute('service');
  }
  public set service(value: string) {
    this._service = value;
  }
  public resetService() {
    this._service = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serviceInput() {
    return this._service;
  }

  // severity - computed: false, optional: true, required: false
  private _severity?: string; 
  public get severity() {
    return this.getStringAttribute('severity');
  }
  public set severity(value: string) {
    this._severity = value;
  }
  public resetSeverity() {
    this._severity = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get severityInput() {
    return this._severity;
  }

  // site - computed: true, optional: true, required: false
  private _site?: string; 
  public get site() {
    return this.getStringAttribute('site');
  }
  public set site(value: string) {
    this._site = value;
  }
  public resetSite() {
    this._site = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get siteInput() {
    return this._site;
  }

  // source - computed: false, optional: true, required: false
  private _source?: string; 
  public get source() {
    return this.getStringAttribute('source');
  }
  public set source(value: string) {
    this._source = value;
  }
  public resetSource() {
    this._source = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sourceInput() {
    return this._source;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // system_fields - computed: true, optional: true, required: false
  private _systemFields?: string[]; 
  public get systemFields() {
    return this.getListAttribute('system_fields');
  }
  public set systemFields(value: string[]) {
    this._systemFields = value;
  }
  public resetSystemFields() {
    this._systemFields = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get systemFieldsInput() {
    return this._systemFields;
  }

  // tags - computed: true, optional: true, required: false
  private _tags?: string[]; 
  public get tags() {
    return this.getListAttribute('tags');
  }
  public set tags(value: string[]) {
    this._tags = value;
  }
  public resetTags() {
    this._tags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagsInput() {
    return this._tags;
  }

  // text_secret - computed: false, optional: true, required: false
  private _textSecret?: string; 
  public get textSecret() {
    return this.getStringAttribute('text_secret');
  }
  public set textSecret(value: string) {
    this._textSecret = value;
  }
  public resetTextSecret() {
    this._textSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get textSecretInput() {
    return this._textSecret;
  }

  // timeout_retry_settings - computed: false, optional: true, required: false
  private _timeoutRetrySettings = new PackDestinationOutputDatadogTimeoutRetrySettingsOutputReference(this, "timeout_retry_settings");
  public get timeoutRetrySettings() {
    return this._timeoutRetrySettings;
  }
  public putTimeoutRetrySettings(value: PackDestinationOutputDatadogTimeoutRetrySettings) {
    this._timeoutRetrySettings.internalValue = value;
  }
  public resetTimeoutRetrySettings() {
    this._timeoutRetrySettings.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutRetrySettingsInput() {
    return this._timeoutRetrySettings.internalValue;
  }

  // timeout_sec - computed: true, optional: true, required: false
  private _timeoutSec?: number; 
  public get timeoutSec() {
    return this.getNumberAttribute('timeout_sec');
  }
  public set timeoutSec(value: number) {
    this._timeoutSec = value;
  }
  public resetTimeoutSec() {
    this._timeoutSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutSecInput() {
    return this._timeoutSec;
  }

  // total_memory_limit_kb - computed: false, optional: true, required: false
  private _totalMemoryLimitKb?: number; 
  public get totalMemoryLimitKb() {
    return this.getNumberAttribute('total_memory_limit_kb');
  }
  public set totalMemoryLimitKb(value: number) {
    this._totalMemoryLimitKb = value;
  }
  public resetTotalMemoryLimitKb() {
    this._totalMemoryLimitKb = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get totalMemoryLimitKbInput() {
    return this._totalMemoryLimitKb;
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // use_round_robin_dns - computed: true, optional: true, required: false
  private _useRoundRobinDns?: boolean | cdktf.IResolvable; 
  public get useRoundRobinDns() {
    return this.getBooleanAttribute('use_round_robin_dns');
  }
  public set useRoundRobinDns(value: boolean | cdktf.IResolvable) {
    this._useRoundRobinDns = value;
  }
  public resetUseRoundRobinDns() {
    this._useRoundRobinDns = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get useRoundRobinDnsInput() {
    return this._useRoundRobinDns;
  }
}
export interface PackDestinationOutputDatasetExtraHttpHeaders {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#name PackDestination#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#value PackDestination#value}
  */
  readonly value: string;
}

export function packDestinationOutputDatasetExtraHttpHeadersToTerraform(struct?: PackDestinationOutputDatasetExtraHttpHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function packDestinationOutputDatasetExtraHttpHeadersToHclTerraform(struct?: PackDestinationOutputDatasetExtraHttpHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputDatasetExtraHttpHeadersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackDestinationOutputDatasetExtraHttpHeaders | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputDatasetExtraHttpHeaders | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class PackDestinationOutputDatasetExtraHttpHeadersList extends cdktf.ComplexList {
  public internalValue? : PackDestinationOutputDatasetExtraHttpHeaders[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackDestinationOutputDatasetExtraHttpHeadersOutputReference {
    return new PackDestinationOutputDatasetExtraHttpHeadersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackDestinationOutputDatasetPqControls {
}

export function packDestinationOutputDatasetPqControlsToTerraform(struct?: PackDestinationOutputDatasetPqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function packDestinationOutputDatasetPqControlsToHclTerraform(struct?: PackDestinationOutputDatasetPqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class PackDestinationOutputDatasetPqControlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackDestinationOutputDatasetPqControls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputDatasetPqControls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface PackDestinationOutputDatasetResponseRetrySettings {
  /**
  * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc. Default: 2
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#backoff_rate PackDestination#backoff_rate}
  */
  readonly backoffRate?: number;
  /**
  * The HTTP response status code that will trigger retries
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#http_status PackDestination#http_status}
  */
  readonly httpStatus: number;
  /**
  * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes). Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#initial_backoff PackDestination#initial_backoff}
  */
  readonly initialBackoff?: number;
  /**
  * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds). Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_backoff PackDestination#max_backoff}
  */
  readonly maxBackoff?: number;
}

export function packDestinationOutputDatasetResponseRetrySettingsToTerraform(struct?: PackDestinationOutputDatasetResponseRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    backoff_rate: cdktf.numberToTerraform(struct!.backoffRate),
    http_status: cdktf.numberToTerraform(struct!.httpStatus),
    initial_backoff: cdktf.numberToTerraform(struct!.initialBackoff),
    max_backoff: cdktf.numberToTerraform(struct!.maxBackoff),
  }
}


export function packDestinationOutputDatasetResponseRetrySettingsToHclTerraform(struct?: PackDestinationOutputDatasetResponseRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    backoff_rate: {
      value: cdktf.numberToHclTerraform(struct!.backoffRate),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    http_status: {
      value: cdktf.numberToHclTerraform(struct!.httpStatus),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    initial_backoff: {
      value: cdktf.numberToHclTerraform(struct!.initialBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_backoff: {
      value: cdktf.numberToHclTerraform(struct!.maxBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputDatasetResponseRetrySettingsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackDestinationOutputDatasetResponseRetrySettings | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._backoffRate !== undefined) {
      hasAnyValues = true;
      internalValueResult.backoffRate = this._backoffRate;
    }
    if (this._httpStatus !== undefined) {
      hasAnyValues = true;
      internalValueResult.httpStatus = this._httpStatus;
    }
    if (this._initialBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.initialBackoff = this._initialBackoff;
    }
    if (this._maxBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBackoff = this._maxBackoff;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputDatasetResponseRetrySettings | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._backoffRate = undefined;
      this._httpStatus = undefined;
      this._initialBackoff = undefined;
      this._maxBackoff = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._backoffRate = value.backoffRate;
      this._httpStatus = value.httpStatus;
      this._initialBackoff = value.initialBackoff;
      this._maxBackoff = value.maxBackoff;
    }
  }

  // backoff_rate - computed: true, optional: true, required: false
  private _backoffRate?: number; 
  public get backoffRate() {
    return this.getNumberAttribute('backoff_rate');
  }
  public set backoffRate(value: number) {
    this._backoffRate = value;
  }
  public resetBackoffRate() {
    this._backoffRate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get backoffRateInput() {
    return this._backoffRate;
  }

  // http_status - computed: false, optional: false, required: true
  private _httpStatus?: number; 
  public get httpStatus() {
    return this.getNumberAttribute('http_status');
  }
  public set httpStatus(value: number) {
    this._httpStatus = value;
  }
  // Temporarily expose input value. Use with caution.
  public get httpStatusInput() {
    return this._httpStatus;
  }

  // initial_backoff - computed: true, optional: true, required: false
  private _initialBackoff?: number; 
  public get initialBackoff() {
    return this.getNumberAttribute('initial_backoff');
  }
  public set initialBackoff(value: number) {
    this._initialBackoff = value;
  }
  public resetInitialBackoff() {
    this._initialBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get initialBackoffInput() {
    return this._initialBackoff;
  }

  // max_backoff - computed: true, optional: true, required: false
  private _maxBackoff?: number; 
  public get maxBackoff() {
    return this.getNumberAttribute('max_backoff');
  }
  public set maxBackoff(value: number) {
    this._maxBackoff = value;
  }
  public resetMaxBackoff() {
    this._maxBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBackoffInput() {
    return this._maxBackoff;
  }
}

export class PackDestinationOutputDatasetResponseRetrySettingsList extends cdktf.ComplexList {
  public internalValue? : PackDestinationOutputDatasetResponseRetrySettings[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackDestinationOutputDatasetResponseRetrySettingsOutputReference {
    return new PackDestinationOutputDatasetResponseRetrySettingsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackDestinationOutputDatasetTimeoutRetrySettings {
  /**
  * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc. Default: 2
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#backoff_rate PackDestination#backoff_rate}
  */
  readonly backoffRate?: number;
  /**
  * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes). Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#initial_backoff PackDestination#initial_backoff}
  */
  readonly initialBackoff?: number;
  /**
  * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds). Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_backoff PackDestination#max_backoff}
  */
  readonly maxBackoff?: number;
  /**
  * Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#timeout_retry PackDestination#timeout_retry}
  */
  readonly timeoutRetry?: boolean | cdktf.IResolvable;
}

export function packDestinationOutputDatasetTimeoutRetrySettingsToTerraform(struct?: PackDestinationOutputDatasetTimeoutRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    backoff_rate: cdktf.numberToTerraform(struct!.backoffRate),
    initial_backoff: cdktf.numberToTerraform(struct!.initialBackoff),
    max_backoff: cdktf.numberToTerraform(struct!.maxBackoff),
    timeout_retry: cdktf.booleanToTerraform(struct!.timeoutRetry),
  }
}


export function packDestinationOutputDatasetTimeoutRetrySettingsToHclTerraform(struct?: PackDestinationOutputDatasetTimeoutRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    backoff_rate: {
      value: cdktf.numberToHclTerraform(struct!.backoffRate),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    initial_backoff: {
      value: cdktf.numberToHclTerraform(struct!.initialBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_backoff: {
      value: cdktf.numberToHclTerraform(struct!.maxBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    timeout_retry: {
      value: cdktf.booleanToHclTerraform(struct!.timeoutRetry),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputDatasetTimeoutRetrySettingsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackDestinationOutputDatasetTimeoutRetrySettings | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._backoffRate !== undefined) {
      hasAnyValues = true;
      internalValueResult.backoffRate = this._backoffRate;
    }
    if (this._initialBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.initialBackoff = this._initialBackoff;
    }
    if (this._maxBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBackoff = this._maxBackoff;
    }
    if (this._timeoutRetry !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutRetry = this._timeoutRetry;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputDatasetTimeoutRetrySettings | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._backoffRate = undefined;
      this._initialBackoff = undefined;
      this._maxBackoff = undefined;
      this._timeoutRetry = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._backoffRate = value.backoffRate;
      this._initialBackoff = value.initialBackoff;
      this._maxBackoff = value.maxBackoff;
      this._timeoutRetry = value.timeoutRetry;
    }
  }

  // backoff_rate - computed: true, optional: true, required: false
  private _backoffRate?: number; 
  public get backoffRate() {
    return this.getNumberAttribute('backoff_rate');
  }
  public set backoffRate(value: number) {
    this._backoffRate = value;
  }
  public resetBackoffRate() {
    this._backoffRate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get backoffRateInput() {
    return this._backoffRate;
  }

  // initial_backoff - computed: true, optional: true, required: false
  private _initialBackoff?: number; 
  public get initialBackoff() {
    return this.getNumberAttribute('initial_backoff');
  }
  public set initialBackoff(value: number) {
    this._initialBackoff = value;
  }
  public resetInitialBackoff() {
    this._initialBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get initialBackoffInput() {
    return this._initialBackoff;
  }

  // max_backoff - computed: true, optional: true, required: false
  private _maxBackoff?: number; 
  public get maxBackoff() {
    return this.getNumberAttribute('max_backoff');
  }
  public set maxBackoff(value: number) {
    this._maxBackoff = value;
  }
  public resetMaxBackoff() {
    this._maxBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBackoffInput() {
    return this._maxBackoff;
  }

  // timeout_retry - computed: true, optional: true, required: false
  private _timeoutRetry?: boolean | cdktf.IResolvable; 
  public get timeoutRetry() {
    return this.getBooleanAttribute('timeout_retry');
  }
  public set timeoutRetry(value: boolean | cdktf.IResolvable) {
    this._timeoutRetry = value;
  }
  public resetTimeoutRetry() {
    this._timeoutRetry = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutRetryInput() {
    return this._timeoutRetry;
  }
}
export interface PackDestinationOutputDataset {
  /**
  * A 'Log Write Access' API key for the DataSet account
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#api_key PackDestination#api_key}
  */
  readonly apiKey?: string;
  /**
  * Enter API key directly, or select a stored secret. Default: "manual"; must be one of ["manual", "secret"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#auth_type PackDestination#auth_type}
  */
  readonly authType?: string;
  /**
  * Compress the payload body before sending. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#compress PackDestination#compress}
  */
  readonly compress?: boolean | cdktf.IResolvable;
  /**
  * Maximum number of ongoing requests before blocking. Default: 5
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#concurrency PackDestination#concurrency}
  */
  readonly concurrency?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#custom_url PackDestination#custom_url}
  */
  readonly customUrl?: string;
  /**
  * Default value for event severity. If the `sev` or `__severity` fields are set on an event, the first one matching will override this value. Default: "info"; must be one of ["finest", "finer", "fine", "info", "warning", "error", "fatal"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#default_severity PackDestination#default_severity}
  */
  readonly defaultSeverity?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#description PackDestination#description}
  */
  readonly description?: string;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#environment PackDestination#environment}
  */
  readonly environment?: string;
  /**
  * Fields to exclude from the event if the Message field is either unspecified or refers to an object. Ignored if the Message field is a string. If empty, we send all non-internal fields. Default: ["sev","_time","ts","thread"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#exclude_fields PackDestination#exclude_fields}
  */
  readonly excludeFields?: string[];
  /**
  * Headers to add to all events
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#extra_http_headers PackDestination#extra_http_headers}
  */
  readonly extraHttpHeaders?: PackDestinationOutputDatasetExtraHttpHeaders[] | cdktf.IResolvable;
  /**
  * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below. Default: "none"; must be one of ["payload", "payloadAndHeaders", "none"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#failed_request_logging_mode PackDestination#failed_request_logging_mode}
  */
  readonly failedRequestLoggingMode?: string;
  /**
  * Maximum time between requests. Small values could cause the payload size to be smaller than the configured Body size limit. Default: 1
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#flush_period_sec PackDestination#flush_period_sec}
  */
  readonly flushPeriodSec?: number;
  /**
  * Unique ID for this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#id PackDestination#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id: string;
  /**
  * Maximum number of events to include in the request body. Default is 0 (unlimited). Default: 0
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_payload_events PackDestination#max_payload_events}
  */
  readonly maxPayloadEvents?: number;
  /**
  * Maximum size, in KB, of the request body. Default: 4096
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_payload_size_kb PackDestination#max_payload_size_kb}
  */
  readonly maxPayloadSizeKb?: number;
  /**
  * Name of the event field that contains the message or attributes to send. If not specified, all of the event's non-internal fields will be sent as attributes.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#message_field PackDestination#message_field}
  */
  readonly messageField?: string;
  /**
  * How to handle events when all receivers are exerting backpressure. Default: "block"; must be one of ["block", "drop", "queue"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#on_backpressure PackDestination#on_backpressure}
  */
  readonly onBackpressure?: string;
  /**
  * Pipeline to process data before sending out to this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pipeline PackDestination#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_compress PackDestination#pq_compress}
  */
  readonly pqCompress?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_controls PackDestination#pq_controls}
  */
  readonly pqControls?: PackDestinationOutputDatasetPqControls;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.). Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_max_file_size PackDestination#pq_max_file_size}
  */
  readonly pqMaxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_max_size PackDestination#pq_max_size}
  */
  readonly pqMaxSize?: string;
  /**
  * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem. Default: "error"; must be one of ["error", "backpressure", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_mode PackDestination#pq_mode}
  */
  readonly pqMode?: string;
  /**
  * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged. Default: "block"; must be one of ["block", "drop"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_on_backpressure PackDestination#pq_on_backpressure}
  */
  readonly pqOnBackpressure?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_path PackDestination#pq_path}
  */
  readonly pqPath?: string;
  /**
  * Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's). 
  *         Enabled by default. When this setting is also present in TLS Settings (Client Side), 
  *         that value will take precedence.
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#reject_unauthorized PackDestination#reject_unauthorized}
  */
  readonly rejectUnauthorized?: boolean | cdktf.IResolvable;
  /**
  * Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#response_honor_retry_after_header PackDestination#response_honor_retry_after_header}
  */
  readonly responseHonorRetryAfterHeader?: boolean | cdktf.IResolvable;
  /**
  * Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#response_retry_settings PackDestination#response_retry_settings}
  */
  readonly responseRetrySettings?: PackDestinationOutputDatasetResponseRetrySettings[] | cdktf.IResolvable;
  /**
  * List of headers that are safe to log in plain text. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#safe_headers PackDestination#safe_headers}
  */
  readonly safeHeaders?: string[];
  /**
  * Name of the event field that contains the `serverHost` identifier. If not specified, defaults to `cribl_<outputId>`.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#server_host_field PackDestination#server_host_field}
  */
  readonly serverHostField?: string;
  /**
  * DataSet site to which events should be sent. Default: "us"; must be one of ["us", "eu", "custom"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#site PackDestination#site}
  */
  readonly site?: string;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#streamtags PackDestination#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Fields to automatically add to events, such as cribl_pipe. Supports wildcards. Default: ["cribl_pipe"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#system_fields PackDestination#system_fields}
  */
  readonly systemFields?: string[];
  /**
  * Select or create a stored text secret
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#text_secret PackDestination#text_secret}
  */
  readonly textSecret?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#timeout_retry_settings PackDestination#timeout_retry_settings}
  */
  readonly timeoutRetrySettings?: PackDestinationOutputDatasetTimeoutRetrySettings;
  /**
  * Amount of time, in seconds, to wait for a request to complete before canceling it. Default: 30
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#timeout_sec PackDestination#timeout_sec}
  */
  readonly timeoutSec?: number;
  /**
  * Name of the event field that contains the timestamp. If not specified, defaults to `ts`, `_time`, or `Date.now()`, in that order.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#timestamp_field PackDestination#timestamp_field}
  */
  readonly timestampField?: string;
  /**
  * Maximum total size of the batches waiting to be sent. If left blank, defaults to 5 times the max body size (if set). If 0, no limit is enforced.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#total_memory_limit_kb PackDestination#total_memory_limit_kb}
  */
  readonly totalMemoryLimitKb?: number;
  /**
  * must be "dataset"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#type PackDestination#type}
  */
  readonly type: string;
  /**
  * Enable round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. For optimal performance, consider enabling this setting for non-load balanced destinations. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#use_round_robin_dns PackDestination#use_round_robin_dns}
  */
  readonly useRoundRobinDns?: boolean | cdktf.IResolvable;
}

export function packDestinationOutputDatasetToTerraform(struct?: PackDestinationOutputDataset | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    api_key: cdktf.stringToTerraform(struct!.apiKey),
    auth_type: cdktf.stringToTerraform(struct!.authType),
    compress: cdktf.booleanToTerraform(struct!.compress),
    concurrency: cdktf.numberToTerraform(struct!.concurrency),
    custom_url: cdktf.stringToTerraform(struct!.customUrl),
    default_severity: cdktf.stringToTerraform(struct!.defaultSeverity),
    description: cdktf.stringToTerraform(struct!.description),
    environment: cdktf.stringToTerraform(struct!.environment),
    exclude_fields: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.excludeFields),
    extra_http_headers: cdktf.listMapper(packDestinationOutputDatasetExtraHttpHeadersToTerraform, false)(struct!.extraHttpHeaders),
    failed_request_logging_mode: cdktf.stringToTerraform(struct!.failedRequestLoggingMode),
    flush_period_sec: cdktf.numberToTerraform(struct!.flushPeriodSec),
    id: cdktf.stringToTerraform(struct!.id),
    max_payload_events: cdktf.numberToTerraform(struct!.maxPayloadEvents),
    max_payload_size_kb: cdktf.numberToTerraform(struct!.maxPayloadSizeKb),
    message_field: cdktf.stringToTerraform(struct!.messageField),
    on_backpressure: cdktf.stringToTerraform(struct!.onBackpressure),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    pq_compress: cdktf.stringToTerraform(struct!.pqCompress),
    pq_controls: packDestinationOutputDatasetPqControlsToTerraform(struct!.pqControls),
    pq_max_file_size: cdktf.stringToTerraform(struct!.pqMaxFileSize),
    pq_max_size: cdktf.stringToTerraform(struct!.pqMaxSize),
    pq_mode: cdktf.stringToTerraform(struct!.pqMode),
    pq_on_backpressure: cdktf.stringToTerraform(struct!.pqOnBackpressure),
    pq_path: cdktf.stringToTerraform(struct!.pqPath),
    reject_unauthorized: cdktf.booleanToTerraform(struct!.rejectUnauthorized),
    response_honor_retry_after_header: cdktf.booleanToTerraform(struct!.responseHonorRetryAfterHeader),
    response_retry_settings: cdktf.listMapper(packDestinationOutputDatasetResponseRetrySettingsToTerraform, false)(struct!.responseRetrySettings),
    safe_headers: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.safeHeaders),
    server_host_field: cdktf.stringToTerraform(struct!.serverHostField),
    site: cdktf.stringToTerraform(struct!.site),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    system_fields: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.systemFields),
    text_secret: cdktf.stringToTerraform(struct!.textSecret),
    timeout_retry_settings: packDestinationOutputDatasetTimeoutRetrySettingsToTerraform(struct!.timeoutRetrySettings),
    timeout_sec: cdktf.numberToTerraform(struct!.timeoutSec),
    timestamp_field: cdktf.stringToTerraform(struct!.timestampField),
    total_memory_limit_kb: cdktf.numberToTerraform(struct!.totalMemoryLimitKb),
    type: cdktf.stringToTerraform(struct!.type),
    use_round_robin_dns: cdktf.booleanToTerraform(struct!.useRoundRobinDns),
  }
}


export function packDestinationOutputDatasetToHclTerraform(struct?: PackDestinationOutputDataset | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    api_key: {
      value: cdktf.stringToHclTerraform(struct!.apiKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    auth_type: {
      value: cdktf.stringToHclTerraform(struct!.authType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    compress: {
      value: cdktf.booleanToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    concurrency: {
      value: cdktf.numberToHclTerraform(struct!.concurrency),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    custom_url: {
      value: cdktf.stringToHclTerraform(struct!.customUrl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    default_severity: {
      value: cdktf.stringToHclTerraform(struct!.defaultSeverity),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    exclude_fields: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.excludeFields),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    extra_http_headers: {
      value: cdktf.listMapperHcl(packDestinationOutputDatasetExtraHttpHeadersToHclTerraform, false)(struct!.extraHttpHeaders),
      isBlock: true,
      type: "list",
      storageClassType: "PackDestinationOutputDatasetExtraHttpHeadersList",
    },
    failed_request_logging_mode: {
      value: cdktf.stringToHclTerraform(struct!.failedRequestLoggingMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    flush_period_sec: {
      value: cdktf.numberToHclTerraform(struct!.flushPeriodSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_payload_events: {
      value: cdktf.numberToHclTerraform(struct!.maxPayloadEvents),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_payload_size_kb: {
      value: cdktf.numberToHclTerraform(struct!.maxPayloadSizeKb),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    message_field: {
      value: cdktf.stringToHclTerraform(struct!.messageField),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.onBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_compress: {
      value: cdktf.stringToHclTerraform(struct!.pqCompress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_controls: {
      value: packDestinationOutputDatasetPqControlsToHclTerraform(struct!.pqControls),
      isBlock: true,
      type: "struct",
      storageClassType: "PackDestinationOutputDatasetPqControls",
    },
    pq_max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_max_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_mode: {
      value: cdktf.stringToHclTerraform(struct!.pqMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.pqOnBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_path: {
      value: cdktf.stringToHclTerraform(struct!.pqPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reject_unauthorized: {
      value: cdktf.booleanToHclTerraform(struct!.rejectUnauthorized),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    response_honor_retry_after_header: {
      value: cdktf.booleanToHclTerraform(struct!.responseHonorRetryAfterHeader),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    response_retry_settings: {
      value: cdktf.listMapperHcl(packDestinationOutputDatasetResponseRetrySettingsToHclTerraform, false)(struct!.responseRetrySettings),
      isBlock: true,
      type: "list",
      storageClassType: "PackDestinationOutputDatasetResponseRetrySettingsList",
    },
    safe_headers: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.safeHeaders),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    server_host_field: {
      value: cdktf.stringToHclTerraform(struct!.serverHostField),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    site: {
      value: cdktf.stringToHclTerraform(struct!.site),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    system_fields: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.systemFields),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    text_secret: {
      value: cdktf.stringToHclTerraform(struct!.textSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    timeout_retry_settings: {
      value: packDestinationOutputDatasetTimeoutRetrySettingsToHclTerraform(struct!.timeoutRetrySettings),
      isBlock: true,
      type: "struct",
      storageClassType: "PackDestinationOutputDatasetTimeoutRetrySettings",
    },
    timeout_sec: {
      value: cdktf.numberToHclTerraform(struct!.timeoutSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    timestamp_field: {
      value: cdktf.stringToHclTerraform(struct!.timestampField),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    total_memory_limit_kb: {
      value: cdktf.numberToHclTerraform(struct!.totalMemoryLimitKb),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    use_round_robin_dns: {
      value: cdktf.booleanToHclTerraform(struct!.useRoundRobinDns),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputDatasetOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackDestinationOutputDataset | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._apiKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.apiKey = this._apiKey;
    }
    if (this._authType !== undefined) {
      hasAnyValues = true;
      internalValueResult.authType = this._authType;
    }
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._concurrency !== undefined) {
      hasAnyValues = true;
      internalValueResult.concurrency = this._concurrency;
    }
    if (this._customUrl !== undefined) {
      hasAnyValues = true;
      internalValueResult.customUrl = this._customUrl;
    }
    if (this._defaultSeverity !== undefined) {
      hasAnyValues = true;
      internalValueResult.defaultSeverity = this._defaultSeverity;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._excludeFields !== undefined) {
      hasAnyValues = true;
      internalValueResult.excludeFields = this._excludeFields;
    }
    if (this._extraHttpHeaders?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.extraHttpHeaders = this._extraHttpHeaders?.internalValue;
    }
    if (this._failedRequestLoggingMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.failedRequestLoggingMode = this._failedRequestLoggingMode;
    }
    if (this._flushPeriodSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.flushPeriodSec = this._flushPeriodSec;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._maxPayloadEvents !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxPayloadEvents = this._maxPayloadEvents;
    }
    if (this._maxPayloadSizeKb !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxPayloadSizeKb = this._maxPayloadSizeKb;
    }
    if (this._messageField !== undefined) {
      hasAnyValues = true;
      internalValueResult.messageField = this._messageField;
    }
    if (this._onBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.onBackpressure = this._onBackpressure;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._pqCompress !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqCompress = this._pqCompress;
    }
    if (this._pqControls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqControls = this._pqControls?.internalValue;
    }
    if (this._pqMaxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxFileSize = this._pqMaxFileSize;
    }
    if (this._pqMaxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxSize = this._pqMaxSize;
    }
    if (this._pqMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMode = this._pqMode;
    }
    if (this._pqOnBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqOnBackpressure = this._pqOnBackpressure;
    }
    if (this._pqPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqPath = this._pqPath;
    }
    if (this._rejectUnauthorized !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectUnauthorized = this._rejectUnauthorized;
    }
    if (this._responseHonorRetryAfterHeader !== undefined) {
      hasAnyValues = true;
      internalValueResult.responseHonorRetryAfterHeader = this._responseHonorRetryAfterHeader;
    }
    if (this._responseRetrySettings?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.responseRetrySettings = this._responseRetrySettings?.internalValue;
    }
    if (this._safeHeaders !== undefined) {
      hasAnyValues = true;
      internalValueResult.safeHeaders = this._safeHeaders;
    }
    if (this._serverHostField !== undefined) {
      hasAnyValues = true;
      internalValueResult.serverHostField = this._serverHostField;
    }
    if (this._site !== undefined) {
      hasAnyValues = true;
      internalValueResult.site = this._site;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._systemFields !== undefined) {
      hasAnyValues = true;
      internalValueResult.systemFields = this._systemFields;
    }
    if (this._textSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.textSecret = this._textSecret;
    }
    if (this._timeoutRetrySettings?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutRetrySettings = this._timeoutRetrySettings?.internalValue;
    }
    if (this._timeoutSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutSec = this._timeoutSec;
    }
    if (this._timestampField !== undefined) {
      hasAnyValues = true;
      internalValueResult.timestampField = this._timestampField;
    }
    if (this._totalMemoryLimitKb !== undefined) {
      hasAnyValues = true;
      internalValueResult.totalMemoryLimitKb = this._totalMemoryLimitKb;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._useRoundRobinDns !== undefined) {
      hasAnyValues = true;
      internalValueResult.useRoundRobinDns = this._useRoundRobinDns;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputDataset | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._apiKey = undefined;
      this._authType = undefined;
      this._compress = undefined;
      this._concurrency = undefined;
      this._customUrl = undefined;
      this._defaultSeverity = undefined;
      this._description = undefined;
      this._environment = undefined;
      this._excludeFields = undefined;
      this._extraHttpHeaders.internalValue = undefined;
      this._failedRequestLoggingMode = undefined;
      this._flushPeriodSec = undefined;
      this._id = undefined;
      this._maxPayloadEvents = undefined;
      this._maxPayloadSizeKb = undefined;
      this._messageField = undefined;
      this._onBackpressure = undefined;
      this._pipeline = undefined;
      this._pqCompress = undefined;
      this._pqControls.internalValue = undefined;
      this._pqMaxFileSize = undefined;
      this._pqMaxSize = undefined;
      this._pqMode = undefined;
      this._pqOnBackpressure = undefined;
      this._pqPath = undefined;
      this._rejectUnauthorized = undefined;
      this._responseHonorRetryAfterHeader = undefined;
      this._responseRetrySettings.internalValue = undefined;
      this._safeHeaders = undefined;
      this._serverHostField = undefined;
      this._site = undefined;
      this._streamtags = undefined;
      this._systemFields = undefined;
      this._textSecret = undefined;
      this._timeoutRetrySettings.internalValue = undefined;
      this._timeoutSec = undefined;
      this._timestampField = undefined;
      this._totalMemoryLimitKb = undefined;
      this._type = undefined;
      this._useRoundRobinDns = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._apiKey = value.apiKey;
      this._authType = value.authType;
      this._compress = value.compress;
      this._concurrency = value.concurrency;
      this._customUrl = value.customUrl;
      this._defaultSeverity = value.defaultSeverity;
      this._description = value.description;
      this._environment = value.environment;
      this._excludeFields = value.excludeFields;
      this._extraHttpHeaders.internalValue = value.extraHttpHeaders;
      this._failedRequestLoggingMode = value.failedRequestLoggingMode;
      this._flushPeriodSec = value.flushPeriodSec;
      this._id = value.id;
      this._maxPayloadEvents = value.maxPayloadEvents;
      this._maxPayloadSizeKb = value.maxPayloadSizeKb;
      this._messageField = value.messageField;
      this._onBackpressure = value.onBackpressure;
      this._pipeline = value.pipeline;
      this._pqCompress = value.pqCompress;
      this._pqControls.internalValue = value.pqControls;
      this._pqMaxFileSize = value.pqMaxFileSize;
      this._pqMaxSize = value.pqMaxSize;
      this._pqMode = value.pqMode;
      this._pqOnBackpressure = value.pqOnBackpressure;
      this._pqPath = value.pqPath;
      this._rejectUnauthorized = value.rejectUnauthorized;
      this._responseHonorRetryAfterHeader = value.responseHonorRetryAfterHeader;
      this._responseRetrySettings.internalValue = value.responseRetrySettings;
      this._safeHeaders = value.safeHeaders;
      this._serverHostField = value.serverHostField;
      this._site = value.site;
      this._streamtags = value.streamtags;
      this._systemFields = value.systemFields;
      this._textSecret = value.textSecret;
      this._timeoutRetrySettings.internalValue = value.timeoutRetrySettings;
      this._timeoutSec = value.timeoutSec;
      this._timestampField = value.timestampField;
      this._totalMemoryLimitKb = value.totalMemoryLimitKb;
      this._type = value.type;
      this._useRoundRobinDns = value.useRoundRobinDns;
    }
  }

  // api_key - computed: false, optional: true, required: false
  private _apiKey?: string; 
  public get apiKey() {
    return this.getStringAttribute('api_key');
  }
  public set apiKey(value: string) {
    this._apiKey = value;
  }
  public resetApiKey() {
    this._apiKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get apiKeyInput() {
    return this._apiKey;
  }

  // auth_type - computed: true, optional: true, required: false
  private _authType?: string; 
  public get authType() {
    return this.getStringAttribute('auth_type');
  }
  public set authType(value: string) {
    this._authType = value;
  }
  public resetAuthType() {
    this._authType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authTypeInput() {
    return this._authType;
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: boolean | cdktf.IResolvable; 
  public get compress() {
    return this.getBooleanAttribute('compress');
  }
  public set compress(value: boolean | cdktf.IResolvable) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // concurrency - computed: true, optional: true, required: false
  private _concurrency?: number; 
  public get concurrency() {
    return this.getNumberAttribute('concurrency');
  }
  public set concurrency(value: number) {
    this._concurrency = value;
  }
  public resetConcurrency() {
    this._concurrency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get concurrencyInput() {
    return this._concurrency;
  }

  // custom_url - computed: false, optional: true, required: false
  private _customUrl?: string; 
  public get customUrl() {
    return this.getStringAttribute('custom_url');
  }
  public set customUrl(value: string) {
    this._customUrl = value;
  }
  public resetCustomUrl() {
    this._customUrl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get customUrlInput() {
    return this._customUrl;
  }

  // default_severity - computed: true, optional: true, required: false
  private _defaultSeverity?: string; 
  public get defaultSeverity() {
    return this.getStringAttribute('default_severity');
  }
  public set defaultSeverity(value: string) {
    this._defaultSeverity = value;
  }
  public resetDefaultSeverity() {
    this._defaultSeverity = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get defaultSeverityInput() {
    return this._defaultSeverity;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // exclude_fields - computed: true, optional: true, required: false
  private _excludeFields?: string[]; 
  public get excludeFields() {
    return this.getListAttribute('exclude_fields');
  }
  public set excludeFields(value: string[]) {
    this._excludeFields = value;
  }
  public resetExcludeFields() {
    this._excludeFields = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get excludeFieldsInput() {
    return this._excludeFields;
  }

  // extra_http_headers - computed: false, optional: true, required: false
  private _extraHttpHeaders = new PackDestinationOutputDatasetExtraHttpHeadersList(this, "extra_http_headers", false);
  public get extraHttpHeaders() {
    return this._extraHttpHeaders;
  }
  public putExtraHttpHeaders(value: PackDestinationOutputDatasetExtraHttpHeaders[] | cdktf.IResolvable) {
    this._extraHttpHeaders.internalValue = value;
  }
  public resetExtraHttpHeaders() {
    this._extraHttpHeaders.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get extraHttpHeadersInput() {
    return this._extraHttpHeaders.internalValue;
  }

  // failed_request_logging_mode - computed: true, optional: true, required: false
  private _failedRequestLoggingMode?: string; 
  public get failedRequestLoggingMode() {
    return this.getStringAttribute('failed_request_logging_mode');
  }
  public set failedRequestLoggingMode(value: string) {
    this._failedRequestLoggingMode = value;
  }
  public resetFailedRequestLoggingMode() {
    this._failedRequestLoggingMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get failedRequestLoggingModeInput() {
    return this._failedRequestLoggingMode;
  }

  // flush_period_sec - computed: true, optional: true, required: false
  private _flushPeriodSec?: number; 
  public get flushPeriodSec() {
    return this.getNumberAttribute('flush_period_sec');
  }
  public set flushPeriodSec(value: number) {
    this._flushPeriodSec = value;
  }
  public resetFlushPeriodSec() {
    this._flushPeriodSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get flushPeriodSecInput() {
    return this._flushPeriodSec;
  }

  // id - computed: false, optional: false, required: true
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // max_payload_events - computed: true, optional: true, required: false
  private _maxPayloadEvents?: number; 
  public get maxPayloadEvents() {
    return this.getNumberAttribute('max_payload_events');
  }
  public set maxPayloadEvents(value: number) {
    this._maxPayloadEvents = value;
  }
  public resetMaxPayloadEvents() {
    this._maxPayloadEvents = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxPayloadEventsInput() {
    return this._maxPayloadEvents;
  }

  // max_payload_size_kb - computed: true, optional: true, required: false
  private _maxPayloadSizeKb?: number; 
  public get maxPayloadSizeKb() {
    return this.getNumberAttribute('max_payload_size_kb');
  }
  public set maxPayloadSizeKb(value: number) {
    this._maxPayloadSizeKb = value;
  }
  public resetMaxPayloadSizeKb() {
    this._maxPayloadSizeKb = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxPayloadSizeKbInput() {
    return this._maxPayloadSizeKb;
  }

  // message_field - computed: false, optional: true, required: false
  private _messageField?: string; 
  public get messageField() {
    return this.getStringAttribute('message_field');
  }
  public set messageField(value: string) {
    this._messageField = value;
  }
  public resetMessageField() {
    this._messageField = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get messageFieldInput() {
    return this._messageField;
  }

  // on_backpressure - computed: true, optional: true, required: false
  private _onBackpressure?: string; 
  public get onBackpressure() {
    return this.getStringAttribute('on_backpressure');
  }
  public set onBackpressure(value: string) {
    this._onBackpressure = value;
  }
  public resetOnBackpressure() {
    this._onBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get onBackpressureInput() {
    return this._onBackpressure;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // pq_compress - computed: true, optional: true, required: false
  private _pqCompress?: string; 
  public get pqCompress() {
    return this.getStringAttribute('pq_compress');
  }
  public set pqCompress(value: string) {
    this._pqCompress = value;
  }
  public resetPqCompress() {
    this._pqCompress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqCompressInput() {
    return this._pqCompress;
  }

  // pq_controls - computed: false, optional: true, required: false
  private _pqControls = new PackDestinationOutputDatasetPqControlsOutputReference(this, "pq_controls");
  public get pqControls() {
    return this._pqControls;
  }
  public putPqControls(value: PackDestinationOutputDatasetPqControls) {
    this._pqControls.internalValue = value;
  }
  public resetPqControls() {
    this._pqControls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqControlsInput() {
    return this._pqControls.internalValue;
  }

  // pq_max_file_size - computed: true, optional: true, required: false
  private _pqMaxFileSize?: string; 
  public get pqMaxFileSize() {
    return this.getStringAttribute('pq_max_file_size');
  }
  public set pqMaxFileSize(value: string) {
    this._pqMaxFileSize = value;
  }
  public resetPqMaxFileSize() {
    this._pqMaxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxFileSizeInput() {
    return this._pqMaxFileSize;
  }

  // pq_max_size - computed: true, optional: true, required: false
  private _pqMaxSize?: string; 
  public get pqMaxSize() {
    return this.getStringAttribute('pq_max_size');
  }
  public set pqMaxSize(value: string) {
    this._pqMaxSize = value;
  }
  public resetPqMaxSize() {
    this._pqMaxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxSizeInput() {
    return this._pqMaxSize;
  }

  // pq_mode - computed: true, optional: true, required: false
  private _pqMode?: string; 
  public get pqMode() {
    return this.getStringAttribute('pq_mode');
  }
  public set pqMode(value: string) {
    this._pqMode = value;
  }
  public resetPqMode() {
    this._pqMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqModeInput() {
    return this._pqMode;
  }

  // pq_on_backpressure - computed: true, optional: true, required: false
  private _pqOnBackpressure?: string; 
  public get pqOnBackpressure() {
    return this.getStringAttribute('pq_on_backpressure');
  }
  public set pqOnBackpressure(value: string) {
    this._pqOnBackpressure = value;
  }
  public resetPqOnBackpressure() {
    this._pqOnBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqOnBackpressureInput() {
    return this._pqOnBackpressure;
  }

  // pq_path - computed: true, optional: true, required: false
  private _pqPath?: string; 
  public get pqPath() {
    return this.getStringAttribute('pq_path');
  }
  public set pqPath(value: string) {
    this._pqPath = value;
  }
  public resetPqPath() {
    this._pqPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqPathInput() {
    return this._pqPath;
  }

  // reject_unauthorized - computed: true, optional: true, required: false
  private _rejectUnauthorized?: boolean | cdktf.IResolvable; 
  public get rejectUnauthorized() {
    return this.getBooleanAttribute('reject_unauthorized');
  }
  public set rejectUnauthorized(value: boolean | cdktf.IResolvable) {
    this._rejectUnauthorized = value;
  }
  public resetRejectUnauthorized() {
    this._rejectUnauthorized = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectUnauthorizedInput() {
    return this._rejectUnauthorized;
  }

  // response_honor_retry_after_header - computed: true, optional: true, required: false
  private _responseHonorRetryAfterHeader?: boolean | cdktf.IResolvable; 
  public get responseHonorRetryAfterHeader() {
    return this.getBooleanAttribute('response_honor_retry_after_header');
  }
  public set responseHonorRetryAfterHeader(value: boolean | cdktf.IResolvable) {
    this._responseHonorRetryAfterHeader = value;
  }
  public resetResponseHonorRetryAfterHeader() {
    this._responseHonorRetryAfterHeader = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get responseHonorRetryAfterHeaderInput() {
    return this._responseHonorRetryAfterHeader;
  }

  // response_retry_settings - computed: false, optional: true, required: false
  private _responseRetrySettings = new PackDestinationOutputDatasetResponseRetrySettingsList(this, "response_retry_settings", false);
  public get responseRetrySettings() {
    return this._responseRetrySettings;
  }
  public putResponseRetrySettings(value: PackDestinationOutputDatasetResponseRetrySettings[] | cdktf.IResolvable) {
    this._responseRetrySettings.internalValue = value;
  }
  public resetResponseRetrySettings() {
    this._responseRetrySettings.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get responseRetrySettingsInput() {
    return this._responseRetrySettings.internalValue;
  }

  // safe_headers - computed: true, optional: true, required: false
  private _safeHeaders?: string[]; 
  public get safeHeaders() {
    return this.getListAttribute('safe_headers');
  }
  public set safeHeaders(value: string[]) {
    this._safeHeaders = value;
  }
  public resetSafeHeaders() {
    this._safeHeaders = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get safeHeadersInput() {
    return this._safeHeaders;
  }

  // server_host_field - computed: false, optional: true, required: false
  private _serverHostField?: string; 
  public get serverHostField() {
    return this.getStringAttribute('server_host_field');
  }
  public set serverHostField(value: string) {
    this._serverHostField = value;
  }
  public resetServerHostField() {
    this._serverHostField = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serverHostFieldInput() {
    return this._serverHostField;
  }

  // site - computed: true, optional: true, required: false
  private _site?: string; 
  public get site() {
    return this.getStringAttribute('site');
  }
  public set site(value: string) {
    this._site = value;
  }
  public resetSite() {
    this._site = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get siteInput() {
    return this._site;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // system_fields - computed: true, optional: true, required: false
  private _systemFields?: string[]; 
  public get systemFields() {
    return this.getListAttribute('system_fields');
  }
  public set systemFields(value: string[]) {
    this._systemFields = value;
  }
  public resetSystemFields() {
    this._systemFields = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get systemFieldsInput() {
    return this._systemFields;
  }

  // text_secret - computed: false, optional: true, required: false
  private _textSecret?: string; 
  public get textSecret() {
    return this.getStringAttribute('text_secret');
  }
  public set textSecret(value: string) {
    this._textSecret = value;
  }
  public resetTextSecret() {
    this._textSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get textSecretInput() {
    return this._textSecret;
  }

  // timeout_retry_settings - computed: false, optional: true, required: false
  private _timeoutRetrySettings = new PackDestinationOutputDatasetTimeoutRetrySettingsOutputReference(this, "timeout_retry_settings");
  public get timeoutRetrySettings() {
    return this._timeoutRetrySettings;
  }
  public putTimeoutRetrySettings(value: PackDestinationOutputDatasetTimeoutRetrySettings) {
    this._timeoutRetrySettings.internalValue = value;
  }
  public resetTimeoutRetrySettings() {
    this._timeoutRetrySettings.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutRetrySettingsInput() {
    return this._timeoutRetrySettings.internalValue;
  }

  // timeout_sec - computed: true, optional: true, required: false
  private _timeoutSec?: number; 
  public get timeoutSec() {
    return this.getNumberAttribute('timeout_sec');
  }
  public set timeoutSec(value: number) {
    this._timeoutSec = value;
  }
  public resetTimeoutSec() {
    this._timeoutSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutSecInput() {
    return this._timeoutSec;
  }

  // timestamp_field - computed: false, optional: true, required: false
  private _timestampField?: string; 
  public get timestampField() {
    return this.getStringAttribute('timestamp_field');
  }
  public set timestampField(value: string) {
    this._timestampField = value;
  }
  public resetTimestampField() {
    this._timestampField = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timestampFieldInput() {
    return this._timestampField;
  }

  // total_memory_limit_kb - computed: false, optional: true, required: false
  private _totalMemoryLimitKb?: number; 
  public get totalMemoryLimitKb() {
    return this.getNumberAttribute('total_memory_limit_kb');
  }
  public set totalMemoryLimitKb(value: number) {
    this._totalMemoryLimitKb = value;
  }
  public resetTotalMemoryLimitKb() {
    this._totalMemoryLimitKb = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get totalMemoryLimitKbInput() {
    return this._totalMemoryLimitKb;
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // use_round_robin_dns - computed: true, optional: true, required: false
  private _useRoundRobinDns?: boolean | cdktf.IResolvable; 
  public get useRoundRobinDns() {
    return this.getBooleanAttribute('use_round_robin_dns');
  }
  public set useRoundRobinDns(value: boolean | cdktf.IResolvable) {
    this._useRoundRobinDns = value;
  }
  public resetUseRoundRobinDns() {
    this._useRoundRobinDns = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get useRoundRobinDnsInput() {
    return this._useRoundRobinDns;
  }
}
export interface PackDestinationOutputDefault {
  /**
  * ID of the default output. This will be used whenever a nonexistent/deleted output is referenced.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#default_id PackDestination#default_id}
  */
  readonly defaultId: string;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#environment PackDestination#environment}
  */
  readonly environment?: string;
  /**
  * Unique ID for this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#id PackDestination#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * Pipeline to process data before sending out to this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pipeline PackDestination#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#streamtags PackDestination#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Fields to automatically add to events, such as cribl_pipe. Supports wildcards. Default: ["cribl_pipe"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#system_fields PackDestination#system_fields}
  */
  readonly systemFields?: string[];
  /**
  * must be "default"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#type PackDestination#type}
  */
  readonly type: string;
}

export function packDestinationOutputDefaultToTerraform(struct?: PackDestinationOutputDefault | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    default_id: cdktf.stringToTerraform(struct!.defaultId),
    environment: cdktf.stringToTerraform(struct!.environment),
    id: cdktf.stringToTerraform(struct!.id),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    system_fields: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.systemFields),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function packDestinationOutputDefaultToHclTerraform(struct?: PackDestinationOutputDefault | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    default_id: {
      value: cdktf.stringToHclTerraform(struct!.defaultId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    system_fields: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.systemFields),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputDefaultOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackDestinationOutputDefault | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._defaultId !== undefined) {
      hasAnyValues = true;
      internalValueResult.defaultId = this._defaultId;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._systemFields !== undefined) {
      hasAnyValues = true;
      internalValueResult.systemFields = this._systemFields;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputDefault | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._defaultId = undefined;
      this._environment = undefined;
      this._id = undefined;
      this._pipeline = undefined;
      this._streamtags = undefined;
      this._systemFields = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._defaultId = value.defaultId;
      this._environment = value.environment;
      this._id = value.id;
      this._pipeline = value.pipeline;
      this._streamtags = value.streamtags;
      this._systemFields = value.systemFields;
      this._type = value.type;
    }
  }

  // default_id - computed: false, optional: false, required: true
  private _defaultId?: string; 
  public get defaultId() {
    return this.getStringAttribute('default_id');
  }
  public set defaultId(value: string) {
    this._defaultId = value;
  }
  // Temporarily expose input value. Use with caution.
  public get defaultIdInput() {
    return this._defaultId;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // system_fields - computed: true, optional: true, required: false
  private _systemFields?: string[]; 
  public get systemFields() {
    return this.getListAttribute('system_fields');
  }
  public set systemFields(value: string[]) {
    this._systemFields = value;
  }
  public resetSystemFields() {
    this._systemFields = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get systemFieldsInput() {
    return this._systemFields;
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface PackDestinationOutputDevnull {
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#environment PackDestination#environment}
  */
  readonly environment?: string;
  /**
  * Unique ID for this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#id PackDestination#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id: string;
  /**
  * Pipeline to process data before sending out to this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pipeline PackDestination#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#streamtags PackDestination#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Fields to automatically add to events, such as cribl_pipe. Supports wildcards. Default: ["cribl_pipe"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#system_fields PackDestination#system_fields}
  */
  readonly systemFields?: string[];
  /**
  * must be "devnull"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#type PackDestination#type}
  */
  readonly type: string;
}

export function packDestinationOutputDevnullToTerraform(struct?: PackDestinationOutputDevnull | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    environment: cdktf.stringToTerraform(struct!.environment),
    id: cdktf.stringToTerraform(struct!.id),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    system_fields: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.systemFields),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function packDestinationOutputDevnullToHclTerraform(struct?: PackDestinationOutputDevnull | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    system_fields: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.systemFields),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputDevnullOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackDestinationOutputDevnull | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._systemFields !== undefined) {
      hasAnyValues = true;
      internalValueResult.systemFields = this._systemFields;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputDevnull | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._environment = undefined;
      this._id = undefined;
      this._pipeline = undefined;
      this._streamtags = undefined;
      this._systemFields = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._environment = value.environment;
      this._id = value.id;
      this._pipeline = value.pipeline;
      this._streamtags = value.streamtags;
      this._systemFields = value.systemFields;
      this._type = value.type;
    }
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // id - computed: false, optional: false, required: true
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // system_fields - computed: true, optional: true, required: false
  private _systemFields?: string[]; 
  public get systemFields() {
    return this.getListAttribute('system_fields');
  }
  public set systemFields(value: string[]) {
    this._systemFields = value;
  }
  public resetSystemFields() {
    this._systemFields = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get systemFieldsInput() {
    return this._systemFields;
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface PackDestinationOutputDiskSpool {
  /**
  * Data compression format. Default is gzip. Default: "gzip"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#compress PackDestination#compress}
  */
  readonly compress?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#description PackDestination#description}
  */
  readonly description?: string;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#environment PackDestination#environment}
  */
  readonly environment?: string;
  /**
  * Unique ID for this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#id PackDestination#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id: string;
  /**
  * Maximum disk space that can be consumed before older buckets are deleted. Examples: 420MB, 4GB. Default is 1GB. Default: "1GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_data_size PackDestination#max_data_size}
  */
  readonly maxDataSize?: string;
  /**
  * Maximum amount of time to retain data before older buckets are deleted. Examples: 2h, 4d. Default is 24h. Default: "24h"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_data_time PackDestination#max_data_time}
  */
  readonly maxDataTime?: string;
  /**
  * JavaScript expression defining how files are partitioned and organized within the time-buckets. If blank, the event's __partition property is used and otherwise, events go directly into the time-bucket directory.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#partition_expr PackDestination#partition_expr}
  */
  readonly partitionExpr?: string;
  /**
  * Pipeline to process data before sending out to this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pipeline PackDestination#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#streamtags PackDestination#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Fields to automatically add to events, such as cribl_pipe. Supports wildcards. Default: ["cribl_pipe"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#system_fields PackDestination#system_fields}
  */
  readonly systemFields?: string[];
  /**
  * Time period for grouping spooled events. Default is 10m. Default: "10m"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#time_window PackDestination#time_window}
  */
  readonly timeWindow?: string;
  /**
  * must be "disk_spool"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#type PackDestination#type}
  */
  readonly type: string;
}

export function packDestinationOutputDiskSpoolToTerraform(struct?: PackDestinationOutputDiskSpool | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    compress: cdktf.stringToTerraform(struct!.compress),
    description: cdktf.stringToTerraform(struct!.description),
    environment: cdktf.stringToTerraform(struct!.environment),
    id: cdktf.stringToTerraform(struct!.id),
    max_data_size: cdktf.stringToTerraform(struct!.maxDataSize),
    max_data_time: cdktf.stringToTerraform(struct!.maxDataTime),
    partition_expr: cdktf.stringToTerraform(struct!.partitionExpr),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    system_fields: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.systemFields),
    time_window: cdktf.stringToTerraform(struct!.timeWindow),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function packDestinationOutputDiskSpoolToHclTerraform(struct?: PackDestinationOutputDiskSpool | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    compress: {
      value: cdktf.stringToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_data_size: {
      value: cdktf.stringToHclTerraform(struct!.maxDataSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_data_time: {
      value: cdktf.stringToHclTerraform(struct!.maxDataTime),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    partition_expr: {
      value: cdktf.stringToHclTerraform(struct!.partitionExpr),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    system_fields: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.systemFields),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    time_window: {
      value: cdktf.stringToHclTerraform(struct!.timeWindow),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputDiskSpoolOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackDestinationOutputDiskSpool | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._maxDataSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxDataSize = this._maxDataSize;
    }
    if (this._maxDataTime !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxDataTime = this._maxDataTime;
    }
    if (this._partitionExpr !== undefined) {
      hasAnyValues = true;
      internalValueResult.partitionExpr = this._partitionExpr;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._systemFields !== undefined) {
      hasAnyValues = true;
      internalValueResult.systemFields = this._systemFields;
    }
    if (this._timeWindow !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeWindow = this._timeWindow;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputDiskSpool | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._compress = undefined;
      this._description = undefined;
      this._environment = undefined;
      this._id = undefined;
      this._maxDataSize = undefined;
      this._maxDataTime = undefined;
      this._partitionExpr = undefined;
      this._pipeline = undefined;
      this._streamtags = undefined;
      this._systemFields = undefined;
      this._timeWindow = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._compress = value.compress;
      this._description = value.description;
      this._environment = value.environment;
      this._id = value.id;
      this._maxDataSize = value.maxDataSize;
      this._maxDataTime = value.maxDataTime;
      this._partitionExpr = value.partitionExpr;
      this._pipeline = value.pipeline;
      this._streamtags = value.streamtags;
      this._systemFields = value.systemFields;
      this._timeWindow = value.timeWindow;
      this._type = value.type;
    }
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: string; 
  public get compress() {
    return this.getStringAttribute('compress');
  }
  public set compress(value: string) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // id - computed: false, optional: false, required: true
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // max_data_size - computed: true, optional: true, required: false
  private _maxDataSize?: string; 
  public get maxDataSize() {
    return this.getStringAttribute('max_data_size');
  }
  public set maxDataSize(value: string) {
    this._maxDataSize = value;
  }
  public resetMaxDataSize() {
    this._maxDataSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxDataSizeInput() {
    return this._maxDataSize;
  }

  // max_data_time - computed: true, optional: true, required: false
  private _maxDataTime?: string; 
  public get maxDataTime() {
    return this.getStringAttribute('max_data_time');
  }
  public set maxDataTime(value: string) {
    this._maxDataTime = value;
  }
  public resetMaxDataTime() {
    this._maxDataTime = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxDataTimeInput() {
    return this._maxDataTime;
  }

  // partition_expr - computed: false, optional: true, required: false
  private _partitionExpr?: string; 
  public get partitionExpr() {
    return this.getStringAttribute('partition_expr');
  }
  public set partitionExpr(value: string) {
    this._partitionExpr = value;
  }
  public resetPartitionExpr() {
    this._partitionExpr = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get partitionExprInput() {
    return this._partitionExpr;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // system_fields - computed: true, optional: true, required: false
  private _systemFields?: string[]; 
  public get systemFields() {
    return this.getListAttribute('system_fields');
  }
  public set systemFields(value: string[]) {
    this._systemFields = value;
  }
  public resetSystemFields() {
    this._systemFields = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get systemFieldsInput() {
    return this._systemFields;
  }

  // time_window - computed: true, optional: true, required: false
  private _timeWindow?: string; 
  public get timeWindow() {
    return this.getStringAttribute('time_window');
  }
  public set timeWindow(value: string) {
    this._timeWindow = value;
  }
  public resetTimeWindow() {
    this._timeWindow = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeWindowInput() {
    return this._timeWindow;
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface PackDestinationOutputDlS3KeyValueMetadata {
  /**
  * Default: ""
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#key PackDestination#key}
  */
  readonly key?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#value PackDestination#value}
  */
  readonly value: string;
}

export function packDestinationOutputDlS3KeyValueMetadataToTerraform(struct?: PackDestinationOutputDlS3KeyValueMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function packDestinationOutputDlS3KeyValueMetadataToHclTerraform(struct?: PackDestinationOutputDlS3KeyValueMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputDlS3KeyValueMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackDestinationOutputDlS3KeyValueMetadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputDlS3KeyValueMetadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._value = value.value;
    }
  }

  // key - computed: true, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class PackDestinationOutputDlS3KeyValueMetadataList extends cdktf.ComplexList {
  public internalValue? : PackDestinationOutputDlS3KeyValueMetadata[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackDestinationOutputDlS3KeyValueMetadataOutputReference {
    return new PackDestinationOutputDlS3KeyValueMetadataOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackDestinationOutputDlS3 {
  /**
  * Add the Output ID value to staging location. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#add_id_to_stage_path PackDestination#add_id_to_stage_path}
  */
  readonly addIdToStagePath?: boolean | cdktf.IResolvable;
  /**
  * Amazon Resource Name (ARN) of the role to assume
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#assume_role_arn PackDestination#assume_role_arn}
  */
  readonly assumeRoleArn?: string;
  /**
  * External ID to use when assuming role
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#assume_role_external_id PackDestination#assume_role_external_id}
  */
  readonly assumeRoleExternalId?: string;
  /**
  * Automatically calculate the schema based on the events of each Parquet file generated. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#automatic_schema PackDestination#automatic_schema}
  */
  readonly automaticSchema?: boolean | cdktf.IResolvable;
  /**
  * This value can be a constant or a JavaScript expression (`${C.env.SOME_ACCESS_KEY}`)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#aws_api_key PackDestination#aws_api_key}
  */
  readonly awsApiKey?: string;
  /**
  * AWS authentication method. Choose Auto to use IAM roles. Default: "auto"; must be one of ["auto", "manual", "secret"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#aws_authentication_method PackDestination#aws_authentication_method}
  */
  readonly awsAuthenticationMethod?: string;
  /**
  * Select or create a stored secret that references your access key and secret key
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#aws_secret PackDestination#aws_secret}
  */
  readonly awsSecret?: string;
  /**
  * Secret key. This value can be a constant or a JavaScript expression. Example: `${C.env.SOME_SECRET}`)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#aws_secret_key PackDestination#aws_secret_key}
  */
  readonly awsSecretKey?: string;
  /**
  * JavaScript expression to define the output filename prefix (can be constant). Default: "`CriblOut`"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#base_file_name PackDestination#base_file_name}
  */
  readonly baseFileName?: string;
  /**
  * Name of the destination S3 bucket. Must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can be evaluated only at initialization time. Example referencing a Global Variable: `myBucket-${C.vars.myVar}`
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#bucket PackDestination#bucket}
  */
  readonly bucket: string;
  /**
  * Data compression format to apply to HTTP content before it is delivered. Default: "gzip"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#compress PackDestination#compress}
  */
  readonly compress?: string;
  /**
  * Compression level to apply before moving files to final destination. Default: "best_speed"; must be one of ["best_speed", "normal", "best_compression"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#compression_level PackDestination#compression_level}
  */
  readonly compressionLevel?: string;
  /**
  * If a file fails to move to its final destination after the maximum number of retries, move it to a designated directory to prevent further errors. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#deadletter_enabled PackDestination#deadletter_enabled}
  */
  readonly deadletterEnabled?: boolean | cdktf.IResolvable;
  /**
  * Storage location for files that fail to reach their final destination after maximum retries are exceeded. Default: "$CRIBL_HOME/state/outputs/dead-letter"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#deadletter_path PackDestination#deadletter_path}
  */
  readonly deadletterPath?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#description PackDestination#description}
  */
  readonly description?: string;
  /**
  * Prefix to append to files before uploading. Must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can be evaluated only at init time. Example referencing a Global Variable: `myKeyPrefix-${C.vars.myVar}`. Default: ""
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#dest_path PackDestination#dest_path}
  */
  readonly destPath?: string;
  /**
  * Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours). Default: 3600
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#duration_seconds PackDestination#duration_seconds}
  */
  readonly durationSeconds?: number;
  /**
  * How frequently, in seconds, to clean up empty directories. Default: 300
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#empty_dir_cleanup_sec PackDestination#empty_dir_cleanup_sec}
  */
  readonly emptyDirCleanupSec?: number;
  /**
  * Use Assume Role credentials to access S3. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#enable_assume_role PackDestination#enable_assume_role}
  */
  readonly enableAssumeRole?: boolean | cdktf.IResolvable;
  /**
  * Parquet tools can use the checksum of a Parquet page to verify data integrity. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#enable_page_checksum PackDestination#enable_page_checksum}
  */
  readonly enablePageChecksum?: boolean | cdktf.IResolvable;
  /**
  * Statistics profile an entire file in terms of minimum/maximum values within data, numbers of nulls, etc. You can use Parquet tools to view statistics. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#enable_statistics PackDestination#enable_statistics}
  */
  readonly enableStatistics?: boolean | cdktf.IResolvable;
  /**
  * One page index contains statistics for one data page. Parquet readers use statistics to enable page skipping. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#enable_write_page_index PackDestination#enable_write_page_index}
  */
  readonly enableWritePageIndex?: boolean | cdktf.IResolvable;
  /**
  * S3 service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to S3-compatible endpoint.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#endpoint PackDestination#endpoint}
  */
  readonly endpoint?: string;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#environment PackDestination#environment}
  */
  readonly environment?: string;
  /**
  * JavaScript expression to define the output filename suffix (can be constant).  The `__format` variable refers to the value of the `Data format` field (`json` or `raw`).  The `__compression` field refers to the kind of compression being used (`none` or `gzip`). Default: "`.${C.env[\"CRIBL_WORKER_ID\"]}.${__format}${__compression === \"gzip\" ? \".gz\" : \"\"}`"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#file_name_suffix PackDestination#file_name_suffix}
  */
  readonly fileNameSuffix?: string;
  /**
  * Format of the output data. Default: "json"; must be one of ["json", "raw", "parquet"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#format PackDestination#format}
  */
  readonly format?: string;
  /**
  * If set, this line will be written to the beginning of each output file. Default: ""
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#header_line PackDestination#header_line}
  */
  readonly headerLine?: string;
  /**
  * Unique ID for this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#id PackDestination#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * The metadata of files the Destination writes will include the properties you add here as key-value pairs. Useful for tagging. Examples: "key":"OCSF Event Class", "value":"9001"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#key_value_metadata PackDestination#key_value_metadata}
  */
  readonly keyValueMetadata?: PackDestinationOutputDlS3KeyValueMetadata[] | cdktf.IResolvable;
  /**
  * ID or ARN of the KMS customer-managed key to use for encryption
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#kms_key_id PackDestination#kms_key_id}
  */
  readonly kmsKeyId?: string;
  /**
  * Maximum number of files that can be waiting for upload before backpressure is applied. Default: 100
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_closing_files_to_backpressure PackDestination#max_closing_files_to_backpressure}
  */
  readonly maxClosingFilesToBackpressure?: number;
  /**
  * Maximum number of parts to upload in parallel per file. Minimum part size is 5MB. Default: 4
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_concurrent_file_parts PackDestination#max_concurrent_file_parts}
  */
  readonly maxConcurrentFileParts?: number;
  /**
  * Maximum amount of time to keep inactive files open. Files open for longer than this will be closed and moved to final output location. Default: 30
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_file_idle_time_sec PackDestination#max_file_idle_time_sec}
  */
  readonly maxFileIdleTimeSec?: number;
  /**
  * Maximum amount of time to write to a file. Files open for longer than this will be closed and moved to final output location. Default: 300
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_file_open_time_sec PackDestination#max_file_open_time_sec}
  */
  readonly maxFileOpenTimeSec?: number;
  /**
  * Maximum uncompressed output file size. Files of this size will be closed and moved to final output location. Default: 32
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_file_size_mb PackDestination#max_file_size_mb}
  */
  readonly maxFileSizeMb?: number;
  /**
  * Maximum number of files to keep open concurrently. When exceeded, @{product} will close the oldest open files and move them to the final output location. Default: 100
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_open_files PackDestination#max_open_files}
  */
  readonly maxOpenFiles?: number;
  /**
  * The maximum number of times a file will attempt to move to its final destination before being dead-lettered. Default: 20
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_retry_num PackDestination#max_retry_num}
  */
  readonly maxRetryNum?: number;
  /**
  * Object ACL to assign to uploaded objects. Default: "private"; must be one of ["private", "public-read", "public-read-write", "authenticated-read", "aws-exec-read", "bucket-owner-read", "bucket-owner-full-control"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#object_acl PackDestination#object_acl}
  */
  readonly objectAcl?: string;
  /**
  * How to handle events when disk space is below the global 'Min free disk space' limit. Default: "block"; must be one of ["block", "drop"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#on_disk_full_backpressure PackDestination#on_disk_full_backpressure}
  */
  readonly onDiskFullBackpressure?: string;
  /**
  * Serialization format of data pages. Note that some reader implementations use Data page V2's attributes to work more efficiently, while others ignore it. Default: "DATA_PAGE_V2"; must be one of ["DATA_PAGE_V1", "DATA_PAGE_V2"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#parquet_data_page_version PackDestination#parquet_data_page_version}
  */
  readonly parquetDataPageVersion?: string;
  /**
  * Target memory size for page segments, such as 1MB or 128MB. Generally, lower values improve reading speed, while higher values improve compression. Default: "1MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#parquet_page_size PackDestination#parquet_page_size}
  */
  readonly parquetPageSize?: string;
  /**
  * The number of rows that every group will contain. The final group can contain a smaller number of rows. Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#parquet_row_group_length PackDestination#parquet_row_group_length}
  */
  readonly parquetRowGroupLength?: number;
  /**
  * Determines which data types are supported and how they are represented. Default: "PARQUET_2_6"; must be one of ["PARQUET_1_0", "PARQUET_2_4", "PARQUET_2_6"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#parquet_version PackDestination#parquet_version}
  */
  readonly parquetVersion?: string;
  /**
  * List of fields to partition the path by, in addition to time, which is included automatically. The effective partition will be YYYY/MM/DD/HH/<list/of/fields>. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#partitioning_fields PackDestination#partitioning_fields}
  */
  readonly partitioningFields?: string[];
  /**
  * Pipeline to process data before sending out to this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pipeline PackDestination#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Region where the S3 bucket is located
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#region PackDestination#region}
  */
  readonly region?: string;
  /**
  * Reject certificates that cannot be verified against a valid CA, such as self-signed certificates. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#reject_unauthorized PackDestination#reject_unauthorized}
  */
  readonly rejectUnauthorized?: boolean | cdktf.IResolvable;
  /**
  * Remove empty staging directories after moving files. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#remove_empty_dirs PackDestination#remove_empty_dirs}
  */
  readonly removeEmptyDirs?: boolean | cdktf.IResolvable;
  /**
  * Reuse connections between requests, which can improve performance. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#reuse_connections PackDestination#reuse_connections}
  */
  readonly reuseConnections?: boolean | cdktf.IResolvable;
  /**
  * must be one of ["AES256", "aws:kms"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#server_side_encryption PackDestination#server_side_encryption}
  */
  readonly serverSideEncryption?: string;
  /**
  * Log up to 3 rows that @{product} skips due to data mismatch
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#should_log_invalid_rows PackDestination#should_log_invalid_rows}
  */
  readonly shouldLogInvalidRows?: boolean | cdktf.IResolvable;
  /**
  * Signature version to use for signing S3 requests. Default: "v4"; must be one of ["v2", "v4"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#signature_version PackDestination#signature_version}
  */
  readonly signatureVersion?: string;
  /**
  * Filesystem location in which to buffer files, before compressing and moving to final destination. Use performant and stable storage. Default: "$CRIBL_HOME/state/outputs/staging"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#stage_path PackDestination#stage_path}
  */
  readonly stagePath?: string;
  /**
  * Storage class to select for uploaded objects. must be one of ["STANDARD", "REDUCED_REDUNDANCY", "STANDARD_IA", "ONEZONE_IA", "INTELLIGENT_TIERING", "GLACIER", "GLACIER_IR", "DEEP_ARCHIVE"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#storage_class PackDestination#storage_class}
  */
  readonly storageClass?: string;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#streamtags PackDestination#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Fields to automatically add to events, such as cribl_pipe. Supports wildcards. Default: ["cribl_pipe"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#system_fields PackDestination#system_fields}
  */
  readonly systemFields?: string[];
  /**
  * must be "dl_s3"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#type PackDestination#type}
  */
  readonly type?: string;
  /**
  * Disable if you can access files within the bucket but not the bucket itself. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#verify_permissions PackDestination#verify_permissions}
  */
  readonly verifyPermissions?: boolean | cdktf.IResolvable;
  /**
  * Buffer size used to write to a file. Default: 64
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#write_high_water_mark PackDestination#write_high_water_mark}
  */
  readonly writeHighWaterMark?: number;
}

export function packDestinationOutputDlS3ToTerraform(struct?: PackDestinationOutputDlS3 | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    add_id_to_stage_path: cdktf.booleanToTerraform(struct!.addIdToStagePath),
    assume_role_arn: cdktf.stringToTerraform(struct!.assumeRoleArn),
    assume_role_external_id: cdktf.stringToTerraform(struct!.assumeRoleExternalId),
    automatic_schema: cdktf.booleanToTerraform(struct!.automaticSchema),
    aws_api_key: cdktf.stringToTerraform(struct!.awsApiKey),
    aws_authentication_method: cdktf.stringToTerraform(struct!.awsAuthenticationMethod),
    aws_secret: cdktf.stringToTerraform(struct!.awsSecret),
    aws_secret_key: cdktf.stringToTerraform(struct!.awsSecretKey),
    base_file_name: cdktf.stringToTerraform(struct!.baseFileName),
    bucket: cdktf.stringToTerraform(struct!.bucket),
    compress: cdktf.stringToTerraform(struct!.compress),
    compression_level: cdktf.stringToTerraform(struct!.compressionLevel),
    deadletter_enabled: cdktf.booleanToTerraform(struct!.deadletterEnabled),
    deadletter_path: cdktf.stringToTerraform(struct!.deadletterPath),
    description: cdktf.stringToTerraform(struct!.description),
    dest_path: cdktf.stringToTerraform(struct!.destPath),
    duration_seconds: cdktf.numberToTerraform(struct!.durationSeconds),
    empty_dir_cleanup_sec: cdktf.numberToTerraform(struct!.emptyDirCleanupSec),
    enable_assume_role: cdktf.booleanToTerraform(struct!.enableAssumeRole),
    enable_page_checksum: cdktf.booleanToTerraform(struct!.enablePageChecksum),
    enable_statistics: cdktf.booleanToTerraform(struct!.enableStatistics),
    enable_write_page_index: cdktf.booleanToTerraform(struct!.enableWritePageIndex),
    endpoint: cdktf.stringToTerraform(struct!.endpoint),
    environment: cdktf.stringToTerraform(struct!.environment),
    file_name_suffix: cdktf.stringToTerraform(struct!.fileNameSuffix),
    format: cdktf.stringToTerraform(struct!.format),
    header_line: cdktf.stringToTerraform(struct!.headerLine),
    id: cdktf.stringToTerraform(struct!.id),
    key_value_metadata: cdktf.listMapper(packDestinationOutputDlS3KeyValueMetadataToTerraform, false)(struct!.keyValueMetadata),
    kms_key_id: cdktf.stringToTerraform(struct!.kmsKeyId),
    max_closing_files_to_backpressure: cdktf.numberToTerraform(struct!.maxClosingFilesToBackpressure),
    max_concurrent_file_parts: cdktf.numberToTerraform(struct!.maxConcurrentFileParts),
    max_file_idle_time_sec: cdktf.numberToTerraform(struct!.maxFileIdleTimeSec),
    max_file_open_time_sec: cdktf.numberToTerraform(struct!.maxFileOpenTimeSec),
    max_file_size_mb: cdktf.numberToTerraform(struct!.maxFileSizeMb),
    max_open_files: cdktf.numberToTerraform(struct!.maxOpenFiles),
    max_retry_num: cdktf.numberToTerraform(struct!.maxRetryNum),
    object_acl: cdktf.stringToTerraform(struct!.objectAcl),
    on_disk_full_backpressure: cdktf.stringToTerraform(struct!.onDiskFullBackpressure),
    parquet_data_page_version: cdktf.stringToTerraform(struct!.parquetDataPageVersion),
    parquet_page_size: cdktf.stringToTerraform(struct!.parquetPageSize),
    parquet_row_group_length: cdktf.numberToTerraform(struct!.parquetRowGroupLength),
    parquet_version: cdktf.stringToTerraform(struct!.parquetVersion),
    partitioning_fields: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.partitioningFields),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    region: cdktf.stringToTerraform(struct!.region),
    reject_unauthorized: cdktf.booleanToTerraform(struct!.rejectUnauthorized),
    remove_empty_dirs: cdktf.booleanToTerraform(struct!.removeEmptyDirs),
    reuse_connections: cdktf.booleanToTerraform(struct!.reuseConnections),
    server_side_encryption: cdktf.stringToTerraform(struct!.serverSideEncryption),
    should_log_invalid_rows: cdktf.booleanToTerraform(struct!.shouldLogInvalidRows),
    signature_version: cdktf.stringToTerraform(struct!.signatureVersion),
    stage_path: cdktf.stringToTerraform(struct!.stagePath),
    storage_class: cdktf.stringToTerraform(struct!.storageClass),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    system_fields: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.systemFields),
    type: cdktf.stringToTerraform(struct!.type),
    verify_permissions: cdktf.booleanToTerraform(struct!.verifyPermissions),
    write_high_water_mark: cdktf.numberToTerraform(struct!.writeHighWaterMark),
  }
}


export function packDestinationOutputDlS3ToHclTerraform(struct?: PackDestinationOutputDlS3 | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    add_id_to_stage_path: {
      value: cdktf.booleanToHclTerraform(struct!.addIdToStagePath),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    assume_role_arn: {
      value: cdktf.stringToHclTerraform(struct!.assumeRoleArn),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    assume_role_external_id: {
      value: cdktf.stringToHclTerraform(struct!.assumeRoleExternalId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    automatic_schema: {
      value: cdktf.booleanToHclTerraform(struct!.automaticSchema),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    aws_api_key: {
      value: cdktf.stringToHclTerraform(struct!.awsApiKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    aws_authentication_method: {
      value: cdktf.stringToHclTerraform(struct!.awsAuthenticationMethod),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    aws_secret: {
      value: cdktf.stringToHclTerraform(struct!.awsSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    aws_secret_key: {
      value: cdktf.stringToHclTerraform(struct!.awsSecretKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    base_file_name: {
      value: cdktf.stringToHclTerraform(struct!.baseFileName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    bucket: {
      value: cdktf.stringToHclTerraform(struct!.bucket),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    compress: {
      value: cdktf.stringToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    compression_level: {
      value: cdktf.stringToHclTerraform(struct!.compressionLevel),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    deadletter_enabled: {
      value: cdktf.booleanToHclTerraform(struct!.deadletterEnabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    deadletter_path: {
      value: cdktf.stringToHclTerraform(struct!.deadletterPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    dest_path: {
      value: cdktf.stringToHclTerraform(struct!.destPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    duration_seconds: {
      value: cdktf.numberToHclTerraform(struct!.durationSeconds),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    empty_dir_cleanup_sec: {
      value: cdktf.numberToHclTerraform(struct!.emptyDirCleanupSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    enable_assume_role: {
      value: cdktf.booleanToHclTerraform(struct!.enableAssumeRole),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    enable_page_checksum: {
      value: cdktf.booleanToHclTerraform(struct!.enablePageChecksum),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    enable_statistics: {
      value: cdktf.booleanToHclTerraform(struct!.enableStatistics),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    enable_write_page_index: {
      value: cdktf.booleanToHclTerraform(struct!.enableWritePageIndex),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    endpoint: {
      value: cdktf.stringToHclTerraform(struct!.endpoint),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    file_name_suffix: {
      value: cdktf.stringToHclTerraform(struct!.fileNameSuffix),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    format: {
      value: cdktf.stringToHclTerraform(struct!.format),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    header_line: {
      value: cdktf.stringToHclTerraform(struct!.headerLine),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    key_value_metadata: {
      value: cdktf.listMapperHcl(packDestinationOutputDlS3KeyValueMetadataToHclTerraform, false)(struct!.keyValueMetadata),
      isBlock: true,
      type: "list",
      storageClassType: "PackDestinationOutputDlS3KeyValueMetadataList",
    },
    kms_key_id: {
      value: cdktf.stringToHclTerraform(struct!.kmsKeyId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_closing_files_to_backpressure: {
      value: cdktf.numberToHclTerraform(struct!.maxClosingFilesToBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_concurrent_file_parts: {
      value: cdktf.numberToHclTerraform(struct!.maxConcurrentFileParts),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_file_idle_time_sec: {
      value: cdktf.numberToHclTerraform(struct!.maxFileIdleTimeSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_file_open_time_sec: {
      value: cdktf.numberToHclTerraform(struct!.maxFileOpenTimeSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_file_size_mb: {
      value: cdktf.numberToHclTerraform(struct!.maxFileSizeMb),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_open_files: {
      value: cdktf.numberToHclTerraform(struct!.maxOpenFiles),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_retry_num: {
      value: cdktf.numberToHclTerraform(struct!.maxRetryNum),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    object_acl: {
      value: cdktf.stringToHclTerraform(struct!.objectAcl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    on_disk_full_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.onDiskFullBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    parquet_data_page_version: {
      value: cdktf.stringToHclTerraform(struct!.parquetDataPageVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    parquet_page_size: {
      value: cdktf.stringToHclTerraform(struct!.parquetPageSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    parquet_row_group_length: {
      value: cdktf.numberToHclTerraform(struct!.parquetRowGroupLength),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    parquet_version: {
      value: cdktf.stringToHclTerraform(struct!.parquetVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    partitioning_fields: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.partitioningFields),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    region: {
      value: cdktf.stringToHclTerraform(struct!.region),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reject_unauthorized: {
      value: cdktf.booleanToHclTerraform(struct!.rejectUnauthorized),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    remove_empty_dirs: {
      value: cdktf.booleanToHclTerraform(struct!.removeEmptyDirs),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    reuse_connections: {
      value: cdktf.booleanToHclTerraform(struct!.reuseConnections),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    server_side_encryption: {
      value: cdktf.stringToHclTerraform(struct!.serverSideEncryption),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    should_log_invalid_rows: {
      value: cdktf.booleanToHclTerraform(struct!.shouldLogInvalidRows),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    signature_version: {
      value: cdktf.stringToHclTerraform(struct!.signatureVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    stage_path: {
      value: cdktf.stringToHclTerraform(struct!.stagePath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    storage_class: {
      value: cdktf.stringToHclTerraform(struct!.storageClass),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    system_fields: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.systemFields),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    verify_permissions: {
      value: cdktf.booleanToHclTerraform(struct!.verifyPermissions),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    write_high_water_mark: {
      value: cdktf.numberToHclTerraform(struct!.writeHighWaterMark),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputDlS3OutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackDestinationOutputDlS3 | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._addIdToStagePath !== undefined) {
      hasAnyValues = true;
      internalValueResult.addIdToStagePath = this._addIdToStagePath;
    }
    if (this._assumeRoleArn !== undefined) {
      hasAnyValues = true;
      internalValueResult.assumeRoleArn = this._assumeRoleArn;
    }
    if (this._assumeRoleExternalId !== undefined) {
      hasAnyValues = true;
      internalValueResult.assumeRoleExternalId = this._assumeRoleExternalId;
    }
    if (this._automaticSchema !== undefined) {
      hasAnyValues = true;
      internalValueResult.automaticSchema = this._automaticSchema;
    }
    if (this._awsApiKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.awsApiKey = this._awsApiKey;
    }
    if (this._awsAuthenticationMethod !== undefined) {
      hasAnyValues = true;
      internalValueResult.awsAuthenticationMethod = this._awsAuthenticationMethod;
    }
    if (this._awsSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.awsSecret = this._awsSecret;
    }
    if (this._awsSecretKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.awsSecretKey = this._awsSecretKey;
    }
    if (this._baseFileName !== undefined) {
      hasAnyValues = true;
      internalValueResult.baseFileName = this._baseFileName;
    }
    if (this._bucket !== undefined) {
      hasAnyValues = true;
      internalValueResult.bucket = this._bucket;
    }
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._compressionLevel !== undefined) {
      hasAnyValues = true;
      internalValueResult.compressionLevel = this._compressionLevel;
    }
    if (this._deadletterEnabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.deadletterEnabled = this._deadletterEnabled;
    }
    if (this._deadletterPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.deadletterPath = this._deadletterPath;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._destPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.destPath = this._destPath;
    }
    if (this._durationSeconds !== undefined) {
      hasAnyValues = true;
      internalValueResult.durationSeconds = this._durationSeconds;
    }
    if (this._emptyDirCleanupSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.emptyDirCleanupSec = this._emptyDirCleanupSec;
    }
    if (this._enableAssumeRole !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableAssumeRole = this._enableAssumeRole;
    }
    if (this._enablePageChecksum !== undefined) {
      hasAnyValues = true;
      internalValueResult.enablePageChecksum = this._enablePageChecksum;
    }
    if (this._enableStatistics !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableStatistics = this._enableStatistics;
    }
    if (this._enableWritePageIndex !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableWritePageIndex = this._enableWritePageIndex;
    }
    if (this._endpoint !== undefined) {
      hasAnyValues = true;
      internalValueResult.endpoint = this._endpoint;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._fileNameSuffix !== undefined) {
      hasAnyValues = true;
      internalValueResult.fileNameSuffix = this._fileNameSuffix;
    }
    if (this._format !== undefined) {
      hasAnyValues = true;
      internalValueResult.format = this._format;
    }
    if (this._headerLine !== undefined) {
      hasAnyValues = true;
      internalValueResult.headerLine = this._headerLine;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._keyValueMetadata?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.keyValueMetadata = this._keyValueMetadata?.internalValue;
    }
    if (this._kmsKeyId !== undefined) {
      hasAnyValues = true;
      internalValueResult.kmsKeyId = this._kmsKeyId;
    }
    if (this._maxClosingFilesToBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxClosingFilesToBackpressure = this._maxClosingFilesToBackpressure;
    }
    if (this._maxConcurrentFileParts !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxConcurrentFileParts = this._maxConcurrentFileParts;
    }
    if (this._maxFileIdleTimeSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxFileIdleTimeSec = this._maxFileIdleTimeSec;
    }
    if (this._maxFileOpenTimeSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxFileOpenTimeSec = this._maxFileOpenTimeSec;
    }
    if (this._maxFileSizeMb !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxFileSizeMb = this._maxFileSizeMb;
    }
    if (this._maxOpenFiles !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxOpenFiles = this._maxOpenFiles;
    }
    if (this._maxRetryNum !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxRetryNum = this._maxRetryNum;
    }
    if (this._objectAcl !== undefined) {
      hasAnyValues = true;
      internalValueResult.objectAcl = this._objectAcl;
    }
    if (this._onDiskFullBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.onDiskFullBackpressure = this._onDiskFullBackpressure;
    }
    if (this._parquetDataPageVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.parquetDataPageVersion = this._parquetDataPageVersion;
    }
    if (this._parquetPageSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.parquetPageSize = this._parquetPageSize;
    }
    if (this._parquetRowGroupLength !== undefined) {
      hasAnyValues = true;
      internalValueResult.parquetRowGroupLength = this._parquetRowGroupLength;
    }
    if (this._parquetVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.parquetVersion = this._parquetVersion;
    }
    if (this._partitioningFields !== undefined) {
      hasAnyValues = true;
      internalValueResult.partitioningFields = this._partitioningFields;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._region !== undefined) {
      hasAnyValues = true;
      internalValueResult.region = this._region;
    }
    if (this._rejectUnauthorized !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectUnauthorized = this._rejectUnauthorized;
    }
    if (this._removeEmptyDirs !== undefined) {
      hasAnyValues = true;
      internalValueResult.removeEmptyDirs = this._removeEmptyDirs;
    }
    if (this._reuseConnections !== undefined) {
      hasAnyValues = true;
      internalValueResult.reuseConnections = this._reuseConnections;
    }
    if (this._serverSideEncryption !== undefined) {
      hasAnyValues = true;
      internalValueResult.serverSideEncryption = this._serverSideEncryption;
    }
    if (this._shouldLogInvalidRows !== undefined) {
      hasAnyValues = true;
      internalValueResult.shouldLogInvalidRows = this._shouldLogInvalidRows;
    }
    if (this._signatureVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.signatureVersion = this._signatureVersion;
    }
    if (this._stagePath !== undefined) {
      hasAnyValues = true;
      internalValueResult.stagePath = this._stagePath;
    }
    if (this._storageClass !== undefined) {
      hasAnyValues = true;
      internalValueResult.storageClass = this._storageClass;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._systemFields !== undefined) {
      hasAnyValues = true;
      internalValueResult.systemFields = this._systemFields;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._verifyPermissions !== undefined) {
      hasAnyValues = true;
      internalValueResult.verifyPermissions = this._verifyPermissions;
    }
    if (this._writeHighWaterMark !== undefined) {
      hasAnyValues = true;
      internalValueResult.writeHighWaterMark = this._writeHighWaterMark;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputDlS3 | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._addIdToStagePath = undefined;
      this._assumeRoleArn = undefined;
      this._assumeRoleExternalId = undefined;
      this._automaticSchema = undefined;
      this._awsApiKey = undefined;
      this._awsAuthenticationMethod = undefined;
      this._awsSecret = undefined;
      this._awsSecretKey = undefined;
      this._baseFileName = undefined;
      this._bucket = undefined;
      this._compress = undefined;
      this._compressionLevel = undefined;
      this._deadletterEnabled = undefined;
      this._deadletterPath = undefined;
      this._description = undefined;
      this._destPath = undefined;
      this._durationSeconds = undefined;
      this._emptyDirCleanupSec = undefined;
      this._enableAssumeRole = undefined;
      this._enablePageChecksum = undefined;
      this._enableStatistics = undefined;
      this._enableWritePageIndex = undefined;
      this._endpoint = undefined;
      this._environment = undefined;
      this._fileNameSuffix = undefined;
      this._format = undefined;
      this._headerLine = undefined;
      this._id = undefined;
      this._keyValueMetadata.internalValue = undefined;
      this._kmsKeyId = undefined;
      this._maxClosingFilesToBackpressure = undefined;
      this._maxConcurrentFileParts = undefined;
      this._maxFileIdleTimeSec = undefined;
      this._maxFileOpenTimeSec = undefined;
      this._maxFileSizeMb = undefined;
      this._maxOpenFiles = undefined;
      this._maxRetryNum = undefined;
      this._objectAcl = undefined;
      this._onDiskFullBackpressure = undefined;
      this._parquetDataPageVersion = undefined;
      this._parquetPageSize = undefined;
      this._parquetRowGroupLength = undefined;
      this._parquetVersion = undefined;
      this._partitioningFields = undefined;
      this._pipeline = undefined;
      this._region = undefined;
      this._rejectUnauthorized = undefined;
      this._removeEmptyDirs = undefined;
      this._reuseConnections = undefined;
      this._serverSideEncryption = undefined;
      this._shouldLogInvalidRows = undefined;
      this._signatureVersion = undefined;
      this._stagePath = undefined;
      this._storageClass = undefined;
      this._streamtags = undefined;
      this._systemFields = undefined;
      this._type = undefined;
      this._verifyPermissions = undefined;
      this._writeHighWaterMark = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._addIdToStagePath = value.addIdToStagePath;
      this._assumeRoleArn = value.assumeRoleArn;
      this._assumeRoleExternalId = value.assumeRoleExternalId;
      this._automaticSchema = value.automaticSchema;
      this._awsApiKey = value.awsApiKey;
      this._awsAuthenticationMethod = value.awsAuthenticationMethod;
      this._awsSecret = value.awsSecret;
      this._awsSecretKey = value.awsSecretKey;
      this._baseFileName = value.baseFileName;
      this._bucket = value.bucket;
      this._compress = value.compress;
      this._compressionLevel = value.compressionLevel;
      this._deadletterEnabled = value.deadletterEnabled;
      this._deadletterPath = value.deadletterPath;
      this._description = value.description;
      this._destPath = value.destPath;
      this._durationSeconds = value.durationSeconds;
      this._emptyDirCleanupSec = value.emptyDirCleanupSec;
      this._enableAssumeRole = value.enableAssumeRole;
      this._enablePageChecksum = value.enablePageChecksum;
      this._enableStatistics = value.enableStatistics;
      this._enableWritePageIndex = value.enableWritePageIndex;
      this._endpoint = value.endpoint;
      this._environment = value.environment;
      this._fileNameSuffix = value.fileNameSuffix;
      this._format = value.format;
      this._headerLine = value.headerLine;
      this._id = value.id;
      this._keyValueMetadata.internalValue = value.keyValueMetadata;
      this._kmsKeyId = value.kmsKeyId;
      this._maxClosingFilesToBackpressure = value.maxClosingFilesToBackpressure;
      this._maxConcurrentFileParts = value.maxConcurrentFileParts;
      this._maxFileIdleTimeSec = value.maxFileIdleTimeSec;
      this._maxFileOpenTimeSec = value.maxFileOpenTimeSec;
      this._maxFileSizeMb = value.maxFileSizeMb;
      this._maxOpenFiles = value.maxOpenFiles;
      this._maxRetryNum = value.maxRetryNum;
      this._objectAcl = value.objectAcl;
      this._onDiskFullBackpressure = value.onDiskFullBackpressure;
      this._parquetDataPageVersion = value.parquetDataPageVersion;
      this._parquetPageSize = value.parquetPageSize;
      this._parquetRowGroupLength = value.parquetRowGroupLength;
      this._parquetVersion = value.parquetVersion;
      this._partitioningFields = value.partitioningFields;
      this._pipeline = value.pipeline;
      this._region = value.region;
      this._rejectUnauthorized = value.rejectUnauthorized;
      this._removeEmptyDirs = value.removeEmptyDirs;
      this._reuseConnections = value.reuseConnections;
      this._serverSideEncryption = value.serverSideEncryption;
      this._shouldLogInvalidRows = value.shouldLogInvalidRows;
      this._signatureVersion = value.signatureVersion;
      this._stagePath = value.stagePath;
      this._storageClass = value.storageClass;
      this._streamtags = value.streamtags;
      this._systemFields = value.systemFields;
      this._type = value.type;
      this._verifyPermissions = value.verifyPermissions;
      this._writeHighWaterMark = value.writeHighWaterMark;
    }
  }

  // add_id_to_stage_path - computed: true, optional: true, required: false
  private _addIdToStagePath?: boolean | cdktf.IResolvable; 
  public get addIdToStagePath() {
    return this.getBooleanAttribute('add_id_to_stage_path');
  }
  public set addIdToStagePath(value: boolean | cdktf.IResolvable) {
    this._addIdToStagePath = value;
  }
  public resetAddIdToStagePath() {
    this._addIdToStagePath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addIdToStagePathInput() {
    return this._addIdToStagePath;
  }

  // assume_role_arn - computed: false, optional: true, required: false
  private _assumeRoleArn?: string; 
  public get assumeRoleArn() {
    return this.getStringAttribute('assume_role_arn');
  }
  public set assumeRoleArn(value: string) {
    this._assumeRoleArn = value;
  }
  public resetAssumeRoleArn() {
    this._assumeRoleArn = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get assumeRoleArnInput() {
    return this._assumeRoleArn;
  }

  // assume_role_external_id - computed: false, optional: true, required: false
  private _assumeRoleExternalId?: string; 
  public get assumeRoleExternalId() {
    return this.getStringAttribute('assume_role_external_id');
  }
  public set assumeRoleExternalId(value: string) {
    this._assumeRoleExternalId = value;
  }
  public resetAssumeRoleExternalId() {
    this._assumeRoleExternalId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get assumeRoleExternalIdInput() {
    return this._assumeRoleExternalId;
  }

  // automatic_schema - computed: true, optional: true, required: false
  private _automaticSchema?: boolean | cdktf.IResolvable; 
  public get automaticSchema() {
    return this.getBooleanAttribute('automatic_schema');
  }
  public set automaticSchema(value: boolean | cdktf.IResolvable) {
    this._automaticSchema = value;
  }
  public resetAutomaticSchema() {
    this._automaticSchema = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get automaticSchemaInput() {
    return this._automaticSchema;
  }

  // aws_api_key - computed: false, optional: true, required: false
  private _awsApiKey?: string; 
  public get awsApiKey() {
    return this.getStringAttribute('aws_api_key');
  }
  public set awsApiKey(value: string) {
    this._awsApiKey = value;
  }
  public resetAwsApiKey() {
    this._awsApiKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsApiKeyInput() {
    return this._awsApiKey;
  }

  // aws_authentication_method - computed: true, optional: true, required: false
  private _awsAuthenticationMethod?: string; 
  public get awsAuthenticationMethod() {
    return this.getStringAttribute('aws_authentication_method');
  }
  public set awsAuthenticationMethod(value: string) {
    this._awsAuthenticationMethod = value;
  }
  public resetAwsAuthenticationMethod() {
    this._awsAuthenticationMethod = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsAuthenticationMethodInput() {
    return this._awsAuthenticationMethod;
  }

  // aws_secret - computed: false, optional: true, required: false
  private _awsSecret?: string; 
  public get awsSecret() {
    return this.getStringAttribute('aws_secret');
  }
  public set awsSecret(value: string) {
    this._awsSecret = value;
  }
  public resetAwsSecret() {
    this._awsSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsSecretInput() {
    return this._awsSecret;
  }

  // aws_secret_key - computed: false, optional: true, required: false
  private _awsSecretKey?: string; 
  public get awsSecretKey() {
    return this.getStringAttribute('aws_secret_key');
  }
  public set awsSecretKey(value: string) {
    this._awsSecretKey = value;
  }
  public resetAwsSecretKey() {
    this._awsSecretKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsSecretKeyInput() {
    return this._awsSecretKey;
  }

  // base_file_name - computed: true, optional: true, required: false
  private _baseFileName?: string; 
  public get baseFileName() {
    return this.getStringAttribute('base_file_name');
  }
  public set baseFileName(value: string) {
    this._baseFileName = value;
  }
  public resetBaseFileName() {
    this._baseFileName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get baseFileNameInput() {
    return this._baseFileName;
  }

  // bucket - computed: false, optional: false, required: true
  private _bucket?: string; 
  public get bucket() {
    return this.getStringAttribute('bucket');
  }
  public set bucket(value: string) {
    this._bucket = value;
  }
  // Temporarily expose input value. Use with caution.
  public get bucketInput() {
    return this._bucket;
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: string; 
  public get compress() {
    return this.getStringAttribute('compress');
  }
  public set compress(value: string) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // compression_level - computed: true, optional: true, required: false
  private _compressionLevel?: string; 
  public get compressionLevel() {
    return this.getStringAttribute('compression_level');
  }
  public set compressionLevel(value: string) {
    this._compressionLevel = value;
  }
  public resetCompressionLevel() {
    this._compressionLevel = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressionLevelInput() {
    return this._compressionLevel;
  }

  // deadletter_enabled - computed: true, optional: true, required: false
  private _deadletterEnabled?: boolean | cdktf.IResolvable; 
  public get deadletterEnabled() {
    return this.getBooleanAttribute('deadletter_enabled');
  }
  public set deadletterEnabled(value: boolean | cdktf.IResolvable) {
    this._deadletterEnabled = value;
  }
  public resetDeadletterEnabled() {
    this._deadletterEnabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get deadletterEnabledInput() {
    return this._deadletterEnabled;
  }

  // deadletter_path - computed: true, optional: true, required: false
  private _deadletterPath?: string; 
  public get deadletterPath() {
    return this.getStringAttribute('deadletter_path');
  }
  public set deadletterPath(value: string) {
    this._deadletterPath = value;
  }
  public resetDeadletterPath() {
    this._deadletterPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get deadletterPathInput() {
    return this._deadletterPath;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // dest_path - computed: true, optional: true, required: false
  private _destPath?: string; 
  public get destPath() {
    return this.getStringAttribute('dest_path');
  }
  public set destPath(value: string) {
    this._destPath = value;
  }
  public resetDestPath() {
    this._destPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get destPathInput() {
    return this._destPath;
  }

  // duration_seconds - computed: true, optional: true, required: false
  private _durationSeconds?: number; 
  public get durationSeconds() {
    return this.getNumberAttribute('duration_seconds');
  }
  public set durationSeconds(value: number) {
    this._durationSeconds = value;
  }
  public resetDurationSeconds() {
    this._durationSeconds = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get durationSecondsInput() {
    return this._durationSeconds;
  }

  // empty_dir_cleanup_sec - computed: true, optional: true, required: false
  private _emptyDirCleanupSec?: number; 
  public get emptyDirCleanupSec() {
    return this.getNumberAttribute('empty_dir_cleanup_sec');
  }
  public set emptyDirCleanupSec(value: number) {
    this._emptyDirCleanupSec = value;
  }
  public resetEmptyDirCleanupSec() {
    this._emptyDirCleanupSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get emptyDirCleanupSecInput() {
    return this._emptyDirCleanupSec;
  }

  // enable_assume_role - computed: true, optional: true, required: false
  private _enableAssumeRole?: boolean | cdktf.IResolvable; 
  public get enableAssumeRole() {
    return this.getBooleanAttribute('enable_assume_role');
  }
  public set enableAssumeRole(value: boolean | cdktf.IResolvable) {
    this._enableAssumeRole = value;
  }
  public resetEnableAssumeRole() {
    this._enableAssumeRole = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableAssumeRoleInput() {
    return this._enableAssumeRole;
  }

  // enable_page_checksum - computed: true, optional: true, required: false
  private _enablePageChecksum?: boolean | cdktf.IResolvable; 
  public get enablePageChecksum() {
    return this.getBooleanAttribute('enable_page_checksum');
  }
  public set enablePageChecksum(value: boolean | cdktf.IResolvable) {
    this._enablePageChecksum = value;
  }
  public resetEnablePageChecksum() {
    this._enablePageChecksum = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enablePageChecksumInput() {
    return this._enablePageChecksum;
  }

  // enable_statistics - computed: true, optional: true, required: false
  private _enableStatistics?: boolean | cdktf.IResolvable; 
  public get enableStatistics() {
    return this.getBooleanAttribute('enable_statistics');
  }
  public set enableStatistics(value: boolean | cdktf.IResolvable) {
    this._enableStatistics = value;
  }
  public resetEnableStatistics() {
    this._enableStatistics = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableStatisticsInput() {
    return this._enableStatistics;
  }

  // enable_write_page_index - computed: true, optional: true, required: false
  private _enableWritePageIndex?: boolean | cdktf.IResolvable; 
  public get enableWritePageIndex() {
    return this.getBooleanAttribute('enable_write_page_index');
  }
  public set enableWritePageIndex(value: boolean | cdktf.IResolvable) {
    this._enableWritePageIndex = value;
  }
  public resetEnableWritePageIndex() {
    this._enableWritePageIndex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableWritePageIndexInput() {
    return this._enableWritePageIndex;
  }

  // endpoint - computed: false, optional: true, required: false
  private _endpoint?: string; 
  public get endpoint() {
    return this.getStringAttribute('endpoint');
  }
  public set endpoint(value: string) {
    this._endpoint = value;
  }
  public resetEndpoint() {
    this._endpoint = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get endpointInput() {
    return this._endpoint;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // file_name_suffix - computed: true, optional: true, required: false
  private _fileNameSuffix?: string; 
  public get fileNameSuffix() {
    return this.getStringAttribute('file_name_suffix');
  }
  public set fileNameSuffix(value: string) {
    this._fileNameSuffix = value;
  }
  public resetFileNameSuffix() {
    this._fileNameSuffix = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fileNameSuffixInput() {
    return this._fileNameSuffix;
  }

  // format - computed: true, optional: true, required: false
  private _format?: string; 
  public get format() {
    return this.getStringAttribute('format');
  }
  public set format(value: string) {
    this._format = value;
  }
  public resetFormat() {
    this._format = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get formatInput() {
    return this._format;
  }

  // header_line - computed: true, optional: true, required: false
  private _headerLine?: string; 
  public get headerLine() {
    return this.getStringAttribute('header_line');
  }
  public set headerLine(value: string) {
    this._headerLine = value;
  }
  public resetHeaderLine() {
    this._headerLine = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get headerLineInput() {
    return this._headerLine;
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // key_value_metadata - computed: false, optional: true, required: false
  private _keyValueMetadata = new PackDestinationOutputDlS3KeyValueMetadataList(this, "key_value_metadata", false);
  public get keyValueMetadata() {
    return this._keyValueMetadata;
  }
  public putKeyValueMetadata(value: PackDestinationOutputDlS3KeyValueMetadata[] | cdktf.IResolvable) {
    this._keyValueMetadata.internalValue = value;
  }
  public resetKeyValueMetadata() {
    this._keyValueMetadata.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyValueMetadataInput() {
    return this._keyValueMetadata.internalValue;
  }

  // kms_key_id - computed: false, optional: true, required: false
  private _kmsKeyId?: string; 
  public get kmsKeyId() {
    return this.getStringAttribute('kms_key_id');
  }
  public set kmsKeyId(value: string) {
    this._kmsKeyId = value;
  }
  public resetKmsKeyId() {
    this._kmsKeyId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get kmsKeyIdInput() {
    return this._kmsKeyId;
  }

  // max_closing_files_to_backpressure - computed: true, optional: true, required: false
  private _maxClosingFilesToBackpressure?: number; 
  public get maxClosingFilesToBackpressure() {
    return this.getNumberAttribute('max_closing_files_to_backpressure');
  }
  public set maxClosingFilesToBackpressure(value: number) {
    this._maxClosingFilesToBackpressure = value;
  }
  public resetMaxClosingFilesToBackpressure() {
    this._maxClosingFilesToBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxClosingFilesToBackpressureInput() {
    return this._maxClosingFilesToBackpressure;
  }

  // max_concurrent_file_parts - computed: true, optional: true, required: false
  private _maxConcurrentFileParts?: number; 
  public get maxConcurrentFileParts() {
    return this.getNumberAttribute('max_concurrent_file_parts');
  }
  public set maxConcurrentFileParts(value: number) {
    this._maxConcurrentFileParts = value;
  }
  public resetMaxConcurrentFileParts() {
    this._maxConcurrentFileParts = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxConcurrentFilePartsInput() {
    return this._maxConcurrentFileParts;
  }

  // max_file_idle_time_sec - computed: true, optional: true, required: false
  private _maxFileIdleTimeSec?: number; 
  public get maxFileIdleTimeSec() {
    return this.getNumberAttribute('max_file_idle_time_sec');
  }
  public set maxFileIdleTimeSec(value: number) {
    this._maxFileIdleTimeSec = value;
  }
  public resetMaxFileIdleTimeSec() {
    this._maxFileIdleTimeSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxFileIdleTimeSecInput() {
    return this._maxFileIdleTimeSec;
  }

  // max_file_open_time_sec - computed: true, optional: true, required: false
  private _maxFileOpenTimeSec?: number; 
  public get maxFileOpenTimeSec() {
    return this.getNumberAttribute('max_file_open_time_sec');
  }
  public set maxFileOpenTimeSec(value: number) {
    this._maxFileOpenTimeSec = value;
  }
  public resetMaxFileOpenTimeSec() {
    this._maxFileOpenTimeSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxFileOpenTimeSecInput() {
    return this._maxFileOpenTimeSec;
  }

  // max_file_size_mb - computed: true, optional: true, required: false
  private _maxFileSizeMb?: number; 
  public get maxFileSizeMb() {
    return this.getNumberAttribute('max_file_size_mb');
  }
  public set maxFileSizeMb(value: number) {
    this._maxFileSizeMb = value;
  }
  public resetMaxFileSizeMb() {
    this._maxFileSizeMb = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxFileSizeMbInput() {
    return this._maxFileSizeMb;
  }

  // max_open_files - computed: true, optional: true, required: false
  private _maxOpenFiles?: number; 
  public get maxOpenFiles() {
    return this.getNumberAttribute('max_open_files');
  }
  public set maxOpenFiles(value: number) {
    this._maxOpenFiles = value;
  }
  public resetMaxOpenFiles() {
    this._maxOpenFiles = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxOpenFilesInput() {
    return this._maxOpenFiles;
  }

  // max_retry_num - computed: true, optional: true, required: false
  private _maxRetryNum?: number; 
  public get maxRetryNum() {
    return this.getNumberAttribute('max_retry_num');
  }
  public set maxRetryNum(value: number) {
    this._maxRetryNum = value;
  }
  public resetMaxRetryNum() {
    this._maxRetryNum = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxRetryNumInput() {
    return this._maxRetryNum;
  }

  // object_acl - computed: true, optional: true, required: false
  private _objectAcl?: string; 
  public get objectAcl() {
    return this.getStringAttribute('object_acl');
  }
  public set objectAcl(value: string) {
    this._objectAcl = value;
  }
  public resetObjectAcl() {
    this._objectAcl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get objectAclInput() {
    return this._objectAcl;
  }

  // on_disk_full_backpressure - computed: true, optional: true, required: false
  private _onDiskFullBackpressure?: string; 
  public get onDiskFullBackpressure() {
    return this.getStringAttribute('on_disk_full_backpressure');
  }
  public set onDiskFullBackpressure(value: string) {
    this._onDiskFullBackpressure = value;
  }
  public resetOnDiskFullBackpressure() {
    this._onDiskFullBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get onDiskFullBackpressureInput() {
    return this._onDiskFullBackpressure;
  }

  // parquet_data_page_version - computed: true, optional: true, required: false
  private _parquetDataPageVersion?: string; 
  public get parquetDataPageVersion() {
    return this.getStringAttribute('parquet_data_page_version');
  }
  public set parquetDataPageVersion(value: string) {
    this._parquetDataPageVersion = value;
  }
  public resetParquetDataPageVersion() {
    this._parquetDataPageVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get parquetDataPageVersionInput() {
    return this._parquetDataPageVersion;
  }

  // parquet_page_size - computed: true, optional: true, required: false
  private _parquetPageSize?: string; 
  public get parquetPageSize() {
    return this.getStringAttribute('parquet_page_size');
  }
  public set parquetPageSize(value: string) {
    this._parquetPageSize = value;
  }
  public resetParquetPageSize() {
    this._parquetPageSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get parquetPageSizeInput() {
    return this._parquetPageSize;
  }

  // parquet_row_group_length - computed: true, optional: true, required: false
  private _parquetRowGroupLength?: number; 
  public get parquetRowGroupLength() {
    return this.getNumberAttribute('parquet_row_group_length');
  }
  public set parquetRowGroupLength(value: number) {
    this._parquetRowGroupLength = value;
  }
  public resetParquetRowGroupLength() {
    this._parquetRowGroupLength = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get parquetRowGroupLengthInput() {
    return this._parquetRowGroupLength;
  }

  // parquet_version - computed: true, optional: true, required: false
  private _parquetVersion?: string; 
  public get parquetVersion() {
    return this.getStringAttribute('parquet_version');
  }
  public set parquetVersion(value: string) {
    this._parquetVersion = value;
  }
  public resetParquetVersion() {
    this._parquetVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get parquetVersionInput() {
    return this._parquetVersion;
  }

  // partitioning_fields - computed: true, optional: true, required: false
  private _partitioningFields?: string[]; 
  public get partitioningFields() {
    return this.getListAttribute('partitioning_fields');
  }
  public set partitioningFields(value: string[]) {
    this._partitioningFields = value;
  }
  public resetPartitioningFields() {
    this._partitioningFields = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get partitioningFieldsInput() {
    return this._partitioningFields;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // region - computed: false, optional: true, required: false
  private _region?: string; 
  public get region() {
    return this.getStringAttribute('region');
  }
  public set region(value: string) {
    this._region = value;
  }
  public resetRegion() {
    this._region = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get regionInput() {
    return this._region;
  }

  // reject_unauthorized - computed: true, optional: true, required: false
  private _rejectUnauthorized?: boolean | cdktf.IResolvable; 
  public get rejectUnauthorized() {
    return this.getBooleanAttribute('reject_unauthorized');
  }
  public set rejectUnauthorized(value: boolean | cdktf.IResolvable) {
    this._rejectUnauthorized = value;
  }
  public resetRejectUnauthorized() {
    this._rejectUnauthorized = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectUnauthorizedInput() {
    return this._rejectUnauthorized;
  }

  // remove_empty_dirs - computed: true, optional: true, required: false
  private _removeEmptyDirs?: boolean | cdktf.IResolvable; 
  public get removeEmptyDirs() {
    return this.getBooleanAttribute('remove_empty_dirs');
  }
  public set removeEmptyDirs(value: boolean | cdktf.IResolvable) {
    this._removeEmptyDirs = value;
  }
  public resetRemoveEmptyDirs() {
    this._removeEmptyDirs = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get removeEmptyDirsInput() {
    return this._removeEmptyDirs;
  }

  // reuse_connections - computed: true, optional: true, required: false
  private _reuseConnections?: boolean | cdktf.IResolvable; 
  public get reuseConnections() {
    return this.getBooleanAttribute('reuse_connections');
  }
  public set reuseConnections(value: boolean | cdktf.IResolvable) {
    this._reuseConnections = value;
  }
  public resetReuseConnections() {
    this._reuseConnections = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get reuseConnectionsInput() {
    return this._reuseConnections;
  }

  // server_side_encryption - computed: false, optional: true, required: false
  private _serverSideEncryption?: string; 
  public get serverSideEncryption() {
    return this.getStringAttribute('server_side_encryption');
  }
  public set serverSideEncryption(value: string) {
    this._serverSideEncryption = value;
  }
  public resetServerSideEncryption() {
    this._serverSideEncryption = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serverSideEncryptionInput() {
    return this._serverSideEncryption;
  }

  // should_log_invalid_rows - computed: false, optional: true, required: false
  private _shouldLogInvalidRows?: boolean | cdktf.IResolvable; 
  public get shouldLogInvalidRows() {
    return this.getBooleanAttribute('should_log_invalid_rows');
  }
  public set shouldLogInvalidRows(value: boolean | cdktf.IResolvable) {
    this._shouldLogInvalidRows = value;
  }
  public resetShouldLogInvalidRows() {
    this._shouldLogInvalidRows = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get shouldLogInvalidRowsInput() {
    return this._shouldLogInvalidRows;
  }

  // signature_version - computed: true, optional: true, required: false
  private _signatureVersion?: string; 
  public get signatureVersion() {
    return this.getStringAttribute('signature_version');
  }
  public set signatureVersion(value: string) {
    this._signatureVersion = value;
  }
  public resetSignatureVersion() {
    this._signatureVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get signatureVersionInput() {
    return this._signatureVersion;
  }

  // stage_path - computed: true, optional: true, required: false
  private _stagePath?: string; 
  public get stagePath() {
    return this.getStringAttribute('stage_path');
  }
  public set stagePath(value: string) {
    this._stagePath = value;
  }
  public resetStagePath() {
    this._stagePath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get stagePathInput() {
    return this._stagePath;
  }

  // storage_class - computed: false, optional: true, required: false
  private _storageClass?: string; 
  public get storageClass() {
    return this.getStringAttribute('storage_class');
  }
  public set storageClass(value: string) {
    this._storageClass = value;
  }
  public resetStorageClass() {
    this._storageClass = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get storageClassInput() {
    return this._storageClass;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // system_fields - computed: true, optional: true, required: false
  private _systemFields?: string[]; 
  public get systemFields() {
    return this.getListAttribute('system_fields');
  }
  public set systemFields(value: string[]) {
    this._systemFields = value;
  }
  public resetSystemFields() {
    this._systemFields = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get systemFieldsInput() {
    return this._systemFields;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // verify_permissions - computed: true, optional: true, required: false
  private _verifyPermissions?: boolean | cdktf.IResolvable; 
  public get verifyPermissions() {
    return this.getBooleanAttribute('verify_permissions');
  }
  public set verifyPermissions(value: boolean | cdktf.IResolvable) {
    this._verifyPermissions = value;
  }
  public resetVerifyPermissions() {
    this._verifyPermissions = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get verifyPermissionsInput() {
    return this._verifyPermissions;
  }

  // write_high_water_mark - computed: true, optional: true, required: false
  private _writeHighWaterMark?: number; 
  public get writeHighWaterMark() {
    return this.getNumberAttribute('write_high_water_mark');
  }
  public set writeHighWaterMark(value: number) {
    this._writeHighWaterMark = value;
  }
  public resetWriteHighWaterMark() {
    this._writeHighWaterMark = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get writeHighWaterMarkInput() {
    return this._writeHighWaterMark;
  }
}
export interface PackDestinationOutputDynatraceHttpExtraHttpHeaders {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#name PackDestination#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#value PackDestination#value}
  */
  readonly value: string;
}

export function packDestinationOutputDynatraceHttpExtraHttpHeadersToTerraform(struct?: PackDestinationOutputDynatraceHttpExtraHttpHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function packDestinationOutputDynatraceHttpExtraHttpHeadersToHclTerraform(struct?: PackDestinationOutputDynatraceHttpExtraHttpHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputDynatraceHttpExtraHttpHeadersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackDestinationOutputDynatraceHttpExtraHttpHeaders | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputDynatraceHttpExtraHttpHeaders | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class PackDestinationOutputDynatraceHttpExtraHttpHeadersList extends cdktf.ComplexList {
  public internalValue? : PackDestinationOutputDynatraceHttpExtraHttpHeaders[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackDestinationOutputDynatraceHttpExtraHttpHeadersOutputReference {
    return new PackDestinationOutputDynatraceHttpExtraHttpHeadersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackDestinationOutputDynatraceHttpPqControls {
}

export function packDestinationOutputDynatraceHttpPqControlsToTerraform(struct?: PackDestinationOutputDynatraceHttpPqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function packDestinationOutputDynatraceHttpPqControlsToHclTerraform(struct?: PackDestinationOutputDynatraceHttpPqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class PackDestinationOutputDynatraceHttpPqControlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackDestinationOutputDynatraceHttpPqControls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputDynatraceHttpPqControls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface PackDestinationOutputDynatraceHttpResponseRetrySettings {
  /**
  * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc. Default: 2
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#backoff_rate PackDestination#backoff_rate}
  */
  readonly backoffRate?: number;
  /**
  * The HTTP response status code that will trigger retries
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#http_status PackDestination#http_status}
  */
  readonly httpStatus: number;
  /**
  * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes). Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#initial_backoff PackDestination#initial_backoff}
  */
  readonly initialBackoff?: number;
  /**
  * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds). Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_backoff PackDestination#max_backoff}
  */
  readonly maxBackoff?: number;
}

export function packDestinationOutputDynatraceHttpResponseRetrySettingsToTerraform(struct?: PackDestinationOutputDynatraceHttpResponseRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    backoff_rate: cdktf.numberToTerraform(struct!.backoffRate),
    http_status: cdktf.numberToTerraform(struct!.httpStatus),
    initial_backoff: cdktf.numberToTerraform(struct!.initialBackoff),
    max_backoff: cdktf.numberToTerraform(struct!.maxBackoff),
  }
}


export function packDestinationOutputDynatraceHttpResponseRetrySettingsToHclTerraform(struct?: PackDestinationOutputDynatraceHttpResponseRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    backoff_rate: {
      value: cdktf.numberToHclTerraform(struct!.backoffRate),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    http_status: {
      value: cdktf.numberToHclTerraform(struct!.httpStatus),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    initial_backoff: {
      value: cdktf.numberToHclTerraform(struct!.initialBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_backoff: {
      value: cdktf.numberToHclTerraform(struct!.maxBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputDynatraceHttpResponseRetrySettingsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackDestinationOutputDynatraceHttpResponseRetrySettings | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._backoffRate !== undefined) {
      hasAnyValues = true;
      internalValueResult.backoffRate = this._backoffRate;
    }
    if (this._httpStatus !== undefined) {
      hasAnyValues = true;
      internalValueResult.httpStatus = this._httpStatus;
    }
    if (this._initialBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.initialBackoff = this._initialBackoff;
    }
    if (this._maxBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBackoff = this._maxBackoff;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputDynatraceHttpResponseRetrySettings | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._backoffRate = undefined;
      this._httpStatus = undefined;
      this._initialBackoff = undefined;
      this._maxBackoff = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._backoffRate = value.backoffRate;
      this._httpStatus = value.httpStatus;
      this._initialBackoff = value.initialBackoff;
      this._maxBackoff = value.maxBackoff;
    }
  }

  // backoff_rate - computed: true, optional: true, required: false
  private _backoffRate?: number; 
  public get backoffRate() {
    return this.getNumberAttribute('backoff_rate');
  }
  public set backoffRate(value: number) {
    this._backoffRate = value;
  }
  public resetBackoffRate() {
    this._backoffRate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get backoffRateInput() {
    return this._backoffRate;
  }

  // http_status - computed: false, optional: false, required: true
  private _httpStatus?: number; 
  public get httpStatus() {
    return this.getNumberAttribute('http_status');
  }
  public set httpStatus(value: number) {
    this._httpStatus = value;
  }
  // Temporarily expose input value. Use with caution.
  public get httpStatusInput() {
    return this._httpStatus;
  }

  // initial_backoff - computed: true, optional: true, required: false
  private _initialBackoff?: number; 
  public get initialBackoff() {
    return this.getNumberAttribute('initial_backoff');
  }
  public set initialBackoff(value: number) {
    this._initialBackoff = value;
  }
  public resetInitialBackoff() {
    this._initialBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get initialBackoffInput() {
    return this._initialBackoff;
  }

  // max_backoff - computed: true, optional: true, required: false
  private _maxBackoff?: number; 
  public get maxBackoff() {
    return this.getNumberAttribute('max_backoff');
  }
  public set maxBackoff(value: number) {
    this._maxBackoff = value;
  }
  public resetMaxBackoff() {
    this._maxBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBackoffInput() {
    return this._maxBackoff;
  }
}

export class PackDestinationOutputDynatraceHttpResponseRetrySettingsList extends cdktf.ComplexList {
  public internalValue? : PackDestinationOutputDynatraceHttpResponseRetrySettings[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackDestinationOutputDynatraceHttpResponseRetrySettingsOutputReference {
    return new PackDestinationOutputDynatraceHttpResponseRetrySettingsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackDestinationOutputDynatraceHttpTimeoutRetrySettings {
  /**
  * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc. Default: 2
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#backoff_rate PackDestination#backoff_rate}
  */
  readonly backoffRate?: number;
  /**
  * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes). Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#initial_backoff PackDestination#initial_backoff}
  */
  readonly initialBackoff?: number;
  /**
  * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds). Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_backoff PackDestination#max_backoff}
  */
  readonly maxBackoff?: number;
  /**
  * Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#timeout_retry PackDestination#timeout_retry}
  */
  readonly timeoutRetry?: boolean | cdktf.IResolvable;
}

export function packDestinationOutputDynatraceHttpTimeoutRetrySettingsToTerraform(struct?: PackDestinationOutputDynatraceHttpTimeoutRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    backoff_rate: cdktf.numberToTerraform(struct!.backoffRate),
    initial_backoff: cdktf.numberToTerraform(struct!.initialBackoff),
    max_backoff: cdktf.numberToTerraform(struct!.maxBackoff),
    timeout_retry: cdktf.booleanToTerraform(struct!.timeoutRetry),
  }
}


export function packDestinationOutputDynatraceHttpTimeoutRetrySettingsToHclTerraform(struct?: PackDestinationOutputDynatraceHttpTimeoutRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    backoff_rate: {
      value: cdktf.numberToHclTerraform(struct!.backoffRate),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    initial_backoff: {
      value: cdktf.numberToHclTerraform(struct!.initialBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_backoff: {
      value: cdktf.numberToHclTerraform(struct!.maxBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    timeout_retry: {
      value: cdktf.booleanToHclTerraform(struct!.timeoutRetry),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputDynatraceHttpTimeoutRetrySettingsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackDestinationOutputDynatraceHttpTimeoutRetrySettings | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._backoffRate !== undefined) {
      hasAnyValues = true;
      internalValueResult.backoffRate = this._backoffRate;
    }
    if (this._initialBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.initialBackoff = this._initialBackoff;
    }
    if (this._maxBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBackoff = this._maxBackoff;
    }
    if (this._timeoutRetry !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutRetry = this._timeoutRetry;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputDynatraceHttpTimeoutRetrySettings | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._backoffRate = undefined;
      this._initialBackoff = undefined;
      this._maxBackoff = undefined;
      this._timeoutRetry = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._backoffRate = value.backoffRate;
      this._initialBackoff = value.initialBackoff;
      this._maxBackoff = value.maxBackoff;
      this._timeoutRetry = value.timeoutRetry;
    }
  }

  // backoff_rate - computed: true, optional: true, required: false
  private _backoffRate?: number; 
  public get backoffRate() {
    return this.getNumberAttribute('backoff_rate');
  }
  public set backoffRate(value: number) {
    this._backoffRate = value;
  }
  public resetBackoffRate() {
    this._backoffRate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get backoffRateInput() {
    return this._backoffRate;
  }

  // initial_backoff - computed: true, optional: true, required: false
  private _initialBackoff?: number; 
  public get initialBackoff() {
    return this.getNumberAttribute('initial_backoff');
  }
  public set initialBackoff(value: number) {
    this._initialBackoff = value;
  }
  public resetInitialBackoff() {
    this._initialBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get initialBackoffInput() {
    return this._initialBackoff;
  }

  // max_backoff - computed: true, optional: true, required: false
  private _maxBackoff?: number; 
  public get maxBackoff() {
    return this.getNumberAttribute('max_backoff');
  }
  public set maxBackoff(value: number) {
    this._maxBackoff = value;
  }
  public resetMaxBackoff() {
    this._maxBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBackoffInput() {
    return this._maxBackoff;
  }

  // timeout_retry - computed: true, optional: true, required: false
  private _timeoutRetry?: boolean | cdktf.IResolvable; 
  public get timeoutRetry() {
    return this.getBooleanAttribute('timeout_retry');
  }
  public set timeoutRetry(value: boolean | cdktf.IResolvable) {
    this._timeoutRetry = value;
  }
  public resetTimeoutRetry() {
    this._timeoutRetry = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutRetryInput() {
    return this._timeoutRetry;
  }
}
export interface PackDestinationOutputDynatraceHttp {
  /**
  * ActiveGate domain with Log analytics collector module enabled. For example https://{activeGate-domain}:9999/e/{environment-id}/api/v2/logs/ingest.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#active_gate_domain PackDestination#active_gate_domain}
  */
  readonly activeGateDomain?: string;
  /**
  * Default: "token"; must be one of ["token", "textSecret"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#auth_type PackDestination#auth_type}
  */
  readonly authType?: string;
  /**
  * Compress the payload body before sending. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#compress PackDestination#compress}
  */
  readonly compress?: boolean | cdktf.IResolvable;
  /**
  * Maximum number of ongoing requests before blocking. Default: 5
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#concurrency PackDestination#concurrency}
  */
  readonly concurrency?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#description PackDestination#description}
  */
  readonly description?: string;
  /**
  * Default: "cloud"; must be one of ["cloud", "activeGate", "manual"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#endpoint PackDestination#endpoint}
  */
  readonly endpoint?: string;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#environment PackDestination#environment}
  */
  readonly environment?: string;
  /**
  * ID of the environment to send to
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#environment_id PackDestination#environment_id}
  */
  readonly environmentId?: string;
  /**
  * Headers to add to all events. You can also add headers dynamically on a per-event basis in the __headers field, as explained in [Cribl Docs](https://docs.cribl.io/stream/destinations-webhook/#internal-fields).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#extra_http_headers PackDestination#extra_http_headers}
  */
  readonly extraHttpHeaders?: PackDestinationOutputDynatraceHttpExtraHttpHeaders[] | cdktf.IResolvable;
  /**
  * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below. Default: "none"; must be one of ["payload", "payloadAndHeaders", "none"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#failed_request_logging_mode PackDestination#failed_request_logging_mode}
  */
  readonly failedRequestLoggingMode?: string;
  /**
  * Maximum time between requests. Small values could cause the payload size to be smaller than the configured Body size limit. Default: 1
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#flush_period_sec PackDestination#flush_period_sec}
  */
  readonly flushPeriodSec?: number;
  /**
  * How to format events before sending. Defaults to JSON. Plaintext is not currently supported. Default: "json_array"; must be one of ["json_array", "plaintext"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#format PackDestination#format}
  */
  readonly format?: string;
  /**
  * Unique ID for this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#id PackDestination#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * Disable to close the connection immediately after sending the outgoing request. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#keep_alive PackDestination#keep_alive}
  */
  readonly keepAlive?: boolean | cdktf.IResolvable;
  /**
  * Maximum number of events to include in the request body. Default is 0 (unlimited). Default: 0
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_payload_events PackDestination#max_payload_events}
  */
  readonly maxPayloadEvents?: number;
  /**
  * Maximum size, in KB, of the request body. Default: 4096
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_payload_size_kb PackDestination#max_payload_size_kb}
  */
  readonly maxPayloadSizeKb?: number;
  /**
  * The method to use when sending events. Default: "POST"; must be one of ["POST", "PUT", "PATCH"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#method PackDestination#method}
  */
  readonly method?: string;
  /**
  * How to handle events when all receivers are exerting backpressure. Default: "block"; must be one of ["block", "drop", "queue"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#on_backpressure PackDestination#on_backpressure}
  */
  readonly onBackpressure?: string;
  /**
  * Pipeline to process data before sending out to this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pipeline PackDestination#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_compress PackDestination#pq_compress}
  */
  readonly pqCompress?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_controls PackDestination#pq_controls}
  */
  readonly pqControls?: PackDestinationOutputDynatraceHttpPqControls;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.). Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_max_file_size PackDestination#pq_max_file_size}
  */
  readonly pqMaxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_max_size PackDestination#pq_max_size}
  */
  readonly pqMaxSize?: string;
  /**
  * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem. Default: "error"; must be one of ["error", "backpressure", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_mode PackDestination#pq_mode}
  */
  readonly pqMode?: string;
  /**
  * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged. Default: "block"; must be one of ["block", "drop"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_on_backpressure PackDestination#pq_on_backpressure}
  */
  readonly pqOnBackpressure?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_path PackDestination#pq_path}
  */
  readonly pqPath?: string;
  /**
  * Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's). 
  *         Enabled by default. When this setting is also present in TLS Settings (Client Side), 
  *         that value will take precedence.
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#reject_unauthorized PackDestination#reject_unauthorized}
  */
  readonly rejectUnauthorized?: boolean | cdktf.IResolvable;
  /**
  * Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#response_honor_retry_after_header PackDestination#response_honor_retry_after_header}
  */
  readonly responseHonorRetryAfterHeader?: boolean | cdktf.IResolvable;
  /**
  * Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#response_retry_settings PackDestination#response_retry_settings}
  */
  readonly responseRetrySettings?: PackDestinationOutputDynatraceHttpResponseRetrySettings[] | cdktf.IResolvable;
  /**
  * List of headers that are safe to log in plain text. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#safe_headers PackDestination#safe_headers}
  */
  readonly safeHeaders?: string[];
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#streamtags PackDestination#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Fields to automatically add to events, such as cribl_pipe. Supports wildcards. Default: ["cribl_pipe"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#system_fields PackDestination#system_fields}
  */
  readonly systemFields?: string[];
  /**
  * Default: "logs"; must be one of ["logs", "metrics"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#telemetry_type PackDestination#telemetry_type}
  */
  readonly telemetryType?: string;
  /**
  * Select or create a stored text secret
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#text_secret PackDestination#text_secret}
  */
  readonly textSecret?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#timeout_retry_settings PackDestination#timeout_retry_settings}
  */
  readonly timeoutRetrySettings?: PackDestinationOutputDynatraceHttpTimeoutRetrySettings;
  /**
  * Amount of time, in seconds, to wait for a request to complete before canceling it. Default: 30
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#timeout_sec PackDestination#timeout_sec}
  */
  readonly timeoutSec?: number;
  /**
  * Bearer token to include in the authorization header
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#token PackDestination#token}
  */
  readonly token?: string;
  /**
  * Maximum total size of the batches waiting to be sent. If left blank, defaults to 5 times the max body size (if set). If 0, no limit is enforced.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#total_memory_limit_kb PackDestination#total_memory_limit_kb}
  */
  readonly totalMemoryLimitKb?: number;
  /**
  * must be "dynatrace_http"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#type PackDestination#type}
  */
  readonly type?: string;
  /**
  * URL to send events to. Can be overwritten by an event's __url field.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#url PackDestination#url}
  */
  readonly url?: string;
  /**
  * Enable round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. For optimal performance, consider enabling this setting for non-load balanced destinations. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#use_round_robin_dns PackDestination#use_round_robin_dns}
  */
  readonly useRoundRobinDns?: boolean | cdktf.IResolvable;
}

export function packDestinationOutputDynatraceHttpToTerraform(struct?: PackDestinationOutputDynatraceHttp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    active_gate_domain: cdktf.stringToTerraform(struct!.activeGateDomain),
    auth_type: cdktf.stringToTerraform(struct!.authType),
    compress: cdktf.booleanToTerraform(struct!.compress),
    concurrency: cdktf.numberToTerraform(struct!.concurrency),
    description: cdktf.stringToTerraform(struct!.description),
    endpoint: cdktf.stringToTerraform(struct!.endpoint),
    environment: cdktf.stringToTerraform(struct!.environment),
    environment_id: cdktf.stringToTerraform(struct!.environmentId),
    extra_http_headers: cdktf.listMapper(packDestinationOutputDynatraceHttpExtraHttpHeadersToTerraform, false)(struct!.extraHttpHeaders),
    failed_request_logging_mode: cdktf.stringToTerraform(struct!.failedRequestLoggingMode),
    flush_period_sec: cdktf.numberToTerraform(struct!.flushPeriodSec),
    format: cdktf.stringToTerraform(struct!.format),
    id: cdktf.stringToTerraform(struct!.id),
    keep_alive: cdktf.booleanToTerraform(struct!.keepAlive),
    max_payload_events: cdktf.numberToTerraform(struct!.maxPayloadEvents),
    max_payload_size_kb: cdktf.numberToTerraform(struct!.maxPayloadSizeKb),
    method: cdktf.stringToTerraform(struct!.method),
    on_backpressure: cdktf.stringToTerraform(struct!.onBackpressure),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    pq_compress: cdktf.stringToTerraform(struct!.pqCompress),
    pq_controls: packDestinationOutputDynatraceHttpPqControlsToTerraform(struct!.pqControls),
    pq_max_file_size: cdktf.stringToTerraform(struct!.pqMaxFileSize),
    pq_max_size: cdktf.stringToTerraform(struct!.pqMaxSize),
    pq_mode: cdktf.stringToTerraform(struct!.pqMode),
    pq_on_backpressure: cdktf.stringToTerraform(struct!.pqOnBackpressure),
    pq_path: cdktf.stringToTerraform(struct!.pqPath),
    reject_unauthorized: cdktf.booleanToTerraform(struct!.rejectUnauthorized),
    response_honor_retry_after_header: cdktf.booleanToTerraform(struct!.responseHonorRetryAfterHeader),
    response_retry_settings: cdktf.listMapper(packDestinationOutputDynatraceHttpResponseRetrySettingsToTerraform, false)(struct!.responseRetrySettings),
    safe_headers: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.safeHeaders),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    system_fields: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.systemFields),
    telemetry_type: cdktf.stringToTerraform(struct!.telemetryType),
    text_secret: cdktf.stringToTerraform(struct!.textSecret),
    timeout_retry_settings: packDestinationOutputDynatraceHttpTimeoutRetrySettingsToTerraform(struct!.timeoutRetrySettings),
    timeout_sec: cdktf.numberToTerraform(struct!.timeoutSec),
    token: cdktf.stringToTerraform(struct!.token),
    total_memory_limit_kb: cdktf.numberToTerraform(struct!.totalMemoryLimitKb),
    type: cdktf.stringToTerraform(struct!.type),
    url: cdktf.stringToTerraform(struct!.url),
    use_round_robin_dns: cdktf.booleanToTerraform(struct!.useRoundRobinDns),
  }
}


export function packDestinationOutputDynatraceHttpToHclTerraform(struct?: PackDestinationOutputDynatraceHttp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    active_gate_domain: {
      value: cdktf.stringToHclTerraform(struct!.activeGateDomain),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    auth_type: {
      value: cdktf.stringToHclTerraform(struct!.authType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    compress: {
      value: cdktf.booleanToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    concurrency: {
      value: cdktf.numberToHclTerraform(struct!.concurrency),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    endpoint: {
      value: cdktf.stringToHclTerraform(struct!.endpoint),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    environment_id: {
      value: cdktf.stringToHclTerraform(struct!.environmentId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    extra_http_headers: {
      value: cdktf.listMapperHcl(packDestinationOutputDynatraceHttpExtraHttpHeadersToHclTerraform, false)(struct!.extraHttpHeaders),
      isBlock: true,
      type: "list",
      storageClassType: "PackDestinationOutputDynatraceHttpExtraHttpHeadersList",
    },
    failed_request_logging_mode: {
      value: cdktf.stringToHclTerraform(struct!.failedRequestLoggingMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    flush_period_sec: {
      value: cdktf.numberToHclTerraform(struct!.flushPeriodSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    format: {
      value: cdktf.stringToHclTerraform(struct!.format),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    keep_alive: {
      value: cdktf.booleanToHclTerraform(struct!.keepAlive),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    max_payload_events: {
      value: cdktf.numberToHclTerraform(struct!.maxPayloadEvents),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_payload_size_kb: {
      value: cdktf.numberToHclTerraform(struct!.maxPayloadSizeKb),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    method: {
      value: cdktf.stringToHclTerraform(struct!.method),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.onBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_compress: {
      value: cdktf.stringToHclTerraform(struct!.pqCompress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_controls: {
      value: packDestinationOutputDynatraceHttpPqControlsToHclTerraform(struct!.pqControls),
      isBlock: true,
      type: "struct",
      storageClassType: "PackDestinationOutputDynatraceHttpPqControls",
    },
    pq_max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_max_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_mode: {
      value: cdktf.stringToHclTerraform(struct!.pqMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.pqOnBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_path: {
      value: cdktf.stringToHclTerraform(struct!.pqPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reject_unauthorized: {
      value: cdktf.booleanToHclTerraform(struct!.rejectUnauthorized),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    response_honor_retry_after_header: {
      value: cdktf.booleanToHclTerraform(struct!.responseHonorRetryAfterHeader),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    response_retry_settings: {
      value: cdktf.listMapperHcl(packDestinationOutputDynatraceHttpResponseRetrySettingsToHclTerraform, false)(struct!.responseRetrySettings),
      isBlock: true,
      type: "list",
      storageClassType: "PackDestinationOutputDynatraceHttpResponseRetrySettingsList",
    },
    safe_headers: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.safeHeaders),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    system_fields: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.systemFields),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    telemetry_type: {
      value: cdktf.stringToHclTerraform(struct!.telemetryType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    text_secret: {
      value: cdktf.stringToHclTerraform(struct!.textSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    timeout_retry_settings: {
      value: packDestinationOutputDynatraceHttpTimeoutRetrySettingsToHclTerraform(struct!.timeoutRetrySettings),
      isBlock: true,
      type: "struct",
      storageClassType: "PackDestinationOutputDynatraceHttpTimeoutRetrySettings",
    },
    timeout_sec: {
      value: cdktf.numberToHclTerraform(struct!.timeoutSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    token: {
      value: cdktf.stringToHclTerraform(struct!.token),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    total_memory_limit_kb: {
      value: cdktf.numberToHclTerraform(struct!.totalMemoryLimitKb),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    url: {
      value: cdktf.stringToHclTerraform(struct!.url),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    use_round_robin_dns: {
      value: cdktf.booleanToHclTerraform(struct!.useRoundRobinDns),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputDynatraceHttpOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackDestinationOutputDynatraceHttp | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._activeGateDomain !== undefined) {
      hasAnyValues = true;
      internalValueResult.activeGateDomain = this._activeGateDomain;
    }
    if (this._authType !== undefined) {
      hasAnyValues = true;
      internalValueResult.authType = this._authType;
    }
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._concurrency !== undefined) {
      hasAnyValues = true;
      internalValueResult.concurrency = this._concurrency;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._endpoint !== undefined) {
      hasAnyValues = true;
      internalValueResult.endpoint = this._endpoint;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._environmentId !== undefined) {
      hasAnyValues = true;
      internalValueResult.environmentId = this._environmentId;
    }
    if (this._extraHttpHeaders?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.extraHttpHeaders = this._extraHttpHeaders?.internalValue;
    }
    if (this._failedRequestLoggingMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.failedRequestLoggingMode = this._failedRequestLoggingMode;
    }
    if (this._flushPeriodSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.flushPeriodSec = this._flushPeriodSec;
    }
    if (this._format !== undefined) {
      hasAnyValues = true;
      internalValueResult.format = this._format;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._keepAlive !== undefined) {
      hasAnyValues = true;
      internalValueResult.keepAlive = this._keepAlive;
    }
    if (this._maxPayloadEvents !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxPayloadEvents = this._maxPayloadEvents;
    }
    if (this._maxPayloadSizeKb !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxPayloadSizeKb = this._maxPayloadSizeKb;
    }
    if (this._method !== undefined) {
      hasAnyValues = true;
      internalValueResult.method = this._method;
    }
    if (this._onBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.onBackpressure = this._onBackpressure;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._pqCompress !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqCompress = this._pqCompress;
    }
    if (this._pqControls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqControls = this._pqControls?.internalValue;
    }
    if (this._pqMaxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxFileSize = this._pqMaxFileSize;
    }
    if (this._pqMaxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxSize = this._pqMaxSize;
    }
    if (this._pqMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMode = this._pqMode;
    }
    if (this._pqOnBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqOnBackpressure = this._pqOnBackpressure;
    }
    if (this._pqPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqPath = this._pqPath;
    }
    if (this._rejectUnauthorized !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectUnauthorized = this._rejectUnauthorized;
    }
    if (this._responseHonorRetryAfterHeader !== undefined) {
      hasAnyValues = true;
      internalValueResult.responseHonorRetryAfterHeader = this._responseHonorRetryAfterHeader;
    }
    if (this._responseRetrySettings?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.responseRetrySettings = this._responseRetrySettings?.internalValue;
    }
    if (this._safeHeaders !== undefined) {
      hasAnyValues = true;
      internalValueResult.safeHeaders = this._safeHeaders;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._systemFields !== undefined) {
      hasAnyValues = true;
      internalValueResult.systemFields = this._systemFields;
    }
    if (this._telemetryType !== undefined) {
      hasAnyValues = true;
      internalValueResult.telemetryType = this._telemetryType;
    }
    if (this._textSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.textSecret = this._textSecret;
    }
    if (this._timeoutRetrySettings?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutRetrySettings = this._timeoutRetrySettings?.internalValue;
    }
    if (this._timeoutSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutSec = this._timeoutSec;
    }
    if (this._token !== undefined) {
      hasAnyValues = true;
      internalValueResult.token = this._token;
    }
    if (this._totalMemoryLimitKb !== undefined) {
      hasAnyValues = true;
      internalValueResult.totalMemoryLimitKb = this._totalMemoryLimitKb;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._url !== undefined) {
      hasAnyValues = true;
      internalValueResult.url = this._url;
    }
    if (this._useRoundRobinDns !== undefined) {
      hasAnyValues = true;
      internalValueResult.useRoundRobinDns = this._useRoundRobinDns;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputDynatraceHttp | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._activeGateDomain = undefined;
      this._authType = undefined;
      this._compress = undefined;
      this._concurrency = undefined;
      this._description = undefined;
      this._endpoint = undefined;
      this._environment = undefined;
      this._environmentId = undefined;
      this._extraHttpHeaders.internalValue = undefined;
      this._failedRequestLoggingMode = undefined;
      this._flushPeriodSec = undefined;
      this._format = undefined;
      this._id = undefined;
      this._keepAlive = undefined;
      this._maxPayloadEvents = undefined;
      this._maxPayloadSizeKb = undefined;
      this._method = undefined;
      this._onBackpressure = undefined;
      this._pipeline = undefined;
      this._pqCompress = undefined;
      this._pqControls.internalValue = undefined;
      this._pqMaxFileSize = undefined;
      this._pqMaxSize = undefined;
      this._pqMode = undefined;
      this._pqOnBackpressure = undefined;
      this._pqPath = undefined;
      this._rejectUnauthorized = undefined;
      this._responseHonorRetryAfterHeader = undefined;
      this._responseRetrySettings.internalValue = undefined;
      this._safeHeaders = undefined;
      this._streamtags = undefined;
      this._systemFields = undefined;
      this._telemetryType = undefined;
      this._textSecret = undefined;
      this._timeoutRetrySettings.internalValue = undefined;
      this._timeoutSec = undefined;
      this._token = undefined;
      this._totalMemoryLimitKb = undefined;
      this._type = undefined;
      this._url = undefined;
      this._useRoundRobinDns = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._activeGateDomain = value.activeGateDomain;
      this._authType = value.authType;
      this._compress = value.compress;
      this._concurrency = value.concurrency;
      this._description = value.description;
      this._endpoint = value.endpoint;
      this._environment = value.environment;
      this._environmentId = value.environmentId;
      this._extraHttpHeaders.internalValue = value.extraHttpHeaders;
      this._failedRequestLoggingMode = value.failedRequestLoggingMode;
      this._flushPeriodSec = value.flushPeriodSec;
      this._format = value.format;
      this._id = value.id;
      this._keepAlive = value.keepAlive;
      this._maxPayloadEvents = value.maxPayloadEvents;
      this._maxPayloadSizeKb = value.maxPayloadSizeKb;
      this._method = value.method;
      this._onBackpressure = value.onBackpressure;
      this._pipeline = value.pipeline;
      this._pqCompress = value.pqCompress;
      this._pqControls.internalValue = value.pqControls;
      this._pqMaxFileSize = value.pqMaxFileSize;
      this._pqMaxSize = value.pqMaxSize;
      this._pqMode = value.pqMode;
      this._pqOnBackpressure = value.pqOnBackpressure;
      this._pqPath = value.pqPath;
      this._rejectUnauthorized = value.rejectUnauthorized;
      this._responseHonorRetryAfterHeader = value.responseHonorRetryAfterHeader;
      this._responseRetrySettings.internalValue = value.responseRetrySettings;
      this._safeHeaders = value.safeHeaders;
      this._streamtags = value.streamtags;
      this._systemFields = value.systemFields;
      this._telemetryType = value.telemetryType;
      this._textSecret = value.textSecret;
      this._timeoutRetrySettings.internalValue = value.timeoutRetrySettings;
      this._timeoutSec = value.timeoutSec;
      this._token = value.token;
      this._totalMemoryLimitKb = value.totalMemoryLimitKb;
      this._type = value.type;
      this._url = value.url;
      this._useRoundRobinDns = value.useRoundRobinDns;
    }
  }

  // active_gate_domain - computed: false, optional: true, required: false
  private _activeGateDomain?: string; 
  public get activeGateDomain() {
    return this.getStringAttribute('active_gate_domain');
  }
  public set activeGateDomain(value: string) {
    this._activeGateDomain = value;
  }
  public resetActiveGateDomain() {
    this._activeGateDomain = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get activeGateDomainInput() {
    return this._activeGateDomain;
  }

  // auth_type - computed: true, optional: true, required: false
  private _authType?: string; 
  public get authType() {
    return this.getStringAttribute('auth_type');
  }
  public set authType(value: string) {
    this._authType = value;
  }
  public resetAuthType() {
    this._authType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authTypeInput() {
    return this._authType;
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: boolean | cdktf.IResolvable; 
  public get compress() {
    return this.getBooleanAttribute('compress');
  }
  public set compress(value: boolean | cdktf.IResolvable) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // concurrency - computed: true, optional: true, required: false
  private _concurrency?: number; 
  public get concurrency() {
    return this.getNumberAttribute('concurrency');
  }
  public set concurrency(value: number) {
    this._concurrency = value;
  }
  public resetConcurrency() {
    this._concurrency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get concurrencyInput() {
    return this._concurrency;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // endpoint - computed: true, optional: true, required: false
  private _endpoint?: string; 
  public get endpoint() {
    return this.getStringAttribute('endpoint');
  }
  public set endpoint(value: string) {
    this._endpoint = value;
  }
  public resetEndpoint() {
    this._endpoint = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get endpointInput() {
    return this._endpoint;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // environment_id - computed: false, optional: true, required: false
  private _environmentId?: string; 
  public get environmentId() {
    return this.getStringAttribute('environment_id');
  }
  public set environmentId(value: string) {
    this._environmentId = value;
  }
  public resetEnvironmentId() {
    this._environmentId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentIdInput() {
    return this._environmentId;
  }

  // extra_http_headers - computed: false, optional: true, required: false
  private _extraHttpHeaders = new PackDestinationOutputDynatraceHttpExtraHttpHeadersList(this, "extra_http_headers", false);
  public get extraHttpHeaders() {
    return this._extraHttpHeaders;
  }
  public putExtraHttpHeaders(value: PackDestinationOutputDynatraceHttpExtraHttpHeaders[] | cdktf.IResolvable) {
    this._extraHttpHeaders.internalValue = value;
  }
  public resetExtraHttpHeaders() {
    this._extraHttpHeaders.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get extraHttpHeadersInput() {
    return this._extraHttpHeaders.internalValue;
  }

  // failed_request_logging_mode - computed: true, optional: true, required: false
  private _failedRequestLoggingMode?: string; 
  public get failedRequestLoggingMode() {
    return this.getStringAttribute('failed_request_logging_mode');
  }
  public set failedRequestLoggingMode(value: string) {
    this._failedRequestLoggingMode = value;
  }
  public resetFailedRequestLoggingMode() {
    this._failedRequestLoggingMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get failedRequestLoggingModeInput() {
    return this._failedRequestLoggingMode;
  }

  // flush_period_sec - computed: true, optional: true, required: false
  private _flushPeriodSec?: number; 
  public get flushPeriodSec() {
    return this.getNumberAttribute('flush_period_sec');
  }
  public set flushPeriodSec(value: number) {
    this._flushPeriodSec = value;
  }
  public resetFlushPeriodSec() {
    this._flushPeriodSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get flushPeriodSecInput() {
    return this._flushPeriodSec;
  }

  // format - computed: true, optional: true, required: false
  private _format?: string; 
  public get format() {
    return this.getStringAttribute('format');
  }
  public set format(value: string) {
    this._format = value;
  }
  public resetFormat() {
    this._format = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get formatInput() {
    return this._format;
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // keep_alive - computed: true, optional: true, required: false
  private _keepAlive?: boolean | cdktf.IResolvable; 
  public get keepAlive() {
    return this.getBooleanAttribute('keep_alive');
  }
  public set keepAlive(value: boolean | cdktf.IResolvable) {
    this._keepAlive = value;
  }
  public resetKeepAlive() {
    this._keepAlive = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keepAliveInput() {
    return this._keepAlive;
  }

  // max_payload_events - computed: true, optional: true, required: false
  private _maxPayloadEvents?: number; 
  public get maxPayloadEvents() {
    return this.getNumberAttribute('max_payload_events');
  }
  public set maxPayloadEvents(value: number) {
    this._maxPayloadEvents = value;
  }
  public resetMaxPayloadEvents() {
    this._maxPayloadEvents = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxPayloadEventsInput() {
    return this._maxPayloadEvents;
  }

  // max_payload_size_kb - computed: true, optional: true, required: false
  private _maxPayloadSizeKb?: number; 
  public get maxPayloadSizeKb() {
    return this.getNumberAttribute('max_payload_size_kb');
  }
  public set maxPayloadSizeKb(value: number) {
    this._maxPayloadSizeKb = value;
  }
  public resetMaxPayloadSizeKb() {
    this._maxPayloadSizeKb = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxPayloadSizeKbInput() {
    return this._maxPayloadSizeKb;
  }

  // method - computed: true, optional: true, required: false
  private _method?: string; 
  public get method() {
    return this.getStringAttribute('method');
  }
  public set method(value: string) {
    this._method = value;
  }
  public resetMethod() {
    this._method = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get methodInput() {
    return this._method;
  }

  // on_backpressure - computed: true, optional: true, required: false
  private _onBackpressure?: string; 
  public get onBackpressure() {
    return this.getStringAttribute('on_backpressure');
  }
  public set onBackpressure(value: string) {
    this._onBackpressure = value;
  }
  public resetOnBackpressure() {
    this._onBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get onBackpressureInput() {
    return this._onBackpressure;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // pq_compress - computed: true, optional: true, required: false
  private _pqCompress?: string; 
  public get pqCompress() {
    return this.getStringAttribute('pq_compress');
  }
  public set pqCompress(value: string) {
    this._pqCompress = value;
  }
  public resetPqCompress() {
    this._pqCompress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqCompressInput() {
    return this._pqCompress;
  }

  // pq_controls - computed: false, optional: true, required: false
  private _pqControls = new PackDestinationOutputDynatraceHttpPqControlsOutputReference(this, "pq_controls");
  public get pqControls() {
    return this._pqControls;
  }
  public putPqControls(value: PackDestinationOutputDynatraceHttpPqControls) {
    this._pqControls.internalValue = value;
  }
  public resetPqControls() {
    this._pqControls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqControlsInput() {
    return this._pqControls.internalValue;
  }

  // pq_max_file_size - computed: true, optional: true, required: false
  private _pqMaxFileSize?: string; 
  public get pqMaxFileSize() {
    return this.getStringAttribute('pq_max_file_size');
  }
  public set pqMaxFileSize(value: string) {
    this._pqMaxFileSize = value;
  }
  public resetPqMaxFileSize() {
    this._pqMaxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxFileSizeInput() {
    return this._pqMaxFileSize;
  }

  // pq_max_size - computed: true, optional: true, required: false
  private _pqMaxSize?: string; 
  public get pqMaxSize() {
    return this.getStringAttribute('pq_max_size');
  }
  public set pqMaxSize(value: string) {
    this._pqMaxSize = value;
  }
  public resetPqMaxSize() {
    this._pqMaxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxSizeInput() {
    return this._pqMaxSize;
  }

  // pq_mode - computed: true, optional: true, required: false
  private _pqMode?: string; 
  public get pqMode() {
    return this.getStringAttribute('pq_mode');
  }
  public set pqMode(value: string) {
    this._pqMode = value;
  }
  public resetPqMode() {
    this._pqMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqModeInput() {
    return this._pqMode;
  }

  // pq_on_backpressure - computed: true, optional: true, required: false
  private _pqOnBackpressure?: string; 
  public get pqOnBackpressure() {
    return this.getStringAttribute('pq_on_backpressure');
  }
  public set pqOnBackpressure(value: string) {
    this._pqOnBackpressure = value;
  }
  public resetPqOnBackpressure() {
    this._pqOnBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqOnBackpressureInput() {
    return this._pqOnBackpressure;
  }

  // pq_path - computed: true, optional: true, required: false
  private _pqPath?: string; 
  public get pqPath() {
    return this.getStringAttribute('pq_path');
  }
  public set pqPath(value: string) {
    this._pqPath = value;
  }
  public resetPqPath() {
    this._pqPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqPathInput() {
    return this._pqPath;
  }

  // reject_unauthorized - computed: true, optional: true, required: false
  private _rejectUnauthorized?: boolean | cdktf.IResolvable; 
  public get rejectUnauthorized() {
    return this.getBooleanAttribute('reject_unauthorized');
  }
  public set rejectUnauthorized(value: boolean | cdktf.IResolvable) {
    this._rejectUnauthorized = value;
  }
  public resetRejectUnauthorized() {
    this._rejectUnauthorized = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectUnauthorizedInput() {
    return this._rejectUnauthorized;
  }

  // response_honor_retry_after_header - computed: true, optional: true, required: false
  private _responseHonorRetryAfterHeader?: boolean | cdktf.IResolvable; 
  public get responseHonorRetryAfterHeader() {
    return this.getBooleanAttribute('response_honor_retry_after_header');
  }
  public set responseHonorRetryAfterHeader(value: boolean | cdktf.IResolvable) {
    this._responseHonorRetryAfterHeader = value;
  }
  public resetResponseHonorRetryAfterHeader() {
    this._responseHonorRetryAfterHeader = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get responseHonorRetryAfterHeaderInput() {
    return this._responseHonorRetryAfterHeader;
  }

  // response_retry_settings - computed: false, optional: true, required: false
  private _responseRetrySettings = new PackDestinationOutputDynatraceHttpResponseRetrySettingsList(this, "response_retry_settings", false);
  public get responseRetrySettings() {
    return this._responseRetrySettings;
  }
  public putResponseRetrySettings(value: PackDestinationOutputDynatraceHttpResponseRetrySettings[] | cdktf.IResolvable) {
    this._responseRetrySettings.internalValue = value;
  }
  public resetResponseRetrySettings() {
    this._responseRetrySettings.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get responseRetrySettingsInput() {
    return this._responseRetrySettings.internalValue;
  }

  // safe_headers - computed: true, optional: true, required: false
  private _safeHeaders?: string[]; 
  public get safeHeaders() {
    return this.getListAttribute('safe_headers');
  }
  public set safeHeaders(value: string[]) {
    this._safeHeaders = value;
  }
  public resetSafeHeaders() {
    this._safeHeaders = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get safeHeadersInput() {
    return this._safeHeaders;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // system_fields - computed: true, optional: true, required: false
  private _systemFields?: string[]; 
  public get systemFields() {
    return this.getListAttribute('system_fields');
  }
  public set systemFields(value: string[]) {
    this._systemFields = value;
  }
  public resetSystemFields() {
    this._systemFields = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get systemFieldsInput() {
    return this._systemFields;
  }

  // telemetry_type - computed: true, optional: true, required: false
  private _telemetryType?: string; 
  public get telemetryType() {
    return this.getStringAttribute('telemetry_type');
  }
  public set telemetryType(value: string) {
    this._telemetryType = value;
  }
  public resetTelemetryType() {
    this._telemetryType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get telemetryTypeInput() {
    return this._telemetryType;
  }

  // text_secret - computed: false, optional: true, required: false
  private _textSecret?: string; 
  public get textSecret() {
    return this.getStringAttribute('text_secret');
  }
  public set textSecret(value: string) {
    this._textSecret = value;
  }
  public resetTextSecret() {
    this._textSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get textSecretInput() {
    return this._textSecret;
  }

  // timeout_retry_settings - computed: false, optional: true, required: false
  private _timeoutRetrySettings = new PackDestinationOutputDynatraceHttpTimeoutRetrySettingsOutputReference(this, "timeout_retry_settings");
  public get timeoutRetrySettings() {
    return this._timeoutRetrySettings;
  }
  public putTimeoutRetrySettings(value: PackDestinationOutputDynatraceHttpTimeoutRetrySettings) {
    this._timeoutRetrySettings.internalValue = value;
  }
  public resetTimeoutRetrySettings() {
    this._timeoutRetrySettings.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutRetrySettingsInput() {
    return this._timeoutRetrySettings.internalValue;
  }

  // timeout_sec - computed: true, optional: true, required: false
  private _timeoutSec?: number; 
  public get timeoutSec() {
    return this.getNumberAttribute('timeout_sec');
  }
  public set timeoutSec(value: number) {
    this._timeoutSec = value;
  }
  public resetTimeoutSec() {
    this._timeoutSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutSecInput() {
    return this._timeoutSec;
  }

  // token - computed: false, optional: true, required: false
  private _token?: string; 
  public get token() {
    return this.getStringAttribute('token');
  }
  public set token(value: string) {
    this._token = value;
  }
  public resetToken() {
    this._token = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tokenInput() {
    return this._token;
  }

  // total_memory_limit_kb - computed: false, optional: true, required: false
  private _totalMemoryLimitKb?: number; 
  public get totalMemoryLimitKb() {
    return this.getNumberAttribute('total_memory_limit_kb');
  }
  public set totalMemoryLimitKb(value: number) {
    this._totalMemoryLimitKb = value;
  }
  public resetTotalMemoryLimitKb() {
    this._totalMemoryLimitKb = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get totalMemoryLimitKbInput() {
    return this._totalMemoryLimitKb;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // url - computed: false, optional: true, required: false
  private _url?: string; 
  public get url() {
    return this.getStringAttribute('url');
  }
  public set url(value: string) {
    this._url = value;
  }
  public resetUrl() {
    this._url = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get urlInput() {
    return this._url;
  }

  // use_round_robin_dns - computed: true, optional: true, required: false
  private _useRoundRobinDns?: boolean | cdktf.IResolvable; 
  public get useRoundRobinDns() {
    return this.getBooleanAttribute('use_round_robin_dns');
  }
  public set useRoundRobinDns(value: boolean | cdktf.IResolvable) {
    this._useRoundRobinDns = value;
  }
  public resetUseRoundRobinDns() {
    this._useRoundRobinDns = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get useRoundRobinDnsInput() {
    return this._useRoundRobinDns;
  }
}
export interface PackDestinationOutputDynatraceOtlpExtraHttpHeaders {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#name PackDestination#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#value PackDestination#value}
  */
  readonly value: string;
}

export function packDestinationOutputDynatraceOtlpExtraHttpHeadersToTerraform(struct?: PackDestinationOutputDynatraceOtlpExtraHttpHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function packDestinationOutputDynatraceOtlpExtraHttpHeadersToHclTerraform(struct?: PackDestinationOutputDynatraceOtlpExtraHttpHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputDynatraceOtlpExtraHttpHeadersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackDestinationOutputDynatraceOtlpExtraHttpHeaders | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputDynatraceOtlpExtraHttpHeaders | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class PackDestinationOutputDynatraceOtlpExtraHttpHeadersList extends cdktf.ComplexList {
  public internalValue? : PackDestinationOutputDynatraceOtlpExtraHttpHeaders[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackDestinationOutputDynatraceOtlpExtraHttpHeadersOutputReference {
    return new PackDestinationOutputDynatraceOtlpExtraHttpHeadersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackDestinationOutputDynatraceOtlpMetadata {
  /**
  * Default: ""
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#key PackDestination#key}
  */
  readonly key?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#value PackDestination#value}
  */
  readonly value: string;
}

export function packDestinationOutputDynatraceOtlpMetadataToTerraform(struct?: PackDestinationOutputDynatraceOtlpMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function packDestinationOutputDynatraceOtlpMetadataToHclTerraform(struct?: PackDestinationOutputDynatraceOtlpMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputDynatraceOtlpMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackDestinationOutputDynatraceOtlpMetadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputDynatraceOtlpMetadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._value = value.value;
    }
  }

  // key - computed: true, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class PackDestinationOutputDynatraceOtlpMetadataList extends cdktf.ComplexList {
  public internalValue? : PackDestinationOutputDynatraceOtlpMetadata[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackDestinationOutputDynatraceOtlpMetadataOutputReference {
    return new PackDestinationOutputDynatraceOtlpMetadataOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackDestinationOutputDynatraceOtlpPqControls {
}

export function packDestinationOutputDynatraceOtlpPqControlsToTerraform(struct?: PackDestinationOutputDynatraceOtlpPqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function packDestinationOutputDynatraceOtlpPqControlsToHclTerraform(struct?: PackDestinationOutputDynatraceOtlpPqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class PackDestinationOutputDynatraceOtlpPqControlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackDestinationOutputDynatraceOtlpPqControls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputDynatraceOtlpPqControls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface PackDestinationOutputDynatraceOtlpResponseRetrySettings {
  /**
  * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc. Default: 2
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#backoff_rate PackDestination#backoff_rate}
  */
  readonly backoffRate?: number;
  /**
  * The HTTP response status code that will trigger retries
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#http_status PackDestination#http_status}
  */
  readonly httpStatus: number;
  /**
  * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes). Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#initial_backoff PackDestination#initial_backoff}
  */
  readonly initialBackoff?: number;
  /**
  * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds). Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_backoff PackDestination#max_backoff}
  */
  readonly maxBackoff?: number;
}

export function packDestinationOutputDynatraceOtlpResponseRetrySettingsToTerraform(struct?: PackDestinationOutputDynatraceOtlpResponseRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    backoff_rate: cdktf.numberToTerraform(struct!.backoffRate),
    http_status: cdktf.numberToTerraform(struct!.httpStatus),
    initial_backoff: cdktf.numberToTerraform(struct!.initialBackoff),
    max_backoff: cdktf.numberToTerraform(struct!.maxBackoff),
  }
}


export function packDestinationOutputDynatraceOtlpResponseRetrySettingsToHclTerraform(struct?: PackDestinationOutputDynatraceOtlpResponseRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    backoff_rate: {
      value: cdktf.numberToHclTerraform(struct!.backoffRate),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    http_status: {
      value: cdktf.numberToHclTerraform(struct!.httpStatus),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    initial_backoff: {
      value: cdktf.numberToHclTerraform(struct!.initialBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_backoff: {
      value: cdktf.numberToHclTerraform(struct!.maxBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputDynatraceOtlpResponseRetrySettingsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackDestinationOutputDynatraceOtlpResponseRetrySettings | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._backoffRate !== undefined) {
      hasAnyValues = true;
      internalValueResult.backoffRate = this._backoffRate;
    }
    if (this._httpStatus !== undefined) {
      hasAnyValues = true;
      internalValueResult.httpStatus = this._httpStatus;
    }
    if (this._initialBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.initialBackoff = this._initialBackoff;
    }
    if (this._maxBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBackoff = this._maxBackoff;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputDynatraceOtlpResponseRetrySettings | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._backoffRate = undefined;
      this._httpStatus = undefined;
      this._initialBackoff = undefined;
      this._maxBackoff = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._backoffRate = value.backoffRate;
      this._httpStatus = value.httpStatus;
      this._initialBackoff = value.initialBackoff;
      this._maxBackoff = value.maxBackoff;
    }
  }

  // backoff_rate - computed: true, optional: true, required: false
  private _backoffRate?: number; 
  public get backoffRate() {
    return this.getNumberAttribute('backoff_rate');
  }
  public set backoffRate(value: number) {
    this._backoffRate = value;
  }
  public resetBackoffRate() {
    this._backoffRate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get backoffRateInput() {
    return this._backoffRate;
  }

  // http_status - computed: false, optional: false, required: true
  private _httpStatus?: number; 
  public get httpStatus() {
    return this.getNumberAttribute('http_status');
  }
  public set httpStatus(value: number) {
    this._httpStatus = value;
  }
  // Temporarily expose input value. Use with caution.
  public get httpStatusInput() {
    return this._httpStatus;
  }

  // initial_backoff - computed: true, optional: true, required: false
  private _initialBackoff?: number; 
  public get initialBackoff() {
    return this.getNumberAttribute('initial_backoff');
  }
  public set initialBackoff(value: number) {
    this._initialBackoff = value;
  }
  public resetInitialBackoff() {
    this._initialBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get initialBackoffInput() {
    return this._initialBackoff;
  }

  // max_backoff - computed: true, optional: true, required: false
  private _maxBackoff?: number; 
  public get maxBackoff() {
    return this.getNumberAttribute('max_backoff');
  }
  public set maxBackoff(value: number) {
    this._maxBackoff = value;
  }
  public resetMaxBackoff() {
    this._maxBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBackoffInput() {
    return this._maxBackoff;
  }
}

export class PackDestinationOutputDynatraceOtlpResponseRetrySettingsList extends cdktf.ComplexList {
  public internalValue? : PackDestinationOutputDynatraceOtlpResponseRetrySettings[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackDestinationOutputDynatraceOtlpResponseRetrySettingsOutputReference {
    return new PackDestinationOutputDynatraceOtlpResponseRetrySettingsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackDestinationOutputDynatraceOtlpTimeoutRetrySettings {
  /**
  * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc. Default: 2
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#backoff_rate PackDestination#backoff_rate}
  */
  readonly backoffRate?: number;
  /**
  * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes). Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#initial_backoff PackDestination#initial_backoff}
  */
  readonly initialBackoff?: number;
  /**
  * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds). Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_backoff PackDestination#max_backoff}
  */
  readonly maxBackoff?: number;
  /**
  * Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#timeout_retry PackDestination#timeout_retry}
  */
  readonly timeoutRetry?: boolean | cdktf.IResolvable;
}

export function packDestinationOutputDynatraceOtlpTimeoutRetrySettingsToTerraform(struct?: PackDestinationOutputDynatraceOtlpTimeoutRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    backoff_rate: cdktf.numberToTerraform(struct!.backoffRate),
    initial_backoff: cdktf.numberToTerraform(struct!.initialBackoff),
    max_backoff: cdktf.numberToTerraform(struct!.maxBackoff),
    timeout_retry: cdktf.booleanToTerraform(struct!.timeoutRetry),
  }
}


export function packDestinationOutputDynatraceOtlpTimeoutRetrySettingsToHclTerraform(struct?: PackDestinationOutputDynatraceOtlpTimeoutRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    backoff_rate: {
      value: cdktf.numberToHclTerraform(struct!.backoffRate),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    initial_backoff: {
      value: cdktf.numberToHclTerraform(struct!.initialBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_backoff: {
      value: cdktf.numberToHclTerraform(struct!.maxBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    timeout_retry: {
      value: cdktf.booleanToHclTerraform(struct!.timeoutRetry),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputDynatraceOtlpTimeoutRetrySettingsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackDestinationOutputDynatraceOtlpTimeoutRetrySettings | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._backoffRate !== undefined) {
      hasAnyValues = true;
      internalValueResult.backoffRate = this._backoffRate;
    }
    if (this._initialBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.initialBackoff = this._initialBackoff;
    }
    if (this._maxBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBackoff = this._maxBackoff;
    }
    if (this._timeoutRetry !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutRetry = this._timeoutRetry;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputDynatraceOtlpTimeoutRetrySettings | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._backoffRate = undefined;
      this._initialBackoff = undefined;
      this._maxBackoff = undefined;
      this._timeoutRetry = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._backoffRate = value.backoffRate;
      this._initialBackoff = value.initialBackoff;
      this._maxBackoff = value.maxBackoff;
      this._timeoutRetry = value.timeoutRetry;
    }
  }

  // backoff_rate - computed: true, optional: true, required: false
  private _backoffRate?: number; 
  public get backoffRate() {
    return this.getNumberAttribute('backoff_rate');
  }
  public set backoffRate(value: number) {
    this._backoffRate = value;
  }
  public resetBackoffRate() {
    this._backoffRate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get backoffRateInput() {
    return this._backoffRate;
  }

  // initial_backoff - computed: true, optional: true, required: false
  private _initialBackoff?: number; 
  public get initialBackoff() {
    return this.getNumberAttribute('initial_backoff');
  }
  public set initialBackoff(value: number) {
    this._initialBackoff = value;
  }
  public resetInitialBackoff() {
    this._initialBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get initialBackoffInput() {
    return this._initialBackoff;
  }

  // max_backoff - computed: true, optional: true, required: false
  private _maxBackoff?: number; 
  public get maxBackoff() {
    return this.getNumberAttribute('max_backoff');
  }
  public set maxBackoff(value: number) {
    this._maxBackoff = value;
  }
  public resetMaxBackoff() {
    this._maxBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBackoffInput() {
    return this._maxBackoff;
  }

  // timeout_retry - computed: true, optional: true, required: false
  private _timeoutRetry?: boolean | cdktf.IResolvable; 
  public get timeoutRetry() {
    return this.getBooleanAttribute('timeout_retry');
  }
  public set timeoutRetry(value: boolean | cdktf.IResolvable) {
    this._timeoutRetry = value;
  }
  public resetTimeoutRetry() {
    this._timeoutRetry = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutRetryInput() {
    return this._timeoutRetry;
  }
}
export interface PackDestinationOutputDynatraceOtlp {
  /**
  * Default: "Authorization"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#auth_token_name PackDestination#auth_token_name}
  */
  readonly authTokenName?: string;
  /**
  * Type of compression to apply to messages sent to the OpenTelemetry endpoint. Default: "gzip"; must be one of ["none", "deflate", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#compress PackDestination#compress}
  */
  readonly compress?: string;
  /**
  * Maximum number of ongoing requests before blocking. Default: 5
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#concurrency PackDestination#concurrency}
  */
  readonly concurrency?: number;
  /**
  * Amount of time (milliseconds) to wait for the connection to establish before retrying. Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#connection_timeout PackDestination#connection_timeout}
  */
  readonly connectionTimeout?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#description PackDestination#description}
  */
  readonly description?: string;
  /**
  * The endpoint where Dynatrace events will be sent. Enter any valid URL or an IP address (IPv4 or IPv6; enclose IPv6 addresses in square brackets). Default: "https://{your-environment-id}.live.dynatrace.com/api/v2/otlp"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#endpoint PackDestination#endpoint}
  */
  readonly endpoint?: string;
  /**
  * Select the type of Dynatrace endpoint configured. Default: "saas"; must be one of ["saas", "ag"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#endpoint_type PackDestination#endpoint_type}
  */
  readonly endpointType?: string;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#environment PackDestination#environment}
  */
  readonly environment?: string;
  /**
  * Headers to add to all events
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#extra_http_headers PackDestination#extra_http_headers}
  */
  readonly extraHttpHeaders?: PackDestinationOutputDynatraceOtlpExtraHttpHeaders[] | cdktf.IResolvable;
  /**
  * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below. Default: "none"; must be one of ["payload", "payloadAndHeaders", "none"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#failed_request_logging_mode PackDestination#failed_request_logging_mode}
  */
  readonly failedRequestLoggingMode?: string;
  /**
  * Maximum time between requests. Small values could cause the payload size to be smaller than the configured Body size limit. Default: 1
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#flush_period_sec PackDestination#flush_period_sec}
  */
  readonly flushPeriodSec?: number;
  /**
  * Type of compression to apply to messages sent to the OpenTelemetry endpoint. Default: "gzip"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#http_compress PackDestination#http_compress}
  */
  readonly httpCompress?: string;
  /**
  * If you want to send logs to the default `{endpoint}/v1/logs` endpoint, leave this field empty; otherwise, specify the desired endpoint
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#http_logs_endpoint_override PackDestination#http_logs_endpoint_override}
  */
  readonly httpLogsEndpointOverride?: string;
  /**
  * If you want to send metrics to the default `{endpoint}/v1/metrics` endpoint, leave this field empty; otherwise, specify the desired endpoint
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#http_metrics_endpoint_override PackDestination#http_metrics_endpoint_override}
  */
  readonly httpMetricsEndpointOverride?: string;
  /**
  * If you want to send traces to the default `{endpoint}/v1/traces` endpoint, leave this field empty; otherwise, specify the desired endpoint
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#http_traces_endpoint_override PackDestination#http_traces_endpoint_override}
  */
  readonly httpTracesEndpointOverride?: string;
  /**
  * Unique ID for this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#id PackDestination#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * Disable to close the connection immediately after sending the outgoing request. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#keep_alive PackDestination#keep_alive}
  */
  readonly keepAlive?: boolean | cdktf.IResolvable;
  /**
  * How often the sender should ping the peer to keep the connection open. Default: 30
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#keep_alive_time PackDestination#keep_alive_time}
  */
  readonly keepAliveTime?: number;
  /**
  * Maximum size (in KB) of the request body. The maximum payload size is 4 MB. If this limit is exceeded, the entire OTLP message is dropped. Default: 2048
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_payload_size_kb PackDestination#max_payload_size_kb}
  */
  readonly maxPayloadSizeKb?: number;
  /**
  * List of key-value pairs to send with each gRPC request. Value supports JavaScript expressions that are evaluated just once, when the destination gets started. To pass credentials as metadata, use 'C.Secret'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#metadata PackDestination#metadata}
  */
  readonly metadata?: PackDestinationOutputDynatraceOtlpMetadata[] | cdktf.IResolvable;
  /**
  * How to handle events when all receivers are exerting backpressure. Default: "block"; must be one of ["block", "drop", "queue"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#on_backpressure PackDestination#on_backpressure}
  */
  readonly onBackpressure?: string;
  /**
  * The version of OTLP Protobuf definitions to use when structuring data to send. Default: "1.3.1"; must be "1.3.1"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#otlp_version PackDestination#otlp_version}
  */
  readonly otlpVersion?: string;
  /**
  * Pipeline to process data before sending out to this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pipeline PackDestination#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_compress PackDestination#pq_compress}
  */
  readonly pqCompress?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_controls PackDestination#pq_controls}
  */
  readonly pqControls?: PackDestinationOutputDynatraceOtlpPqControls;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.). Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_max_file_size PackDestination#pq_max_file_size}
  */
  readonly pqMaxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_max_size PackDestination#pq_max_size}
  */
  readonly pqMaxSize?: string;
  /**
  * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem. Default: "error"; must be one of ["error", "backpressure", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_mode PackDestination#pq_mode}
  */
  readonly pqMode?: string;
  /**
  * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged. Default: "block"; must be one of ["block", "drop"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_on_backpressure PackDestination#pq_on_backpressure}
  */
  readonly pqOnBackpressure?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_path PackDestination#pq_path}
  */
  readonly pqPath?: string;
  /**
  * Select a transport option for Dynatrace. Default: "http"; must be "http"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#protocol PackDestination#protocol}
  */
  readonly protocol?: string;
  /**
  * Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's). 
  *         Enabled by default. When this setting is also present in TLS Settings (Client Side), 
  *         that value will take precedence.
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#reject_unauthorized PackDestination#reject_unauthorized}
  */
  readonly rejectUnauthorized?: boolean | cdktf.IResolvable;
  /**
  * Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#response_honor_retry_after_header PackDestination#response_honor_retry_after_header}
  */
  readonly responseHonorRetryAfterHeader?: boolean | cdktf.IResolvable;
  /**
  * Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#response_retry_settings PackDestination#response_retry_settings}
  */
  readonly responseRetrySettings?: PackDestinationOutputDynatraceOtlpResponseRetrySettings[] | cdktf.IResolvable;
  /**
  * List of headers that are safe to log in plain text. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#safe_headers PackDestination#safe_headers}
  */
  readonly safeHeaders?: string[];
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#streamtags PackDestination#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Fields to automatically add to events, such as cribl_pipe. Supports wildcards. Default: ["cribl_pipe"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#system_fields PackDestination#system_fields}
  */
  readonly systemFields?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#timeout_retry_settings PackDestination#timeout_retry_settings}
  */
  readonly timeoutRetrySettings?: PackDestinationOutputDynatraceOtlpTimeoutRetrySettings;
  /**
  * Amount of time, in seconds, to wait for a request to complete before canceling it. Default: 30
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#timeout_sec PackDestination#timeout_sec}
  */
  readonly timeoutSec?: number;
  /**
  * Select or create a stored text secret
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#token_secret PackDestination#token_secret}
  */
  readonly tokenSecret: string;
  /**
  * must be "dynatrace_otlp"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#type PackDestination#type}
  */
  readonly type?: string;
  /**
  * Enable round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. For optimal performance, consider enabling this setting for non-load balanced destinations. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#use_round_robin_dns PackDestination#use_round_robin_dns}
  */
  readonly useRoundRobinDns?: boolean | cdktf.IResolvable;
}

export function packDestinationOutputDynatraceOtlpToTerraform(struct?: PackDestinationOutputDynatraceOtlp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    auth_token_name: cdktf.stringToTerraform(struct!.authTokenName),
    compress: cdktf.stringToTerraform(struct!.compress),
    concurrency: cdktf.numberToTerraform(struct!.concurrency),
    connection_timeout: cdktf.numberToTerraform(struct!.connectionTimeout),
    description: cdktf.stringToTerraform(struct!.description),
    endpoint: cdktf.stringToTerraform(struct!.endpoint),
    endpoint_type: cdktf.stringToTerraform(struct!.endpointType),
    environment: cdktf.stringToTerraform(struct!.environment),
    extra_http_headers: cdktf.listMapper(packDestinationOutputDynatraceOtlpExtraHttpHeadersToTerraform, false)(struct!.extraHttpHeaders),
    failed_request_logging_mode: cdktf.stringToTerraform(struct!.failedRequestLoggingMode),
    flush_period_sec: cdktf.numberToTerraform(struct!.flushPeriodSec),
    http_compress: cdktf.stringToTerraform(struct!.httpCompress),
    http_logs_endpoint_override: cdktf.stringToTerraform(struct!.httpLogsEndpointOverride),
    http_metrics_endpoint_override: cdktf.stringToTerraform(struct!.httpMetricsEndpointOverride),
    http_traces_endpoint_override: cdktf.stringToTerraform(struct!.httpTracesEndpointOverride),
    id: cdktf.stringToTerraform(struct!.id),
    keep_alive: cdktf.booleanToTerraform(struct!.keepAlive),
    keep_alive_time: cdktf.numberToTerraform(struct!.keepAliveTime),
    max_payload_size_kb: cdktf.numberToTerraform(struct!.maxPayloadSizeKb),
    metadata: cdktf.listMapper(packDestinationOutputDynatraceOtlpMetadataToTerraform, false)(struct!.metadata),
    on_backpressure: cdktf.stringToTerraform(struct!.onBackpressure),
    otlp_version: cdktf.stringToTerraform(struct!.otlpVersion),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    pq_compress: cdktf.stringToTerraform(struct!.pqCompress),
    pq_controls: packDestinationOutputDynatraceOtlpPqControlsToTerraform(struct!.pqControls),
    pq_max_file_size: cdktf.stringToTerraform(struct!.pqMaxFileSize),
    pq_max_size: cdktf.stringToTerraform(struct!.pqMaxSize),
    pq_mode: cdktf.stringToTerraform(struct!.pqMode),
    pq_on_backpressure: cdktf.stringToTerraform(struct!.pqOnBackpressure),
    pq_path: cdktf.stringToTerraform(struct!.pqPath),
    protocol: cdktf.stringToTerraform(struct!.protocol),
    reject_unauthorized: cdktf.booleanToTerraform(struct!.rejectUnauthorized),
    response_honor_retry_after_header: cdktf.booleanToTerraform(struct!.responseHonorRetryAfterHeader),
    response_retry_settings: cdktf.listMapper(packDestinationOutputDynatraceOtlpResponseRetrySettingsToTerraform, false)(struct!.responseRetrySettings),
    safe_headers: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.safeHeaders),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    system_fields: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.systemFields),
    timeout_retry_settings: packDestinationOutputDynatraceOtlpTimeoutRetrySettingsToTerraform(struct!.timeoutRetrySettings),
    timeout_sec: cdktf.numberToTerraform(struct!.timeoutSec),
    token_secret: cdktf.stringToTerraform(struct!.tokenSecret),
    type: cdktf.stringToTerraform(struct!.type),
    use_round_robin_dns: cdktf.booleanToTerraform(struct!.useRoundRobinDns),
  }
}


export function packDestinationOutputDynatraceOtlpToHclTerraform(struct?: PackDestinationOutputDynatraceOtlp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    auth_token_name: {
      value: cdktf.stringToHclTerraform(struct!.authTokenName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    compress: {
      value: cdktf.stringToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    concurrency: {
      value: cdktf.numberToHclTerraform(struct!.concurrency),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    connection_timeout: {
      value: cdktf.numberToHclTerraform(struct!.connectionTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    endpoint: {
      value: cdktf.stringToHclTerraform(struct!.endpoint),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    endpoint_type: {
      value: cdktf.stringToHclTerraform(struct!.endpointType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    extra_http_headers: {
      value: cdktf.listMapperHcl(packDestinationOutputDynatraceOtlpExtraHttpHeadersToHclTerraform, false)(struct!.extraHttpHeaders),
      isBlock: true,
      type: "list",
      storageClassType: "PackDestinationOutputDynatraceOtlpExtraHttpHeadersList",
    },
    failed_request_logging_mode: {
      value: cdktf.stringToHclTerraform(struct!.failedRequestLoggingMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    flush_period_sec: {
      value: cdktf.numberToHclTerraform(struct!.flushPeriodSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    http_compress: {
      value: cdktf.stringToHclTerraform(struct!.httpCompress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    http_logs_endpoint_override: {
      value: cdktf.stringToHclTerraform(struct!.httpLogsEndpointOverride),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    http_metrics_endpoint_override: {
      value: cdktf.stringToHclTerraform(struct!.httpMetricsEndpointOverride),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    http_traces_endpoint_override: {
      value: cdktf.stringToHclTerraform(struct!.httpTracesEndpointOverride),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    keep_alive: {
      value: cdktf.booleanToHclTerraform(struct!.keepAlive),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    keep_alive_time: {
      value: cdktf.numberToHclTerraform(struct!.keepAliveTime),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_payload_size_kb: {
      value: cdktf.numberToHclTerraform(struct!.maxPayloadSizeKb),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    metadata: {
      value: cdktf.listMapperHcl(packDestinationOutputDynatraceOtlpMetadataToHclTerraform, false)(struct!.metadata),
      isBlock: true,
      type: "list",
      storageClassType: "PackDestinationOutputDynatraceOtlpMetadataList",
    },
    on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.onBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    otlp_version: {
      value: cdktf.stringToHclTerraform(struct!.otlpVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_compress: {
      value: cdktf.stringToHclTerraform(struct!.pqCompress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_controls: {
      value: packDestinationOutputDynatraceOtlpPqControlsToHclTerraform(struct!.pqControls),
      isBlock: true,
      type: "struct",
      storageClassType: "PackDestinationOutputDynatraceOtlpPqControls",
    },
    pq_max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_max_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_mode: {
      value: cdktf.stringToHclTerraform(struct!.pqMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.pqOnBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_path: {
      value: cdktf.stringToHclTerraform(struct!.pqPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    protocol: {
      value: cdktf.stringToHclTerraform(struct!.protocol),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reject_unauthorized: {
      value: cdktf.booleanToHclTerraform(struct!.rejectUnauthorized),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    response_honor_retry_after_header: {
      value: cdktf.booleanToHclTerraform(struct!.responseHonorRetryAfterHeader),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    response_retry_settings: {
      value: cdktf.listMapperHcl(packDestinationOutputDynatraceOtlpResponseRetrySettingsToHclTerraform, false)(struct!.responseRetrySettings),
      isBlock: true,
      type: "list",
      storageClassType: "PackDestinationOutputDynatraceOtlpResponseRetrySettingsList",
    },
    safe_headers: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.safeHeaders),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    system_fields: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.systemFields),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    timeout_retry_settings: {
      value: packDestinationOutputDynatraceOtlpTimeoutRetrySettingsToHclTerraform(struct!.timeoutRetrySettings),
      isBlock: true,
      type: "struct",
      storageClassType: "PackDestinationOutputDynatraceOtlpTimeoutRetrySettings",
    },
    timeout_sec: {
      value: cdktf.numberToHclTerraform(struct!.timeoutSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    token_secret: {
      value: cdktf.stringToHclTerraform(struct!.tokenSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    use_round_robin_dns: {
      value: cdktf.booleanToHclTerraform(struct!.useRoundRobinDns),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputDynatraceOtlpOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackDestinationOutputDynatraceOtlp | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._authTokenName !== undefined) {
      hasAnyValues = true;
      internalValueResult.authTokenName = this._authTokenName;
    }
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._concurrency !== undefined) {
      hasAnyValues = true;
      internalValueResult.concurrency = this._concurrency;
    }
    if (this._connectionTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.connectionTimeout = this._connectionTimeout;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._endpoint !== undefined) {
      hasAnyValues = true;
      internalValueResult.endpoint = this._endpoint;
    }
    if (this._endpointType !== undefined) {
      hasAnyValues = true;
      internalValueResult.endpointType = this._endpointType;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._extraHttpHeaders?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.extraHttpHeaders = this._extraHttpHeaders?.internalValue;
    }
    if (this._failedRequestLoggingMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.failedRequestLoggingMode = this._failedRequestLoggingMode;
    }
    if (this._flushPeriodSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.flushPeriodSec = this._flushPeriodSec;
    }
    if (this._httpCompress !== undefined) {
      hasAnyValues = true;
      internalValueResult.httpCompress = this._httpCompress;
    }
    if (this._httpLogsEndpointOverride !== undefined) {
      hasAnyValues = true;
      internalValueResult.httpLogsEndpointOverride = this._httpLogsEndpointOverride;
    }
    if (this._httpMetricsEndpointOverride !== undefined) {
      hasAnyValues = true;
      internalValueResult.httpMetricsEndpointOverride = this._httpMetricsEndpointOverride;
    }
    if (this._httpTracesEndpointOverride !== undefined) {
      hasAnyValues = true;
      internalValueResult.httpTracesEndpointOverride = this._httpTracesEndpointOverride;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._keepAlive !== undefined) {
      hasAnyValues = true;
      internalValueResult.keepAlive = this._keepAlive;
    }
    if (this._keepAliveTime !== undefined) {
      hasAnyValues = true;
      internalValueResult.keepAliveTime = this._keepAliveTime;
    }
    if (this._maxPayloadSizeKb !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxPayloadSizeKb = this._maxPayloadSizeKb;
    }
    if (this._metadata?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadata = this._metadata?.internalValue;
    }
    if (this._onBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.onBackpressure = this._onBackpressure;
    }
    if (this._otlpVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.otlpVersion = this._otlpVersion;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._pqCompress !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqCompress = this._pqCompress;
    }
    if (this._pqControls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqControls = this._pqControls?.internalValue;
    }
    if (this._pqMaxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxFileSize = this._pqMaxFileSize;
    }
    if (this._pqMaxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxSize = this._pqMaxSize;
    }
    if (this._pqMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMode = this._pqMode;
    }
    if (this._pqOnBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqOnBackpressure = this._pqOnBackpressure;
    }
    if (this._pqPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqPath = this._pqPath;
    }
    if (this._protocol !== undefined) {
      hasAnyValues = true;
      internalValueResult.protocol = this._protocol;
    }
    if (this._rejectUnauthorized !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectUnauthorized = this._rejectUnauthorized;
    }
    if (this._responseHonorRetryAfterHeader !== undefined) {
      hasAnyValues = true;
      internalValueResult.responseHonorRetryAfterHeader = this._responseHonorRetryAfterHeader;
    }
    if (this._responseRetrySettings?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.responseRetrySettings = this._responseRetrySettings?.internalValue;
    }
    if (this._safeHeaders !== undefined) {
      hasAnyValues = true;
      internalValueResult.safeHeaders = this._safeHeaders;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._systemFields !== undefined) {
      hasAnyValues = true;
      internalValueResult.systemFields = this._systemFields;
    }
    if (this._timeoutRetrySettings?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutRetrySettings = this._timeoutRetrySettings?.internalValue;
    }
    if (this._timeoutSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutSec = this._timeoutSec;
    }
    if (this._tokenSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.tokenSecret = this._tokenSecret;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._useRoundRobinDns !== undefined) {
      hasAnyValues = true;
      internalValueResult.useRoundRobinDns = this._useRoundRobinDns;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputDynatraceOtlp | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._authTokenName = undefined;
      this._compress = undefined;
      this._concurrency = undefined;
      this._connectionTimeout = undefined;
      this._description = undefined;
      this._endpoint = undefined;
      this._endpointType = undefined;
      this._environment = undefined;
      this._extraHttpHeaders.internalValue = undefined;
      this._failedRequestLoggingMode = undefined;
      this._flushPeriodSec = undefined;
      this._httpCompress = undefined;
      this._httpLogsEndpointOverride = undefined;
      this._httpMetricsEndpointOverride = undefined;
      this._httpTracesEndpointOverride = undefined;
      this._id = undefined;
      this._keepAlive = undefined;
      this._keepAliveTime = undefined;
      this._maxPayloadSizeKb = undefined;
      this._metadata.internalValue = undefined;
      this._onBackpressure = undefined;
      this._otlpVersion = undefined;
      this._pipeline = undefined;
      this._pqCompress = undefined;
      this._pqControls.internalValue = undefined;
      this._pqMaxFileSize = undefined;
      this._pqMaxSize = undefined;
      this._pqMode = undefined;
      this._pqOnBackpressure = undefined;
      this._pqPath = undefined;
      this._protocol = undefined;
      this._rejectUnauthorized = undefined;
      this._responseHonorRetryAfterHeader = undefined;
      this._responseRetrySettings.internalValue = undefined;
      this._safeHeaders = undefined;
      this._streamtags = undefined;
      this._systemFields = undefined;
      this._timeoutRetrySettings.internalValue = undefined;
      this._timeoutSec = undefined;
      this._tokenSecret = undefined;
      this._type = undefined;
      this._useRoundRobinDns = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._authTokenName = value.authTokenName;
      this._compress = value.compress;
      this._concurrency = value.concurrency;
      this._connectionTimeout = value.connectionTimeout;
      this._description = value.description;
      this._endpoint = value.endpoint;
      this._endpointType = value.endpointType;
      this._environment = value.environment;
      this._extraHttpHeaders.internalValue = value.extraHttpHeaders;
      this._failedRequestLoggingMode = value.failedRequestLoggingMode;
      this._flushPeriodSec = value.flushPeriodSec;
      this._httpCompress = value.httpCompress;
      this._httpLogsEndpointOverride = value.httpLogsEndpointOverride;
      this._httpMetricsEndpointOverride = value.httpMetricsEndpointOverride;
      this._httpTracesEndpointOverride = value.httpTracesEndpointOverride;
      this._id = value.id;
      this._keepAlive = value.keepAlive;
      this._keepAliveTime = value.keepAliveTime;
      this._maxPayloadSizeKb = value.maxPayloadSizeKb;
      this._metadata.internalValue = value.metadata;
      this._onBackpressure = value.onBackpressure;
      this._otlpVersion = value.otlpVersion;
      this._pipeline = value.pipeline;
      this._pqCompress = value.pqCompress;
      this._pqControls.internalValue = value.pqControls;
      this._pqMaxFileSize = value.pqMaxFileSize;
      this._pqMaxSize = value.pqMaxSize;
      this._pqMode = value.pqMode;
      this._pqOnBackpressure = value.pqOnBackpressure;
      this._pqPath = value.pqPath;
      this._protocol = value.protocol;
      this._rejectUnauthorized = value.rejectUnauthorized;
      this._responseHonorRetryAfterHeader = value.responseHonorRetryAfterHeader;
      this._responseRetrySettings.internalValue = value.responseRetrySettings;
      this._safeHeaders = value.safeHeaders;
      this._streamtags = value.streamtags;
      this._systemFields = value.systemFields;
      this._timeoutRetrySettings.internalValue = value.timeoutRetrySettings;
      this._timeoutSec = value.timeoutSec;
      this._tokenSecret = value.tokenSecret;
      this._type = value.type;
      this._useRoundRobinDns = value.useRoundRobinDns;
    }
  }

  // auth_token_name - computed: true, optional: true, required: false
  private _authTokenName?: string; 
  public get authTokenName() {
    return this.getStringAttribute('auth_token_name');
  }
  public set authTokenName(value: string) {
    this._authTokenName = value;
  }
  public resetAuthTokenName() {
    this._authTokenName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authTokenNameInput() {
    return this._authTokenName;
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: string; 
  public get compress() {
    return this.getStringAttribute('compress');
  }
  public set compress(value: string) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // concurrency - computed: true, optional: true, required: false
  private _concurrency?: number; 
  public get concurrency() {
    return this.getNumberAttribute('concurrency');
  }
  public set concurrency(value: number) {
    this._concurrency = value;
  }
  public resetConcurrency() {
    this._concurrency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get concurrencyInput() {
    return this._concurrency;
  }

  // connection_timeout - computed: true, optional: true, required: false
  private _connectionTimeout?: number; 
  public get connectionTimeout() {
    return this.getNumberAttribute('connection_timeout');
  }
  public set connectionTimeout(value: number) {
    this._connectionTimeout = value;
  }
  public resetConnectionTimeout() {
    this._connectionTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectionTimeoutInput() {
    return this._connectionTimeout;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // endpoint - computed: true, optional: true, required: false
  private _endpoint?: string; 
  public get endpoint() {
    return this.getStringAttribute('endpoint');
  }
  public set endpoint(value: string) {
    this._endpoint = value;
  }
  public resetEndpoint() {
    this._endpoint = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get endpointInput() {
    return this._endpoint;
  }

  // endpoint_type - computed: true, optional: true, required: false
  private _endpointType?: string; 
  public get endpointType() {
    return this.getStringAttribute('endpoint_type');
  }
  public set endpointType(value: string) {
    this._endpointType = value;
  }
  public resetEndpointType() {
    this._endpointType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get endpointTypeInput() {
    return this._endpointType;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // extra_http_headers - computed: false, optional: true, required: false
  private _extraHttpHeaders = new PackDestinationOutputDynatraceOtlpExtraHttpHeadersList(this, "extra_http_headers", false);
  public get extraHttpHeaders() {
    return this._extraHttpHeaders;
  }
  public putExtraHttpHeaders(value: PackDestinationOutputDynatraceOtlpExtraHttpHeaders[] | cdktf.IResolvable) {
    this._extraHttpHeaders.internalValue = value;
  }
  public resetExtraHttpHeaders() {
    this._extraHttpHeaders.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get extraHttpHeadersInput() {
    return this._extraHttpHeaders.internalValue;
  }

  // failed_request_logging_mode - computed: true, optional: true, required: false
  private _failedRequestLoggingMode?: string; 
  public get failedRequestLoggingMode() {
    return this.getStringAttribute('failed_request_logging_mode');
  }
  public set failedRequestLoggingMode(value: string) {
    this._failedRequestLoggingMode = value;
  }
  public resetFailedRequestLoggingMode() {
    this._failedRequestLoggingMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get failedRequestLoggingModeInput() {
    return this._failedRequestLoggingMode;
  }

  // flush_period_sec - computed: true, optional: true, required: false
  private _flushPeriodSec?: number; 
  public get flushPeriodSec() {
    return this.getNumberAttribute('flush_period_sec');
  }
  public set flushPeriodSec(value: number) {
    this._flushPeriodSec = value;
  }
  public resetFlushPeriodSec() {
    this._flushPeriodSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get flushPeriodSecInput() {
    return this._flushPeriodSec;
  }

  // http_compress - computed: true, optional: true, required: false
  private _httpCompress?: string; 
  public get httpCompress() {
    return this.getStringAttribute('http_compress');
  }
  public set httpCompress(value: string) {
    this._httpCompress = value;
  }
  public resetHttpCompress() {
    this._httpCompress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get httpCompressInput() {
    return this._httpCompress;
  }

  // http_logs_endpoint_override - computed: false, optional: true, required: false
  private _httpLogsEndpointOverride?: string; 
  public get httpLogsEndpointOverride() {
    return this.getStringAttribute('http_logs_endpoint_override');
  }
  public set httpLogsEndpointOverride(value: string) {
    this._httpLogsEndpointOverride = value;
  }
  public resetHttpLogsEndpointOverride() {
    this._httpLogsEndpointOverride = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get httpLogsEndpointOverrideInput() {
    return this._httpLogsEndpointOverride;
  }

  // http_metrics_endpoint_override - computed: false, optional: true, required: false
  private _httpMetricsEndpointOverride?: string; 
  public get httpMetricsEndpointOverride() {
    return this.getStringAttribute('http_metrics_endpoint_override');
  }
  public set httpMetricsEndpointOverride(value: string) {
    this._httpMetricsEndpointOverride = value;
  }
  public resetHttpMetricsEndpointOverride() {
    this._httpMetricsEndpointOverride = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get httpMetricsEndpointOverrideInput() {
    return this._httpMetricsEndpointOverride;
  }

  // http_traces_endpoint_override - computed: false, optional: true, required: false
  private _httpTracesEndpointOverride?: string; 
  public get httpTracesEndpointOverride() {
    return this.getStringAttribute('http_traces_endpoint_override');
  }
  public set httpTracesEndpointOverride(value: string) {
    this._httpTracesEndpointOverride = value;
  }
  public resetHttpTracesEndpointOverride() {
    this._httpTracesEndpointOverride = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get httpTracesEndpointOverrideInput() {
    return this._httpTracesEndpointOverride;
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // keep_alive - computed: true, optional: true, required: false
  private _keepAlive?: boolean | cdktf.IResolvable; 
  public get keepAlive() {
    return this.getBooleanAttribute('keep_alive');
  }
  public set keepAlive(value: boolean | cdktf.IResolvable) {
    this._keepAlive = value;
  }
  public resetKeepAlive() {
    this._keepAlive = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keepAliveInput() {
    return this._keepAlive;
  }

  // keep_alive_time - computed: true, optional: true, required: false
  private _keepAliveTime?: number; 
  public get keepAliveTime() {
    return this.getNumberAttribute('keep_alive_time');
  }
  public set keepAliveTime(value: number) {
    this._keepAliveTime = value;
  }
  public resetKeepAliveTime() {
    this._keepAliveTime = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keepAliveTimeInput() {
    return this._keepAliveTime;
  }

  // max_payload_size_kb - computed: true, optional: true, required: false
  private _maxPayloadSizeKb?: number; 
  public get maxPayloadSizeKb() {
    return this.getNumberAttribute('max_payload_size_kb');
  }
  public set maxPayloadSizeKb(value: number) {
    this._maxPayloadSizeKb = value;
  }
  public resetMaxPayloadSizeKb() {
    this._maxPayloadSizeKb = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxPayloadSizeKbInput() {
    return this._maxPayloadSizeKb;
  }

  // metadata - computed: false, optional: true, required: false
  private _metadata = new PackDestinationOutputDynatraceOtlpMetadataList(this, "metadata", false);
  public get metadata() {
    return this._metadata;
  }
  public putMetadata(value: PackDestinationOutputDynatraceOtlpMetadata[] | cdktf.IResolvable) {
    this._metadata.internalValue = value;
  }
  public resetMetadata() {
    this._metadata.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataInput() {
    return this._metadata.internalValue;
  }

  // on_backpressure - computed: true, optional: true, required: false
  private _onBackpressure?: string; 
  public get onBackpressure() {
    return this.getStringAttribute('on_backpressure');
  }
  public set onBackpressure(value: string) {
    this._onBackpressure = value;
  }
  public resetOnBackpressure() {
    this._onBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get onBackpressureInput() {
    return this._onBackpressure;
  }

  // otlp_version - computed: true, optional: true, required: false
  private _otlpVersion?: string; 
  public get otlpVersion() {
    return this.getStringAttribute('otlp_version');
  }
  public set otlpVersion(value: string) {
    this._otlpVersion = value;
  }
  public resetOtlpVersion() {
    this._otlpVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get otlpVersionInput() {
    return this._otlpVersion;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // pq_compress - computed: true, optional: true, required: false
  private _pqCompress?: string; 
  public get pqCompress() {
    return this.getStringAttribute('pq_compress');
  }
  public set pqCompress(value: string) {
    this._pqCompress = value;
  }
  public resetPqCompress() {
    this._pqCompress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqCompressInput() {
    return this._pqCompress;
  }

  // pq_controls - computed: false, optional: true, required: false
  private _pqControls = new PackDestinationOutputDynatraceOtlpPqControlsOutputReference(this, "pq_controls");
  public get pqControls() {
    return this._pqControls;
  }
  public putPqControls(value: PackDestinationOutputDynatraceOtlpPqControls) {
    this._pqControls.internalValue = value;
  }
  public resetPqControls() {
    this._pqControls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqControlsInput() {
    return this._pqControls.internalValue;
  }

  // pq_max_file_size - computed: true, optional: true, required: false
  private _pqMaxFileSize?: string; 
  public get pqMaxFileSize() {
    return this.getStringAttribute('pq_max_file_size');
  }
  public set pqMaxFileSize(value: string) {
    this._pqMaxFileSize = value;
  }
  public resetPqMaxFileSize() {
    this._pqMaxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxFileSizeInput() {
    return this._pqMaxFileSize;
  }

  // pq_max_size - computed: true, optional: true, required: false
  private _pqMaxSize?: string; 
  public get pqMaxSize() {
    return this.getStringAttribute('pq_max_size');
  }
  public set pqMaxSize(value: string) {
    this._pqMaxSize = value;
  }
  public resetPqMaxSize() {
    this._pqMaxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxSizeInput() {
    return this._pqMaxSize;
  }

  // pq_mode - computed: true, optional: true, required: false
  private _pqMode?: string; 
  public get pqMode() {
    return this.getStringAttribute('pq_mode');
  }
  public set pqMode(value: string) {
    this._pqMode = value;
  }
  public resetPqMode() {
    this._pqMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqModeInput() {
    return this._pqMode;
  }

  // pq_on_backpressure - computed: true, optional: true, required: false
  private _pqOnBackpressure?: string; 
  public get pqOnBackpressure() {
    return this.getStringAttribute('pq_on_backpressure');
  }
  public set pqOnBackpressure(value: string) {
    this._pqOnBackpressure = value;
  }
  public resetPqOnBackpressure() {
    this._pqOnBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqOnBackpressureInput() {
    return this._pqOnBackpressure;
  }

  // pq_path - computed: true, optional: true, required: false
  private _pqPath?: string; 
  public get pqPath() {
    return this.getStringAttribute('pq_path');
  }
  public set pqPath(value: string) {
    this._pqPath = value;
  }
  public resetPqPath() {
    this._pqPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqPathInput() {
    return this._pqPath;
  }

  // protocol - computed: true, optional: true, required: false
  private _protocol?: string; 
  public get protocol() {
    return this.getStringAttribute('protocol');
  }
  public set protocol(value: string) {
    this._protocol = value;
  }
  public resetProtocol() {
    this._protocol = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get protocolInput() {
    return this._protocol;
  }

  // reject_unauthorized - computed: true, optional: true, required: false
  private _rejectUnauthorized?: boolean | cdktf.IResolvable; 
  public get rejectUnauthorized() {
    return this.getBooleanAttribute('reject_unauthorized');
  }
  public set rejectUnauthorized(value: boolean | cdktf.IResolvable) {
    this._rejectUnauthorized = value;
  }
  public resetRejectUnauthorized() {
    this._rejectUnauthorized = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectUnauthorizedInput() {
    return this._rejectUnauthorized;
  }

  // response_honor_retry_after_header - computed: true, optional: true, required: false
  private _responseHonorRetryAfterHeader?: boolean | cdktf.IResolvable; 
  public get responseHonorRetryAfterHeader() {
    return this.getBooleanAttribute('response_honor_retry_after_header');
  }
  public set responseHonorRetryAfterHeader(value: boolean | cdktf.IResolvable) {
    this._responseHonorRetryAfterHeader = value;
  }
  public resetResponseHonorRetryAfterHeader() {
    this._responseHonorRetryAfterHeader = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get responseHonorRetryAfterHeaderInput() {
    return this._responseHonorRetryAfterHeader;
  }

  // response_retry_settings - computed: false, optional: true, required: false
  private _responseRetrySettings = new PackDestinationOutputDynatraceOtlpResponseRetrySettingsList(this, "response_retry_settings", false);
  public get responseRetrySettings() {
    return this._responseRetrySettings;
  }
  public putResponseRetrySettings(value: PackDestinationOutputDynatraceOtlpResponseRetrySettings[] | cdktf.IResolvable) {
    this._responseRetrySettings.internalValue = value;
  }
  public resetResponseRetrySettings() {
    this._responseRetrySettings.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get responseRetrySettingsInput() {
    return this._responseRetrySettings.internalValue;
  }

  // safe_headers - computed: true, optional: true, required: false
  private _safeHeaders?: string[]; 
  public get safeHeaders() {
    return this.getListAttribute('safe_headers');
  }
  public set safeHeaders(value: string[]) {
    this._safeHeaders = value;
  }
  public resetSafeHeaders() {
    this._safeHeaders = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get safeHeadersInput() {
    return this._safeHeaders;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // system_fields - computed: true, optional: true, required: false
  private _systemFields?: string[]; 
  public get systemFields() {
    return this.getListAttribute('system_fields');
  }
  public set systemFields(value: string[]) {
    this._systemFields = value;
  }
  public resetSystemFields() {
    this._systemFields = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get systemFieldsInput() {
    return this._systemFields;
  }

  // timeout_retry_settings - computed: false, optional: true, required: false
  private _timeoutRetrySettings = new PackDestinationOutputDynatraceOtlpTimeoutRetrySettingsOutputReference(this, "timeout_retry_settings");
  public get timeoutRetrySettings() {
    return this._timeoutRetrySettings;
  }
  public putTimeoutRetrySettings(value: PackDestinationOutputDynatraceOtlpTimeoutRetrySettings) {
    this._timeoutRetrySettings.internalValue = value;
  }
  public resetTimeoutRetrySettings() {
    this._timeoutRetrySettings.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutRetrySettingsInput() {
    return this._timeoutRetrySettings.internalValue;
  }

  // timeout_sec - computed: true, optional: true, required: false
  private _timeoutSec?: number; 
  public get timeoutSec() {
    return this.getNumberAttribute('timeout_sec');
  }
  public set timeoutSec(value: number) {
    this._timeoutSec = value;
  }
  public resetTimeoutSec() {
    this._timeoutSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutSecInput() {
    return this._timeoutSec;
  }

  // token_secret - computed: false, optional: false, required: true
  private _tokenSecret?: string; 
  public get tokenSecret() {
    return this.getStringAttribute('token_secret');
  }
  public set tokenSecret(value: string) {
    this._tokenSecret = value;
  }
  // Temporarily expose input value. Use with caution.
  public get tokenSecretInput() {
    return this._tokenSecret;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // use_round_robin_dns - computed: true, optional: true, required: false
  private _useRoundRobinDns?: boolean | cdktf.IResolvable; 
  public get useRoundRobinDns() {
    return this.getBooleanAttribute('use_round_robin_dns');
  }
  public set useRoundRobinDns(value: boolean | cdktf.IResolvable) {
    this._useRoundRobinDns = value;
  }
  public resetUseRoundRobinDns() {
    this._useRoundRobinDns = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get useRoundRobinDnsInput() {
    return this._useRoundRobinDns;
  }
}
export interface PackDestinationOutputElasticAuth {
  /**
  * Enter credentials directly, or select a stored secret. Default: "manual"; must be one of ["manual", "secret", "manualAPIKey", "textSecret"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#auth_type PackDestination#auth_type}
  */
  readonly authType?: string;
  /**
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#disabled PackDestination#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
}

export function packDestinationOutputElasticAuthToTerraform(struct?: PackDestinationOutputElasticAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    auth_type: cdktf.stringToTerraform(struct!.authType),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
  }
}


export function packDestinationOutputElasticAuthToHclTerraform(struct?: PackDestinationOutputElasticAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    auth_type: {
      value: cdktf.stringToHclTerraform(struct!.authType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputElasticAuthOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackDestinationOutputElasticAuth | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._authType !== undefined) {
      hasAnyValues = true;
      internalValueResult.authType = this._authType;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputElasticAuth | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._authType = undefined;
      this._disabled = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._authType = value.authType;
      this._disabled = value.disabled;
    }
  }

  // auth_type - computed: true, optional: true, required: false
  private _authType?: string; 
  public get authType() {
    return this.getStringAttribute('auth_type');
  }
  public set authType(value: string) {
    this._authType = value;
  }
  public resetAuthType() {
    this._authType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authTypeInput() {
    return this._authType;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }
}
export interface PackDestinationOutputElasticExtraHttpHeaders {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#name PackDestination#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#value PackDestination#value}
  */
  readonly value: string;
}

export function packDestinationOutputElasticExtraHttpHeadersToTerraform(struct?: PackDestinationOutputElasticExtraHttpHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function packDestinationOutputElasticExtraHttpHeadersToHclTerraform(struct?: PackDestinationOutputElasticExtraHttpHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputElasticExtraHttpHeadersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackDestinationOutputElasticExtraHttpHeaders | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputElasticExtraHttpHeaders | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class PackDestinationOutputElasticExtraHttpHeadersList extends cdktf.ComplexList {
  public internalValue? : PackDestinationOutputElasticExtraHttpHeaders[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackDestinationOutputElasticExtraHttpHeadersOutputReference {
    return new PackDestinationOutputElasticExtraHttpHeadersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackDestinationOutputElasticExtraParams {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#name PackDestination#name}
  */
  readonly name: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#value PackDestination#value}
  */
  readonly value: string;
}

export function packDestinationOutputElasticExtraParamsToTerraform(struct?: PackDestinationOutputElasticExtraParams | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function packDestinationOutputElasticExtraParamsToHclTerraform(struct?: PackDestinationOutputElasticExtraParams | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputElasticExtraParamsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackDestinationOutputElasticExtraParams | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputElasticExtraParams | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class PackDestinationOutputElasticExtraParamsList extends cdktf.ComplexList {
  public internalValue? : PackDestinationOutputElasticExtraParams[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackDestinationOutputElasticExtraParamsOutputReference {
    return new PackDestinationOutputElasticExtraParamsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackDestinationOutputElasticPqControls {
}

export function packDestinationOutputElasticPqControlsToTerraform(struct?: PackDestinationOutputElasticPqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function packDestinationOutputElasticPqControlsToHclTerraform(struct?: PackDestinationOutputElasticPqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class PackDestinationOutputElasticPqControlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackDestinationOutputElasticPqControls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputElasticPqControls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface PackDestinationOutputElasticResponseRetrySettings {
  /**
  * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc. Default: 2
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#backoff_rate PackDestination#backoff_rate}
  */
  readonly backoffRate?: number;
  /**
  * The HTTP response status code that will trigger retries
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#http_status PackDestination#http_status}
  */
  readonly httpStatus: number;
  /**
  * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes). Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#initial_backoff PackDestination#initial_backoff}
  */
  readonly initialBackoff?: number;
  /**
  * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds). Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_backoff PackDestination#max_backoff}
  */
  readonly maxBackoff?: number;
}

export function packDestinationOutputElasticResponseRetrySettingsToTerraform(struct?: PackDestinationOutputElasticResponseRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    backoff_rate: cdktf.numberToTerraform(struct!.backoffRate),
    http_status: cdktf.numberToTerraform(struct!.httpStatus),
    initial_backoff: cdktf.numberToTerraform(struct!.initialBackoff),
    max_backoff: cdktf.numberToTerraform(struct!.maxBackoff),
  }
}


export function packDestinationOutputElasticResponseRetrySettingsToHclTerraform(struct?: PackDestinationOutputElasticResponseRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    backoff_rate: {
      value: cdktf.numberToHclTerraform(struct!.backoffRate),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    http_status: {
      value: cdktf.numberToHclTerraform(struct!.httpStatus),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    initial_backoff: {
      value: cdktf.numberToHclTerraform(struct!.initialBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_backoff: {
      value: cdktf.numberToHclTerraform(struct!.maxBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputElasticResponseRetrySettingsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackDestinationOutputElasticResponseRetrySettings | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._backoffRate !== undefined) {
      hasAnyValues = true;
      internalValueResult.backoffRate = this._backoffRate;
    }
    if (this._httpStatus !== undefined) {
      hasAnyValues = true;
      internalValueResult.httpStatus = this._httpStatus;
    }
    if (this._initialBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.initialBackoff = this._initialBackoff;
    }
    if (this._maxBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBackoff = this._maxBackoff;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputElasticResponseRetrySettings | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._backoffRate = undefined;
      this._httpStatus = undefined;
      this._initialBackoff = undefined;
      this._maxBackoff = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._backoffRate = value.backoffRate;
      this._httpStatus = value.httpStatus;
      this._initialBackoff = value.initialBackoff;
      this._maxBackoff = value.maxBackoff;
    }
  }

  // backoff_rate - computed: true, optional: true, required: false
  private _backoffRate?: number; 
  public get backoffRate() {
    return this.getNumberAttribute('backoff_rate');
  }
  public set backoffRate(value: number) {
    this._backoffRate = value;
  }
  public resetBackoffRate() {
    this._backoffRate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get backoffRateInput() {
    return this._backoffRate;
  }

  // http_status - computed: false, optional: false, required: true
  private _httpStatus?: number; 
  public get httpStatus() {
    return this.getNumberAttribute('http_status');
  }
  public set httpStatus(value: number) {
    this._httpStatus = value;
  }
  // Temporarily expose input value. Use with caution.
  public get httpStatusInput() {
    return this._httpStatus;
  }

  // initial_backoff - computed: true, optional: true, required: false
  private _initialBackoff?: number; 
  public get initialBackoff() {
    return this.getNumberAttribute('initial_backoff');
  }
  public set initialBackoff(value: number) {
    this._initialBackoff = value;
  }
  public resetInitialBackoff() {
    this._initialBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get initialBackoffInput() {
    return this._initialBackoff;
  }

  // max_backoff - computed: true, optional: true, required: false
  private _maxBackoff?: number; 
  public get maxBackoff() {
    return this.getNumberAttribute('max_backoff');
  }
  public set maxBackoff(value: number) {
    this._maxBackoff = value;
  }
  public resetMaxBackoff() {
    this._maxBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBackoffInput() {
    return this._maxBackoff;
  }
}

export class PackDestinationOutputElasticResponseRetrySettingsList extends cdktf.ComplexList {
  public internalValue? : PackDestinationOutputElasticResponseRetrySettings[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackDestinationOutputElasticResponseRetrySettingsOutputReference {
    return new PackDestinationOutputElasticResponseRetrySettingsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackDestinationOutputElasticTimeoutRetrySettings {
  /**
  * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc. Default: 2
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#backoff_rate PackDestination#backoff_rate}
  */
  readonly backoffRate?: number;
  /**
  * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes). Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#initial_backoff PackDestination#initial_backoff}
  */
  readonly initialBackoff?: number;
  /**
  * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds). Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_backoff PackDestination#max_backoff}
  */
  readonly maxBackoff?: number;
  /**
  * Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#timeout_retry PackDestination#timeout_retry}
  */
  readonly timeoutRetry?: boolean | cdktf.IResolvable;
}

export function packDestinationOutputElasticTimeoutRetrySettingsToTerraform(struct?: PackDestinationOutputElasticTimeoutRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    backoff_rate: cdktf.numberToTerraform(struct!.backoffRate),
    initial_backoff: cdktf.numberToTerraform(struct!.initialBackoff),
    max_backoff: cdktf.numberToTerraform(struct!.maxBackoff),
    timeout_retry: cdktf.booleanToTerraform(struct!.timeoutRetry),
  }
}


export function packDestinationOutputElasticTimeoutRetrySettingsToHclTerraform(struct?: PackDestinationOutputElasticTimeoutRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    backoff_rate: {
      value: cdktf.numberToHclTerraform(struct!.backoffRate),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    initial_backoff: {
      value: cdktf.numberToHclTerraform(struct!.initialBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_backoff: {
      value: cdktf.numberToHclTerraform(struct!.maxBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    timeout_retry: {
      value: cdktf.booleanToHclTerraform(struct!.timeoutRetry),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputElasticTimeoutRetrySettingsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackDestinationOutputElasticTimeoutRetrySettings | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._backoffRate !== undefined) {
      hasAnyValues = true;
      internalValueResult.backoffRate = this._backoffRate;
    }
    if (this._initialBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.initialBackoff = this._initialBackoff;
    }
    if (this._maxBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBackoff = this._maxBackoff;
    }
    if (this._timeoutRetry !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutRetry = this._timeoutRetry;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputElasticTimeoutRetrySettings | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._backoffRate = undefined;
      this._initialBackoff = undefined;
      this._maxBackoff = undefined;
      this._timeoutRetry = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._backoffRate = value.backoffRate;
      this._initialBackoff = value.initialBackoff;
      this._maxBackoff = value.maxBackoff;
      this._timeoutRetry = value.timeoutRetry;
    }
  }

  // backoff_rate - computed: true, optional: true, required: false
  private _backoffRate?: number; 
  public get backoffRate() {
    return this.getNumberAttribute('backoff_rate');
  }
  public set backoffRate(value: number) {
    this._backoffRate = value;
  }
  public resetBackoffRate() {
    this._backoffRate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get backoffRateInput() {
    return this._backoffRate;
  }

  // initial_backoff - computed: true, optional: true, required: false
  private _initialBackoff?: number; 
  public get initialBackoff() {
    return this.getNumberAttribute('initial_backoff');
  }
  public set initialBackoff(value: number) {
    this._initialBackoff = value;
  }
  public resetInitialBackoff() {
    this._initialBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get initialBackoffInput() {
    return this._initialBackoff;
  }

  // max_backoff - computed: true, optional: true, required: false
  private _maxBackoff?: number; 
  public get maxBackoff() {
    return this.getNumberAttribute('max_backoff');
  }
  public set maxBackoff(value: number) {
    this._maxBackoff = value;
  }
  public resetMaxBackoff() {
    this._maxBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBackoffInput() {
    return this._maxBackoff;
  }

  // timeout_retry - computed: true, optional: true, required: false
  private _timeoutRetry?: boolean | cdktf.IResolvable; 
  public get timeoutRetry() {
    return this.getBooleanAttribute('timeout_retry');
  }
  public set timeoutRetry(value: boolean | cdktf.IResolvable) {
    this._timeoutRetry = value;
  }
  public resetTimeoutRetry() {
    this._timeoutRetry = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutRetryInput() {
    return this._timeoutRetry;
  }
}
export interface PackDestinationOutputElasticUrls {
  /**
  * The URL to an Elastic node to send events to. Example: http://elastic:9200/_bulk
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#url PackDestination#url}
  */
  readonly url: string;
  /**
  * Assign a weight (>0) to each endpoint to indicate its traffic-handling capability. Default: 1
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#weight PackDestination#weight}
  */
  readonly weight?: number;
}

export function packDestinationOutputElasticUrlsToTerraform(struct?: PackDestinationOutputElasticUrls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    url: cdktf.stringToTerraform(struct!.url),
    weight: cdktf.numberToTerraform(struct!.weight),
  }
}


export function packDestinationOutputElasticUrlsToHclTerraform(struct?: PackDestinationOutputElasticUrls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    url: {
      value: cdktf.stringToHclTerraform(struct!.url),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    weight: {
      value: cdktf.numberToHclTerraform(struct!.weight),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputElasticUrlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackDestinationOutputElasticUrls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._url !== undefined) {
      hasAnyValues = true;
      internalValueResult.url = this._url;
    }
    if (this._weight !== undefined) {
      hasAnyValues = true;
      internalValueResult.weight = this._weight;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputElasticUrls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._url = undefined;
      this._weight = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._url = value.url;
      this._weight = value.weight;
    }
  }

  // url - computed: false, optional: false, required: true
  private _url?: string; 
  public get url() {
    return this.getStringAttribute('url');
  }
  public set url(value: string) {
    this._url = value;
  }
  // Temporarily expose input value. Use with caution.
  public get urlInput() {
    return this._url;
  }

  // weight - computed: true, optional: true, required: false
  private _weight?: number; 
  public get weight() {
    return this.getNumberAttribute('weight');
  }
  public set weight(value: number) {
    this._weight = value;
  }
  public resetWeight() {
    this._weight = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get weightInput() {
    return this._weight;
  }
}

export class PackDestinationOutputElasticUrlsList extends cdktf.ComplexList {
  public internalValue? : PackDestinationOutputElasticUrls[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackDestinationOutputElasticUrlsOutputReference {
    return new PackDestinationOutputElasticUrlsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackDestinationOutputElastic {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#auth PackDestination#auth}
  */
  readonly auth?: PackDestinationOutputElasticAuth;
  /**
  * Compress the payload body before sending. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#compress PackDestination#compress}
  */
  readonly compress?: boolean | cdktf.IResolvable;
  /**
  * Maximum number of ongoing requests before blocking. Default: 5
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#concurrency PackDestination#concurrency}
  */
  readonly concurrency?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#description PackDestination#description}
  */
  readonly description?: string;
  /**
  * The interval in which to re-resolve any hostnames and pick up destinations from A records. Default: 600
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#dns_resolve_period_sec PackDestination#dns_resolve_period_sec}
  */
  readonly dnsResolvePeriodSec?: number;
  /**
  * Document type to use for events. Can be overwritten by an event's __type field.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#doc_type PackDestination#doc_type}
  */
  readonly docType?: string;
  /**
  * Optional Elasticsearch destination pipeline
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#elastic_pipeline PackDestination#elastic_pipeline}
  */
  readonly elasticPipeline?: string;
  /**
  * Optional Elasticsearch version, used to format events. If not specified, will auto-discover version. Default: "auto"; must be one of ["auto", "6", "7"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#elastic_version PackDestination#elastic_version}
  */
  readonly elasticVersion?: string;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#environment PackDestination#environment}
  */
  readonly environment?: string;
  /**
  * Exclude all IPs of the current host from the list of any resolved hostnames. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#exclude_self PackDestination#exclude_self}
  */
  readonly excludeSelf?: boolean | cdktf.IResolvable;
  /**
  * Headers to add to all events
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#extra_http_headers PackDestination#extra_http_headers}
  */
  readonly extraHttpHeaders?: PackDestinationOutputElasticExtraHttpHeaders[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#extra_params PackDestination#extra_params}
  */
  readonly extraParams?: PackDestinationOutputElasticExtraParams[] | cdktf.IResolvable;
  /**
  * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below. Default: "none"; must be one of ["payload", "payloadAndHeaders", "none"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#failed_request_logging_mode PackDestination#failed_request_logging_mode}
  */
  readonly failedRequestLoggingMode?: string;
  /**
  * Maximum time between requests. Small values could cause the payload size to be smaller than the configured Body size limit. Default: 1
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#flush_period_sec PackDestination#flush_period_sec}
  */
  readonly flushPeriodSec?: number;
  /**
  * Unique ID for this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#id PackDestination#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * Include the `document_id` field when sending events to an Elastic TSDS (time series data stream). Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#include_doc_id PackDestination#include_doc_id}
  */
  readonly includeDocId?: boolean | cdktf.IResolvable;
  /**
  * Index or data stream to send events to. Must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can be overwritten by an event's __index field.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#index PackDestination#index}
  */
  readonly index: string;
  /**
  * How far back in time to keep traffic stats for load balancing purposes. Default: 300
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#load_balance_stats_period_sec PackDestination#load_balance_stats_period_sec}
  */
  readonly loadBalanceStatsPeriodSec?: number;
  /**
  * Enable for optimal performance. Even if you have one hostname, it can expand to multiple IPs. If disabled, consider enabling round-robin DNS. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#load_balanced PackDestination#load_balanced}
  */
  readonly loadBalanced?: boolean | cdktf.IResolvable;
  /**
  * Maximum number of events to include in the request body. Default is 0 (unlimited). Default: 0
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_payload_events PackDestination#max_payload_events}
  */
  readonly maxPayloadEvents?: number;
  /**
  * Maximum size, in KB, of the request body. Default: 4096
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_payload_size_kb PackDestination#max_payload_size_kb}
  */
  readonly maxPayloadSizeKb?: number;
  /**
  * How to handle events when all receivers are exerting backpressure. Default: "block"; must be one of ["block", "drop", "queue"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#on_backpressure PackDestination#on_backpressure}
  */
  readonly onBackpressure?: string;
  /**
  * Pipeline to process data before sending out to this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pipeline PackDestination#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_compress PackDestination#pq_compress}
  */
  readonly pqCompress?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_controls PackDestination#pq_controls}
  */
  readonly pqControls?: PackDestinationOutputElasticPqControls;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.). Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_max_file_size PackDestination#pq_max_file_size}
  */
  readonly pqMaxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_max_size PackDestination#pq_max_size}
  */
  readonly pqMaxSize?: string;
  /**
  * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem. Default: "error"; must be one of ["error", "backpressure", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_mode PackDestination#pq_mode}
  */
  readonly pqMode?: string;
  /**
  * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged. Default: "block"; must be one of ["block", "drop"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_on_backpressure PackDestination#pq_on_backpressure}
  */
  readonly pqOnBackpressure?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_path PackDestination#pq_path}
  */
  readonly pqPath?: string;
  /**
  * Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's). 
  *         Enabled by default. When this setting is also present in TLS Settings (Client Side), 
  *         that value will take precedence.
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#reject_unauthorized PackDestination#reject_unauthorized}
  */
  readonly rejectUnauthorized?: boolean | cdktf.IResolvable;
  /**
  * Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#response_honor_retry_after_header PackDestination#response_honor_retry_after_header}
  */
  readonly responseHonorRetryAfterHeader?: boolean | cdktf.IResolvable;
  /**
  * Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#response_retry_settings PackDestination#response_retry_settings}
  */
  readonly responseRetrySettings?: PackDestinationOutputElasticResponseRetrySettings[] | cdktf.IResolvable;
  /**
  * Retry failed events when a bulk request to Elastic is successful, but the response body returns an error for one or more events in the batch. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#retry_partial_errors PackDestination#retry_partial_errors}
  */
  readonly retryPartialErrors?: boolean | cdktf.IResolvable;
  /**
  * List of headers that are safe to log in plain text. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#safe_headers PackDestination#safe_headers}
  */
  readonly safeHeaders?: string[];
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#streamtags PackDestination#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Fields to automatically add to events, such as cribl_pipe. Supports wildcards. Default: ["cribl_pipe"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#system_fields PackDestination#system_fields}
  */
  readonly systemFields?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#timeout_retry_settings PackDestination#timeout_retry_settings}
  */
  readonly timeoutRetrySettings?: PackDestinationOutputElasticTimeoutRetrySettings;
  /**
  * Amount of time, in seconds, to wait for a request to complete before canceling it. Default: 30
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#timeout_sec PackDestination#timeout_sec}
  */
  readonly timeoutSec?: number;
  /**
  * must be "elastic"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#type PackDestination#type}
  */
  readonly type: string;
  /**
  * The Cloud ID or URL to an Elastic cluster to send events to. Example: http://elastic:9200/_bulk
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#url PackDestination#url}
  */
  readonly url?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#urls PackDestination#urls}
  */
  readonly urls?: PackDestinationOutputElasticUrls[] | cdktf.IResolvable;
  /**
  * Enable round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. For optimal performance, consider enabling this setting for non-load balanced destinations. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#use_round_robin_dns PackDestination#use_round_robin_dns}
  */
  readonly useRoundRobinDns?: boolean | cdktf.IResolvable;
  /**
  * Action to use when writing events. Must be set to `Create` when writing to a data stream. Default: "create"; must be one of ["index", "create"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#write_action PackDestination#write_action}
  */
  readonly writeAction?: string;
}

export function packDestinationOutputElasticToTerraform(struct?: PackDestinationOutputElastic | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    auth: packDestinationOutputElasticAuthToTerraform(struct!.auth),
    compress: cdktf.booleanToTerraform(struct!.compress),
    concurrency: cdktf.numberToTerraform(struct!.concurrency),
    description: cdktf.stringToTerraform(struct!.description),
    dns_resolve_period_sec: cdktf.numberToTerraform(struct!.dnsResolvePeriodSec),
    doc_type: cdktf.stringToTerraform(struct!.docType),
    elastic_pipeline: cdktf.stringToTerraform(struct!.elasticPipeline),
    elastic_version: cdktf.stringToTerraform(struct!.elasticVersion),
    environment: cdktf.stringToTerraform(struct!.environment),
    exclude_self: cdktf.booleanToTerraform(struct!.excludeSelf),
    extra_http_headers: cdktf.listMapper(packDestinationOutputElasticExtraHttpHeadersToTerraform, false)(struct!.extraHttpHeaders),
    extra_params: cdktf.listMapper(packDestinationOutputElasticExtraParamsToTerraform, false)(struct!.extraParams),
    failed_request_logging_mode: cdktf.stringToTerraform(struct!.failedRequestLoggingMode),
    flush_period_sec: cdktf.numberToTerraform(struct!.flushPeriodSec),
    id: cdktf.stringToTerraform(struct!.id),
    include_doc_id: cdktf.booleanToTerraform(struct!.includeDocId),
    index: cdktf.stringToTerraform(struct!.index),
    load_balance_stats_period_sec: cdktf.numberToTerraform(struct!.loadBalanceStatsPeriodSec),
    load_balanced: cdktf.booleanToTerraform(struct!.loadBalanced),
    max_payload_events: cdktf.numberToTerraform(struct!.maxPayloadEvents),
    max_payload_size_kb: cdktf.numberToTerraform(struct!.maxPayloadSizeKb),
    on_backpressure: cdktf.stringToTerraform(struct!.onBackpressure),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    pq_compress: cdktf.stringToTerraform(struct!.pqCompress),
    pq_controls: packDestinationOutputElasticPqControlsToTerraform(struct!.pqControls),
    pq_max_file_size: cdktf.stringToTerraform(struct!.pqMaxFileSize),
    pq_max_size: cdktf.stringToTerraform(struct!.pqMaxSize),
    pq_mode: cdktf.stringToTerraform(struct!.pqMode),
    pq_on_backpressure: cdktf.stringToTerraform(struct!.pqOnBackpressure),
    pq_path: cdktf.stringToTerraform(struct!.pqPath),
    reject_unauthorized: cdktf.booleanToTerraform(struct!.rejectUnauthorized),
    response_honor_retry_after_header: cdktf.booleanToTerraform(struct!.responseHonorRetryAfterHeader),
    response_retry_settings: cdktf.listMapper(packDestinationOutputElasticResponseRetrySettingsToTerraform, false)(struct!.responseRetrySettings),
    retry_partial_errors: cdktf.booleanToTerraform(struct!.retryPartialErrors),
    safe_headers: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.safeHeaders),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    system_fields: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.systemFields),
    timeout_retry_settings: packDestinationOutputElasticTimeoutRetrySettingsToTerraform(struct!.timeoutRetrySettings),
    timeout_sec: cdktf.numberToTerraform(struct!.timeoutSec),
    type: cdktf.stringToTerraform(struct!.type),
    url: cdktf.stringToTerraform(struct!.url),
    urls: cdktf.listMapper(packDestinationOutputElasticUrlsToTerraform, false)(struct!.urls),
    use_round_robin_dns: cdktf.booleanToTerraform(struct!.useRoundRobinDns),
    write_action: cdktf.stringToTerraform(struct!.writeAction),
  }
}


export function packDestinationOutputElasticToHclTerraform(struct?: PackDestinationOutputElastic | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    auth: {
      value: packDestinationOutputElasticAuthToHclTerraform(struct!.auth),
      isBlock: true,
      type: "struct",
      storageClassType: "PackDestinationOutputElasticAuth",
    },
    compress: {
      value: cdktf.booleanToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    concurrency: {
      value: cdktf.numberToHclTerraform(struct!.concurrency),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    dns_resolve_period_sec: {
      value: cdktf.numberToHclTerraform(struct!.dnsResolvePeriodSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    doc_type: {
      value: cdktf.stringToHclTerraform(struct!.docType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    elastic_pipeline: {
      value: cdktf.stringToHclTerraform(struct!.elasticPipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    elastic_version: {
      value: cdktf.stringToHclTerraform(struct!.elasticVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    exclude_self: {
      value: cdktf.booleanToHclTerraform(struct!.excludeSelf),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    extra_http_headers: {
      value: cdktf.listMapperHcl(packDestinationOutputElasticExtraHttpHeadersToHclTerraform, false)(struct!.extraHttpHeaders),
      isBlock: true,
      type: "list",
      storageClassType: "PackDestinationOutputElasticExtraHttpHeadersList",
    },
    extra_params: {
      value: cdktf.listMapperHcl(packDestinationOutputElasticExtraParamsToHclTerraform, false)(struct!.extraParams),
      isBlock: true,
      type: "list",
      storageClassType: "PackDestinationOutputElasticExtraParamsList",
    },
    failed_request_logging_mode: {
      value: cdktf.stringToHclTerraform(struct!.failedRequestLoggingMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    flush_period_sec: {
      value: cdktf.numberToHclTerraform(struct!.flushPeriodSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    include_doc_id: {
      value: cdktf.booleanToHclTerraform(struct!.includeDocId),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    index: {
      value: cdktf.stringToHclTerraform(struct!.index),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    load_balance_stats_period_sec: {
      value: cdktf.numberToHclTerraform(struct!.loadBalanceStatsPeriodSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    load_balanced: {
      value: cdktf.booleanToHclTerraform(struct!.loadBalanced),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    max_payload_events: {
      value: cdktf.numberToHclTerraform(struct!.maxPayloadEvents),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_payload_size_kb: {
      value: cdktf.numberToHclTerraform(struct!.maxPayloadSizeKb),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.onBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_compress: {
      value: cdktf.stringToHclTerraform(struct!.pqCompress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_controls: {
      value: packDestinationOutputElasticPqControlsToHclTerraform(struct!.pqControls),
      isBlock: true,
      type: "struct",
      storageClassType: "PackDestinationOutputElasticPqControls",
    },
    pq_max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_max_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_mode: {
      value: cdktf.stringToHclTerraform(struct!.pqMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.pqOnBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_path: {
      value: cdktf.stringToHclTerraform(struct!.pqPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reject_unauthorized: {
      value: cdktf.booleanToHclTerraform(struct!.rejectUnauthorized),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    response_honor_retry_after_header: {
      value: cdktf.booleanToHclTerraform(struct!.responseHonorRetryAfterHeader),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    response_retry_settings: {
      value: cdktf.listMapperHcl(packDestinationOutputElasticResponseRetrySettingsToHclTerraform, false)(struct!.responseRetrySettings),
      isBlock: true,
      type: "list",
      storageClassType: "PackDestinationOutputElasticResponseRetrySettingsList",
    },
    retry_partial_errors: {
      value: cdktf.booleanToHclTerraform(struct!.retryPartialErrors),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    safe_headers: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.safeHeaders),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    system_fields: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.systemFields),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    timeout_retry_settings: {
      value: packDestinationOutputElasticTimeoutRetrySettingsToHclTerraform(struct!.timeoutRetrySettings),
      isBlock: true,
      type: "struct",
      storageClassType: "PackDestinationOutputElasticTimeoutRetrySettings",
    },
    timeout_sec: {
      value: cdktf.numberToHclTerraform(struct!.timeoutSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    url: {
      value: cdktf.stringToHclTerraform(struct!.url),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    urls: {
      value: cdktf.listMapperHcl(packDestinationOutputElasticUrlsToHclTerraform, false)(struct!.urls),
      isBlock: true,
      type: "list",
      storageClassType: "PackDestinationOutputElasticUrlsList",
    },
    use_round_robin_dns: {
      value: cdktf.booleanToHclTerraform(struct!.useRoundRobinDns),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    write_action: {
      value: cdktf.stringToHclTerraform(struct!.writeAction),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputElasticOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackDestinationOutputElastic | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._auth?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.auth = this._auth?.internalValue;
    }
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._concurrency !== undefined) {
      hasAnyValues = true;
      internalValueResult.concurrency = this._concurrency;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._dnsResolvePeriodSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.dnsResolvePeriodSec = this._dnsResolvePeriodSec;
    }
    if (this._docType !== undefined) {
      hasAnyValues = true;
      internalValueResult.docType = this._docType;
    }
    if (this._elasticPipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.elasticPipeline = this._elasticPipeline;
    }
    if (this._elasticVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.elasticVersion = this._elasticVersion;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._excludeSelf !== undefined) {
      hasAnyValues = true;
      internalValueResult.excludeSelf = this._excludeSelf;
    }
    if (this._extraHttpHeaders?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.extraHttpHeaders = this._extraHttpHeaders?.internalValue;
    }
    if (this._extraParams?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.extraParams = this._extraParams?.internalValue;
    }
    if (this._failedRequestLoggingMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.failedRequestLoggingMode = this._failedRequestLoggingMode;
    }
    if (this._flushPeriodSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.flushPeriodSec = this._flushPeriodSec;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._includeDocId !== undefined) {
      hasAnyValues = true;
      internalValueResult.includeDocId = this._includeDocId;
    }
    if (this._index !== undefined) {
      hasAnyValues = true;
      internalValueResult.index = this._index;
    }
    if (this._loadBalanceStatsPeriodSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.loadBalanceStatsPeriodSec = this._loadBalanceStatsPeriodSec;
    }
    if (this._loadBalanced !== undefined) {
      hasAnyValues = true;
      internalValueResult.loadBalanced = this._loadBalanced;
    }
    if (this._maxPayloadEvents !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxPayloadEvents = this._maxPayloadEvents;
    }
    if (this._maxPayloadSizeKb !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxPayloadSizeKb = this._maxPayloadSizeKb;
    }
    if (this._onBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.onBackpressure = this._onBackpressure;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._pqCompress !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqCompress = this._pqCompress;
    }
    if (this._pqControls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqControls = this._pqControls?.internalValue;
    }
    if (this._pqMaxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxFileSize = this._pqMaxFileSize;
    }
    if (this._pqMaxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxSize = this._pqMaxSize;
    }
    if (this._pqMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMode = this._pqMode;
    }
    if (this._pqOnBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqOnBackpressure = this._pqOnBackpressure;
    }
    if (this._pqPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqPath = this._pqPath;
    }
    if (this._rejectUnauthorized !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectUnauthorized = this._rejectUnauthorized;
    }
    if (this._responseHonorRetryAfterHeader !== undefined) {
      hasAnyValues = true;
      internalValueResult.responseHonorRetryAfterHeader = this._responseHonorRetryAfterHeader;
    }
    if (this._responseRetrySettings?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.responseRetrySettings = this._responseRetrySettings?.internalValue;
    }
    if (this._retryPartialErrors !== undefined) {
      hasAnyValues = true;
      internalValueResult.retryPartialErrors = this._retryPartialErrors;
    }
    if (this._safeHeaders !== undefined) {
      hasAnyValues = true;
      internalValueResult.safeHeaders = this._safeHeaders;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._systemFields !== undefined) {
      hasAnyValues = true;
      internalValueResult.systemFields = this._systemFields;
    }
    if (this._timeoutRetrySettings?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutRetrySettings = this._timeoutRetrySettings?.internalValue;
    }
    if (this._timeoutSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutSec = this._timeoutSec;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._url !== undefined) {
      hasAnyValues = true;
      internalValueResult.url = this._url;
    }
    if (this._urls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.urls = this._urls?.internalValue;
    }
    if (this._useRoundRobinDns !== undefined) {
      hasAnyValues = true;
      internalValueResult.useRoundRobinDns = this._useRoundRobinDns;
    }
    if (this._writeAction !== undefined) {
      hasAnyValues = true;
      internalValueResult.writeAction = this._writeAction;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputElastic | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._auth.internalValue = undefined;
      this._compress = undefined;
      this._concurrency = undefined;
      this._description = undefined;
      this._dnsResolvePeriodSec = undefined;
      this._docType = undefined;
      this._elasticPipeline = undefined;
      this._elasticVersion = undefined;
      this._environment = undefined;
      this._excludeSelf = undefined;
      this._extraHttpHeaders.internalValue = undefined;
      this._extraParams.internalValue = undefined;
      this._failedRequestLoggingMode = undefined;
      this._flushPeriodSec = undefined;
      this._id = undefined;
      this._includeDocId = undefined;
      this._index = undefined;
      this._loadBalanceStatsPeriodSec = undefined;
      this._loadBalanced = undefined;
      this._maxPayloadEvents = undefined;
      this._maxPayloadSizeKb = undefined;
      this._onBackpressure = undefined;
      this._pipeline = undefined;
      this._pqCompress = undefined;
      this._pqControls.internalValue = undefined;
      this._pqMaxFileSize = undefined;
      this._pqMaxSize = undefined;
      this._pqMode = undefined;
      this._pqOnBackpressure = undefined;
      this._pqPath = undefined;
      this._rejectUnauthorized = undefined;
      this._responseHonorRetryAfterHeader = undefined;
      this._responseRetrySettings.internalValue = undefined;
      this._retryPartialErrors = undefined;
      this._safeHeaders = undefined;
      this._streamtags = undefined;
      this._systemFields = undefined;
      this._timeoutRetrySettings.internalValue = undefined;
      this._timeoutSec = undefined;
      this._type = undefined;
      this._url = undefined;
      this._urls.internalValue = undefined;
      this._useRoundRobinDns = undefined;
      this._writeAction = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._auth.internalValue = value.auth;
      this._compress = value.compress;
      this._concurrency = value.concurrency;
      this._description = value.description;
      this._dnsResolvePeriodSec = value.dnsResolvePeriodSec;
      this._docType = value.docType;
      this._elasticPipeline = value.elasticPipeline;
      this._elasticVersion = value.elasticVersion;
      this._environment = value.environment;
      this._excludeSelf = value.excludeSelf;
      this._extraHttpHeaders.internalValue = value.extraHttpHeaders;
      this._extraParams.internalValue = value.extraParams;
      this._failedRequestLoggingMode = value.failedRequestLoggingMode;
      this._flushPeriodSec = value.flushPeriodSec;
      this._id = value.id;
      this._includeDocId = value.includeDocId;
      this._index = value.index;
      this._loadBalanceStatsPeriodSec = value.loadBalanceStatsPeriodSec;
      this._loadBalanced = value.loadBalanced;
      this._maxPayloadEvents = value.maxPayloadEvents;
      this._maxPayloadSizeKb = value.maxPayloadSizeKb;
      this._onBackpressure = value.onBackpressure;
      this._pipeline = value.pipeline;
      this._pqCompress = value.pqCompress;
      this._pqControls.internalValue = value.pqControls;
      this._pqMaxFileSize = value.pqMaxFileSize;
      this._pqMaxSize = value.pqMaxSize;
      this._pqMode = value.pqMode;
      this._pqOnBackpressure = value.pqOnBackpressure;
      this._pqPath = value.pqPath;
      this._rejectUnauthorized = value.rejectUnauthorized;
      this._responseHonorRetryAfterHeader = value.responseHonorRetryAfterHeader;
      this._responseRetrySettings.internalValue = value.responseRetrySettings;
      this._retryPartialErrors = value.retryPartialErrors;
      this._safeHeaders = value.safeHeaders;
      this._streamtags = value.streamtags;
      this._systemFields = value.systemFields;
      this._timeoutRetrySettings.internalValue = value.timeoutRetrySettings;
      this._timeoutSec = value.timeoutSec;
      this._type = value.type;
      this._url = value.url;
      this._urls.internalValue = value.urls;
      this._useRoundRobinDns = value.useRoundRobinDns;
      this._writeAction = value.writeAction;
    }
  }

  // auth - computed: false, optional: true, required: false
  private _auth = new PackDestinationOutputElasticAuthOutputReference(this, "auth");
  public get auth() {
    return this._auth;
  }
  public putAuth(value: PackDestinationOutputElasticAuth) {
    this._auth.internalValue = value;
  }
  public resetAuth() {
    this._auth.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authInput() {
    return this._auth.internalValue;
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: boolean | cdktf.IResolvable; 
  public get compress() {
    return this.getBooleanAttribute('compress');
  }
  public set compress(value: boolean | cdktf.IResolvable) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // concurrency - computed: true, optional: true, required: false
  private _concurrency?: number; 
  public get concurrency() {
    return this.getNumberAttribute('concurrency');
  }
  public set concurrency(value: number) {
    this._concurrency = value;
  }
  public resetConcurrency() {
    this._concurrency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get concurrencyInput() {
    return this._concurrency;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // dns_resolve_period_sec - computed: true, optional: true, required: false
  private _dnsResolvePeriodSec?: number; 
  public get dnsResolvePeriodSec() {
    return this.getNumberAttribute('dns_resolve_period_sec');
  }
  public set dnsResolvePeriodSec(value: number) {
    this._dnsResolvePeriodSec = value;
  }
  public resetDnsResolvePeriodSec() {
    this._dnsResolvePeriodSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dnsResolvePeriodSecInput() {
    return this._dnsResolvePeriodSec;
  }

  // doc_type - computed: false, optional: true, required: false
  private _docType?: string; 
  public get docType() {
    return this.getStringAttribute('doc_type');
  }
  public set docType(value: string) {
    this._docType = value;
  }
  public resetDocType() {
    this._docType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get docTypeInput() {
    return this._docType;
  }

  // elastic_pipeline - computed: false, optional: true, required: false
  private _elasticPipeline?: string; 
  public get elasticPipeline() {
    return this.getStringAttribute('elastic_pipeline');
  }
  public set elasticPipeline(value: string) {
    this._elasticPipeline = value;
  }
  public resetElasticPipeline() {
    this._elasticPipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get elasticPipelineInput() {
    return this._elasticPipeline;
  }

  // elastic_version - computed: true, optional: true, required: false
  private _elasticVersion?: string; 
  public get elasticVersion() {
    return this.getStringAttribute('elastic_version');
  }
  public set elasticVersion(value: string) {
    this._elasticVersion = value;
  }
  public resetElasticVersion() {
    this._elasticVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get elasticVersionInput() {
    return this._elasticVersion;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // exclude_self - computed: true, optional: true, required: false
  private _excludeSelf?: boolean | cdktf.IResolvable; 
  public get excludeSelf() {
    return this.getBooleanAttribute('exclude_self');
  }
  public set excludeSelf(value: boolean | cdktf.IResolvable) {
    this._excludeSelf = value;
  }
  public resetExcludeSelf() {
    this._excludeSelf = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get excludeSelfInput() {
    return this._excludeSelf;
  }

  // extra_http_headers - computed: false, optional: true, required: false
  private _extraHttpHeaders = new PackDestinationOutputElasticExtraHttpHeadersList(this, "extra_http_headers", false);
  public get extraHttpHeaders() {
    return this._extraHttpHeaders;
  }
  public putExtraHttpHeaders(value: PackDestinationOutputElasticExtraHttpHeaders[] | cdktf.IResolvable) {
    this._extraHttpHeaders.internalValue = value;
  }
  public resetExtraHttpHeaders() {
    this._extraHttpHeaders.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get extraHttpHeadersInput() {
    return this._extraHttpHeaders.internalValue;
  }

  // extra_params - computed: false, optional: true, required: false
  private _extraParams = new PackDestinationOutputElasticExtraParamsList(this, "extra_params", false);
  public get extraParams() {
    return this._extraParams;
  }
  public putExtraParams(value: PackDestinationOutputElasticExtraParams[] | cdktf.IResolvable) {
    this._extraParams.internalValue = value;
  }
  public resetExtraParams() {
    this._extraParams.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get extraParamsInput() {
    return this._extraParams.internalValue;
  }

  // failed_request_logging_mode - computed: true, optional: true, required: false
  private _failedRequestLoggingMode?: string; 
  public get failedRequestLoggingMode() {
    return this.getStringAttribute('failed_request_logging_mode');
  }
  public set failedRequestLoggingMode(value: string) {
    this._failedRequestLoggingMode = value;
  }
  public resetFailedRequestLoggingMode() {
    this._failedRequestLoggingMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get failedRequestLoggingModeInput() {
    return this._failedRequestLoggingMode;
  }

  // flush_period_sec - computed: true, optional: true, required: false
  private _flushPeriodSec?: number; 
  public get flushPeriodSec() {
    return this.getNumberAttribute('flush_period_sec');
  }
  public set flushPeriodSec(value: number) {
    this._flushPeriodSec = value;
  }
  public resetFlushPeriodSec() {
    this._flushPeriodSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get flushPeriodSecInput() {
    return this._flushPeriodSec;
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // include_doc_id - computed: true, optional: true, required: false
  private _includeDocId?: boolean | cdktf.IResolvable; 
  public get includeDocId() {
    return this.getBooleanAttribute('include_doc_id');
  }
  public set includeDocId(value: boolean | cdktf.IResolvable) {
    this._includeDocId = value;
  }
  public resetIncludeDocId() {
    this._includeDocId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get includeDocIdInput() {
    return this._includeDocId;
  }

  // index - computed: false, optional: false, required: true
  private _index?: string; 
  public get index() {
    return this.getStringAttribute('index');
  }
  public set index(value: string) {
    this._index = value;
  }
  // Temporarily expose input value. Use with caution.
  public get indexInput() {
    return this._index;
  }

  // load_balance_stats_period_sec - computed: true, optional: true, required: false
  private _loadBalanceStatsPeriodSec?: number; 
  public get loadBalanceStatsPeriodSec() {
    return this.getNumberAttribute('load_balance_stats_period_sec');
  }
  public set loadBalanceStatsPeriodSec(value: number) {
    this._loadBalanceStatsPeriodSec = value;
  }
  public resetLoadBalanceStatsPeriodSec() {
    this._loadBalanceStatsPeriodSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get loadBalanceStatsPeriodSecInput() {
    return this._loadBalanceStatsPeriodSec;
  }

  // load_balanced - computed: true, optional: true, required: false
  private _loadBalanced?: boolean | cdktf.IResolvable; 
  public get loadBalanced() {
    return this.getBooleanAttribute('load_balanced');
  }
  public set loadBalanced(value: boolean | cdktf.IResolvable) {
    this._loadBalanced = value;
  }
  public resetLoadBalanced() {
    this._loadBalanced = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get loadBalancedInput() {
    return this._loadBalanced;
  }

  // max_payload_events - computed: true, optional: true, required: false
  private _maxPayloadEvents?: number; 
  public get maxPayloadEvents() {
    return this.getNumberAttribute('max_payload_events');
  }
  public set maxPayloadEvents(value: number) {
    this._maxPayloadEvents = value;
  }
  public resetMaxPayloadEvents() {
    this._maxPayloadEvents = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxPayloadEventsInput() {
    return this._maxPayloadEvents;
  }

  // max_payload_size_kb - computed: true, optional: true, required: false
  private _maxPayloadSizeKb?: number; 
  public get maxPayloadSizeKb() {
    return this.getNumberAttribute('max_payload_size_kb');
  }
  public set maxPayloadSizeKb(value: number) {
    this._maxPayloadSizeKb = value;
  }
  public resetMaxPayloadSizeKb() {
    this._maxPayloadSizeKb = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxPayloadSizeKbInput() {
    return this._maxPayloadSizeKb;
  }

  // on_backpressure - computed: true, optional: true, required: false
  private _onBackpressure?: string; 
  public get onBackpressure() {
    return this.getStringAttribute('on_backpressure');
  }
  public set onBackpressure(value: string) {
    this._onBackpressure = value;
  }
  public resetOnBackpressure() {
    this._onBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get onBackpressureInput() {
    return this._onBackpressure;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // pq_compress - computed: true, optional: true, required: false
  private _pqCompress?: string; 
  public get pqCompress() {
    return this.getStringAttribute('pq_compress');
  }
  public set pqCompress(value: string) {
    this._pqCompress = value;
  }
  public resetPqCompress() {
    this._pqCompress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqCompressInput() {
    return this._pqCompress;
  }

  // pq_controls - computed: false, optional: true, required: false
  private _pqControls = new PackDestinationOutputElasticPqControlsOutputReference(this, "pq_controls");
  public get pqControls() {
    return this._pqControls;
  }
  public putPqControls(value: PackDestinationOutputElasticPqControls) {
    this._pqControls.internalValue = value;
  }
  public resetPqControls() {
    this._pqControls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqControlsInput() {
    return this._pqControls.internalValue;
  }

  // pq_max_file_size - computed: true, optional: true, required: false
  private _pqMaxFileSize?: string; 
  public get pqMaxFileSize() {
    return this.getStringAttribute('pq_max_file_size');
  }
  public set pqMaxFileSize(value: string) {
    this._pqMaxFileSize = value;
  }
  public resetPqMaxFileSize() {
    this._pqMaxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxFileSizeInput() {
    return this._pqMaxFileSize;
  }

  // pq_max_size - computed: true, optional: true, required: false
  private _pqMaxSize?: string; 
  public get pqMaxSize() {
    return this.getStringAttribute('pq_max_size');
  }
  public set pqMaxSize(value: string) {
    this._pqMaxSize = value;
  }
  public resetPqMaxSize() {
    this._pqMaxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxSizeInput() {
    return this._pqMaxSize;
  }

  // pq_mode - computed: true, optional: true, required: false
  private _pqMode?: string; 
  public get pqMode() {
    return this.getStringAttribute('pq_mode');
  }
  public set pqMode(value: string) {
    this._pqMode = value;
  }
  public resetPqMode() {
    this._pqMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqModeInput() {
    return this._pqMode;
  }

  // pq_on_backpressure - computed: true, optional: true, required: false
  private _pqOnBackpressure?: string; 
  public get pqOnBackpressure() {
    return this.getStringAttribute('pq_on_backpressure');
  }
  public set pqOnBackpressure(value: string) {
    this._pqOnBackpressure = value;
  }
  public resetPqOnBackpressure() {
    this._pqOnBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqOnBackpressureInput() {
    return this._pqOnBackpressure;
  }

  // pq_path - computed: true, optional: true, required: false
  private _pqPath?: string; 
  public get pqPath() {
    return this.getStringAttribute('pq_path');
  }
  public set pqPath(value: string) {
    this._pqPath = value;
  }
  public resetPqPath() {
    this._pqPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqPathInput() {
    return this._pqPath;
  }

  // reject_unauthorized - computed: true, optional: true, required: false
  private _rejectUnauthorized?: boolean | cdktf.IResolvable; 
  public get rejectUnauthorized() {
    return this.getBooleanAttribute('reject_unauthorized');
  }
  public set rejectUnauthorized(value: boolean | cdktf.IResolvable) {
    this._rejectUnauthorized = value;
  }
  public resetRejectUnauthorized() {
    this._rejectUnauthorized = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectUnauthorizedInput() {
    return this._rejectUnauthorized;
  }

  // response_honor_retry_after_header - computed: true, optional: true, required: false
  private _responseHonorRetryAfterHeader?: boolean | cdktf.IResolvable; 
  public get responseHonorRetryAfterHeader() {
    return this.getBooleanAttribute('response_honor_retry_after_header');
  }
  public set responseHonorRetryAfterHeader(value: boolean | cdktf.IResolvable) {
    this._responseHonorRetryAfterHeader = value;
  }
  public resetResponseHonorRetryAfterHeader() {
    this._responseHonorRetryAfterHeader = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get responseHonorRetryAfterHeaderInput() {
    return this._responseHonorRetryAfterHeader;
  }

  // response_retry_settings - computed: false, optional: true, required: false
  private _responseRetrySettings = new PackDestinationOutputElasticResponseRetrySettingsList(this, "response_retry_settings", false);
  public get responseRetrySettings() {
    return this._responseRetrySettings;
  }
  public putResponseRetrySettings(value: PackDestinationOutputElasticResponseRetrySettings[] | cdktf.IResolvable) {
    this._responseRetrySettings.internalValue = value;
  }
  public resetResponseRetrySettings() {
    this._responseRetrySettings.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get responseRetrySettingsInput() {
    return this._responseRetrySettings.internalValue;
  }

  // retry_partial_errors - computed: true, optional: true, required: false
  private _retryPartialErrors?: boolean | cdktf.IResolvable; 
  public get retryPartialErrors() {
    return this.getBooleanAttribute('retry_partial_errors');
  }
  public set retryPartialErrors(value: boolean | cdktf.IResolvable) {
    this._retryPartialErrors = value;
  }
  public resetRetryPartialErrors() {
    this._retryPartialErrors = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get retryPartialErrorsInput() {
    return this._retryPartialErrors;
  }

  // safe_headers - computed: true, optional: true, required: false
  private _safeHeaders?: string[]; 
  public get safeHeaders() {
    return this.getListAttribute('safe_headers');
  }
  public set safeHeaders(value: string[]) {
    this._safeHeaders = value;
  }
  public resetSafeHeaders() {
    this._safeHeaders = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get safeHeadersInput() {
    return this._safeHeaders;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // system_fields - computed: true, optional: true, required: false
  private _systemFields?: string[]; 
  public get systemFields() {
    return this.getListAttribute('system_fields');
  }
  public set systemFields(value: string[]) {
    this._systemFields = value;
  }
  public resetSystemFields() {
    this._systemFields = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get systemFieldsInput() {
    return this._systemFields;
  }

  // timeout_retry_settings - computed: false, optional: true, required: false
  private _timeoutRetrySettings = new PackDestinationOutputElasticTimeoutRetrySettingsOutputReference(this, "timeout_retry_settings");
  public get timeoutRetrySettings() {
    return this._timeoutRetrySettings;
  }
  public putTimeoutRetrySettings(value: PackDestinationOutputElasticTimeoutRetrySettings) {
    this._timeoutRetrySettings.internalValue = value;
  }
  public resetTimeoutRetrySettings() {
    this._timeoutRetrySettings.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutRetrySettingsInput() {
    return this._timeoutRetrySettings.internalValue;
  }

  // timeout_sec - computed: true, optional: true, required: false
  private _timeoutSec?: number; 
  public get timeoutSec() {
    return this.getNumberAttribute('timeout_sec');
  }
  public set timeoutSec(value: number) {
    this._timeoutSec = value;
  }
  public resetTimeoutSec() {
    this._timeoutSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutSecInput() {
    return this._timeoutSec;
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // url - computed: false, optional: true, required: false
  private _url?: string; 
  public get url() {
    return this.getStringAttribute('url');
  }
  public set url(value: string) {
    this._url = value;
  }
  public resetUrl() {
    this._url = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get urlInput() {
    return this._url;
  }

  // urls - computed: false, optional: true, required: false
  private _urls = new PackDestinationOutputElasticUrlsList(this, "urls", false);
  public get urls() {
    return this._urls;
  }
  public putUrls(value: PackDestinationOutputElasticUrls[] | cdktf.IResolvable) {
    this._urls.internalValue = value;
  }
  public resetUrls() {
    this._urls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get urlsInput() {
    return this._urls.internalValue;
  }

  // use_round_robin_dns - computed: true, optional: true, required: false
  private _useRoundRobinDns?: boolean | cdktf.IResolvable; 
  public get useRoundRobinDns() {
    return this.getBooleanAttribute('use_round_robin_dns');
  }
  public set useRoundRobinDns(value: boolean | cdktf.IResolvable) {
    this._useRoundRobinDns = value;
  }
  public resetUseRoundRobinDns() {
    this._useRoundRobinDns = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get useRoundRobinDnsInput() {
    return this._useRoundRobinDns;
  }

  // write_action - computed: true, optional: true, required: false
  private _writeAction?: string; 
  public get writeAction() {
    return this.getStringAttribute('write_action');
  }
  public set writeAction(value: string) {
    this._writeAction = value;
  }
  public resetWriteAction() {
    this._writeAction = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get writeActionInput() {
    return this._writeAction;
  }
}
export interface PackDestinationOutputElasticCloudAuth {
  /**
  * Enter credentials directly, or select a stored secret. Default: "manual"; must be one of ["manual", "secret", "manualAPIKey", "textSecret"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#auth_type PackDestination#auth_type}
  */
  readonly authType?: string;
  /**
  * Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#disabled PackDestination#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
}

export function packDestinationOutputElasticCloudAuthToTerraform(struct?: PackDestinationOutputElasticCloudAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    auth_type: cdktf.stringToTerraform(struct!.authType),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
  }
}


export function packDestinationOutputElasticCloudAuthToHclTerraform(struct?: PackDestinationOutputElasticCloudAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    auth_type: {
      value: cdktf.stringToHclTerraform(struct!.authType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputElasticCloudAuthOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackDestinationOutputElasticCloudAuth | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._authType !== undefined) {
      hasAnyValues = true;
      internalValueResult.authType = this._authType;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputElasticCloudAuth | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._authType = undefined;
      this._disabled = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._authType = value.authType;
      this._disabled = value.disabled;
    }
  }

  // auth_type - computed: true, optional: true, required: false
  private _authType?: string; 
  public get authType() {
    return this.getStringAttribute('auth_type');
  }
  public set authType(value: string) {
    this._authType = value;
  }
  public resetAuthType() {
    this._authType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authTypeInput() {
    return this._authType;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }
}
export interface PackDestinationOutputElasticCloudExtraHttpHeaders {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#name PackDestination#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#value PackDestination#value}
  */
  readonly value: string;
}

export function packDestinationOutputElasticCloudExtraHttpHeadersToTerraform(struct?: PackDestinationOutputElasticCloudExtraHttpHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function packDestinationOutputElasticCloudExtraHttpHeadersToHclTerraform(struct?: PackDestinationOutputElasticCloudExtraHttpHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputElasticCloudExtraHttpHeadersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackDestinationOutputElasticCloudExtraHttpHeaders | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputElasticCloudExtraHttpHeaders | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class PackDestinationOutputElasticCloudExtraHttpHeadersList extends cdktf.ComplexList {
  public internalValue? : PackDestinationOutputElasticCloudExtraHttpHeaders[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackDestinationOutputElasticCloudExtraHttpHeadersOutputReference {
    return new PackDestinationOutputElasticCloudExtraHttpHeadersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackDestinationOutputElasticCloudExtraParams {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#name PackDestination#name}
  */
  readonly name: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#value PackDestination#value}
  */
  readonly value: string;
}

export function packDestinationOutputElasticCloudExtraParamsToTerraform(struct?: PackDestinationOutputElasticCloudExtraParams | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function packDestinationOutputElasticCloudExtraParamsToHclTerraform(struct?: PackDestinationOutputElasticCloudExtraParams | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputElasticCloudExtraParamsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackDestinationOutputElasticCloudExtraParams | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputElasticCloudExtraParams | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class PackDestinationOutputElasticCloudExtraParamsList extends cdktf.ComplexList {
  public internalValue? : PackDestinationOutputElasticCloudExtraParams[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackDestinationOutputElasticCloudExtraParamsOutputReference {
    return new PackDestinationOutputElasticCloudExtraParamsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackDestinationOutputElasticCloudPqControls {
}

export function packDestinationOutputElasticCloudPqControlsToTerraform(struct?: PackDestinationOutputElasticCloudPqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function packDestinationOutputElasticCloudPqControlsToHclTerraform(struct?: PackDestinationOutputElasticCloudPqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class PackDestinationOutputElasticCloudPqControlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackDestinationOutputElasticCloudPqControls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputElasticCloudPqControls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface PackDestinationOutputElasticCloudResponseRetrySettings {
  /**
  * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc. Default: 2
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#backoff_rate PackDestination#backoff_rate}
  */
  readonly backoffRate?: number;
  /**
  * The HTTP response status code that will trigger retries
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#http_status PackDestination#http_status}
  */
  readonly httpStatus: number;
  /**
  * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes). Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#initial_backoff PackDestination#initial_backoff}
  */
  readonly initialBackoff?: number;
  /**
  * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds). Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_backoff PackDestination#max_backoff}
  */
  readonly maxBackoff?: number;
}

export function packDestinationOutputElasticCloudResponseRetrySettingsToTerraform(struct?: PackDestinationOutputElasticCloudResponseRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    backoff_rate: cdktf.numberToTerraform(struct!.backoffRate),
    http_status: cdktf.numberToTerraform(struct!.httpStatus),
    initial_backoff: cdktf.numberToTerraform(struct!.initialBackoff),
    max_backoff: cdktf.numberToTerraform(struct!.maxBackoff),
  }
}


export function packDestinationOutputElasticCloudResponseRetrySettingsToHclTerraform(struct?: PackDestinationOutputElasticCloudResponseRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    backoff_rate: {
      value: cdktf.numberToHclTerraform(struct!.backoffRate),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    http_status: {
      value: cdktf.numberToHclTerraform(struct!.httpStatus),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    initial_backoff: {
      value: cdktf.numberToHclTerraform(struct!.initialBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_backoff: {
      value: cdktf.numberToHclTerraform(struct!.maxBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputElasticCloudResponseRetrySettingsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackDestinationOutputElasticCloudResponseRetrySettings | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._backoffRate !== undefined) {
      hasAnyValues = true;
      internalValueResult.backoffRate = this._backoffRate;
    }
    if (this._httpStatus !== undefined) {
      hasAnyValues = true;
      internalValueResult.httpStatus = this._httpStatus;
    }
    if (this._initialBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.initialBackoff = this._initialBackoff;
    }
    if (this._maxBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBackoff = this._maxBackoff;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputElasticCloudResponseRetrySettings | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._backoffRate = undefined;
      this._httpStatus = undefined;
      this._initialBackoff = undefined;
      this._maxBackoff = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._backoffRate = value.backoffRate;
      this._httpStatus = value.httpStatus;
      this._initialBackoff = value.initialBackoff;
      this._maxBackoff = value.maxBackoff;
    }
  }

  // backoff_rate - computed: true, optional: true, required: false
  private _backoffRate?: number; 
  public get backoffRate() {
    return this.getNumberAttribute('backoff_rate');
  }
  public set backoffRate(value: number) {
    this._backoffRate = value;
  }
  public resetBackoffRate() {
    this._backoffRate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get backoffRateInput() {
    return this._backoffRate;
  }

  // http_status - computed: false, optional: false, required: true
  private _httpStatus?: number; 
  public get httpStatus() {
    return this.getNumberAttribute('http_status');
  }
  public set httpStatus(value: number) {
    this._httpStatus = value;
  }
  // Temporarily expose input value. Use with caution.
  public get httpStatusInput() {
    return this._httpStatus;
  }

  // initial_backoff - computed: true, optional: true, required: false
  private _initialBackoff?: number; 
  public get initialBackoff() {
    return this.getNumberAttribute('initial_backoff');
  }
  public set initialBackoff(value: number) {
    this._initialBackoff = value;
  }
  public resetInitialBackoff() {
    this._initialBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get initialBackoffInput() {
    return this._initialBackoff;
  }

  // max_backoff - computed: true, optional: true, required: false
  private _maxBackoff?: number; 
  public get maxBackoff() {
    return this.getNumberAttribute('max_backoff');
  }
  public set maxBackoff(value: number) {
    this._maxBackoff = value;
  }
  public resetMaxBackoff() {
    this._maxBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBackoffInput() {
    return this._maxBackoff;
  }
}

export class PackDestinationOutputElasticCloudResponseRetrySettingsList extends cdktf.ComplexList {
  public internalValue? : PackDestinationOutputElasticCloudResponseRetrySettings[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackDestinationOutputElasticCloudResponseRetrySettingsOutputReference {
    return new PackDestinationOutputElasticCloudResponseRetrySettingsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackDestinationOutputElasticCloudTimeoutRetrySettings {
  /**
  * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc. Default: 2
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#backoff_rate PackDestination#backoff_rate}
  */
  readonly backoffRate?: number;
  /**
  * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes). Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#initial_backoff PackDestination#initial_backoff}
  */
  readonly initialBackoff?: number;
  /**
  * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds). Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_backoff PackDestination#max_backoff}
  */
  readonly maxBackoff?: number;
  /**
  * Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#timeout_retry PackDestination#timeout_retry}
  */
  readonly timeoutRetry?: boolean | cdktf.IResolvable;
}

export function packDestinationOutputElasticCloudTimeoutRetrySettingsToTerraform(struct?: PackDestinationOutputElasticCloudTimeoutRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    backoff_rate: cdktf.numberToTerraform(struct!.backoffRate),
    initial_backoff: cdktf.numberToTerraform(struct!.initialBackoff),
    max_backoff: cdktf.numberToTerraform(struct!.maxBackoff),
    timeout_retry: cdktf.booleanToTerraform(struct!.timeoutRetry),
  }
}


export function packDestinationOutputElasticCloudTimeoutRetrySettingsToHclTerraform(struct?: PackDestinationOutputElasticCloudTimeoutRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    backoff_rate: {
      value: cdktf.numberToHclTerraform(struct!.backoffRate),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    initial_backoff: {
      value: cdktf.numberToHclTerraform(struct!.initialBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_backoff: {
      value: cdktf.numberToHclTerraform(struct!.maxBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    timeout_retry: {
      value: cdktf.booleanToHclTerraform(struct!.timeoutRetry),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputElasticCloudTimeoutRetrySettingsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackDestinationOutputElasticCloudTimeoutRetrySettings | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._backoffRate !== undefined) {
      hasAnyValues = true;
      internalValueResult.backoffRate = this._backoffRate;
    }
    if (this._initialBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.initialBackoff = this._initialBackoff;
    }
    if (this._maxBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBackoff = this._maxBackoff;
    }
    if (this._timeoutRetry !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutRetry = this._timeoutRetry;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputElasticCloudTimeoutRetrySettings | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._backoffRate = undefined;
      this._initialBackoff = undefined;
      this._maxBackoff = undefined;
      this._timeoutRetry = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._backoffRate = value.backoffRate;
      this._initialBackoff = value.initialBackoff;
      this._maxBackoff = value.maxBackoff;
      this._timeoutRetry = value.timeoutRetry;
    }
  }

  // backoff_rate - computed: true, optional: true, required: false
  private _backoffRate?: number; 
  public get backoffRate() {
    return this.getNumberAttribute('backoff_rate');
  }
  public set backoffRate(value: number) {
    this._backoffRate = value;
  }
  public resetBackoffRate() {
    this._backoffRate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get backoffRateInput() {
    return this._backoffRate;
  }

  // initial_backoff - computed: true, optional: true, required: false
  private _initialBackoff?: number; 
  public get initialBackoff() {
    return this.getNumberAttribute('initial_backoff');
  }
  public set initialBackoff(value: number) {
    this._initialBackoff = value;
  }
  public resetInitialBackoff() {
    this._initialBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get initialBackoffInput() {
    return this._initialBackoff;
  }

  // max_backoff - computed: true, optional: true, required: false
  private _maxBackoff?: number; 
  public get maxBackoff() {
    return this.getNumberAttribute('max_backoff');
  }
  public set maxBackoff(value: number) {
    this._maxBackoff = value;
  }
  public resetMaxBackoff() {
    this._maxBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBackoffInput() {
    return this._maxBackoff;
  }

  // timeout_retry - computed: true, optional: true, required: false
  private _timeoutRetry?: boolean | cdktf.IResolvable; 
  public get timeoutRetry() {
    return this.getBooleanAttribute('timeout_retry');
  }
  public set timeoutRetry(value: boolean | cdktf.IResolvable) {
    this._timeoutRetry = value;
  }
  public resetTimeoutRetry() {
    this._timeoutRetry = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutRetryInput() {
    return this._timeoutRetry;
  }
}
export interface PackDestinationOutputElasticCloud {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#auth PackDestination#auth}
  */
  readonly auth?: PackDestinationOutputElasticCloudAuth;
  /**
  * Compress the payload body before sending. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#compress PackDestination#compress}
  */
  readonly compress?: boolean | cdktf.IResolvable;
  /**
  * Maximum number of ongoing requests before blocking. Default: 5
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#concurrency PackDestination#concurrency}
  */
  readonly concurrency?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#description PackDestination#description}
  */
  readonly description?: string;
  /**
  * Optional Elastic Cloud Destination pipeline
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#elastic_pipeline PackDestination#elastic_pipeline}
  */
  readonly elasticPipeline?: string;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#environment PackDestination#environment}
  */
  readonly environment?: string;
  /**
  * Headers to add to all events
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#extra_http_headers PackDestination#extra_http_headers}
  */
  readonly extraHttpHeaders?: PackDestinationOutputElasticCloudExtraHttpHeaders[] | cdktf.IResolvable;
  /**
  * Extra parameters to use in HTTP requests
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#extra_params PackDestination#extra_params}
  */
  readonly extraParams?: PackDestinationOutputElasticCloudExtraParams[] | cdktf.IResolvable;
  /**
  * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below. Default: "none"; must be one of ["payload", "payloadAndHeaders", "none"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#failed_request_logging_mode PackDestination#failed_request_logging_mode}
  */
  readonly failedRequestLoggingMode?: string;
  /**
  * Maximum time between requests. Small values could cause the payload size to be smaller than the configured Body size limit. Default: 1
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#flush_period_sec PackDestination#flush_period_sec}
  */
  readonly flushPeriodSec?: number;
  /**
  * Unique ID for this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#id PackDestination#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * Include the `document_id` field when sending events to an Elastic TSDS (time series data stream). Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#include_doc_id PackDestination#include_doc_id}
  */
  readonly includeDocId?: boolean | cdktf.IResolvable;
  /**
  * Data stream or index to send events to. Must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can be overwritten by an event's __index field.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#index PackDestination#index}
  */
  readonly index: string;
  /**
  * Maximum number of events to include in the request body. Default is 0 (unlimited). Default: 0
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_payload_events PackDestination#max_payload_events}
  */
  readonly maxPayloadEvents?: number;
  /**
  * Maximum size, in KB, of the request body. Default: 4096
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_payload_size_kb PackDestination#max_payload_size_kb}
  */
  readonly maxPayloadSizeKb?: number;
  /**
  * How to handle events when all receivers are exerting backpressure. Default: "block"; must be one of ["block", "drop", "queue"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#on_backpressure PackDestination#on_backpressure}
  */
  readonly onBackpressure?: string;
  /**
  * Pipeline to process data before sending out to this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pipeline PackDestination#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_compress PackDestination#pq_compress}
  */
  readonly pqCompress?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_controls PackDestination#pq_controls}
  */
  readonly pqControls?: PackDestinationOutputElasticCloudPqControls;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.). Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_max_file_size PackDestination#pq_max_file_size}
  */
  readonly pqMaxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_max_size PackDestination#pq_max_size}
  */
  readonly pqMaxSize?: string;
  /**
  * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem. Default: "error"; must be one of ["error", "backpressure", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_mode PackDestination#pq_mode}
  */
  readonly pqMode?: string;
  /**
  * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged. Default: "block"; must be one of ["block", "drop"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_on_backpressure PackDestination#pq_on_backpressure}
  */
  readonly pqOnBackpressure?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_path PackDestination#pq_path}
  */
  readonly pqPath?: string;
  /**
  * Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's). 
  *         Enabled by default. When this setting is also present in TLS Settings (Client Side), 
  *         that value will take precedence.
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#reject_unauthorized PackDestination#reject_unauthorized}
  */
  readonly rejectUnauthorized?: boolean | cdktf.IResolvable;
  /**
  * Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#response_honor_retry_after_header PackDestination#response_honor_retry_after_header}
  */
  readonly responseHonorRetryAfterHeader?: boolean | cdktf.IResolvable;
  /**
  * Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#response_retry_settings PackDestination#response_retry_settings}
  */
  readonly responseRetrySettings?: PackDestinationOutputElasticCloudResponseRetrySettings[] | cdktf.IResolvable;
  /**
  * List of headers that are safe to log in plain text. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#safe_headers PackDestination#safe_headers}
  */
  readonly safeHeaders?: string[];
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#streamtags PackDestination#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Fields to automatically add to events, such as cribl_pipe. Supports wildcards. Default: ["cribl_pipe"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#system_fields PackDestination#system_fields}
  */
  readonly systemFields?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#timeout_retry_settings PackDestination#timeout_retry_settings}
  */
  readonly timeoutRetrySettings?: PackDestinationOutputElasticCloudTimeoutRetrySettings;
  /**
  * Amount of time, in seconds, to wait for a request to complete before canceling it. Default: 30
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#timeout_sec PackDestination#timeout_sec}
  */
  readonly timeoutSec?: number;
  /**
  * must be "elastic_cloud"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#type PackDestination#type}
  */
  readonly type?: string;
  /**
  * Enter Cloud ID of the Elastic Cloud environment to send events to
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#url PackDestination#url}
  */
  readonly url: string;
}

export function packDestinationOutputElasticCloudToTerraform(struct?: PackDestinationOutputElasticCloud | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    auth: packDestinationOutputElasticCloudAuthToTerraform(struct!.auth),
    compress: cdktf.booleanToTerraform(struct!.compress),
    concurrency: cdktf.numberToTerraform(struct!.concurrency),
    description: cdktf.stringToTerraform(struct!.description),
    elastic_pipeline: cdktf.stringToTerraform(struct!.elasticPipeline),
    environment: cdktf.stringToTerraform(struct!.environment),
    extra_http_headers: cdktf.listMapper(packDestinationOutputElasticCloudExtraHttpHeadersToTerraform, false)(struct!.extraHttpHeaders),
    extra_params: cdktf.listMapper(packDestinationOutputElasticCloudExtraParamsToTerraform, false)(struct!.extraParams),
    failed_request_logging_mode: cdktf.stringToTerraform(struct!.failedRequestLoggingMode),
    flush_period_sec: cdktf.numberToTerraform(struct!.flushPeriodSec),
    id: cdktf.stringToTerraform(struct!.id),
    include_doc_id: cdktf.booleanToTerraform(struct!.includeDocId),
    index: cdktf.stringToTerraform(struct!.index),
    max_payload_events: cdktf.numberToTerraform(struct!.maxPayloadEvents),
    max_payload_size_kb: cdktf.numberToTerraform(struct!.maxPayloadSizeKb),
    on_backpressure: cdktf.stringToTerraform(struct!.onBackpressure),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    pq_compress: cdktf.stringToTerraform(struct!.pqCompress),
    pq_controls: packDestinationOutputElasticCloudPqControlsToTerraform(struct!.pqControls),
    pq_max_file_size: cdktf.stringToTerraform(struct!.pqMaxFileSize),
    pq_max_size: cdktf.stringToTerraform(struct!.pqMaxSize),
    pq_mode: cdktf.stringToTerraform(struct!.pqMode),
    pq_on_backpressure: cdktf.stringToTerraform(struct!.pqOnBackpressure),
    pq_path: cdktf.stringToTerraform(struct!.pqPath),
    reject_unauthorized: cdktf.booleanToTerraform(struct!.rejectUnauthorized),
    response_honor_retry_after_header: cdktf.booleanToTerraform(struct!.responseHonorRetryAfterHeader),
    response_retry_settings: cdktf.listMapper(packDestinationOutputElasticCloudResponseRetrySettingsToTerraform, false)(struct!.responseRetrySettings),
    safe_headers: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.safeHeaders),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    system_fields: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.systemFields),
    timeout_retry_settings: packDestinationOutputElasticCloudTimeoutRetrySettingsToTerraform(struct!.timeoutRetrySettings),
    timeout_sec: cdktf.numberToTerraform(struct!.timeoutSec),
    type: cdktf.stringToTerraform(struct!.type),
    url: cdktf.stringToTerraform(struct!.url),
  }
}


export function packDestinationOutputElasticCloudToHclTerraform(struct?: PackDestinationOutputElasticCloud | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    auth: {
      value: packDestinationOutputElasticCloudAuthToHclTerraform(struct!.auth),
      isBlock: true,
      type: "struct",
      storageClassType: "PackDestinationOutputElasticCloudAuth",
    },
    compress: {
      value: cdktf.booleanToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    concurrency: {
      value: cdktf.numberToHclTerraform(struct!.concurrency),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    elastic_pipeline: {
      value: cdktf.stringToHclTerraform(struct!.elasticPipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    extra_http_headers: {
      value: cdktf.listMapperHcl(packDestinationOutputElasticCloudExtraHttpHeadersToHclTerraform, false)(struct!.extraHttpHeaders),
      isBlock: true,
      type: "list",
      storageClassType: "PackDestinationOutputElasticCloudExtraHttpHeadersList",
    },
    extra_params: {
      value: cdktf.listMapperHcl(packDestinationOutputElasticCloudExtraParamsToHclTerraform, false)(struct!.extraParams),
      isBlock: true,
      type: "list",
      storageClassType: "PackDestinationOutputElasticCloudExtraParamsList",
    },
    failed_request_logging_mode: {
      value: cdktf.stringToHclTerraform(struct!.failedRequestLoggingMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    flush_period_sec: {
      value: cdktf.numberToHclTerraform(struct!.flushPeriodSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    include_doc_id: {
      value: cdktf.booleanToHclTerraform(struct!.includeDocId),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    index: {
      value: cdktf.stringToHclTerraform(struct!.index),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_payload_events: {
      value: cdktf.numberToHclTerraform(struct!.maxPayloadEvents),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_payload_size_kb: {
      value: cdktf.numberToHclTerraform(struct!.maxPayloadSizeKb),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.onBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_compress: {
      value: cdktf.stringToHclTerraform(struct!.pqCompress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_controls: {
      value: packDestinationOutputElasticCloudPqControlsToHclTerraform(struct!.pqControls),
      isBlock: true,
      type: "struct",
      storageClassType: "PackDestinationOutputElasticCloudPqControls",
    },
    pq_max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_max_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_mode: {
      value: cdktf.stringToHclTerraform(struct!.pqMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.pqOnBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_path: {
      value: cdktf.stringToHclTerraform(struct!.pqPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reject_unauthorized: {
      value: cdktf.booleanToHclTerraform(struct!.rejectUnauthorized),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    response_honor_retry_after_header: {
      value: cdktf.booleanToHclTerraform(struct!.responseHonorRetryAfterHeader),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    response_retry_settings: {
      value: cdktf.listMapperHcl(packDestinationOutputElasticCloudResponseRetrySettingsToHclTerraform, false)(struct!.responseRetrySettings),
      isBlock: true,
      type: "list",
      storageClassType: "PackDestinationOutputElasticCloudResponseRetrySettingsList",
    },
    safe_headers: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.safeHeaders),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    system_fields: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.systemFields),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    timeout_retry_settings: {
      value: packDestinationOutputElasticCloudTimeoutRetrySettingsToHclTerraform(struct!.timeoutRetrySettings),
      isBlock: true,
      type: "struct",
      storageClassType: "PackDestinationOutputElasticCloudTimeoutRetrySettings",
    },
    timeout_sec: {
      value: cdktf.numberToHclTerraform(struct!.timeoutSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    url: {
      value: cdktf.stringToHclTerraform(struct!.url),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputElasticCloudOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackDestinationOutputElasticCloud | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._auth?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.auth = this._auth?.internalValue;
    }
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._concurrency !== undefined) {
      hasAnyValues = true;
      internalValueResult.concurrency = this._concurrency;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._elasticPipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.elasticPipeline = this._elasticPipeline;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._extraHttpHeaders?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.extraHttpHeaders = this._extraHttpHeaders?.internalValue;
    }
    if (this._extraParams?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.extraParams = this._extraParams?.internalValue;
    }
    if (this._failedRequestLoggingMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.failedRequestLoggingMode = this._failedRequestLoggingMode;
    }
    if (this._flushPeriodSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.flushPeriodSec = this._flushPeriodSec;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._includeDocId !== undefined) {
      hasAnyValues = true;
      internalValueResult.includeDocId = this._includeDocId;
    }
    if (this._index !== undefined) {
      hasAnyValues = true;
      internalValueResult.index = this._index;
    }
    if (this._maxPayloadEvents !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxPayloadEvents = this._maxPayloadEvents;
    }
    if (this._maxPayloadSizeKb !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxPayloadSizeKb = this._maxPayloadSizeKb;
    }
    if (this._onBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.onBackpressure = this._onBackpressure;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._pqCompress !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqCompress = this._pqCompress;
    }
    if (this._pqControls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqControls = this._pqControls?.internalValue;
    }
    if (this._pqMaxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxFileSize = this._pqMaxFileSize;
    }
    if (this._pqMaxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxSize = this._pqMaxSize;
    }
    if (this._pqMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMode = this._pqMode;
    }
    if (this._pqOnBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqOnBackpressure = this._pqOnBackpressure;
    }
    if (this._pqPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqPath = this._pqPath;
    }
    if (this._rejectUnauthorized !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectUnauthorized = this._rejectUnauthorized;
    }
    if (this._responseHonorRetryAfterHeader !== undefined) {
      hasAnyValues = true;
      internalValueResult.responseHonorRetryAfterHeader = this._responseHonorRetryAfterHeader;
    }
    if (this._responseRetrySettings?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.responseRetrySettings = this._responseRetrySettings?.internalValue;
    }
    if (this._safeHeaders !== undefined) {
      hasAnyValues = true;
      internalValueResult.safeHeaders = this._safeHeaders;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._systemFields !== undefined) {
      hasAnyValues = true;
      internalValueResult.systemFields = this._systemFields;
    }
    if (this._timeoutRetrySettings?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutRetrySettings = this._timeoutRetrySettings?.internalValue;
    }
    if (this._timeoutSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutSec = this._timeoutSec;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._url !== undefined) {
      hasAnyValues = true;
      internalValueResult.url = this._url;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputElasticCloud | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._auth.internalValue = undefined;
      this._compress = undefined;
      this._concurrency = undefined;
      this._description = undefined;
      this._elasticPipeline = undefined;
      this._environment = undefined;
      this._extraHttpHeaders.internalValue = undefined;
      this._extraParams.internalValue = undefined;
      this._failedRequestLoggingMode = undefined;
      this._flushPeriodSec = undefined;
      this._id = undefined;
      this._includeDocId = undefined;
      this._index = undefined;
      this._maxPayloadEvents = undefined;
      this._maxPayloadSizeKb = undefined;
      this._onBackpressure = undefined;
      this._pipeline = undefined;
      this._pqCompress = undefined;
      this._pqControls.internalValue = undefined;
      this._pqMaxFileSize = undefined;
      this._pqMaxSize = undefined;
      this._pqMode = undefined;
      this._pqOnBackpressure = undefined;
      this._pqPath = undefined;
      this._rejectUnauthorized = undefined;
      this._responseHonorRetryAfterHeader = undefined;
      this._responseRetrySettings.internalValue = undefined;
      this._safeHeaders = undefined;
      this._streamtags = undefined;
      this._systemFields = undefined;
      this._timeoutRetrySettings.internalValue = undefined;
      this._timeoutSec = undefined;
      this._type = undefined;
      this._url = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._auth.internalValue = value.auth;
      this._compress = value.compress;
      this._concurrency = value.concurrency;
      this._description = value.description;
      this._elasticPipeline = value.elasticPipeline;
      this._environment = value.environment;
      this._extraHttpHeaders.internalValue = value.extraHttpHeaders;
      this._extraParams.internalValue = value.extraParams;
      this._failedRequestLoggingMode = value.failedRequestLoggingMode;
      this._flushPeriodSec = value.flushPeriodSec;
      this._id = value.id;
      this._includeDocId = value.includeDocId;
      this._index = value.index;
      this._maxPayloadEvents = value.maxPayloadEvents;
      this._maxPayloadSizeKb = value.maxPayloadSizeKb;
      this._onBackpressure = value.onBackpressure;
      this._pipeline = value.pipeline;
      this._pqCompress = value.pqCompress;
      this._pqControls.internalValue = value.pqControls;
      this._pqMaxFileSize = value.pqMaxFileSize;
      this._pqMaxSize = value.pqMaxSize;
      this._pqMode = value.pqMode;
      this._pqOnBackpressure = value.pqOnBackpressure;
      this._pqPath = value.pqPath;
      this._rejectUnauthorized = value.rejectUnauthorized;
      this._responseHonorRetryAfterHeader = value.responseHonorRetryAfterHeader;
      this._responseRetrySettings.internalValue = value.responseRetrySettings;
      this._safeHeaders = value.safeHeaders;
      this._streamtags = value.streamtags;
      this._systemFields = value.systemFields;
      this._timeoutRetrySettings.internalValue = value.timeoutRetrySettings;
      this._timeoutSec = value.timeoutSec;
      this._type = value.type;
      this._url = value.url;
    }
  }

  // auth - computed: false, optional: true, required: false
  private _auth = new PackDestinationOutputElasticCloudAuthOutputReference(this, "auth");
  public get auth() {
    return this._auth;
  }
  public putAuth(value: PackDestinationOutputElasticCloudAuth) {
    this._auth.internalValue = value;
  }
  public resetAuth() {
    this._auth.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authInput() {
    return this._auth.internalValue;
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: boolean | cdktf.IResolvable; 
  public get compress() {
    return this.getBooleanAttribute('compress');
  }
  public set compress(value: boolean | cdktf.IResolvable) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // concurrency - computed: true, optional: true, required: false
  private _concurrency?: number; 
  public get concurrency() {
    return this.getNumberAttribute('concurrency');
  }
  public set concurrency(value: number) {
    this._concurrency = value;
  }
  public resetConcurrency() {
    this._concurrency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get concurrencyInput() {
    return this._concurrency;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // elastic_pipeline - computed: false, optional: true, required: false
  private _elasticPipeline?: string; 
  public get elasticPipeline() {
    return this.getStringAttribute('elastic_pipeline');
  }
  public set elasticPipeline(value: string) {
    this._elasticPipeline = value;
  }
  public resetElasticPipeline() {
    this._elasticPipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get elasticPipelineInput() {
    return this._elasticPipeline;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // extra_http_headers - computed: false, optional: true, required: false
  private _extraHttpHeaders = new PackDestinationOutputElasticCloudExtraHttpHeadersList(this, "extra_http_headers", false);
  public get extraHttpHeaders() {
    return this._extraHttpHeaders;
  }
  public putExtraHttpHeaders(value: PackDestinationOutputElasticCloudExtraHttpHeaders[] | cdktf.IResolvable) {
    this._extraHttpHeaders.internalValue = value;
  }
  public resetExtraHttpHeaders() {
    this._extraHttpHeaders.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get extraHttpHeadersInput() {
    return this._extraHttpHeaders.internalValue;
  }

  // extra_params - computed: false, optional: true, required: false
  private _extraParams = new PackDestinationOutputElasticCloudExtraParamsList(this, "extra_params", false);
  public get extraParams() {
    return this._extraParams;
  }
  public putExtraParams(value: PackDestinationOutputElasticCloudExtraParams[] | cdktf.IResolvable) {
    this._extraParams.internalValue = value;
  }
  public resetExtraParams() {
    this._extraParams.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get extraParamsInput() {
    return this._extraParams.internalValue;
  }

  // failed_request_logging_mode - computed: true, optional: true, required: false
  private _failedRequestLoggingMode?: string; 
  public get failedRequestLoggingMode() {
    return this.getStringAttribute('failed_request_logging_mode');
  }
  public set failedRequestLoggingMode(value: string) {
    this._failedRequestLoggingMode = value;
  }
  public resetFailedRequestLoggingMode() {
    this._failedRequestLoggingMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get failedRequestLoggingModeInput() {
    return this._failedRequestLoggingMode;
  }

  // flush_period_sec - computed: true, optional: true, required: false
  private _flushPeriodSec?: number; 
  public get flushPeriodSec() {
    return this.getNumberAttribute('flush_period_sec');
  }
  public set flushPeriodSec(value: number) {
    this._flushPeriodSec = value;
  }
  public resetFlushPeriodSec() {
    this._flushPeriodSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get flushPeriodSecInput() {
    return this._flushPeriodSec;
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // include_doc_id - computed: true, optional: true, required: false
  private _includeDocId?: boolean | cdktf.IResolvable; 
  public get includeDocId() {
    return this.getBooleanAttribute('include_doc_id');
  }
  public set includeDocId(value: boolean | cdktf.IResolvable) {
    this._includeDocId = value;
  }
  public resetIncludeDocId() {
    this._includeDocId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get includeDocIdInput() {
    return this._includeDocId;
  }

  // index - computed: false, optional: false, required: true
  private _index?: string; 
  public get index() {
    return this.getStringAttribute('index');
  }
  public set index(value: string) {
    this._index = value;
  }
  // Temporarily expose input value. Use with caution.
  public get indexInput() {
    return this._index;
  }

  // max_payload_events - computed: true, optional: true, required: false
  private _maxPayloadEvents?: number; 
  public get maxPayloadEvents() {
    return this.getNumberAttribute('max_payload_events');
  }
  public set maxPayloadEvents(value: number) {
    this._maxPayloadEvents = value;
  }
  public resetMaxPayloadEvents() {
    this._maxPayloadEvents = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxPayloadEventsInput() {
    return this._maxPayloadEvents;
  }

  // max_payload_size_kb - computed: true, optional: true, required: false
  private _maxPayloadSizeKb?: number; 
  public get maxPayloadSizeKb() {
    return this.getNumberAttribute('max_payload_size_kb');
  }
  public set maxPayloadSizeKb(value: number) {
    this._maxPayloadSizeKb = value;
  }
  public resetMaxPayloadSizeKb() {
    this._maxPayloadSizeKb = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxPayloadSizeKbInput() {
    return this._maxPayloadSizeKb;
  }

  // on_backpressure - computed: true, optional: true, required: false
  private _onBackpressure?: string; 
  public get onBackpressure() {
    return this.getStringAttribute('on_backpressure');
  }
  public set onBackpressure(value: string) {
    this._onBackpressure = value;
  }
  public resetOnBackpressure() {
    this._onBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get onBackpressureInput() {
    return this._onBackpressure;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // pq_compress - computed: true, optional: true, required: false
  private _pqCompress?: string; 
  public get pqCompress() {
    return this.getStringAttribute('pq_compress');
  }
  public set pqCompress(value: string) {
    this._pqCompress = value;
  }
  public resetPqCompress() {
    this._pqCompress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqCompressInput() {
    return this._pqCompress;
  }

  // pq_controls - computed: false, optional: true, required: false
  private _pqControls = new PackDestinationOutputElasticCloudPqControlsOutputReference(this, "pq_controls");
  public get pqControls() {
    return this._pqControls;
  }
  public putPqControls(value: PackDestinationOutputElasticCloudPqControls) {
    this._pqControls.internalValue = value;
  }
  public resetPqControls() {
    this._pqControls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqControlsInput() {
    return this._pqControls.internalValue;
  }

  // pq_max_file_size - computed: true, optional: true, required: false
  private _pqMaxFileSize?: string; 
  public get pqMaxFileSize() {
    return this.getStringAttribute('pq_max_file_size');
  }
  public set pqMaxFileSize(value: string) {
    this._pqMaxFileSize = value;
  }
  public resetPqMaxFileSize() {
    this._pqMaxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxFileSizeInput() {
    return this._pqMaxFileSize;
  }

  // pq_max_size - computed: true, optional: true, required: false
  private _pqMaxSize?: string; 
  public get pqMaxSize() {
    return this.getStringAttribute('pq_max_size');
  }
  public set pqMaxSize(value: string) {
    this._pqMaxSize = value;
  }
  public resetPqMaxSize() {
    this._pqMaxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxSizeInput() {
    return this._pqMaxSize;
  }

  // pq_mode - computed: true, optional: true, required: false
  private _pqMode?: string; 
  public get pqMode() {
    return this.getStringAttribute('pq_mode');
  }
  public set pqMode(value: string) {
    this._pqMode = value;
  }
  public resetPqMode() {
    this._pqMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqModeInput() {
    return this._pqMode;
  }

  // pq_on_backpressure - computed: true, optional: true, required: false
  private _pqOnBackpressure?: string; 
  public get pqOnBackpressure() {
    return this.getStringAttribute('pq_on_backpressure');
  }
  public set pqOnBackpressure(value: string) {
    this._pqOnBackpressure = value;
  }
  public resetPqOnBackpressure() {
    this._pqOnBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqOnBackpressureInput() {
    return this._pqOnBackpressure;
  }

  // pq_path - computed: true, optional: true, required: false
  private _pqPath?: string; 
  public get pqPath() {
    return this.getStringAttribute('pq_path');
  }
  public set pqPath(value: string) {
    this._pqPath = value;
  }
  public resetPqPath() {
    this._pqPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqPathInput() {
    return this._pqPath;
  }

  // reject_unauthorized - computed: true, optional: true, required: false
  private _rejectUnauthorized?: boolean | cdktf.IResolvable; 
  public get rejectUnauthorized() {
    return this.getBooleanAttribute('reject_unauthorized');
  }
  public set rejectUnauthorized(value: boolean | cdktf.IResolvable) {
    this._rejectUnauthorized = value;
  }
  public resetRejectUnauthorized() {
    this._rejectUnauthorized = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectUnauthorizedInput() {
    return this._rejectUnauthorized;
  }

  // response_honor_retry_after_header - computed: true, optional: true, required: false
  private _responseHonorRetryAfterHeader?: boolean | cdktf.IResolvable; 
  public get responseHonorRetryAfterHeader() {
    return this.getBooleanAttribute('response_honor_retry_after_header');
  }
  public set responseHonorRetryAfterHeader(value: boolean | cdktf.IResolvable) {
    this._responseHonorRetryAfterHeader = value;
  }
  public resetResponseHonorRetryAfterHeader() {
    this._responseHonorRetryAfterHeader = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get responseHonorRetryAfterHeaderInput() {
    return this._responseHonorRetryAfterHeader;
  }

  // response_retry_settings - computed: false, optional: true, required: false
  private _responseRetrySettings = new PackDestinationOutputElasticCloudResponseRetrySettingsList(this, "response_retry_settings", false);
  public get responseRetrySettings() {
    return this._responseRetrySettings;
  }
  public putResponseRetrySettings(value: PackDestinationOutputElasticCloudResponseRetrySettings[] | cdktf.IResolvable) {
    this._responseRetrySettings.internalValue = value;
  }
  public resetResponseRetrySettings() {
    this._responseRetrySettings.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get responseRetrySettingsInput() {
    return this._responseRetrySettings.internalValue;
  }

  // safe_headers - computed: true, optional: true, required: false
  private _safeHeaders?: string[]; 
  public get safeHeaders() {
    return this.getListAttribute('safe_headers');
  }
  public set safeHeaders(value: string[]) {
    this._safeHeaders = value;
  }
  public resetSafeHeaders() {
    this._safeHeaders = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get safeHeadersInput() {
    return this._safeHeaders;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // system_fields - computed: true, optional: true, required: false
  private _systemFields?: string[]; 
  public get systemFields() {
    return this.getListAttribute('system_fields');
  }
  public set systemFields(value: string[]) {
    this._systemFields = value;
  }
  public resetSystemFields() {
    this._systemFields = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get systemFieldsInput() {
    return this._systemFields;
  }

  // timeout_retry_settings - computed: false, optional: true, required: false
  private _timeoutRetrySettings = new PackDestinationOutputElasticCloudTimeoutRetrySettingsOutputReference(this, "timeout_retry_settings");
  public get timeoutRetrySettings() {
    return this._timeoutRetrySettings;
  }
  public putTimeoutRetrySettings(value: PackDestinationOutputElasticCloudTimeoutRetrySettings) {
    this._timeoutRetrySettings.internalValue = value;
  }
  public resetTimeoutRetrySettings() {
    this._timeoutRetrySettings.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutRetrySettingsInput() {
    return this._timeoutRetrySettings.internalValue;
  }

  // timeout_sec - computed: true, optional: true, required: false
  private _timeoutSec?: number; 
  public get timeoutSec() {
    return this.getNumberAttribute('timeout_sec');
  }
  public set timeoutSec(value: number) {
    this._timeoutSec = value;
  }
  public resetTimeoutSec() {
    this._timeoutSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutSecInput() {
    return this._timeoutSec;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // url - computed: false, optional: false, required: true
  private _url?: string; 
  public get url() {
    return this.getStringAttribute('url');
  }
  public set url(value: string) {
    this._url = value;
  }
  // Temporarily expose input value. Use with caution.
  public get urlInput() {
    return this._url;
  }
}
export interface PackDestinationOutputExabeam {
  /**
  * Add the Output ID value to staging location. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#add_id_to_stage_path PackDestination#add_id_to_stage_path}
  */
  readonly addIdToStagePath?: boolean | cdktf.IResolvable;
  /**
  * HMAC access key. Can be a constant or a JavaScript expression, such as `${C.env.GCS_ACCESS_KEY}`.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#aws_api_key PackDestination#aws_api_key}
  */
  readonly awsApiKey?: string;
  /**
  * HMAC secret. Can be a constant or a JavaScript expression, such as `${C.env.GCS_SECRET}`.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#aws_secret_key PackDestination#aws_secret_key}
  */
  readonly awsSecretKey?: string;
  /**
  * Name of the destination bucket. A constant or a JavaScript expression that can only be evaluated at init time. Example of referencing a JavaScript Global Variable: `myBucket-${C.vars.myVar}`.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#bucket PackDestination#bucket}
  */
  readonly bucket: string;
  /**
  * ID of the Exabeam Collector where data should be sent. Example: 11112222-3333-4444-5555-666677778888
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#collector_instance_id PackDestination#collector_instance_id}
  */
  readonly collectorInstanceId: string;
  /**
  * If a file fails to move to its final destination after the maximum number of retries, move it to a designated directory to prevent further errors. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#deadletter_enabled PackDestination#deadletter_enabled}
  */
  readonly deadletterEnabled?: boolean | cdktf.IResolvable;
  /**
  * Storage location for files that fail to reach their final destination after maximum retries are exceeded. Default: "$CRIBL_HOME/state/outputs/dead-letter"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#deadletter_path PackDestination#deadletter_path}
  */
  readonly deadletterPath?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#description PackDestination#description}
  */
  readonly description?: string;
  /**
  * How frequently, in seconds, to clean up empty directories. Default: 300
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#empty_dir_cleanup_sec PackDestination#empty_dir_cleanup_sec}
  */
  readonly emptyDirCleanupSec?: number;
  /**
  * Enter an encoded string containing Exabeam configurations
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#encoded_configuration PackDestination#encoded_configuration}
  */
  readonly encodedConfiguration?: string;
  /**
  * Google Cloud Storage service endpoint. Default: "https://storage.googleapis.com"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#endpoint PackDestination#endpoint}
  */
  readonly endpoint?: string;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#environment PackDestination#environment}
  */
  readonly environment?: string;
  /**
  * Unique ID for this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#id PackDestination#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * Maximum amount of time to keep inactive files open. Files open for longer than this will be closed and moved to final output location. Default: 30
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_file_idle_time_sec PackDestination#max_file_idle_time_sec}
  */
  readonly maxFileIdleTimeSec?: number;
  /**
  * Maximum amount of time to write to a file. Files open for longer than this will be closed and moved to final output location. Default: 300
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_file_open_time_sec PackDestination#max_file_open_time_sec}
  */
  readonly maxFileOpenTimeSec?: number;
  /**
  * Maximum uncompressed output file size. Files of this size will be closed and moved to final output location. Default: 10
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_file_size_mb PackDestination#max_file_size_mb}
  */
  readonly maxFileSizeMb?: number;
  /**
  * Maximum number of files to keep open concurrently. When exceeded, @{product} will close the oldest open files and move them to the final output location. Default: 100
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_open_files PackDestination#max_open_files}
  */
  readonly maxOpenFiles?: number;
  /**
  * The maximum number of times a file will attempt to move to its final destination before being dead-lettered. Default: 20
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_retry_num PackDestination#max_retry_num}
  */
  readonly maxRetryNum?: number;
  /**
  * Object ACL to assign to uploaded objects. Default: "private"; must be one of ["private", "bucket-owner-read", "bucket-owner-full-control", "project-private", "authenticated-read", "public-read"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#object_acl PackDestination#object_acl}
  */
  readonly objectAcl?: string;
  /**
  * How to handle events when all receivers are exerting backpressure. Default: "block"; must be one of ["block", "drop"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#on_backpressure PackDestination#on_backpressure}
  */
  readonly onBackpressure?: string;
  /**
  * How to handle events when disk space is below the global 'Min free disk space' limit. Default: "block"; must be one of ["block", "drop"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#on_disk_full_backpressure PackDestination#on_disk_full_backpressure}
  */
  readonly onDiskFullBackpressure?: string;
  /**
  * Pipeline to process data before sending out to this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pipeline PackDestination#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Region where the bucket is located
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#region PackDestination#region}
  */
  readonly region: string;
  /**
  * Reject certificates that cannot be verified against a valid CA, such as self-signed certificates. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#reject_unauthorized PackDestination#reject_unauthorized}
  */
  readonly rejectUnauthorized?: boolean | cdktf.IResolvable;
  /**
  * Remove empty staging directories after moving files. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#remove_empty_dirs PackDestination#remove_empty_dirs}
  */
  readonly removeEmptyDirs?: boolean | cdktf.IResolvable;
  /**
  * Reuse connections between requests, which can improve performance. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#reuse_connections PackDestination#reuse_connections}
  */
  readonly reuseConnections?: boolean | cdktf.IResolvable;
  /**
  * Signature version to use for signing Google Cloud Storage requests. Default: "v4"; must be one of ["v2", "v4"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#signature_version PackDestination#signature_version}
  */
  readonly signatureVersion?: string;
  /**
  * Exabeam site ID. If left blank, @{product} will use the value of the Exabeam site name.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#site_id PackDestination#site_id}
  */
  readonly siteId?: string;
  /**
  * Constant or JavaScript expression to create an Exabeam site name. Values that aren't successfully evaluated will be treated as string constants.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#site_name PackDestination#site_name}
  */
  readonly siteName?: string;
  /**
  * Filesystem location in which to buffer files, before compressing and moving to final destination. Use performant and stable storage. Default: "$CRIBL_HOME/state/outputs/staging"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#stage_path PackDestination#stage_path}
  */
  readonly stagePath?: string;
  /**
  * Storage class to select for uploaded objects. must be one of ["STANDARD", "NEARLINE", "COLDLINE", "ARCHIVE"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#storage_class PackDestination#storage_class}
  */
  readonly storageClass?: string;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#streamtags PackDestination#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Fields to automatically add to events, such as cribl_pipe. Supports wildcards. Default: ["cribl_pipe"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#system_fields PackDestination#system_fields}
  */
  readonly systemFields?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#timezone_offset PackDestination#timezone_offset}
  */
  readonly timezoneOffset?: string;
  /**
  * must be "exabeam"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#type PackDestination#type}
  */
  readonly type?: string;
}

export function packDestinationOutputExabeamToTerraform(struct?: PackDestinationOutputExabeam | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    add_id_to_stage_path: cdktf.booleanToTerraform(struct!.addIdToStagePath),
    aws_api_key: cdktf.stringToTerraform(struct!.awsApiKey),
    aws_secret_key: cdktf.stringToTerraform(struct!.awsSecretKey),
    bucket: cdktf.stringToTerraform(struct!.bucket),
    collector_instance_id: cdktf.stringToTerraform(struct!.collectorInstanceId),
    deadletter_enabled: cdktf.booleanToTerraform(struct!.deadletterEnabled),
    deadletter_path: cdktf.stringToTerraform(struct!.deadletterPath),
    description: cdktf.stringToTerraform(struct!.description),
    empty_dir_cleanup_sec: cdktf.numberToTerraform(struct!.emptyDirCleanupSec),
    encoded_configuration: cdktf.stringToTerraform(struct!.encodedConfiguration),
    endpoint: cdktf.stringToTerraform(struct!.endpoint),
    environment: cdktf.stringToTerraform(struct!.environment),
    id: cdktf.stringToTerraform(struct!.id),
    max_file_idle_time_sec: cdktf.numberToTerraform(struct!.maxFileIdleTimeSec),
    max_file_open_time_sec: cdktf.numberToTerraform(struct!.maxFileOpenTimeSec),
    max_file_size_mb: cdktf.numberToTerraform(struct!.maxFileSizeMb),
    max_open_files: cdktf.numberToTerraform(struct!.maxOpenFiles),
    max_retry_num: cdktf.numberToTerraform(struct!.maxRetryNum),
    object_acl: cdktf.stringToTerraform(struct!.objectAcl),
    on_backpressure: cdktf.stringToTerraform(struct!.onBackpressure),
    on_disk_full_backpressure: cdktf.stringToTerraform(struct!.onDiskFullBackpressure),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    region: cdktf.stringToTerraform(struct!.region),
    reject_unauthorized: cdktf.booleanToTerraform(struct!.rejectUnauthorized),
    remove_empty_dirs: cdktf.booleanToTerraform(struct!.removeEmptyDirs),
    reuse_connections: cdktf.booleanToTerraform(struct!.reuseConnections),
    signature_version: cdktf.stringToTerraform(struct!.signatureVersion),
    site_id: cdktf.stringToTerraform(struct!.siteId),
    site_name: cdktf.stringToTerraform(struct!.siteName),
    stage_path: cdktf.stringToTerraform(struct!.stagePath),
    storage_class: cdktf.stringToTerraform(struct!.storageClass),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    system_fields: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.systemFields),
    timezone_offset: cdktf.stringToTerraform(struct!.timezoneOffset),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function packDestinationOutputExabeamToHclTerraform(struct?: PackDestinationOutputExabeam | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    add_id_to_stage_path: {
      value: cdktf.booleanToHclTerraform(struct!.addIdToStagePath),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    aws_api_key: {
      value: cdktf.stringToHclTerraform(struct!.awsApiKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    aws_secret_key: {
      value: cdktf.stringToHclTerraform(struct!.awsSecretKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    bucket: {
      value: cdktf.stringToHclTerraform(struct!.bucket),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    collector_instance_id: {
      value: cdktf.stringToHclTerraform(struct!.collectorInstanceId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    deadletter_enabled: {
      value: cdktf.booleanToHclTerraform(struct!.deadletterEnabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    deadletter_path: {
      value: cdktf.stringToHclTerraform(struct!.deadletterPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    empty_dir_cleanup_sec: {
      value: cdktf.numberToHclTerraform(struct!.emptyDirCleanupSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    encoded_configuration: {
      value: cdktf.stringToHclTerraform(struct!.encodedConfiguration),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    endpoint: {
      value: cdktf.stringToHclTerraform(struct!.endpoint),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_file_idle_time_sec: {
      value: cdktf.numberToHclTerraform(struct!.maxFileIdleTimeSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_file_open_time_sec: {
      value: cdktf.numberToHclTerraform(struct!.maxFileOpenTimeSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_file_size_mb: {
      value: cdktf.numberToHclTerraform(struct!.maxFileSizeMb),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_open_files: {
      value: cdktf.numberToHclTerraform(struct!.maxOpenFiles),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_retry_num: {
      value: cdktf.numberToHclTerraform(struct!.maxRetryNum),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    object_acl: {
      value: cdktf.stringToHclTerraform(struct!.objectAcl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.onBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    on_disk_full_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.onDiskFullBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    region: {
      value: cdktf.stringToHclTerraform(struct!.region),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reject_unauthorized: {
      value: cdktf.booleanToHclTerraform(struct!.rejectUnauthorized),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    remove_empty_dirs: {
      value: cdktf.booleanToHclTerraform(struct!.removeEmptyDirs),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    reuse_connections: {
      value: cdktf.booleanToHclTerraform(struct!.reuseConnections),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    signature_version: {
      value: cdktf.stringToHclTerraform(struct!.signatureVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    site_id: {
      value: cdktf.stringToHclTerraform(struct!.siteId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    site_name: {
      value: cdktf.stringToHclTerraform(struct!.siteName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    stage_path: {
      value: cdktf.stringToHclTerraform(struct!.stagePath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    storage_class: {
      value: cdktf.stringToHclTerraform(struct!.storageClass),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    system_fields: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.systemFields),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    timezone_offset: {
      value: cdktf.stringToHclTerraform(struct!.timezoneOffset),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputExabeamOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackDestinationOutputExabeam | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._addIdToStagePath !== undefined) {
      hasAnyValues = true;
      internalValueResult.addIdToStagePath = this._addIdToStagePath;
    }
    if (this._awsApiKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.awsApiKey = this._awsApiKey;
    }
    if (this._awsSecretKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.awsSecretKey = this._awsSecretKey;
    }
    if (this._bucket !== undefined) {
      hasAnyValues = true;
      internalValueResult.bucket = this._bucket;
    }
    if (this._collectorInstanceId !== undefined) {
      hasAnyValues = true;
      internalValueResult.collectorInstanceId = this._collectorInstanceId;
    }
    if (this._deadletterEnabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.deadletterEnabled = this._deadletterEnabled;
    }
    if (this._deadletterPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.deadletterPath = this._deadletterPath;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._emptyDirCleanupSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.emptyDirCleanupSec = this._emptyDirCleanupSec;
    }
    if (this._encodedConfiguration !== undefined) {
      hasAnyValues = true;
      internalValueResult.encodedConfiguration = this._encodedConfiguration;
    }
    if (this._endpoint !== undefined) {
      hasAnyValues = true;
      internalValueResult.endpoint = this._endpoint;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._maxFileIdleTimeSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxFileIdleTimeSec = this._maxFileIdleTimeSec;
    }
    if (this._maxFileOpenTimeSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxFileOpenTimeSec = this._maxFileOpenTimeSec;
    }
    if (this._maxFileSizeMb !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxFileSizeMb = this._maxFileSizeMb;
    }
    if (this._maxOpenFiles !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxOpenFiles = this._maxOpenFiles;
    }
    if (this._maxRetryNum !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxRetryNum = this._maxRetryNum;
    }
    if (this._objectAcl !== undefined) {
      hasAnyValues = true;
      internalValueResult.objectAcl = this._objectAcl;
    }
    if (this._onBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.onBackpressure = this._onBackpressure;
    }
    if (this._onDiskFullBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.onDiskFullBackpressure = this._onDiskFullBackpressure;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._region !== undefined) {
      hasAnyValues = true;
      internalValueResult.region = this._region;
    }
    if (this._rejectUnauthorized !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectUnauthorized = this._rejectUnauthorized;
    }
    if (this._removeEmptyDirs !== undefined) {
      hasAnyValues = true;
      internalValueResult.removeEmptyDirs = this._removeEmptyDirs;
    }
    if (this._reuseConnections !== undefined) {
      hasAnyValues = true;
      internalValueResult.reuseConnections = this._reuseConnections;
    }
    if (this._signatureVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.signatureVersion = this._signatureVersion;
    }
    if (this._siteId !== undefined) {
      hasAnyValues = true;
      internalValueResult.siteId = this._siteId;
    }
    if (this._siteName !== undefined) {
      hasAnyValues = true;
      internalValueResult.siteName = this._siteName;
    }
    if (this._stagePath !== undefined) {
      hasAnyValues = true;
      internalValueResult.stagePath = this._stagePath;
    }
    if (this._storageClass !== undefined) {
      hasAnyValues = true;
      internalValueResult.storageClass = this._storageClass;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._systemFields !== undefined) {
      hasAnyValues = true;
      internalValueResult.systemFields = this._systemFields;
    }
    if (this._timezoneOffset !== undefined) {
      hasAnyValues = true;
      internalValueResult.timezoneOffset = this._timezoneOffset;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputExabeam | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._addIdToStagePath = undefined;
      this._awsApiKey = undefined;
      this._awsSecretKey = undefined;
      this._bucket = undefined;
      this._collectorInstanceId = undefined;
      this._deadletterEnabled = undefined;
      this._deadletterPath = undefined;
      this._description = undefined;
      this._emptyDirCleanupSec = undefined;
      this._encodedConfiguration = undefined;
      this._endpoint = undefined;
      this._environment = undefined;
      this._id = undefined;
      this._maxFileIdleTimeSec = undefined;
      this._maxFileOpenTimeSec = undefined;
      this._maxFileSizeMb = undefined;
      this._maxOpenFiles = undefined;
      this._maxRetryNum = undefined;
      this._objectAcl = undefined;
      this._onBackpressure = undefined;
      this._onDiskFullBackpressure = undefined;
      this._pipeline = undefined;
      this._region = undefined;
      this._rejectUnauthorized = undefined;
      this._removeEmptyDirs = undefined;
      this._reuseConnections = undefined;
      this._signatureVersion = undefined;
      this._siteId = undefined;
      this._siteName = undefined;
      this._stagePath = undefined;
      this._storageClass = undefined;
      this._streamtags = undefined;
      this._systemFields = undefined;
      this._timezoneOffset = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._addIdToStagePath = value.addIdToStagePath;
      this._awsApiKey = value.awsApiKey;
      this._awsSecretKey = value.awsSecretKey;
      this._bucket = value.bucket;
      this._collectorInstanceId = value.collectorInstanceId;
      this._deadletterEnabled = value.deadletterEnabled;
      this._deadletterPath = value.deadletterPath;
      this._description = value.description;
      this._emptyDirCleanupSec = value.emptyDirCleanupSec;
      this._encodedConfiguration = value.encodedConfiguration;
      this._endpoint = value.endpoint;
      this._environment = value.environment;
      this._id = value.id;
      this._maxFileIdleTimeSec = value.maxFileIdleTimeSec;
      this._maxFileOpenTimeSec = value.maxFileOpenTimeSec;
      this._maxFileSizeMb = value.maxFileSizeMb;
      this._maxOpenFiles = value.maxOpenFiles;
      this._maxRetryNum = value.maxRetryNum;
      this._objectAcl = value.objectAcl;
      this._onBackpressure = value.onBackpressure;
      this._onDiskFullBackpressure = value.onDiskFullBackpressure;
      this._pipeline = value.pipeline;
      this._region = value.region;
      this._rejectUnauthorized = value.rejectUnauthorized;
      this._removeEmptyDirs = value.removeEmptyDirs;
      this._reuseConnections = value.reuseConnections;
      this._signatureVersion = value.signatureVersion;
      this._siteId = value.siteId;
      this._siteName = value.siteName;
      this._stagePath = value.stagePath;
      this._storageClass = value.storageClass;
      this._streamtags = value.streamtags;
      this._systemFields = value.systemFields;
      this._timezoneOffset = value.timezoneOffset;
      this._type = value.type;
    }
  }

  // add_id_to_stage_path - computed: true, optional: true, required: false
  private _addIdToStagePath?: boolean | cdktf.IResolvable; 
  public get addIdToStagePath() {
    return this.getBooleanAttribute('add_id_to_stage_path');
  }
  public set addIdToStagePath(value: boolean | cdktf.IResolvable) {
    this._addIdToStagePath = value;
  }
  public resetAddIdToStagePath() {
    this._addIdToStagePath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addIdToStagePathInput() {
    return this._addIdToStagePath;
  }

  // aws_api_key - computed: false, optional: true, required: false
  private _awsApiKey?: string; 
  public get awsApiKey() {
    return this.getStringAttribute('aws_api_key');
  }
  public set awsApiKey(value: string) {
    this._awsApiKey = value;
  }
  public resetAwsApiKey() {
    this._awsApiKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsApiKeyInput() {
    return this._awsApiKey;
  }

  // aws_secret_key - computed: false, optional: true, required: false
  private _awsSecretKey?: string; 
  public get awsSecretKey() {
    return this.getStringAttribute('aws_secret_key');
  }
  public set awsSecretKey(value: string) {
    this._awsSecretKey = value;
  }
  public resetAwsSecretKey() {
    this._awsSecretKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsSecretKeyInput() {
    return this._awsSecretKey;
  }

  // bucket - computed: false, optional: false, required: true
  private _bucket?: string; 
  public get bucket() {
    return this.getStringAttribute('bucket');
  }
  public set bucket(value: string) {
    this._bucket = value;
  }
  // Temporarily expose input value. Use with caution.
  public get bucketInput() {
    return this._bucket;
  }

  // collector_instance_id - computed: false, optional: false, required: true
  private _collectorInstanceId?: string; 
  public get collectorInstanceId() {
    return this.getStringAttribute('collector_instance_id');
  }
  public set collectorInstanceId(value: string) {
    this._collectorInstanceId = value;
  }
  // Temporarily expose input value. Use with caution.
  public get collectorInstanceIdInput() {
    return this._collectorInstanceId;
  }

  // deadletter_enabled - computed: true, optional: true, required: false
  private _deadletterEnabled?: boolean | cdktf.IResolvable; 
  public get deadletterEnabled() {
    return this.getBooleanAttribute('deadletter_enabled');
  }
  public set deadletterEnabled(value: boolean | cdktf.IResolvable) {
    this._deadletterEnabled = value;
  }
  public resetDeadletterEnabled() {
    this._deadletterEnabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get deadletterEnabledInput() {
    return this._deadletterEnabled;
  }

  // deadletter_path - computed: true, optional: true, required: false
  private _deadletterPath?: string; 
  public get deadletterPath() {
    return this.getStringAttribute('deadletter_path');
  }
  public set deadletterPath(value: string) {
    this._deadletterPath = value;
  }
  public resetDeadletterPath() {
    this._deadletterPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get deadletterPathInput() {
    return this._deadletterPath;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // empty_dir_cleanup_sec - computed: true, optional: true, required: false
  private _emptyDirCleanupSec?: number; 
  public get emptyDirCleanupSec() {
    return this.getNumberAttribute('empty_dir_cleanup_sec');
  }
  public set emptyDirCleanupSec(value: number) {
    this._emptyDirCleanupSec = value;
  }
  public resetEmptyDirCleanupSec() {
    this._emptyDirCleanupSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get emptyDirCleanupSecInput() {
    return this._emptyDirCleanupSec;
  }

  // encoded_configuration - computed: false, optional: true, required: false
  private _encodedConfiguration?: string; 
  public get encodedConfiguration() {
    return this.getStringAttribute('encoded_configuration');
  }
  public set encodedConfiguration(value: string) {
    this._encodedConfiguration = value;
  }
  public resetEncodedConfiguration() {
    this._encodedConfiguration = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get encodedConfigurationInput() {
    return this._encodedConfiguration;
  }

  // endpoint - computed: true, optional: true, required: false
  private _endpoint?: string; 
  public get endpoint() {
    return this.getStringAttribute('endpoint');
  }
  public set endpoint(value: string) {
    this._endpoint = value;
  }
  public resetEndpoint() {
    this._endpoint = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get endpointInput() {
    return this._endpoint;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // max_file_idle_time_sec - computed: true, optional: true, required: false
  private _maxFileIdleTimeSec?: number; 
  public get maxFileIdleTimeSec() {
    return this.getNumberAttribute('max_file_idle_time_sec');
  }
  public set maxFileIdleTimeSec(value: number) {
    this._maxFileIdleTimeSec = value;
  }
  public resetMaxFileIdleTimeSec() {
    this._maxFileIdleTimeSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxFileIdleTimeSecInput() {
    return this._maxFileIdleTimeSec;
  }

  // max_file_open_time_sec - computed: true, optional: true, required: false
  private _maxFileOpenTimeSec?: number; 
  public get maxFileOpenTimeSec() {
    return this.getNumberAttribute('max_file_open_time_sec');
  }
  public set maxFileOpenTimeSec(value: number) {
    this._maxFileOpenTimeSec = value;
  }
  public resetMaxFileOpenTimeSec() {
    this._maxFileOpenTimeSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxFileOpenTimeSecInput() {
    return this._maxFileOpenTimeSec;
  }

  // max_file_size_mb - computed: true, optional: true, required: false
  private _maxFileSizeMb?: number; 
  public get maxFileSizeMb() {
    return this.getNumberAttribute('max_file_size_mb');
  }
  public set maxFileSizeMb(value: number) {
    this._maxFileSizeMb = value;
  }
  public resetMaxFileSizeMb() {
    this._maxFileSizeMb = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxFileSizeMbInput() {
    return this._maxFileSizeMb;
  }

  // max_open_files - computed: true, optional: true, required: false
  private _maxOpenFiles?: number; 
  public get maxOpenFiles() {
    return this.getNumberAttribute('max_open_files');
  }
  public set maxOpenFiles(value: number) {
    this._maxOpenFiles = value;
  }
  public resetMaxOpenFiles() {
    this._maxOpenFiles = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxOpenFilesInput() {
    return this._maxOpenFiles;
  }

  // max_retry_num - computed: true, optional: true, required: false
  private _maxRetryNum?: number; 
  public get maxRetryNum() {
    return this.getNumberAttribute('max_retry_num');
  }
  public set maxRetryNum(value: number) {
    this._maxRetryNum = value;
  }
  public resetMaxRetryNum() {
    this._maxRetryNum = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxRetryNumInput() {
    return this._maxRetryNum;
  }

  // object_acl - computed: true, optional: true, required: false
  private _objectAcl?: string; 
  public get objectAcl() {
    return this.getStringAttribute('object_acl');
  }
  public set objectAcl(value: string) {
    this._objectAcl = value;
  }
  public resetObjectAcl() {
    this._objectAcl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get objectAclInput() {
    return this._objectAcl;
  }

  // on_backpressure - computed: true, optional: true, required: false
  private _onBackpressure?: string; 
  public get onBackpressure() {
    return this.getStringAttribute('on_backpressure');
  }
  public set onBackpressure(value: string) {
    this._onBackpressure = value;
  }
  public resetOnBackpressure() {
    this._onBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get onBackpressureInput() {
    return this._onBackpressure;
  }

  // on_disk_full_backpressure - computed: true, optional: true, required: false
  private _onDiskFullBackpressure?: string; 
  public get onDiskFullBackpressure() {
    return this.getStringAttribute('on_disk_full_backpressure');
  }
  public set onDiskFullBackpressure(value: string) {
    this._onDiskFullBackpressure = value;
  }
  public resetOnDiskFullBackpressure() {
    this._onDiskFullBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get onDiskFullBackpressureInput() {
    return this._onDiskFullBackpressure;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // region - computed: false, optional: false, required: true
  private _region?: string; 
  public get region() {
    return this.getStringAttribute('region');
  }
  public set region(value: string) {
    this._region = value;
  }
  // Temporarily expose input value. Use with caution.
  public get regionInput() {
    return this._region;
  }

  // reject_unauthorized - computed: true, optional: true, required: false
  private _rejectUnauthorized?: boolean | cdktf.IResolvable; 
  public get rejectUnauthorized() {
    return this.getBooleanAttribute('reject_unauthorized');
  }
  public set rejectUnauthorized(value: boolean | cdktf.IResolvable) {
    this._rejectUnauthorized = value;
  }
  public resetRejectUnauthorized() {
    this._rejectUnauthorized = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectUnauthorizedInput() {
    return this._rejectUnauthorized;
  }

  // remove_empty_dirs - computed: true, optional: true, required: false
  private _removeEmptyDirs?: boolean | cdktf.IResolvable; 
  public get removeEmptyDirs() {
    return this.getBooleanAttribute('remove_empty_dirs');
  }
  public set removeEmptyDirs(value: boolean | cdktf.IResolvable) {
    this._removeEmptyDirs = value;
  }
  public resetRemoveEmptyDirs() {
    this._removeEmptyDirs = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get removeEmptyDirsInput() {
    return this._removeEmptyDirs;
  }

  // reuse_connections - computed: true, optional: true, required: false
  private _reuseConnections?: boolean | cdktf.IResolvable; 
  public get reuseConnections() {
    return this.getBooleanAttribute('reuse_connections');
  }
  public set reuseConnections(value: boolean | cdktf.IResolvable) {
    this._reuseConnections = value;
  }
  public resetReuseConnections() {
    this._reuseConnections = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get reuseConnectionsInput() {
    return this._reuseConnections;
  }

  // signature_version - computed: true, optional: true, required: false
  private _signatureVersion?: string; 
  public get signatureVersion() {
    return this.getStringAttribute('signature_version');
  }
  public set signatureVersion(value: string) {
    this._signatureVersion = value;
  }
  public resetSignatureVersion() {
    this._signatureVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get signatureVersionInput() {
    return this._signatureVersion;
  }

  // site_id - computed: false, optional: true, required: false
  private _siteId?: string; 
  public get siteId() {
    return this.getStringAttribute('site_id');
  }
  public set siteId(value: string) {
    this._siteId = value;
  }
  public resetSiteId() {
    this._siteId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get siteIdInput() {
    return this._siteId;
  }

  // site_name - computed: false, optional: true, required: false
  private _siteName?: string; 
  public get siteName() {
    return this.getStringAttribute('site_name');
  }
  public set siteName(value: string) {
    this._siteName = value;
  }
  public resetSiteName() {
    this._siteName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get siteNameInput() {
    return this._siteName;
  }

  // stage_path - computed: true, optional: true, required: false
  private _stagePath?: string; 
  public get stagePath() {
    return this.getStringAttribute('stage_path');
  }
  public set stagePath(value: string) {
    this._stagePath = value;
  }
  public resetStagePath() {
    this._stagePath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get stagePathInput() {
    return this._stagePath;
  }

  // storage_class - computed: false, optional: true, required: false
  private _storageClass?: string; 
  public get storageClass() {
    return this.getStringAttribute('storage_class');
  }
  public set storageClass(value: string) {
    this._storageClass = value;
  }
  public resetStorageClass() {
    this._storageClass = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get storageClassInput() {
    return this._storageClass;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // system_fields - computed: true, optional: true, required: false
  private _systemFields?: string[]; 
  public get systemFields() {
    return this.getListAttribute('system_fields');
  }
  public set systemFields(value: string[]) {
    this._systemFields = value;
  }
  public resetSystemFields() {
    this._systemFields = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get systemFieldsInput() {
    return this._systemFields;
  }

  // timezone_offset - computed: false, optional: true, required: false
  private _timezoneOffset?: string; 
  public get timezoneOffset() {
    return this.getStringAttribute('timezone_offset');
  }
  public set timezoneOffset(value: string) {
    this._timezoneOffset = value;
  }
  public resetTimezoneOffset() {
    this._timezoneOffset = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timezoneOffsetInput() {
    return this._timezoneOffset;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface PackDestinationOutputFilesystemKeyValueMetadata {
  /**
  * Default: ""
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#key PackDestination#key}
  */
  readonly key?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#value PackDestination#value}
  */
  readonly value: string;
}

export function packDestinationOutputFilesystemKeyValueMetadataToTerraform(struct?: PackDestinationOutputFilesystemKeyValueMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function packDestinationOutputFilesystemKeyValueMetadataToHclTerraform(struct?: PackDestinationOutputFilesystemKeyValueMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputFilesystemKeyValueMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackDestinationOutputFilesystemKeyValueMetadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputFilesystemKeyValueMetadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._value = value.value;
    }
  }

  // key - computed: true, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class PackDestinationOutputFilesystemKeyValueMetadataList extends cdktf.ComplexList {
  public internalValue? : PackDestinationOutputFilesystemKeyValueMetadata[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackDestinationOutputFilesystemKeyValueMetadataOutputReference {
    return new PackDestinationOutputFilesystemKeyValueMetadataOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackDestinationOutputFilesystem {
  /**
  * Add the Output ID value to staging location. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#add_id_to_stage_path PackDestination#add_id_to_stage_path}
  */
  readonly addIdToStagePath?: boolean | cdktf.IResolvable;
  /**
  * Automatically calculate the schema based on the events of each Parquet file generated. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#automatic_schema PackDestination#automatic_schema}
  */
  readonly automaticSchema?: boolean | cdktf.IResolvable;
  /**
  * JavaScript expression to define the output filename prefix (can be constant). Default: "`CriblOut`"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#base_file_name PackDestination#base_file_name}
  */
  readonly baseFileName?: string;
  /**
  * Data compression format to apply to HTTP content before it is delivered. Default: "gzip"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#compress PackDestination#compress}
  */
  readonly compress?: string;
  /**
  * Compression level to apply before moving files to final destination. Default: "best_speed"; must be one of ["best_speed", "normal", "best_compression"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#compression_level PackDestination#compression_level}
  */
  readonly compressionLevel?: string;
  /**
  * If a file fails to move to its final destination after the maximum number of retries, move it to a designated directory to prevent further errors. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#deadletter_enabled PackDestination#deadletter_enabled}
  */
  readonly deadletterEnabled?: boolean | cdktf.IResolvable;
  /**
  * Storage location for files that fail to reach their final destination after maximum retries are exceeded. Default: "$CRIBL_HOME/state/outputs/dead-letter"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#deadletter_path PackDestination#deadletter_path}
  */
  readonly deadletterPath?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#description PackDestination#description}
  */
  readonly description?: string;
  /**
  * Final destination for the output files
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#dest_path PackDestination#dest_path}
  */
  readonly destPath: string;
  /**
  * How frequently, in seconds, to clean up empty directories. Default: 300
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#empty_dir_cleanup_sec PackDestination#empty_dir_cleanup_sec}
  */
  readonly emptyDirCleanupSec?: number;
  /**
  * Parquet tools can use the checksum of a Parquet page to verify data integrity. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#enable_page_checksum PackDestination#enable_page_checksum}
  */
  readonly enablePageChecksum?: boolean | cdktf.IResolvable;
  /**
  * Statistics profile an entire file in terms of minimum/maximum values within data, numbers of nulls, etc. You can use Parquet tools to view statistics. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#enable_statistics PackDestination#enable_statistics}
  */
  readonly enableStatistics?: boolean | cdktf.IResolvable;
  /**
  * One page index contains statistics for one data page. Parquet readers use statistics to enable page skipping. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#enable_write_page_index PackDestination#enable_write_page_index}
  */
  readonly enableWritePageIndex?: boolean | cdktf.IResolvable;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#environment PackDestination#environment}
  */
  readonly environment?: string;
  /**
  * JavaScript expression to define the output filename suffix (can be constant).  The `__format` variable refers to the value of the `Data format` field (`json` or `raw`).  The `__compression` field refers to the kind of compression being used (`none` or `gzip`). Default: "`.${C.env[\"CRIBL_WORKER_ID\"]}.${__format}${__compression === \"gzip\" ? \".gz\" : \"\"}`"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#file_name_suffix PackDestination#file_name_suffix}
  */
  readonly fileNameSuffix?: string;
  /**
  * Format of the output data. Default: "json"; must be one of ["json", "raw", "parquet"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#format PackDestination#format}
  */
  readonly format?: string;
  /**
  * If set, this line will be written to the beginning of each output file. Default: ""
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#header_line PackDestination#header_line}
  */
  readonly headerLine?: string;
  /**
  * Unique ID for this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#id PackDestination#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * The metadata of files the Destination writes will include the properties you add here as key-value pairs. Useful for tagging. Examples: "key":"OCSF Event Class", "value":"9001"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#key_value_metadata PackDestination#key_value_metadata}
  */
  readonly keyValueMetadata?: PackDestinationOutputFilesystemKeyValueMetadata[] | cdktf.IResolvable;
  /**
  * Maximum amount of time to keep inactive files open. Files open for longer than this will be closed and moved to final output location. Default: 30
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_file_idle_time_sec PackDestination#max_file_idle_time_sec}
  */
  readonly maxFileIdleTimeSec?: number;
  /**
  * Maximum amount of time to write to a file. Files open for longer than this will be closed and moved to final output location. Default: 300
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_file_open_time_sec PackDestination#max_file_open_time_sec}
  */
  readonly maxFileOpenTimeSec?: number;
  /**
  * Maximum uncompressed output file size. Files of this size will be closed and moved to final output location. Default: 32
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_file_size_mb PackDestination#max_file_size_mb}
  */
  readonly maxFileSizeMb?: number;
  /**
  * Maximum number of files to keep open concurrently. When exceeded, @{product} will close the oldest open files and move them to the final output location. Default: 100
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_open_files PackDestination#max_open_files}
  */
  readonly maxOpenFiles?: number;
  /**
  * The maximum number of times a file will attempt to move to its final destination before being dead-lettered. Default: 20
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_retry_num PackDestination#max_retry_num}
  */
  readonly maxRetryNum?: number;
  /**
  * How to handle events when all receivers are exerting backpressure. Default: "block"; must be one of ["block", "drop"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#on_backpressure PackDestination#on_backpressure}
  */
  readonly onBackpressure?: string;
  /**
  * How to handle events when disk space is below the global 'Min free disk space' limit. Default: "block"; must be one of ["block", "drop"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#on_disk_full_backpressure PackDestination#on_disk_full_backpressure}
  */
  readonly onDiskFullBackpressure?: string;
  /**
  * Serialization format of data pages. Note that some reader implementations use Data page V2's attributes to work more efficiently, while others ignore it. Default: "DATA_PAGE_V2"; must be one of ["DATA_PAGE_V1", "DATA_PAGE_V2"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#parquet_data_page_version PackDestination#parquet_data_page_version}
  */
  readonly parquetDataPageVersion?: string;
  /**
  * Target memory size for page segments, such as 1MB or 128MB. Generally, lower values improve reading speed, while higher values improve compression. Default: "1MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#parquet_page_size PackDestination#parquet_page_size}
  */
  readonly parquetPageSize?: string;
  /**
  * The number of rows that every group will contain. The final group can contain a smaller number of rows. Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#parquet_row_group_length PackDestination#parquet_row_group_length}
  */
  readonly parquetRowGroupLength?: number;
  /**
  * Determines which data types are supported and how they are represented. Default: "PARQUET_2_6"; must be one of ["PARQUET_1_0", "PARQUET_2_4", "PARQUET_2_6"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#parquet_version PackDestination#parquet_version}
  */
  readonly parquetVersion?: string;
  /**
  * JavaScript expression defining how files are partitioned and organized. Default is date-based. If blank, Stream will fall back to the event's __partition field value – if present – otherwise to each location's root directory. Default: "C.Time.strftime(_time ? _time : Date.now()/1000, '%Y/%m/%d')"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#partition_expr PackDestination#partition_expr}
  */
  readonly partitionExpr?: string;
  /**
  * Pipeline to process data before sending out to this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pipeline PackDestination#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Remove empty staging directories after moving files. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#remove_empty_dirs PackDestination#remove_empty_dirs}
  */
  readonly removeEmptyDirs?: boolean | cdktf.IResolvable;
  /**
  * Log up to 3 rows that @{product} skips due to data mismatch
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#should_log_invalid_rows PackDestination#should_log_invalid_rows}
  */
  readonly shouldLogInvalidRows?: boolean | cdktf.IResolvable;
  /**
  * Filesystem location in which to buffer files before compressing and moving to final destination. Use performant, stable storage.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#stage_path PackDestination#stage_path}
  */
  readonly stagePath?: string;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#streamtags PackDestination#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Fields to automatically add to events, such as cribl_pipe. Supports wildcards. Default: ["cribl_pipe"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#system_fields PackDestination#system_fields}
  */
  readonly systemFields?: string[];
  /**
  * must be "filesystem"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#type PackDestination#type}
  */
  readonly type: string;
  /**
  * Buffer size used to write to a file. Default: 64
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#write_high_water_mark PackDestination#write_high_water_mark}
  */
  readonly writeHighWaterMark?: number;
}

export function packDestinationOutputFilesystemToTerraform(struct?: PackDestinationOutputFilesystem | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    add_id_to_stage_path: cdktf.booleanToTerraform(struct!.addIdToStagePath),
    automatic_schema: cdktf.booleanToTerraform(struct!.automaticSchema),
    base_file_name: cdktf.stringToTerraform(struct!.baseFileName),
    compress: cdktf.stringToTerraform(struct!.compress),
    compression_level: cdktf.stringToTerraform(struct!.compressionLevel),
    deadletter_enabled: cdktf.booleanToTerraform(struct!.deadletterEnabled),
    deadletter_path: cdktf.stringToTerraform(struct!.deadletterPath),
    description: cdktf.stringToTerraform(struct!.description),
    dest_path: cdktf.stringToTerraform(struct!.destPath),
    empty_dir_cleanup_sec: cdktf.numberToTerraform(struct!.emptyDirCleanupSec),
    enable_page_checksum: cdktf.booleanToTerraform(struct!.enablePageChecksum),
    enable_statistics: cdktf.booleanToTerraform(struct!.enableStatistics),
    enable_write_page_index: cdktf.booleanToTerraform(struct!.enableWritePageIndex),
    environment: cdktf.stringToTerraform(struct!.environment),
    file_name_suffix: cdktf.stringToTerraform(struct!.fileNameSuffix),
    format: cdktf.stringToTerraform(struct!.format),
    header_line: cdktf.stringToTerraform(struct!.headerLine),
    id: cdktf.stringToTerraform(struct!.id),
    key_value_metadata: cdktf.listMapper(packDestinationOutputFilesystemKeyValueMetadataToTerraform, false)(struct!.keyValueMetadata),
    max_file_idle_time_sec: cdktf.numberToTerraform(struct!.maxFileIdleTimeSec),
    max_file_open_time_sec: cdktf.numberToTerraform(struct!.maxFileOpenTimeSec),
    max_file_size_mb: cdktf.numberToTerraform(struct!.maxFileSizeMb),
    max_open_files: cdktf.numberToTerraform(struct!.maxOpenFiles),
    max_retry_num: cdktf.numberToTerraform(struct!.maxRetryNum),
    on_backpressure: cdktf.stringToTerraform(struct!.onBackpressure),
    on_disk_full_backpressure: cdktf.stringToTerraform(struct!.onDiskFullBackpressure),
    parquet_data_page_version: cdktf.stringToTerraform(struct!.parquetDataPageVersion),
    parquet_page_size: cdktf.stringToTerraform(struct!.parquetPageSize),
    parquet_row_group_length: cdktf.numberToTerraform(struct!.parquetRowGroupLength),
    parquet_version: cdktf.stringToTerraform(struct!.parquetVersion),
    partition_expr: cdktf.stringToTerraform(struct!.partitionExpr),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    remove_empty_dirs: cdktf.booleanToTerraform(struct!.removeEmptyDirs),
    should_log_invalid_rows: cdktf.booleanToTerraform(struct!.shouldLogInvalidRows),
    stage_path: cdktf.stringToTerraform(struct!.stagePath),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    system_fields: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.systemFields),
    type: cdktf.stringToTerraform(struct!.type),
    write_high_water_mark: cdktf.numberToTerraform(struct!.writeHighWaterMark),
  }
}


export function packDestinationOutputFilesystemToHclTerraform(struct?: PackDestinationOutputFilesystem | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    add_id_to_stage_path: {
      value: cdktf.booleanToHclTerraform(struct!.addIdToStagePath),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    automatic_schema: {
      value: cdktf.booleanToHclTerraform(struct!.automaticSchema),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    base_file_name: {
      value: cdktf.stringToHclTerraform(struct!.baseFileName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    compress: {
      value: cdktf.stringToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    compression_level: {
      value: cdktf.stringToHclTerraform(struct!.compressionLevel),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    deadletter_enabled: {
      value: cdktf.booleanToHclTerraform(struct!.deadletterEnabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    deadletter_path: {
      value: cdktf.stringToHclTerraform(struct!.deadletterPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    dest_path: {
      value: cdktf.stringToHclTerraform(struct!.destPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    empty_dir_cleanup_sec: {
      value: cdktf.numberToHclTerraform(struct!.emptyDirCleanupSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    enable_page_checksum: {
      value: cdktf.booleanToHclTerraform(struct!.enablePageChecksum),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    enable_statistics: {
      value: cdktf.booleanToHclTerraform(struct!.enableStatistics),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    enable_write_page_index: {
      value: cdktf.booleanToHclTerraform(struct!.enableWritePageIndex),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    file_name_suffix: {
      value: cdktf.stringToHclTerraform(struct!.fileNameSuffix),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    format: {
      value: cdktf.stringToHclTerraform(struct!.format),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    header_line: {
      value: cdktf.stringToHclTerraform(struct!.headerLine),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    key_value_metadata: {
      value: cdktf.listMapperHcl(packDestinationOutputFilesystemKeyValueMetadataToHclTerraform, false)(struct!.keyValueMetadata),
      isBlock: true,
      type: "list",
      storageClassType: "PackDestinationOutputFilesystemKeyValueMetadataList",
    },
    max_file_idle_time_sec: {
      value: cdktf.numberToHclTerraform(struct!.maxFileIdleTimeSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_file_open_time_sec: {
      value: cdktf.numberToHclTerraform(struct!.maxFileOpenTimeSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_file_size_mb: {
      value: cdktf.numberToHclTerraform(struct!.maxFileSizeMb),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_open_files: {
      value: cdktf.numberToHclTerraform(struct!.maxOpenFiles),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_retry_num: {
      value: cdktf.numberToHclTerraform(struct!.maxRetryNum),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.onBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    on_disk_full_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.onDiskFullBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    parquet_data_page_version: {
      value: cdktf.stringToHclTerraform(struct!.parquetDataPageVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    parquet_page_size: {
      value: cdktf.stringToHclTerraform(struct!.parquetPageSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    parquet_row_group_length: {
      value: cdktf.numberToHclTerraform(struct!.parquetRowGroupLength),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    parquet_version: {
      value: cdktf.stringToHclTerraform(struct!.parquetVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    partition_expr: {
      value: cdktf.stringToHclTerraform(struct!.partitionExpr),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    remove_empty_dirs: {
      value: cdktf.booleanToHclTerraform(struct!.removeEmptyDirs),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    should_log_invalid_rows: {
      value: cdktf.booleanToHclTerraform(struct!.shouldLogInvalidRows),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    stage_path: {
      value: cdktf.stringToHclTerraform(struct!.stagePath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    system_fields: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.systemFields),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    write_high_water_mark: {
      value: cdktf.numberToHclTerraform(struct!.writeHighWaterMark),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputFilesystemOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackDestinationOutputFilesystem | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._addIdToStagePath !== undefined) {
      hasAnyValues = true;
      internalValueResult.addIdToStagePath = this._addIdToStagePath;
    }
    if (this._automaticSchema !== undefined) {
      hasAnyValues = true;
      internalValueResult.automaticSchema = this._automaticSchema;
    }
    if (this._baseFileName !== undefined) {
      hasAnyValues = true;
      internalValueResult.baseFileName = this._baseFileName;
    }
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._compressionLevel !== undefined) {
      hasAnyValues = true;
      internalValueResult.compressionLevel = this._compressionLevel;
    }
    if (this._deadletterEnabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.deadletterEnabled = this._deadletterEnabled;
    }
    if (this._deadletterPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.deadletterPath = this._deadletterPath;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._destPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.destPath = this._destPath;
    }
    if (this._emptyDirCleanupSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.emptyDirCleanupSec = this._emptyDirCleanupSec;
    }
    if (this._enablePageChecksum !== undefined) {
      hasAnyValues = true;
      internalValueResult.enablePageChecksum = this._enablePageChecksum;
    }
    if (this._enableStatistics !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableStatistics = this._enableStatistics;
    }
    if (this._enableWritePageIndex !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableWritePageIndex = this._enableWritePageIndex;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._fileNameSuffix !== undefined) {
      hasAnyValues = true;
      internalValueResult.fileNameSuffix = this._fileNameSuffix;
    }
    if (this._format !== undefined) {
      hasAnyValues = true;
      internalValueResult.format = this._format;
    }
    if (this._headerLine !== undefined) {
      hasAnyValues = true;
      internalValueResult.headerLine = this._headerLine;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._keyValueMetadata?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.keyValueMetadata = this._keyValueMetadata?.internalValue;
    }
    if (this._maxFileIdleTimeSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxFileIdleTimeSec = this._maxFileIdleTimeSec;
    }
    if (this._maxFileOpenTimeSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxFileOpenTimeSec = this._maxFileOpenTimeSec;
    }
    if (this._maxFileSizeMb !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxFileSizeMb = this._maxFileSizeMb;
    }
    if (this._maxOpenFiles !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxOpenFiles = this._maxOpenFiles;
    }
    if (this._maxRetryNum !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxRetryNum = this._maxRetryNum;
    }
    if (this._onBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.onBackpressure = this._onBackpressure;
    }
    if (this._onDiskFullBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.onDiskFullBackpressure = this._onDiskFullBackpressure;
    }
    if (this._parquetDataPageVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.parquetDataPageVersion = this._parquetDataPageVersion;
    }
    if (this._parquetPageSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.parquetPageSize = this._parquetPageSize;
    }
    if (this._parquetRowGroupLength !== undefined) {
      hasAnyValues = true;
      internalValueResult.parquetRowGroupLength = this._parquetRowGroupLength;
    }
    if (this._parquetVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.parquetVersion = this._parquetVersion;
    }
    if (this._partitionExpr !== undefined) {
      hasAnyValues = true;
      internalValueResult.partitionExpr = this._partitionExpr;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._removeEmptyDirs !== undefined) {
      hasAnyValues = true;
      internalValueResult.removeEmptyDirs = this._removeEmptyDirs;
    }
    if (this._shouldLogInvalidRows !== undefined) {
      hasAnyValues = true;
      internalValueResult.shouldLogInvalidRows = this._shouldLogInvalidRows;
    }
    if (this._stagePath !== undefined) {
      hasAnyValues = true;
      internalValueResult.stagePath = this._stagePath;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._systemFields !== undefined) {
      hasAnyValues = true;
      internalValueResult.systemFields = this._systemFields;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._writeHighWaterMark !== undefined) {
      hasAnyValues = true;
      internalValueResult.writeHighWaterMark = this._writeHighWaterMark;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputFilesystem | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._addIdToStagePath = undefined;
      this._automaticSchema = undefined;
      this._baseFileName = undefined;
      this._compress = undefined;
      this._compressionLevel = undefined;
      this._deadletterEnabled = undefined;
      this._deadletterPath = undefined;
      this._description = undefined;
      this._destPath = undefined;
      this._emptyDirCleanupSec = undefined;
      this._enablePageChecksum = undefined;
      this._enableStatistics = undefined;
      this._enableWritePageIndex = undefined;
      this._environment = undefined;
      this._fileNameSuffix = undefined;
      this._format = undefined;
      this._headerLine = undefined;
      this._id = undefined;
      this._keyValueMetadata.internalValue = undefined;
      this._maxFileIdleTimeSec = undefined;
      this._maxFileOpenTimeSec = undefined;
      this._maxFileSizeMb = undefined;
      this._maxOpenFiles = undefined;
      this._maxRetryNum = undefined;
      this._onBackpressure = undefined;
      this._onDiskFullBackpressure = undefined;
      this._parquetDataPageVersion = undefined;
      this._parquetPageSize = undefined;
      this._parquetRowGroupLength = undefined;
      this._parquetVersion = undefined;
      this._partitionExpr = undefined;
      this._pipeline = undefined;
      this._removeEmptyDirs = undefined;
      this._shouldLogInvalidRows = undefined;
      this._stagePath = undefined;
      this._streamtags = undefined;
      this._systemFields = undefined;
      this._type = undefined;
      this._writeHighWaterMark = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._addIdToStagePath = value.addIdToStagePath;
      this._automaticSchema = value.automaticSchema;
      this._baseFileName = value.baseFileName;
      this._compress = value.compress;
      this._compressionLevel = value.compressionLevel;
      this._deadletterEnabled = value.deadletterEnabled;
      this._deadletterPath = value.deadletterPath;
      this._description = value.description;
      this._destPath = value.destPath;
      this._emptyDirCleanupSec = value.emptyDirCleanupSec;
      this._enablePageChecksum = value.enablePageChecksum;
      this._enableStatistics = value.enableStatistics;
      this._enableWritePageIndex = value.enableWritePageIndex;
      this._environment = value.environment;
      this._fileNameSuffix = value.fileNameSuffix;
      this._format = value.format;
      this._headerLine = value.headerLine;
      this._id = value.id;
      this._keyValueMetadata.internalValue = value.keyValueMetadata;
      this._maxFileIdleTimeSec = value.maxFileIdleTimeSec;
      this._maxFileOpenTimeSec = value.maxFileOpenTimeSec;
      this._maxFileSizeMb = value.maxFileSizeMb;
      this._maxOpenFiles = value.maxOpenFiles;
      this._maxRetryNum = value.maxRetryNum;
      this._onBackpressure = value.onBackpressure;
      this._onDiskFullBackpressure = value.onDiskFullBackpressure;
      this._parquetDataPageVersion = value.parquetDataPageVersion;
      this._parquetPageSize = value.parquetPageSize;
      this._parquetRowGroupLength = value.parquetRowGroupLength;
      this._parquetVersion = value.parquetVersion;
      this._partitionExpr = value.partitionExpr;
      this._pipeline = value.pipeline;
      this._removeEmptyDirs = value.removeEmptyDirs;
      this._shouldLogInvalidRows = value.shouldLogInvalidRows;
      this._stagePath = value.stagePath;
      this._streamtags = value.streamtags;
      this._systemFields = value.systemFields;
      this._type = value.type;
      this._writeHighWaterMark = value.writeHighWaterMark;
    }
  }

  // add_id_to_stage_path - computed: true, optional: true, required: false
  private _addIdToStagePath?: boolean | cdktf.IResolvable; 
  public get addIdToStagePath() {
    return this.getBooleanAttribute('add_id_to_stage_path');
  }
  public set addIdToStagePath(value: boolean | cdktf.IResolvable) {
    this._addIdToStagePath = value;
  }
  public resetAddIdToStagePath() {
    this._addIdToStagePath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addIdToStagePathInput() {
    return this._addIdToStagePath;
  }

  // automatic_schema - computed: true, optional: true, required: false
  private _automaticSchema?: boolean | cdktf.IResolvable; 
  public get automaticSchema() {
    return this.getBooleanAttribute('automatic_schema');
  }
  public set automaticSchema(value: boolean | cdktf.IResolvable) {
    this._automaticSchema = value;
  }
  public resetAutomaticSchema() {
    this._automaticSchema = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get automaticSchemaInput() {
    return this._automaticSchema;
  }

  // base_file_name - computed: true, optional: true, required: false
  private _baseFileName?: string; 
  public get baseFileName() {
    return this.getStringAttribute('base_file_name');
  }
  public set baseFileName(value: string) {
    this._baseFileName = value;
  }
  public resetBaseFileName() {
    this._baseFileName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get baseFileNameInput() {
    return this._baseFileName;
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: string; 
  public get compress() {
    return this.getStringAttribute('compress');
  }
  public set compress(value: string) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // compression_level - computed: true, optional: true, required: false
  private _compressionLevel?: string; 
  public get compressionLevel() {
    return this.getStringAttribute('compression_level');
  }
  public set compressionLevel(value: string) {
    this._compressionLevel = value;
  }
  public resetCompressionLevel() {
    this._compressionLevel = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressionLevelInput() {
    return this._compressionLevel;
  }

  // deadletter_enabled - computed: true, optional: true, required: false
  private _deadletterEnabled?: boolean | cdktf.IResolvable; 
  public get deadletterEnabled() {
    return this.getBooleanAttribute('deadletter_enabled');
  }
  public set deadletterEnabled(value: boolean | cdktf.IResolvable) {
    this._deadletterEnabled = value;
  }
  public resetDeadletterEnabled() {
    this._deadletterEnabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get deadletterEnabledInput() {
    return this._deadletterEnabled;
  }

  // deadletter_path - computed: true, optional: true, required: false
  private _deadletterPath?: string; 
  public get deadletterPath() {
    return this.getStringAttribute('deadletter_path');
  }
  public set deadletterPath(value: string) {
    this._deadletterPath = value;
  }
  public resetDeadletterPath() {
    this._deadletterPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get deadletterPathInput() {
    return this._deadletterPath;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // dest_path - computed: false, optional: false, required: true
  private _destPath?: string; 
  public get destPath() {
    return this.getStringAttribute('dest_path');
  }
  public set destPath(value: string) {
    this._destPath = value;
  }
  // Temporarily expose input value. Use with caution.
  public get destPathInput() {
    return this._destPath;
  }

  // empty_dir_cleanup_sec - computed: true, optional: true, required: false
  private _emptyDirCleanupSec?: number; 
  public get emptyDirCleanupSec() {
    return this.getNumberAttribute('empty_dir_cleanup_sec');
  }
  public set emptyDirCleanupSec(value: number) {
    this._emptyDirCleanupSec = value;
  }
  public resetEmptyDirCleanupSec() {
    this._emptyDirCleanupSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get emptyDirCleanupSecInput() {
    return this._emptyDirCleanupSec;
  }

  // enable_page_checksum - computed: true, optional: true, required: false
  private _enablePageChecksum?: boolean | cdktf.IResolvable; 
  public get enablePageChecksum() {
    return this.getBooleanAttribute('enable_page_checksum');
  }
  public set enablePageChecksum(value: boolean | cdktf.IResolvable) {
    this._enablePageChecksum = value;
  }
  public resetEnablePageChecksum() {
    this._enablePageChecksum = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enablePageChecksumInput() {
    return this._enablePageChecksum;
  }

  // enable_statistics - computed: true, optional: true, required: false
  private _enableStatistics?: boolean | cdktf.IResolvable; 
  public get enableStatistics() {
    return this.getBooleanAttribute('enable_statistics');
  }
  public set enableStatistics(value: boolean | cdktf.IResolvable) {
    this._enableStatistics = value;
  }
  public resetEnableStatistics() {
    this._enableStatistics = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableStatisticsInput() {
    return this._enableStatistics;
  }

  // enable_write_page_index - computed: true, optional: true, required: false
  private _enableWritePageIndex?: boolean | cdktf.IResolvable; 
  public get enableWritePageIndex() {
    return this.getBooleanAttribute('enable_write_page_index');
  }
  public set enableWritePageIndex(value: boolean | cdktf.IResolvable) {
    this._enableWritePageIndex = value;
  }
  public resetEnableWritePageIndex() {
    this._enableWritePageIndex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableWritePageIndexInput() {
    return this._enableWritePageIndex;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // file_name_suffix - computed: true, optional: true, required: false
  private _fileNameSuffix?: string; 
  public get fileNameSuffix() {
    return this.getStringAttribute('file_name_suffix');
  }
  public set fileNameSuffix(value: string) {
    this._fileNameSuffix = value;
  }
  public resetFileNameSuffix() {
    this._fileNameSuffix = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fileNameSuffixInput() {
    return this._fileNameSuffix;
  }

  // format - computed: true, optional: true, required: false
  private _format?: string; 
  public get format() {
    return this.getStringAttribute('format');
  }
  public set format(value: string) {
    this._format = value;
  }
  public resetFormat() {
    this._format = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get formatInput() {
    return this._format;
  }

  // header_line - computed: true, optional: true, required: false
  private _headerLine?: string; 
  public get headerLine() {
    return this.getStringAttribute('header_line');
  }
  public set headerLine(value: string) {
    this._headerLine = value;
  }
  public resetHeaderLine() {
    this._headerLine = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get headerLineInput() {
    return this._headerLine;
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // key_value_metadata - computed: false, optional: true, required: false
  private _keyValueMetadata = new PackDestinationOutputFilesystemKeyValueMetadataList(this, "key_value_metadata", false);
  public get keyValueMetadata() {
    return this._keyValueMetadata;
  }
  public putKeyValueMetadata(value: PackDestinationOutputFilesystemKeyValueMetadata[] | cdktf.IResolvable) {
    this._keyValueMetadata.internalValue = value;
  }
  public resetKeyValueMetadata() {
    this._keyValueMetadata.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyValueMetadataInput() {
    return this._keyValueMetadata.internalValue;
  }

  // max_file_idle_time_sec - computed: true, optional: true, required: false
  private _maxFileIdleTimeSec?: number; 
  public get maxFileIdleTimeSec() {
    return this.getNumberAttribute('max_file_idle_time_sec');
  }
  public set maxFileIdleTimeSec(value: number) {
    this._maxFileIdleTimeSec = value;
  }
  public resetMaxFileIdleTimeSec() {
    this._maxFileIdleTimeSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxFileIdleTimeSecInput() {
    return this._maxFileIdleTimeSec;
  }

  // max_file_open_time_sec - computed: true, optional: true, required: false
  private _maxFileOpenTimeSec?: number; 
  public get maxFileOpenTimeSec() {
    return this.getNumberAttribute('max_file_open_time_sec');
  }
  public set maxFileOpenTimeSec(value: number) {
    this._maxFileOpenTimeSec = value;
  }
  public resetMaxFileOpenTimeSec() {
    this._maxFileOpenTimeSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxFileOpenTimeSecInput() {
    return this._maxFileOpenTimeSec;
  }

  // max_file_size_mb - computed: true, optional: true, required: false
  private _maxFileSizeMb?: number; 
  public get maxFileSizeMb() {
    return this.getNumberAttribute('max_file_size_mb');
  }
  public set maxFileSizeMb(value: number) {
    this._maxFileSizeMb = value;
  }
  public resetMaxFileSizeMb() {
    this._maxFileSizeMb = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxFileSizeMbInput() {
    return this._maxFileSizeMb;
  }

  // max_open_files - computed: true, optional: true, required: false
  private _maxOpenFiles?: number; 
  public get maxOpenFiles() {
    return this.getNumberAttribute('max_open_files');
  }
  public set maxOpenFiles(value: number) {
    this._maxOpenFiles = value;
  }
  public resetMaxOpenFiles() {
    this._maxOpenFiles = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxOpenFilesInput() {
    return this._maxOpenFiles;
  }

  // max_retry_num - computed: true, optional: true, required: false
  private _maxRetryNum?: number; 
  public get maxRetryNum() {
    return this.getNumberAttribute('max_retry_num');
  }
  public set maxRetryNum(value: number) {
    this._maxRetryNum = value;
  }
  public resetMaxRetryNum() {
    this._maxRetryNum = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxRetryNumInput() {
    return this._maxRetryNum;
  }

  // on_backpressure - computed: true, optional: true, required: false
  private _onBackpressure?: string; 
  public get onBackpressure() {
    return this.getStringAttribute('on_backpressure');
  }
  public set onBackpressure(value: string) {
    this._onBackpressure = value;
  }
  public resetOnBackpressure() {
    this._onBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get onBackpressureInput() {
    return this._onBackpressure;
  }

  // on_disk_full_backpressure - computed: true, optional: true, required: false
  private _onDiskFullBackpressure?: string; 
  public get onDiskFullBackpressure() {
    return this.getStringAttribute('on_disk_full_backpressure');
  }
  public set onDiskFullBackpressure(value: string) {
    this._onDiskFullBackpressure = value;
  }
  public resetOnDiskFullBackpressure() {
    this._onDiskFullBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get onDiskFullBackpressureInput() {
    return this._onDiskFullBackpressure;
  }

  // parquet_data_page_version - computed: true, optional: true, required: false
  private _parquetDataPageVersion?: string; 
  public get parquetDataPageVersion() {
    return this.getStringAttribute('parquet_data_page_version');
  }
  public set parquetDataPageVersion(value: string) {
    this._parquetDataPageVersion = value;
  }
  public resetParquetDataPageVersion() {
    this._parquetDataPageVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get parquetDataPageVersionInput() {
    return this._parquetDataPageVersion;
  }

  // parquet_page_size - computed: true, optional: true, required: false
  private _parquetPageSize?: string; 
  public get parquetPageSize() {
    return this.getStringAttribute('parquet_page_size');
  }
  public set parquetPageSize(value: string) {
    this._parquetPageSize = value;
  }
  public resetParquetPageSize() {
    this._parquetPageSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get parquetPageSizeInput() {
    return this._parquetPageSize;
  }

  // parquet_row_group_length - computed: true, optional: true, required: false
  private _parquetRowGroupLength?: number; 
  public get parquetRowGroupLength() {
    return this.getNumberAttribute('parquet_row_group_length');
  }
  public set parquetRowGroupLength(value: number) {
    this._parquetRowGroupLength = value;
  }
  public resetParquetRowGroupLength() {
    this._parquetRowGroupLength = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get parquetRowGroupLengthInput() {
    return this._parquetRowGroupLength;
  }

  // parquet_version - computed: true, optional: true, required: false
  private _parquetVersion?: string; 
  public get parquetVersion() {
    return this.getStringAttribute('parquet_version');
  }
  public set parquetVersion(value: string) {
    this._parquetVersion = value;
  }
  public resetParquetVersion() {
    this._parquetVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get parquetVersionInput() {
    return this._parquetVersion;
  }

  // partition_expr - computed: true, optional: true, required: false
  private _partitionExpr?: string; 
  public get partitionExpr() {
    return this.getStringAttribute('partition_expr');
  }
  public set partitionExpr(value: string) {
    this._partitionExpr = value;
  }
  public resetPartitionExpr() {
    this._partitionExpr = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get partitionExprInput() {
    return this._partitionExpr;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // remove_empty_dirs - computed: true, optional: true, required: false
  private _removeEmptyDirs?: boolean | cdktf.IResolvable; 
  public get removeEmptyDirs() {
    return this.getBooleanAttribute('remove_empty_dirs');
  }
  public set removeEmptyDirs(value: boolean | cdktf.IResolvable) {
    this._removeEmptyDirs = value;
  }
  public resetRemoveEmptyDirs() {
    this._removeEmptyDirs = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get removeEmptyDirsInput() {
    return this._removeEmptyDirs;
  }

  // should_log_invalid_rows - computed: false, optional: true, required: false
  private _shouldLogInvalidRows?: boolean | cdktf.IResolvable; 
  public get shouldLogInvalidRows() {
    return this.getBooleanAttribute('should_log_invalid_rows');
  }
  public set shouldLogInvalidRows(value: boolean | cdktf.IResolvable) {
    this._shouldLogInvalidRows = value;
  }
  public resetShouldLogInvalidRows() {
    this._shouldLogInvalidRows = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get shouldLogInvalidRowsInput() {
    return this._shouldLogInvalidRows;
  }

  // stage_path - computed: false, optional: true, required: false
  private _stagePath?: string; 
  public get stagePath() {
    return this.getStringAttribute('stage_path');
  }
  public set stagePath(value: string) {
    this._stagePath = value;
  }
  public resetStagePath() {
    this._stagePath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get stagePathInput() {
    return this._stagePath;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // system_fields - computed: true, optional: true, required: false
  private _systemFields?: string[]; 
  public get systemFields() {
    return this.getListAttribute('system_fields');
  }
  public set systemFields(value: string[]) {
    this._systemFields = value;
  }
  public resetSystemFields() {
    this._systemFields = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get systemFieldsInput() {
    return this._systemFields;
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // write_high_water_mark - computed: true, optional: true, required: false
  private _writeHighWaterMark?: number; 
  public get writeHighWaterMark() {
    return this.getNumberAttribute('write_high_water_mark');
  }
  public set writeHighWaterMark(value: number) {
    this._writeHighWaterMark = value;
  }
  public resetWriteHighWaterMark() {
    this._writeHighWaterMark = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get writeHighWaterMarkInput() {
    return this._writeHighWaterMark;
  }
}
export interface PackDestinationOutputGoogleChronicleCustomLabels {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#key PackDestination#key}
  */
  readonly key: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#value PackDestination#value}
  */
  readonly value: string;
}

export function packDestinationOutputGoogleChronicleCustomLabelsToTerraform(struct?: PackDestinationOutputGoogleChronicleCustomLabels | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function packDestinationOutputGoogleChronicleCustomLabelsToHclTerraform(struct?: PackDestinationOutputGoogleChronicleCustomLabels | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputGoogleChronicleCustomLabelsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackDestinationOutputGoogleChronicleCustomLabels | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputGoogleChronicleCustomLabels | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._value = value.value;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class PackDestinationOutputGoogleChronicleCustomLabelsList extends cdktf.ComplexList {
  public internalValue? : PackDestinationOutputGoogleChronicleCustomLabels[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackDestinationOutputGoogleChronicleCustomLabelsOutputReference {
    return new PackDestinationOutputGoogleChronicleCustomLabelsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackDestinationOutputGoogleChronicleExtraHttpHeaders {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#name PackDestination#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#value PackDestination#value}
  */
  readonly value: string;
}

export function packDestinationOutputGoogleChronicleExtraHttpHeadersToTerraform(struct?: PackDestinationOutputGoogleChronicleExtraHttpHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function packDestinationOutputGoogleChronicleExtraHttpHeadersToHclTerraform(struct?: PackDestinationOutputGoogleChronicleExtraHttpHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputGoogleChronicleExtraHttpHeadersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackDestinationOutputGoogleChronicleExtraHttpHeaders | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputGoogleChronicleExtraHttpHeaders | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class PackDestinationOutputGoogleChronicleExtraHttpHeadersList extends cdktf.ComplexList {
  public internalValue? : PackDestinationOutputGoogleChronicleExtraHttpHeaders[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackDestinationOutputGoogleChronicleExtraHttpHeadersOutputReference {
    return new PackDestinationOutputGoogleChronicleExtraHttpHeadersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackDestinationOutputGoogleChronicleExtraLogTypes {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#description PackDestination#description}
  */
  readonly description?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#log_type PackDestination#log_type}
  */
  readonly logType: string;
}

export function packDestinationOutputGoogleChronicleExtraLogTypesToTerraform(struct?: PackDestinationOutputGoogleChronicleExtraLogTypes | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    description: cdktf.stringToTerraform(struct!.description),
    log_type: cdktf.stringToTerraform(struct!.logType),
  }
}


export function packDestinationOutputGoogleChronicleExtraLogTypesToHclTerraform(struct?: PackDestinationOutputGoogleChronicleExtraLogTypes | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    log_type: {
      value: cdktf.stringToHclTerraform(struct!.logType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputGoogleChronicleExtraLogTypesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackDestinationOutputGoogleChronicleExtraLogTypes | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._logType !== undefined) {
      hasAnyValues = true;
      internalValueResult.logType = this._logType;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputGoogleChronicleExtraLogTypes | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._description = undefined;
      this._logType = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._description = value.description;
      this._logType = value.logType;
    }
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // log_type - computed: false, optional: false, required: true
  private _logType?: string; 
  public get logType() {
    return this.getStringAttribute('log_type');
  }
  public set logType(value: string) {
    this._logType = value;
  }
  // Temporarily expose input value. Use with caution.
  public get logTypeInput() {
    return this._logType;
  }
}

export class PackDestinationOutputGoogleChronicleExtraLogTypesList extends cdktf.ComplexList {
  public internalValue? : PackDestinationOutputGoogleChronicleExtraLogTypes[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackDestinationOutputGoogleChronicleExtraLogTypesOutputReference {
    return new PackDestinationOutputGoogleChronicleExtraLogTypesOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackDestinationOutputGoogleChroniclePqControls {
}

export function packDestinationOutputGoogleChroniclePqControlsToTerraform(struct?: PackDestinationOutputGoogleChroniclePqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function packDestinationOutputGoogleChroniclePqControlsToHclTerraform(struct?: PackDestinationOutputGoogleChroniclePqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class PackDestinationOutputGoogleChroniclePqControlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackDestinationOutputGoogleChroniclePqControls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputGoogleChroniclePqControls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface PackDestinationOutputGoogleChronicleResponseRetrySettings {
  /**
  * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc. Default: 2
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#backoff_rate PackDestination#backoff_rate}
  */
  readonly backoffRate?: number;
  /**
  * The HTTP response status code that will trigger retries
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#http_status PackDestination#http_status}
  */
  readonly httpStatus: number;
  /**
  * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes). Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#initial_backoff PackDestination#initial_backoff}
  */
  readonly initialBackoff?: number;
  /**
  * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds). Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_backoff PackDestination#max_backoff}
  */
  readonly maxBackoff?: number;
}

export function packDestinationOutputGoogleChronicleResponseRetrySettingsToTerraform(struct?: PackDestinationOutputGoogleChronicleResponseRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    backoff_rate: cdktf.numberToTerraform(struct!.backoffRate),
    http_status: cdktf.numberToTerraform(struct!.httpStatus),
    initial_backoff: cdktf.numberToTerraform(struct!.initialBackoff),
    max_backoff: cdktf.numberToTerraform(struct!.maxBackoff),
  }
}


export function packDestinationOutputGoogleChronicleResponseRetrySettingsToHclTerraform(struct?: PackDestinationOutputGoogleChronicleResponseRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    backoff_rate: {
      value: cdktf.numberToHclTerraform(struct!.backoffRate),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    http_status: {
      value: cdktf.numberToHclTerraform(struct!.httpStatus),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    initial_backoff: {
      value: cdktf.numberToHclTerraform(struct!.initialBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_backoff: {
      value: cdktf.numberToHclTerraform(struct!.maxBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputGoogleChronicleResponseRetrySettingsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackDestinationOutputGoogleChronicleResponseRetrySettings | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._backoffRate !== undefined) {
      hasAnyValues = true;
      internalValueResult.backoffRate = this._backoffRate;
    }
    if (this._httpStatus !== undefined) {
      hasAnyValues = true;
      internalValueResult.httpStatus = this._httpStatus;
    }
    if (this._initialBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.initialBackoff = this._initialBackoff;
    }
    if (this._maxBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBackoff = this._maxBackoff;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputGoogleChronicleResponseRetrySettings | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._backoffRate = undefined;
      this._httpStatus = undefined;
      this._initialBackoff = undefined;
      this._maxBackoff = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._backoffRate = value.backoffRate;
      this._httpStatus = value.httpStatus;
      this._initialBackoff = value.initialBackoff;
      this._maxBackoff = value.maxBackoff;
    }
  }

  // backoff_rate - computed: true, optional: true, required: false
  private _backoffRate?: number; 
  public get backoffRate() {
    return this.getNumberAttribute('backoff_rate');
  }
  public set backoffRate(value: number) {
    this._backoffRate = value;
  }
  public resetBackoffRate() {
    this._backoffRate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get backoffRateInput() {
    return this._backoffRate;
  }

  // http_status - computed: false, optional: false, required: true
  private _httpStatus?: number; 
  public get httpStatus() {
    return this.getNumberAttribute('http_status');
  }
  public set httpStatus(value: number) {
    this._httpStatus = value;
  }
  // Temporarily expose input value. Use with caution.
  public get httpStatusInput() {
    return this._httpStatus;
  }

  // initial_backoff - computed: true, optional: true, required: false
  private _initialBackoff?: number; 
  public get initialBackoff() {
    return this.getNumberAttribute('initial_backoff');
  }
  public set initialBackoff(value: number) {
    this._initialBackoff = value;
  }
  public resetInitialBackoff() {
    this._initialBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get initialBackoffInput() {
    return this._initialBackoff;
  }

  // max_backoff - computed: true, optional: true, required: false
  private _maxBackoff?: number; 
  public get maxBackoff() {
    return this.getNumberAttribute('max_backoff');
  }
  public set maxBackoff(value: number) {
    this._maxBackoff = value;
  }
  public resetMaxBackoff() {
    this._maxBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBackoffInput() {
    return this._maxBackoff;
  }
}

export class PackDestinationOutputGoogleChronicleResponseRetrySettingsList extends cdktf.ComplexList {
  public internalValue? : PackDestinationOutputGoogleChronicleResponseRetrySettings[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackDestinationOutputGoogleChronicleResponseRetrySettingsOutputReference {
    return new PackDestinationOutputGoogleChronicleResponseRetrySettingsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackDestinationOutputGoogleChronicleTimeoutRetrySettings {
  /**
  * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc. Default: 2
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#backoff_rate PackDestination#backoff_rate}
  */
  readonly backoffRate?: number;
  /**
  * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes). Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#initial_backoff PackDestination#initial_backoff}
  */
  readonly initialBackoff?: number;
  /**
  * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds). Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_backoff PackDestination#max_backoff}
  */
  readonly maxBackoff?: number;
  /**
  * Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#timeout_retry PackDestination#timeout_retry}
  */
  readonly timeoutRetry?: boolean | cdktf.IResolvable;
}

export function packDestinationOutputGoogleChronicleTimeoutRetrySettingsToTerraform(struct?: PackDestinationOutputGoogleChronicleTimeoutRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    backoff_rate: cdktf.numberToTerraform(struct!.backoffRate),
    initial_backoff: cdktf.numberToTerraform(struct!.initialBackoff),
    max_backoff: cdktf.numberToTerraform(struct!.maxBackoff),
    timeout_retry: cdktf.booleanToTerraform(struct!.timeoutRetry),
  }
}


export function packDestinationOutputGoogleChronicleTimeoutRetrySettingsToHclTerraform(struct?: PackDestinationOutputGoogleChronicleTimeoutRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    backoff_rate: {
      value: cdktf.numberToHclTerraform(struct!.backoffRate),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    initial_backoff: {
      value: cdktf.numberToHclTerraform(struct!.initialBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_backoff: {
      value: cdktf.numberToHclTerraform(struct!.maxBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    timeout_retry: {
      value: cdktf.booleanToHclTerraform(struct!.timeoutRetry),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputGoogleChronicleTimeoutRetrySettingsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackDestinationOutputGoogleChronicleTimeoutRetrySettings | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._backoffRate !== undefined) {
      hasAnyValues = true;
      internalValueResult.backoffRate = this._backoffRate;
    }
    if (this._initialBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.initialBackoff = this._initialBackoff;
    }
    if (this._maxBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBackoff = this._maxBackoff;
    }
    if (this._timeoutRetry !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutRetry = this._timeoutRetry;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputGoogleChronicleTimeoutRetrySettings | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._backoffRate = undefined;
      this._initialBackoff = undefined;
      this._maxBackoff = undefined;
      this._timeoutRetry = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._backoffRate = value.backoffRate;
      this._initialBackoff = value.initialBackoff;
      this._maxBackoff = value.maxBackoff;
      this._timeoutRetry = value.timeoutRetry;
    }
  }

  // backoff_rate - computed: true, optional: true, required: false
  private _backoffRate?: number; 
  public get backoffRate() {
    return this.getNumberAttribute('backoff_rate');
  }
  public set backoffRate(value: number) {
    this._backoffRate = value;
  }
  public resetBackoffRate() {
    this._backoffRate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get backoffRateInput() {
    return this._backoffRate;
  }

  // initial_backoff - computed: true, optional: true, required: false
  private _initialBackoff?: number; 
  public get initialBackoff() {
    return this.getNumberAttribute('initial_backoff');
  }
  public set initialBackoff(value: number) {
    this._initialBackoff = value;
  }
  public resetInitialBackoff() {
    this._initialBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get initialBackoffInput() {
    return this._initialBackoff;
  }

  // max_backoff - computed: true, optional: true, required: false
  private _maxBackoff?: number; 
  public get maxBackoff() {
    return this.getNumberAttribute('max_backoff');
  }
  public set maxBackoff(value: number) {
    this._maxBackoff = value;
  }
  public resetMaxBackoff() {
    this._maxBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBackoffInput() {
    return this._maxBackoff;
  }

  // timeout_retry - computed: true, optional: true, required: false
  private _timeoutRetry?: boolean | cdktf.IResolvable; 
  public get timeoutRetry() {
    return this.getBooleanAttribute('timeout_retry');
  }
  public set timeoutRetry(value: boolean | cdktf.IResolvable) {
    this._timeoutRetry = value;
  }
  public resetTimeoutRetry() {
    this._timeoutRetry = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutRetryInput() {
    return this._timeoutRetry;
  }
}
export interface PackDestinationOutputGoogleChronicle {
  /**
  * Organization's API key in Google SecOps
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#api_key PackDestination#api_key}
  */
  readonly apiKey?: string;
  /**
  * Select or create a stored text secret
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#api_key_secret PackDestination#api_key_secret}
  */
  readonly apiKeySecret?: string;
  /**
  * Default: "v1"; must be one of ["v1", "v2"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#api_version PackDestination#api_version}
  */
  readonly apiVersion?: string;
  /**
  * Default: "serviceAccount"; must be one of ["manual", "secret", "serviceAccount", "serviceAccountSecret"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#authentication_method PackDestination#authentication_method}
  */
  readonly authenticationMethod?: string;
  /**
  * Compress the payload body before sending. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#compress PackDestination#compress}
  */
  readonly compress?: boolean | cdktf.IResolvable;
  /**
  * Maximum number of ongoing requests before blocking. Default: 5
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#concurrency PackDestination#concurrency}
  */
  readonly concurrency?: number;
  /**
  * Custom labels to be added to every batch
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#custom_labels PackDestination#custom_labels}
  */
  readonly customLabels?: PackDestinationOutputGoogleChronicleCustomLabels[] | cdktf.IResolvable;
  /**
  * Unique identifier (UUID) corresponding to a particular SecOps instance. Provided by your SecOps representative.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#customer_id PackDestination#customer_id}
  */
  readonly customerId?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#description PackDestination#description}
  */
  readonly description?: string;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#environment PackDestination#environment}
  */
  readonly environment?: string;
  /**
  * Headers to add to all events
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#extra_http_headers PackDestination#extra_http_headers}
  */
  readonly extraHttpHeaders?: PackDestinationOutputGoogleChronicleExtraHttpHeaders[] | cdktf.IResolvable;
  /**
  * Custom log types. If the value "Custom" is selected in the setting "Default log type" above, the first custom log type in this table will be automatically selected as default log type.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#extra_log_types PackDestination#extra_log_types}
  */
  readonly extraLogTypes?: PackDestinationOutputGoogleChronicleExtraLogTypes[] | cdktf.IResolvable;
  /**
  * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below. Default: "none"; must be one of ["payload", "payloadAndHeaders", "none"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#failed_request_logging_mode PackDestination#failed_request_logging_mode}
  */
  readonly failedRequestLoggingMode?: string;
  /**
  * Maximum time between requests. Small values could cause the payload size to be smaller than the configured Body size limit. Default: 1
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#flush_period_sec PackDestination#flush_period_sec}
  */
  readonly flushPeriodSec?: number;
  /**
  * Unique ID for this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#id PackDestination#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * Default: "unstructured"; must be one of ["unstructured", "udm"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#log_format_type PackDestination#log_format_type}
  */
  readonly logFormatType?: string;
  /**
  * Name of the event field that contains the log text to send. If not specified, Stream sends a JSON representation of the whole event.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#log_text_field PackDestination#log_text_field}
  */
  readonly logTextField?: string;
  /**
  * Default log type value to send to SecOps. Can be overwritten by event field __logType.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#log_type PackDestination#log_type}
  */
  readonly logType?: string;
  /**
  * Maximum number of events to include in the request body. Default is 0 (unlimited). Default: 0
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_payload_events PackDestination#max_payload_events}
  */
  readonly maxPayloadEvents?: number;
  /**
  * Maximum size, in KB, of the request body. Default: 1024
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_payload_size_kb PackDestination#max_payload_size_kb}
  */
  readonly maxPayloadSizeKb?: number;
  /**
  * User-configured environment namespace to identify the data domain the logs originated from. Use namespace as a tag to identify the appropriate data domain for indexing and enrichment functionality. Can be overwritten by event field __namespace.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#namespace PackDestination#namespace}
  */
  readonly namespace?: string;
  /**
  * How to handle events when all receivers are exerting backpressure. Default: "block"; must be one of ["block", "drop", "queue"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#on_backpressure PackDestination#on_backpressure}
  */
  readonly onBackpressure?: string;
  /**
  * Pipeline to process data before sending out to this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pipeline PackDestination#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_compress PackDestination#pq_compress}
  */
  readonly pqCompress?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_controls PackDestination#pq_controls}
  */
  readonly pqControls?: PackDestinationOutputGoogleChroniclePqControls;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.). Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_max_file_size PackDestination#pq_max_file_size}
  */
  readonly pqMaxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_max_size PackDestination#pq_max_size}
  */
  readonly pqMaxSize?: string;
  /**
  * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem. Default: "error"; must be one of ["error", "backpressure", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_mode PackDestination#pq_mode}
  */
  readonly pqMode?: string;
  /**
  * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged. Default: "block"; must be one of ["block", "drop"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_on_backpressure PackDestination#pq_on_backpressure}
  */
  readonly pqOnBackpressure?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_path PackDestination#pq_path}
  */
  readonly pqPath?: string;
  /**
  * Regional endpoint to send events to
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#region PackDestination#region}
  */
  readonly region?: string;
  /**
  * Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's). 
  *         Enabled by default. When this setting is also present in TLS Settings (Client Side), 
  *         that value will take precedence.
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#reject_unauthorized PackDestination#reject_unauthorized}
  */
  readonly rejectUnauthorized?: boolean | cdktf.IResolvable;
  /**
  * Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#response_honor_retry_after_header PackDestination#response_honor_retry_after_header}
  */
  readonly responseHonorRetryAfterHeader?: boolean | cdktf.IResolvable;
  /**
  * Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#response_retry_settings PackDestination#response_retry_settings}
  */
  readonly responseRetrySettings?: PackDestinationOutputGoogleChronicleResponseRetrySettings[] | cdktf.IResolvable;
  /**
  * List of headers that are safe to log in plain text. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#safe_headers PackDestination#safe_headers}
  */
  readonly safeHeaders?: string[];
  /**
  * Contents of service account credentials (JSON keys) file downloaded from Google Cloud. To upload a file, click the upload button at this field's upper right.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#service_account_credentials PackDestination#service_account_credentials}
  */
  readonly serviceAccountCredentials?: string;
  /**
  * Select or create a stored text secret
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#service_account_credentials_secret PackDestination#service_account_credentials_secret}
  */
  readonly serviceAccountCredentialsSecret?: string;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#streamtags PackDestination#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Fields to automatically add to events, such as cribl_pipe. Supports wildcards. Default: ["cribl_pipe"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#system_fields PackDestination#system_fields}
  */
  readonly systemFields?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#timeout_retry_settings PackDestination#timeout_retry_settings}
  */
  readonly timeoutRetrySettings?: PackDestinationOutputGoogleChronicleTimeoutRetrySettings;
  /**
  * Amount of time, in seconds, to wait for a request to complete before canceling it. Default: 90
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#timeout_sec PackDestination#timeout_sec}
  */
  readonly timeoutSec?: number;
  /**
  * Maximum total size of the batches waiting to be sent. If left blank, defaults to 5 times the max body size (if set). If 0, no limit is enforced.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#total_memory_limit_kb PackDestination#total_memory_limit_kb}
  */
  readonly totalMemoryLimitKb?: number;
  /**
  * must be "google_chronicle"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#type PackDestination#type}
  */
  readonly type: string;
  /**
  * Enable round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#use_round_robin_dns PackDestination#use_round_robin_dns}
  */
  readonly useRoundRobinDns?: boolean | cdktf.IResolvable;
}

export function packDestinationOutputGoogleChronicleToTerraform(struct?: PackDestinationOutputGoogleChronicle | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    api_key: cdktf.stringToTerraform(struct!.apiKey),
    api_key_secret: cdktf.stringToTerraform(struct!.apiKeySecret),
    api_version: cdktf.stringToTerraform(struct!.apiVersion),
    authentication_method: cdktf.stringToTerraform(struct!.authenticationMethod),
    compress: cdktf.booleanToTerraform(struct!.compress),
    concurrency: cdktf.numberToTerraform(struct!.concurrency),
    custom_labels: cdktf.listMapper(packDestinationOutputGoogleChronicleCustomLabelsToTerraform, false)(struct!.customLabels),
    customer_id: cdktf.stringToTerraform(struct!.customerId),
    description: cdktf.stringToTerraform(struct!.description),
    environment: cdktf.stringToTerraform(struct!.environment),
    extra_http_headers: cdktf.listMapper(packDestinationOutputGoogleChronicleExtraHttpHeadersToTerraform, false)(struct!.extraHttpHeaders),
    extra_log_types: cdktf.listMapper(packDestinationOutputGoogleChronicleExtraLogTypesToTerraform, false)(struct!.extraLogTypes),
    failed_request_logging_mode: cdktf.stringToTerraform(struct!.failedRequestLoggingMode),
    flush_period_sec: cdktf.numberToTerraform(struct!.flushPeriodSec),
    id: cdktf.stringToTerraform(struct!.id),
    log_format_type: cdktf.stringToTerraform(struct!.logFormatType),
    log_text_field: cdktf.stringToTerraform(struct!.logTextField),
    log_type: cdktf.stringToTerraform(struct!.logType),
    max_payload_events: cdktf.numberToTerraform(struct!.maxPayloadEvents),
    max_payload_size_kb: cdktf.numberToTerraform(struct!.maxPayloadSizeKb),
    namespace: cdktf.stringToTerraform(struct!.namespace),
    on_backpressure: cdktf.stringToTerraform(struct!.onBackpressure),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    pq_compress: cdktf.stringToTerraform(struct!.pqCompress),
    pq_controls: packDestinationOutputGoogleChroniclePqControlsToTerraform(struct!.pqControls),
    pq_max_file_size: cdktf.stringToTerraform(struct!.pqMaxFileSize),
    pq_max_size: cdktf.stringToTerraform(struct!.pqMaxSize),
    pq_mode: cdktf.stringToTerraform(struct!.pqMode),
    pq_on_backpressure: cdktf.stringToTerraform(struct!.pqOnBackpressure),
    pq_path: cdktf.stringToTerraform(struct!.pqPath),
    region: cdktf.stringToTerraform(struct!.region),
    reject_unauthorized: cdktf.booleanToTerraform(struct!.rejectUnauthorized),
    response_honor_retry_after_header: cdktf.booleanToTerraform(struct!.responseHonorRetryAfterHeader),
    response_retry_settings: cdktf.listMapper(packDestinationOutputGoogleChronicleResponseRetrySettingsToTerraform, false)(struct!.responseRetrySettings),
    safe_headers: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.safeHeaders),
    service_account_credentials: cdktf.stringToTerraform(struct!.serviceAccountCredentials),
    service_account_credentials_secret: cdktf.stringToTerraform(struct!.serviceAccountCredentialsSecret),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    system_fields: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.systemFields),
    timeout_retry_settings: packDestinationOutputGoogleChronicleTimeoutRetrySettingsToTerraform(struct!.timeoutRetrySettings),
    timeout_sec: cdktf.numberToTerraform(struct!.timeoutSec),
    total_memory_limit_kb: cdktf.numberToTerraform(struct!.totalMemoryLimitKb),
    type: cdktf.stringToTerraform(struct!.type),
    use_round_robin_dns: cdktf.booleanToTerraform(struct!.useRoundRobinDns),
  }
}


export function packDestinationOutputGoogleChronicleToHclTerraform(struct?: PackDestinationOutputGoogleChronicle | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    api_key: {
      value: cdktf.stringToHclTerraform(struct!.apiKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    api_key_secret: {
      value: cdktf.stringToHclTerraform(struct!.apiKeySecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    api_version: {
      value: cdktf.stringToHclTerraform(struct!.apiVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    authentication_method: {
      value: cdktf.stringToHclTerraform(struct!.authenticationMethod),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    compress: {
      value: cdktf.booleanToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    concurrency: {
      value: cdktf.numberToHclTerraform(struct!.concurrency),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    custom_labels: {
      value: cdktf.listMapperHcl(packDestinationOutputGoogleChronicleCustomLabelsToHclTerraform, false)(struct!.customLabels),
      isBlock: true,
      type: "list",
      storageClassType: "PackDestinationOutputGoogleChronicleCustomLabelsList",
    },
    customer_id: {
      value: cdktf.stringToHclTerraform(struct!.customerId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    extra_http_headers: {
      value: cdktf.listMapperHcl(packDestinationOutputGoogleChronicleExtraHttpHeadersToHclTerraform, false)(struct!.extraHttpHeaders),
      isBlock: true,
      type: "list",
      storageClassType: "PackDestinationOutputGoogleChronicleExtraHttpHeadersList",
    },
    extra_log_types: {
      value: cdktf.listMapperHcl(packDestinationOutputGoogleChronicleExtraLogTypesToHclTerraform, false)(struct!.extraLogTypes),
      isBlock: true,
      type: "list",
      storageClassType: "PackDestinationOutputGoogleChronicleExtraLogTypesList",
    },
    failed_request_logging_mode: {
      value: cdktf.stringToHclTerraform(struct!.failedRequestLoggingMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    flush_period_sec: {
      value: cdktf.numberToHclTerraform(struct!.flushPeriodSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    log_format_type: {
      value: cdktf.stringToHclTerraform(struct!.logFormatType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    log_text_field: {
      value: cdktf.stringToHclTerraform(struct!.logTextField),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    log_type: {
      value: cdktf.stringToHclTerraform(struct!.logType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_payload_events: {
      value: cdktf.numberToHclTerraform(struct!.maxPayloadEvents),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_payload_size_kb: {
      value: cdktf.numberToHclTerraform(struct!.maxPayloadSizeKb),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.onBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_compress: {
      value: cdktf.stringToHclTerraform(struct!.pqCompress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_controls: {
      value: packDestinationOutputGoogleChroniclePqControlsToHclTerraform(struct!.pqControls),
      isBlock: true,
      type: "struct",
      storageClassType: "PackDestinationOutputGoogleChroniclePqControls",
    },
    pq_max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_max_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_mode: {
      value: cdktf.stringToHclTerraform(struct!.pqMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.pqOnBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_path: {
      value: cdktf.stringToHclTerraform(struct!.pqPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    region: {
      value: cdktf.stringToHclTerraform(struct!.region),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reject_unauthorized: {
      value: cdktf.booleanToHclTerraform(struct!.rejectUnauthorized),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    response_honor_retry_after_header: {
      value: cdktf.booleanToHclTerraform(struct!.responseHonorRetryAfterHeader),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    response_retry_settings: {
      value: cdktf.listMapperHcl(packDestinationOutputGoogleChronicleResponseRetrySettingsToHclTerraform, false)(struct!.responseRetrySettings),
      isBlock: true,
      type: "list",
      storageClassType: "PackDestinationOutputGoogleChronicleResponseRetrySettingsList",
    },
    safe_headers: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.safeHeaders),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    service_account_credentials: {
      value: cdktf.stringToHclTerraform(struct!.serviceAccountCredentials),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    service_account_credentials_secret: {
      value: cdktf.stringToHclTerraform(struct!.serviceAccountCredentialsSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    system_fields: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.systemFields),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    timeout_retry_settings: {
      value: packDestinationOutputGoogleChronicleTimeoutRetrySettingsToHclTerraform(struct!.timeoutRetrySettings),
      isBlock: true,
      type: "struct",
      storageClassType: "PackDestinationOutputGoogleChronicleTimeoutRetrySettings",
    },
    timeout_sec: {
      value: cdktf.numberToHclTerraform(struct!.timeoutSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    total_memory_limit_kb: {
      value: cdktf.numberToHclTerraform(struct!.totalMemoryLimitKb),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    use_round_robin_dns: {
      value: cdktf.booleanToHclTerraform(struct!.useRoundRobinDns),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputGoogleChronicleOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackDestinationOutputGoogleChronicle | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._apiKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.apiKey = this._apiKey;
    }
    if (this._apiKeySecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.apiKeySecret = this._apiKeySecret;
    }
    if (this._apiVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.apiVersion = this._apiVersion;
    }
    if (this._authenticationMethod !== undefined) {
      hasAnyValues = true;
      internalValueResult.authenticationMethod = this._authenticationMethod;
    }
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._concurrency !== undefined) {
      hasAnyValues = true;
      internalValueResult.concurrency = this._concurrency;
    }
    if (this._customLabels?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.customLabels = this._customLabels?.internalValue;
    }
    if (this._customerId !== undefined) {
      hasAnyValues = true;
      internalValueResult.customerId = this._customerId;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._extraHttpHeaders?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.extraHttpHeaders = this._extraHttpHeaders?.internalValue;
    }
    if (this._extraLogTypes?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.extraLogTypes = this._extraLogTypes?.internalValue;
    }
    if (this._failedRequestLoggingMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.failedRequestLoggingMode = this._failedRequestLoggingMode;
    }
    if (this._flushPeriodSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.flushPeriodSec = this._flushPeriodSec;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._logFormatType !== undefined) {
      hasAnyValues = true;
      internalValueResult.logFormatType = this._logFormatType;
    }
    if (this._logTextField !== undefined) {
      hasAnyValues = true;
      internalValueResult.logTextField = this._logTextField;
    }
    if (this._logType !== undefined) {
      hasAnyValues = true;
      internalValueResult.logType = this._logType;
    }
    if (this._maxPayloadEvents !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxPayloadEvents = this._maxPayloadEvents;
    }
    if (this._maxPayloadSizeKb !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxPayloadSizeKb = this._maxPayloadSizeKb;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    if (this._onBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.onBackpressure = this._onBackpressure;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._pqCompress !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqCompress = this._pqCompress;
    }
    if (this._pqControls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqControls = this._pqControls?.internalValue;
    }
    if (this._pqMaxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxFileSize = this._pqMaxFileSize;
    }
    if (this._pqMaxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxSize = this._pqMaxSize;
    }
    if (this._pqMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMode = this._pqMode;
    }
    if (this._pqOnBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqOnBackpressure = this._pqOnBackpressure;
    }
    if (this._pqPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqPath = this._pqPath;
    }
    if (this._region !== undefined) {
      hasAnyValues = true;
      internalValueResult.region = this._region;
    }
    if (this._rejectUnauthorized !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectUnauthorized = this._rejectUnauthorized;
    }
    if (this._responseHonorRetryAfterHeader !== undefined) {
      hasAnyValues = true;
      internalValueResult.responseHonorRetryAfterHeader = this._responseHonorRetryAfterHeader;
    }
    if (this._responseRetrySettings?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.responseRetrySettings = this._responseRetrySettings?.internalValue;
    }
    if (this._safeHeaders !== undefined) {
      hasAnyValues = true;
      internalValueResult.safeHeaders = this._safeHeaders;
    }
    if (this._serviceAccountCredentials !== undefined) {
      hasAnyValues = true;
      internalValueResult.serviceAccountCredentials = this._serviceAccountCredentials;
    }
    if (this._serviceAccountCredentialsSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.serviceAccountCredentialsSecret = this._serviceAccountCredentialsSecret;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._systemFields !== undefined) {
      hasAnyValues = true;
      internalValueResult.systemFields = this._systemFields;
    }
    if (this._timeoutRetrySettings?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutRetrySettings = this._timeoutRetrySettings?.internalValue;
    }
    if (this._timeoutSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutSec = this._timeoutSec;
    }
    if (this._totalMemoryLimitKb !== undefined) {
      hasAnyValues = true;
      internalValueResult.totalMemoryLimitKb = this._totalMemoryLimitKb;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._useRoundRobinDns !== undefined) {
      hasAnyValues = true;
      internalValueResult.useRoundRobinDns = this._useRoundRobinDns;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputGoogleChronicle | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._apiKey = undefined;
      this._apiKeySecret = undefined;
      this._apiVersion = undefined;
      this._authenticationMethod = undefined;
      this._compress = undefined;
      this._concurrency = undefined;
      this._customLabels.internalValue = undefined;
      this._customerId = undefined;
      this._description = undefined;
      this._environment = undefined;
      this._extraHttpHeaders.internalValue = undefined;
      this._extraLogTypes.internalValue = undefined;
      this._failedRequestLoggingMode = undefined;
      this._flushPeriodSec = undefined;
      this._id = undefined;
      this._logFormatType = undefined;
      this._logTextField = undefined;
      this._logType = undefined;
      this._maxPayloadEvents = undefined;
      this._maxPayloadSizeKb = undefined;
      this._namespace = undefined;
      this._onBackpressure = undefined;
      this._pipeline = undefined;
      this._pqCompress = undefined;
      this._pqControls.internalValue = undefined;
      this._pqMaxFileSize = undefined;
      this._pqMaxSize = undefined;
      this._pqMode = undefined;
      this._pqOnBackpressure = undefined;
      this._pqPath = undefined;
      this._region = undefined;
      this._rejectUnauthorized = undefined;
      this._responseHonorRetryAfterHeader = undefined;
      this._responseRetrySettings.internalValue = undefined;
      this._safeHeaders = undefined;
      this._serviceAccountCredentials = undefined;
      this._serviceAccountCredentialsSecret = undefined;
      this._streamtags = undefined;
      this._systemFields = undefined;
      this._timeoutRetrySettings.internalValue = undefined;
      this._timeoutSec = undefined;
      this._totalMemoryLimitKb = undefined;
      this._type = undefined;
      this._useRoundRobinDns = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._apiKey = value.apiKey;
      this._apiKeySecret = value.apiKeySecret;
      this._apiVersion = value.apiVersion;
      this._authenticationMethod = value.authenticationMethod;
      this._compress = value.compress;
      this._concurrency = value.concurrency;
      this._customLabels.internalValue = value.customLabels;
      this._customerId = value.customerId;
      this._description = value.description;
      this._environment = value.environment;
      this._extraHttpHeaders.internalValue = value.extraHttpHeaders;
      this._extraLogTypes.internalValue = value.extraLogTypes;
      this._failedRequestLoggingMode = value.failedRequestLoggingMode;
      this._flushPeriodSec = value.flushPeriodSec;
      this._id = value.id;
      this._logFormatType = value.logFormatType;
      this._logTextField = value.logTextField;
      this._logType = value.logType;
      this._maxPayloadEvents = value.maxPayloadEvents;
      this._maxPayloadSizeKb = value.maxPayloadSizeKb;
      this._namespace = value.namespace;
      this._onBackpressure = value.onBackpressure;
      this._pipeline = value.pipeline;
      this._pqCompress = value.pqCompress;
      this._pqControls.internalValue = value.pqControls;
      this._pqMaxFileSize = value.pqMaxFileSize;
      this._pqMaxSize = value.pqMaxSize;
      this._pqMode = value.pqMode;
      this._pqOnBackpressure = value.pqOnBackpressure;
      this._pqPath = value.pqPath;
      this._region = value.region;
      this._rejectUnauthorized = value.rejectUnauthorized;
      this._responseHonorRetryAfterHeader = value.responseHonorRetryAfterHeader;
      this._responseRetrySettings.internalValue = value.responseRetrySettings;
      this._safeHeaders = value.safeHeaders;
      this._serviceAccountCredentials = value.serviceAccountCredentials;
      this._serviceAccountCredentialsSecret = value.serviceAccountCredentialsSecret;
      this._streamtags = value.streamtags;
      this._systemFields = value.systemFields;
      this._timeoutRetrySettings.internalValue = value.timeoutRetrySettings;
      this._timeoutSec = value.timeoutSec;
      this._totalMemoryLimitKb = value.totalMemoryLimitKb;
      this._type = value.type;
      this._useRoundRobinDns = value.useRoundRobinDns;
    }
  }

  // api_key - computed: false, optional: true, required: false
  private _apiKey?: string; 
  public get apiKey() {
    return this.getStringAttribute('api_key');
  }
  public set apiKey(value: string) {
    this._apiKey = value;
  }
  public resetApiKey() {
    this._apiKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get apiKeyInput() {
    return this._apiKey;
  }

  // api_key_secret - computed: false, optional: true, required: false
  private _apiKeySecret?: string; 
  public get apiKeySecret() {
    return this.getStringAttribute('api_key_secret');
  }
  public set apiKeySecret(value: string) {
    this._apiKeySecret = value;
  }
  public resetApiKeySecret() {
    this._apiKeySecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get apiKeySecretInput() {
    return this._apiKeySecret;
  }

  // api_version - computed: true, optional: true, required: false
  private _apiVersion?: string; 
  public get apiVersion() {
    return this.getStringAttribute('api_version');
  }
  public set apiVersion(value: string) {
    this._apiVersion = value;
  }
  public resetApiVersion() {
    this._apiVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get apiVersionInput() {
    return this._apiVersion;
  }

  // authentication_method - computed: true, optional: true, required: false
  private _authenticationMethod?: string; 
  public get authenticationMethod() {
    return this.getStringAttribute('authentication_method');
  }
  public set authenticationMethod(value: string) {
    this._authenticationMethod = value;
  }
  public resetAuthenticationMethod() {
    this._authenticationMethod = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authenticationMethodInput() {
    return this._authenticationMethod;
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: boolean | cdktf.IResolvable; 
  public get compress() {
    return this.getBooleanAttribute('compress');
  }
  public set compress(value: boolean | cdktf.IResolvable) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // concurrency - computed: true, optional: true, required: false
  private _concurrency?: number; 
  public get concurrency() {
    return this.getNumberAttribute('concurrency');
  }
  public set concurrency(value: number) {
    this._concurrency = value;
  }
  public resetConcurrency() {
    this._concurrency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get concurrencyInput() {
    return this._concurrency;
  }

  // custom_labels - computed: false, optional: true, required: false
  private _customLabels = new PackDestinationOutputGoogleChronicleCustomLabelsList(this, "custom_labels", false);
  public get customLabels() {
    return this._customLabels;
  }
  public putCustomLabels(value: PackDestinationOutputGoogleChronicleCustomLabels[] | cdktf.IResolvable) {
    this._customLabels.internalValue = value;
  }
  public resetCustomLabels() {
    this._customLabels.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get customLabelsInput() {
    return this._customLabels.internalValue;
  }

  // customer_id - computed: false, optional: true, required: false
  private _customerId?: string; 
  public get customerId() {
    return this.getStringAttribute('customer_id');
  }
  public set customerId(value: string) {
    this._customerId = value;
  }
  public resetCustomerId() {
    this._customerId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get customerIdInput() {
    return this._customerId;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // extra_http_headers - computed: false, optional: true, required: false
  private _extraHttpHeaders = new PackDestinationOutputGoogleChronicleExtraHttpHeadersList(this, "extra_http_headers", false);
  public get extraHttpHeaders() {
    return this._extraHttpHeaders;
  }
  public putExtraHttpHeaders(value: PackDestinationOutputGoogleChronicleExtraHttpHeaders[] | cdktf.IResolvable) {
    this._extraHttpHeaders.internalValue = value;
  }
  public resetExtraHttpHeaders() {
    this._extraHttpHeaders.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get extraHttpHeadersInput() {
    return this._extraHttpHeaders.internalValue;
  }

  // extra_log_types - computed: false, optional: true, required: false
  private _extraLogTypes = new PackDestinationOutputGoogleChronicleExtraLogTypesList(this, "extra_log_types", false);
  public get extraLogTypes() {
    return this._extraLogTypes;
  }
  public putExtraLogTypes(value: PackDestinationOutputGoogleChronicleExtraLogTypes[] | cdktf.IResolvable) {
    this._extraLogTypes.internalValue = value;
  }
  public resetExtraLogTypes() {
    this._extraLogTypes.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get extraLogTypesInput() {
    return this._extraLogTypes.internalValue;
  }

  // failed_request_logging_mode - computed: true, optional: true, required: false
  private _failedRequestLoggingMode?: string; 
  public get failedRequestLoggingMode() {
    return this.getStringAttribute('failed_request_logging_mode');
  }
  public set failedRequestLoggingMode(value: string) {
    this._failedRequestLoggingMode = value;
  }
  public resetFailedRequestLoggingMode() {
    this._failedRequestLoggingMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get failedRequestLoggingModeInput() {
    return this._failedRequestLoggingMode;
  }

  // flush_period_sec - computed: true, optional: true, required: false
  private _flushPeriodSec?: number; 
  public get flushPeriodSec() {
    return this.getNumberAttribute('flush_period_sec');
  }
  public set flushPeriodSec(value: number) {
    this._flushPeriodSec = value;
  }
  public resetFlushPeriodSec() {
    this._flushPeriodSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get flushPeriodSecInput() {
    return this._flushPeriodSec;
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // log_format_type - computed: true, optional: true, required: false
  private _logFormatType?: string; 
  public get logFormatType() {
    return this.getStringAttribute('log_format_type');
  }
  public set logFormatType(value: string) {
    this._logFormatType = value;
  }
  public resetLogFormatType() {
    this._logFormatType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get logFormatTypeInput() {
    return this._logFormatType;
  }

  // log_text_field - computed: false, optional: true, required: false
  private _logTextField?: string; 
  public get logTextField() {
    return this.getStringAttribute('log_text_field');
  }
  public set logTextField(value: string) {
    this._logTextField = value;
  }
  public resetLogTextField() {
    this._logTextField = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get logTextFieldInput() {
    return this._logTextField;
  }

  // log_type - computed: false, optional: true, required: false
  private _logType?: string; 
  public get logType() {
    return this.getStringAttribute('log_type');
  }
  public set logType(value: string) {
    this._logType = value;
  }
  public resetLogType() {
    this._logType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get logTypeInput() {
    return this._logType;
  }

  // max_payload_events - computed: true, optional: true, required: false
  private _maxPayloadEvents?: number; 
  public get maxPayloadEvents() {
    return this.getNumberAttribute('max_payload_events');
  }
  public set maxPayloadEvents(value: number) {
    this._maxPayloadEvents = value;
  }
  public resetMaxPayloadEvents() {
    this._maxPayloadEvents = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxPayloadEventsInput() {
    return this._maxPayloadEvents;
  }

  // max_payload_size_kb - computed: true, optional: true, required: false
  private _maxPayloadSizeKb?: number; 
  public get maxPayloadSizeKb() {
    return this.getNumberAttribute('max_payload_size_kb');
  }
  public set maxPayloadSizeKb(value: number) {
    this._maxPayloadSizeKb = value;
  }
  public resetMaxPayloadSizeKb() {
    this._maxPayloadSizeKb = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxPayloadSizeKbInput() {
    return this._maxPayloadSizeKb;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }

  // on_backpressure - computed: true, optional: true, required: false
  private _onBackpressure?: string; 
  public get onBackpressure() {
    return this.getStringAttribute('on_backpressure');
  }
  public set onBackpressure(value: string) {
    this._onBackpressure = value;
  }
  public resetOnBackpressure() {
    this._onBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get onBackpressureInput() {
    return this._onBackpressure;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // pq_compress - computed: true, optional: true, required: false
  private _pqCompress?: string; 
  public get pqCompress() {
    return this.getStringAttribute('pq_compress');
  }
  public set pqCompress(value: string) {
    this._pqCompress = value;
  }
  public resetPqCompress() {
    this._pqCompress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqCompressInput() {
    return this._pqCompress;
  }

  // pq_controls - computed: false, optional: true, required: false
  private _pqControls = new PackDestinationOutputGoogleChroniclePqControlsOutputReference(this, "pq_controls");
  public get pqControls() {
    return this._pqControls;
  }
  public putPqControls(value: PackDestinationOutputGoogleChroniclePqControls) {
    this._pqControls.internalValue = value;
  }
  public resetPqControls() {
    this._pqControls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqControlsInput() {
    return this._pqControls.internalValue;
  }

  // pq_max_file_size - computed: true, optional: true, required: false
  private _pqMaxFileSize?: string; 
  public get pqMaxFileSize() {
    return this.getStringAttribute('pq_max_file_size');
  }
  public set pqMaxFileSize(value: string) {
    this._pqMaxFileSize = value;
  }
  public resetPqMaxFileSize() {
    this._pqMaxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxFileSizeInput() {
    return this._pqMaxFileSize;
  }

  // pq_max_size - computed: true, optional: true, required: false
  private _pqMaxSize?: string; 
  public get pqMaxSize() {
    return this.getStringAttribute('pq_max_size');
  }
  public set pqMaxSize(value: string) {
    this._pqMaxSize = value;
  }
  public resetPqMaxSize() {
    this._pqMaxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxSizeInput() {
    return this._pqMaxSize;
  }

  // pq_mode - computed: true, optional: true, required: false
  private _pqMode?: string; 
  public get pqMode() {
    return this.getStringAttribute('pq_mode');
  }
  public set pqMode(value: string) {
    this._pqMode = value;
  }
  public resetPqMode() {
    this._pqMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqModeInput() {
    return this._pqMode;
  }

  // pq_on_backpressure - computed: true, optional: true, required: false
  private _pqOnBackpressure?: string; 
  public get pqOnBackpressure() {
    return this.getStringAttribute('pq_on_backpressure');
  }
  public set pqOnBackpressure(value: string) {
    this._pqOnBackpressure = value;
  }
  public resetPqOnBackpressure() {
    this._pqOnBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqOnBackpressureInput() {
    return this._pqOnBackpressure;
  }

  // pq_path - computed: true, optional: true, required: false
  private _pqPath?: string; 
  public get pqPath() {
    return this.getStringAttribute('pq_path');
  }
  public set pqPath(value: string) {
    this._pqPath = value;
  }
  public resetPqPath() {
    this._pqPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqPathInput() {
    return this._pqPath;
  }

  // region - computed: false, optional: true, required: false
  private _region?: string; 
  public get region() {
    return this.getStringAttribute('region');
  }
  public set region(value: string) {
    this._region = value;
  }
  public resetRegion() {
    this._region = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get regionInput() {
    return this._region;
  }

  // reject_unauthorized - computed: true, optional: true, required: false
  private _rejectUnauthorized?: boolean | cdktf.IResolvable; 
  public get rejectUnauthorized() {
    return this.getBooleanAttribute('reject_unauthorized');
  }
  public set rejectUnauthorized(value: boolean | cdktf.IResolvable) {
    this._rejectUnauthorized = value;
  }
  public resetRejectUnauthorized() {
    this._rejectUnauthorized = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectUnauthorizedInput() {
    return this._rejectUnauthorized;
  }

  // response_honor_retry_after_header - computed: true, optional: true, required: false
  private _responseHonorRetryAfterHeader?: boolean | cdktf.IResolvable; 
  public get responseHonorRetryAfterHeader() {
    return this.getBooleanAttribute('response_honor_retry_after_header');
  }
  public set responseHonorRetryAfterHeader(value: boolean | cdktf.IResolvable) {
    this._responseHonorRetryAfterHeader = value;
  }
  public resetResponseHonorRetryAfterHeader() {
    this._responseHonorRetryAfterHeader = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get responseHonorRetryAfterHeaderInput() {
    return this._responseHonorRetryAfterHeader;
  }

  // response_retry_settings - computed: false, optional: true, required: false
  private _responseRetrySettings = new PackDestinationOutputGoogleChronicleResponseRetrySettingsList(this, "response_retry_settings", false);
  public get responseRetrySettings() {
    return this._responseRetrySettings;
  }
  public putResponseRetrySettings(value: PackDestinationOutputGoogleChronicleResponseRetrySettings[] | cdktf.IResolvable) {
    this._responseRetrySettings.internalValue = value;
  }
  public resetResponseRetrySettings() {
    this._responseRetrySettings.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get responseRetrySettingsInput() {
    return this._responseRetrySettings.internalValue;
  }

  // safe_headers - computed: true, optional: true, required: false
  private _safeHeaders?: string[]; 
  public get safeHeaders() {
    return this.getListAttribute('safe_headers');
  }
  public set safeHeaders(value: string[]) {
    this._safeHeaders = value;
  }
  public resetSafeHeaders() {
    this._safeHeaders = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get safeHeadersInput() {
    return this._safeHeaders;
  }

  // service_account_credentials - computed: false, optional: true, required: false
  private _serviceAccountCredentials?: string; 
  public get serviceAccountCredentials() {
    return this.getStringAttribute('service_account_credentials');
  }
  public set serviceAccountCredentials(value: string) {
    this._serviceAccountCredentials = value;
  }
  public resetServiceAccountCredentials() {
    this._serviceAccountCredentials = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serviceAccountCredentialsInput() {
    return this._serviceAccountCredentials;
  }

  // service_account_credentials_secret - computed: false, optional: true, required: false
  private _serviceAccountCredentialsSecret?: string; 
  public get serviceAccountCredentialsSecret() {
    return this.getStringAttribute('service_account_credentials_secret');
  }
  public set serviceAccountCredentialsSecret(value: string) {
    this._serviceAccountCredentialsSecret = value;
  }
  public resetServiceAccountCredentialsSecret() {
    this._serviceAccountCredentialsSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serviceAccountCredentialsSecretInput() {
    return this._serviceAccountCredentialsSecret;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // system_fields - computed: true, optional: true, required: false
  private _systemFields?: string[]; 
  public get systemFields() {
    return this.getListAttribute('system_fields');
  }
  public set systemFields(value: string[]) {
    this._systemFields = value;
  }
  public resetSystemFields() {
    this._systemFields = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get systemFieldsInput() {
    return this._systemFields;
  }

  // timeout_retry_settings - computed: false, optional: true, required: false
  private _timeoutRetrySettings = new PackDestinationOutputGoogleChronicleTimeoutRetrySettingsOutputReference(this, "timeout_retry_settings");
  public get timeoutRetrySettings() {
    return this._timeoutRetrySettings;
  }
  public putTimeoutRetrySettings(value: PackDestinationOutputGoogleChronicleTimeoutRetrySettings) {
    this._timeoutRetrySettings.internalValue = value;
  }
  public resetTimeoutRetrySettings() {
    this._timeoutRetrySettings.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutRetrySettingsInput() {
    return this._timeoutRetrySettings.internalValue;
  }

  // timeout_sec - computed: true, optional: true, required: false
  private _timeoutSec?: number; 
  public get timeoutSec() {
    return this.getNumberAttribute('timeout_sec');
  }
  public set timeoutSec(value: number) {
    this._timeoutSec = value;
  }
  public resetTimeoutSec() {
    this._timeoutSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutSecInput() {
    return this._timeoutSec;
  }

  // total_memory_limit_kb - computed: false, optional: true, required: false
  private _totalMemoryLimitKb?: number; 
  public get totalMemoryLimitKb() {
    return this.getNumberAttribute('total_memory_limit_kb');
  }
  public set totalMemoryLimitKb(value: number) {
    this._totalMemoryLimitKb = value;
  }
  public resetTotalMemoryLimitKb() {
    this._totalMemoryLimitKb = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get totalMemoryLimitKbInput() {
    return this._totalMemoryLimitKb;
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // use_round_robin_dns - computed: true, optional: true, required: false
  private _useRoundRobinDns?: boolean | cdktf.IResolvable; 
  public get useRoundRobinDns() {
    return this.getBooleanAttribute('use_round_robin_dns');
  }
  public set useRoundRobinDns(value: boolean | cdktf.IResolvable) {
    this._useRoundRobinDns = value;
  }
  public resetUseRoundRobinDns() {
    this._useRoundRobinDns = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get useRoundRobinDnsInput() {
    return this._useRoundRobinDns;
  }
}
export interface PackDestinationOutputGoogleCloudLoggingLogLabels {
  /**
  * Label name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#label PackDestination#label}
  */
  readonly label: string;
  /**
  * JavaScript expression to compute the label's value.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#value_expression PackDestination#value_expression}
  */
  readonly valueExpression: string;
}

export function packDestinationOutputGoogleCloudLoggingLogLabelsToTerraform(struct?: PackDestinationOutputGoogleCloudLoggingLogLabels | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    label: cdktf.stringToTerraform(struct!.label),
    value_expression: cdktf.stringToTerraform(struct!.valueExpression),
  }
}


export function packDestinationOutputGoogleCloudLoggingLogLabelsToHclTerraform(struct?: PackDestinationOutputGoogleCloudLoggingLogLabels | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    label: {
      value: cdktf.stringToHclTerraform(struct!.label),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value_expression: {
      value: cdktf.stringToHclTerraform(struct!.valueExpression),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputGoogleCloudLoggingLogLabelsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackDestinationOutputGoogleCloudLoggingLogLabels | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._label !== undefined) {
      hasAnyValues = true;
      internalValueResult.label = this._label;
    }
    if (this._valueExpression !== undefined) {
      hasAnyValues = true;
      internalValueResult.valueExpression = this._valueExpression;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputGoogleCloudLoggingLogLabels | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._label = undefined;
      this._valueExpression = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._label = value.label;
      this._valueExpression = value.valueExpression;
    }
  }

  // label - computed: false, optional: false, required: true
  private _label?: string; 
  public get label() {
    return this.getStringAttribute('label');
  }
  public set label(value: string) {
    this._label = value;
  }
  // Temporarily expose input value. Use with caution.
  public get labelInput() {
    return this._label;
  }

  // value_expression - computed: false, optional: false, required: true
  private _valueExpression?: string; 
  public get valueExpression() {
    return this.getStringAttribute('value_expression');
  }
  public set valueExpression(value: string) {
    this._valueExpression = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueExpressionInput() {
    return this._valueExpression;
  }
}

export class PackDestinationOutputGoogleCloudLoggingLogLabelsList extends cdktf.ComplexList {
  public internalValue? : PackDestinationOutputGoogleCloudLoggingLogLabels[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackDestinationOutputGoogleCloudLoggingLogLabelsOutputReference {
    return new PackDestinationOutputGoogleCloudLoggingLogLabelsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackDestinationOutputGoogleCloudLoggingPqControls {
}

export function packDestinationOutputGoogleCloudLoggingPqControlsToTerraform(struct?: PackDestinationOutputGoogleCloudLoggingPqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function packDestinationOutputGoogleCloudLoggingPqControlsToHclTerraform(struct?: PackDestinationOutputGoogleCloudLoggingPqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class PackDestinationOutputGoogleCloudLoggingPqControlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackDestinationOutputGoogleCloudLoggingPqControls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputGoogleCloudLoggingPqControls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface PackDestinationOutputGoogleCloudLoggingResourceTypeLabels {
  /**
  * Label name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#label PackDestination#label}
  */
  readonly label: string;
  /**
  * JavaScript expression to compute the label's value.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#value_expression PackDestination#value_expression}
  */
  readonly valueExpression: string;
}

export function packDestinationOutputGoogleCloudLoggingResourceTypeLabelsToTerraform(struct?: PackDestinationOutputGoogleCloudLoggingResourceTypeLabels | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    label: cdktf.stringToTerraform(struct!.label),
    value_expression: cdktf.stringToTerraform(struct!.valueExpression),
  }
}


export function packDestinationOutputGoogleCloudLoggingResourceTypeLabelsToHclTerraform(struct?: PackDestinationOutputGoogleCloudLoggingResourceTypeLabels | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    label: {
      value: cdktf.stringToHclTerraform(struct!.label),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value_expression: {
      value: cdktf.stringToHclTerraform(struct!.valueExpression),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputGoogleCloudLoggingResourceTypeLabelsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackDestinationOutputGoogleCloudLoggingResourceTypeLabels | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._label !== undefined) {
      hasAnyValues = true;
      internalValueResult.label = this._label;
    }
    if (this._valueExpression !== undefined) {
      hasAnyValues = true;
      internalValueResult.valueExpression = this._valueExpression;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputGoogleCloudLoggingResourceTypeLabels | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._label = undefined;
      this._valueExpression = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._label = value.label;
      this._valueExpression = value.valueExpression;
    }
  }

  // label - computed: false, optional: false, required: true
  private _label?: string; 
  public get label() {
    return this.getStringAttribute('label');
  }
  public set label(value: string) {
    this._label = value;
  }
  // Temporarily expose input value. Use with caution.
  public get labelInput() {
    return this._label;
  }

  // value_expression - computed: false, optional: false, required: true
  private _valueExpression?: string; 
  public get valueExpression() {
    return this.getStringAttribute('value_expression');
  }
  public set valueExpression(value: string) {
    this._valueExpression = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueExpressionInput() {
    return this._valueExpression;
  }
}

export class PackDestinationOutputGoogleCloudLoggingResourceTypeLabelsList extends cdktf.ComplexList {
  public internalValue? : PackDestinationOutputGoogleCloudLoggingResourceTypeLabels[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackDestinationOutputGoogleCloudLoggingResourceTypeLabelsOutputReference {
    return new PackDestinationOutputGoogleCloudLoggingResourceTypeLabelsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackDestinationOutputGoogleCloudLogging {
  /**
  * A JavaScript expression that evaluates to the HTTP request cache fill bytes as a string, in int64 format. See the [documentation](https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry#httprequest) for details.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#cache_fill_bytes_expression PackDestination#cache_fill_bytes_expression}
  */
  readonly cacheFillBytesExpression?: string;
  /**
  * A JavaScript expression that evaluates to the HTTP request cache hit as a boolean. See the [documentation](https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry#httprequest) for details.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#cache_hit_expression PackDestination#cache_hit_expression}
  */
  readonly cacheHitExpression?: string;
  /**
  * A JavaScript expression that evaluates to the HTTP request cache lookup as a boolean. See the [documentation](https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry#httprequest) for details.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#cache_lookup_expression PackDestination#cache_lookup_expression}
  */
  readonly cacheLookupExpression?: string;
  /**
  * A JavaScript expression that evaluates to the HTTP request cache validated with origin server as a boolean. See the [documentation](https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry#httprequest) for details.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#cache_validated_expression PackDestination#cache_validated_expression}
  */
  readonly cacheValidatedExpression?: string;
  /**
  * Maximum number of ongoing requests before blocking. Default: 5
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#concurrency PackDestination#concurrency}
  */
  readonly concurrency?: number;
  /**
  * Amount of time (milliseconds) to wait for the connection to establish before retrying. Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#connection_timeout PackDestination#connection_timeout}
  */
  readonly connectionTimeout?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#description PackDestination#description}
  */
  readonly description?: string;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#environment PackDestination#environment}
  */
  readonly environment?: string;
  /**
  * A JavaScript expression that evaluates to the log entry source location file as a string. See the [documentation](https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry#logentrysourcelocation) for details.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#file_expression PackDestination#file_expression}
  */
  readonly fileExpression?: string;
  /**
  * A JavaScript expression that evaluates to the log entry operation first flag as a boolean. See the [documentation](https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry#logentryoperation) for details.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#first_expression PackDestination#first_expression}
  */
  readonly firstExpression?: string;
  /**
  * Maximum time between requests. Small values could cause the payload size to be smaller than the configured Max record size. Default: 1
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#flush_period_sec PackDestination#flush_period_sec}
  */
  readonly flushPeriodSec?: number;
  /**
  * A JavaScript expression that evaluates to the log entry source location function as a string. See the [documentation](https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry#logentrysourcelocation) for details.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#function_expression PackDestination#function_expression}
  */
  readonly functionExpression?: string;
  /**
  * Choose Auto to use Google Application Default Credentials (ADC), Manual to enter Google service account credentials directly, or Secret to select or create a stored secret that references Google service account credentials. Default: "manual"; must be one of ["auto", "manual", "secret"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#google_auth_method PackDestination#google_auth_method}
  */
  readonly googleAuthMethod?: string;
  /**
  * Unique ID for this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#id PackDestination#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * A JavaScript expression that evaluates to the log entry operation ID as a string. See the [documentation](https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry#logentryoperation) for details.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#id_expression PackDestination#id_expression}
  */
  readonly idExpression?: string;
  /**
  * A JavaScript expression that evaluates to the log entry log split index as a number. See the [documentation](https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry#logsplit) for details.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#index_expression PackDestination#index_expression}
  */
  readonly indexExpression?: string;
  /**
  * JavaScript expression to compute the value of the insert ID field.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#insert_id_expression PackDestination#insert_id_expression}
  */
  readonly insertIdExpression?: string;
  /**
  * A JavaScript expression that evaluates to the log entry operation last flag as a boolean. See the [documentation](https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry#logentryoperation) for details.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#last_expression PackDestination#last_expression}
  */
  readonly lastExpression?: string;
  /**
  * A JavaScript expression that evaluates to the HTTP request latency, formatted as <seconds>.<nanoseconds>s (for example, 1.23s). See the [documentation](https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry#httprequest) for details.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#latency_expression PackDestination#latency_expression}
  */
  readonly latencyExpression?: string;
  /**
  * A JavaScript expression that evaluates to the log entry source location line as a string, in int64 format. See the [documentation](https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry#logentrysourcelocation) for details.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#line_expression PackDestination#line_expression}
  */
  readonly lineExpression?: string;
  /**
  * Labels to apply to the log entry
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#log_labels PackDestination#log_labels}
  */
  readonly logLabels?: PackDestinationOutputGoogleCloudLoggingLogLabels[] | cdktf.IResolvable;
  /**
  * JavaScript expression to compute the value of the folder ID with which log entries should be associated.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#log_location_expression PackDestination#log_location_expression}
  */
  readonly logLocationExpression: string;
  /**
  * must be one of ["project", "organization", "billingAccount", "folder"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#log_location_type PackDestination#log_location_type}
  */
  readonly logLocationType: string;
  /**
  * JavaScript expression to compute the value of the log name.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#log_name_expression PackDestination#log_name_expression}
  */
  readonly logNameExpression: string;
  /**
  * Max number of events to include in the request body. Default is 0 (unlimited). Default: 0
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_payload_events PackDestination#max_payload_events}
  */
  readonly maxPayloadEvents?: number;
  /**
  * Maximum size, in KB, of the request body. Default: 4096
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_payload_size_kb PackDestination#max_payload_size_kb}
  */
  readonly maxPayloadSizeKb?: number;
  /**
  * How to handle events when all receivers are exerting backpressure. Default: "block"; must be one of ["block", "drop", "queue"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#on_backpressure PackDestination#on_backpressure}
  */
  readonly onBackpressure?: string;
  /**
  * JavaScript expression to compute the value of the payload. Must evaluate to a JavaScript object value. If an invalid value is encountered it will result in the default value instead. Defaults to the entire event.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#payload_expression PackDestination#payload_expression}
  */
  readonly payloadExpression?: string;
  /**
  * Format to use when sending payload. Defaults to Text. Default: "text"; must be one of ["text", "json"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#payload_format PackDestination#payload_format}
  */
  readonly payloadFormat?: string;
  /**
  * Pipeline to process data before sending out to this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pipeline PackDestination#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_compress PackDestination#pq_compress}
  */
  readonly pqCompress?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_controls PackDestination#pq_controls}
  */
  readonly pqControls?: PackDestinationOutputGoogleCloudLoggingPqControls;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.). Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_max_file_size PackDestination#pq_max_file_size}
  */
  readonly pqMaxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_max_size PackDestination#pq_max_size}
  */
  readonly pqMaxSize?: string;
  /**
  * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem. Default: "error"; must be one of ["error", "backpressure", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_mode PackDestination#pq_mode}
  */
  readonly pqMode?: string;
  /**
  * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged. Default: "block"; must be one of ["block", "drop"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_on_backpressure PackDestination#pq_on_backpressure}
  */
  readonly pqOnBackpressure?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_path PackDestination#pq_path}
  */
  readonly pqPath?: string;
  /**
  * A JavaScript expression that evaluates to the log entry operation producer as a string. See the [documentation](https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry#logentryoperation) for details.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#producer_expression PackDestination#producer_expression}
  */
  readonly producerExpression?: string;
  /**
  * A JavaScript expression that evaluates to the HTTP request protocol as a string. See the [documentation](https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry#httprequest) for details.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#protocol_expression PackDestination#protocol_expression}
  */
  readonly protocolExpression?: string;
  /**
  * A JavaScript expression that evaluates to the HTTP request referer as a string. See the [documentation](https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry#httprequest) for details.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#referer_expression PackDestination#referer_expression}
  */
  readonly refererExpression?: string;
  /**
  * A JavaScript expression that evaluates to the HTTP request remote IP as a string. See the [documentation](https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry#httprequest) for details.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#remote_ip_expression PackDestination#remote_ip_expression}
  */
  readonly remoteIpExpression?: string;
  /**
  * A JavaScript expression that evaluates to the HTTP request method as a string. See the [documentation](https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry#httprequest) for details.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#request_method_expression PackDestination#request_method_expression}
  */
  readonly requestMethodExpression?: string;
  /**
  * A JavaScript expression that evaluates to the HTTP request size as a string, in int64 format. See the [documentation](https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry#httprequest) for details.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#request_size_expression PackDestination#request_size_expression}
  */
  readonly requestSizeExpression?: string;
  /**
  * A JavaScript expression that evaluates to the HTTP request URL as a string. See the [documentation](https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry#httprequest) for details.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#request_url_expression PackDestination#request_url_expression}
  */
  readonly requestUrlExpression?: string;
  /**
  * JavaScript expression to compute the value of the managed resource type field. Must evaluate to one of the valid values [here](https://cloud.google.com/logging/docs/api/v2/resource-list#resource-types). Defaults to "global".
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#resource_type_expression PackDestination#resource_type_expression}
  */
  readonly resourceTypeExpression?: string;
  /**
  * Labels to apply to the managed resource. These must correspond to the valid labels for the specified resource type (see [here](https://cloud.google.com/logging/docs/api/v2/resource-list#resource-types)). Otherwise, they will be dropped by Google Cloud Logging.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#resource_type_labels PackDestination#resource_type_labels}
  */
  readonly resourceTypeLabels?: PackDestinationOutputGoogleCloudLoggingResourceTypeLabels[] | cdktf.IResolvable;
  /**
  * A JavaScript expression that evaluates to the HTTP response size as a string, in int64 format. See the [documentation](https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry#httprequest) for details.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#response_size_expression PackDestination#response_size_expression}
  */
  readonly responseSizeExpression?: string;
  /**
  * Select or create a stored text secret
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#secret PackDestination#secret}
  */
  readonly secret?: string;
  /**
  * A JavaScript expression that evaluates to the HTTP request server IP as a string. See the [documentation](https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry#httprequest) for details.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#server_ip_expression PackDestination#server_ip_expression}
  */
  readonly serverIpExpression?: string;
  /**
  * Contents of service account credentials (JSON keys) file downloaded from Google Cloud. To upload a file, click the upload button at this field's upper right.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#service_account_credentials PackDestination#service_account_credentials}
  */
  readonly serviceAccountCredentials?: string;
  /**
  * JavaScript expression to compute the value of the severity field. Must evaluate to one of the severity values supported by Google Cloud Logging [here](https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry#logseverity) (case insensitive). Defaults to "DEFAULT".
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#severity_expression PackDestination#severity_expression}
  */
  readonly severityExpression?: string;
  /**
  * A JavaScript expression that evaluates to the ID of the cloud trace span associated with the current operation in which the log is being written as a string. See the [documentation](https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry) for details.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#span_id_expression PackDestination#span_id_expression}
  */
  readonly spanIdExpression?: string;
  /**
  * A JavaScript expression that evaluates to the HTTP request method as a number. See the [documentation](https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry#httprequest) for details.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#status_expression PackDestination#status_expression}
  */
  readonly statusExpression?: string;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#streamtags PackDestination#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Fields to automatically add to events, such as cribl_pipe. Supports wildcards. Default: ["cribl_pipe"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#system_fields PackDestination#system_fields}
  */
  readonly systemFields?: string[];
  /**
  * Maximum number of requests to limit to per second.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#throttle_rate_req_per_sec PackDestination#throttle_rate_req_per_sec}
  */
  readonly throttleRateReqPerSec?: number;
  /**
  * Amount of time, in seconds, to wait for a request to complete before canceling it. Default: 30
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#timeout_sec PackDestination#timeout_sec}
  */
  readonly timeoutSec?: number;
  /**
  * Maximum total size of the batches waiting to be sent. If left blank, defaults to 5 times the max body size (if set). If 0, no limit is enforced.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#total_memory_limit_kb PackDestination#total_memory_limit_kb}
  */
  readonly totalMemoryLimitKb?: number;
  /**
  * A JavaScript expression that evaluates to the log entry log split total splits as a number. See the [documentation](https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry#logsplit) for details.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#total_splits_expression PackDestination#total_splits_expression}
  */
  readonly totalSplitsExpression?: string;
  /**
  * A JavaScript expression that evaluates to the REST resource name of the trace being written as a string. See the [documentation](https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry) for details.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#trace_expression PackDestination#trace_expression}
  */
  readonly traceExpression?: string;
  /**
  * A JavaScript expression that evaluates to the the sampling decision of the span associated with the log entry. See the [documentation](https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry) for details.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#trace_sampled_expression PackDestination#trace_sampled_expression}
  */
  readonly traceSampledExpression?: string;
  /**
  * must be "google_cloud_logging"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#type PackDestination#type}
  */
  readonly type?: string;
  /**
  * A JavaScript expression that evaluates to the log entry log split UID as a string. See the [documentation](https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry#logsplit) for details.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#uid_expression PackDestination#uid_expression}
  */
  readonly uidExpression?: string;
  /**
  * A JavaScript expression that evaluates to the HTTP request user agent as a string. See the [documentation](https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry#httprequest) for details.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#user_agent_expression PackDestination#user_agent_expression}
  */
  readonly userAgentExpression?: string;
}

export function packDestinationOutputGoogleCloudLoggingToTerraform(struct?: PackDestinationOutputGoogleCloudLogging | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    cache_fill_bytes_expression: cdktf.stringToTerraform(struct!.cacheFillBytesExpression),
    cache_hit_expression: cdktf.stringToTerraform(struct!.cacheHitExpression),
    cache_lookup_expression: cdktf.stringToTerraform(struct!.cacheLookupExpression),
    cache_validated_expression: cdktf.stringToTerraform(struct!.cacheValidatedExpression),
    concurrency: cdktf.numberToTerraform(struct!.concurrency),
    connection_timeout: cdktf.numberToTerraform(struct!.connectionTimeout),
    description: cdktf.stringToTerraform(struct!.description),
    environment: cdktf.stringToTerraform(struct!.environment),
    file_expression: cdktf.stringToTerraform(struct!.fileExpression),
    first_expression: cdktf.stringToTerraform(struct!.firstExpression),
    flush_period_sec: cdktf.numberToTerraform(struct!.flushPeriodSec),
    function_expression: cdktf.stringToTerraform(struct!.functionExpression),
    google_auth_method: cdktf.stringToTerraform(struct!.googleAuthMethod),
    id: cdktf.stringToTerraform(struct!.id),
    id_expression: cdktf.stringToTerraform(struct!.idExpression),
    index_expression: cdktf.stringToTerraform(struct!.indexExpression),
    insert_id_expression: cdktf.stringToTerraform(struct!.insertIdExpression),
    last_expression: cdktf.stringToTerraform(struct!.lastExpression),
    latency_expression: cdktf.stringToTerraform(struct!.latencyExpression),
    line_expression: cdktf.stringToTerraform(struct!.lineExpression),
    log_labels: cdktf.listMapper(packDestinationOutputGoogleCloudLoggingLogLabelsToTerraform, false)(struct!.logLabels),
    log_location_expression: cdktf.stringToTerraform(struct!.logLocationExpression),
    log_location_type: cdktf.stringToTerraform(struct!.logLocationType),
    log_name_expression: cdktf.stringToTerraform(struct!.logNameExpression),
    max_payload_events: cdktf.numberToTerraform(struct!.maxPayloadEvents),
    max_payload_size_kb: cdktf.numberToTerraform(struct!.maxPayloadSizeKb),
    on_backpressure: cdktf.stringToTerraform(struct!.onBackpressure),
    payload_expression: cdktf.stringToTerraform(struct!.payloadExpression),
    payload_format: cdktf.stringToTerraform(struct!.payloadFormat),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    pq_compress: cdktf.stringToTerraform(struct!.pqCompress),
    pq_controls: packDestinationOutputGoogleCloudLoggingPqControlsToTerraform(struct!.pqControls),
    pq_max_file_size: cdktf.stringToTerraform(struct!.pqMaxFileSize),
    pq_max_size: cdktf.stringToTerraform(struct!.pqMaxSize),
    pq_mode: cdktf.stringToTerraform(struct!.pqMode),
    pq_on_backpressure: cdktf.stringToTerraform(struct!.pqOnBackpressure),
    pq_path: cdktf.stringToTerraform(struct!.pqPath),
    producer_expression: cdktf.stringToTerraform(struct!.producerExpression),
    protocol_expression: cdktf.stringToTerraform(struct!.protocolExpression),
    referer_expression: cdktf.stringToTerraform(struct!.refererExpression),
    remote_ip_expression: cdktf.stringToTerraform(struct!.remoteIpExpression),
    request_method_expression: cdktf.stringToTerraform(struct!.requestMethodExpression),
    request_size_expression: cdktf.stringToTerraform(struct!.requestSizeExpression),
    request_url_expression: cdktf.stringToTerraform(struct!.requestUrlExpression),
    resource_type_expression: cdktf.stringToTerraform(struct!.resourceTypeExpression),
    resource_type_labels: cdktf.listMapper(packDestinationOutputGoogleCloudLoggingResourceTypeLabelsToTerraform, false)(struct!.resourceTypeLabels),
    response_size_expression: cdktf.stringToTerraform(struct!.responseSizeExpression),
    secret: cdktf.stringToTerraform(struct!.secret),
    server_ip_expression: cdktf.stringToTerraform(struct!.serverIpExpression),
    service_account_credentials: cdktf.stringToTerraform(struct!.serviceAccountCredentials),
    severity_expression: cdktf.stringToTerraform(struct!.severityExpression),
    span_id_expression: cdktf.stringToTerraform(struct!.spanIdExpression),
    status_expression: cdktf.stringToTerraform(struct!.statusExpression),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    system_fields: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.systemFields),
    throttle_rate_req_per_sec: cdktf.numberToTerraform(struct!.throttleRateReqPerSec),
    timeout_sec: cdktf.numberToTerraform(struct!.timeoutSec),
    total_memory_limit_kb: cdktf.numberToTerraform(struct!.totalMemoryLimitKb),
    total_splits_expression: cdktf.stringToTerraform(struct!.totalSplitsExpression),
    trace_expression: cdktf.stringToTerraform(struct!.traceExpression),
    trace_sampled_expression: cdktf.stringToTerraform(struct!.traceSampledExpression),
    type: cdktf.stringToTerraform(struct!.type),
    uid_expression: cdktf.stringToTerraform(struct!.uidExpression),
    user_agent_expression: cdktf.stringToTerraform(struct!.userAgentExpression),
  }
}


export function packDestinationOutputGoogleCloudLoggingToHclTerraform(struct?: PackDestinationOutputGoogleCloudLogging | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    cache_fill_bytes_expression: {
      value: cdktf.stringToHclTerraform(struct!.cacheFillBytesExpression),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    cache_hit_expression: {
      value: cdktf.stringToHclTerraform(struct!.cacheHitExpression),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    cache_lookup_expression: {
      value: cdktf.stringToHclTerraform(struct!.cacheLookupExpression),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    cache_validated_expression: {
      value: cdktf.stringToHclTerraform(struct!.cacheValidatedExpression),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    concurrency: {
      value: cdktf.numberToHclTerraform(struct!.concurrency),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    connection_timeout: {
      value: cdktf.numberToHclTerraform(struct!.connectionTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    file_expression: {
      value: cdktf.stringToHclTerraform(struct!.fileExpression),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    first_expression: {
      value: cdktf.stringToHclTerraform(struct!.firstExpression),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    flush_period_sec: {
      value: cdktf.numberToHclTerraform(struct!.flushPeriodSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    function_expression: {
      value: cdktf.stringToHclTerraform(struct!.functionExpression),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    google_auth_method: {
      value: cdktf.stringToHclTerraform(struct!.googleAuthMethod),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    id_expression: {
      value: cdktf.stringToHclTerraform(struct!.idExpression),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    index_expression: {
      value: cdktf.stringToHclTerraform(struct!.indexExpression),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    insert_id_expression: {
      value: cdktf.stringToHclTerraform(struct!.insertIdExpression),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    last_expression: {
      value: cdktf.stringToHclTerraform(struct!.lastExpression),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    latency_expression: {
      value: cdktf.stringToHclTerraform(struct!.latencyExpression),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    line_expression: {
      value: cdktf.stringToHclTerraform(struct!.lineExpression),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    log_labels: {
      value: cdktf.listMapperHcl(packDestinationOutputGoogleCloudLoggingLogLabelsToHclTerraform, false)(struct!.logLabels),
      isBlock: true,
      type: "list",
      storageClassType: "PackDestinationOutputGoogleCloudLoggingLogLabelsList",
    },
    log_location_expression: {
      value: cdktf.stringToHclTerraform(struct!.logLocationExpression),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    log_location_type: {
      value: cdktf.stringToHclTerraform(struct!.logLocationType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    log_name_expression: {
      value: cdktf.stringToHclTerraform(struct!.logNameExpression),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_payload_events: {
      value: cdktf.numberToHclTerraform(struct!.maxPayloadEvents),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_payload_size_kb: {
      value: cdktf.numberToHclTerraform(struct!.maxPayloadSizeKb),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.onBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    payload_expression: {
      value: cdktf.stringToHclTerraform(struct!.payloadExpression),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    payload_format: {
      value: cdktf.stringToHclTerraform(struct!.payloadFormat),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_compress: {
      value: cdktf.stringToHclTerraform(struct!.pqCompress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_controls: {
      value: packDestinationOutputGoogleCloudLoggingPqControlsToHclTerraform(struct!.pqControls),
      isBlock: true,
      type: "struct",
      storageClassType: "PackDestinationOutputGoogleCloudLoggingPqControls",
    },
    pq_max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_max_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_mode: {
      value: cdktf.stringToHclTerraform(struct!.pqMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.pqOnBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_path: {
      value: cdktf.stringToHclTerraform(struct!.pqPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    producer_expression: {
      value: cdktf.stringToHclTerraform(struct!.producerExpression),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    protocol_expression: {
      value: cdktf.stringToHclTerraform(struct!.protocolExpression),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    referer_expression: {
      value: cdktf.stringToHclTerraform(struct!.refererExpression),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    remote_ip_expression: {
      value: cdktf.stringToHclTerraform(struct!.remoteIpExpression),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    request_method_expression: {
      value: cdktf.stringToHclTerraform(struct!.requestMethodExpression),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    request_size_expression: {
      value: cdktf.stringToHclTerraform(struct!.requestSizeExpression),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    request_url_expression: {
      value: cdktf.stringToHclTerraform(struct!.requestUrlExpression),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    resource_type_expression: {
      value: cdktf.stringToHclTerraform(struct!.resourceTypeExpression),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    resource_type_labels: {
      value: cdktf.listMapperHcl(packDestinationOutputGoogleCloudLoggingResourceTypeLabelsToHclTerraform, false)(struct!.resourceTypeLabels),
      isBlock: true,
      type: "list",
      storageClassType: "PackDestinationOutputGoogleCloudLoggingResourceTypeLabelsList",
    },
    response_size_expression: {
      value: cdktf.stringToHclTerraform(struct!.responseSizeExpression),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret: {
      value: cdktf.stringToHclTerraform(struct!.secret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    server_ip_expression: {
      value: cdktf.stringToHclTerraform(struct!.serverIpExpression),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    service_account_credentials: {
      value: cdktf.stringToHclTerraform(struct!.serviceAccountCredentials),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    severity_expression: {
      value: cdktf.stringToHclTerraform(struct!.severityExpression),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    span_id_expression: {
      value: cdktf.stringToHclTerraform(struct!.spanIdExpression),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    status_expression: {
      value: cdktf.stringToHclTerraform(struct!.statusExpression),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    system_fields: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.systemFields),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    throttle_rate_req_per_sec: {
      value: cdktf.numberToHclTerraform(struct!.throttleRateReqPerSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    timeout_sec: {
      value: cdktf.numberToHclTerraform(struct!.timeoutSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    total_memory_limit_kb: {
      value: cdktf.numberToHclTerraform(struct!.totalMemoryLimitKb),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    total_splits_expression: {
      value: cdktf.stringToHclTerraform(struct!.totalSplitsExpression),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    trace_expression: {
      value: cdktf.stringToHclTerraform(struct!.traceExpression),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    trace_sampled_expression: {
      value: cdktf.stringToHclTerraform(struct!.traceSampledExpression),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    uid_expression: {
      value: cdktf.stringToHclTerraform(struct!.uidExpression),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    user_agent_expression: {
      value: cdktf.stringToHclTerraform(struct!.userAgentExpression),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputGoogleCloudLoggingOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackDestinationOutputGoogleCloudLogging | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._cacheFillBytesExpression !== undefined) {
      hasAnyValues = true;
      internalValueResult.cacheFillBytesExpression = this._cacheFillBytesExpression;
    }
    if (this._cacheHitExpression !== undefined) {
      hasAnyValues = true;
      internalValueResult.cacheHitExpression = this._cacheHitExpression;
    }
    if (this._cacheLookupExpression !== undefined) {
      hasAnyValues = true;
      internalValueResult.cacheLookupExpression = this._cacheLookupExpression;
    }
    if (this._cacheValidatedExpression !== undefined) {
      hasAnyValues = true;
      internalValueResult.cacheValidatedExpression = this._cacheValidatedExpression;
    }
    if (this._concurrency !== undefined) {
      hasAnyValues = true;
      internalValueResult.concurrency = this._concurrency;
    }
    if (this._connectionTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.connectionTimeout = this._connectionTimeout;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._fileExpression !== undefined) {
      hasAnyValues = true;
      internalValueResult.fileExpression = this._fileExpression;
    }
    if (this._firstExpression !== undefined) {
      hasAnyValues = true;
      internalValueResult.firstExpression = this._firstExpression;
    }
    if (this._flushPeriodSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.flushPeriodSec = this._flushPeriodSec;
    }
    if (this._functionExpression !== undefined) {
      hasAnyValues = true;
      internalValueResult.functionExpression = this._functionExpression;
    }
    if (this._googleAuthMethod !== undefined) {
      hasAnyValues = true;
      internalValueResult.googleAuthMethod = this._googleAuthMethod;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._idExpression !== undefined) {
      hasAnyValues = true;
      internalValueResult.idExpression = this._idExpression;
    }
    if (this._indexExpression !== undefined) {
      hasAnyValues = true;
      internalValueResult.indexExpression = this._indexExpression;
    }
    if (this._insertIdExpression !== undefined) {
      hasAnyValues = true;
      internalValueResult.insertIdExpression = this._insertIdExpression;
    }
    if (this._lastExpression !== undefined) {
      hasAnyValues = true;
      internalValueResult.lastExpression = this._lastExpression;
    }
    if (this._latencyExpression !== undefined) {
      hasAnyValues = true;
      internalValueResult.latencyExpression = this._latencyExpression;
    }
    if (this._lineExpression !== undefined) {
      hasAnyValues = true;
      internalValueResult.lineExpression = this._lineExpression;
    }
    if (this._logLabels?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.logLabels = this._logLabels?.internalValue;
    }
    if (this._logLocationExpression !== undefined) {
      hasAnyValues = true;
      internalValueResult.logLocationExpression = this._logLocationExpression;
    }
    if (this._logLocationType !== undefined) {
      hasAnyValues = true;
      internalValueResult.logLocationType = this._logLocationType;
    }
    if (this._logNameExpression !== undefined) {
      hasAnyValues = true;
      internalValueResult.logNameExpression = this._logNameExpression;
    }
    if (this._maxPayloadEvents !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxPayloadEvents = this._maxPayloadEvents;
    }
    if (this._maxPayloadSizeKb !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxPayloadSizeKb = this._maxPayloadSizeKb;
    }
    if (this._onBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.onBackpressure = this._onBackpressure;
    }
    if (this._payloadExpression !== undefined) {
      hasAnyValues = true;
      internalValueResult.payloadExpression = this._payloadExpression;
    }
    if (this._payloadFormat !== undefined) {
      hasAnyValues = true;
      internalValueResult.payloadFormat = this._payloadFormat;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._pqCompress !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqCompress = this._pqCompress;
    }
    if (this._pqControls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqControls = this._pqControls?.internalValue;
    }
    if (this._pqMaxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxFileSize = this._pqMaxFileSize;
    }
    if (this._pqMaxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxSize = this._pqMaxSize;
    }
    if (this._pqMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMode = this._pqMode;
    }
    if (this._pqOnBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqOnBackpressure = this._pqOnBackpressure;
    }
    if (this._pqPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqPath = this._pqPath;
    }
    if (this._producerExpression !== undefined) {
      hasAnyValues = true;
      internalValueResult.producerExpression = this._producerExpression;
    }
    if (this._protocolExpression !== undefined) {
      hasAnyValues = true;
      internalValueResult.protocolExpression = this._protocolExpression;
    }
    if (this._refererExpression !== undefined) {
      hasAnyValues = true;
      internalValueResult.refererExpression = this._refererExpression;
    }
    if (this._remoteIpExpression !== undefined) {
      hasAnyValues = true;
      internalValueResult.remoteIpExpression = this._remoteIpExpression;
    }
    if (this._requestMethodExpression !== undefined) {
      hasAnyValues = true;
      internalValueResult.requestMethodExpression = this._requestMethodExpression;
    }
    if (this._requestSizeExpression !== undefined) {
      hasAnyValues = true;
      internalValueResult.requestSizeExpression = this._requestSizeExpression;
    }
    if (this._requestUrlExpression !== undefined) {
      hasAnyValues = true;
      internalValueResult.requestUrlExpression = this._requestUrlExpression;
    }
    if (this._resourceTypeExpression !== undefined) {
      hasAnyValues = true;
      internalValueResult.resourceTypeExpression = this._resourceTypeExpression;
    }
    if (this._resourceTypeLabels?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.resourceTypeLabels = this._resourceTypeLabels?.internalValue;
    }
    if (this._responseSizeExpression !== undefined) {
      hasAnyValues = true;
      internalValueResult.responseSizeExpression = this._responseSizeExpression;
    }
    if (this._secret !== undefined) {
      hasAnyValues = true;
      internalValueResult.secret = this._secret;
    }
    if (this._serverIpExpression !== undefined) {
      hasAnyValues = true;
      internalValueResult.serverIpExpression = this._serverIpExpression;
    }
    if (this._serviceAccountCredentials !== undefined) {
      hasAnyValues = true;
      internalValueResult.serviceAccountCredentials = this._serviceAccountCredentials;
    }
    if (this._severityExpression !== undefined) {
      hasAnyValues = true;
      internalValueResult.severityExpression = this._severityExpression;
    }
    if (this._spanIdExpression !== undefined) {
      hasAnyValues = true;
      internalValueResult.spanIdExpression = this._spanIdExpression;
    }
    if (this._statusExpression !== undefined) {
      hasAnyValues = true;
      internalValueResult.statusExpression = this._statusExpression;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._systemFields !== undefined) {
      hasAnyValues = true;
      internalValueResult.systemFields = this._systemFields;
    }
    if (this._throttleRateReqPerSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.throttleRateReqPerSec = this._throttleRateReqPerSec;
    }
    if (this._timeoutSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutSec = this._timeoutSec;
    }
    if (this._totalMemoryLimitKb !== undefined) {
      hasAnyValues = true;
      internalValueResult.totalMemoryLimitKb = this._totalMemoryLimitKb;
    }
    if (this._totalSplitsExpression !== undefined) {
      hasAnyValues = true;
      internalValueResult.totalSplitsExpression = this._totalSplitsExpression;
    }
    if (this._traceExpression !== undefined) {
      hasAnyValues = true;
      internalValueResult.traceExpression = this._traceExpression;
    }
    if (this._traceSampledExpression !== undefined) {
      hasAnyValues = true;
      internalValueResult.traceSampledExpression = this._traceSampledExpression;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._uidExpression !== undefined) {
      hasAnyValues = true;
      internalValueResult.uidExpression = this._uidExpression;
    }
    if (this._userAgentExpression !== undefined) {
      hasAnyValues = true;
      internalValueResult.userAgentExpression = this._userAgentExpression;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputGoogleCloudLogging | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._cacheFillBytesExpression = undefined;
      this._cacheHitExpression = undefined;
      this._cacheLookupExpression = undefined;
      this._cacheValidatedExpression = undefined;
      this._concurrency = undefined;
      this._connectionTimeout = undefined;
      this._description = undefined;
      this._environment = undefined;
      this._fileExpression = undefined;
      this._firstExpression = undefined;
      this._flushPeriodSec = undefined;
      this._functionExpression = undefined;
      this._googleAuthMethod = undefined;
      this._id = undefined;
      this._idExpression = undefined;
      this._indexExpression = undefined;
      this._insertIdExpression = undefined;
      this._lastExpression = undefined;
      this._latencyExpression = undefined;
      this._lineExpression = undefined;
      this._logLabels.internalValue = undefined;
      this._logLocationExpression = undefined;
      this._logLocationType = undefined;
      this._logNameExpression = undefined;
      this._maxPayloadEvents = undefined;
      this._maxPayloadSizeKb = undefined;
      this._onBackpressure = undefined;
      this._payloadExpression = undefined;
      this._payloadFormat = undefined;
      this._pipeline = undefined;
      this._pqCompress = undefined;
      this._pqControls.internalValue = undefined;
      this._pqMaxFileSize = undefined;
      this._pqMaxSize = undefined;
      this._pqMode = undefined;
      this._pqOnBackpressure = undefined;
      this._pqPath = undefined;
      this._producerExpression = undefined;
      this._protocolExpression = undefined;
      this._refererExpression = undefined;
      this._remoteIpExpression = undefined;
      this._requestMethodExpression = undefined;
      this._requestSizeExpression = undefined;
      this._requestUrlExpression = undefined;
      this._resourceTypeExpression = undefined;
      this._resourceTypeLabels.internalValue = undefined;
      this._responseSizeExpression = undefined;
      this._secret = undefined;
      this._serverIpExpression = undefined;
      this._serviceAccountCredentials = undefined;
      this._severityExpression = undefined;
      this._spanIdExpression = undefined;
      this._statusExpression = undefined;
      this._streamtags = undefined;
      this._systemFields = undefined;
      this._throttleRateReqPerSec = undefined;
      this._timeoutSec = undefined;
      this._totalMemoryLimitKb = undefined;
      this._totalSplitsExpression = undefined;
      this._traceExpression = undefined;
      this._traceSampledExpression = undefined;
      this._type = undefined;
      this._uidExpression = undefined;
      this._userAgentExpression = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._cacheFillBytesExpression = value.cacheFillBytesExpression;
      this._cacheHitExpression = value.cacheHitExpression;
      this._cacheLookupExpression = value.cacheLookupExpression;
      this._cacheValidatedExpression = value.cacheValidatedExpression;
      this._concurrency = value.concurrency;
      this._connectionTimeout = value.connectionTimeout;
      this._description = value.description;
      this._environment = value.environment;
      this._fileExpression = value.fileExpression;
      this._firstExpression = value.firstExpression;
      this._flushPeriodSec = value.flushPeriodSec;
      this._functionExpression = value.functionExpression;
      this._googleAuthMethod = value.googleAuthMethod;
      this._id = value.id;
      this._idExpression = value.idExpression;
      this._indexExpression = value.indexExpression;
      this._insertIdExpression = value.insertIdExpression;
      this._lastExpression = value.lastExpression;
      this._latencyExpression = value.latencyExpression;
      this._lineExpression = value.lineExpression;
      this._logLabels.internalValue = value.logLabels;
      this._logLocationExpression = value.logLocationExpression;
      this._logLocationType = value.logLocationType;
      this._logNameExpression = value.logNameExpression;
      this._maxPayloadEvents = value.maxPayloadEvents;
      this._maxPayloadSizeKb = value.maxPayloadSizeKb;
      this._onBackpressure = value.onBackpressure;
      this._payloadExpression = value.payloadExpression;
      this._payloadFormat = value.payloadFormat;
      this._pipeline = value.pipeline;
      this._pqCompress = value.pqCompress;
      this._pqControls.internalValue = value.pqControls;
      this._pqMaxFileSize = value.pqMaxFileSize;
      this._pqMaxSize = value.pqMaxSize;
      this._pqMode = value.pqMode;
      this._pqOnBackpressure = value.pqOnBackpressure;
      this._pqPath = value.pqPath;
      this._producerExpression = value.producerExpression;
      this._protocolExpression = value.protocolExpression;
      this._refererExpression = value.refererExpression;
      this._remoteIpExpression = value.remoteIpExpression;
      this._requestMethodExpression = value.requestMethodExpression;
      this._requestSizeExpression = value.requestSizeExpression;
      this._requestUrlExpression = value.requestUrlExpression;
      this._resourceTypeExpression = value.resourceTypeExpression;
      this._resourceTypeLabels.internalValue = value.resourceTypeLabels;
      this._responseSizeExpression = value.responseSizeExpression;
      this._secret = value.secret;
      this._serverIpExpression = value.serverIpExpression;
      this._serviceAccountCredentials = value.serviceAccountCredentials;
      this._severityExpression = value.severityExpression;
      this._spanIdExpression = value.spanIdExpression;
      this._statusExpression = value.statusExpression;
      this._streamtags = value.streamtags;
      this._systemFields = value.systemFields;
      this._throttleRateReqPerSec = value.throttleRateReqPerSec;
      this._timeoutSec = value.timeoutSec;
      this._totalMemoryLimitKb = value.totalMemoryLimitKb;
      this._totalSplitsExpression = value.totalSplitsExpression;
      this._traceExpression = value.traceExpression;
      this._traceSampledExpression = value.traceSampledExpression;
      this._type = value.type;
      this._uidExpression = value.uidExpression;
      this._userAgentExpression = value.userAgentExpression;
    }
  }

  // cache_fill_bytes_expression - computed: false, optional: true, required: false
  private _cacheFillBytesExpression?: string; 
  public get cacheFillBytesExpression() {
    return this.getStringAttribute('cache_fill_bytes_expression');
  }
  public set cacheFillBytesExpression(value: string) {
    this._cacheFillBytesExpression = value;
  }
  public resetCacheFillBytesExpression() {
    this._cacheFillBytesExpression = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cacheFillBytesExpressionInput() {
    return this._cacheFillBytesExpression;
  }

  // cache_hit_expression - computed: false, optional: true, required: false
  private _cacheHitExpression?: string; 
  public get cacheHitExpression() {
    return this.getStringAttribute('cache_hit_expression');
  }
  public set cacheHitExpression(value: string) {
    this._cacheHitExpression = value;
  }
  public resetCacheHitExpression() {
    this._cacheHitExpression = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cacheHitExpressionInput() {
    return this._cacheHitExpression;
  }

  // cache_lookup_expression - computed: false, optional: true, required: false
  private _cacheLookupExpression?: string; 
  public get cacheLookupExpression() {
    return this.getStringAttribute('cache_lookup_expression');
  }
  public set cacheLookupExpression(value: string) {
    this._cacheLookupExpression = value;
  }
  public resetCacheLookupExpression() {
    this._cacheLookupExpression = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cacheLookupExpressionInput() {
    return this._cacheLookupExpression;
  }

  // cache_validated_expression - computed: false, optional: true, required: false
  private _cacheValidatedExpression?: string; 
  public get cacheValidatedExpression() {
    return this.getStringAttribute('cache_validated_expression');
  }
  public set cacheValidatedExpression(value: string) {
    this._cacheValidatedExpression = value;
  }
  public resetCacheValidatedExpression() {
    this._cacheValidatedExpression = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cacheValidatedExpressionInput() {
    return this._cacheValidatedExpression;
  }

  // concurrency - computed: true, optional: true, required: false
  private _concurrency?: number; 
  public get concurrency() {
    return this.getNumberAttribute('concurrency');
  }
  public set concurrency(value: number) {
    this._concurrency = value;
  }
  public resetConcurrency() {
    this._concurrency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get concurrencyInput() {
    return this._concurrency;
  }

  // connection_timeout - computed: true, optional: true, required: false
  private _connectionTimeout?: number; 
  public get connectionTimeout() {
    return this.getNumberAttribute('connection_timeout');
  }
  public set connectionTimeout(value: number) {
    this._connectionTimeout = value;
  }
  public resetConnectionTimeout() {
    this._connectionTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectionTimeoutInput() {
    return this._connectionTimeout;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // file_expression - computed: false, optional: true, required: false
  private _fileExpression?: string; 
  public get fileExpression() {
    return this.getStringAttribute('file_expression');
  }
  public set fileExpression(value: string) {
    this._fileExpression = value;
  }
  public resetFileExpression() {
    this._fileExpression = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fileExpressionInput() {
    return this._fileExpression;
  }

  // first_expression - computed: false, optional: true, required: false
  private _firstExpression?: string; 
  public get firstExpression() {
    return this.getStringAttribute('first_expression');
  }
  public set firstExpression(value: string) {
    this._firstExpression = value;
  }
  public resetFirstExpression() {
    this._firstExpression = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get firstExpressionInput() {
    return this._firstExpression;
  }

  // flush_period_sec - computed: true, optional: true, required: false
  private _flushPeriodSec?: number; 
  public get flushPeriodSec() {
    return this.getNumberAttribute('flush_period_sec');
  }
  public set flushPeriodSec(value: number) {
    this._flushPeriodSec = value;
  }
  public resetFlushPeriodSec() {
    this._flushPeriodSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get flushPeriodSecInput() {
    return this._flushPeriodSec;
  }

  // function_expression - computed: false, optional: true, required: false
  private _functionExpression?: string; 
  public get functionExpression() {
    return this.getStringAttribute('function_expression');
  }
  public set functionExpression(value: string) {
    this._functionExpression = value;
  }
  public resetFunctionExpression() {
    this._functionExpression = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get functionExpressionInput() {
    return this._functionExpression;
  }

  // google_auth_method - computed: true, optional: true, required: false
  private _googleAuthMethod?: string; 
  public get googleAuthMethod() {
    return this.getStringAttribute('google_auth_method');
  }
  public set googleAuthMethod(value: string) {
    this._googleAuthMethod = value;
  }
  public resetGoogleAuthMethod() {
    this._googleAuthMethod = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get googleAuthMethodInput() {
    return this._googleAuthMethod;
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // id_expression - computed: false, optional: true, required: false
  private _idExpression?: string; 
  public get idExpression() {
    return this.getStringAttribute('id_expression');
  }
  public set idExpression(value: string) {
    this._idExpression = value;
  }
  public resetIdExpression() {
    this._idExpression = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idExpressionInput() {
    return this._idExpression;
  }

  // index_expression - computed: false, optional: true, required: false
  private _indexExpression?: string; 
  public get indexExpression() {
    return this.getStringAttribute('index_expression');
  }
  public set indexExpression(value: string) {
    this._indexExpression = value;
  }
  public resetIndexExpression() {
    this._indexExpression = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get indexExpressionInput() {
    return this._indexExpression;
  }

  // insert_id_expression - computed: false, optional: true, required: false
  private _insertIdExpression?: string; 
  public get insertIdExpression() {
    return this.getStringAttribute('insert_id_expression');
  }
  public set insertIdExpression(value: string) {
    this._insertIdExpression = value;
  }
  public resetInsertIdExpression() {
    this._insertIdExpression = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get insertIdExpressionInput() {
    return this._insertIdExpression;
  }

  // last_expression - computed: false, optional: true, required: false
  private _lastExpression?: string; 
  public get lastExpression() {
    return this.getStringAttribute('last_expression');
  }
  public set lastExpression(value: string) {
    this._lastExpression = value;
  }
  public resetLastExpression() {
    this._lastExpression = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get lastExpressionInput() {
    return this._lastExpression;
  }

  // latency_expression - computed: false, optional: true, required: false
  private _latencyExpression?: string; 
  public get latencyExpression() {
    return this.getStringAttribute('latency_expression');
  }
  public set latencyExpression(value: string) {
    this._latencyExpression = value;
  }
  public resetLatencyExpression() {
    this._latencyExpression = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get latencyExpressionInput() {
    return this._latencyExpression;
  }

  // line_expression - computed: false, optional: true, required: false
  private _lineExpression?: string; 
  public get lineExpression() {
    return this.getStringAttribute('line_expression');
  }
  public set lineExpression(value: string) {
    this._lineExpression = value;
  }
  public resetLineExpression() {
    this._lineExpression = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get lineExpressionInput() {
    return this._lineExpression;
  }

  // log_labels - computed: false, optional: true, required: false
  private _logLabels = new PackDestinationOutputGoogleCloudLoggingLogLabelsList(this, "log_labels", false);
  public get logLabels() {
    return this._logLabels;
  }
  public putLogLabels(value: PackDestinationOutputGoogleCloudLoggingLogLabels[] | cdktf.IResolvable) {
    this._logLabels.internalValue = value;
  }
  public resetLogLabels() {
    this._logLabels.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get logLabelsInput() {
    return this._logLabels.internalValue;
  }

  // log_location_expression - computed: false, optional: false, required: true
  private _logLocationExpression?: string; 
  public get logLocationExpression() {
    return this.getStringAttribute('log_location_expression');
  }
  public set logLocationExpression(value: string) {
    this._logLocationExpression = value;
  }
  // Temporarily expose input value. Use with caution.
  public get logLocationExpressionInput() {
    return this._logLocationExpression;
  }

  // log_location_type - computed: false, optional: false, required: true
  private _logLocationType?: string; 
  public get logLocationType() {
    return this.getStringAttribute('log_location_type');
  }
  public set logLocationType(value: string) {
    this._logLocationType = value;
  }
  // Temporarily expose input value. Use with caution.
  public get logLocationTypeInput() {
    return this._logLocationType;
  }

  // log_name_expression - computed: false, optional: false, required: true
  private _logNameExpression?: string; 
  public get logNameExpression() {
    return this.getStringAttribute('log_name_expression');
  }
  public set logNameExpression(value: string) {
    this._logNameExpression = value;
  }
  // Temporarily expose input value. Use with caution.
  public get logNameExpressionInput() {
    return this._logNameExpression;
  }

  // max_payload_events - computed: true, optional: true, required: false
  private _maxPayloadEvents?: number; 
  public get maxPayloadEvents() {
    return this.getNumberAttribute('max_payload_events');
  }
  public set maxPayloadEvents(value: number) {
    this._maxPayloadEvents = value;
  }
  public resetMaxPayloadEvents() {
    this._maxPayloadEvents = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxPayloadEventsInput() {
    return this._maxPayloadEvents;
  }

  // max_payload_size_kb - computed: true, optional: true, required: false
  private _maxPayloadSizeKb?: number; 
  public get maxPayloadSizeKb() {
    return this.getNumberAttribute('max_payload_size_kb');
  }
  public set maxPayloadSizeKb(value: number) {
    this._maxPayloadSizeKb = value;
  }
  public resetMaxPayloadSizeKb() {
    this._maxPayloadSizeKb = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxPayloadSizeKbInput() {
    return this._maxPayloadSizeKb;
  }

  // on_backpressure - computed: true, optional: true, required: false
  private _onBackpressure?: string; 
  public get onBackpressure() {
    return this.getStringAttribute('on_backpressure');
  }
  public set onBackpressure(value: string) {
    this._onBackpressure = value;
  }
  public resetOnBackpressure() {
    this._onBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get onBackpressureInput() {
    return this._onBackpressure;
  }

  // payload_expression - computed: false, optional: true, required: false
  private _payloadExpression?: string; 
  public get payloadExpression() {
    return this.getStringAttribute('payload_expression');
  }
  public set payloadExpression(value: string) {
    this._payloadExpression = value;
  }
  public resetPayloadExpression() {
    this._payloadExpression = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get payloadExpressionInput() {
    return this._payloadExpression;
  }

  // payload_format - computed: true, optional: true, required: false
  private _payloadFormat?: string; 
  public get payloadFormat() {
    return this.getStringAttribute('payload_format');
  }
  public set payloadFormat(value: string) {
    this._payloadFormat = value;
  }
  public resetPayloadFormat() {
    this._payloadFormat = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get payloadFormatInput() {
    return this._payloadFormat;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // pq_compress - computed: true, optional: true, required: false
  private _pqCompress?: string; 
  public get pqCompress() {
    return this.getStringAttribute('pq_compress');
  }
  public set pqCompress(value: string) {
    this._pqCompress = value;
  }
  public resetPqCompress() {
    this._pqCompress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqCompressInput() {
    return this._pqCompress;
  }

  // pq_controls - computed: false, optional: true, required: false
  private _pqControls = new PackDestinationOutputGoogleCloudLoggingPqControlsOutputReference(this, "pq_controls");
  public get pqControls() {
    return this._pqControls;
  }
  public putPqControls(value: PackDestinationOutputGoogleCloudLoggingPqControls) {
    this._pqControls.internalValue = value;
  }
  public resetPqControls() {
    this._pqControls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqControlsInput() {
    return this._pqControls.internalValue;
  }

  // pq_max_file_size - computed: true, optional: true, required: false
  private _pqMaxFileSize?: string; 
  public get pqMaxFileSize() {
    return this.getStringAttribute('pq_max_file_size');
  }
  public set pqMaxFileSize(value: string) {
    this._pqMaxFileSize = value;
  }
  public resetPqMaxFileSize() {
    this._pqMaxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxFileSizeInput() {
    return this._pqMaxFileSize;
  }

  // pq_max_size - computed: true, optional: true, required: false
  private _pqMaxSize?: string; 
  public get pqMaxSize() {
    return this.getStringAttribute('pq_max_size');
  }
  public set pqMaxSize(value: string) {
    this._pqMaxSize = value;
  }
  public resetPqMaxSize() {
    this._pqMaxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxSizeInput() {
    return this._pqMaxSize;
  }

  // pq_mode - computed: true, optional: true, required: false
  private _pqMode?: string; 
  public get pqMode() {
    return this.getStringAttribute('pq_mode');
  }
  public set pqMode(value: string) {
    this._pqMode = value;
  }
  public resetPqMode() {
    this._pqMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqModeInput() {
    return this._pqMode;
  }

  // pq_on_backpressure - computed: true, optional: true, required: false
  private _pqOnBackpressure?: string; 
  public get pqOnBackpressure() {
    return this.getStringAttribute('pq_on_backpressure');
  }
  public set pqOnBackpressure(value: string) {
    this._pqOnBackpressure = value;
  }
  public resetPqOnBackpressure() {
    this._pqOnBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqOnBackpressureInput() {
    return this._pqOnBackpressure;
  }

  // pq_path - computed: true, optional: true, required: false
  private _pqPath?: string; 
  public get pqPath() {
    return this.getStringAttribute('pq_path');
  }
  public set pqPath(value: string) {
    this._pqPath = value;
  }
  public resetPqPath() {
    this._pqPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqPathInput() {
    return this._pqPath;
  }

  // producer_expression - computed: false, optional: true, required: false
  private _producerExpression?: string; 
  public get producerExpression() {
    return this.getStringAttribute('producer_expression');
  }
  public set producerExpression(value: string) {
    this._producerExpression = value;
  }
  public resetProducerExpression() {
    this._producerExpression = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get producerExpressionInput() {
    return this._producerExpression;
  }

  // protocol_expression - computed: false, optional: true, required: false
  private _protocolExpression?: string; 
  public get protocolExpression() {
    return this.getStringAttribute('protocol_expression');
  }
  public set protocolExpression(value: string) {
    this._protocolExpression = value;
  }
  public resetProtocolExpression() {
    this._protocolExpression = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get protocolExpressionInput() {
    return this._protocolExpression;
  }

  // referer_expression - computed: false, optional: true, required: false
  private _refererExpression?: string; 
  public get refererExpression() {
    return this.getStringAttribute('referer_expression');
  }
  public set refererExpression(value: string) {
    this._refererExpression = value;
  }
  public resetRefererExpression() {
    this._refererExpression = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get refererExpressionInput() {
    return this._refererExpression;
  }

  // remote_ip_expression - computed: false, optional: true, required: false
  private _remoteIpExpression?: string; 
  public get remoteIpExpression() {
    return this.getStringAttribute('remote_ip_expression');
  }
  public set remoteIpExpression(value: string) {
    this._remoteIpExpression = value;
  }
  public resetRemoteIpExpression() {
    this._remoteIpExpression = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get remoteIpExpressionInput() {
    return this._remoteIpExpression;
  }

  // request_method_expression - computed: false, optional: true, required: false
  private _requestMethodExpression?: string; 
  public get requestMethodExpression() {
    return this.getStringAttribute('request_method_expression');
  }
  public set requestMethodExpression(value: string) {
    this._requestMethodExpression = value;
  }
  public resetRequestMethodExpression() {
    this._requestMethodExpression = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestMethodExpressionInput() {
    return this._requestMethodExpression;
  }

  // request_size_expression - computed: false, optional: true, required: false
  private _requestSizeExpression?: string; 
  public get requestSizeExpression() {
    return this.getStringAttribute('request_size_expression');
  }
  public set requestSizeExpression(value: string) {
    this._requestSizeExpression = value;
  }
  public resetRequestSizeExpression() {
    this._requestSizeExpression = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestSizeExpressionInput() {
    return this._requestSizeExpression;
  }

  // request_url_expression - computed: false, optional: true, required: false
  private _requestUrlExpression?: string; 
  public get requestUrlExpression() {
    return this.getStringAttribute('request_url_expression');
  }
  public set requestUrlExpression(value: string) {
    this._requestUrlExpression = value;
  }
  public resetRequestUrlExpression() {
    this._requestUrlExpression = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestUrlExpressionInput() {
    return this._requestUrlExpression;
  }

  // resource_type_expression - computed: false, optional: true, required: false
  private _resourceTypeExpression?: string; 
  public get resourceTypeExpression() {
    return this.getStringAttribute('resource_type_expression');
  }
  public set resourceTypeExpression(value: string) {
    this._resourceTypeExpression = value;
  }
  public resetResourceTypeExpression() {
    this._resourceTypeExpression = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get resourceTypeExpressionInput() {
    return this._resourceTypeExpression;
  }

  // resource_type_labels - computed: false, optional: true, required: false
  private _resourceTypeLabels = new PackDestinationOutputGoogleCloudLoggingResourceTypeLabelsList(this, "resource_type_labels", false);
  public get resourceTypeLabels() {
    return this._resourceTypeLabels;
  }
  public putResourceTypeLabels(value: PackDestinationOutputGoogleCloudLoggingResourceTypeLabels[] | cdktf.IResolvable) {
    this._resourceTypeLabels.internalValue = value;
  }
  public resetResourceTypeLabels() {
    this._resourceTypeLabels.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get resourceTypeLabelsInput() {
    return this._resourceTypeLabels.internalValue;
  }

  // response_size_expression - computed: false, optional: true, required: false
  private _responseSizeExpression?: string; 
  public get responseSizeExpression() {
    return this.getStringAttribute('response_size_expression');
  }
  public set responseSizeExpression(value: string) {
    this._responseSizeExpression = value;
  }
  public resetResponseSizeExpression() {
    this._responseSizeExpression = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get responseSizeExpressionInput() {
    return this._responseSizeExpression;
  }

  // secret - computed: false, optional: true, required: false
  private _secret?: string; 
  public get secret() {
    return this.getStringAttribute('secret');
  }
  public set secret(value: string) {
    this._secret = value;
  }
  public resetSecret() {
    this._secret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretInput() {
    return this._secret;
  }

  // server_ip_expression - computed: false, optional: true, required: false
  private _serverIpExpression?: string; 
  public get serverIpExpression() {
    return this.getStringAttribute('server_ip_expression');
  }
  public set serverIpExpression(value: string) {
    this._serverIpExpression = value;
  }
  public resetServerIpExpression() {
    this._serverIpExpression = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serverIpExpressionInput() {
    return this._serverIpExpression;
  }

  // service_account_credentials - computed: false, optional: true, required: false
  private _serviceAccountCredentials?: string; 
  public get serviceAccountCredentials() {
    return this.getStringAttribute('service_account_credentials');
  }
  public set serviceAccountCredentials(value: string) {
    this._serviceAccountCredentials = value;
  }
  public resetServiceAccountCredentials() {
    this._serviceAccountCredentials = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serviceAccountCredentialsInput() {
    return this._serviceAccountCredentials;
  }

  // severity_expression - computed: false, optional: true, required: false
  private _severityExpression?: string; 
  public get severityExpression() {
    return this.getStringAttribute('severity_expression');
  }
  public set severityExpression(value: string) {
    this._severityExpression = value;
  }
  public resetSeverityExpression() {
    this._severityExpression = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get severityExpressionInput() {
    return this._severityExpression;
  }

  // span_id_expression - computed: false, optional: true, required: false
  private _spanIdExpression?: string; 
  public get spanIdExpression() {
    return this.getStringAttribute('span_id_expression');
  }
  public set spanIdExpression(value: string) {
    this._spanIdExpression = value;
  }
  public resetSpanIdExpression() {
    this._spanIdExpression = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get spanIdExpressionInput() {
    return this._spanIdExpression;
  }

  // status_expression - computed: false, optional: true, required: false
  private _statusExpression?: string; 
  public get statusExpression() {
    return this.getStringAttribute('status_expression');
  }
  public set statusExpression(value: string) {
    this._statusExpression = value;
  }
  public resetStatusExpression() {
    this._statusExpression = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get statusExpressionInput() {
    return this._statusExpression;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // system_fields - computed: true, optional: true, required: false
  private _systemFields?: string[]; 
  public get systemFields() {
    return this.getListAttribute('system_fields');
  }
  public set systemFields(value: string[]) {
    this._systemFields = value;
  }
  public resetSystemFields() {
    this._systemFields = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get systemFieldsInput() {
    return this._systemFields;
  }

  // throttle_rate_req_per_sec - computed: false, optional: true, required: false
  private _throttleRateReqPerSec?: number; 
  public get throttleRateReqPerSec() {
    return this.getNumberAttribute('throttle_rate_req_per_sec');
  }
  public set throttleRateReqPerSec(value: number) {
    this._throttleRateReqPerSec = value;
  }
  public resetThrottleRateReqPerSec() {
    this._throttleRateReqPerSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get throttleRateReqPerSecInput() {
    return this._throttleRateReqPerSec;
  }

  // timeout_sec - computed: true, optional: true, required: false
  private _timeoutSec?: number; 
  public get timeoutSec() {
    return this.getNumberAttribute('timeout_sec');
  }
  public set timeoutSec(value: number) {
    this._timeoutSec = value;
  }
  public resetTimeoutSec() {
    this._timeoutSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutSecInput() {
    return this._timeoutSec;
  }

  // total_memory_limit_kb - computed: false, optional: true, required: false
  private _totalMemoryLimitKb?: number; 
  public get totalMemoryLimitKb() {
    return this.getNumberAttribute('total_memory_limit_kb');
  }
  public set totalMemoryLimitKb(value: number) {
    this._totalMemoryLimitKb = value;
  }
  public resetTotalMemoryLimitKb() {
    this._totalMemoryLimitKb = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get totalMemoryLimitKbInput() {
    return this._totalMemoryLimitKb;
  }

  // total_splits_expression - computed: false, optional: true, required: false
  private _totalSplitsExpression?: string; 
  public get totalSplitsExpression() {
    return this.getStringAttribute('total_splits_expression');
  }
  public set totalSplitsExpression(value: string) {
    this._totalSplitsExpression = value;
  }
  public resetTotalSplitsExpression() {
    this._totalSplitsExpression = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get totalSplitsExpressionInput() {
    return this._totalSplitsExpression;
  }

  // trace_expression - computed: false, optional: true, required: false
  private _traceExpression?: string; 
  public get traceExpression() {
    return this.getStringAttribute('trace_expression');
  }
  public set traceExpression(value: string) {
    this._traceExpression = value;
  }
  public resetTraceExpression() {
    this._traceExpression = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get traceExpressionInput() {
    return this._traceExpression;
  }

  // trace_sampled_expression - computed: false, optional: true, required: false
  private _traceSampledExpression?: string; 
  public get traceSampledExpression() {
    return this.getStringAttribute('trace_sampled_expression');
  }
  public set traceSampledExpression(value: string) {
    this._traceSampledExpression = value;
  }
  public resetTraceSampledExpression() {
    this._traceSampledExpression = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get traceSampledExpressionInput() {
    return this._traceSampledExpression;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // uid_expression - computed: false, optional: true, required: false
  private _uidExpression?: string; 
  public get uidExpression() {
    return this.getStringAttribute('uid_expression');
  }
  public set uidExpression(value: string) {
    this._uidExpression = value;
  }
  public resetUidExpression() {
    this._uidExpression = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get uidExpressionInput() {
    return this._uidExpression;
  }

  // user_agent_expression - computed: false, optional: true, required: false
  private _userAgentExpression?: string; 
  public get userAgentExpression() {
    return this.getStringAttribute('user_agent_expression');
  }
  public set userAgentExpression(value: string) {
    this._userAgentExpression = value;
  }
  public resetUserAgentExpression() {
    this._userAgentExpression = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get userAgentExpressionInput() {
    return this._userAgentExpression;
  }
}
export interface PackDestinationOutputGoogleCloudStorageKeyValueMetadata {
  /**
  * Default: ""
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#key PackDestination#key}
  */
  readonly key?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#value PackDestination#value}
  */
  readonly value: string;
}

export function packDestinationOutputGoogleCloudStorageKeyValueMetadataToTerraform(struct?: PackDestinationOutputGoogleCloudStorageKeyValueMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function packDestinationOutputGoogleCloudStorageKeyValueMetadataToHclTerraform(struct?: PackDestinationOutputGoogleCloudStorageKeyValueMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputGoogleCloudStorageKeyValueMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackDestinationOutputGoogleCloudStorageKeyValueMetadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputGoogleCloudStorageKeyValueMetadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._value = value.value;
    }
  }

  // key - computed: true, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class PackDestinationOutputGoogleCloudStorageKeyValueMetadataList extends cdktf.ComplexList {
  public internalValue? : PackDestinationOutputGoogleCloudStorageKeyValueMetadata[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackDestinationOutputGoogleCloudStorageKeyValueMetadataOutputReference {
    return new PackDestinationOutputGoogleCloudStorageKeyValueMetadataOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackDestinationOutputGoogleCloudStorage {
  /**
  * Add the Output ID value to staging location. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#add_id_to_stage_path PackDestination#add_id_to_stage_path}
  */
  readonly addIdToStagePath?: boolean | cdktf.IResolvable;
  /**
  * Automatically calculate the schema based on the events of each Parquet file generated. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#automatic_schema PackDestination#automatic_schema}
  */
  readonly automaticSchema?: boolean | cdktf.IResolvable;
  /**
  * HMAC access key. This value can be a constant or a JavaScript expression, such as `${C.env.GCS_ACCESS_KEY}`.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#aws_api_key PackDestination#aws_api_key}
  */
  readonly awsApiKey?: string;
  /**
  * Default: "manual"; must be one of ["auto", "manual", "secret"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#aws_authentication_method PackDestination#aws_authentication_method}
  */
  readonly awsAuthenticationMethod?: string;
  /**
  * Select or create a stored secret that references your access key and secret key
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#aws_secret PackDestination#aws_secret}
  */
  readonly awsSecret?: string;
  /**
  * HMAC secret. This value can be a constant or a JavaScript expression, such as `${C.env.GCS_SECRET}`.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#aws_secret_key PackDestination#aws_secret_key}
  */
  readonly awsSecretKey?: string;
  /**
  * JavaScript expression to define the output filename prefix (can be constant). Default: "`CriblOut`"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#base_file_name PackDestination#base_file_name}
  */
  readonly baseFileName?: string;
  /**
  * Name of the destination bucket. This value can be a constant or a JavaScript expression that can only be evaluated at init time. Example of referencing a Global Variable: `myBucket-${C.vars.myVar}`.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#bucket PackDestination#bucket}
  */
  readonly bucket: string;
  /**
  * Data compression format to apply to HTTP content before it is delivered. Default: "gzip"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#compress PackDestination#compress}
  */
  readonly compress?: string;
  /**
  * Compression level to apply before moving files to final destination. Default: "best_speed"; must be one of ["best_speed", "normal", "best_compression"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#compression_level PackDestination#compression_level}
  */
  readonly compressionLevel?: string;
  /**
  * If a file fails to move to its final destination after the maximum number of retries, move it to a designated directory to prevent further errors. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#deadletter_enabled PackDestination#deadletter_enabled}
  */
  readonly deadletterEnabled?: boolean | cdktf.IResolvable;
  /**
  * Storage location for files that fail to reach their final destination after maximum retries are exceeded. Default: "$CRIBL_HOME/state/outputs/dead-letter"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#deadletter_path PackDestination#deadletter_path}
  */
  readonly deadletterPath?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#description PackDestination#description}
  */
  readonly description?: string;
  /**
  * Prefix to append to files before uploading. Must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can be evaluated only at init time. Example referencing a Global Variable: `myKeyPrefix-${C.vars.myVar}`. Default: ""
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#dest_path PackDestination#dest_path}
  */
  readonly destPath?: string;
  /**
  * How frequently, in seconds, to clean up empty directories. Default: 300
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#empty_dir_cleanup_sec PackDestination#empty_dir_cleanup_sec}
  */
  readonly emptyDirCleanupSec?: number;
  /**
  * Parquet tools can use the checksum of a Parquet page to verify data integrity. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#enable_page_checksum PackDestination#enable_page_checksum}
  */
  readonly enablePageChecksum?: boolean | cdktf.IResolvable;
  /**
  * Statistics profile an entire file in terms of minimum/maximum values within data, numbers of nulls, etc. You can use Parquet tools to view statistics. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#enable_statistics PackDestination#enable_statistics}
  */
  readonly enableStatistics?: boolean | cdktf.IResolvable;
  /**
  * One page index contains statistics for one data page. Parquet readers use statistics to enable page skipping. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#enable_write_page_index PackDestination#enable_write_page_index}
  */
  readonly enableWritePageIndex?: boolean | cdktf.IResolvable;
  /**
  * Google Cloud Storage service endpoint. Default: "https://storage.googleapis.com"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#endpoint PackDestination#endpoint}
  */
  readonly endpoint?: string;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#environment PackDestination#environment}
  */
  readonly environment?: string;
  /**
  * JavaScript expression to define the output filename suffix (can be constant).  The `__format` variable refers to the value of the `Data format` field (`json` or `raw`).  The `__compression` field refers to the kind of compression being used (`none` or `gzip`). Default: "`.${C.env[\"CRIBL_WORKER_ID\"]}.${__format}${__compression === \"gzip\" ? \".gz\" : \"\"}`"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#file_name_suffix PackDestination#file_name_suffix}
  */
  readonly fileNameSuffix?: string;
  /**
  * Format of the output data. Default: "json"; must be one of ["json", "raw", "parquet"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#format PackDestination#format}
  */
  readonly format?: string;
  /**
  * If set, this line will be written to the beginning of each output file. Default: ""
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#header_line PackDestination#header_line}
  */
  readonly headerLine?: string;
  /**
  * Unique ID for this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#id PackDestination#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * The metadata of files the Destination writes will include the properties you add here as key-value pairs. Useful for tagging. Examples: "key":"OCSF Event Class", "value":"9001"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#key_value_metadata PackDestination#key_value_metadata}
  */
  readonly keyValueMetadata?: PackDestinationOutputGoogleCloudStorageKeyValueMetadata[] | cdktf.IResolvable;
  /**
  * Maximum amount of time to keep inactive files open. Files open for longer than this will be closed and moved to final output location. Default: 30
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_file_idle_time_sec PackDestination#max_file_idle_time_sec}
  */
  readonly maxFileIdleTimeSec?: number;
  /**
  * Maximum amount of time to write to a file. Files open for longer than this will be closed and moved to final output location. Default: 300
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_file_open_time_sec PackDestination#max_file_open_time_sec}
  */
  readonly maxFileOpenTimeSec?: number;
  /**
  * Maximum uncompressed output file size. Files of this size will be closed and moved to final output location. Default: 32
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_file_size_mb PackDestination#max_file_size_mb}
  */
  readonly maxFileSizeMb?: number;
  /**
  * Maximum number of files to keep open concurrently. When exceeded, @{product} will close the oldest open files and move them to the final output location. Default: 100
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_open_files PackDestination#max_open_files}
  */
  readonly maxOpenFiles?: number;
  /**
  * The maximum number of times a file will attempt to move to its final destination before being dead-lettered. Default: 20
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_retry_num PackDestination#max_retry_num}
  */
  readonly maxRetryNum?: number;
  /**
  * Object ACL to assign to uploaded objects. Default: "private"; must be one of ["private", "bucket-owner-read", "bucket-owner-full-control", "project-private", "authenticated-read", "public-read"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#object_acl PackDestination#object_acl}
  */
  readonly objectAcl?: string;
  /**
  * How to handle events when all receivers are exerting backpressure. Default: "block"; must be one of ["block", "drop"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#on_backpressure PackDestination#on_backpressure}
  */
  readonly onBackpressure?: string;
  /**
  * How to handle events when disk space is below the global 'Min free disk space' limit. Default: "block"; must be one of ["block", "drop"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#on_disk_full_backpressure PackDestination#on_disk_full_backpressure}
  */
  readonly onDiskFullBackpressure?: string;
  /**
  * Serialization format of data pages. Note that some reader implementations use Data page V2's attributes to work more efficiently, while others ignore it. Default: "DATA_PAGE_V2"; must be one of ["DATA_PAGE_V1", "DATA_PAGE_V2"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#parquet_data_page_version PackDestination#parquet_data_page_version}
  */
  readonly parquetDataPageVersion?: string;
  /**
  * Target memory size for page segments, such as 1MB or 128MB. Generally, lower values improve reading speed, while higher values improve compression. Default: "1MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#parquet_page_size PackDestination#parquet_page_size}
  */
  readonly parquetPageSize?: string;
  /**
  * The number of rows that every group will contain. The final group can contain a smaller number of rows. Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#parquet_row_group_length PackDestination#parquet_row_group_length}
  */
  readonly parquetRowGroupLength?: number;
  /**
  * Determines which data types are supported and how they are represented. Default: "PARQUET_2_6"; must be one of ["PARQUET_1_0", "PARQUET_2_4", "PARQUET_2_6"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#parquet_version PackDestination#parquet_version}
  */
  readonly parquetVersion?: string;
  /**
  * JavaScript expression defining how files are partitioned and organized. Default is date-based. If blank, Stream will fall back to the event's __partition field value – if present – otherwise to each location's root directory. Default: "C.Time.strftime(_time ? _time : Date.now()/1000, '%Y/%m/%d')"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#partition_expr PackDestination#partition_expr}
  */
  readonly partitionExpr?: string;
  /**
  * Pipeline to process data before sending out to this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pipeline PackDestination#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Region where the bucket is located
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#region PackDestination#region}
  */
  readonly region: string;
  /**
  * Reject certificates that cannot be verified against a valid CA, such as self-signed certificates. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#reject_unauthorized PackDestination#reject_unauthorized}
  */
  readonly rejectUnauthorized?: boolean | cdktf.IResolvable;
  /**
  * Remove empty staging directories after moving files. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#remove_empty_dirs PackDestination#remove_empty_dirs}
  */
  readonly removeEmptyDirs?: boolean | cdktf.IResolvable;
  /**
  * Reuse connections between requests, which can improve performance. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#reuse_connections PackDestination#reuse_connections}
  */
  readonly reuseConnections?: boolean | cdktf.IResolvable;
  /**
  * Log up to 3 rows that @{product} skips due to data mismatch
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#should_log_invalid_rows PackDestination#should_log_invalid_rows}
  */
  readonly shouldLogInvalidRows?: boolean | cdktf.IResolvable;
  /**
  * Signature version to use for signing Google Cloud Storage requests. Default: "v4"; must be one of ["v2", "v4"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#signature_version PackDestination#signature_version}
  */
  readonly signatureVersion?: string;
  /**
  * Filesystem location in which to buffer files, before compressing and moving to final destination. Use performant and stable storage. Default: "$CRIBL_HOME/state/outputs/staging"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#stage_path PackDestination#stage_path}
  */
  readonly stagePath?: string;
  /**
  * Storage class to select for uploaded objects. must be one of ["STANDARD", "NEARLINE", "COLDLINE", "ARCHIVE"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#storage_class PackDestination#storage_class}
  */
  readonly storageClass?: string;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#streamtags PackDestination#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Fields to automatically add to events, such as cribl_pipe. Supports wildcards. Default: ["cribl_pipe"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#system_fields PackDestination#system_fields}
  */
  readonly systemFields?: string[];
  /**
  * must be "google_cloud_storage"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#type PackDestination#type}
  */
  readonly type?: string;
  /**
  * Disable if you can access files within the bucket but not the bucket itself. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#verify_permissions PackDestination#verify_permissions}
  */
  readonly verifyPermissions?: boolean | cdktf.IResolvable;
  /**
  * Buffer size used to write to a file. Default: 64
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#write_high_water_mark PackDestination#write_high_water_mark}
  */
  readonly writeHighWaterMark?: number;
}

export function packDestinationOutputGoogleCloudStorageToTerraform(struct?: PackDestinationOutputGoogleCloudStorage | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    add_id_to_stage_path: cdktf.booleanToTerraform(struct!.addIdToStagePath),
    automatic_schema: cdktf.booleanToTerraform(struct!.automaticSchema),
    aws_api_key: cdktf.stringToTerraform(struct!.awsApiKey),
    aws_authentication_method: cdktf.stringToTerraform(struct!.awsAuthenticationMethod),
    aws_secret: cdktf.stringToTerraform(struct!.awsSecret),
    aws_secret_key: cdktf.stringToTerraform(struct!.awsSecretKey),
    base_file_name: cdktf.stringToTerraform(struct!.baseFileName),
    bucket: cdktf.stringToTerraform(struct!.bucket),
    compress: cdktf.stringToTerraform(struct!.compress),
    compression_level: cdktf.stringToTerraform(struct!.compressionLevel),
    deadletter_enabled: cdktf.booleanToTerraform(struct!.deadletterEnabled),
    deadletter_path: cdktf.stringToTerraform(struct!.deadletterPath),
    description: cdktf.stringToTerraform(struct!.description),
    dest_path: cdktf.stringToTerraform(struct!.destPath),
    empty_dir_cleanup_sec: cdktf.numberToTerraform(struct!.emptyDirCleanupSec),
    enable_page_checksum: cdktf.booleanToTerraform(struct!.enablePageChecksum),
    enable_statistics: cdktf.booleanToTerraform(struct!.enableStatistics),
    enable_write_page_index: cdktf.booleanToTerraform(struct!.enableWritePageIndex),
    endpoint: cdktf.stringToTerraform(struct!.endpoint),
    environment: cdktf.stringToTerraform(struct!.environment),
    file_name_suffix: cdktf.stringToTerraform(struct!.fileNameSuffix),
    format: cdktf.stringToTerraform(struct!.format),
    header_line: cdktf.stringToTerraform(struct!.headerLine),
    id: cdktf.stringToTerraform(struct!.id),
    key_value_metadata: cdktf.listMapper(packDestinationOutputGoogleCloudStorageKeyValueMetadataToTerraform, false)(struct!.keyValueMetadata),
    max_file_idle_time_sec: cdktf.numberToTerraform(struct!.maxFileIdleTimeSec),
    max_file_open_time_sec: cdktf.numberToTerraform(struct!.maxFileOpenTimeSec),
    max_file_size_mb: cdktf.numberToTerraform(struct!.maxFileSizeMb),
    max_open_files: cdktf.numberToTerraform(struct!.maxOpenFiles),
    max_retry_num: cdktf.numberToTerraform(struct!.maxRetryNum),
    object_acl: cdktf.stringToTerraform(struct!.objectAcl),
    on_backpressure: cdktf.stringToTerraform(struct!.onBackpressure),
    on_disk_full_backpressure: cdktf.stringToTerraform(struct!.onDiskFullBackpressure),
    parquet_data_page_version: cdktf.stringToTerraform(struct!.parquetDataPageVersion),
    parquet_page_size: cdktf.stringToTerraform(struct!.parquetPageSize),
    parquet_row_group_length: cdktf.numberToTerraform(struct!.parquetRowGroupLength),
    parquet_version: cdktf.stringToTerraform(struct!.parquetVersion),
    partition_expr: cdktf.stringToTerraform(struct!.partitionExpr),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    region: cdktf.stringToTerraform(struct!.region),
    reject_unauthorized: cdktf.booleanToTerraform(struct!.rejectUnauthorized),
    remove_empty_dirs: cdktf.booleanToTerraform(struct!.removeEmptyDirs),
    reuse_connections: cdktf.booleanToTerraform(struct!.reuseConnections),
    should_log_invalid_rows: cdktf.booleanToTerraform(struct!.shouldLogInvalidRows),
    signature_version: cdktf.stringToTerraform(struct!.signatureVersion),
    stage_path: cdktf.stringToTerraform(struct!.stagePath),
    storage_class: cdktf.stringToTerraform(struct!.storageClass),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    system_fields: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.systemFields),
    type: cdktf.stringToTerraform(struct!.type),
    verify_permissions: cdktf.booleanToTerraform(struct!.verifyPermissions),
    write_high_water_mark: cdktf.numberToTerraform(struct!.writeHighWaterMark),
  }
}


export function packDestinationOutputGoogleCloudStorageToHclTerraform(struct?: PackDestinationOutputGoogleCloudStorage | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    add_id_to_stage_path: {
      value: cdktf.booleanToHclTerraform(struct!.addIdToStagePath),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    automatic_schema: {
      value: cdktf.booleanToHclTerraform(struct!.automaticSchema),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    aws_api_key: {
      value: cdktf.stringToHclTerraform(struct!.awsApiKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    aws_authentication_method: {
      value: cdktf.stringToHclTerraform(struct!.awsAuthenticationMethod),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    aws_secret: {
      value: cdktf.stringToHclTerraform(struct!.awsSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    aws_secret_key: {
      value: cdktf.stringToHclTerraform(struct!.awsSecretKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    base_file_name: {
      value: cdktf.stringToHclTerraform(struct!.baseFileName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    bucket: {
      value: cdktf.stringToHclTerraform(struct!.bucket),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    compress: {
      value: cdktf.stringToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    compression_level: {
      value: cdktf.stringToHclTerraform(struct!.compressionLevel),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    deadletter_enabled: {
      value: cdktf.booleanToHclTerraform(struct!.deadletterEnabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    deadletter_path: {
      value: cdktf.stringToHclTerraform(struct!.deadletterPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    dest_path: {
      value: cdktf.stringToHclTerraform(struct!.destPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    empty_dir_cleanup_sec: {
      value: cdktf.numberToHclTerraform(struct!.emptyDirCleanupSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    enable_page_checksum: {
      value: cdktf.booleanToHclTerraform(struct!.enablePageChecksum),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    enable_statistics: {
      value: cdktf.booleanToHclTerraform(struct!.enableStatistics),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    enable_write_page_index: {
      value: cdktf.booleanToHclTerraform(struct!.enableWritePageIndex),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    endpoint: {
      value: cdktf.stringToHclTerraform(struct!.endpoint),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    file_name_suffix: {
      value: cdktf.stringToHclTerraform(struct!.fileNameSuffix),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    format: {
      value: cdktf.stringToHclTerraform(struct!.format),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    header_line: {
      value: cdktf.stringToHclTerraform(struct!.headerLine),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    key_value_metadata: {
      value: cdktf.listMapperHcl(packDestinationOutputGoogleCloudStorageKeyValueMetadataToHclTerraform, false)(struct!.keyValueMetadata),
      isBlock: true,
      type: "list",
      storageClassType: "PackDestinationOutputGoogleCloudStorageKeyValueMetadataList",
    },
    max_file_idle_time_sec: {
      value: cdktf.numberToHclTerraform(struct!.maxFileIdleTimeSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_file_open_time_sec: {
      value: cdktf.numberToHclTerraform(struct!.maxFileOpenTimeSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_file_size_mb: {
      value: cdktf.numberToHclTerraform(struct!.maxFileSizeMb),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_open_files: {
      value: cdktf.numberToHclTerraform(struct!.maxOpenFiles),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_retry_num: {
      value: cdktf.numberToHclTerraform(struct!.maxRetryNum),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    object_acl: {
      value: cdktf.stringToHclTerraform(struct!.objectAcl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.onBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    on_disk_full_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.onDiskFullBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    parquet_data_page_version: {
      value: cdktf.stringToHclTerraform(struct!.parquetDataPageVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    parquet_page_size: {
      value: cdktf.stringToHclTerraform(struct!.parquetPageSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    parquet_row_group_length: {
      value: cdktf.numberToHclTerraform(struct!.parquetRowGroupLength),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    parquet_version: {
      value: cdktf.stringToHclTerraform(struct!.parquetVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    partition_expr: {
      value: cdktf.stringToHclTerraform(struct!.partitionExpr),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    region: {
      value: cdktf.stringToHclTerraform(struct!.region),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reject_unauthorized: {
      value: cdktf.booleanToHclTerraform(struct!.rejectUnauthorized),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    remove_empty_dirs: {
      value: cdktf.booleanToHclTerraform(struct!.removeEmptyDirs),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    reuse_connections: {
      value: cdktf.booleanToHclTerraform(struct!.reuseConnections),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    should_log_invalid_rows: {
      value: cdktf.booleanToHclTerraform(struct!.shouldLogInvalidRows),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    signature_version: {
      value: cdktf.stringToHclTerraform(struct!.signatureVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    stage_path: {
      value: cdktf.stringToHclTerraform(struct!.stagePath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    storage_class: {
      value: cdktf.stringToHclTerraform(struct!.storageClass),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    system_fields: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.systemFields),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    verify_permissions: {
      value: cdktf.booleanToHclTerraform(struct!.verifyPermissions),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    write_high_water_mark: {
      value: cdktf.numberToHclTerraform(struct!.writeHighWaterMark),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputGoogleCloudStorageOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackDestinationOutputGoogleCloudStorage | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._addIdToStagePath !== undefined) {
      hasAnyValues = true;
      internalValueResult.addIdToStagePath = this._addIdToStagePath;
    }
    if (this._automaticSchema !== undefined) {
      hasAnyValues = true;
      internalValueResult.automaticSchema = this._automaticSchema;
    }
    if (this._awsApiKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.awsApiKey = this._awsApiKey;
    }
    if (this._awsAuthenticationMethod !== undefined) {
      hasAnyValues = true;
      internalValueResult.awsAuthenticationMethod = this._awsAuthenticationMethod;
    }
    if (this._awsSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.awsSecret = this._awsSecret;
    }
    if (this._awsSecretKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.awsSecretKey = this._awsSecretKey;
    }
    if (this._baseFileName !== undefined) {
      hasAnyValues = true;
      internalValueResult.baseFileName = this._baseFileName;
    }
    if (this._bucket !== undefined) {
      hasAnyValues = true;
      internalValueResult.bucket = this._bucket;
    }
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._compressionLevel !== undefined) {
      hasAnyValues = true;
      internalValueResult.compressionLevel = this._compressionLevel;
    }
    if (this._deadletterEnabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.deadletterEnabled = this._deadletterEnabled;
    }
    if (this._deadletterPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.deadletterPath = this._deadletterPath;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._destPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.destPath = this._destPath;
    }
    if (this._emptyDirCleanupSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.emptyDirCleanupSec = this._emptyDirCleanupSec;
    }
    if (this._enablePageChecksum !== undefined) {
      hasAnyValues = true;
      internalValueResult.enablePageChecksum = this._enablePageChecksum;
    }
    if (this._enableStatistics !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableStatistics = this._enableStatistics;
    }
    if (this._enableWritePageIndex !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableWritePageIndex = this._enableWritePageIndex;
    }
    if (this._endpoint !== undefined) {
      hasAnyValues = true;
      internalValueResult.endpoint = this._endpoint;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._fileNameSuffix !== undefined) {
      hasAnyValues = true;
      internalValueResult.fileNameSuffix = this._fileNameSuffix;
    }
    if (this._format !== undefined) {
      hasAnyValues = true;
      internalValueResult.format = this._format;
    }
    if (this._headerLine !== undefined) {
      hasAnyValues = true;
      internalValueResult.headerLine = this._headerLine;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._keyValueMetadata?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.keyValueMetadata = this._keyValueMetadata?.internalValue;
    }
    if (this._maxFileIdleTimeSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxFileIdleTimeSec = this._maxFileIdleTimeSec;
    }
    if (this._maxFileOpenTimeSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxFileOpenTimeSec = this._maxFileOpenTimeSec;
    }
    if (this._maxFileSizeMb !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxFileSizeMb = this._maxFileSizeMb;
    }
    if (this._maxOpenFiles !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxOpenFiles = this._maxOpenFiles;
    }
    if (this._maxRetryNum !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxRetryNum = this._maxRetryNum;
    }
    if (this._objectAcl !== undefined) {
      hasAnyValues = true;
      internalValueResult.objectAcl = this._objectAcl;
    }
    if (this._onBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.onBackpressure = this._onBackpressure;
    }
    if (this._onDiskFullBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.onDiskFullBackpressure = this._onDiskFullBackpressure;
    }
    if (this._parquetDataPageVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.parquetDataPageVersion = this._parquetDataPageVersion;
    }
    if (this._parquetPageSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.parquetPageSize = this._parquetPageSize;
    }
    if (this._parquetRowGroupLength !== undefined) {
      hasAnyValues = true;
      internalValueResult.parquetRowGroupLength = this._parquetRowGroupLength;
    }
    if (this._parquetVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.parquetVersion = this._parquetVersion;
    }
    if (this._partitionExpr !== undefined) {
      hasAnyValues = true;
      internalValueResult.partitionExpr = this._partitionExpr;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._region !== undefined) {
      hasAnyValues = true;
      internalValueResult.region = this._region;
    }
    if (this._rejectUnauthorized !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectUnauthorized = this._rejectUnauthorized;
    }
    if (this._removeEmptyDirs !== undefined) {
      hasAnyValues = true;
      internalValueResult.removeEmptyDirs = this._removeEmptyDirs;
    }
    if (this._reuseConnections !== undefined) {
      hasAnyValues = true;
      internalValueResult.reuseConnections = this._reuseConnections;
    }
    if (this._shouldLogInvalidRows !== undefined) {
      hasAnyValues = true;
      internalValueResult.shouldLogInvalidRows = this._shouldLogInvalidRows;
    }
    if (this._signatureVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.signatureVersion = this._signatureVersion;
    }
    if (this._stagePath !== undefined) {
      hasAnyValues = true;
      internalValueResult.stagePath = this._stagePath;
    }
    if (this._storageClass !== undefined) {
      hasAnyValues = true;
      internalValueResult.storageClass = this._storageClass;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._systemFields !== undefined) {
      hasAnyValues = true;
      internalValueResult.systemFields = this._systemFields;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._verifyPermissions !== undefined) {
      hasAnyValues = true;
      internalValueResult.verifyPermissions = this._verifyPermissions;
    }
    if (this._writeHighWaterMark !== undefined) {
      hasAnyValues = true;
      internalValueResult.writeHighWaterMark = this._writeHighWaterMark;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputGoogleCloudStorage | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._addIdToStagePath = undefined;
      this._automaticSchema = undefined;
      this._awsApiKey = undefined;
      this._awsAuthenticationMethod = undefined;
      this._awsSecret = undefined;
      this._awsSecretKey = undefined;
      this._baseFileName = undefined;
      this._bucket = undefined;
      this._compress = undefined;
      this._compressionLevel = undefined;
      this._deadletterEnabled = undefined;
      this._deadletterPath = undefined;
      this._description = undefined;
      this._destPath = undefined;
      this._emptyDirCleanupSec = undefined;
      this._enablePageChecksum = undefined;
      this._enableStatistics = undefined;
      this._enableWritePageIndex = undefined;
      this._endpoint = undefined;
      this._environment = undefined;
      this._fileNameSuffix = undefined;
      this._format = undefined;
      this._headerLine = undefined;
      this._id = undefined;
      this._keyValueMetadata.internalValue = undefined;
      this._maxFileIdleTimeSec = undefined;
      this._maxFileOpenTimeSec = undefined;
      this._maxFileSizeMb = undefined;
      this._maxOpenFiles = undefined;
      this._maxRetryNum = undefined;
      this._objectAcl = undefined;
      this._onBackpressure = undefined;
      this._onDiskFullBackpressure = undefined;
      this._parquetDataPageVersion = undefined;
      this._parquetPageSize = undefined;
      this._parquetRowGroupLength = undefined;
      this._parquetVersion = undefined;
      this._partitionExpr = undefined;
      this._pipeline = undefined;
      this._region = undefined;
      this._rejectUnauthorized = undefined;
      this._removeEmptyDirs = undefined;
      this._reuseConnections = undefined;
      this._shouldLogInvalidRows = undefined;
      this._signatureVersion = undefined;
      this._stagePath = undefined;
      this._storageClass = undefined;
      this._streamtags = undefined;
      this._systemFields = undefined;
      this._type = undefined;
      this._verifyPermissions = undefined;
      this._writeHighWaterMark = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._addIdToStagePath = value.addIdToStagePath;
      this._automaticSchema = value.automaticSchema;
      this._awsApiKey = value.awsApiKey;
      this._awsAuthenticationMethod = value.awsAuthenticationMethod;
      this._awsSecret = value.awsSecret;
      this._awsSecretKey = value.awsSecretKey;
      this._baseFileName = value.baseFileName;
      this._bucket = value.bucket;
      this._compress = value.compress;
      this._compressionLevel = value.compressionLevel;
      this._deadletterEnabled = value.deadletterEnabled;
      this._deadletterPath = value.deadletterPath;
      this._description = value.description;
      this._destPath = value.destPath;
      this._emptyDirCleanupSec = value.emptyDirCleanupSec;
      this._enablePageChecksum = value.enablePageChecksum;
      this._enableStatistics = value.enableStatistics;
      this._enableWritePageIndex = value.enableWritePageIndex;
      this._endpoint = value.endpoint;
      this._environment = value.environment;
      this._fileNameSuffix = value.fileNameSuffix;
      this._format = value.format;
      this._headerLine = value.headerLine;
      this._id = value.id;
      this._keyValueMetadata.internalValue = value.keyValueMetadata;
      this._maxFileIdleTimeSec = value.maxFileIdleTimeSec;
      this._maxFileOpenTimeSec = value.maxFileOpenTimeSec;
      this._maxFileSizeMb = value.maxFileSizeMb;
      this._maxOpenFiles = value.maxOpenFiles;
      this._maxRetryNum = value.maxRetryNum;
      this._objectAcl = value.objectAcl;
      this._onBackpressure = value.onBackpressure;
      this._onDiskFullBackpressure = value.onDiskFullBackpressure;
      this._parquetDataPageVersion = value.parquetDataPageVersion;
      this._parquetPageSize = value.parquetPageSize;
      this._parquetRowGroupLength = value.parquetRowGroupLength;
      this._parquetVersion = value.parquetVersion;
      this._partitionExpr = value.partitionExpr;
      this._pipeline = value.pipeline;
      this._region = value.region;
      this._rejectUnauthorized = value.rejectUnauthorized;
      this._removeEmptyDirs = value.removeEmptyDirs;
      this._reuseConnections = value.reuseConnections;
      this._shouldLogInvalidRows = value.shouldLogInvalidRows;
      this._signatureVersion = value.signatureVersion;
      this._stagePath = value.stagePath;
      this._storageClass = value.storageClass;
      this._streamtags = value.streamtags;
      this._systemFields = value.systemFields;
      this._type = value.type;
      this._verifyPermissions = value.verifyPermissions;
      this._writeHighWaterMark = value.writeHighWaterMark;
    }
  }

  // add_id_to_stage_path - computed: true, optional: true, required: false
  private _addIdToStagePath?: boolean | cdktf.IResolvable; 
  public get addIdToStagePath() {
    return this.getBooleanAttribute('add_id_to_stage_path');
  }
  public set addIdToStagePath(value: boolean | cdktf.IResolvable) {
    this._addIdToStagePath = value;
  }
  public resetAddIdToStagePath() {
    this._addIdToStagePath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addIdToStagePathInput() {
    return this._addIdToStagePath;
  }

  // automatic_schema - computed: true, optional: true, required: false
  private _automaticSchema?: boolean | cdktf.IResolvable; 
  public get automaticSchema() {
    return this.getBooleanAttribute('automatic_schema');
  }
  public set automaticSchema(value: boolean | cdktf.IResolvable) {
    this._automaticSchema = value;
  }
  public resetAutomaticSchema() {
    this._automaticSchema = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get automaticSchemaInput() {
    return this._automaticSchema;
  }

  // aws_api_key - computed: false, optional: true, required: false
  private _awsApiKey?: string; 
  public get awsApiKey() {
    return this.getStringAttribute('aws_api_key');
  }
  public set awsApiKey(value: string) {
    this._awsApiKey = value;
  }
  public resetAwsApiKey() {
    this._awsApiKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsApiKeyInput() {
    return this._awsApiKey;
  }

  // aws_authentication_method - computed: true, optional: true, required: false
  private _awsAuthenticationMethod?: string; 
  public get awsAuthenticationMethod() {
    return this.getStringAttribute('aws_authentication_method');
  }
  public set awsAuthenticationMethod(value: string) {
    this._awsAuthenticationMethod = value;
  }
  public resetAwsAuthenticationMethod() {
    this._awsAuthenticationMethod = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsAuthenticationMethodInput() {
    return this._awsAuthenticationMethod;
  }

  // aws_secret - computed: false, optional: true, required: false
  private _awsSecret?: string; 
  public get awsSecret() {
    return this.getStringAttribute('aws_secret');
  }
  public set awsSecret(value: string) {
    this._awsSecret = value;
  }
  public resetAwsSecret() {
    this._awsSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsSecretInput() {
    return this._awsSecret;
  }

  // aws_secret_key - computed: false, optional: true, required: false
  private _awsSecretKey?: string; 
  public get awsSecretKey() {
    return this.getStringAttribute('aws_secret_key');
  }
  public set awsSecretKey(value: string) {
    this._awsSecretKey = value;
  }
  public resetAwsSecretKey() {
    this._awsSecretKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsSecretKeyInput() {
    return this._awsSecretKey;
  }

  // base_file_name - computed: true, optional: true, required: false
  private _baseFileName?: string; 
  public get baseFileName() {
    return this.getStringAttribute('base_file_name');
  }
  public set baseFileName(value: string) {
    this._baseFileName = value;
  }
  public resetBaseFileName() {
    this._baseFileName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get baseFileNameInput() {
    return this._baseFileName;
  }

  // bucket - computed: false, optional: false, required: true
  private _bucket?: string; 
  public get bucket() {
    return this.getStringAttribute('bucket');
  }
  public set bucket(value: string) {
    this._bucket = value;
  }
  // Temporarily expose input value. Use with caution.
  public get bucketInput() {
    return this._bucket;
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: string; 
  public get compress() {
    return this.getStringAttribute('compress');
  }
  public set compress(value: string) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // compression_level - computed: true, optional: true, required: false
  private _compressionLevel?: string; 
  public get compressionLevel() {
    return this.getStringAttribute('compression_level');
  }
  public set compressionLevel(value: string) {
    this._compressionLevel = value;
  }
  public resetCompressionLevel() {
    this._compressionLevel = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressionLevelInput() {
    return this._compressionLevel;
  }

  // deadletter_enabled - computed: true, optional: true, required: false
  private _deadletterEnabled?: boolean | cdktf.IResolvable; 
  public get deadletterEnabled() {
    return this.getBooleanAttribute('deadletter_enabled');
  }
  public set deadletterEnabled(value: boolean | cdktf.IResolvable) {
    this._deadletterEnabled = value;
  }
  public resetDeadletterEnabled() {
    this._deadletterEnabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get deadletterEnabledInput() {
    return this._deadletterEnabled;
  }

  // deadletter_path - computed: true, optional: true, required: false
  private _deadletterPath?: string; 
  public get deadletterPath() {
    return this.getStringAttribute('deadletter_path');
  }
  public set deadletterPath(value: string) {
    this._deadletterPath = value;
  }
  public resetDeadletterPath() {
    this._deadletterPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get deadletterPathInput() {
    return this._deadletterPath;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // dest_path - computed: true, optional: true, required: false
  private _destPath?: string; 
  public get destPath() {
    return this.getStringAttribute('dest_path');
  }
  public set destPath(value: string) {
    this._destPath = value;
  }
  public resetDestPath() {
    this._destPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get destPathInput() {
    return this._destPath;
  }

  // empty_dir_cleanup_sec - computed: true, optional: true, required: false
  private _emptyDirCleanupSec?: number; 
  public get emptyDirCleanupSec() {
    return this.getNumberAttribute('empty_dir_cleanup_sec');
  }
  public set emptyDirCleanupSec(value: number) {
    this._emptyDirCleanupSec = value;
  }
  public resetEmptyDirCleanupSec() {
    this._emptyDirCleanupSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get emptyDirCleanupSecInput() {
    return this._emptyDirCleanupSec;
  }

  // enable_page_checksum - computed: true, optional: true, required: false
  private _enablePageChecksum?: boolean | cdktf.IResolvable; 
  public get enablePageChecksum() {
    return this.getBooleanAttribute('enable_page_checksum');
  }
  public set enablePageChecksum(value: boolean | cdktf.IResolvable) {
    this._enablePageChecksum = value;
  }
  public resetEnablePageChecksum() {
    this._enablePageChecksum = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enablePageChecksumInput() {
    return this._enablePageChecksum;
  }

  // enable_statistics - computed: true, optional: true, required: false
  private _enableStatistics?: boolean | cdktf.IResolvable; 
  public get enableStatistics() {
    return this.getBooleanAttribute('enable_statistics');
  }
  public set enableStatistics(value: boolean | cdktf.IResolvable) {
    this._enableStatistics = value;
  }
  public resetEnableStatistics() {
    this._enableStatistics = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableStatisticsInput() {
    return this._enableStatistics;
  }

  // enable_write_page_index - computed: true, optional: true, required: false
  private _enableWritePageIndex?: boolean | cdktf.IResolvable; 
  public get enableWritePageIndex() {
    return this.getBooleanAttribute('enable_write_page_index');
  }
  public set enableWritePageIndex(value: boolean | cdktf.IResolvable) {
    this._enableWritePageIndex = value;
  }
  public resetEnableWritePageIndex() {
    this._enableWritePageIndex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableWritePageIndexInput() {
    return this._enableWritePageIndex;
  }

  // endpoint - computed: true, optional: true, required: false
  private _endpoint?: string; 
  public get endpoint() {
    return this.getStringAttribute('endpoint');
  }
  public set endpoint(value: string) {
    this._endpoint = value;
  }
  public resetEndpoint() {
    this._endpoint = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get endpointInput() {
    return this._endpoint;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // file_name_suffix - computed: true, optional: true, required: false
  private _fileNameSuffix?: string; 
  public get fileNameSuffix() {
    return this.getStringAttribute('file_name_suffix');
  }
  public set fileNameSuffix(value: string) {
    this._fileNameSuffix = value;
  }
  public resetFileNameSuffix() {
    this._fileNameSuffix = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fileNameSuffixInput() {
    return this._fileNameSuffix;
  }

  // format - computed: true, optional: true, required: false
  private _format?: string; 
  public get format() {
    return this.getStringAttribute('format');
  }
  public set format(value: string) {
    this._format = value;
  }
  public resetFormat() {
    this._format = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get formatInput() {
    return this._format;
  }

  // header_line - computed: true, optional: true, required: false
  private _headerLine?: string; 
  public get headerLine() {
    return this.getStringAttribute('header_line');
  }
  public set headerLine(value: string) {
    this._headerLine = value;
  }
  public resetHeaderLine() {
    this._headerLine = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get headerLineInput() {
    return this._headerLine;
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // key_value_metadata - computed: false, optional: true, required: false
  private _keyValueMetadata = new PackDestinationOutputGoogleCloudStorageKeyValueMetadataList(this, "key_value_metadata", false);
  public get keyValueMetadata() {
    return this._keyValueMetadata;
  }
  public putKeyValueMetadata(value: PackDestinationOutputGoogleCloudStorageKeyValueMetadata[] | cdktf.IResolvable) {
    this._keyValueMetadata.internalValue = value;
  }
  public resetKeyValueMetadata() {
    this._keyValueMetadata.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyValueMetadataInput() {
    return this._keyValueMetadata.internalValue;
  }

  // max_file_idle_time_sec - computed: true, optional: true, required: false
  private _maxFileIdleTimeSec?: number; 
  public get maxFileIdleTimeSec() {
    return this.getNumberAttribute('max_file_idle_time_sec');
  }
  public set maxFileIdleTimeSec(value: number) {
    this._maxFileIdleTimeSec = value;
  }
  public resetMaxFileIdleTimeSec() {
    this._maxFileIdleTimeSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxFileIdleTimeSecInput() {
    return this._maxFileIdleTimeSec;
  }

  // max_file_open_time_sec - computed: true, optional: true, required: false
  private _maxFileOpenTimeSec?: number; 
  public get maxFileOpenTimeSec() {
    return this.getNumberAttribute('max_file_open_time_sec');
  }
  public set maxFileOpenTimeSec(value: number) {
    this._maxFileOpenTimeSec = value;
  }
  public resetMaxFileOpenTimeSec() {
    this._maxFileOpenTimeSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxFileOpenTimeSecInput() {
    return this._maxFileOpenTimeSec;
  }

  // max_file_size_mb - computed: true, optional: true, required: false
  private _maxFileSizeMb?: number; 
  public get maxFileSizeMb() {
    return this.getNumberAttribute('max_file_size_mb');
  }
  public set maxFileSizeMb(value: number) {
    this._maxFileSizeMb = value;
  }
  public resetMaxFileSizeMb() {
    this._maxFileSizeMb = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxFileSizeMbInput() {
    return this._maxFileSizeMb;
  }

  // max_open_files - computed: true, optional: true, required: false
  private _maxOpenFiles?: number; 
  public get maxOpenFiles() {
    return this.getNumberAttribute('max_open_files');
  }
  public set maxOpenFiles(value: number) {
    this._maxOpenFiles = value;
  }
  public resetMaxOpenFiles() {
    this._maxOpenFiles = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxOpenFilesInput() {
    return this._maxOpenFiles;
  }

  // max_retry_num - computed: true, optional: true, required: false
  private _maxRetryNum?: number; 
  public get maxRetryNum() {
    return this.getNumberAttribute('max_retry_num');
  }
  public set maxRetryNum(value: number) {
    this._maxRetryNum = value;
  }
  public resetMaxRetryNum() {
    this._maxRetryNum = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxRetryNumInput() {
    return this._maxRetryNum;
  }

  // object_acl - computed: true, optional: true, required: false
  private _objectAcl?: string; 
  public get objectAcl() {
    return this.getStringAttribute('object_acl');
  }
  public set objectAcl(value: string) {
    this._objectAcl = value;
  }
  public resetObjectAcl() {
    this._objectAcl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get objectAclInput() {
    return this._objectAcl;
  }

  // on_backpressure - computed: true, optional: true, required: false
  private _onBackpressure?: string; 
  public get onBackpressure() {
    return this.getStringAttribute('on_backpressure');
  }
  public set onBackpressure(value: string) {
    this._onBackpressure = value;
  }
  public resetOnBackpressure() {
    this._onBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get onBackpressureInput() {
    return this._onBackpressure;
  }

  // on_disk_full_backpressure - computed: true, optional: true, required: false
  private _onDiskFullBackpressure?: string; 
  public get onDiskFullBackpressure() {
    return this.getStringAttribute('on_disk_full_backpressure');
  }
  public set onDiskFullBackpressure(value: string) {
    this._onDiskFullBackpressure = value;
  }
  public resetOnDiskFullBackpressure() {
    this._onDiskFullBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get onDiskFullBackpressureInput() {
    return this._onDiskFullBackpressure;
  }

  // parquet_data_page_version - computed: true, optional: true, required: false
  private _parquetDataPageVersion?: string; 
  public get parquetDataPageVersion() {
    return this.getStringAttribute('parquet_data_page_version');
  }
  public set parquetDataPageVersion(value: string) {
    this._parquetDataPageVersion = value;
  }
  public resetParquetDataPageVersion() {
    this._parquetDataPageVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get parquetDataPageVersionInput() {
    return this._parquetDataPageVersion;
  }

  // parquet_page_size - computed: true, optional: true, required: false
  private _parquetPageSize?: string; 
  public get parquetPageSize() {
    return this.getStringAttribute('parquet_page_size');
  }
  public set parquetPageSize(value: string) {
    this._parquetPageSize = value;
  }
  public resetParquetPageSize() {
    this._parquetPageSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get parquetPageSizeInput() {
    return this._parquetPageSize;
  }

  // parquet_row_group_length - computed: true, optional: true, required: false
  private _parquetRowGroupLength?: number; 
  public get parquetRowGroupLength() {
    return this.getNumberAttribute('parquet_row_group_length');
  }
  public set parquetRowGroupLength(value: number) {
    this._parquetRowGroupLength = value;
  }
  public resetParquetRowGroupLength() {
    this._parquetRowGroupLength = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get parquetRowGroupLengthInput() {
    return this._parquetRowGroupLength;
  }

  // parquet_version - computed: true, optional: true, required: false
  private _parquetVersion?: string; 
  public get parquetVersion() {
    return this.getStringAttribute('parquet_version');
  }
  public set parquetVersion(value: string) {
    this._parquetVersion = value;
  }
  public resetParquetVersion() {
    this._parquetVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get parquetVersionInput() {
    return this._parquetVersion;
  }

  // partition_expr - computed: true, optional: true, required: false
  private _partitionExpr?: string; 
  public get partitionExpr() {
    return this.getStringAttribute('partition_expr');
  }
  public set partitionExpr(value: string) {
    this._partitionExpr = value;
  }
  public resetPartitionExpr() {
    this._partitionExpr = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get partitionExprInput() {
    return this._partitionExpr;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // region - computed: false, optional: false, required: true
  private _region?: string; 
  public get region() {
    return this.getStringAttribute('region');
  }
  public set region(value: string) {
    this._region = value;
  }
  // Temporarily expose input value. Use with caution.
  public get regionInput() {
    return this._region;
  }

  // reject_unauthorized - computed: true, optional: true, required: false
  private _rejectUnauthorized?: boolean | cdktf.IResolvable; 
  public get rejectUnauthorized() {
    return this.getBooleanAttribute('reject_unauthorized');
  }
  public set rejectUnauthorized(value: boolean | cdktf.IResolvable) {
    this._rejectUnauthorized = value;
  }
  public resetRejectUnauthorized() {
    this._rejectUnauthorized = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectUnauthorizedInput() {
    return this._rejectUnauthorized;
  }

  // remove_empty_dirs - computed: true, optional: true, required: false
  private _removeEmptyDirs?: boolean | cdktf.IResolvable; 
  public get removeEmptyDirs() {
    return this.getBooleanAttribute('remove_empty_dirs');
  }
  public set removeEmptyDirs(value: boolean | cdktf.IResolvable) {
    this._removeEmptyDirs = value;
  }
  public resetRemoveEmptyDirs() {
    this._removeEmptyDirs = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get removeEmptyDirsInput() {
    return this._removeEmptyDirs;
  }

  // reuse_connections - computed: true, optional: true, required: false
  private _reuseConnections?: boolean | cdktf.IResolvable; 
  public get reuseConnections() {
    return this.getBooleanAttribute('reuse_connections');
  }
  public set reuseConnections(value: boolean | cdktf.IResolvable) {
    this._reuseConnections = value;
  }
  public resetReuseConnections() {
    this._reuseConnections = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get reuseConnectionsInput() {
    return this._reuseConnections;
  }

  // should_log_invalid_rows - computed: false, optional: true, required: false
  private _shouldLogInvalidRows?: boolean | cdktf.IResolvable; 
  public get shouldLogInvalidRows() {
    return this.getBooleanAttribute('should_log_invalid_rows');
  }
  public set shouldLogInvalidRows(value: boolean | cdktf.IResolvable) {
    this._shouldLogInvalidRows = value;
  }
  public resetShouldLogInvalidRows() {
    this._shouldLogInvalidRows = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get shouldLogInvalidRowsInput() {
    return this._shouldLogInvalidRows;
  }

  // signature_version - computed: true, optional: true, required: false
  private _signatureVersion?: string; 
  public get signatureVersion() {
    return this.getStringAttribute('signature_version');
  }
  public set signatureVersion(value: string) {
    this._signatureVersion = value;
  }
  public resetSignatureVersion() {
    this._signatureVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get signatureVersionInput() {
    return this._signatureVersion;
  }

  // stage_path - computed: true, optional: true, required: false
  private _stagePath?: string; 
  public get stagePath() {
    return this.getStringAttribute('stage_path');
  }
  public set stagePath(value: string) {
    this._stagePath = value;
  }
  public resetStagePath() {
    this._stagePath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get stagePathInput() {
    return this._stagePath;
  }

  // storage_class - computed: false, optional: true, required: false
  private _storageClass?: string; 
  public get storageClass() {
    return this.getStringAttribute('storage_class');
  }
  public set storageClass(value: string) {
    this._storageClass = value;
  }
  public resetStorageClass() {
    this._storageClass = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get storageClassInput() {
    return this._storageClass;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // system_fields - computed: true, optional: true, required: false
  private _systemFields?: string[]; 
  public get systemFields() {
    return this.getListAttribute('system_fields');
  }
  public set systemFields(value: string[]) {
    this._systemFields = value;
  }
  public resetSystemFields() {
    this._systemFields = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get systemFieldsInput() {
    return this._systemFields;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // verify_permissions - computed: true, optional: true, required: false
  private _verifyPermissions?: boolean | cdktf.IResolvable; 
  public get verifyPermissions() {
    return this.getBooleanAttribute('verify_permissions');
  }
  public set verifyPermissions(value: boolean | cdktf.IResolvable) {
    this._verifyPermissions = value;
  }
  public resetVerifyPermissions() {
    this._verifyPermissions = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get verifyPermissionsInput() {
    return this._verifyPermissions;
  }

  // write_high_water_mark - computed: true, optional: true, required: false
  private _writeHighWaterMark?: number; 
  public get writeHighWaterMark() {
    return this.getNumberAttribute('write_high_water_mark');
  }
  public set writeHighWaterMark(value: number) {
    this._writeHighWaterMark = value;
  }
  public resetWriteHighWaterMark() {
    this._writeHighWaterMark = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get writeHighWaterMarkInput() {
    return this._writeHighWaterMark;
  }
}
export interface PackDestinationOutputGooglePubsubPqControls {
}

export function packDestinationOutputGooglePubsubPqControlsToTerraform(struct?: PackDestinationOutputGooglePubsubPqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function packDestinationOutputGooglePubsubPqControlsToHclTerraform(struct?: PackDestinationOutputGooglePubsubPqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class PackDestinationOutputGooglePubsubPqControlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackDestinationOutputGooglePubsubPqControls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputGooglePubsubPqControls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface PackDestinationOutputGooglePubsub {
  /**
  * The maximum number of items the Google API should batch before it sends them to the topic. Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#batch_size PackDestination#batch_size}
  */
  readonly batchSize?: number;
  /**
  * The maximum amount of time, in milliseconds, that the Google API should wait to send a batch (if the Batch size is not reached). Default: 100
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#batch_timeout PackDestination#batch_timeout}
  */
  readonly batchTimeout?: number;
  /**
  * If enabled, create topic if it does not exist. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#create_topic PackDestination#create_topic}
  */
  readonly createTopic?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#description PackDestination#description}
  */
  readonly description?: string;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#environment PackDestination#environment}
  */
  readonly environment?: string;
  /**
  * Maximum time to wait before sending a batch (when batch size limit is not reached). Default: 1
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#flush_period_sec PackDestination#flush_period_sec}
  */
  readonly flushPeriodSec?: number;
  /**
  * Choose Auto to use Google Application Default Credentials (ADC), Manual to enter Google service account credentials directly, or Secret to select or create a stored secret that references Google service account credentials. Default: "manual"; must be one of ["auto", "manual", "secret"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#google_auth_method PackDestination#google_auth_method}
  */
  readonly googleAuthMethod?: string;
  /**
  * Unique ID for this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#id PackDestination#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * The maximum number of in-progress API requests before backpressure is applied. Default: 10
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_in_progress PackDestination#max_in_progress}
  */
  readonly maxInProgress?: number;
  /**
  * Maximum number of queued batches before blocking. Default: 100
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_queue_size PackDestination#max_queue_size}
  */
  readonly maxQueueSize?: number;
  /**
  * Maximum size (KB) of batches to send. Default: 256
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_record_size_kb PackDestination#max_record_size_kb}
  */
  readonly maxRecordSizeKb?: number;
  /**
  * How to handle events when all receivers are exerting backpressure. Default: "block"; must be one of ["block", "drop", "queue"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#on_backpressure PackDestination#on_backpressure}
  */
  readonly onBackpressure?: string;
  /**
  * If enabled, send events in the order they were added to the queue. For this to work correctly, the process receiving events must have ordering enabled. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#ordered_delivery PackDestination#ordered_delivery}
  */
  readonly orderedDelivery?: boolean | cdktf.IResolvable;
  /**
  * Pipeline to process data before sending out to this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pipeline PackDestination#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_compress PackDestination#pq_compress}
  */
  readonly pqCompress?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_controls PackDestination#pq_controls}
  */
  readonly pqControls?: PackDestinationOutputGooglePubsubPqControls;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.). Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_max_file_size PackDestination#pq_max_file_size}
  */
  readonly pqMaxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_max_size PackDestination#pq_max_size}
  */
  readonly pqMaxSize?: string;
  /**
  * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem. Default: "error"; must be one of ["error", "backpressure", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_mode PackDestination#pq_mode}
  */
  readonly pqMode?: string;
  /**
  * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged. Default: "block"; must be one of ["block", "drop"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_on_backpressure PackDestination#pq_on_backpressure}
  */
  readonly pqOnBackpressure?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_path PackDestination#pq_path}
  */
  readonly pqPath?: string;
  /**
  * Region to publish messages to. Select 'default' to allow Google to auto-select the nearest region. When using ordered delivery, the selected region must be allowed by message storage policy.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#region PackDestination#region}
  */
  readonly region?: string;
  /**
  * Select or create a stored text secret
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#secret PackDestination#secret}
  */
  readonly secret?: string;
  /**
  * Contents of service account credentials (JSON keys) file downloaded from Google Cloud. To upload a file, click the upload button at this field's upper right.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#service_account_credentials PackDestination#service_account_credentials}
  */
  readonly serviceAccountCredentials?: string;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#streamtags PackDestination#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Fields to automatically add to events, such as cribl_pipe. Supports wildcards. Default: ["cribl_pipe"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#system_fields PackDestination#system_fields}
  */
  readonly systemFields?: string[];
  /**
  * ID of the topic to send events to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#topic_name PackDestination#topic_name}
  */
  readonly topicName: string;
  /**
  * must be "google_pubsub"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#type PackDestination#type}
  */
  readonly type: string;
}

export function packDestinationOutputGooglePubsubToTerraform(struct?: PackDestinationOutputGooglePubsub | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    batch_size: cdktf.numberToTerraform(struct!.batchSize),
    batch_timeout: cdktf.numberToTerraform(struct!.batchTimeout),
    create_topic: cdktf.booleanToTerraform(struct!.createTopic),
    description: cdktf.stringToTerraform(struct!.description),
    environment: cdktf.stringToTerraform(struct!.environment),
    flush_period_sec: cdktf.numberToTerraform(struct!.flushPeriodSec),
    google_auth_method: cdktf.stringToTerraform(struct!.googleAuthMethod),
    id: cdktf.stringToTerraform(struct!.id),
    max_in_progress: cdktf.numberToTerraform(struct!.maxInProgress),
    max_queue_size: cdktf.numberToTerraform(struct!.maxQueueSize),
    max_record_size_kb: cdktf.numberToTerraform(struct!.maxRecordSizeKb),
    on_backpressure: cdktf.stringToTerraform(struct!.onBackpressure),
    ordered_delivery: cdktf.booleanToTerraform(struct!.orderedDelivery),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    pq_compress: cdktf.stringToTerraform(struct!.pqCompress),
    pq_controls: packDestinationOutputGooglePubsubPqControlsToTerraform(struct!.pqControls),
    pq_max_file_size: cdktf.stringToTerraform(struct!.pqMaxFileSize),
    pq_max_size: cdktf.stringToTerraform(struct!.pqMaxSize),
    pq_mode: cdktf.stringToTerraform(struct!.pqMode),
    pq_on_backpressure: cdktf.stringToTerraform(struct!.pqOnBackpressure),
    pq_path: cdktf.stringToTerraform(struct!.pqPath),
    region: cdktf.stringToTerraform(struct!.region),
    secret: cdktf.stringToTerraform(struct!.secret),
    service_account_credentials: cdktf.stringToTerraform(struct!.serviceAccountCredentials),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    system_fields: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.systemFields),
    topic_name: cdktf.stringToTerraform(struct!.topicName),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function packDestinationOutputGooglePubsubToHclTerraform(struct?: PackDestinationOutputGooglePubsub | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    batch_size: {
      value: cdktf.numberToHclTerraform(struct!.batchSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    batch_timeout: {
      value: cdktf.numberToHclTerraform(struct!.batchTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    create_topic: {
      value: cdktf.booleanToHclTerraform(struct!.createTopic),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    flush_period_sec: {
      value: cdktf.numberToHclTerraform(struct!.flushPeriodSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    google_auth_method: {
      value: cdktf.stringToHclTerraform(struct!.googleAuthMethod),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_in_progress: {
      value: cdktf.numberToHclTerraform(struct!.maxInProgress),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_queue_size: {
      value: cdktf.numberToHclTerraform(struct!.maxQueueSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_record_size_kb: {
      value: cdktf.numberToHclTerraform(struct!.maxRecordSizeKb),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.onBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ordered_delivery: {
      value: cdktf.booleanToHclTerraform(struct!.orderedDelivery),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_compress: {
      value: cdktf.stringToHclTerraform(struct!.pqCompress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_controls: {
      value: packDestinationOutputGooglePubsubPqControlsToHclTerraform(struct!.pqControls),
      isBlock: true,
      type: "struct",
      storageClassType: "PackDestinationOutputGooglePubsubPqControls",
    },
    pq_max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_max_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_mode: {
      value: cdktf.stringToHclTerraform(struct!.pqMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.pqOnBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_path: {
      value: cdktf.stringToHclTerraform(struct!.pqPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    region: {
      value: cdktf.stringToHclTerraform(struct!.region),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret: {
      value: cdktf.stringToHclTerraform(struct!.secret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    service_account_credentials: {
      value: cdktf.stringToHclTerraform(struct!.serviceAccountCredentials),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    system_fields: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.systemFields),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    topic_name: {
      value: cdktf.stringToHclTerraform(struct!.topicName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputGooglePubsubOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackDestinationOutputGooglePubsub | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._batchSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.batchSize = this._batchSize;
    }
    if (this._batchTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.batchTimeout = this._batchTimeout;
    }
    if (this._createTopic !== undefined) {
      hasAnyValues = true;
      internalValueResult.createTopic = this._createTopic;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._flushPeriodSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.flushPeriodSec = this._flushPeriodSec;
    }
    if (this._googleAuthMethod !== undefined) {
      hasAnyValues = true;
      internalValueResult.googleAuthMethod = this._googleAuthMethod;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._maxInProgress !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxInProgress = this._maxInProgress;
    }
    if (this._maxQueueSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxQueueSize = this._maxQueueSize;
    }
    if (this._maxRecordSizeKb !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxRecordSizeKb = this._maxRecordSizeKb;
    }
    if (this._onBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.onBackpressure = this._onBackpressure;
    }
    if (this._orderedDelivery !== undefined) {
      hasAnyValues = true;
      internalValueResult.orderedDelivery = this._orderedDelivery;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._pqCompress !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqCompress = this._pqCompress;
    }
    if (this._pqControls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqControls = this._pqControls?.internalValue;
    }
    if (this._pqMaxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxFileSize = this._pqMaxFileSize;
    }
    if (this._pqMaxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxSize = this._pqMaxSize;
    }
    if (this._pqMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMode = this._pqMode;
    }
    if (this._pqOnBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqOnBackpressure = this._pqOnBackpressure;
    }
    if (this._pqPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqPath = this._pqPath;
    }
    if (this._region !== undefined) {
      hasAnyValues = true;
      internalValueResult.region = this._region;
    }
    if (this._secret !== undefined) {
      hasAnyValues = true;
      internalValueResult.secret = this._secret;
    }
    if (this._serviceAccountCredentials !== undefined) {
      hasAnyValues = true;
      internalValueResult.serviceAccountCredentials = this._serviceAccountCredentials;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._systemFields !== undefined) {
      hasAnyValues = true;
      internalValueResult.systemFields = this._systemFields;
    }
    if (this._topicName !== undefined) {
      hasAnyValues = true;
      internalValueResult.topicName = this._topicName;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputGooglePubsub | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._batchSize = undefined;
      this._batchTimeout = undefined;
      this._createTopic = undefined;
      this._description = undefined;
      this._environment = undefined;
      this._flushPeriodSec = undefined;
      this._googleAuthMethod = undefined;
      this._id = undefined;
      this._maxInProgress = undefined;
      this._maxQueueSize = undefined;
      this._maxRecordSizeKb = undefined;
      this._onBackpressure = undefined;
      this._orderedDelivery = undefined;
      this._pipeline = undefined;
      this._pqCompress = undefined;
      this._pqControls.internalValue = undefined;
      this._pqMaxFileSize = undefined;
      this._pqMaxSize = undefined;
      this._pqMode = undefined;
      this._pqOnBackpressure = undefined;
      this._pqPath = undefined;
      this._region = undefined;
      this._secret = undefined;
      this._serviceAccountCredentials = undefined;
      this._streamtags = undefined;
      this._systemFields = undefined;
      this._topicName = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._batchSize = value.batchSize;
      this._batchTimeout = value.batchTimeout;
      this._createTopic = value.createTopic;
      this._description = value.description;
      this._environment = value.environment;
      this._flushPeriodSec = value.flushPeriodSec;
      this._googleAuthMethod = value.googleAuthMethod;
      this._id = value.id;
      this._maxInProgress = value.maxInProgress;
      this._maxQueueSize = value.maxQueueSize;
      this._maxRecordSizeKb = value.maxRecordSizeKb;
      this._onBackpressure = value.onBackpressure;
      this._orderedDelivery = value.orderedDelivery;
      this._pipeline = value.pipeline;
      this._pqCompress = value.pqCompress;
      this._pqControls.internalValue = value.pqControls;
      this._pqMaxFileSize = value.pqMaxFileSize;
      this._pqMaxSize = value.pqMaxSize;
      this._pqMode = value.pqMode;
      this._pqOnBackpressure = value.pqOnBackpressure;
      this._pqPath = value.pqPath;
      this._region = value.region;
      this._secret = value.secret;
      this._serviceAccountCredentials = value.serviceAccountCredentials;
      this._streamtags = value.streamtags;
      this._systemFields = value.systemFields;
      this._topicName = value.topicName;
      this._type = value.type;
    }
  }

  // batch_size - computed: true, optional: true, required: false
  private _batchSize?: number; 
  public get batchSize() {
    return this.getNumberAttribute('batch_size');
  }
  public set batchSize(value: number) {
    this._batchSize = value;
  }
  public resetBatchSize() {
    this._batchSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get batchSizeInput() {
    return this._batchSize;
  }

  // batch_timeout - computed: true, optional: true, required: false
  private _batchTimeout?: number; 
  public get batchTimeout() {
    return this.getNumberAttribute('batch_timeout');
  }
  public set batchTimeout(value: number) {
    this._batchTimeout = value;
  }
  public resetBatchTimeout() {
    this._batchTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get batchTimeoutInput() {
    return this._batchTimeout;
  }

  // create_topic - computed: true, optional: true, required: false
  private _createTopic?: boolean | cdktf.IResolvable; 
  public get createTopic() {
    return this.getBooleanAttribute('create_topic');
  }
  public set createTopic(value: boolean | cdktf.IResolvable) {
    this._createTopic = value;
  }
  public resetCreateTopic() {
    this._createTopic = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get createTopicInput() {
    return this._createTopic;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // flush_period_sec - computed: true, optional: true, required: false
  private _flushPeriodSec?: number; 
  public get flushPeriodSec() {
    return this.getNumberAttribute('flush_period_sec');
  }
  public set flushPeriodSec(value: number) {
    this._flushPeriodSec = value;
  }
  public resetFlushPeriodSec() {
    this._flushPeriodSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get flushPeriodSecInput() {
    return this._flushPeriodSec;
  }

  // google_auth_method - computed: true, optional: true, required: false
  private _googleAuthMethod?: string; 
  public get googleAuthMethod() {
    return this.getStringAttribute('google_auth_method');
  }
  public set googleAuthMethod(value: string) {
    this._googleAuthMethod = value;
  }
  public resetGoogleAuthMethod() {
    this._googleAuthMethod = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get googleAuthMethodInput() {
    return this._googleAuthMethod;
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // max_in_progress - computed: true, optional: true, required: false
  private _maxInProgress?: number; 
  public get maxInProgress() {
    return this.getNumberAttribute('max_in_progress');
  }
  public set maxInProgress(value: number) {
    this._maxInProgress = value;
  }
  public resetMaxInProgress() {
    this._maxInProgress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxInProgressInput() {
    return this._maxInProgress;
  }

  // max_queue_size - computed: true, optional: true, required: false
  private _maxQueueSize?: number; 
  public get maxQueueSize() {
    return this.getNumberAttribute('max_queue_size');
  }
  public set maxQueueSize(value: number) {
    this._maxQueueSize = value;
  }
  public resetMaxQueueSize() {
    this._maxQueueSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxQueueSizeInput() {
    return this._maxQueueSize;
  }

  // max_record_size_kb - computed: true, optional: true, required: false
  private _maxRecordSizeKb?: number; 
  public get maxRecordSizeKb() {
    return this.getNumberAttribute('max_record_size_kb');
  }
  public set maxRecordSizeKb(value: number) {
    this._maxRecordSizeKb = value;
  }
  public resetMaxRecordSizeKb() {
    this._maxRecordSizeKb = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxRecordSizeKbInput() {
    return this._maxRecordSizeKb;
  }

  // on_backpressure - computed: true, optional: true, required: false
  private _onBackpressure?: string; 
  public get onBackpressure() {
    return this.getStringAttribute('on_backpressure');
  }
  public set onBackpressure(value: string) {
    this._onBackpressure = value;
  }
  public resetOnBackpressure() {
    this._onBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get onBackpressureInput() {
    return this._onBackpressure;
  }

  // ordered_delivery - computed: true, optional: true, required: false
  private _orderedDelivery?: boolean | cdktf.IResolvable; 
  public get orderedDelivery() {
    return this.getBooleanAttribute('ordered_delivery');
  }
  public set orderedDelivery(value: boolean | cdktf.IResolvable) {
    this._orderedDelivery = value;
  }
  public resetOrderedDelivery() {
    this._orderedDelivery = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get orderedDeliveryInput() {
    return this._orderedDelivery;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // pq_compress - computed: true, optional: true, required: false
  private _pqCompress?: string; 
  public get pqCompress() {
    return this.getStringAttribute('pq_compress');
  }
  public set pqCompress(value: string) {
    this._pqCompress = value;
  }
  public resetPqCompress() {
    this._pqCompress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqCompressInput() {
    return this._pqCompress;
  }

  // pq_controls - computed: false, optional: true, required: false
  private _pqControls = new PackDestinationOutputGooglePubsubPqControlsOutputReference(this, "pq_controls");
  public get pqControls() {
    return this._pqControls;
  }
  public putPqControls(value: PackDestinationOutputGooglePubsubPqControls) {
    this._pqControls.internalValue = value;
  }
  public resetPqControls() {
    this._pqControls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqControlsInput() {
    return this._pqControls.internalValue;
  }

  // pq_max_file_size - computed: true, optional: true, required: false
  private _pqMaxFileSize?: string; 
  public get pqMaxFileSize() {
    return this.getStringAttribute('pq_max_file_size');
  }
  public set pqMaxFileSize(value: string) {
    this._pqMaxFileSize = value;
  }
  public resetPqMaxFileSize() {
    this._pqMaxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxFileSizeInput() {
    return this._pqMaxFileSize;
  }

  // pq_max_size - computed: true, optional: true, required: false
  private _pqMaxSize?: string; 
  public get pqMaxSize() {
    return this.getStringAttribute('pq_max_size');
  }
  public set pqMaxSize(value: string) {
    this._pqMaxSize = value;
  }
  public resetPqMaxSize() {
    this._pqMaxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxSizeInput() {
    return this._pqMaxSize;
  }

  // pq_mode - computed: true, optional: true, required: false
  private _pqMode?: string; 
  public get pqMode() {
    return this.getStringAttribute('pq_mode');
  }
  public set pqMode(value: string) {
    this._pqMode = value;
  }
  public resetPqMode() {
    this._pqMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqModeInput() {
    return this._pqMode;
  }

  // pq_on_backpressure - computed: true, optional: true, required: false
  private _pqOnBackpressure?: string; 
  public get pqOnBackpressure() {
    return this.getStringAttribute('pq_on_backpressure');
  }
  public set pqOnBackpressure(value: string) {
    this._pqOnBackpressure = value;
  }
  public resetPqOnBackpressure() {
    this._pqOnBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqOnBackpressureInput() {
    return this._pqOnBackpressure;
  }

  // pq_path - computed: true, optional: true, required: false
  private _pqPath?: string; 
  public get pqPath() {
    return this.getStringAttribute('pq_path');
  }
  public set pqPath(value: string) {
    this._pqPath = value;
  }
  public resetPqPath() {
    this._pqPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqPathInput() {
    return this._pqPath;
  }

  // region - computed: false, optional: true, required: false
  private _region?: string; 
  public get region() {
    return this.getStringAttribute('region');
  }
  public set region(value: string) {
    this._region = value;
  }
  public resetRegion() {
    this._region = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get regionInput() {
    return this._region;
  }

  // secret - computed: false, optional: true, required: false
  private _secret?: string; 
  public get secret() {
    return this.getStringAttribute('secret');
  }
  public set secret(value: string) {
    this._secret = value;
  }
  public resetSecret() {
    this._secret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretInput() {
    return this._secret;
  }

  // service_account_credentials - computed: false, optional: true, required: false
  private _serviceAccountCredentials?: string; 
  public get serviceAccountCredentials() {
    return this.getStringAttribute('service_account_credentials');
  }
  public set serviceAccountCredentials(value: string) {
    this._serviceAccountCredentials = value;
  }
  public resetServiceAccountCredentials() {
    this._serviceAccountCredentials = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serviceAccountCredentialsInput() {
    return this._serviceAccountCredentials;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // system_fields - computed: true, optional: true, required: false
  private _systemFields?: string[]; 
  public get systemFields() {
    return this.getListAttribute('system_fields');
  }
  public set systemFields(value: string[]) {
    this._systemFields = value;
  }
  public resetSystemFields() {
    this._systemFields = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get systemFieldsInput() {
    return this._systemFields;
  }

  // topic_name - computed: false, optional: false, required: true
  private _topicName?: string; 
  public get topicName() {
    return this.getStringAttribute('topic_name');
  }
  public set topicName(value: string) {
    this._topicName = value;
  }
  // Temporarily expose input value. Use with caution.
  public get topicNameInput() {
    return this._topicName;
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1ExtraHttpHeaders {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#name PackDestination#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#value PackDestination#value}
  */
  readonly value: string;
}

export function packDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1ExtraHttpHeadersToTerraform(struct?: PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1ExtraHttpHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function packDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1ExtraHttpHeadersToHclTerraform(struct?: PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1ExtraHttpHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1ExtraHttpHeadersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1ExtraHttpHeaders | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1ExtraHttpHeaders | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1ExtraHttpHeadersList extends cdktf.ComplexList {
  public internalValue? : PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1ExtraHttpHeaders[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1ExtraHttpHeadersOutputReference {
    return new PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1ExtraHttpHeadersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1Labels {
  /**
  * Default: ""
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#name PackDestination#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#value PackDestination#value}
  */
  readonly value: string;
}

export function packDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1LabelsToTerraform(struct?: PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1Labels | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function packDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1LabelsToHclTerraform(struct?: PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1Labels | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1LabelsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1Labels | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1Labels | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: true, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1LabelsList extends cdktf.ComplexList {
  public internalValue? : PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1Labels[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1LabelsOutputReference {
    return new PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1LabelsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1LokiAuth {
  /**
  * Default: "basic"; must be one of ["none", "token", "textSecret", "basic", "credentialsSecret"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#auth_type PackDestination#auth_type}
  */
  readonly authType?: string;
  /**
  * Select or create a secret that references your credentials
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#credentials_secret PackDestination#credentials_secret}
  */
  readonly credentialsSecret?: string;
  /**
  * Password (API key in Grafana Cloud domain) for authentication
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#password PackDestination#password}
  */
  readonly password?: string;
  /**
  * Select or create a stored text secret
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#text_secret PackDestination#text_secret}
  */
  readonly textSecret?: string;
  /**
  * Bearer token to include in the authorization header. In Grafana Cloud, this is generally built by concatenating the username and the API key, separated by a colon. Example: <your-username>:<your-api-key>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#token PackDestination#token}
  */
  readonly token?: string;
  /**
  * Username for authentication
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#username PackDestination#username}
  */
  readonly username?: string;
}

export function packDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1LokiAuthToTerraform(struct?: PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1LokiAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    auth_type: cdktf.stringToTerraform(struct!.authType),
    credentials_secret: cdktf.stringToTerraform(struct!.credentialsSecret),
    password: cdktf.stringToTerraform(struct!.password),
    text_secret: cdktf.stringToTerraform(struct!.textSecret),
    token: cdktf.stringToTerraform(struct!.token),
    username: cdktf.stringToTerraform(struct!.username),
  }
}


export function packDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1LokiAuthToHclTerraform(struct?: PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1LokiAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    auth_type: {
      value: cdktf.stringToHclTerraform(struct!.authType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    credentials_secret: {
      value: cdktf.stringToHclTerraform(struct!.credentialsSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    password: {
      value: cdktf.stringToHclTerraform(struct!.password),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    text_secret: {
      value: cdktf.stringToHclTerraform(struct!.textSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    token: {
      value: cdktf.stringToHclTerraform(struct!.token),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    username: {
      value: cdktf.stringToHclTerraform(struct!.username),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1LokiAuthOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1LokiAuth | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._authType !== undefined) {
      hasAnyValues = true;
      internalValueResult.authType = this._authType;
    }
    if (this._credentialsSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.credentialsSecret = this._credentialsSecret;
    }
    if (this._password !== undefined) {
      hasAnyValues = true;
      internalValueResult.password = this._password;
    }
    if (this._textSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.textSecret = this._textSecret;
    }
    if (this._token !== undefined) {
      hasAnyValues = true;
      internalValueResult.token = this._token;
    }
    if (this._username !== undefined) {
      hasAnyValues = true;
      internalValueResult.username = this._username;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1LokiAuth | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._authType = undefined;
      this._credentialsSecret = undefined;
      this._password = undefined;
      this._textSecret = undefined;
      this._token = undefined;
      this._username = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._authType = value.authType;
      this._credentialsSecret = value.credentialsSecret;
      this._password = value.password;
      this._textSecret = value.textSecret;
      this._token = value.token;
      this._username = value.username;
    }
  }

  // auth_type - computed: true, optional: true, required: false
  private _authType?: string; 
  public get authType() {
    return this.getStringAttribute('auth_type');
  }
  public set authType(value: string) {
    this._authType = value;
  }
  public resetAuthType() {
    this._authType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authTypeInput() {
    return this._authType;
  }

  // credentials_secret - computed: false, optional: true, required: false
  private _credentialsSecret?: string; 
  public get credentialsSecret() {
    return this.getStringAttribute('credentials_secret');
  }
  public set credentialsSecret(value: string) {
    this._credentialsSecret = value;
  }
  public resetCredentialsSecret() {
    this._credentialsSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get credentialsSecretInput() {
    return this._credentialsSecret;
  }

  // password - computed: false, optional: true, required: false
  private _password?: string; 
  public get password() {
    return this.getStringAttribute('password');
  }
  public set password(value: string) {
    this._password = value;
  }
  public resetPassword() {
    this._password = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passwordInput() {
    return this._password;
  }

  // text_secret - computed: false, optional: true, required: false
  private _textSecret?: string; 
  public get textSecret() {
    return this.getStringAttribute('text_secret');
  }
  public set textSecret(value: string) {
    this._textSecret = value;
  }
  public resetTextSecret() {
    this._textSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get textSecretInput() {
    return this._textSecret;
  }

  // token - computed: false, optional: true, required: false
  private _token?: string; 
  public get token() {
    return this.getStringAttribute('token');
  }
  public set token(value: string) {
    this._token = value;
  }
  public resetToken() {
    this._token = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tokenInput() {
    return this._token;
  }

  // username - computed: false, optional: true, required: false
  private _username?: string; 
  public get username() {
    return this.getStringAttribute('username');
  }
  public set username(value: string) {
    this._username = value;
  }
  public resetUsername() {
    this._username = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usernameInput() {
    return this._username;
  }
}
export interface PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1PqControls {
}

export function packDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1PqControlsToTerraform(struct?: PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1PqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function packDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1PqControlsToHclTerraform(struct?: PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1PqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1PqControlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1PqControls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1PqControls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1PrometheusAuth {
  /**
  * Default: "basic"; must be one of ["none", "token", "textSecret", "basic", "credentialsSecret"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#auth_type PackDestination#auth_type}
  */
  readonly authType?: string;
  /**
  * Select or create a secret that references your credentials
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#credentials_secret PackDestination#credentials_secret}
  */
  readonly credentialsSecret?: string;
  /**
  * Password (API key in Grafana Cloud domain) for authentication
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#password PackDestination#password}
  */
  readonly password?: string;
  /**
  * Select or create a stored text secret
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#text_secret PackDestination#text_secret}
  */
  readonly textSecret?: string;
  /**
  * Bearer token to include in the authorization header. In Grafana Cloud, this is generally built by concatenating the username and the API key, separated by a colon. Example: <your-username>:<your-api-key>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#token PackDestination#token}
  */
  readonly token?: string;
  /**
  * Username for authentication
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#username PackDestination#username}
  */
  readonly username?: string;
}

export function packDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1PrometheusAuthToTerraform(struct?: PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1PrometheusAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    auth_type: cdktf.stringToTerraform(struct!.authType),
    credentials_secret: cdktf.stringToTerraform(struct!.credentialsSecret),
    password: cdktf.stringToTerraform(struct!.password),
    text_secret: cdktf.stringToTerraform(struct!.textSecret),
    token: cdktf.stringToTerraform(struct!.token),
    username: cdktf.stringToTerraform(struct!.username),
  }
}


export function packDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1PrometheusAuthToHclTerraform(struct?: PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1PrometheusAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    auth_type: {
      value: cdktf.stringToHclTerraform(struct!.authType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    credentials_secret: {
      value: cdktf.stringToHclTerraform(struct!.credentialsSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    password: {
      value: cdktf.stringToHclTerraform(struct!.password),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    text_secret: {
      value: cdktf.stringToHclTerraform(struct!.textSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    token: {
      value: cdktf.stringToHclTerraform(struct!.token),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    username: {
      value: cdktf.stringToHclTerraform(struct!.username),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1PrometheusAuthOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1PrometheusAuth | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._authType !== undefined) {
      hasAnyValues = true;
      internalValueResult.authType = this._authType;
    }
    if (this._credentialsSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.credentialsSecret = this._credentialsSecret;
    }
    if (this._password !== undefined) {
      hasAnyValues = true;
      internalValueResult.password = this._password;
    }
    if (this._textSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.textSecret = this._textSecret;
    }
    if (this._token !== undefined) {
      hasAnyValues = true;
      internalValueResult.token = this._token;
    }
    if (this._username !== undefined) {
      hasAnyValues = true;
      internalValueResult.username = this._username;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1PrometheusAuth | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._authType = undefined;
      this._credentialsSecret = undefined;
      this._password = undefined;
      this._textSecret = undefined;
      this._token = undefined;
      this._username = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._authType = value.authType;
      this._credentialsSecret = value.credentialsSecret;
      this._password = value.password;
      this._textSecret = value.textSecret;
      this._token = value.token;
      this._username = value.username;
    }
  }

  // auth_type - computed: true, optional: true, required: false
  private _authType?: string; 
  public get authType() {
    return this.getStringAttribute('auth_type');
  }
  public set authType(value: string) {
    this._authType = value;
  }
  public resetAuthType() {
    this._authType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authTypeInput() {
    return this._authType;
  }

  // credentials_secret - computed: false, optional: true, required: false
  private _credentialsSecret?: string; 
  public get credentialsSecret() {
    return this.getStringAttribute('credentials_secret');
  }
  public set credentialsSecret(value: string) {
    this._credentialsSecret = value;
  }
  public resetCredentialsSecret() {
    this._credentialsSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get credentialsSecretInput() {
    return this._credentialsSecret;
  }

  // password - computed: false, optional: true, required: false
  private _password?: string; 
  public get password() {
    return this.getStringAttribute('password');
  }
  public set password(value: string) {
    this._password = value;
  }
  public resetPassword() {
    this._password = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passwordInput() {
    return this._password;
  }

  // text_secret - computed: false, optional: true, required: false
  private _textSecret?: string; 
  public get textSecret() {
    return this.getStringAttribute('text_secret');
  }
  public set textSecret(value: string) {
    this._textSecret = value;
  }
  public resetTextSecret() {
    this._textSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get textSecretInput() {
    return this._textSecret;
  }

  // token - computed: false, optional: true, required: false
  private _token?: string; 
  public get token() {
    return this.getStringAttribute('token');
  }
  public set token(value: string) {
    this._token = value;
  }
  public resetToken() {
    this._token = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tokenInput() {
    return this._token;
  }

  // username - computed: false, optional: true, required: false
  private _username?: string; 
  public get username() {
    return this.getStringAttribute('username');
  }
  public set username(value: string) {
    this._username = value;
  }
  public resetUsername() {
    this._username = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usernameInput() {
    return this._username;
  }
}
export interface PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1ResponseRetrySettings {
  /**
  * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc. Default: 2
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#backoff_rate PackDestination#backoff_rate}
  */
  readonly backoffRate?: number;
  /**
  * The HTTP response status code that will trigger retries
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#http_status PackDestination#http_status}
  */
  readonly httpStatus: number;
  /**
  * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes). Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#initial_backoff PackDestination#initial_backoff}
  */
  readonly initialBackoff?: number;
  /**
  * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds). Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_backoff PackDestination#max_backoff}
  */
  readonly maxBackoff?: number;
}

export function packDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1ResponseRetrySettingsToTerraform(struct?: PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1ResponseRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    backoff_rate: cdktf.numberToTerraform(struct!.backoffRate),
    http_status: cdktf.numberToTerraform(struct!.httpStatus),
    initial_backoff: cdktf.numberToTerraform(struct!.initialBackoff),
    max_backoff: cdktf.numberToTerraform(struct!.maxBackoff),
  }
}


export function packDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1ResponseRetrySettingsToHclTerraform(struct?: PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1ResponseRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    backoff_rate: {
      value: cdktf.numberToHclTerraform(struct!.backoffRate),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    http_status: {
      value: cdktf.numberToHclTerraform(struct!.httpStatus),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    initial_backoff: {
      value: cdktf.numberToHclTerraform(struct!.initialBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_backoff: {
      value: cdktf.numberToHclTerraform(struct!.maxBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1ResponseRetrySettingsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1ResponseRetrySettings | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._backoffRate !== undefined) {
      hasAnyValues = true;
      internalValueResult.backoffRate = this._backoffRate;
    }
    if (this._httpStatus !== undefined) {
      hasAnyValues = true;
      internalValueResult.httpStatus = this._httpStatus;
    }
    if (this._initialBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.initialBackoff = this._initialBackoff;
    }
    if (this._maxBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBackoff = this._maxBackoff;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1ResponseRetrySettings | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._backoffRate = undefined;
      this._httpStatus = undefined;
      this._initialBackoff = undefined;
      this._maxBackoff = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._backoffRate = value.backoffRate;
      this._httpStatus = value.httpStatus;
      this._initialBackoff = value.initialBackoff;
      this._maxBackoff = value.maxBackoff;
    }
  }

  // backoff_rate - computed: true, optional: true, required: false
  private _backoffRate?: number; 
  public get backoffRate() {
    return this.getNumberAttribute('backoff_rate');
  }
  public set backoffRate(value: number) {
    this._backoffRate = value;
  }
  public resetBackoffRate() {
    this._backoffRate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get backoffRateInput() {
    return this._backoffRate;
  }

  // http_status - computed: false, optional: false, required: true
  private _httpStatus?: number; 
  public get httpStatus() {
    return this.getNumberAttribute('http_status');
  }
  public set httpStatus(value: number) {
    this._httpStatus = value;
  }
  // Temporarily expose input value. Use with caution.
  public get httpStatusInput() {
    return this._httpStatus;
  }

  // initial_backoff - computed: true, optional: true, required: false
  private _initialBackoff?: number; 
  public get initialBackoff() {
    return this.getNumberAttribute('initial_backoff');
  }
  public set initialBackoff(value: number) {
    this._initialBackoff = value;
  }
  public resetInitialBackoff() {
    this._initialBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get initialBackoffInput() {
    return this._initialBackoff;
  }

  // max_backoff - computed: true, optional: true, required: false
  private _maxBackoff?: number; 
  public get maxBackoff() {
    return this.getNumberAttribute('max_backoff');
  }
  public set maxBackoff(value: number) {
    this._maxBackoff = value;
  }
  public resetMaxBackoff() {
    this._maxBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBackoffInput() {
    return this._maxBackoff;
  }
}

export class PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1ResponseRetrySettingsList extends cdktf.ComplexList {
  public internalValue? : PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1ResponseRetrySettings[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1ResponseRetrySettingsOutputReference {
    return new PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1ResponseRetrySettingsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1TimeoutRetrySettings {
  /**
  * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc. Default: 2
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#backoff_rate PackDestination#backoff_rate}
  */
  readonly backoffRate?: number;
  /**
  * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes). Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#initial_backoff PackDestination#initial_backoff}
  */
  readonly initialBackoff?: number;
  /**
  * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds). Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_backoff PackDestination#max_backoff}
  */
  readonly maxBackoff?: number;
  /**
  * Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#timeout_retry PackDestination#timeout_retry}
  */
  readonly timeoutRetry?: boolean | cdktf.IResolvable;
}

export function packDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1TimeoutRetrySettingsToTerraform(struct?: PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1TimeoutRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    backoff_rate: cdktf.numberToTerraform(struct!.backoffRate),
    initial_backoff: cdktf.numberToTerraform(struct!.initialBackoff),
    max_backoff: cdktf.numberToTerraform(struct!.maxBackoff),
    timeout_retry: cdktf.booleanToTerraform(struct!.timeoutRetry),
  }
}


export function packDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1TimeoutRetrySettingsToHclTerraform(struct?: PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1TimeoutRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    backoff_rate: {
      value: cdktf.numberToHclTerraform(struct!.backoffRate),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    initial_backoff: {
      value: cdktf.numberToHclTerraform(struct!.initialBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_backoff: {
      value: cdktf.numberToHclTerraform(struct!.maxBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    timeout_retry: {
      value: cdktf.booleanToHclTerraform(struct!.timeoutRetry),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1TimeoutRetrySettingsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1TimeoutRetrySettings | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._backoffRate !== undefined) {
      hasAnyValues = true;
      internalValueResult.backoffRate = this._backoffRate;
    }
    if (this._initialBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.initialBackoff = this._initialBackoff;
    }
    if (this._maxBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBackoff = this._maxBackoff;
    }
    if (this._timeoutRetry !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutRetry = this._timeoutRetry;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1TimeoutRetrySettings | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._backoffRate = undefined;
      this._initialBackoff = undefined;
      this._maxBackoff = undefined;
      this._timeoutRetry = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._backoffRate = value.backoffRate;
      this._initialBackoff = value.initialBackoff;
      this._maxBackoff = value.maxBackoff;
      this._timeoutRetry = value.timeoutRetry;
    }
  }

  // backoff_rate - computed: true, optional: true, required: false
  private _backoffRate?: number; 
  public get backoffRate() {
    return this.getNumberAttribute('backoff_rate');
  }
  public set backoffRate(value: number) {
    this._backoffRate = value;
  }
  public resetBackoffRate() {
    this._backoffRate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get backoffRateInput() {
    return this._backoffRate;
  }

  // initial_backoff - computed: true, optional: true, required: false
  private _initialBackoff?: number; 
  public get initialBackoff() {
    return this.getNumberAttribute('initial_backoff');
  }
  public set initialBackoff(value: number) {
    this._initialBackoff = value;
  }
  public resetInitialBackoff() {
    this._initialBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get initialBackoffInput() {
    return this._initialBackoff;
  }

  // max_backoff - computed: true, optional: true, required: false
  private _maxBackoff?: number; 
  public get maxBackoff() {
    return this.getNumberAttribute('max_backoff');
  }
  public set maxBackoff(value: number) {
    this._maxBackoff = value;
  }
  public resetMaxBackoff() {
    this._maxBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBackoffInput() {
    return this._maxBackoff;
  }

  // timeout_retry - computed: true, optional: true, required: false
  private _timeoutRetry?: boolean | cdktf.IResolvable; 
  public get timeoutRetry() {
    return this.getBooleanAttribute('timeout_retry');
  }
  public set timeoutRetry(value: boolean | cdktf.IResolvable) {
    this._timeoutRetry = value;
  }
  public resetTimeoutRetry() {
    this._timeoutRetry = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutRetryInput() {
    return this._timeoutRetry;
  }
}
export interface PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1 {
  /**
  * Compress the payload body before sending. Applies only to JSON payloads; the Protobuf variant for both Prometheus and Loki are snappy-compressed by default. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#compress PackDestination#compress}
  */
  readonly compress?: boolean | cdktf.IResolvable;
  /**
  * Maximum number of ongoing requests before blocking. Warning: Setting this value > 1 can cause Loki and Prometheus to complain about entries being delivered out of order. Default: 1
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#concurrency PackDestination#concurrency}
  */
  readonly concurrency?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#description PackDestination#description}
  */
  readonly description?: string;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#environment PackDestination#environment}
  */
  readonly environment?: string;
  /**
  * Headers to add to all events
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#extra_http_headers PackDestination#extra_http_headers}
  */
  readonly extraHttpHeaders?: PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1ExtraHttpHeaders[] | cdktf.IResolvable;
  /**
  * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below. Default: "none"; must be one of ["payload", "payloadAndHeaders", "none"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#failed_request_logging_mode PackDestination#failed_request_logging_mode}
  */
  readonly failedRequestLoggingMode?: string;
  /**
  * Maximum time between requests. Small values could cause the payload size to be smaller than the configured Maximum time between requests. Small values can reduce the payload size below the configured 'Max record size' and 'Max events per request'. Warning: Setting this too low can increase the number of ongoing requests (depending on the value of 'Request concurrency'); this can cause Loki and Prometheus to complain about entries being delivered out of order. Default: 15
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#flush_period_sec PackDestination#flush_period_sec}
  */
  readonly flushPeriodSec?: number;
  /**
  * Unique ID for this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#id PackDestination#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id: string;
  /**
  * List of labels to send with logs. Labels define Loki streams, so use static labels to avoid proliferating label value combinations and streams. Can be merged and/or overridden by the events __labels field. Example: "__labels: {host: "cribl.io", level: "error"}"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#labels PackDestination#labels}
  */
  readonly labels?: PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1Labels[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#loki_auth PackDestination#loki_auth}
  */
  readonly lokiAuth?: PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1LokiAuth;
  /**
  * The endpoint to send logs to, such as https://logs-prod-us-central1.grafana.net
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#loki_url PackDestination#loki_url}
  */
  readonly lokiUrl: string;
  /**
  * Maximum number of events to include in the request body. Default is 0 (unlimited). Warning: Setting this too low can increase the number of ongoing requests (depending on the value of 'Request concurrency'); this can cause Loki and Prometheus to complain about entries being delivered out of order. Default: 0
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_payload_events PackDestination#max_payload_events}
  */
  readonly maxPayloadEvents?: number;
  /**
  * Maximum size, in KB, of the request body. Warning: Setting this too low can increase the number of ongoing requests (depending on the value of 'Request concurrency'); this can cause Loki and Prometheus to complain about entries being delivered out of order. Default: 4096
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_payload_size_kb PackDestination#max_payload_size_kb}
  */
  readonly maxPayloadSizeKb?: number;
  /**
  * Name of the event field that contains the message to send. If not specified, Stream sends a JSON representation of the whole event.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#message PackDestination#message}
  */
  readonly message?: string;
  /**
  * Format to use when sending logs to Loki (Protobuf or JSON). Default: "protobuf"; must be one of ["protobuf", "json"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#message_format PackDestination#message_format}
  */
  readonly messageFormat?: string;
  /**
  * JavaScript expression that can be used to rename metrics. For example, name.replace(/\./g, '_') will replace all '.' characters in a metric's name with the supported '_' character. Use the 'name' global variable to access the metric's name. You can access event fields' values via __e.<fieldName>. Default: "name.replace(/[^a-zA-Z0-9_]/g, '_')"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#metric_rename_expr PackDestination#metric_rename_expr}
  */
  readonly metricRenameExpr?: string;
  /**
  * How to handle events when all receivers are exerting backpressure. Default: "block"; must be one of ["block", "drop", "queue"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#on_backpressure PackDestination#on_backpressure}
  */
  readonly onBackpressure?: string;
  /**
  * Pipeline to process data before sending out to this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pipeline PackDestination#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_compress PackDestination#pq_compress}
  */
  readonly pqCompress?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_controls PackDestination#pq_controls}
  */
  readonly pqControls?: PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1PqControls;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.). Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_max_file_size PackDestination#pq_max_file_size}
  */
  readonly pqMaxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_max_size PackDestination#pq_max_size}
  */
  readonly pqMaxSize?: string;
  /**
  * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem. Default: "error"; must be one of ["error", "backpressure", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_mode PackDestination#pq_mode}
  */
  readonly pqMode?: string;
  /**
  * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged. Default: "block"; must be one of ["block", "drop"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_on_backpressure PackDestination#pq_on_backpressure}
  */
  readonly pqOnBackpressure?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_path PackDestination#pq_path}
  */
  readonly pqPath?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#prometheus_auth PackDestination#prometheus_auth}
  */
  readonly prometheusAuth?: PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1PrometheusAuth;
  /**
  * The remote_write endpoint to send Prometheus metrics to, such as https://prometheus-blocks-prod-us-central1.grafana.net/api/prom/push
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#prometheus_url PackDestination#prometheus_url}
  */
  readonly prometheusUrl?: string;
  /**
  * Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's). 
  *         Enabled by default. When this setting is also present in TLS Settings (Client Side), 
  *         that value will take precedence.
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#reject_unauthorized PackDestination#reject_unauthorized}
  */
  readonly rejectUnauthorized?: boolean | cdktf.IResolvable;
  /**
  * Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#response_honor_retry_after_header PackDestination#response_honor_retry_after_header}
  */
  readonly responseHonorRetryAfterHeader?: boolean | cdktf.IResolvable;
  /**
  * Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#response_retry_settings PackDestination#response_retry_settings}
  */
  readonly responseRetrySettings?: PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1ResponseRetrySettings[] | cdktf.IResolvable;
  /**
  * List of headers that are safe to log in plain text. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#safe_headers PackDestination#safe_headers}
  */
  readonly safeHeaders?: string[];
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#streamtags PackDestination#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Fields to automatically add to events, such as cribl_pipe. Supports wildcards. These fields are added as dimensions and labels to generated metrics and logs, respectively. Default: ["cribl_host","cribl_wp"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#system_fields PackDestination#system_fields}
  */
  readonly systemFields?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#timeout_retry_settings PackDestination#timeout_retry_settings}
  */
  readonly timeoutRetrySettings?: PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1TimeoutRetrySettings;
  /**
  * Amount of time, in seconds, to wait for a request to complete before canceling it. Default: 30
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#timeout_sec PackDestination#timeout_sec}
  */
  readonly timeoutSec?: number;
  /**
  * must be "grafana_cloud"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#type PackDestination#type}
  */
  readonly type: string;
  /**
  * Enable round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. For optimal performance, consider enabling this setting for non-load balanced destinations. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#use_round_robin_dns PackDestination#use_round_robin_dns}
  */
  readonly useRoundRobinDns?: boolean | cdktf.IResolvable;
}

export function packDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1ToTerraform(struct?: PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1 | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    compress: cdktf.booleanToTerraform(struct!.compress),
    concurrency: cdktf.numberToTerraform(struct!.concurrency),
    description: cdktf.stringToTerraform(struct!.description),
    environment: cdktf.stringToTerraform(struct!.environment),
    extra_http_headers: cdktf.listMapper(packDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1ExtraHttpHeadersToTerraform, false)(struct!.extraHttpHeaders),
    failed_request_logging_mode: cdktf.stringToTerraform(struct!.failedRequestLoggingMode),
    flush_period_sec: cdktf.numberToTerraform(struct!.flushPeriodSec),
    id: cdktf.stringToTerraform(struct!.id),
    labels: cdktf.listMapper(packDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1LabelsToTerraform, false)(struct!.labels),
    loki_auth: packDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1LokiAuthToTerraform(struct!.lokiAuth),
    loki_url: cdktf.stringToTerraform(struct!.lokiUrl),
    max_payload_events: cdktf.numberToTerraform(struct!.maxPayloadEvents),
    max_payload_size_kb: cdktf.numberToTerraform(struct!.maxPayloadSizeKb),
    message: cdktf.stringToTerraform(struct!.message),
    message_format: cdktf.stringToTerraform(struct!.messageFormat),
    metric_rename_expr: cdktf.stringToTerraform(struct!.metricRenameExpr),
    on_backpressure: cdktf.stringToTerraform(struct!.onBackpressure),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    pq_compress: cdktf.stringToTerraform(struct!.pqCompress),
    pq_controls: packDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1PqControlsToTerraform(struct!.pqControls),
    pq_max_file_size: cdktf.stringToTerraform(struct!.pqMaxFileSize),
    pq_max_size: cdktf.stringToTerraform(struct!.pqMaxSize),
    pq_mode: cdktf.stringToTerraform(struct!.pqMode),
    pq_on_backpressure: cdktf.stringToTerraform(struct!.pqOnBackpressure),
    pq_path: cdktf.stringToTerraform(struct!.pqPath),
    prometheus_auth: packDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1PrometheusAuthToTerraform(struct!.prometheusAuth),
    prometheus_url: cdktf.stringToTerraform(struct!.prometheusUrl),
    reject_unauthorized: cdktf.booleanToTerraform(struct!.rejectUnauthorized),
    response_honor_retry_after_header: cdktf.booleanToTerraform(struct!.responseHonorRetryAfterHeader),
    response_retry_settings: cdktf.listMapper(packDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1ResponseRetrySettingsToTerraform, false)(struct!.responseRetrySettings),
    safe_headers: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.safeHeaders),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    system_fields: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.systemFields),
    timeout_retry_settings: packDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1TimeoutRetrySettingsToTerraform(struct!.timeoutRetrySettings),
    timeout_sec: cdktf.numberToTerraform(struct!.timeoutSec),
    type: cdktf.stringToTerraform(struct!.type),
    use_round_robin_dns: cdktf.booleanToTerraform(struct!.useRoundRobinDns),
  }
}


export function packDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1ToHclTerraform(struct?: PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1 | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    compress: {
      value: cdktf.booleanToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    concurrency: {
      value: cdktf.numberToHclTerraform(struct!.concurrency),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    extra_http_headers: {
      value: cdktf.listMapperHcl(packDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1ExtraHttpHeadersToHclTerraform, false)(struct!.extraHttpHeaders),
      isBlock: true,
      type: "list",
      storageClassType: "PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1ExtraHttpHeadersList",
    },
    failed_request_logging_mode: {
      value: cdktf.stringToHclTerraform(struct!.failedRequestLoggingMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    flush_period_sec: {
      value: cdktf.numberToHclTerraform(struct!.flushPeriodSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    labels: {
      value: cdktf.listMapperHcl(packDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1LabelsToHclTerraform, false)(struct!.labels),
      isBlock: true,
      type: "list",
      storageClassType: "PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1LabelsList",
    },
    loki_auth: {
      value: packDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1LokiAuthToHclTerraform(struct!.lokiAuth),
      isBlock: true,
      type: "struct",
      storageClassType: "PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1LokiAuth",
    },
    loki_url: {
      value: cdktf.stringToHclTerraform(struct!.lokiUrl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_payload_events: {
      value: cdktf.numberToHclTerraform(struct!.maxPayloadEvents),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_payload_size_kb: {
      value: cdktf.numberToHclTerraform(struct!.maxPayloadSizeKb),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    message: {
      value: cdktf.stringToHclTerraform(struct!.message),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    message_format: {
      value: cdktf.stringToHclTerraform(struct!.messageFormat),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    metric_rename_expr: {
      value: cdktf.stringToHclTerraform(struct!.metricRenameExpr),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.onBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_compress: {
      value: cdktf.stringToHclTerraform(struct!.pqCompress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_controls: {
      value: packDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1PqControlsToHclTerraform(struct!.pqControls),
      isBlock: true,
      type: "struct",
      storageClassType: "PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1PqControls",
    },
    pq_max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_max_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_mode: {
      value: cdktf.stringToHclTerraform(struct!.pqMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.pqOnBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_path: {
      value: cdktf.stringToHclTerraform(struct!.pqPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    prometheus_auth: {
      value: packDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1PrometheusAuthToHclTerraform(struct!.prometheusAuth),
      isBlock: true,
      type: "struct",
      storageClassType: "PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1PrometheusAuth",
    },
    prometheus_url: {
      value: cdktf.stringToHclTerraform(struct!.prometheusUrl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reject_unauthorized: {
      value: cdktf.booleanToHclTerraform(struct!.rejectUnauthorized),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    response_honor_retry_after_header: {
      value: cdktf.booleanToHclTerraform(struct!.responseHonorRetryAfterHeader),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    response_retry_settings: {
      value: cdktf.listMapperHcl(packDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1ResponseRetrySettingsToHclTerraform, false)(struct!.responseRetrySettings),
      isBlock: true,
      type: "list",
      storageClassType: "PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1ResponseRetrySettingsList",
    },
    safe_headers: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.safeHeaders),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    system_fields: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.systemFields),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    timeout_retry_settings: {
      value: packDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1TimeoutRetrySettingsToHclTerraform(struct!.timeoutRetrySettings),
      isBlock: true,
      type: "struct",
      storageClassType: "PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1TimeoutRetrySettings",
    },
    timeout_sec: {
      value: cdktf.numberToHclTerraform(struct!.timeoutSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    use_round_robin_dns: {
      value: cdktf.booleanToHclTerraform(struct!.useRoundRobinDns),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1OutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1 | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._concurrency !== undefined) {
      hasAnyValues = true;
      internalValueResult.concurrency = this._concurrency;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._extraHttpHeaders?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.extraHttpHeaders = this._extraHttpHeaders?.internalValue;
    }
    if (this._failedRequestLoggingMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.failedRequestLoggingMode = this._failedRequestLoggingMode;
    }
    if (this._flushPeriodSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.flushPeriodSec = this._flushPeriodSec;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._labels?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.labels = this._labels?.internalValue;
    }
    if (this._lokiAuth?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.lokiAuth = this._lokiAuth?.internalValue;
    }
    if (this._lokiUrl !== undefined) {
      hasAnyValues = true;
      internalValueResult.lokiUrl = this._lokiUrl;
    }
    if (this._maxPayloadEvents !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxPayloadEvents = this._maxPayloadEvents;
    }
    if (this._maxPayloadSizeKb !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxPayloadSizeKb = this._maxPayloadSizeKb;
    }
    if (this._message !== undefined) {
      hasAnyValues = true;
      internalValueResult.message = this._message;
    }
    if (this._messageFormat !== undefined) {
      hasAnyValues = true;
      internalValueResult.messageFormat = this._messageFormat;
    }
    if (this._metricRenameExpr !== undefined) {
      hasAnyValues = true;
      internalValueResult.metricRenameExpr = this._metricRenameExpr;
    }
    if (this._onBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.onBackpressure = this._onBackpressure;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._pqCompress !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqCompress = this._pqCompress;
    }
    if (this._pqControls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqControls = this._pqControls?.internalValue;
    }
    if (this._pqMaxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxFileSize = this._pqMaxFileSize;
    }
    if (this._pqMaxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxSize = this._pqMaxSize;
    }
    if (this._pqMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMode = this._pqMode;
    }
    if (this._pqOnBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqOnBackpressure = this._pqOnBackpressure;
    }
    if (this._pqPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqPath = this._pqPath;
    }
    if (this._prometheusAuth?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.prometheusAuth = this._prometheusAuth?.internalValue;
    }
    if (this._prometheusUrl !== undefined) {
      hasAnyValues = true;
      internalValueResult.prometheusUrl = this._prometheusUrl;
    }
    if (this._rejectUnauthorized !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectUnauthorized = this._rejectUnauthorized;
    }
    if (this._responseHonorRetryAfterHeader !== undefined) {
      hasAnyValues = true;
      internalValueResult.responseHonorRetryAfterHeader = this._responseHonorRetryAfterHeader;
    }
    if (this._responseRetrySettings?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.responseRetrySettings = this._responseRetrySettings?.internalValue;
    }
    if (this._safeHeaders !== undefined) {
      hasAnyValues = true;
      internalValueResult.safeHeaders = this._safeHeaders;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._systemFields !== undefined) {
      hasAnyValues = true;
      internalValueResult.systemFields = this._systemFields;
    }
    if (this._timeoutRetrySettings?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutRetrySettings = this._timeoutRetrySettings?.internalValue;
    }
    if (this._timeoutSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutSec = this._timeoutSec;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._useRoundRobinDns !== undefined) {
      hasAnyValues = true;
      internalValueResult.useRoundRobinDns = this._useRoundRobinDns;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1 | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._compress = undefined;
      this._concurrency = undefined;
      this._description = undefined;
      this._environment = undefined;
      this._extraHttpHeaders.internalValue = undefined;
      this._failedRequestLoggingMode = undefined;
      this._flushPeriodSec = undefined;
      this._id = undefined;
      this._labels.internalValue = undefined;
      this._lokiAuth.internalValue = undefined;
      this._lokiUrl = undefined;
      this._maxPayloadEvents = undefined;
      this._maxPayloadSizeKb = undefined;
      this._message = undefined;
      this._messageFormat = undefined;
      this._metricRenameExpr = undefined;
      this._onBackpressure = undefined;
      this._pipeline = undefined;
      this._pqCompress = undefined;
      this._pqControls.internalValue = undefined;
      this._pqMaxFileSize = undefined;
      this._pqMaxSize = undefined;
      this._pqMode = undefined;
      this._pqOnBackpressure = undefined;
      this._pqPath = undefined;
      this._prometheusAuth.internalValue = undefined;
      this._prometheusUrl = undefined;
      this._rejectUnauthorized = undefined;
      this._responseHonorRetryAfterHeader = undefined;
      this._responseRetrySettings.internalValue = undefined;
      this._safeHeaders = undefined;
      this._streamtags = undefined;
      this._systemFields = undefined;
      this._timeoutRetrySettings.internalValue = undefined;
      this._timeoutSec = undefined;
      this._type = undefined;
      this._useRoundRobinDns = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._compress = value.compress;
      this._concurrency = value.concurrency;
      this._description = value.description;
      this._environment = value.environment;
      this._extraHttpHeaders.internalValue = value.extraHttpHeaders;
      this._failedRequestLoggingMode = value.failedRequestLoggingMode;
      this._flushPeriodSec = value.flushPeriodSec;
      this._id = value.id;
      this._labels.internalValue = value.labels;
      this._lokiAuth.internalValue = value.lokiAuth;
      this._lokiUrl = value.lokiUrl;
      this._maxPayloadEvents = value.maxPayloadEvents;
      this._maxPayloadSizeKb = value.maxPayloadSizeKb;
      this._message = value.message;
      this._messageFormat = value.messageFormat;
      this._metricRenameExpr = value.metricRenameExpr;
      this._onBackpressure = value.onBackpressure;
      this._pipeline = value.pipeline;
      this._pqCompress = value.pqCompress;
      this._pqControls.internalValue = value.pqControls;
      this._pqMaxFileSize = value.pqMaxFileSize;
      this._pqMaxSize = value.pqMaxSize;
      this._pqMode = value.pqMode;
      this._pqOnBackpressure = value.pqOnBackpressure;
      this._pqPath = value.pqPath;
      this._prometheusAuth.internalValue = value.prometheusAuth;
      this._prometheusUrl = value.prometheusUrl;
      this._rejectUnauthorized = value.rejectUnauthorized;
      this._responseHonorRetryAfterHeader = value.responseHonorRetryAfterHeader;
      this._responseRetrySettings.internalValue = value.responseRetrySettings;
      this._safeHeaders = value.safeHeaders;
      this._streamtags = value.streamtags;
      this._systemFields = value.systemFields;
      this._timeoutRetrySettings.internalValue = value.timeoutRetrySettings;
      this._timeoutSec = value.timeoutSec;
      this._type = value.type;
      this._useRoundRobinDns = value.useRoundRobinDns;
    }
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: boolean | cdktf.IResolvable; 
  public get compress() {
    return this.getBooleanAttribute('compress');
  }
  public set compress(value: boolean | cdktf.IResolvable) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // concurrency - computed: true, optional: true, required: false
  private _concurrency?: number; 
  public get concurrency() {
    return this.getNumberAttribute('concurrency');
  }
  public set concurrency(value: number) {
    this._concurrency = value;
  }
  public resetConcurrency() {
    this._concurrency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get concurrencyInput() {
    return this._concurrency;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // extra_http_headers - computed: false, optional: true, required: false
  private _extraHttpHeaders = new PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1ExtraHttpHeadersList(this, "extra_http_headers", false);
  public get extraHttpHeaders() {
    return this._extraHttpHeaders;
  }
  public putExtraHttpHeaders(value: PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1ExtraHttpHeaders[] | cdktf.IResolvable) {
    this._extraHttpHeaders.internalValue = value;
  }
  public resetExtraHttpHeaders() {
    this._extraHttpHeaders.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get extraHttpHeadersInput() {
    return this._extraHttpHeaders.internalValue;
  }

  // failed_request_logging_mode - computed: true, optional: true, required: false
  private _failedRequestLoggingMode?: string; 
  public get failedRequestLoggingMode() {
    return this.getStringAttribute('failed_request_logging_mode');
  }
  public set failedRequestLoggingMode(value: string) {
    this._failedRequestLoggingMode = value;
  }
  public resetFailedRequestLoggingMode() {
    this._failedRequestLoggingMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get failedRequestLoggingModeInput() {
    return this._failedRequestLoggingMode;
  }

  // flush_period_sec - computed: true, optional: true, required: false
  private _flushPeriodSec?: number; 
  public get flushPeriodSec() {
    return this.getNumberAttribute('flush_period_sec');
  }
  public set flushPeriodSec(value: number) {
    this._flushPeriodSec = value;
  }
  public resetFlushPeriodSec() {
    this._flushPeriodSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get flushPeriodSecInput() {
    return this._flushPeriodSec;
  }

  // id - computed: false, optional: false, required: true
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // labels - computed: false, optional: true, required: false
  private _labels = new PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1LabelsList(this, "labels", false);
  public get labels() {
    return this._labels;
  }
  public putLabels(value: PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1Labels[] | cdktf.IResolvable) {
    this._labels.internalValue = value;
  }
  public resetLabels() {
    this._labels.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelsInput() {
    return this._labels.internalValue;
  }

  // loki_auth - computed: false, optional: true, required: false
  private _lokiAuth = new PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1LokiAuthOutputReference(this, "loki_auth");
  public get lokiAuth() {
    return this._lokiAuth;
  }
  public putLokiAuth(value: PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1LokiAuth) {
    this._lokiAuth.internalValue = value;
  }
  public resetLokiAuth() {
    this._lokiAuth.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get lokiAuthInput() {
    return this._lokiAuth.internalValue;
  }

  // loki_url - computed: false, optional: false, required: true
  private _lokiUrl?: string; 
  public get lokiUrl() {
    return this.getStringAttribute('loki_url');
  }
  public set lokiUrl(value: string) {
    this._lokiUrl = value;
  }
  // Temporarily expose input value. Use with caution.
  public get lokiUrlInput() {
    return this._lokiUrl;
  }

  // max_payload_events - computed: true, optional: true, required: false
  private _maxPayloadEvents?: number; 
  public get maxPayloadEvents() {
    return this.getNumberAttribute('max_payload_events');
  }
  public set maxPayloadEvents(value: number) {
    this._maxPayloadEvents = value;
  }
  public resetMaxPayloadEvents() {
    this._maxPayloadEvents = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxPayloadEventsInput() {
    return this._maxPayloadEvents;
  }

  // max_payload_size_kb - computed: true, optional: true, required: false
  private _maxPayloadSizeKb?: number; 
  public get maxPayloadSizeKb() {
    return this.getNumberAttribute('max_payload_size_kb');
  }
  public set maxPayloadSizeKb(value: number) {
    this._maxPayloadSizeKb = value;
  }
  public resetMaxPayloadSizeKb() {
    this._maxPayloadSizeKb = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxPayloadSizeKbInput() {
    return this._maxPayloadSizeKb;
  }

  // message - computed: false, optional: true, required: false
  private _message?: string; 
  public get message() {
    return this.getStringAttribute('message');
  }
  public set message(value: string) {
    this._message = value;
  }
  public resetMessage() {
    this._message = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get messageInput() {
    return this._message;
  }

  // message_format - computed: true, optional: true, required: false
  private _messageFormat?: string; 
  public get messageFormat() {
    return this.getStringAttribute('message_format');
  }
  public set messageFormat(value: string) {
    this._messageFormat = value;
  }
  public resetMessageFormat() {
    this._messageFormat = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get messageFormatInput() {
    return this._messageFormat;
  }

  // metric_rename_expr - computed: true, optional: true, required: false
  private _metricRenameExpr?: string; 
  public get metricRenameExpr() {
    return this.getStringAttribute('metric_rename_expr');
  }
  public set metricRenameExpr(value: string) {
    this._metricRenameExpr = value;
  }
  public resetMetricRenameExpr() {
    this._metricRenameExpr = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metricRenameExprInput() {
    return this._metricRenameExpr;
  }

  // on_backpressure - computed: true, optional: true, required: false
  private _onBackpressure?: string; 
  public get onBackpressure() {
    return this.getStringAttribute('on_backpressure');
  }
  public set onBackpressure(value: string) {
    this._onBackpressure = value;
  }
  public resetOnBackpressure() {
    this._onBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get onBackpressureInput() {
    return this._onBackpressure;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // pq_compress - computed: true, optional: true, required: false
  private _pqCompress?: string; 
  public get pqCompress() {
    return this.getStringAttribute('pq_compress');
  }
  public set pqCompress(value: string) {
    this._pqCompress = value;
  }
  public resetPqCompress() {
    this._pqCompress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqCompressInput() {
    return this._pqCompress;
  }

  // pq_controls - computed: false, optional: true, required: false
  private _pqControls = new PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1PqControlsOutputReference(this, "pq_controls");
  public get pqControls() {
    return this._pqControls;
  }
  public putPqControls(value: PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1PqControls) {
    this._pqControls.internalValue = value;
  }
  public resetPqControls() {
    this._pqControls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqControlsInput() {
    return this._pqControls.internalValue;
  }

  // pq_max_file_size - computed: true, optional: true, required: false
  private _pqMaxFileSize?: string; 
  public get pqMaxFileSize() {
    return this.getStringAttribute('pq_max_file_size');
  }
  public set pqMaxFileSize(value: string) {
    this._pqMaxFileSize = value;
  }
  public resetPqMaxFileSize() {
    this._pqMaxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxFileSizeInput() {
    return this._pqMaxFileSize;
  }

  // pq_max_size - computed: true, optional: true, required: false
  private _pqMaxSize?: string; 
  public get pqMaxSize() {
    return this.getStringAttribute('pq_max_size');
  }
  public set pqMaxSize(value: string) {
    this._pqMaxSize = value;
  }
  public resetPqMaxSize() {
    this._pqMaxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxSizeInput() {
    return this._pqMaxSize;
  }

  // pq_mode - computed: true, optional: true, required: false
  private _pqMode?: string; 
  public get pqMode() {
    return this.getStringAttribute('pq_mode');
  }
  public set pqMode(value: string) {
    this._pqMode = value;
  }
  public resetPqMode() {
    this._pqMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqModeInput() {
    return this._pqMode;
  }

  // pq_on_backpressure - computed: true, optional: true, required: false
  private _pqOnBackpressure?: string; 
  public get pqOnBackpressure() {
    return this.getStringAttribute('pq_on_backpressure');
  }
  public set pqOnBackpressure(value: string) {
    this._pqOnBackpressure = value;
  }
  public resetPqOnBackpressure() {
    this._pqOnBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqOnBackpressureInput() {
    return this._pqOnBackpressure;
  }

  // pq_path - computed: true, optional: true, required: false
  private _pqPath?: string; 
  public get pqPath() {
    return this.getStringAttribute('pq_path');
  }
  public set pqPath(value: string) {
    this._pqPath = value;
  }
  public resetPqPath() {
    this._pqPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqPathInput() {
    return this._pqPath;
  }

  // prometheus_auth - computed: false, optional: true, required: false
  private _prometheusAuth = new PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1PrometheusAuthOutputReference(this, "prometheus_auth");
  public get prometheusAuth() {
    return this._prometheusAuth;
  }
  public putPrometheusAuth(value: PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1PrometheusAuth) {
    this._prometheusAuth.internalValue = value;
  }
  public resetPrometheusAuth() {
    this._prometheusAuth.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get prometheusAuthInput() {
    return this._prometheusAuth.internalValue;
  }

  // prometheus_url - computed: false, optional: true, required: false
  private _prometheusUrl?: string; 
  public get prometheusUrl() {
    return this.getStringAttribute('prometheus_url');
  }
  public set prometheusUrl(value: string) {
    this._prometheusUrl = value;
  }
  public resetPrometheusUrl() {
    this._prometheusUrl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get prometheusUrlInput() {
    return this._prometheusUrl;
  }

  // reject_unauthorized - computed: true, optional: true, required: false
  private _rejectUnauthorized?: boolean | cdktf.IResolvable; 
  public get rejectUnauthorized() {
    return this.getBooleanAttribute('reject_unauthorized');
  }
  public set rejectUnauthorized(value: boolean | cdktf.IResolvable) {
    this._rejectUnauthorized = value;
  }
  public resetRejectUnauthorized() {
    this._rejectUnauthorized = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectUnauthorizedInput() {
    return this._rejectUnauthorized;
  }

  // response_honor_retry_after_header - computed: true, optional: true, required: false
  private _responseHonorRetryAfterHeader?: boolean | cdktf.IResolvable; 
  public get responseHonorRetryAfterHeader() {
    return this.getBooleanAttribute('response_honor_retry_after_header');
  }
  public set responseHonorRetryAfterHeader(value: boolean | cdktf.IResolvable) {
    this._responseHonorRetryAfterHeader = value;
  }
  public resetResponseHonorRetryAfterHeader() {
    this._responseHonorRetryAfterHeader = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get responseHonorRetryAfterHeaderInput() {
    return this._responseHonorRetryAfterHeader;
  }

  // response_retry_settings - computed: false, optional: true, required: false
  private _responseRetrySettings = new PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1ResponseRetrySettingsList(this, "response_retry_settings", false);
  public get responseRetrySettings() {
    return this._responseRetrySettings;
  }
  public putResponseRetrySettings(value: PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1ResponseRetrySettings[] | cdktf.IResolvable) {
    this._responseRetrySettings.internalValue = value;
  }
  public resetResponseRetrySettings() {
    this._responseRetrySettings.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get responseRetrySettingsInput() {
    return this._responseRetrySettings.internalValue;
  }

  // safe_headers - computed: true, optional: true, required: false
  private _safeHeaders?: string[]; 
  public get safeHeaders() {
    return this.getListAttribute('safe_headers');
  }
  public set safeHeaders(value: string[]) {
    this._safeHeaders = value;
  }
  public resetSafeHeaders() {
    this._safeHeaders = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get safeHeadersInput() {
    return this._safeHeaders;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // system_fields - computed: true, optional: true, required: false
  private _systemFields?: string[]; 
  public get systemFields() {
    return this.getListAttribute('system_fields');
  }
  public set systemFields(value: string[]) {
    this._systemFields = value;
  }
  public resetSystemFields() {
    this._systemFields = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get systemFieldsInput() {
    return this._systemFields;
  }

  // timeout_retry_settings - computed: false, optional: true, required: false
  private _timeoutRetrySettings = new PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1TimeoutRetrySettingsOutputReference(this, "timeout_retry_settings");
  public get timeoutRetrySettings() {
    return this._timeoutRetrySettings;
  }
  public putTimeoutRetrySettings(value: PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1TimeoutRetrySettings) {
    this._timeoutRetrySettings.internalValue = value;
  }
  public resetTimeoutRetrySettings() {
    this._timeoutRetrySettings.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutRetrySettingsInput() {
    return this._timeoutRetrySettings.internalValue;
  }

  // timeout_sec - computed: true, optional: true, required: false
  private _timeoutSec?: number; 
  public get timeoutSec() {
    return this.getNumberAttribute('timeout_sec');
  }
  public set timeoutSec(value: number) {
    this._timeoutSec = value;
  }
  public resetTimeoutSec() {
    this._timeoutSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutSecInput() {
    return this._timeoutSec;
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // use_round_robin_dns - computed: true, optional: true, required: false
  private _useRoundRobinDns?: boolean | cdktf.IResolvable; 
  public get useRoundRobinDns() {
    return this.getBooleanAttribute('use_round_robin_dns');
  }
  public set useRoundRobinDns(value: boolean | cdktf.IResolvable) {
    this._useRoundRobinDns = value;
  }
  public resetUseRoundRobinDns() {
    this._useRoundRobinDns = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get useRoundRobinDnsInput() {
    return this._useRoundRobinDns;
  }
}
export interface PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2ExtraHttpHeaders {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#name PackDestination#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#value PackDestination#value}
  */
  readonly value: string;
}

export function packDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2ExtraHttpHeadersToTerraform(struct?: PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2ExtraHttpHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function packDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2ExtraHttpHeadersToHclTerraform(struct?: PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2ExtraHttpHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2ExtraHttpHeadersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2ExtraHttpHeaders | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2ExtraHttpHeaders | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2ExtraHttpHeadersList extends cdktf.ComplexList {
  public internalValue? : PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2ExtraHttpHeaders[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2ExtraHttpHeadersOutputReference {
    return new PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2ExtraHttpHeadersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2Labels {
  /**
  * Default: ""
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#name PackDestination#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#value PackDestination#value}
  */
  readonly value: string;
}

export function packDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2LabelsToTerraform(struct?: PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2Labels | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function packDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2LabelsToHclTerraform(struct?: PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2Labels | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2LabelsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2Labels | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2Labels | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: true, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2LabelsList extends cdktf.ComplexList {
  public internalValue? : PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2Labels[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2LabelsOutputReference {
    return new PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2LabelsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2LokiAuth {
  /**
  * Default: "basic"; must be one of ["none", "token", "textSecret", "basic", "credentialsSecret"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#auth_type PackDestination#auth_type}
  */
  readonly authType?: string;
  /**
  * Select or create a secret that references your credentials
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#credentials_secret PackDestination#credentials_secret}
  */
  readonly credentialsSecret?: string;
  /**
  * Password (API key in Grafana Cloud domain) for authentication
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#password PackDestination#password}
  */
  readonly password?: string;
  /**
  * Select or create a stored text secret
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#text_secret PackDestination#text_secret}
  */
  readonly textSecret?: string;
  /**
  * Bearer token to include in the authorization header. In Grafana Cloud, this is generally built by concatenating the username and the API key, separated by a colon. Example: <your-username>:<your-api-key>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#token PackDestination#token}
  */
  readonly token?: string;
  /**
  * Username for authentication
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#username PackDestination#username}
  */
  readonly username?: string;
}

export function packDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2LokiAuthToTerraform(struct?: PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2LokiAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    auth_type: cdktf.stringToTerraform(struct!.authType),
    credentials_secret: cdktf.stringToTerraform(struct!.credentialsSecret),
    password: cdktf.stringToTerraform(struct!.password),
    text_secret: cdktf.stringToTerraform(struct!.textSecret),
    token: cdktf.stringToTerraform(struct!.token),
    username: cdktf.stringToTerraform(struct!.username),
  }
}


export function packDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2LokiAuthToHclTerraform(struct?: PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2LokiAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    auth_type: {
      value: cdktf.stringToHclTerraform(struct!.authType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    credentials_secret: {
      value: cdktf.stringToHclTerraform(struct!.credentialsSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    password: {
      value: cdktf.stringToHclTerraform(struct!.password),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    text_secret: {
      value: cdktf.stringToHclTerraform(struct!.textSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    token: {
      value: cdktf.stringToHclTerraform(struct!.token),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    username: {
      value: cdktf.stringToHclTerraform(struct!.username),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2LokiAuthOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2LokiAuth | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._authType !== undefined) {
      hasAnyValues = true;
      internalValueResult.authType = this._authType;
    }
    if (this._credentialsSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.credentialsSecret = this._credentialsSecret;
    }
    if (this._password !== undefined) {
      hasAnyValues = true;
      internalValueResult.password = this._password;
    }
    if (this._textSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.textSecret = this._textSecret;
    }
    if (this._token !== undefined) {
      hasAnyValues = true;
      internalValueResult.token = this._token;
    }
    if (this._username !== undefined) {
      hasAnyValues = true;
      internalValueResult.username = this._username;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2LokiAuth | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._authType = undefined;
      this._credentialsSecret = undefined;
      this._password = undefined;
      this._textSecret = undefined;
      this._token = undefined;
      this._username = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._authType = value.authType;
      this._credentialsSecret = value.credentialsSecret;
      this._password = value.password;
      this._textSecret = value.textSecret;
      this._token = value.token;
      this._username = value.username;
    }
  }

  // auth_type - computed: true, optional: true, required: false
  private _authType?: string; 
  public get authType() {
    return this.getStringAttribute('auth_type');
  }
  public set authType(value: string) {
    this._authType = value;
  }
  public resetAuthType() {
    this._authType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authTypeInput() {
    return this._authType;
  }

  // credentials_secret - computed: false, optional: true, required: false
  private _credentialsSecret?: string; 
  public get credentialsSecret() {
    return this.getStringAttribute('credentials_secret');
  }
  public set credentialsSecret(value: string) {
    this._credentialsSecret = value;
  }
  public resetCredentialsSecret() {
    this._credentialsSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get credentialsSecretInput() {
    return this._credentialsSecret;
  }

  // password - computed: false, optional: true, required: false
  private _password?: string; 
  public get password() {
    return this.getStringAttribute('password');
  }
  public set password(value: string) {
    this._password = value;
  }
  public resetPassword() {
    this._password = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passwordInput() {
    return this._password;
  }

  // text_secret - computed: false, optional: true, required: false
  private _textSecret?: string; 
  public get textSecret() {
    return this.getStringAttribute('text_secret');
  }
  public set textSecret(value: string) {
    this._textSecret = value;
  }
  public resetTextSecret() {
    this._textSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get textSecretInput() {
    return this._textSecret;
  }

  // token - computed: false, optional: true, required: false
  private _token?: string; 
  public get token() {
    return this.getStringAttribute('token');
  }
  public set token(value: string) {
    this._token = value;
  }
  public resetToken() {
    this._token = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tokenInput() {
    return this._token;
  }

  // username - computed: false, optional: true, required: false
  private _username?: string; 
  public get username() {
    return this.getStringAttribute('username');
  }
  public set username(value: string) {
    this._username = value;
  }
  public resetUsername() {
    this._username = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usernameInput() {
    return this._username;
  }
}
export interface PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2PqControls {
}

export function packDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2PqControlsToTerraform(struct?: PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2PqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function packDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2PqControlsToHclTerraform(struct?: PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2PqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2PqControlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2PqControls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2PqControls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2PrometheusAuth {
  /**
  * Default: "basic"; must be one of ["none", "token", "textSecret", "basic", "credentialsSecret"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#auth_type PackDestination#auth_type}
  */
  readonly authType?: string;
  /**
  * Select or create a secret that references your credentials
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#credentials_secret PackDestination#credentials_secret}
  */
  readonly credentialsSecret?: string;
  /**
  * Password (API key in Grafana Cloud domain) for authentication
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#password PackDestination#password}
  */
  readonly password?: string;
  /**
  * Select or create a stored text secret
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#text_secret PackDestination#text_secret}
  */
  readonly textSecret?: string;
  /**
  * Bearer token to include in the authorization header. In Grafana Cloud, this is generally built by concatenating the username and the API key, separated by a colon. Example: <your-username>:<your-api-key>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#token PackDestination#token}
  */
  readonly token?: string;
  /**
  * Username for authentication
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#username PackDestination#username}
  */
  readonly username?: string;
}

export function packDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2PrometheusAuthToTerraform(struct?: PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2PrometheusAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    auth_type: cdktf.stringToTerraform(struct!.authType),
    credentials_secret: cdktf.stringToTerraform(struct!.credentialsSecret),
    password: cdktf.stringToTerraform(struct!.password),
    text_secret: cdktf.stringToTerraform(struct!.textSecret),
    token: cdktf.stringToTerraform(struct!.token),
    username: cdktf.stringToTerraform(struct!.username),
  }
}


export function packDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2PrometheusAuthToHclTerraform(struct?: PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2PrometheusAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    auth_type: {
      value: cdktf.stringToHclTerraform(struct!.authType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    credentials_secret: {
      value: cdktf.stringToHclTerraform(struct!.credentialsSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    password: {
      value: cdktf.stringToHclTerraform(struct!.password),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    text_secret: {
      value: cdktf.stringToHclTerraform(struct!.textSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    token: {
      value: cdktf.stringToHclTerraform(struct!.token),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    username: {
      value: cdktf.stringToHclTerraform(struct!.username),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2PrometheusAuthOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2PrometheusAuth | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._authType !== undefined) {
      hasAnyValues = true;
      internalValueResult.authType = this._authType;
    }
    if (this._credentialsSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.credentialsSecret = this._credentialsSecret;
    }
    if (this._password !== undefined) {
      hasAnyValues = true;
      internalValueResult.password = this._password;
    }
    if (this._textSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.textSecret = this._textSecret;
    }
    if (this._token !== undefined) {
      hasAnyValues = true;
      internalValueResult.token = this._token;
    }
    if (this._username !== undefined) {
      hasAnyValues = true;
      internalValueResult.username = this._username;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2PrometheusAuth | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._authType = undefined;
      this._credentialsSecret = undefined;
      this._password = undefined;
      this._textSecret = undefined;
      this._token = undefined;
      this._username = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._authType = value.authType;
      this._credentialsSecret = value.credentialsSecret;
      this._password = value.password;
      this._textSecret = value.textSecret;
      this._token = value.token;
      this._username = value.username;
    }
  }

  // auth_type - computed: true, optional: true, required: false
  private _authType?: string; 
  public get authType() {
    return this.getStringAttribute('auth_type');
  }
  public set authType(value: string) {
    this._authType = value;
  }
  public resetAuthType() {
    this._authType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authTypeInput() {
    return this._authType;
  }

  // credentials_secret - computed: false, optional: true, required: false
  private _credentialsSecret?: string; 
  public get credentialsSecret() {
    return this.getStringAttribute('credentials_secret');
  }
  public set credentialsSecret(value: string) {
    this._credentialsSecret = value;
  }
  public resetCredentialsSecret() {
    this._credentialsSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get credentialsSecretInput() {
    return this._credentialsSecret;
  }

  // password - computed: false, optional: true, required: false
  private _password?: string; 
  public get password() {
    return this.getStringAttribute('password');
  }
  public set password(value: string) {
    this._password = value;
  }
  public resetPassword() {
    this._password = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passwordInput() {
    return this._password;
  }

  // text_secret - computed: false, optional: true, required: false
  private _textSecret?: string; 
  public get textSecret() {
    return this.getStringAttribute('text_secret');
  }
  public set textSecret(value: string) {
    this._textSecret = value;
  }
  public resetTextSecret() {
    this._textSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get textSecretInput() {
    return this._textSecret;
  }

  // token - computed: false, optional: true, required: false
  private _token?: string; 
  public get token() {
    return this.getStringAttribute('token');
  }
  public set token(value: string) {
    this._token = value;
  }
  public resetToken() {
    this._token = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tokenInput() {
    return this._token;
  }

  // username - computed: false, optional: true, required: false
  private _username?: string; 
  public get username() {
    return this.getStringAttribute('username');
  }
  public set username(value: string) {
    this._username = value;
  }
  public resetUsername() {
    this._username = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usernameInput() {
    return this._username;
  }
}
export interface PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2ResponseRetrySettings {
  /**
  * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc. Default: 2
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#backoff_rate PackDestination#backoff_rate}
  */
  readonly backoffRate?: number;
  /**
  * The HTTP response status code that will trigger retries
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#http_status PackDestination#http_status}
  */
  readonly httpStatus: number;
  /**
  * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes). Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#initial_backoff PackDestination#initial_backoff}
  */
  readonly initialBackoff?: number;
  /**
  * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds). Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_backoff PackDestination#max_backoff}
  */
  readonly maxBackoff?: number;
}

export function packDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2ResponseRetrySettingsToTerraform(struct?: PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2ResponseRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    backoff_rate: cdktf.numberToTerraform(struct!.backoffRate),
    http_status: cdktf.numberToTerraform(struct!.httpStatus),
    initial_backoff: cdktf.numberToTerraform(struct!.initialBackoff),
    max_backoff: cdktf.numberToTerraform(struct!.maxBackoff),
  }
}


export function packDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2ResponseRetrySettingsToHclTerraform(struct?: PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2ResponseRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    backoff_rate: {
      value: cdktf.numberToHclTerraform(struct!.backoffRate),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    http_status: {
      value: cdktf.numberToHclTerraform(struct!.httpStatus),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    initial_backoff: {
      value: cdktf.numberToHclTerraform(struct!.initialBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_backoff: {
      value: cdktf.numberToHclTerraform(struct!.maxBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2ResponseRetrySettingsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2ResponseRetrySettings | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._backoffRate !== undefined) {
      hasAnyValues = true;
      internalValueResult.backoffRate = this._backoffRate;
    }
    if (this._httpStatus !== undefined) {
      hasAnyValues = true;
      internalValueResult.httpStatus = this._httpStatus;
    }
    if (this._initialBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.initialBackoff = this._initialBackoff;
    }
    if (this._maxBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBackoff = this._maxBackoff;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2ResponseRetrySettings | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._backoffRate = undefined;
      this._httpStatus = undefined;
      this._initialBackoff = undefined;
      this._maxBackoff = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._backoffRate = value.backoffRate;
      this._httpStatus = value.httpStatus;
      this._initialBackoff = value.initialBackoff;
      this._maxBackoff = value.maxBackoff;
    }
  }

  // backoff_rate - computed: true, optional: true, required: false
  private _backoffRate?: number; 
  public get backoffRate() {
    return this.getNumberAttribute('backoff_rate');
  }
  public set backoffRate(value: number) {
    this._backoffRate = value;
  }
  public resetBackoffRate() {
    this._backoffRate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get backoffRateInput() {
    return this._backoffRate;
  }

  // http_status - computed: false, optional: false, required: true
  private _httpStatus?: number; 
  public get httpStatus() {
    return this.getNumberAttribute('http_status');
  }
  public set httpStatus(value: number) {
    this._httpStatus = value;
  }
  // Temporarily expose input value. Use with caution.
  public get httpStatusInput() {
    return this._httpStatus;
  }

  // initial_backoff - computed: true, optional: true, required: false
  private _initialBackoff?: number; 
  public get initialBackoff() {
    return this.getNumberAttribute('initial_backoff');
  }
  public set initialBackoff(value: number) {
    this._initialBackoff = value;
  }
  public resetInitialBackoff() {
    this._initialBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get initialBackoffInput() {
    return this._initialBackoff;
  }

  // max_backoff - computed: true, optional: true, required: false
  private _maxBackoff?: number; 
  public get maxBackoff() {
    return this.getNumberAttribute('max_backoff');
  }
  public set maxBackoff(value: number) {
    this._maxBackoff = value;
  }
  public resetMaxBackoff() {
    this._maxBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBackoffInput() {
    return this._maxBackoff;
  }
}

export class PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2ResponseRetrySettingsList extends cdktf.ComplexList {
  public internalValue? : PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2ResponseRetrySettings[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2ResponseRetrySettingsOutputReference {
    return new PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2ResponseRetrySettingsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2TimeoutRetrySettings {
  /**
  * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc. Default: 2
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#backoff_rate PackDestination#backoff_rate}
  */
  readonly backoffRate?: number;
  /**
  * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes). Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#initial_backoff PackDestination#initial_backoff}
  */
  readonly initialBackoff?: number;
  /**
  * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds). Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_backoff PackDestination#max_backoff}
  */
  readonly maxBackoff?: number;
  /**
  * Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#timeout_retry PackDestination#timeout_retry}
  */
  readonly timeoutRetry?: boolean | cdktf.IResolvable;
}

export function packDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2TimeoutRetrySettingsToTerraform(struct?: PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2TimeoutRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    backoff_rate: cdktf.numberToTerraform(struct!.backoffRate),
    initial_backoff: cdktf.numberToTerraform(struct!.initialBackoff),
    max_backoff: cdktf.numberToTerraform(struct!.maxBackoff),
    timeout_retry: cdktf.booleanToTerraform(struct!.timeoutRetry),
  }
}


export function packDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2TimeoutRetrySettingsToHclTerraform(struct?: PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2TimeoutRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    backoff_rate: {
      value: cdktf.numberToHclTerraform(struct!.backoffRate),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    initial_backoff: {
      value: cdktf.numberToHclTerraform(struct!.initialBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_backoff: {
      value: cdktf.numberToHclTerraform(struct!.maxBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    timeout_retry: {
      value: cdktf.booleanToHclTerraform(struct!.timeoutRetry),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2TimeoutRetrySettingsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2TimeoutRetrySettings | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._backoffRate !== undefined) {
      hasAnyValues = true;
      internalValueResult.backoffRate = this._backoffRate;
    }
    if (this._initialBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.initialBackoff = this._initialBackoff;
    }
    if (this._maxBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBackoff = this._maxBackoff;
    }
    if (this._timeoutRetry !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutRetry = this._timeoutRetry;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2TimeoutRetrySettings | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._backoffRate = undefined;
      this._initialBackoff = undefined;
      this._maxBackoff = undefined;
      this._timeoutRetry = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._backoffRate = value.backoffRate;
      this._initialBackoff = value.initialBackoff;
      this._maxBackoff = value.maxBackoff;
      this._timeoutRetry = value.timeoutRetry;
    }
  }

  // backoff_rate - computed: true, optional: true, required: false
  private _backoffRate?: number; 
  public get backoffRate() {
    return this.getNumberAttribute('backoff_rate');
  }
  public set backoffRate(value: number) {
    this._backoffRate = value;
  }
  public resetBackoffRate() {
    this._backoffRate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get backoffRateInput() {
    return this._backoffRate;
  }

  // initial_backoff - computed: true, optional: true, required: false
  private _initialBackoff?: number; 
  public get initialBackoff() {
    return this.getNumberAttribute('initial_backoff');
  }
  public set initialBackoff(value: number) {
    this._initialBackoff = value;
  }
  public resetInitialBackoff() {
    this._initialBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get initialBackoffInput() {
    return this._initialBackoff;
  }

  // max_backoff - computed: true, optional: true, required: false
  private _maxBackoff?: number; 
  public get maxBackoff() {
    return this.getNumberAttribute('max_backoff');
  }
  public set maxBackoff(value: number) {
    this._maxBackoff = value;
  }
  public resetMaxBackoff() {
    this._maxBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBackoffInput() {
    return this._maxBackoff;
  }

  // timeout_retry - computed: true, optional: true, required: false
  private _timeoutRetry?: boolean | cdktf.IResolvable; 
  public get timeoutRetry() {
    return this.getBooleanAttribute('timeout_retry');
  }
  public set timeoutRetry(value: boolean | cdktf.IResolvable) {
    this._timeoutRetry = value;
  }
  public resetTimeoutRetry() {
    this._timeoutRetry = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutRetryInput() {
    return this._timeoutRetry;
  }
}
export interface PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2 {
  /**
  * Compress the payload body before sending. Applies only to JSON payloads; the Protobuf variant for both Prometheus and Loki are snappy-compressed by default. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#compress PackDestination#compress}
  */
  readonly compress?: boolean | cdktf.IResolvable;
  /**
  * Maximum number of ongoing requests before blocking. Warning: Setting this value > 1 can cause Loki and Prometheus to complain about entries being delivered out of order. Default: 1
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#concurrency PackDestination#concurrency}
  */
  readonly concurrency?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#description PackDestination#description}
  */
  readonly description?: string;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#environment PackDestination#environment}
  */
  readonly environment?: string;
  /**
  * Headers to add to all events
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#extra_http_headers PackDestination#extra_http_headers}
  */
  readonly extraHttpHeaders?: PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2ExtraHttpHeaders[] | cdktf.IResolvable;
  /**
  * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below. Default: "none"; must be one of ["payload", "payloadAndHeaders", "none"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#failed_request_logging_mode PackDestination#failed_request_logging_mode}
  */
  readonly failedRequestLoggingMode?: string;
  /**
  * Maximum time between requests. Small values could cause the payload size to be smaller than the configured Maximum time between requests. Small values can reduce the payload size below the configured 'Max record size' and 'Max events per request'. Warning: Setting this too low can increase the number of ongoing requests (depending on the value of 'Request concurrency'); this can cause Loki and Prometheus to complain about entries being delivered out of order. Default: 15
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#flush_period_sec PackDestination#flush_period_sec}
  */
  readonly flushPeriodSec?: number;
  /**
  * Unique ID for this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#id PackDestination#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id: string;
  /**
  * List of labels to send with logs. Labels define Loki streams, so use static labels to avoid proliferating label value combinations and streams. Can be merged and/or overridden by the events __labels field. Example: "__labels: {host: "cribl.io", level: "error"}"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#labels PackDestination#labels}
  */
  readonly labels?: PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2Labels[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#loki_auth PackDestination#loki_auth}
  */
  readonly lokiAuth?: PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2LokiAuth;
  /**
  * The endpoint to send logs to, such as https://logs-prod-us-central1.grafana.net
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#loki_url PackDestination#loki_url}
  */
  readonly lokiUrl?: string;
  /**
  * Maximum number of events to include in the request body. Default is 0 (unlimited). Warning: Setting this too low can increase the number of ongoing requests (depending on the value of 'Request concurrency'); this can cause Loki and Prometheus to complain about entries being delivered out of order. Default: 0
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_payload_events PackDestination#max_payload_events}
  */
  readonly maxPayloadEvents?: number;
  /**
  * Maximum size, in KB, of the request body. Warning: Setting this too low can increase the number of ongoing requests (depending on the value of 'Request concurrency'); this can cause Loki and Prometheus to complain about entries being delivered out of order. Default: 4096
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_payload_size_kb PackDestination#max_payload_size_kb}
  */
  readonly maxPayloadSizeKb?: number;
  /**
  * Name of the event field that contains the message to send. If not specified, Stream sends a JSON representation of the whole event.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#message PackDestination#message}
  */
  readonly message?: string;
  /**
  * Format to use when sending logs to Loki (Protobuf or JSON). Default: "protobuf"; must be one of ["protobuf", "json"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#message_format PackDestination#message_format}
  */
  readonly messageFormat?: string;
  /**
  * JavaScript expression that can be used to rename metrics. For example, name.replace(/\./g, '_') will replace all '.' characters in a metric's name with the supported '_' character. Use the 'name' global variable to access the metric's name. You can access event fields' values via __e.<fieldName>. Default: "name.replace(/[^a-zA-Z0-9_]/g, '_')"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#metric_rename_expr PackDestination#metric_rename_expr}
  */
  readonly metricRenameExpr?: string;
  /**
  * How to handle events when all receivers are exerting backpressure. Default: "block"; must be one of ["block", "drop", "queue"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#on_backpressure PackDestination#on_backpressure}
  */
  readonly onBackpressure?: string;
  /**
  * Pipeline to process data before sending out to this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pipeline PackDestination#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_compress PackDestination#pq_compress}
  */
  readonly pqCompress?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_controls PackDestination#pq_controls}
  */
  readonly pqControls?: PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2PqControls;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.). Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_max_file_size PackDestination#pq_max_file_size}
  */
  readonly pqMaxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_max_size PackDestination#pq_max_size}
  */
  readonly pqMaxSize?: string;
  /**
  * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem. Default: "error"; must be one of ["error", "backpressure", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_mode PackDestination#pq_mode}
  */
  readonly pqMode?: string;
  /**
  * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged. Default: "block"; must be one of ["block", "drop"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_on_backpressure PackDestination#pq_on_backpressure}
  */
  readonly pqOnBackpressure?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_path PackDestination#pq_path}
  */
  readonly pqPath?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#prometheus_auth PackDestination#prometheus_auth}
  */
  readonly prometheusAuth?: PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2PrometheusAuth;
  /**
  * The remote_write endpoint to send Prometheus metrics to, such as https://prometheus-blocks-prod-us-central1.grafana.net/api/prom/push
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#prometheus_url PackDestination#prometheus_url}
  */
  readonly prometheusUrl: string;
  /**
  * Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's). 
  *         Enabled by default. When this setting is also present in TLS Settings (Client Side), 
  *         that value will take precedence.
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#reject_unauthorized PackDestination#reject_unauthorized}
  */
  readonly rejectUnauthorized?: boolean | cdktf.IResolvable;
  /**
  * Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#response_honor_retry_after_header PackDestination#response_honor_retry_after_header}
  */
  readonly responseHonorRetryAfterHeader?: boolean | cdktf.IResolvable;
  /**
  * Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#response_retry_settings PackDestination#response_retry_settings}
  */
  readonly responseRetrySettings?: PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2ResponseRetrySettings[] | cdktf.IResolvable;
  /**
  * List of headers that are safe to log in plain text. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#safe_headers PackDestination#safe_headers}
  */
  readonly safeHeaders?: string[];
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#streamtags PackDestination#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Fields to automatically add to events, such as cribl_pipe. Supports wildcards. These fields are added as dimensions and labels to generated metrics and logs, respectively. Default: ["cribl_host","cribl_wp"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#system_fields PackDestination#system_fields}
  */
  readonly systemFields?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#timeout_retry_settings PackDestination#timeout_retry_settings}
  */
  readonly timeoutRetrySettings?: PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2TimeoutRetrySettings;
  /**
  * Amount of time, in seconds, to wait for a request to complete before canceling it. Default: 30
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#timeout_sec PackDestination#timeout_sec}
  */
  readonly timeoutSec?: number;
  /**
  * must be "grafana_cloud"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#type PackDestination#type}
  */
  readonly type: string;
  /**
  * Enable round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. For optimal performance, consider enabling this setting for non-load balanced destinations. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#use_round_robin_dns PackDestination#use_round_robin_dns}
  */
  readonly useRoundRobinDns?: boolean | cdktf.IResolvable;
}

export function packDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2ToTerraform(struct?: PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2 | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    compress: cdktf.booleanToTerraform(struct!.compress),
    concurrency: cdktf.numberToTerraform(struct!.concurrency),
    description: cdktf.stringToTerraform(struct!.description),
    environment: cdktf.stringToTerraform(struct!.environment),
    extra_http_headers: cdktf.listMapper(packDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2ExtraHttpHeadersToTerraform, false)(struct!.extraHttpHeaders),
    failed_request_logging_mode: cdktf.stringToTerraform(struct!.failedRequestLoggingMode),
    flush_period_sec: cdktf.numberToTerraform(struct!.flushPeriodSec),
    id: cdktf.stringToTerraform(struct!.id),
    labels: cdktf.listMapper(packDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2LabelsToTerraform, false)(struct!.labels),
    loki_auth: packDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2LokiAuthToTerraform(struct!.lokiAuth),
    loki_url: cdktf.stringToTerraform(struct!.lokiUrl),
    max_payload_events: cdktf.numberToTerraform(struct!.maxPayloadEvents),
    max_payload_size_kb: cdktf.numberToTerraform(struct!.maxPayloadSizeKb),
    message: cdktf.stringToTerraform(struct!.message),
    message_format: cdktf.stringToTerraform(struct!.messageFormat),
    metric_rename_expr: cdktf.stringToTerraform(struct!.metricRenameExpr),
    on_backpressure: cdktf.stringToTerraform(struct!.onBackpressure),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    pq_compress: cdktf.stringToTerraform(struct!.pqCompress),
    pq_controls: packDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2PqControlsToTerraform(struct!.pqControls),
    pq_max_file_size: cdktf.stringToTerraform(struct!.pqMaxFileSize),
    pq_max_size: cdktf.stringToTerraform(struct!.pqMaxSize),
    pq_mode: cdktf.stringToTerraform(struct!.pqMode),
    pq_on_backpressure: cdktf.stringToTerraform(struct!.pqOnBackpressure),
    pq_path: cdktf.stringToTerraform(struct!.pqPath),
    prometheus_auth: packDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2PrometheusAuthToTerraform(struct!.prometheusAuth),
    prometheus_url: cdktf.stringToTerraform(struct!.prometheusUrl),
    reject_unauthorized: cdktf.booleanToTerraform(struct!.rejectUnauthorized),
    response_honor_retry_after_header: cdktf.booleanToTerraform(struct!.responseHonorRetryAfterHeader),
    response_retry_settings: cdktf.listMapper(packDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2ResponseRetrySettingsToTerraform, false)(struct!.responseRetrySettings),
    safe_headers: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.safeHeaders),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    system_fields: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.systemFields),
    timeout_retry_settings: packDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2TimeoutRetrySettingsToTerraform(struct!.timeoutRetrySettings),
    timeout_sec: cdktf.numberToTerraform(struct!.timeoutSec),
    type: cdktf.stringToTerraform(struct!.type),
    use_round_robin_dns: cdktf.booleanToTerraform(struct!.useRoundRobinDns),
  }
}


export function packDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2ToHclTerraform(struct?: PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2 | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    compress: {
      value: cdktf.booleanToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    concurrency: {
      value: cdktf.numberToHclTerraform(struct!.concurrency),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    extra_http_headers: {
      value: cdktf.listMapperHcl(packDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2ExtraHttpHeadersToHclTerraform, false)(struct!.extraHttpHeaders),
      isBlock: true,
      type: "list",
      storageClassType: "PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2ExtraHttpHeadersList",
    },
    failed_request_logging_mode: {
      value: cdktf.stringToHclTerraform(struct!.failedRequestLoggingMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    flush_period_sec: {
      value: cdktf.numberToHclTerraform(struct!.flushPeriodSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    labels: {
      value: cdktf.listMapperHcl(packDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2LabelsToHclTerraform, false)(struct!.labels),
      isBlock: true,
      type: "list",
      storageClassType: "PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2LabelsList",
    },
    loki_auth: {
      value: packDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2LokiAuthToHclTerraform(struct!.lokiAuth),
      isBlock: true,
      type: "struct",
      storageClassType: "PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2LokiAuth",
    },
    loki_url: {
      value: cdktf.stringToHclTerraform(struct!.lokiUrl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_payload_events: {
      value: cdktf.numberToHclTerraform(struct!.maxPayloadEvents),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_payload_size_kb: {
      value: cdktf.numberToHclTerraform(struct!.maxPayloadSizeKb),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    message: {
      value: cdktf.stringToHclTerraform(struct!.message),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    message_format: {
      value: cdktf.stringToHclTerraform(struct!.messageFormat),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    metric_rename_expr: {
      value: cdktf.stringToHclTerraform(struct!.metricRenameExpr),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.onBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_compress: {
      value: cdktf.stringToHclTerraform(struct!.pqCompress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_controls: {
      value: packDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2PqControlsToHclTerraform(struct!.pqControls),
      isBlock: true,
      type: "struct",
      storageClassType: "PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2PqControls",
    },
    pq_max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_max_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_mode: {
      value: cdktf.stringToHclTerraform(struct!.pqMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.pqOnBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_path: {
      value: cdktf.stringToHclTerraform(struct!.pqPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    prometheus_auth: {
      value: packDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2PrometheusAuthToHclTerraform(struct!.prometheusAuth),
      isBlock: true,
      type: "struct",
      storageClassType: "PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2PrometheusAuth",
    },
    prometheus_url: {
      value: cdktf.stringToHclTerraform(struct!.prometheusUrl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reject_unauthorized: {
      value: cdktf.booleanToHclTerraform(struct!.rejectUnauthorized),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    response_honor_retry_after_header: {
      value: cdktf.booleanToHclTerraform(struct!.responseHonorRetryAfterHeader),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    response_retry_settings: {
      value: cdktf.listMapperHcl(packDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2ResponseRetrySettingsToHclTerraform, false)(struct!.responseRetrySettings),
      isBlock: true,
      type: "list",
      storageClassType: "PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2ResponseRetrySettingsList",
    },
    safe_headers: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.safeHeaders),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    system_fields: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.systemFields),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    timeout_retry_settings: {
      value: packDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2TimeoutRetrySettingsToHclTerraform(struct!.timeoutRetrySettings),
      isBlock: true,
      type: "struct",
      storageClassType: "PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2TimeoutRetrySettings",
    },
    timeout_sec: {
      value: cdktf.numberToHclTerraform(struct!.timeoutSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    use_round_robin_dns: {
      value: cdktf.booleanToHclTerraform(struct!.useRoundRobinDns),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2OutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2 | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._concurrency !== undefined) {
      hasAnyValues = true;
      internalValueResult.concurrency = this._concurrency;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._extraHttpHeaders?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.extraHttpHeaders = this._extraHttpHeaders?.internalValue;
    }
    if (this._failedRequestLoggingMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.failedRequestLoggingMode = this._failedRequestLoggingMode;
    }
    if (this._flushPeriodSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.flushPeriodSec = this._flushPeriodSec;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._labels?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.labels = this._labels?.internalValue;
    }
    if (this._lokiAuth?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.lokiAuth = this._lokiAuth?.internalValue;
    }
    if (this._lokiUrl !== undefined) {
      hasAnyValues = true;
      internalValueResult.lokiUrl = this._lokiUrl;
    }
    if (this._maxPayloadEvents !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxPayloadEvents = this._maxPayloadEvents;
    }
    if (this._maxPayloadSizeKb !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxPayloadSizeKb = this._maxPayloadSizeKb;
    }
    if (this._message !== undefined) {
      hasAnyValues = true;
      internalValueResult.message = this._message;
    }
    if (this._messageFormat !== undefined) {
      hasAnyValues = true;
      internalValueResult.messageFormat = this._messageFormat;
    }
    if (this._metricRenameExpr !== undefined) {
      hasAnyValues = true;
      internalValueResult.metricRenameExpr = this._metricRenameExpr;
    }
    if (this._onBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.onBackpressure = this._onBackpressure;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._pqCompress !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqCompress = this._pqCompress;
    }
    if (this._pqControls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqControls = this._pqControls?.internalValue;
    }
    if (this._pqMaxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxFileSize = this._pqMaxFileSize;
    }
    if (this._pqMaxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxSize = this._pqMaxSize;
    }
    if (this._pqMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMode = this._pqMode;
    }
    if (this._pqOnBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqOnBackpressure = this._pqOnBackpressure;
    }
    if (this._pqPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqPath = this._pqPath;
    }
    if (this._prometheusAuth?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.prometheusAuth = this._prometheusAuth?.internalValue;
    }
    if (this._prometheusUrl !== undefined) {
      hasAnyValues = true;
      internalValueResult.prometheusUrl = this._prometheusUrl;
    }
    if (this._rejectUnauthorized !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectUnauthorized = this._rejectUnauthorized;
    }
    if (this._responseHonorRetryAfterHeader !== undefined) {
      hasAnyValues = true;
      internalValueResult.responseHonorRetryAfterHeader = this._responseHonorRetryAfterHeader;
    }
    if (this._responseRetrySettings?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.responseRetrySettings = this._responseRetrySettings?.internalValue;
    }
    if (this._safeHeaders !== undefined) {
      hasAnyValues = true;
      internalValueResult.safeHeaders = this._safeHeaders;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._systemFields !== undefined) {
      hasAnyValues = true;
      internalValueResult.systemFields = this._systemFields;
    }
    if (this._timeoutRetrySettings?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutRetrySettings = this._timeoutRetrySettings?.internalValue;
    }
    if (this._timeoutSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutSec = this._timeoutSec;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._useRoundRobinDns !== undefined) {
      hasAnyValues = true;
      internalValueResult.useRoundRobinDns = this._useRoundRobinDns;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2 | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._compress = undefined;
      this._concurrency = undefined;
      this._description = undefined;
      this._environment = undefined;
      this._extraHttpHeaders.internalValue = undefined;
      this._failedRequestLoggingMode = undefined;
      this._flushPeriodSec = undefined;
      this._id = undefined;
      this._labels.internalValue = undefined;
      this._lokiAuth.internalValue = undefined;
      this._lokiUrl = undefined;
      this._maxPayloadEvents = undefined;
      this._maxPayloadSizeKb = undefined;
      this._message = undefined;
      this._messageFormat = undefined;
      this._metricRenameExpr = undefined;
      this._onBackpressure = undefined;
      this._pipeline = undefined;
      this._pqCompress = undefined;
      this._pqControls.internalValue = undefined;
      this._pqMaxFileSize = undefined;
      this._pqMaxSize = undefined;
      this._pqMode = undefined;
      this._pqOnBackpressure = undefined;
      this._pqPath = undefined;
      this._prometheusAuth.internalValue = undefined;
      this._prometheusUrl = undefined;
      this._rejectUnauthorized = undefined;
      this._responseHonorRetryAfterHeader = undefined;
      this._responseRetrySettings.internalValue = undefined;
      this._safeHeaders = undefined;
      this._streamtags = undefined;
      this._systemFields = undefined;
      this._timeoutRetrySettings.internalValue = undefined;
      this._timeoutSec = undefined;
      this._type = undefined;
      this._useRoundRobinDns = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._compress = value.compress;
      this._concurrency = value.concurrency;
      this._description = value.description;
      this._environment = value.environment;
      this._extraHttpHeaders.internalValue = value.extraHttpHeaders;
      this._failedRequestLoggingMode = value.failedRequestLoggingMode;
      this._flushPeriodSec = value.flushPeriodSec;
      this._id = value.id;
      this._labels.internalValue = value.labels;
      this._lokiAuth.internalValue = value.lokiAuth;
      this._lokiUrl = value.lokiUrl;
      this._maxPayloadEvents = value.maxPayloadEvents;
      this._maxPayloadSizeKb = value.maxPayloadSizeKb;
      this._message = value.message;
      this._messageFormat = value.messageFormat;
      this._metricRenameExpr = value.metricRenameExpr;
      this._onBackpressure = value.onBackpressure;
      this._pipeline = value.pipeline;
      this._pqCompress = value.pqCompress;
      this._pqControls.internalValue = value.pqControls;
      this._pqMaxFileSize = value.pqMaxFileSize;
      this._pqMaxSize = value.pqMaxSize;
      this._pqMode = value.pqMode;
      this._pqOnBackpressure = value.pqOnBackpressure;
      this._pqPath = value.pqPath;
      this._prometheusAuth.internalValue = value.prometheusAuth;
      this._prometheusUrl = value.prometheusUrl;
      this._rejectUnauthorized = value.rejectUnauthorized;
      this._responseHonorRetryAfterHeader = value.responseHonorRetryAfterHeader;
      this._responseRetrySettings.internalValue = value.responseRetrySettings;
      this._safeHeaders = value.safeHeaders;
      this._streamtags = value.streamtags;
      this._systemFields = value.systemFields;
      this._timeoutRetrySettings.internalValue = value.timeoutRetrySettings;
      this._timeoutSec = value.timeoutSec;
      this._type = value.type;
      this._useRoundRobinDns = value.useRoundRobinDns;
    }
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: boolean | cdktf.IResolvable; 
  public get compress() {
    return this.getBooleanAttribute('compress');
  }
  public set compress(value: boolean | cdktf.IResolvable) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // concurrency - computed: true, optional: true, required: false
  private _concurrency?: number; 
  public get concurrency() {
    return this.getNumberAttribute('concurrency');
  }
  public set concurrency(value: number) {
    this._concurrency = value;
  }
  public resetConcurrency() {
    this._concurrency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get concurrencyInput() {
    return this._concurrency;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // extra_http_headers - computed: false, optional: true, required: false
  private _extraHttpHeaders = new PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2ExtraHttpHeadersList(this, "extra_http_headers", false);
  public get extraHttpHeaders() {
    return this._extraHttpHeaders;
  }
  public putExtraHttpHeaders(value: PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2ExtraHttpHeaders[] | cdktf.IResolvable) {
    this._extraHttpHeaders.internalValue = value;
  }
  public resetExtraHttpHeaders() {
    this._extraHttpHeaders.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get extraHttpHeadersInput() {
    return this._extraHttpHeaders.internalValue;
  }

  // failed_request_logging_mode - computed: true, optional: true, required: false
  private _failedRequestLoggingMode?: string; 
  public get failedRequestLoggingMode() {
    return this.getStringAttribute('failed_request_logging_mode');
  }
  public set failedRequestLoggingMode(value: string) {
    this._failedRequestLoggingMode = value;
  }
  public resetFailedRequestLoggingMode() {
    this._failedRequestLoggingMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get failedRequestLoggingModeInput() {
    return this._failedRequestLoggingMode;
  }

  // flush_period_sec - computed: true, optional: true, required: false
  private _flushPeriodSec?: number; 
  public get flushPeriodSec() {
    return this.getNumberAttribute('flush_period_sec');
  }
  public set flushPeriodSec(value: number) {
    this._flushPeriodSec = value;
  }
  public resetFlushPeriodSec() {
    this._flushPeriodSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get flushPeriodSecInput() {
    return this._flushPeriodSec;
  }

  // id - computed: false, optional: false, required: true
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // labels - computed: false, optional: true, required: false
  private _labels = new PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2LabelsList(this, "labels", false);
  public get labels() {
    return this._labels;
  }
  public putLabels(value: PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2Labels[] | cdktf.IResolvable) {
    this._labels.internalValue = value;
  }
  public resetLabels() {
    this._labels.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelsInput() {
    return this._labels.internalValue;
  }

  // loki_auth - computed: false, optional: true, required: false
  private _lokiAuth = new PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2LokiAuthOutputReference(this, "loki_auth");
  public get lokiAuth() {
    return this._lokiAuth;
  }
  public putLokiAuth(value: PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2LokiAuth) {
    this._lokiAuth.internalValue = value;
  }
  public resetLokiAuth() {
    this._lokiAuth.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get lokiAuthInput() {
    return this._lokiAuth.internalValue;
  }

  // loki_url - computed: false, optional: true, required: false
  private _lokiUrl?: string; 
  public get lokiUrl() {
    return this.getStringAttribute('loki_url');
  }
  public set lokiUrl(value: string) {
    this._lokiUrl = value;
  }
  public resetLokiUrl() {
    this._lokiUrl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get lokiUrlInput() {
    return this._lokiUrl;
  }

  // max_payload_events - computed: true, optional: true, required: false
  private _maxPayloadEvents?: number; 
  public get maxPayloadEvents() {
    return this.getNumberAttribute('max_payload_events');
  }
  public set maxPayloadEvents(value: number) {
    this._maxPayloadEvents = value;
  }
  public resetMaxPayloadEvents() {
    this._maxPayloadEvents = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxPayloadEventsInput() {
    return this._maxPayloadEvents;
  }

  // max_payload_size_kb - computed: true, optional: true, required: false
  private _maxPayloadSizeKb?: number; 
  public get maxPayloadSizeKb() {
    return this.getNumberAttribute('max_payload_size_kb');
  }
  public set maxPayloadSizeKb(value: number) {
    this._maxPayloadSizeKb = value;
  }
  public resetMaxPayloadSizeKb() {
    this._maxPayloadSizeKb = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxPayloadSizeKbInput() {
    return this._maxPayloadSizeKb;
  }

  // message - computed: false, optional: true, required: false
  private _message?: string; 
  public get message() {
    return this.getStringAttribute('message');
  }
  public set message(value: string) {
    this._message = value;
  }
  public resetMessage() {
    this._message = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get messageInput() {
    return this._message;
  }

  // message_format - computed: true, optional: true, required: false
  private _messageFormat?: string; 
  public get messageFormat() {
    return this.getStringAttribute('message_format');
  }
  public set messageFormat(value: string) {
    this._messageFormat = value;
  }
  public resetMessageFormat() {
    this._messageFormat = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get messageFormatInput() {
    return this._messageFormat;
  }

  // metric_rename_expr - computed: true, optional: true, required: false
  private _metricRenameExpr?: string; 
  public get metricRenameExpr() {
    return this.getStringAttribute('metric_rename_expr');
  }
  public set metricRenameExpr(value: string) {
    this._metricRenameExpr = value;
  }
  public resetMetricRenameExpr() {
    this._metricRenameExpr = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metricRenameExprInput() {
    return this._metricRenameExpr;
  }

  // on_backpressure - computed: true, optional: true, required: false
  private _onBackpressure?: string; 
  public get onBackpressure() {
    return this.getStringAttribute('on_backpressure');
  }
  public set onBackpressure(value: string) {
    this._onBackpressure = value;
  }
  public resetOnBackpressure() {
    this._onBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get onBackpressureInput() {
    return this._onBackpressure;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // pq_compress - computed: true, optional: true, required: false
  private _pqCompress?: string; 
  public get pqCompress() {
    return this.getStringAttribute('pq_compress');
  }
  public set pqCompress(value: string) {
    this._pqCompress = value;
  }
  public resetPqCompress() {
    this._pqCompress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqCompressInput() {
    return this._pqCompress;
  }

  // pq_controls - computed: false, optional: true, required: false
  private _pqControls = new PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2PqControlsOutputReference(this, "pq_controls");
  public get pqControls() {
    return this._pqControls;
  }
  public putPqControls(value: PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2PqControls) {
    this._pqControls.internalValue = value;
  }
  public resetPqControls() {
    this._pqControls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqControlsInput() {
    return this._pqControls.internalValue;
  }

  // pq_max_file_size - computed: true, optional: true, required: false
  private _pqMaxFileSize?: string; 
  public get pqMaxFileSize() {
    return this.getStringAttribute('pq_max_file_size');
  }
  public set pqMaxFileSize(value: string) {
    this._pqMaxFileSize = value;
  }
  public resetPqMaxFileSize() {
    this._pqMaxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxFileSizeInput() {
    return this._pqMaxFileSize;
  }

  // pq_max_size - computed: true, optional: true, required: false
  private _pqMaxSize?: string; 
  public get pqMaxSize() {
    return this.getStringAttribute('pq_max_size');
  }
  public set pqMaxSize(value: string) {
    this._pqMaxSize = value;
  }
  public resetPqMaxSize() {
    this._pqMaxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxSizeInput() {
    return this._pqMaxSize;
  }

  // pq_mode - computed: true, optional: true, required: false
  private _pqMode?: string; 
  public get pqMode() {
    return this.getStringAttribute('pq_mode');
  }
  public set pqMode(value: string) {
    this._pqMode = value;
  }
  public resetPqMode() {
    this._pqMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqModeInput() {
    return this._pqMode;
  }

  // pq_on_backpressure - computed: true, optional: true, required: false
  private _pqOnBackpressure?: string; 
  public get pqOnBackpressure() {
    return this.getStringAttribute('pq_on_backpressure');
  }
  public set pqOnBackpressure(value: string) {
    this._pqOnBackpressure = value;
  }
  public resetPqOnBackpressure() {
    this._pqOnBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqOnBackpressureInput() {
    return this._pqOnBackpressure;
  }

  // pq_path - computed: true, optional: true, required: false
  private _pqPath?: string; 
  public get pqPath() {
    return this.getStringAttribute('pq_path');
  }
  public set pqPath(value: string) {
    this._pqPath = value;
  }
  public resetPqPath() {
    this._pqPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqPathInput() {
    return this._pqPath;
  }

  // prometheus_auth - computed: false, optional: true, required: false
  private _prometheusAuth = new PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2PrometheusAuthOutputReference(this, "prometheus_auth");
  public get prometheusAuth() {
    return this._prometheusAuth;
  }
  public putPrometheusAuth(value: PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2PrometheusAuth) {
    this._prometheusAuth.internalValue = value;
  }
  public resetPrometheusAuth() {
    this._prometheusAuth.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get prometheusAuthInput() {
    return this._prometheusAuth.internalValue;
  }

  // prometheus_url - computed: false, optional: false, required: true
  private _prometheusUrl?: string; 
  public get prometheusUrl() {
    return this.getStringAttribute('prometheus_url');
  }
  public set prometheusUrl(value: string) {
    this._prometheusUrl = value;
  }
  // Temporarily expose input value. Use with caution.
  public get prometheusUrlInput() {
    return this._prometheusUrl;
  }

  // reject_unauthorized - computed: true, optional: true, required: false
  private _rejectUnauthorized?: boolean | cdktf.IResolvable; 
  public get rejectUnauthorized() {
    return this.getBooleanAttribute('reject_unauthorized');
  }
  public set rejectUnauthorized(value: boolean | cdktf.IResolvable) {
    this._rejectUnauthorized = value;
  }
  public resetRejectUnauthorized() {
    this._rejectUnauthorized = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectUnauthorizedInput() {
    return this._rejectUnauthorized;
  }

  // response_honor_retry_after_header - computed: true, optional: true, required: false
  private _responseHonorRetryAfterHeader?: boolean | cdktf.IResolvable; 
  public get responseHonorRetryAfterHeader() {
    return this.getBooleanAttribute('response_honor_retry_after_header');
  }
  public set responseHonorRetryAfterHeader(value: boolean | cdktf.IResolvable) {
    this._responseHonorRetryAfterHeader = value;
  }
  public resetResponseHonorRetryAfterHeader() {
    this._responseHonorRetryAfterHeader = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get responseHonorRetryAfterHeaderInput() {
    return this._responseHonorRetryAfterHeader;
  }

  // response_retry_settings - computed: false, optional: true, required: false
  private _responseRetrySettings = new PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2ResponseRetrySettingsList(this, "response_retry_settings", false);
  public get responseRetrySettings() {
    return this._responseRetrySettings;
  }
  public putResponseRetrySettings(value: PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2ResponseRetrySettings[] | cdktf.IResolvable) {
    this._responseRetrySettings.internalValue = value;
  }
  public resetResponseRetrySettings() {
    this._responseRetrySettings.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get responseRetrySettingsInput() {
    return this._responseRetrySettings.internalValue;
  }

  // safe_headers - computed: true, optional: true, required: false
  private _safeHeaders?: string[]; 
  public get safeHeaders() {
    return this.getListAttribute('safe_headers');
  }
  public set safeHeaders(value: string[]) {
    this._safeHeaders = value;
  }
  public resetSafeHeaders() {
    this._safeHeaders = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get safeHeadersInput() {
    return this._safeHeaders;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // system_fields - computed: true, optional: true, required: false
  private _systemFields?: string[]; 
  public get systemFields() {
    return this.getListAttribute('system_fields');
  }
  public set systemFields(value: string[]) {
    this._systemFields = value;
  }
  public resetSystemFields() {
    this._systemFields = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get systemFieldsInput() {
    return this._systemFields;
  }

  // timeout_retry_settings - computed: false, optional: true, required: false
  private _timeoutRetrySettings = new PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2TimeoutRetrySettingsOutputReference(this, "timeout_retry_settings");
  public get timeoutRetrySettings() {
    return this._timeoutRetrySettings;
  }
  public putTimeoutRetrySettings(value: PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2TimeoutRetrySettings) {
    this._timeoutRetrySettings.internalValue = value;
  }
  public resetTimeoutRetrySettings() {
    this._timeoutRetrySettings.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutRetrySettingsInput() {
    return this._timeoutRetrySettings.internalValue;
  }

  // timeout_sec - computed: true, optional: true, required: false
  private _timeoutSec?: number; 
  public get timeoutSec() {
    return this.getNumberAttribute('timeout_sec');
  }
  public set timeoutSec(value: number) {
    this._timeoutSec = value;
  }
  public resetTimeoutSec() {
    this._timeoutSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutSecInput() {
    return this._timeoutSec;
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // use_round_robin_dns - computed: true, optional: true, required: false
  private _useRoundRobinDns?: boolean | cdktf.IResolvable; 
  public get useRoundRobinDns() {
    return this.getBooleanAttribute('use_round_robin_dns');
  }
  public set useRoundRobinDns(value: boolean | cdktf.IResolvable) {
    this._useRoundRobinDns = value;
  }
  public resetUseRoundRobinDns() {
    this._useRoundRobinDns = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get useRoundRobinDnsInput() {
    return this._useRoundRobinDns;
  }
}
export interface PackDestinationOutputGrafanaCloud {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#output_grafana_cloud_grafana_cloud1 PackDestination#output_grafana_cloud_grafana_cloud1}
  */
  readonly outputGrafanaCloudGrafanaCloud1?: PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#output_grafana_cloud_grafana_cloud2 PackDestination#output_grafana_cloud_grafana_cloud2}
  */
  readonly outputGrafanaCloudGrafanaCloud2?: PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2;
}

export function packDestinationOutputGrafanaCloudToTerraform(struct?: PackDestinationOutputGrafanaCloud | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    output_grafana_cloud_grafana_cloud1: packDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1ToTerraform(struct!.outputGrafanaCloudGrafanaCloud1),
    output_grafana_cloud_grafana_cloud2: packDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2ToTerraform(struct!.outputGrafanaCloudGrafanaCloud2),
  }
}


export function packDestinationOutputGrafanaCloudToHclTerraform(struct?: PackDestinationOutputGrafanaCloud | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    output_grafana_cloud_grafana_cloud1: {
      value: packDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1ToHclTerraform(struct!.outputGrafanaCloudGrafanaCloud1),
      isBlock: true,
      type: "struct",
      storageClassType: "PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1",
    },
    output_grafana_cloud_grafana_cloud2: {
      value: packDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2ToHclTerraform(struct!.outputGrafanaCloudGrafanaCloud2),
      isBlock: true,
      type: "struct",
      storageClassType: "PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputGrafanaCloudOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackDestinationOutputGrafanaCloud | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._outputGrafanaCloudGrafanaCloud1?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.outputGrafanaCloudGrafanaCloud1 = this._outputGrafanaCloudGrafanaCloud1?.internalValue;
    }
    if (this._outputGrafanaCloudGrafanaCloud2?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.outputGrafanaCloudGrafanaCloud2 = this._outputGrafanaCloudGrafanaCloud2?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputGrafanaCloud | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._outputGrafanaCloudGrafanaCloud1.internalValue = undefined;
      this._outputGrafanaCloudGrafanaCloud2.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._outputGrafanaCloudGrafanaCloud1.internalValue = value.outputGrafanaCloudGrafanaCloud1;
      this._outputGrafanaCloudGrafanaCloud2.internalValue = value.outputGrafanaCloudGrafanaCloud2;
    }
  }

  // output_grafana_cloud_grafana_cloud1 - computed: false, optional: true, required: false
  private _outputGrafanaCloudGrafanaCloud1 = new PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1OutputReference(this, "output_grafana_cloud_grafana_cloud1");
  public get outputGrafanaCloudGrafanaCloud1() {
    return this._outputGrafanaCloudGrafanaCloud1;
  }
  public putOutputGrafanaCloudGrafanaCloud1(value: PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1) {
    this._outputGrafanaCloudGrafanaCloud1.internalValue = value;
  }
  public resetOutputGrafanaCloudGrafanaCloud1() {
    this._outputGrafanaCloudGrafanaCloud1.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get outputGrafanaCloudGrafanaCloud1Input() {
    return this._outputGrafanaCloudGrafanaCloud1.internalValue;
  }

  // output_grafana_cloud_grafana_cloud2 - computed: false, optional: true, required: false
  private _outputGrafanaCloudGrafanaCloud2 = new PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2OutputReference(this, "output_grafana_cloud_grafana_cloud2");
  public get outputGrafanaCloudGrafanaCloud2() {
    return this._outputGrafanaCloudGrafanaCloud2;
  }
  public putOutputGrafanaCloudGrafanaCloud2(value: PackDestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2) {
    this._outputGrafanaCloudGrafanaCloud2.internalValue = value;
  }
  public resetOutputGrafanaCloudGrafanaCloud2() {
    this._outputGrafanaCloudGrafanaCloud2.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get outputGrafanaCloudGrafanaCloud2Input() {
    return this._outputGrafanaCloudGrafanaCloud2.internalValue;
  }
}
export interface PackDestinationOutputGraphitePqControls {
}

export function packDestinationOutputGraphitePqControlsToTerraform(struct?: PackDestinationOutputGraphitePqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function packDestinationOutputGraphitePqControlsToHclTerraform(struct?: PackDestinationOutputGraphitePqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class PackDestinationOutputGraphitePqControlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackDestinationOutputGraphitePqControls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputGraphitePqControls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface PackDestinationOutputGraphite {
  /**
  * Amount of time (milliseconds) to wait for the connection to establish before retrying. Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#connection_timeout PackDestination#connection_timeout}
  */
  readonly connectionTimeout?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#description PackDestination#description}
  */
  readonly description?: string;
  /**
  * How often to resolve the destination hostname to an IP address. Ignored if the destination is an IP address. A value of 0 means every batch sent will incur a DNS lookup. Default: 0
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#dns_resolve_period_sec PackDestination#dns_resolve_period_sec}
  */
  readonly dnsResolvePeriodSec?: number;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#environment PackDestination#environment}
  */
  readonly environment?: string;
  /**
  * When protocol is TCP, specifies how often buffers should be flushed, resulting in records sent to the destination. Default: 1
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#flush_period_sec PackDestination#flush_period_sec}
  */
  readonly flushPeriodSec?: number;
  /**
  * The hostname of the destination.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#host PackDestination#host}
  */
  readonly host: string;
  /**
  * Unique ID for this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#id PackDestination#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * When protocol is UDP, specifies the maximum size of packets sent to the destination. Also known as the MTU for the network path to the destination system. Default: 512
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#mtu PackDestination#mtu}
  */
  readonly mtu?: number;
  /**
  * How to handle events when all receivers are exerting backpressure. Default: "block"; must be one of ["block", "drop", "queue"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#on_backpressure PackDestination#on_backpressure}
  */
  readonly onBackpressure?: string;
  /**
  * Pipeline to process data before sending out to this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pipeline PackDestination#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Destination port. Default: 8125
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#port PackDestination#port}
  */
  readonly port?: number;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_compress PackDestination#pq_compress}
  */
  readonly pqCompress?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_controls PackDestination#pq_controls}
  */
  readonly pqControls?: PackDestinationOutputGraphitePqControls;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.). Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_max_file_size PackDestination#pq_max_file_size}
  */
  readonly pqMaxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_max_size PackDestination#pq_max_size}
  */
  readonly pqMaxSize?: string;
  /**
  * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem. Default: "error"; must be one of ["error", "backpressure", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_mode PackDestination#pq_mode}
  */
  readonly pqMode?: string;
  /**
  * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged. Default: "block"; must be one of ["block", "drop"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_on_backpressure PackDestination#pq_on_backpressure}
  */
  readonly pqOnBackpressure?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_path PackDestination#pq_path}
  */
  readonly pqPath?: string;
  /**
  * Protocol to use when communicating with the destination. Default: "udp"; must be one of ["udp", "tcp"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#protocol PackDestination#protocol}
  */
  readonly protocol?: string;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#streamtags PackDestination#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Fields to automatically add to events, such as cribl_pipe. Supports wildcards. Default: ["cribl_pipe"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#system_fields PackDestination#system_fields}
  */
  readonly systemFields?: string[];
  /**
  * Rate (in bytes per second) to throttle while writing to an output. Accepts values with multiple-byte units, such as KB, MB, and GB. (Example: 42 MB) Default value of 0 specifies no throttling. Default: "0"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#throttle_rate_per_sec PackDestination#throttle_rate_per_sec}
  */
  readonly throttleRatePerSec?: string;
  /**
  * must be "graphite"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#type PackDestination#type}
  */
  readonly type?: string;
  /**
  * Amount of time (milliseconds) to wait for a write to complete before assuming connection is dead. Default: 60000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#write_timeout PackDestination#write_timeout}
  */
  readonly writeTimeout?: number;
}

export function packDestinationOutputGraphiteToTerraform(struct?: PackDestinationOutputGraphite | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    connection_timeout: cdktf.numberToTerraform(struct!.connectionTimeout),
    description: cdktf.stringToTerraform(struct!.description),
    dns_resolve_period_sec: cdktf.numberToTerraform(struct!.dnsResolvePeriodSec),
    environment: cdktf.stringToTerraform(struct!.environment),
    flush_period_sec: cdktf.numberToTerraform(struct!.flushPeriodSec),
    host: cdktf.stringToTerraform(struct!.host),
    id: cdktf.stringToTerraform(struct!.id),
    mtu: cdktf.numberToTerraform(struct!.mtu),
    on_backpressure: cdktf.stringToTerraform(struct!.onBackpressure),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    port: cdktf.numberToTerraform(struct!.port),
    pq_compress: cdktf.stringToTerraform(struct!.pqCompress),
    pq_controls: packDestinationOutputGraphitePqControlsToTerraform(struct!.pqControls),
    pq_max_file_size: cdktf.stringToTerraform(struct!.pqMaxFileSize),
    pq_max_size: cdktf.stringToTerraform(struct!.pqMaxSize),
    pq_mode: cdktf.stringToTerraform(struct!.pqMode),
    pq_on_backpressure: cdktf.stringToTerraform(struct!.pqOnBackpressure),
    pq_path: cdktf.stringToTerraform(struct!.pqPath),
    protocol: cdktf.stringToTerraform(struct!.protocol),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    system_fields: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.systemFields),
    throttle_rate_per_sec: cdktf.stringToTerraform(struct!.throttleRatePerSec),
    type: cdktf.stringToTerraform(struct!.type),
    write_timeout: cdktf.numberToTerraform(struct!.writeTimeout),
  }
}


export function packDestinationOutputGraphiteToHclTerraform(struct?: PackDestinationOutputGraphite | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    connection_timeout: {
      value: cdktf.numberToHclTerraform(struct!.connectionTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    dns_resolve_period_sec: {
      value: cdktf.numberToHclTerraform(struct!.dnsResolvePeriodSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    flush_period_sec: {
      value: cdktf.numberToHclTerraform(struct!.flushPeriodSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    host: {
      value: cdktf.stringToHclTerraform(struct!.host),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    mtu: {
      value: cdktf.numberToHclTerraform(struct!.mtu),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.onBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    pq_compress: {
      value: cdktf.stringToHclTerraform(struct!.pqCompress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_controls: {
      value: packDestinationOutputGraphitePqControlsToHclTerraform(struct!.pqControls),
      isBlock: true,
      type: "struct",
      storageClassType: "PackDestinationOutputGraphitePqControls",
    },
    pq_max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_max_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_mode: {
      value: cdktf.stringToHclTerraform(struct!.pqMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.pqOnBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_path: {
      value: cdktf.stringToHclTerraform(struct!.pqPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    protocol: {
      value: cdktf.stringToHclTerraform(struct!.protocol),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    system_fields: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.systemFields),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    throttle_rate_per_sec: {
      value: cdktf.stringToHclTerraform(struct!.throttleRatePerSec),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    write_timeout: {
      value: cdktf.numberToHclTerraform(struct!.writeTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputGraphiteOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackDestinationOutputGraphite | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._connectionTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.connectionTimeout = this._connectionTimeout;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._dnsResolvePeriodSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.dnsResolvePeriodSec = this._dnsResolvePeriodSec;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._flushPeriodSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.flushPeriodSec = this._flushPeriodSec;
    }
    if (this._host !== undefined) {
      hasAnyValues = true;
      internalValueResult.host = this._host;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._mtu !== undefined) {
      hasAnyValues = true;
      internalValueResult.mtu = this._mtu;
    }
    if (this._onBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.onBackpressure = this._onBackpressure;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._pqCompress !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqCompress = this._pqCompress;
    }
    if (this._pqControls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqControls = this._pqControls?.internalValue;
    }
    if (this._pqMaxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxFileSize = this._pqMaxFileSize;
    }
    if (this._pqMaxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxSize = this._pqMaxSize;
    }
    if (this._pqMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMode = this._pqMode;
    }
    if (this._pqOnBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqOnBackpressure = this._pqOnBackpressure;
    }
    if (this._pqPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqPath = this._pqPath;
    }
    if (this._protocol !== undefined) {
      hasAnyValues = true;
      internalValueResult.protocol = this._protocol;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._systemFields !== undefined) {
      hasAnyValues = true;
      internalValueResult.systemFields = this._systemFields;
    }
    if (this._throttleRatePerSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.throttleRatePerSec = this._throttleRatePerSec;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._writeTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.writeTimeout = this._writeTimeout;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputGraphite | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._connectionTimeout = undefined;
      this._description = undefined;
      this._dnsResolvePeriodSec = undefined;
      this._environment = undefined;
      this._flushPeriodSec = undefined;
      this._host = undefined;
      this._id = undefined;
      this._mtu = undefined;
      this._onBackpressure = undefined;
      this._pipeline = undefined;
      this._port = undefined;
      this._pqCompress = undefined;
      this._pqControls.internalValue = undefined;
      this._pqMaxFileSize = undefined;
      this._pqMaxSize = undefined;
      this._pqMode = undefined;
      this._pqOnBackpressure = undefined;
      this._pqPath = undefined;
      this._protocol = undefined;
      this._streamtags = undefined;
      this._systemFields = undefined;
      this._throttleRatePerSec = undefined;
      this._type = undefined;
      this._writeTimeout = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._connectionTimeout = value.connectionTimeout;
      this._description = value.description;
      this._dnsResolvePeriodSec = value.dnsResolvePeriodSec;
      this._environment = value.environment;
      this._flushPeriodSec = value.flushPeriodSec;
      this._host = value.host;
      this._id = value.id;
      this._mtu = value.mtu;
      this._onBackpressure = value.onBackpressure;
      this._pipeline = value.pipeline;
      this._port = value.port;
      this._pqCompress = value.pqCompress;
      this._pqControls.internalValue = value.pqControls;
      this._pqMaxFileSize = value.pqMaxFileSize;
      this._pqMaxSize = value.pqMaxSize;
      this._pqMode = value.pqMode;
      this._pqOnBackpressure = value.pqOnBackpressure;
      this._pqPath = value.pqPath;
      this._protocol = value.protocol;
      this._streamtags = value.streamtags;
      this._systemFields = value.systemFields;
      this._throttleRatePerSec = value.throttleRatePerSec;
      this._type = value.type;
      this._writeTimeout = value.writeTimeout;
    }
  }

  // connection_timeout - computed: true, optional: true, required: false
  private _connectionTimeout?: number; 
  public get connectionTimeout() {
    return this.getNumberAttribute('connection_timeout');
  }
  public set connectionTimeout(value: number) {
    this._connectionTimeout = value;
  }
  public resetConnectionTimeout() {
    this._connectionTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectionTimeoutInput() {
    return this._connectionTimeout;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // dns_resolve_period_sec - computed: true, optional: true, required: false
  private _dnsResolvePeriodSec?: number; 
  public get dnsResolvePeriodSec() {
    return this.getNumberAttribute('dns_resolve_period_sec');
  }
  public set dnsResolvePeriodSec(value: number) {
    this._dnsResolvePeriodSec = value;
  }
  public resetDnsResolvePeriodSec() {
    this._dnsResolvePeriodSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dnsResolvePeriodSecInput() {
    return this._dnsResolvePeriodSec;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // flush_period_sec - computed: true, optional: true, required: false
  private _flushPeriodSec?: number; 
  public get flushPeriodSec() {
    return this.getNumberAttribute('flush_period_sec');
  }
  public set flushPeriodSec(value: number) {
    this._flushPeriodSec = value;
  }
  public resetFlushPeriodSec() {
    this._flushPeriodSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get flushPeriodSecInput() {
    return this._flushPeriodSec;
  }

  // host - computed: false, optional: false, required: true
  private _host?: string; 
  public get host() {
    return this.getStringAttribute('host');
  }
  public set host(value: string) {
    this._host = value;
  }
  // Temporarily expose input value. Use with caution.
  public get hostInput() {
    return this._host;
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // mtu - computed: true, optional: true, required: false
  private _mtu?: number; 
  public get mtu() {
    return this.getNumberAttribute('mtu');
  }
  public set mtu(value: number) {
    this._mtu = value;
  }
  public resetMtu() {
    this._mtu = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get mtuInput() {
    return this._mtu;
  }

  // on_backpressure - computed: true, optional: true, required: false
  private _onBackpressure?: string; 
  public get onBackpressure() {
    return this.getStringAttribute('on_backpressure');
  }
  public set onBackpressure(value: string) {
    this._onBackpressure = value;
  }
  public resetOnBackpressure() {
    this._onBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get onBackpressureInput() {
    return this._onBackpressure;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // port - computed: true, optional: true, required: false
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // pq_compress - computed: true, optional: true, required: false
  private _pqCompress?: string; 
  public get pqCompress() {
    return this.getStringAttribute('pq_compress');
  }
  public set pqCompress(value: string) {
    this._pqCompress = value;
  }
  public resetPqCompress() {
    this._pqCompress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqCompressInput() {
    return this._pqCompress;
  }

  // pq_controls - computed: false, optional: true, required: false
  private _pqControls = new PackDestinationOutputGraphitePqControlsOutputReference(this, "pq_controls");
  public get pqControls() {
    return this._pqControls;
  }
  public putPqControls(value: PackDestinationOutputGraphitePqControls) {
    this._pqControls.internalValue = value;
  }
  public resetPqControls() {
    this._pqControls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqControlsInput() {
    return this._pqControls.internalValue;
  }

  // pq_max_file_size - computed: true, optional: true, required: false
  private _pqMaxFileSize?: string; 
  public get pqMaxFileSize() {
    return this.getStringAttribute('pq_max_file_size');
  }
  public set pqMaxFileSize(value: string) {
    this._pqMaxFileSize = value;
  }
  public resetPqMaxFileSize() {
    this._pqMaxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxFileSizeInput() {
    return this._pqMaxFileSize;
  }

  // pq_max_size - computed: true, optional: true, required: false
  private _pqMaxSize?: string; 
  public get pqMaxSize() {
    return this.getStringAttribute('pq_max_size');
  }
  public set pqMaxSize(value: string) {
    this._pqMaxSize = value;
  }
  public resetPqMaxSize() {
    this._pqMaxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxSizeInput() {
    return this._pqMaxSize;
  }

  // pq_mode - computed: true, optional: true, required: false
  private _pqMode?: string; 
  public get pqMode() {
    return this.getStringAttribute('pq_mode');
  }
  public set pqMode(value: string) {
    this._pqMode = value;
  }
  public resetPqMode() {
    this._pqMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqModeInput() {
    return this._pqMode;
  }

  // pq_on_backpressure - computed: true, optional: true, required: false
  private _pqOnBackpressure?: string; 
  public get pqOnBackpressure() {
    return this.getStringAttribute('pq_on_backpressure');
  }
  public set pqOnBackpressure(value: string) {
    this._pqOnBackpressure = value;
  }
  public resetPqOnBackpressure() {
    this._pqOnBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqOnBackpressureInput() {
    return this._pqOnBackpressure;
  }

  // pq_path - computed: true, optional: true, required: false
  private _pqPath?: string; 
  public get pqPath() {
    return this.getStringAttribute('pq_path');
  }
  public set pqPath(value: string) {
    this._pqPath = value;
  }
  public resetPqPath() {
    this._pqPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqPathInput() {
    return this._pqPath;
  }

  // protocol - computed: true, optional: true, required: false
  private _protocol?: string; 
  public get protocol() {
    return this.getStringAttribute('protocol');
  }
  public set protocol(value: string) {
    this._protocol = value;
  }
  public resetProtocol() {
    this._protocol = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get protocolInput() {
    return this._protocol;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // system_fields - computed: true, optional: true, required: false
  private _systemFields?: string[]; 
  public get systemFields() {
    return this.getListAttribute('system_fields');
  }
  public set systemFields(value: string[]) {
    this._systemFields = value;
  }
  public resetSystemFields() {
    this._systemFields = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get systemFieldsInput() {
    return this._systemFields;
  }

  // throttle_rate_per_sec - computed: true, optional: true, required: false
  private _throttleRatePerSec?: string; 
  public get throttleRatePerSec() {
    return this.getStringAttribute('throttle_rate_per_sec');
  }
  public set throttleRatePerSec(value: string) {
    this._throttleRatePerSec = value;
  }
  public resetThrottleRatePerSec() {
    this._throttleRatePerSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get throttleRatePerSecInput() {
    return this._throttleRatePerSec;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // write_timeout - computed: true, optional: true, required: false
  private _writeTimeout?: number; 
  public get writeTimeout() {
    return this.getNumberAttribute('write_timeout');
  }
  public set writeTimeout(value: number) {
    this._writeTimeout = value;
  }
  public resetWriteTimeout() {
    this._writeTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get writeTimeoutInput() {
    return this._writeTimeout;
  }
}
export interface PackDestinationOutputHoneycombExtraHttpHeaders {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#name PackDestination#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#value PackDestination#value}
  */
  readonly value: string;
}

export function packDestinationOutputHoneycombExtraHttpHeadersToTerraform(struct?: PackDestinationOutputHoneycombExtraHttpHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function packDestinationOutputHoneycombExtraHttpHeadersToHclTerraform(struct?: PackDestinationOutputHoneycombExtraHttpHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputHoneycombExtraHttpHeadersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackDestinationOutputHoneycombExtraHttpHeaders | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputHoneycombExtraHttpHeaders | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class PackDestinationOutputHoneycombExtraHttpHeadersList extends cdktf.ComplexList {
  public internalValue? : PackDestinationOutputHoneycombExtraHttpHeaders[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackDestinationOutputHoneycombExtraHttpHeadersOutputReference {
    return new PackDestinationOutputHoneycombExtraHttpHeadersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackDestinationOutputHoneycombPqControls {
}

export function packDestinationOutputHoneycombPqControlsToTerraform(struct?: PackDestinationOutputHoneycombPqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function packDestinationOutputHoneycombPqControlsToHclTerraform(struct?: PackDestinationOutputHoneycombPqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class PackDestinationOutputHoneycombPqControlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackDestinationOutputHoneycombPqControls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputHoneycombPqControls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface PackDestinationOutputHoneycombResponseRetrySettings {
  /**
  * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc. Default: 2
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#backoff_rate PackDestination#backoff_rate}
  */
  readonly backoffRate?: number;
  /**
  * The HTTP response status code that will trigger retries
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#http_status PackDestination#http_status}
  */
  readonly httpStatus: number;
  /**
  * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes). Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#initial_backoff PackDestination#initial_backoff}
  */
  readonly initialBackoff?: number;
  /**
  * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds). Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_backoff PackDestination#max_backoff}
  */
  readonly maxBackoff?: number;
}

export function packDestinationOutputHoneycombResponseRetrySettingsToTerraform(struct?: PackDestinationOutputHoneycombResponseRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    backoff_rate: cdktf.numberToTerraform(struct!.backoffRate),
    http_status: cdktf.numberToTerraform(struct!.httpStatus),
    initial_backoff: cdktf.numberToTerraform(struct!.initialBackoff),
    max_backoff: cdktf.numberToTerraform(struct!.maxBackoff),
  }
}


export function packDestinationOutputHoneycombResponseRetrySettingsToHclTerraform(struct?: PackDestinationOutputHoneycombResponseRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    backoff_rate: {
      value: cdktf.numberToHclTerraform(struct!.backoffRate),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    http_status: {
      value: cdktf.numberToHclTerraform(struct!.httpStatus),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    initial_backoff: {
      value: cdktf.numberToHclTerraform(struct!.initialBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_backoff: {
      value: cdktf.numberToHclTerraform(struct!.maxBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputHoneycombResponseRetrySettingsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackDestinationOutputHoneycombResponseRetrySettings | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._backoffRate !== undefined) {
      hasAnyValues = true;
      internalValueResult.backoffRate = this._backoffRate;
    }
    if (this._httpStatus !== undefined) {
      hasAnyValues = true;
      internalValueResult.httpStatus = this._httpStatus;
    }
    if (this._initialBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.initialBackoff = this._initialBackoff;
    }
    if (this._maxBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBackoff = this._maxBackoff;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputHoneycombResponseRetrySettings | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._backoffRate = undefined;
      this._httpStatus = undefined;
      this._initialBackoff = undefined;
      this._maxBackoff = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._backoffRate = value.backoffRate;
      this._httpStatus = value.httpStatus;
      this._initialBackoff = value.initialBackoff;
      this._maxBackoff = value.maxBackoff;
    }
  }

  // backoff_rate - computed: true, optional: true, required: false
  private _backoffRate?: number; 
  public get backoffRate() {
    return this.getNumberAttribute('backoff_rate');
  }
  public set backoffRate(value: number) {
    this._backoffRate = value;
  }
  public resetBackoffRate() {
    this._backoffRate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get backoffRateInput() {
    return this._backoffRate;
  }

  // http_status - computed: false, optional: false, required: true
  private _httpStatus?: number; 
  public get httpStatus() {
    return this.getNumberAttribute('http_status');
  }
  public set httpStatus(value: number) {
    this._httpStatus = value;
  }
  // Temporarily expose input value. Use with caution.
  public get httpStatusInput() {
    return this._httpStatus;
  }

  // initial_backoff - computed: true, optional: true, required: false
  private _initialBackoff?: number; 
  public get initialBackoff() {
    return this.getNumberAttribute('initial_backoff');
  }
  public set initialBackoff(value: number) {
    this._initialBackoff = value;
  }
  public resetInitialBackoff() {
    this._initialBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get initialBackoffInput() {
    return this._initialBackoff;
  }

  // max_backoff - computed: true, optional: true, required: false
  private _maxBackoff?: number; 
  public get maxBackoff() {
    return this.getNumberAttribute('max_backoff');
  }
  public set maxBackoff(value: number) {
    this._maxBackoff = value;
  }
  public resetMaxBackoff() {
    this._maxBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBackoffInput() {
    return this._maxBackoff;
  }
}

export class PackDestinationOutputHoneycombResponseRetrySettingsList extends cdktf.ComplexList {
  public internalValue? : PackDestinationOutputHoneycombResponseRetrySettings[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackDestinationOutputHoneycombResponseRetrySettingsOutputReference {
    return new PackDestinationOutputHoneycombResponseRetrySettingsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackDestinationOutputHoneycombTimeoutRetrySettings {
  /**
  * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc. Default: 2
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#backoff_rate PackDestination#backoff_rate}
  */
  readonly backoffRate?: number;
  /**
  * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes). Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#initial_backoff PackDestination#initial_backoff}
  */
  readonly initialBackoff?: number;
  /**
  * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds). Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_backoff PackDestination#max_backoff}
  */
  readonly maxBackoff?: number;
  /**
  * Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#timeout_retry PackDestination#timeout_retry}
  */
  readonly timeoutRetry?: boolean | cdktf.IResolvable;
}

export function packDestinationOutputHoneycombTimeoutRetrySettingsToTerraform(struct?: PackDestinationOutputHoneycombTimeoutRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    backoff_rate: cdktf.numberToTerraform(struct!.backoffRate),
    initial_backoff: cdktf.numberToTerraform(struct!.initialBackoff),
    max_backoff: cdktf.numberToTerraform(struct!.maxBackoff),
    timeout_retry: cdktf.booleanToTerraform(struct!.timeoutRetry),
  }
}


export function packDestinationOutputHoneycombTimeoutRetrySettingsToHclTerraform(struct?: PackDestinationOutputHoneycombTimeoutRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    backoff_rate: {
      value: cdktf.numberToHclTerraform(struct!.backoffRate),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    initial_backoff: {
      value: cdktf.numberToHclTerraform(struct!.initialBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_backoff: {
      value: cdktf.numberToHclTerraform(struct!.maxBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    timeout_retry: {
      value: cdktf.booleanToHclTerraform(struct!.timeoutRetry),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputHoneycombTimeoutRetrySettingsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackDestinationOutputHoneycombTimeoutRetrySettings | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._backoffRate !== undefined) {
      hasAnyValues = true;
      internalValueResult.backoffRate = this._backoffRate;
    }
    if (this._initialBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.initialBackoff = this._initialBackoff;
    }
    if (this._maxBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBackoff = this._maxBackoff;
    }
    if (this._timeoutRetry !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutRetry = this._timeoutRetry;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputHoneycombTimeoutRetrySettings | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._backoffRate = undefined;
      this._initialBackoff = undefined;
      this._maxBackoff = undefined;
      this._timeoutRetry = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._backoffRate = value.backoffRate;
      this._initialBackoff = value.initialBackoff;
      this._maxBackoff = value.maxBackoff;
      this._timeoutRetry = value.timeoutRetry;
    }
  }

  // backoff_rate - computed: true, optional: true, required: false
  private _backoffRate?: number; 
  public get backoffRate() {
    return this.getNumberAttribute('backoff_rate');
  }
  public set backoffRate(value: number) {
    this._backoffRate = value;
  }
  public resetBackoffRate() {
    this._backoffRate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get backoffRateInput() {
    return this._backoffRate;
  }

  // initial_backoff - computed: true, optional: true, required: false
  private _initialBackoff?: number; 
  public get initialBackoff() {
    return this.getNumberAttribute('initial_backoff');
  }
  public set initialBackoff(value: number) {
    this._initialBackoff = value;
  }
  public resetInitialBackoff() {
    this._initialBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get initialBackoffInput() {
    return this._initialBackoff;
  }

  // max_backoff - computed: true, optional: true, required: false
  private _maxBackoff?: number; 
  public get maxBackoff() {
    return this.getNumberAttribute('max_backoff');
  }
  public set maxBackoff(value: number) {
    this._maxBackoff = value;
  }
  public resetMaxBackoff() {
    this._maxBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBackoffInput() {
    return this._maxBackoff;
  }

  // timeout_retry - computed: true, optional: true, required: false
  private _timeoutRetry?: boolean | cdktf.IResolvable; 
  public get timeoutRetry() {
    return this.getBooleanAttribute('timeout_retry');
  }
  public set timeoutRetry(value: boolean | cdktf.IResolvable) {
    this._timeoutRetry = value;
  }
  public resetTimeoutRetry() {
    this._timeoutRetry = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutRetryInput() {
    return this._timeoutRetry;
  }
}
export interface PackDestinationOutputHoneycomb {
  /**
  * Enter API key directly, or select a stored secret. Default: "manual"; must be one of ["manual", "secret"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#auth_type PackDestination#auth_type}
  */
  readonly authType?: string;
  /**
  * Compress the payload body before sending. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#compress PackDestination#compress}
  */
  readonly compress?: boolean | cdktf.IResolvable;
  /**
  * Maximum number of ongoing requests before blocking. Default: 5
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#concurrency PackDestination#concurrency}
  */
  readonly concurrency?: number;
  /**
  * Name of the dataset to send events to – e.g., observability
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#dataset PackDestination#dataset}
  */
  readonly dataset: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#description PackDestination#description}
  */
  readonly description?: string;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#environment PackDestination#environment}
  */
  readonly environment?: string;
  /**
  * Headers to add to all events
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#extra_http_headers PackDestination#extra_http_headers}
  */
  readonly extraHttpHeaders?: PackDestinationOutputHoneycombExtraHttpHeaders[] | cdktf.IResolvable;
  /**
  * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below. Default: "none"; must be one of ["payload", "payloadAndHeaders", "none"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#failed_request_logging_mode PackDestination#failed_request_logging_mode}
  */
  readonly failedRequestLoggingMode?: string;
  /**
  * Maximum time between requests. Small values could cause the payload size to be smaller than the configured Body size limit. Default: 1
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#flush_period_sec PackDestination#flush_period_sec}
  */
  readonly flushPeriodSec?: number;
  /**
  * Unique ID for this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#id PackDestination#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * Maximum number of events to include in the request body. Default is 0 (unlimited). Default: 0
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_payload_events PackDestination#max_payload_events}
  */
  readonly maxPayloadEvents?: number;
  /**
  * Maximum size, in KB, of the request body. Default: 4096
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_payload_size_kb PackDestination#max_payload_size_kb}
  */
  readonly maxPayloadSizeKb?: number;
  /**
  * How to handle events when all receivers are exerting backpressure. Default: "block"; must be one of ["block", "drop", "queue"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#on_backpressure PackDestination#on_backpressure}
  */
  readonly onBackpressure?: string;
  /**
  * Pipeline to process data before sending out to this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pipeline PackDestination#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_compress PackDestination#pq_compress}
  */
  readonly pqCompress?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_controls PackDestination#pq_controls}
  */
  readonly pqControls?: PackDestinationOutputHoneycombPqControls;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.). Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_max_file_size PackDestination#pq_max_file_size}
  */
  readonly pqMaxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_max_size PackDestination#pq_max_size}
  */
  readonly pqMaxSize?: string;
  /**
  * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem. Default: "error"; must be one of ["error", "backpressure", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_mode PackDestination#pq_mode}
  */
  readonly pqMode?: string;
  /**
  * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged. Default: "block"; must be one of ["block", "drop"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_on_backpressure PackDestination#pq_on_backpressure}
  */
  readonly pqOnBackpressure?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_path PackDestination#pq_path}
  */
  readonly pqPath?: string;
  /**
  * Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's). 
  *         Enabled by default. When this setting is also present in TLS Settings (Client Side), 
  *         that value will take precedence.
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#reject_unauthorized PackDestination#reject_unauthorized}
  */
  readonly rejectUnauthorized?: boolean | cdktf.IResolvable;
  /**
  * Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#response_honor_retry_after_header PackDestination#response_honor_retry_after_header}
  */
  readonly responseHonorRetryAfterHeader?: boolean | cdktf.IResolvable;
  /**
  * Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#response_retry_settings PackDestination#response_retry_settings}
  */
  readonly responseRetrySettings?: PackDestinationOutputHoneycombResponseRetrySettings[] | cdktf.IResolvable;
  /**
  * List of headers that are safe to log in plain text. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#safe_headers PackDestination#safe_headers}
  */
  readonly safeHeaders?: string[];
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#streamtags PackDestination#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Fields to automatically add to events, such as cribl_pipe. Supports wildcards. Default: ["cribl_pipe"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#system_fields PackDestination#system_fields}
  */
  readonly systemFields?: string[];
  /**
  * Team API key where the dataset belongs
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#team PackDestination#team}
  */
  readonly team?: string;
  /**
  * Select or create a stored text secret
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#text_secret PackDestination#text_secret}
  */
  readonly textSecret?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#timeout_retry_settings PackDestination#timeout_retry_settings}
  */
  readonly timeoutRetrySettings?: PackDestinationOutputHoneycombTimeoutRetrySettings;
  /**
  * Amount of time, in seconds, to wait for a request to complete before canceling it. Default: 30
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#timeout_sec PackDestination#timeout_sec}
  */
  readonly timeoutSec?: number;
  /**
  * must be "honeycomb"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#type PackDestination#type}
  */
  readonly type: string;
  /**
  * Enable round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. For optimal performance, consider enabling this setting for non-load balanced destinations. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#use_round_robin_dns PackDestination#use_round_robin_dns}
  */
  readonly useRoundRobinDns?: boolean | cdktf.IResolvable;
}

export function packDestinationOutputHoneycombToTerraform(struct?: PackDestinationOutputHoneycomb | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    auth_type: cdktf.stringToTerraform(struct!.authType),
    compress: cdktf.booleanToTerraform(struct!.compress),
    concurrency: cdktf.numberToTerraform(struct!.concurrency),
    dataset: cdktf.stringToTerraform(struct!.dataset),
    description: cdktf.stringToTerraform(struct!.description),
    environment: cdktf.stringToTerraform(struct!.environment),
    extra_http_headers: cdktf.listMapper(packDestinationOutputHoneycombExtraHttpHeadersToTerraform, false)(struct!.extraHttpHeaders),
    failed_request_logging_mode: cdktf.stringToTerraform(struct!.failedRequestLoggingMode),
    flush_period_sec: cdktf.numberToTerraform(struct!.flushPeriodSec),
    id: cdktf.stringToTerraform(struct!.id),
    max_payload_events: cdktf.numberToTerraform(struct!.maxPayloadEvents),
    max_payload_size_kb: cdktf.numberToTerraform(struct!.maxPayloadSizeKb),
    on_backpressure: cdktf.stringToTerraform(struct!.onBackpressure),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    pq_compress: cdktf.stringToTerraform(struct!.pqCompress),
    pq_controls: packDestinationOutputHoneycombPqControlsToTerraform(struct!.pqControls),
    pq_max_file_size: cdktf.stringToTerraform(struct!.pqMaxFileSize),
    pq_max_size: cdktf.stringToTerraform(struct!.pqMaxSize),
    pq_mode: cdktf.stringToTerraform(struct!.pqMode),
    pq_on_backpressure: cdktf.stringToTerraform(struct!.pqOnBackpressure),
    pq_path: cdktf.stringToTerraform(struct!.pqPath),
    reject_unauthorized: cdktf.booleanToTerraform(struct!.rejectUnauthorized),
    response_honor_retry_after_header: cdktf.booleanToTerraform(struct!.responseHonorRetryAfterHeader),
    response_retry_settings: cdktf.listMapper(packDestinationOutputHoneycombResponseRetrySettingsToTerraform, false)(struct!.responseRetrySettings),
    safe_headers: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.safeHeaders),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    system_fields: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.systemFields),
    team: cdktf.stringToTerraform(struct!.team),
    text_secret: cdktf.stringToTerraform(struct!.textSecret),
    timeout_retry_settings: packDestinationOutputHoneycombTimeoutRetrySettingsToTerraform(struct!.timeoutRetrySettings),
    timeout_sec: cdktf.numberToTerraform(struct!.timeoutSec),
    type: cdktf.stringToTerraform(struct!.type),
    use_round_robin_dns: cdktf.booleanToTerraform(struct!.useRoundRobinDns),
  }
}


export function packDestinationOutputHoneycombToHclTerraform(struct?: PackDestinationOutputHoneycomb | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    auth_type: {
      value: cdktf.stringToHclTerraform(struct!.authType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    compress: {
      value: cdktf.booleanToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    concurrency: {
      value: cdktf.numberToHclTerraform(struct!.concurrency),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    dataset: {
      value: cdktf.stringToHclTerraform(struct!.dataset),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    extra_http_headers: {
      value: cdktf.listMapperHcl(packDestinationOutputHoneycombExtraHttpHeadersToHclTerraform, false)(struct!.extraHttpHeaders),
      isBlock: true,
      type: "list",
      storageClassType: "PackDestinationOutputHoneycombExtraHttpHeadersList",
    },
    failed_request_logging_mode: {
      value: cdktf.stringToHclTerraform(struct!.failedRequestLoggingMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    flush_period_sec: {
      value: cdktf.numberToHclTerraform(struct!.flushPeriodSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_payload_events: {
      value: cdktf.numberToHclTerraform(struct!.maxPayloadEvents),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_payload_size_kb: {
      value: cdktf.numberToHclTerraform(struct!.maxPayloadSizeKb),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.onBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_compress: {
      value: cdktf.stringToHclTerraform(struct!.pqCompress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_controls: {
      value: packDestinationOutputHoneycombPqControlsToHclTerraform(struct!.pqControls),
      isBlock: true,
      type: "struct",
      storageClassType: "PackDestinationOutputHoneycombPqControls",
    },
    pq_max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_max_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_mode: {
      value: cdktf.stringToHclTerraform(struct!.pqMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.pqOnBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_path: {
      value: cdktf.stringToHclTerraform(struct!.pqPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reject_unauthorized: {
      value: cdktf.booleanToHclTerraform(struct!.rejectUnauthorized),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    response_honor_retry_after_header: {
      value: cdktf.booleanToHclTerraform(struct!.responseHonorRetryAfterHeader),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    response_retry_settings: {
      value: cdktf.listMapperHcl(packDestinationOutputHoneycombResponseRetrySettingsToHclTerraform, false)(struct!.responseRetrySettings),
      isBlock: true,
      type: "list",
      storageClassType: "PackDestinationOutputHoneycombResponseRetrySettingsList",
    },
    safe_headers: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.safeHeaders),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    system_fields: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.systemFields),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    team: {
      value: cdktf.stringToHclTerraform(struct!.team),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    text_secret: {
      value: cdktf.stringToHclTerraform(struct!.textSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    timeout_retry_settings: {
      value: packDestinationOutputHoneycombTimeoutRetrySettingsToHclTerraform(struct!.timeoutRetrySettings),
      isBlock: true,
      type: "struct",
      storageClassType: "PackDestinationOutputHoneycombTimeoutRetrySettings",
    },
    timeout_sec: {
      value: cdktf.numberToHclTerraform(struct!.timeoutSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    use_round_robin_dns: {
      value: cdktf.booleanToHclTerraform(struct!.useRoundRobinDns),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputHoneycombOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackDestinationOutputHoneycomb | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._authType !== undefined) {
      hasAnyValues = true;
      internalValueResult.authType = this._authType;
    }
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._concurrency !== undefined) {
      hasAnyValues = true;
      internalValueResult.concurrency = this._concurrency;
    }
    if (this._dataset !== undefined) {
      hasAnyValues = true;
      internalValueResult.dataset = this._dataset;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._extraHttpHeaders?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.extraHttpHeaders = this._extraHttpHeaders?.internalValue;
    }
    if (this._failedRequestLoggingMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.failedRequestLoggingMode = this._failedRequestLoggingMode;
    }
    if (this._flushPeriodSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.flushPeriodSec = this._flushPeriodSec;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._maxPayloadEvents !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxPayloadEvents = this._maxPayloadEvents;
    }
    if (this._maxPayloadSizeKb !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxPayloadSizeKb = this._maxPayloadSizeKb;
    }
    if (this._onBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.onBackpressure = this._onBackpressure;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._pqCompress !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqCompress = this._pqCompress;
    }
    if (this._pqControls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqControls = this._pqControls?.internalValue;
    }
    if (this._pqMaxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxFileSize = this._pqMaxFileSize;
    }
    if (this._pqMaxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxSize = this._pqMaxSize;
    }
    if (this._pqMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMode = this._pqMode;
    }
    if (this._pqOnBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqOnBackpressure = this._pqOnBackpressure;
    }
    if (this._pqPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqPath = this._pqPath;
    }
    if (this._rejectUnauthorized !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectUnauthorized = this._rejectUnauthorized;
    }
    if (this._responseHonorRetryAfterHeader !== undefined) {
      hasAnyValues = true;
      internalValueResult.responseHonorRetryAfterHeader = this._responseHonorRetryAfterHeader;
    }
    if (this._responseRetrySettings?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.responseRetrySettings = this._responseRetrySettings?.internalValue;
    }
    if (this._safeHeaders !== undefined) {
      hasAnyValues = true;
      internalValueResult.safeHeaders = this._safeHeaders;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._systemFields !== undefined) {
      hasAnyValues = true;
      internalValueResult.systemFields = this._systemFields;
    }
    if (this._team !== undefined) {
      hasAnyValues = true;
      internalValueResult.team = this._team;
    }
    if (this._textSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.textSecret = this._textSecret;
    }
    if (this._timeoutRetrySettings?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutRetrySettings = this._timeoutRetrySettings?.internalValue;
    }
    if (this._timeoutSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutSec = this._timeoutSec;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._useRoundRobinDns !== undefined) {
      hasAnyValues = true;
      internalValueResult.useRoundRobinDns = this._useRoundRobinDns;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputHoneycomb | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._authType = undefined;
      this._compress = undefined;
      this._concurrency = undefined;
      this._dataset = undefined;
      this._description = undefined;
      this._environment = undefined;
      this._extraHttpHeaders.internalValue = undefined;
      this._failedRequestLoggingMode = undefined;
      this._flushPeriodSec = undefined;
      this._id = undefined;
      this._maxPayloadEvents = undefined;
      this._maxPayloadSizeKb = undefined;
      this._onBackpressure = undefined;
      this._pipeline = undefined;
      this._pqCompress = undefined;
      this._pqControls.internalValue = undefined;
      this._pqMaxFileSize = undefined;
      this._pqMaxSize = undefined;
      this._pqMode = undefined;
      this._pqOnBackpressure = undefined;
      this._pqPath = undefined;
      this._rejectUnauthorized = undefined;
      this._responseHonorRetryAfterHeader = undefined;
      this._responseRetrySettings.internalValue = undefined;
      this._safeHeaders = undefined;
      this._streamtags = undefined;
      this._systemFields = undefined;
      this._team = undefined;
      this._textSecret = undefined;
      this._timeoutRetrySettings.internalValue = undefined;
      this._timeoutSec = undefined;
      this._type = undefined;
      this._useRoundRobinDns = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._authType = value.authType;
      this._compress = value.compress;
      this._concurrency = value.concurrency;
      this._dataset = value.dataset;
      this._description = value.description;
      this._environment = value.environment;
      this._extraHttpHeaders.internalValue = value.extraHttpHeaders;
      this._failedRequestLoggingMode = value.failedRequestLoggingMode;
      this._flushPeriodSec = value.flushPeriodSec;
      this._id = value.id;
      this._maxPayloadEvents = value.maxPayloadEvents;
      this._maxPayloadSizeKb = value.maxPayloadSizeKb;
      this._onBackpressure = value.onBackpressure;
      this._pipeline = value.pipeline;
      this._pqCompress = value.pqCompress;
      this._pqControls.internalValue = value.pqControls;
      this._pqMaxFileSize = value.pqMaxFileSize;
      this._pqMaxSize = value.pqMaxSize;
      this._pqMode = value.pqMode;
      this._pqOnBackpressure = value.pqOnBackpressure;
      this._pqPath = value.pqPath;
      this._rejectUnauthorized = value.rejectUnauthorized;
      this._responseHonorRetryAfterHeader = value.responseHonorRetryAfterHeader;
      this._responseRetrySettings.internalValue = value.responseRetrySettings;
      this._safeHeaders = value.safeHeaders;
      this._streamtags = value.streamtags;
      this._systemFields = value.systemFields;
      this._team = value.team;
      this._textSecret = value.textSecret;
      this._timeoutRetrySettings.internalValue = value.timeoutRetrySettings;
      this._timeoutSec = value.timeoutSec;
      this._type = value.type;
      this._useRoundRobinDns = value.useRoundRobinDns;
    }
  }

  // auth_type - computed: true, optional: true, required: false
  private _authType?: string; 
  public get authType() {
    return this.getStringAttribute('auth_type');
  }
  public set authType(value: string) {
    this._authType = value;
  }
  public resetAuthType() {
    this._authType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authTypeInput() {
    return this._authType;
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: boolean | cdktf.IResolvable; 
  public get compress() {
    return this.getBooleanAttribute('compress');
  }
  public set compress(value: boolean | cdktf.IResolvable) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // concurrency - computed: true, optional: true, required: false
  private _concurrency?: number; 
  public get concurrency() {
    return this.getNumberAttribute('concurrency');
  }
  public set concurrency(value: number) {
    this._concurrency = value;
  }
  public resetConcurrency() {
    this._concurrency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get concurrencyInput() {
    return this._concurrency;
  }

  // dataset - computed: false, optional: false, required: true
  private _dataset?: string; 
  public get dataset() {
    return this.getStringAttribute('dataset');
  }
  public set dataset(value: string) {
    this._dataset = value;
  }
  // Temporarily expose input value. Use with caution.
  public get datasetInput() {
    return this._dataset;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // extra_http_headers - computed: false, optional: true, required: false
  private _extraHttpHeaders = new PackDestinationOutputHoneycombExtraHttpHeadersList(this, "extra_http_headers", false);
  public get extraHttpHeaders() {
    return this._extraHttpHeaders;
  }
  public putExtraHttpHeaders(value: PackDestinationOutputHoneycombExtraHttpHeaders[] | cdktf.IResolvable) {
    this._extraHttpHeaders.internalValue = value;
  }
  public resetExtraHttpHeaders() {
    this._extraHttpHeaders.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get extraHttpHeadersInput() {
    return this._extraHttpHeaders.internalValue;
  }

  // failed_request_logging_mode - computed: true, optional: true, required: false
  private _failedRequestLoggingMode?: string; 
  public get failedRequestLoggingMode() {
    return this.getStringAttribute('failed_request_logging_mode');
  }
  public set failedRequestLoggingMode(value: string) {
    this._failedRequestLoggingMode = value;
  }
  public resetFailedRequestLoggingMode() {
    this._failedRequestLoggingMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get failedRequestLoggingModeInput() {
    return this._failedRequestLoggingMode;
  }

  // flush_period_sec - computed: true, optional: true, required: false
  private _flushPeriodSec?: number; 
  public get flushPeriodSec() {
    return this.getNumberAttribute('flush_period_sec');
  }
  public set flushPeriodSec(value: number) {
    this._flushPeriodSec = value;
  }
  public resetFlushPeriodSec() {
    this._flushPeriodSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get flushPeriodSecInput() {
    return this._flushPeriodSec;
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // max_payload_events - computed: true, optional: true, required: false
  private _maxPayloadEvents?: number; 
  public get maxPayloadEvents() {
    return this.getNumberAttribute('max_payload_events');
  }
  public set maxPayloadEvents(value: number) {
    this._maxPayloadEvents = value;
  }
  public resetMaxPayloadEvents() {
    this._maxPayloadEvents = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxPayloadEventsInput() {
    return this._maxPayloadEvents;
  }

  // max_payload_size_kb - computed: true, optional: true, required: false
  private _maxPayloadSizeKb?: number; 
  public get maxPayloadSizeKb() {
    return this.getNumberAttribute('max_payload_size_kb');
  }
  public set maxPayloadSizeKb(value: number) {
    this._maxPayloadSizeKb = value;
  }
  public resetMaxPayloadSizeKb() {
    this._maxPayloadSizeKb = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxPayloadSizeKbInput() {
    return this._maxPayloadSizeKb;
  }

  // on_backpressure - computed: true, optional: true, required: false
  private _onBackpressure?: string; 
  public get onBackpressure() {
    return this.getStringAttribute('on_backpressure');
  }
  public set onBackpressure(value: string) {
    this._onBackpressure = value;
  }
  public resetOnBackpressure() {
    this._onBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get onBackpressureInput() {
    return this._onBackpressure;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // pq_compress - computed: true, optional: true, required: false
  private _pqCompress?: string; 
  public get pqCompress() {
    return this.getStringAttribute('pq_compress');
  }
  public set pqCompress(value: string) {
    this._pqCompress = value;
  }
  public resetPqCompress() {
    this._pqCompress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqCompressInput() {
    return this._pqCompress;
  }

  // pq_controls - computed: false, optional: true, required: false
  private _pqControls = new PackDestinationOutputHoneycombPqControlsOutputReference(this, "pq_controls");
  public get pqControls() {
    return this._pqControls;
  }
  public putPqControls(value: PackDestinationOutputHoneycombPqControls) {
    this._pqControls.internalValue = value;
  }
  public resetPqControls() {
    this._pqControls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqControlsInput() {
    return this._pqControls.internalValue;
  }

  // pq_max_file_size - computed: true, optional: true, required: false
  private _pqMaxFileSize?: string; 
  public get pqMaxFileSize() {
    return this.getStringAttribute('pq_max_file_size');
  }
  public set pqMaxFileSize(value: string) {
    this._pqMaxFileSize = value;
  }
  public resetPqMaxFileSize() {
    this._pqMaxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxFileSizeInput() {
    return this._pqMaxFileSize;
  }

  // pq_max_size - computed: true, optional: true, required: false
  private _pqMaxSize?: string; 
  public get pqMaxSize() {
    return this.getStringAttribute('pq_max_size');
  }
  public set pqMaxSize(value: string) {
    this._pqMaxSize = value;
  }
  public resetPqMaxSize() {
    this._pqMaxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxSizeInput() {
    return this._pqMaxSize;
  }

  // pq_mode - computed: true, optional: true, required: false
  private _pqMode?: string; 
  public get pqMode() {
    return this.getStringAttribute('pq_mode');
  }
  public set pqMode(value: string) {
    this._pqMode = value;
  }
  public resetPqMode() {
    this._pqMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqModeInput() {
    return this._pqMode;
  }

  // pq_on_backpressure - computed: true, optional: true, required: false
  private _pqOnBackpressure?: string; 
  public get pqOnBackpressure() {
    return this.getStringAttribute('pq_on_backpressure');
  }
  public set pqOnBackpressure(value: string) {
    this._pqOnBackpressure = value;
  }
  public resetPqOnBackpressure() {
    this._pqOnBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqOnBackpressureInput() {
    return this._pqOnBackpressure;
  }

  // pq_path - computed: true, optional: true, required: false
  private _pqPath?: string; 
  public get pqPath() {
    return this.getStringAttribute('pq_path');
  }
  public set pqPath(value: string) {
    this._pqPath = value;
  }
  public resetPqPath() {
    this._pqPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqPathInput() {
    return this._pqPath;
  }

  // reject_unauthorized - computed: true, optional: true, required: false
  private _rejectUnauthorized?: boolean | cdktf.IResolvable; 
  public get rejectUnauthorized() {
    return this.getBooleanAttribute('reject_unauthorized');
  }
  public set rejectUnauthorized(value: boolean | cdktf.IResolvable) {
    this._rejectUnauthorized = value;
  }
  public resetRejectUnauthorized() {
    this._rejectUnauthorized = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectUnauthorizedInput() {
    return this._rejectUnauthorized;
  }

  // response_honor_retry_after_header - computed: true, optional: true, required: false
  private _responseHonorRetryAfterHeader?: boolean | cdktf.IResolvable; 
  public get responseHonorRetryAfterHeader() {
    return this.getBooleanAttribute('response_honor_retry_after_header');
  }
  public set responseHonorRetryAfterHeader(value: boolean | cdktf.IResolvable) {
    this._responseHonorRetryAfterHeader = value;
  }
  public resetResponseHonorRetryAfterHeader() {
    this._responseHonorRetryAfterHeader = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get responseHonorRetryAfterHeaderInput() {
    return this._responseHonorRetryAfterHeader;
  }

  // response_retry_settings - computed: false, optional: true, required: false
  private _responseRetrySettings = new PackDestinationOutputHoneycombResponseRetrySettingsList(this, "response_retry_settings", false);
  public get responseRetrySettings() {
    return this._responseRetrySettings;
  }
  public putResponseRetrySettings(value: PackDestinationOutputHoneycombResponseRetrySettings[] | cdktf.IResolvable) {
    this._responseRetrySettings.internalValue = value;
  }
  public resetResponseRetrySettings() {
    this._responseRetrySettings.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get responseRetrySettingsInput() {
    return this._responseRetrySettings.internalValue;
  }

  // safe_headers - computed: true, optional: true, required: false
  private _safeHeaders?: string[]; 
  public get safeHeaders() {
    return this.getListAttribute('safe_headers');
  }
  public set safeHeaders(value: string[]) {
    this._safeHeaders = value;
  }
  public resetSafeHeaders() {
    this._safeHeaders = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get safeHeadersInput() {
    return this._safeHeaders;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // system_fields - computed: true, optional: true, required: false
  private _systemFields?: string[]; 
  public get systemFields() {
    return this.getListAttribute('system_fields');
  }
  public set systemFields(value: string[]) {
    this._systemFields = value;
  }
  public resetSystemFields() {
    this._systemFields = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get systemFieldsInput() {
    return this._systemFields;
  }

  // team - computed: false, optional: true, required: false
  private _team?: string; 
  public get team() {
    return this.getStringAttribute('team');
  }
  public set team(value: string) {
    this._team = value;
  }
  public resetTeam() {
    this._team = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get teamInput() {
    return this._team;
  }

  // text_secret - computed: false, optional: true, required: false
  private _textSecret?: string; 
  public get textSecret() {
    return this.getStringAttribute('text_secret');
  }
  public set textSecret(value: string) {
    this._textSecret = value;
  }
  public resetTextSecret() {
    this._textSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get textSecretInput() {
    return this._textSecret;
  }

  // timeout_retry_settings - computed: false, optional: true, required: false
  private _timeoutRetrySettings = new PackDestinationOutputHoneycombTimeoutRetrySettingsOutputReference(this, "timeout_retry_settings");
  public get timeoutRetrySettings() {
    return this._timeoutRetrySettings;
  }
  public putTimeoutRetrySettings(value: PackDestinationOutputHoneycombTimeoutRetrySettings) {
    this._timeoutRetrySettings.internalValue = value;
  }
  public resetTimeoutRetrySettings() {
    this._timeoutRetrySettings.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutRetrySettingsInput() {
    return this._timeoutRetrySettings.internalValue;
  }

  // timeout_sec - computed: true, optional: true, required: false
  private _timeoutSec?: number; 
  public get timeoutSec() {
    return this.getNumberAttribute('timeout_sec');
  }
  public set timeoutSec(value: number) {
    this._timeoutSec = value;
  }
  public resetTimeoutSec() {
    this._timeoutSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutSecInput() {
    return this._timeoutSec;
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // use_round_robin_dns - computed: true, optional: true, required: false
  private _useRoundRobinDns?: boolean | cdktf.IResolvable; 
  public get useRoundRobinDns() {
    return this.getBooleanAttribute('use_round_robin_dns');
  }
  public set useRoundRobinDns(value: boolean | cdktf.IResolvable) {
    this._useRoundRobinDns = value;
  }
  public resetUseRoundRobinDns() {
    this._useRoundRobinDns = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get useRoundRobinDnsInput() {
    return this._useRoundRobinDns;
  }
}
export interface PackDestinationOutputHumioHecExtraHttpHeaders {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#name PackDestination#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#value PackDestination#value}
  */
  readonly value: string;
}

export function packDestinationOutputHumioHecExtraHttpHeadersToTerraform(struct?: PackDestinationOutputHumioHecExtraHttpHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function packDestinationOutputHumioHecExtraHttpHeadersToHclTerraform(struct?: PackDestinationOutputHumioHecExtraHttpHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputHumioHecExtraHttpHeadersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackDestinationOutputHumioHecExtraHttpHeaders | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputHumioHecExtraHttpHeaders | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class PackDestinationOutputHumioHecExtraHttpHeadersList extends cdktf.ComplexList {
  public internalValue? : PackDestinationOutputHumioHecExtraHttpHeaders[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackDestinationOutputHumioHecExtraHttpHeadersOutputReference {
    return new PackDestinationOutputHumioHecExtraHttpHeadersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackDestinationOutputHumioHecPqControls {
}

export function packDestinationOutputHumioHecPqControlsToTerraform(struct?: PackDestinationOutputHumioHecPqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function packDestinationOutputHumioHecPqControlsToHclTerraform(struct?: PackDestinationOutputHumioHecPqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class PackDestinationOutputHumioHecPqControlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackDestinationOutputHumioHecPqControls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputHumioHecPqControls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface PackDestinationOutputHumioHecResponseRetrySettings {
  /**
  * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc. Default: 2
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#backoff_rate PackDestination#backoff_rate}
  */
  readonly backoffRate?: number;
  /**
  * The HTTP response status code that will trigger retries
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#http_status PackDestination#http_status}
  */
  readonly httpStatus: number;
  /**
  * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes). Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#initial_backoff PackDestination#initial_backoff}
  */
  readonly initialBackoff?: number;
  /**
  * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds). Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_backoff PackDestination#max_backoff}
  */
  readonly maxBackoff?: number;
}

export function packDestinationOutputHumioHecResponseRetrySettingsToTerraform(struct?: PackDestinationOutputHumioHecResponseRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    backoff_rate: cdktf.numberToTerraform(struct!.backoffRate),
    http_status: cdktf.numberToTerraform(struct!.httpStatus),
    initial_backoff: cdktf.numberToTerraform(struct!.initialBackoff),
    max_backoff: cdktf.numberToTerraform(struct!.maxBackoff),
  }
}


export function packDestinationOutputHumioHecResponseRetrySettingsToHclTerraform(struct?: PackDestinationOutputHumioHecResponseRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    backoff_rate: {
      value: cdktf.numberToHclTerraform(struct!.backoffRate),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    http_status: {
      value: cdktf.numberToHclTerraform(struct!.httpStatus),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    initial_backoff: {
      value: cdktf.numberToHclTerraform(struct!.initialBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_backoff: {
      value: cdktf.numberToHclTerraform(struct!.maxBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputHumioHecResponseRetrySettingsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackDestinationOutputHumioHecResponseRetrySettings | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._backoffRate !== undefined) {
      hasAnyValues = true;
      internalValueResult.backoffRate = this._backoffRate;
    }
    if (this._httpStatus !== undefined) {
      hasAnyValues = true;
      internalValueResult.httpStatus = this._httpStatus;
    }
    if (this._initialBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.initialBackoff = this._initialBackoff;
    }
    if (this._maxBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBackoff = this._maxBackoff;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputHumioHecResponseRetrySettings | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._backoffRate = undefined;
      this._httpStatus = undefined;
      this._initialBackoff = undefined;
      this._maxBackoff = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._backoffRate = value.backoffRate;
      this._httpStatus = value.httpStatus;
      this._initialBackoff = value.initialBackoff;
      this._maxBackoff = value.maxBackoff;
    }
  }

  // backoff_rate - computed: true, optional: true, required: false
  private _backoffRate?: number; 
  public get backoffRate() {
    return this.getNumberAttribute('backoff_rate');
  }
  public set backoffRate(value: number) {
    this._backoffRate = value;
  }
  public resetBackoffRate() {
    this._backoffRate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get backoffRateInput() {
    return this._backoffRate;
  }

  // http_status - computed: false, optional: false, required: true
  private _httpStatus?: number; 
  public get httpStatus() {
    return this.getNumberAttribute('http_status');
  }
  public set httpStatus(value: number) {
    this._httpStatus = value;
  }
  // Temporarily expose input value. Use with caution.
  public get httpStatusInput() {
    return this._httpStatus;
  }

  // initial_backoff - computed: true, optional: true, required: false
  private _initialBackoff?: number; 
  public get initialBackoff() {
    return this.getNumberAttribute('initial_backoff');
  }
  public set initialBackoff(value: number) {
    this._initialBackoff = value;
  }
  public resetInitialBackoff() {
    this._initialBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get initialBackoffInput() {
    return this._initialBackoff;
  }

  // max_backoff - computed: true, optional: true, required: false
  private _maxBackoff?: number; 
  public get maxBackoff() {
    return this.getNumberAttribute('max_backoff');
  }
  public set maxBackoff(value: number) {
    this._maxBackoff = value;
  }
  public resetMaxBackoff() {
    this._maxBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBackoffInput() {
    return this._maxBackoff;
  }
}

export class PackDestinationOutputHumioHecResponseRetrySettingsList extends cdktf.ComplexList {
  public internalValue? : PackDestinationOutputHumioHecResponseRetrySettings[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackDestinationOutputHumioHecResponseRetrySettingsOutputReference {
    return new PackDestinationOutputHumioHecResponseRetrySettingsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackDestinationOutputHumioHecTimeoutRetrySettings {
  /**
  * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc. Default: 2
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#backoff_rate PackDestination#backoff_rate}
  */
  readonly backoffRate?: number;
  /**
  * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes). Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#initial_backoff PackDestination#initial_backoff}
  */
  readonly initialBackoff?: number;
  /**
  * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds). Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_backoff PackDestination#max_backoff}
  */
  readonly maxBackoff?: number;
  /**
  * Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#timeout_retry PackDestination#timeout_retry}
  */
  readonly timeoutRetry?: boolean | cdktf.IResolvable;
}

export function packDestinationOutputHumioHecTimeoutRetrySettingsToTerraform(struct?: PackDestinationOutputHumioHecTimeoutRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    backoff_rate: cdktf.numberToTerraform(struct!.backoffRate),
    initial_backoff: cdktf.numberToTerraform(struct!.initialBackoff),
    max_backoff: cdktf.numberToTerraform(struct!.maxBackoff),
    timeout_retry: cdktf.booleanToTerraform(struct!.timeoutRetry),
  }
}


export function packDestinationOutputHumioHecTimeoutRetrySettingsToHclTerraform(struct?: PackDestinationOutputHumioHecTimeoutRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    backoff_rate: {
      value: cdktf.numberToHclTerraform(struct!.backoffRate),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    initial_backoff: {
      value: cdktf.numberToHclTerraform(struct!.initialBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_backoff: {
      value: cdktf.numberToHclTerraform(struct!.maxBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    timeout_retry: {
      value: cdktf.booleanToHclTerraform(struct!.timeoutRetry),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputHumioHecTimeoutRetrySettingsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackDestinationOutputHumioHecTimeoutRetrySettings | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._backoffRate !== undefined) {
      hasAnyValues = true;
      internalValueResult.backoffRate = this._backoffRate;
    }
    if (this._initialBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.initialBackoff = this._initialBackoff;
    }
    if (this._maxBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBackoff = this._maxBackoff;
    }
    if (this._timeoutRetry !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutRetry = this._timeoutRetry;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputHumioHecTimeoutRetrySettings | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._backoffRate = undefined;
      this._initialBackoff = undefined;
      this._maxBackoff = undefined;
      this._timeoutRetry = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._backoffRate = value.backoffRate;
      this._initialBackoff = value.initialBackoff;
      this._maxBackoff = value.maxBackoff;
      this._timeoutRetry = value.timeoutRetry;
    }
  }

  // backoff_rate - computed: true, optional: true, required: false
  private _backoffRate?: number; 
  public get backoffRate() {
    return this.getNumberAttribute('backoff_rate');
  }
  public set backoffRate(value: number) {
    this._backoffRate = value;
  }
  public resetBackoffRate() {
    this._backoffRate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get backoffRateInput() {
    return this._backoffRate;
  }

  // initial_backoff - computed: true, optional: true, required: false
  private _initialBackoff?: number; 
  public get initialBackoff() {
    return this.getNumberAttribute('initial_backoff');
  }
  public set initialBackoff(value: number) {
    this._initialBackoff = value;
  }
  public resetInitialBackoff() {
    this._initialBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get initialBackoffInput() {
    return this._initialBackoff;
  }

  // max_backoff - computed: true, optional: true, required: false
  private _maxBackoff?: number; 
  public get maxBackoff() {
    return this.getNumberAttribute('max_backoff');
  }
  public set maxBackoff(value: number) {
    this._maxBackoff = value;
  }
  public resetMaxBackoff() {
    this._maxBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBackoffInput() {
    return this._maxBackoff;
  }

  // timeout_retry - computed: true, optional: true, required: false
  private _timeoutRetry?: boolean | cdktf.IResolvable; 
  public get timeoutRetry() {
    return this.getBooleanAttribute('timeout_retry');
  }
  public set timeoutRetry(value: boolean | cdktf.IResolvable) {
    this._timeoutRetry = value;
  }
  public resetTimeoutRetry() {
    this._timeoutRetry = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutRetryInput() {
    return this._timeoutRetry;
  }
}
export interface PackDestinationOutputHumioHec {
  /**
  * Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate. Default: "manual"; must be one of ["manual", "secret"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#auth_type PackDestination#auth_type}
  */
  readonly authType?: string;
  /**
  * Compress the payload body before sending. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#compress PackDestination#compress}
  */
  readonly compress?: boolean | cdktf.IResolvable;
  /**
  * Maximum number of ongoing requests before blocking. Default: 5
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#concurrency PackDestination#concurrency}
  */
  readonly concurrency?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#description PackDestination#description}
  */
  readonly description?: string;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#environment PackDestination#environment}
  */
  readonly environment?: string;
  /**
  * Headers to add to all events
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#extra_http_headers PackDestination#extra_http_headers}
  */
  readonly extraHttpHeaders?: PackDestinationOutputHumioHecExtraHttpHeaders[] | cdktf.IResolvable;
  /**
  * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below. Default: "none"; must be one of ["payload", "payloadAndHeaders", "none"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#failed_request_logging_mode PackDestination#failed_request_logging_mode}
  */
  readonly failedRequestLoggingMode?: string;
  /**
  * Maximum time between requests. Small values could cause the payload size to be smaller than the configured Body size limit. Default: 1
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#flush_period_sec PackDestination#flush_period_sec}
  */
  readonly flushPeriodSec?: number;
  /**
  * When set to JSON, the event is automatically formatted with required fields before sending. When set to Raw, only the event's `_raw` value is sent. Default: "JSON"; must be one of ["JSON", "raw"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#format PackDestination#format}
  */
  readonly format?: string;
  /**
  * Unique ID for this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#id PackDestination#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * Maximum number of events to include in the request body. Default is 0 (unlimited). Default: 0
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_payload_events PackDestination#max_payload_events}
  */
  readonly maxPayloadEvents?: number;
  /**
  * Maximum size, in KB, of the request body. Default: 4096
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#max_payload_size_kb PackDestination#max_payload_size_kb}
  */
  readonly maxPayloadSizeKb?: number;
  /**
  * How to handle events when all receivers are exerting backpressure. Default: "block"; must be one of ["block", "drop", "queue"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#on_backpressure PackDestination#on_backpressure}
  */
  readonly onBackpressure?: string;
  /**
  * Pipeline to process data before sending out to this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pipeline PackDestination#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_compress PackDestination#pq_compress}
  */
  readonly pqCompress?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_controls PackDestination#pq_controls}
  */
  readonly pqControls?: PackDestinationOutputHumioHecPqControls;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.). Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_max_file_size PackDestination#pq_max_file_size}
  */
  readonly pqMaxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_max_size PackDestination#pq_max_size}
  */
  readonly pqMaxSize?: string;
  /**
  * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem. Default: "error"; must be one of ["error", "backpressure", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_mode PackDestination#pq_mode}
  */
  readonly pqMode?: string;
  /**
  * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged. Default: "block"; must be one of ["block", "drop"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_on_backpressure PackDestination#pq_on_backpressure}
  */
  readonly pqOnBackpressure?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#pq_path PackDestination#pq_path}
  */
  readonly pqPath?: string;
  /**
  * Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's). 
  *         Enabled by default. When this setting is also present in TLS Settings (Client Side), 
  *         that value will take precedence.
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#reject_unauthorized PackDestination#reject_unauthorized}
  */
  readonly rejectUnauthorized?: boolean | cdktf.IResolvable;
  /**
  * Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#response_honor_retry_after_header PackDestination#response_honor_retry_after_header}
  */
  readonly responseHonorRetryAfterHeader?: boolean | cdktf.IResolvable;
  /**
  * Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#response_retry_settings PackDestination#response_retry_settings}
  */
  readonly responseRetrySettings?: PackDestinationOutputHumioHecResponseRetrySettings[] | cdktf.IResolvable;
  /**
  * List of headers that are safe to log in plain text. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#safe_headers PackDestination#safe_headers}
  */
  readonly safeHeaders?: string[];
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#streamtags PackDestination#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Fields to automatically add to events, such as cribl_pipe. Supports wildcards. Default: ["cribl_pipe"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#system_fields PackDestination#system_fields}
  */
  readonly systemFields?: string[];
  /**
  * Select or create a stored text secret
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#text_secret PackDestination#text_secret}
  */
  readonly textSecret?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#timeout_retry_settings PackDestination#timeout_retry_settings}
  */
  readonly timeoutRetrySettings?: PackDestinationOutputHumioHecTimeoutRetrySettings;
  /**
  * Amount of time, in seconds, to wait for a request to complete before canceling it. Default: 30
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#timeout_sec PackDestination#timeout_sec}
  */
  readonly timeoutSec?: number;
  /**
  * CrowdStrike Falcon LogScale authentication token
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#token PackDestination#token}
  */
  readonly token?: string;
  /**
  * must be "humio_hec"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#type PackDestination#type}
  */
  readonly type?: string;
  /**
  * URL to a CrowdStrike Falcon LogScale endpoint to send events to. Examples: https://cloud.us.humio.com/api/v1/ingest/hec for JSON and https://cloud.us.humio.com/api/v1/ingest/hec/raw for raw. Default: "https://cloud.us.humio.com/api/v1/ingest/hec"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#url PackDestination#url}
  */
  readonly url?: string;
  /**
  * Enable round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. For optimal performance, consider enabling this setting for non-load balanced destinations. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#use_round_robin_dns PackDestination#use_round_robin_dns}
  */
  readonly useRoundRobinDns?: boolean | cdktf.IResolvable;
}

export function packDestinationOutputHumioHecToTerraform(struct?: PackDestinationOutputHumioHec | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    auth_type: cdktf.stringToTerraform(struct!.authType),
    compress: cdktf.booleanToTerraform(struct!.compress),
    concurrency: cdktf.numberToTerraform(struct!.concurrency),
    description: cdktf.stringToTerraform(struct!.description),
    environment: cdktf.stringToTerraform(struct!.environment),
    extra_http_headers: cdktf.listMapper(packDestinationOutputHumioHecExtraHttpHeadersToTerraform, false)(struct!.extraHttpHeaders),
    failed_request_logging_mode: cdktf.stringToTerraform(struct!.failedRequestLoggingMode),
    flush_period_sec: cdktf.numberToTerraform(struct!.flushPeriodSec),
    format: cdktf.stringToTerraform(struct!.format),
    id: cdktf.stringToTerraform(struct!.id),
    max_payload_events: cdktf.numberToTerraform(struct!.maxPayloadEvents),
    max_payload_size_kb: cdktf.numberToTerraform(struct!.maxPayloadSizeKb),
    on_backpressure: cdktf.stringToTerraform(struct!.onBackpressure),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    pq_compress: cdktf.stringToTerraform(struct!.pqCompress),
    pq_controls: packDestinationOutputHumioHecPqControlsToTerraform(struct!.pqControls),
    pq_max_file_size: cdktf.stringToTerraform(struct!.pqMaxFileSize),
    pq_max_size: cdktf.stringToTerraform(struct!.pqMaxSize),
    pq_mode: cdktf.stringToTerraform(struct!.pqMode),
    pq_on_backpressure: cdktf.stringToTerraform(struct!.pqOnBackpressure),
    pq_path: cdktf.stringToTerraform(struct!.pqPath),
    reject_unauthorized: cdktf.booleanToTerraform(struct!.rejectUnauthorized),
    response_honor_retry_after_header: cdktf.booleanToTerraform(struct!.responseHonorRetryAfterHeader),
    response_retry_settings: cdktf.listMapper(packDestinationOutputHumioHecResponseRetrySettingsToTerraform, false)(struct!.responseRetrySettings),
    safe_headers: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.safeHeaders),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    system_fields: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.systemFields),
    text_secret: cdktf.stringToTerraform(struct!.textSecret),
    timeout_retry_settings: packDestinationOutputHumioHecTimeoutRetrySettingsToTerraform(struct!.timeoutRetrySettings),
    timeout_sec: cdktf.numberToTerraform(struct!.timeoutSec),
    token: cdktf.stringToTerraform(struct!.token),
    type: cdktf.stringToTerraform(struct!.type),
    url: cdktf.stringToTerraform(struct!.url),
    use_round_robin_dns: cdktf.booleanToTerraform(struct!.useRoundRobinDns),
  }
}


export function packDestinationOutputHumioHecToHclTerraform(struct?: PackDestinationOutputHumioHec | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    auth_type: {
      value: cdktf.stringToHclTerraform(struct!.authType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    compress: {
      value: cdktf.booleanToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    concurrency: {
      value: cdktf.numberToHclTerraform(struct!.concurrency),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    extra_http_headers: {
      value: cdktf.listMapperHcl(packDestinationOutputHumioHecExtraHttpHeadersToHclTerraform, false)(struct!.extraHttpHeaders),
      isBlock: true,
      type: "list",
      storageClassType: "PackDestinationOutputHumioHecExtraHttpHeadersList",
    },
    failed_request_logging_mode: {
      value: cdktf.stringToHclTerraform(struct!.failedRequestLoggingMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    flush_period_sec: {
      value: cdktf.numberToHclTerraform(struct!.flushPeriodSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    format: {
      value: cdktf.stringToHclTerraform(struct!.format),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_payload_events: {
      value: cdktf.numberToHclTerraform(struct!.maxPayloadEvents),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_payload_size_kb: {
      value: cdktf.numberToHclTerraform(struct!.maxPayloadSizeKb),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.onBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_compress: {
      value: cdktf.stringToHclTerraform(struct!.pqCompress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_controls: {
      value: packDestinationOutputHumioHecPqControlsToHclTerraform(struct!.pqControls),
      isBlock: true,
      type: "struct",
      storageClassType: "PackDestinationOutputHumioHecPqControls",
    },
    pq_max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_max_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_mode: {
      value: cdktf.stringToHclTerraform(struct!.pqMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.pqOnBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_path: {
      value: cdktf.stringToHclTerraform(struct!.pqPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reject_unauthorized: {
      value: cdktf.booleanToHclTerraform(struct!.rejectUnauthorized),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    response_honor_retry_after_header: {
      value: cdktf.booleanToHclTerraform(struct!.responseHonorRetryAfterHeader),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    response_retry_settings: {
      value: cdktf.listMapperHcl(packDestinationOutputHumioHecResponseRetrySettingsToHclTerraform, false)(struct!.responseRetrySettings),
      isBlock: true,
      type: "list",
      storageClassType: "PackDestinationOutputHumioHecResponseRetrySettingsList",
    },
    safe_headers: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.safeHeaders),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    system_fields: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.systemFields),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    text_secret: {
      value: cdktf.stringToHclTerraform(struct!.textSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    timeout_retry_settings: {
      value: packDestinationOutputHumioHecTimeoutRetrySettingsToHclTerraform(struct!.timeoutRetrySettings),
      isBlock: true,
      type: "struct",
      storageClassType: "PackDestinationOutputHumioHecTimeoutRetrySettings",
    },
    timeout_sec: {
      value: cdktf.numberToHclTerraform(struct!.timeoutSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    token: {
      value: cdktf.stringToHclTerraform(struct!.token),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    url: {
      value: cdktf.stringToHclTerraform(struct!.url),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    use_round_robin_dns: {
      value: cdktf.booleanToHclTerraform(struct!.useRoundRobinDns),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputHumioHecOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): PackDestinationOutputHumioHec | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._authType !== undefined) {
      hasAnyValues = true;
      internalValueResult.authType = this._authType;
    }
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._concurrency !== undefined) {
      hasAnyValues = true;
      internalValueResult.concurrency = this._concurrency;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._extraHttpHeaders?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.extraHttpHeaders = this._extraHttpHeaders?.internalValue;
    }
    if (this._failedRequestLoggingMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.failedRequestLoggingMode = this._failedRequestLoggingMode;
    }
    if (this._flushPeriodSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.flushPeriodSec = this._flushPeriodSec;
    }
    if (this._format !== undefined) {
      hasAnyValues = true;
      internalValueResult.format = this._format;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._maxPayloadEvents !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxPayloadEvents = this._maxPayloadEvents;
    }
    if (this._maxPayloadSizeKb !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxPayloadSizeKb = this._maxPayloadSizeKb;
    }
    if (this._onBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.onBackpressure = this._onBackpressure;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._pqCompress !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqCompress = this._pqCompress;
    }
    if (this._pqControls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqControls = this._pqControls?.internalValue;
    }
    if (this._pqMaxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxFileSize = this._pqMaxFileSize;
    }
    if (this._pqMaxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxSize = this._pqMaxSize;
    }
    if (this._pqMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMode = this._pqMode;
    }
    if (this._pqOnBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqOnBackpressure = this._pqOnBackpressure;
    }
    if (this._pqPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqPath = this._pqPath;
    }
    if (this._rejectUnauthorized !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectUnauthorized = this._rejectUnauthorized;
    }
    if (this._responseHonorRetryAfterHeader !== undefined) {
      hasAnyValues = true;
      internalValueResult.responseHonorRetryAfterHeader = this._responseHonorRetryAfterHeader;
    }
    if (this._responseRetrySettings?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.responseRetrySettings = this._responseRetrySettings?.internalValue;
    }
    if (this._safeHeaders !== undefined) {
      hasAnyValues = true;
      internalValueResult.safeHeaders = this._safeHeaders;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._systemFields !== undefined) {
      hasAnyValues = true;
      internalValueResult.systemFields = this._systemFields;
    }
    if (this._textSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.textSecret = this._textSecret;
    }
    if (this._timeoutRetrySettings?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutRetrySettings = this._timeoutRetrySettings?.internalValue;
    }
    if (this._timeoutSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutSec = this._timeoutSec;
    }
    if (this._token !== undefined) {
      hasAnyValues = true;
      internalValueResult.token = this._token;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._url !== undefined) {
      hasAnyValues = true;
      internalValueResult.url = this._url;
    }
    if (this._useRoundRobinDns !== undefined) {
      hasAnyValues = true;
      internalValueResult.useRoundRobinDns = this._useRoundRobinDns;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputHumioHec | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._authType = undefined;
      this._compress = undefined;
      this._concurrency = undefined;
      this._description = undefined;
      this._environment = undefined;
      this._extraHttpHeaders.internalValue = undefined;
      this._failedRequestLoggingMode = undefined;
      this._flushPeriodSec = undefined;
      this._format = undefined;
      this._id = undefined;
      this._maxPayloadEvents = undefined;
      this._maxPayloadSizeKb = undefined;
      this._onBackpressure = undefined;
      this._pipeline = undefined;
      this._pqCompress = undefined;
      this._pqControls.internalValue = undefined;
      this._pqMaxFileSize = undefined;
      this._pqMaxSize = undefined;
      this._pqMode = undefined;
      this._pqOnBackpressure = undefined;
      this._pqPath = undefined;
      this._rejectUnauthorized = undefined;
      this._responseHonorRetryAfterHeader = undefined;
      this._responseRetrySettings.internalValue = undefined;
      this._safeHeaders = undefined;
      this._streamtags = undefined;
      this._systemFields = undefined;
      this._textSecret = undefined;
      this._timeoutRetrySettings.internalValue = undefined;
      this._timeoutSec = undefined;
      this._token = undefined;
      this._type = undefined;
      this._url = undefined;
      this._useRoundRobinDns = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._authType = value.authType;
      this._compress = value.compress;
      this._concurrency = value.concurrency;
      this._description = value.description;
      this._environment = value.environment;
      this._extraHttpHeaders.internalValue = value.extraHttpHeaders;
      this._failedRequestLoggingMode = value.failedRequestLoggingMode;
      this._flushPeriodSec = value.flushPeriodSec;
      this._format = value.format;
      this._id = value.id;
      this._maxPayloadEvents = value.maxPayloadEvents;
      this._maxPayloadSizeKb = value.maxPayloadSizeKb;
      this._onBackpressure = value.onBackpressure;
      this._pipeline = value.pipeline;
      this._pqCompress = value.pqCompress;
      this._pqControls.internalValue = value.pqControls;
      this._pqMaxFileSize = value.pqMaxFileSize;
      this._pqMaxSize = value.pqMaxSize;
      this._pqMode = value.pqMode;
      this._pqOnBackpressure = value.pqOnBackpressure;
      this._pqPath = value.pqPath;
      this._rejectUnauthorized = value.rejectUnauthorized;
      this._responseHonorRetryAfterHeader = value.responseHonorRetryAfterHeader;
      this._responseRetrySettings.internalValue = value.responseRetrySettings;
      this._safeHeaders = value.safeHeaders;
      this._streamtags = value.streamtags;
      this._systemFields = value.systemFields;
      this._textSecret = value.textSecret;
      this._timeoutRetrySettings.internalValue = value.timeoutRetrySettings;
      this._timeoutSec = value.timeoutSec;
      this._token = value.token;
      this._type = value.type;
      this._url = value.url;
      this._useRoundRobinDns = value.useRoundRobinDns;
    }
  }

  // auth_type - computed: true, optional: true, required: false
  private _authType?: string; 
  public get authType() {
    return this.getStringAttribute('auth_type');
  }
  public set authType(value: string) {
    this._authType = value;
  }
  public resetAuthType() {
    this._authType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authTypeInput() {
    return this._authType;
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: boolean | cdktf.IResolvable; 
  public get compress() {
    return this.getBooleanAttribute('compress');
  }
  public set compress(value: boolean | cdktf.IResolvable) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // concurrency - computed: true, optional: true, required: false
  private _concurrency?: number; 
  public get concurrency() {
    return this.getNumberAttribute('concurrency');
  }
  public set concurrency(value: number) {
    this._concurrency = value;
  }
  public resetConcurrency() {
    this._concurrency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get concurrencyInput() {
    return this._concurrency;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // extra_http_headers - computed: false, optional: true, required: false
  private _extraHttpHeaders = new PackDestinationOutputHumioHecExtraHttpHeadersList(this, "extra_http_headers", false);
  public get extraHttpHeaders() {
    return this._extraHttpHeaders;
  }
  public putExtraHttpHeaders(value: PackDestinationOutputHumioHecExtraHttpHeaders[] | cdktf.IResolvable) {
    this._extraHttpHeaders.internalValue = value;
  }
  public resetExtraHttpHeaders() {
    this._extraHttpHeaders.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get extraHttpHeadersInput() {
    return this._extraHttpHeaders.internalValue;
  }

  // failed_request_logging_mode - computed: true, optional: true, required: false
  private _failedRequestLoggingMode?: string; 
  public get failedRequestLoggingMode() {
    return this.getStringAttribute('failed_request_logging_mode');
  }
  public set failedRequestLoggingMode(value: string) {
    this._failedRequestLoggingMode = value;
  }
  public resetFailedRequestLoggingMode() {
    this._failedRequestLoggingMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get failedRequestLoggingModeInput() {
    return this._failedRequestLoggingMode;
  }

  // flush_period_sec - computed: true, optional: true, required: false
  private _flushPeriodSec?: number; 
  public get flushPeriodSec() {
    return this.getNumberAttribute('flush_period_sec');
  }
  public set flushPeriodSec(value: number) {
    this._flushPeriodSec = value;
  }
  public resetFlushPeriodSec() {
    this._flushPeriodSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get flushPeriodSecInput() {
    return this._flushPeriodSec;
  }

  // format - computed: true, optional: true, required: false
  private _format?: string; 
  public get format() {
    return this.getStringAttribute('format');
  }
  public set format(value: string) {
    this._format = value;
  }
  public resetFormat() {
    this._format = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get formatInput() {
    return this._format;
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // max_payload_events - computed: true, optional: true, required: false
  private _maxPayloadEvents?: number; 
  public get maxPayloadEvents() {
    return this.getNumberAttribute('max_payload_events');
  }
  public set maxPayloadEvents(value: number) {
    this._maxPayloadEvents = value;
  }
  public resetMaxPayloadEvents() {
    this._maxPayloadEvents = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxPayloadEventsInput() {
    return this._maxPayloadEvents;
  }

  // max_payload_size_kb - computed: true, optional: true, required: false
  private _maxPayloadSizeKb?: number; 
  public get maxPayloadSizeKb() {
    return this.getNumberAttribute('max_payload_size_kb');
  }
  public set maxPayloadSizeKb(value: number) {
    this._maxPayloadSizeKb = value;
  }
  public resetMaxPayloadSizeKb() {
    this._maxPayloadSizeKb = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxPayloadSizeKbInput() {
    return this._maxPayloadSizeKb;
  }

  // on_backpressure - computed: true, optional: true, required: false
  private _onBackpressure?: string; 
  public get onBackpressure() {
    return this.getStringAttribute('on_backpressure');
  }
  public set onBackpressure(value: string) {
    this._onBackpressure = value;
  }
  public resetOnBackpressure() {
    this._onBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get onBackpressureInput() {
    return this._onBackpressure;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // pq_compress - computed: true, optional: true, required: false
  private _pqCompress?: string; 
  public get pqCompress() {
    return this.getStringAttribute('pq_compress');
  }
  public set pqCompress(value: string) {
    this._pqCompress = value;
  }
  public resetPqCompress() {
    this._pqCompress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqCompressInput() {
    return this._pqCompress;
  }

  // pq_controls - computed: false, optional: true, required: false
  private _pqControls = new PackDestinationOutputHumioHecPqControlsOutputReference(this, "pq_controls");
  public get pqControls() {
    return this._pqControls;
  }
  public putPqControls(value: PackDestinationOutputHumioHecPqControls) {
    this._pqControls.internalValue = value;
  }
  public resetPqControls() {
    this._pqControls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqControlsInput() {
    return this._pqControls.internalValue;
  }

  // pq_max_file_size - computed: true, optional: true, required: false
  private _pqMaxFileSize?: string; 
  public get pqMaxFileSize() {
    return this.getStringAttribute('pq_max_file_size');
  }
  public set pqMaxFileSize(value: string) {
    this._pqMaxFileSize = value;
  }
  public resetPqMaxFileSize() {
    this._pqMaxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxFileSizeInput() {
    return this._pqMaxFileSize;
  }

  // pq_max_size - computed: true, optional: true, required: false
  private _pqMaxSize?: string; 
  public get pqMaxSize() {
    return this.getStringAttribute('pq_max_size');
  }
  public set pqMaxSize(value: string) {
    this._pqMaxSize = value;
  }
  public resetPqMaxSize() {
    this._pqMaxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxSizeInput() {
    return this._pqMaxSize;
  }

  // pq_mode - computed: true, optional: true, required: false
  private _pqMode?: string; 
  public get pqMode() {
    return this.getStringAttribute('pq_mode');
  }
  public set pqMode(value: string) {
    this._pqMode = value;
  }
  public resetPqMode() {
    this._pqMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqModeInput() {
    return this._pqMode;
  }

  // pq_on_backpressure - computed: true, optional: true, required: false
  private _pqOnBackpressure?: string; 
  public get pqOnBackpressure() {
    return this.getStringAttribute('pq_on_backpressure');
  }
  public set pqOnBackpressure(value: string) {
    this._pqOnBackpressure = value;
  }
  public resetPqOnBackpressure() {
    this._pqOnBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqOnBackpressureInput() {
    return this._pqOnBackpressure;
  }

  // pq_path - computed: true, optional: true, required: false
  private _pqPath?: string; 
  public get pqPath() {
    return this.getStringAttribute('pq_path');
  }
  public set pqPath(value: string) {
    this._pqPath = value;
  }
  public resetPqPath() {
    this._pqPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqPathInput() {
    return this._pqPath;
  }

  // reject_unauthorized - computed: true, optional: true, required: false
  private _rejectUnauthorized?: boolean | cdktf.IResolvable; 
  public get rejectUnauthorized() {
    return this.getBooleanAttribute('reject_unauthorized');
  }
  public set rejectUnauthorized(value: boolean | cdktf.IResolvable) {
    this._rejectUnauthorized = value;
  }
  public resetRejectUnauthorized() {
    this._rejectUnauthorized = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectUnauthorizedInput() {
    return this._rejectUnauthorized;
  }

  // response_honor_retry_after_header - computed: true, optional: true, required: false
  private _responseHonorRetryAfterHeader?: boolean | cdktf.IResolvable; 
  public get responseHonorRetryAfterHeader() {
    return this.getBooleanAttribute('response_honor_retry_after_header');
  }
  public set responseHonorRetryAfterHeader(value: boolean | cdktf.IResolvable) {
    this._responseHonorRetryAfterHeader = value;
  }
  public resetResponseHonorRetryAfterHeader() {
    this._responseHonorRetryAfterHeader = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get responseHonorRetryAfterHeaderInput() {
    return this._responseHonorRetryAfterHeader;
  }

  // response_retry_settings - computed: false, optional: true, required: false
  private _responseRetrySettings = new PackDestinationOutputHumioHecResponseRetrySettingsList(this, "response_retry_settings", false);
  public get responseRetrySettings() {
    return this._responseRetrySettings;
  }
  public putResponseRetrySettings(value: PackDestinationOutputHumioHecResponseRetrySettings[] | cdktf.IResolvable) {
    this._responseRetrySettings.internalValue = value;
  }
  public resetResponseRetrySettings() {
    this._responseRetrySettings.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get responseRetrySettingsInput() {
    return this._responseRetrySettings.internalValue;
  }

  // safe_headers - computed: true, optional: true, required: false
  private _safeHeaders?: string[]; 
  public get safeHeaders() {
    return this.getListAttribute('safe_headers');
  }
  public set safeHeaders(value: string[]) {
    this._safeHeaders = value;
  }
  public resetSafeHeaders() {
    this._safeHeaders = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get safeHeadersInput() {
    return this._safeHeaders;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // system_fields - computed: true, optional: true, required: false
  private _systemFields?: string[]; 
  public get systemFields() {
    return this.getListAttribute('system_fields');
  }
  public set systemFields(value: string[]) {
    this._systemFields = value;
  }
  public resetSystemFields() {
    this._systemFields = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get systemFieldsInput() {
    return this._systemFields;
  }

  // text_secret - computed: false, optional: true, required: false
  private _textSecret?: string; 
  public get textSecret() {
    return this.getStringAttribute('text_secret');
  }
  public set textSecret(value: string) {
    this._textSecret = value;
  }
  public resetTextSecret() {
    this._textSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get textSecretInput() {
    return this._textSecret;
  }

  // timeout_retry_settings - computed: false, optional: true, required: false
  private _timeoutRetrySettings = new PackDestinationOutputHumioHecTimeoutRetrySettingsOutputReference(this, "timeout_retry_settings");
  public get timeoutRetrySettings() {
    return this._timeoutRetrySettings;
  }
  public putTimeoutRetrySettings(value: PackDestinationOutputHumioHecTimeoutRetrySettings) {
    this._timeoutRetrySettings.internalValue = value;
  }
  public resetTimeoutRetrySettings() {
    this._timeoutRetrySettings.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutRetrySettingsInput() {
    return this._timeoutRetrySettings.internalValue;
  }

  // timeout_sec - computed: true, optional: true, required: false
  private _timeoutSec?: number; 
  public get timeoutSec() {
    return this.getNumberAttribute('timeout_sec');
  }
  public set timeoutSec(value: number) {
    this._timeoutSec = value;
  }
  public resetTimeoutSec() {
    this._timeoutSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutSecInput() {
    return this._timeoutSec;
  }

  // token - computed: false, optional: true, required: false
  private _token?: string; 
  public get token() {
    return this.getStringAttribute('token');
  }
  public set token(value: string) {
    this._token = value;
  }
  public resetToken() {
    this._token = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tokenInput() {
    return this._token;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // url - computed: true, optional: true, required: false
  private _url?: string; 
  public get url() {
    return this.getStringAttribute('url');
  }
  public set url(value: string) {
    this._url = value;
  }
  public resetUrl() {
    this._url = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get urlInput() {
    return this._url;
  }

  // use_round_robin_dns - computed: true, optional: true, required: false
  private _useRoundRobinDns?: boolean | cdktf.IResolvable; 
  public get useRoundRobinDns() {
    return this.getBooleanAttribute('use_round_robin_dns');
  }
  public set useRoundRobinDns(value: boolean | cdktf.IResolvable) {
    this._useRoundRobinDns = value;
  }
  public resetUseRoundRobinDns() {
    this._useRoundRobinDns = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get useRoundRobinDnsInput() {
    return this._useRoundRobinDns;
  }
}
export interface PackDestinationOutputInfluxdbExtraHttpHeaders {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#name PackDestination#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#value PackDestination#value}
  */
  readonly value: string;
}

export function packDestinationOutputInfluxdbExtraHttpHeadersToTerraform(struct?: PackDestinationOutputInfluxdbExtraHttpHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function packDestinationOutputInfluxdbExtraHttpHeadersToHclTerraform(struct?: PackDestinationOutputInfluxdbExtraHttpHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputInfluxdbExtraHttpHeadersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackDestinationOutputInfluxdbExtraHttpHeaders | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputInfluxdbExtraHttpHeaders | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class PackDestinationOutputInfluxdbExtraHttpHeadersList extends cdktf.ComplexList {
  public internalValue? : PackDestinationOutputInfluxdbExtraHttpHeaders[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackDestinationOutputInfluxdbExtraHttpHeadersOutputReference {
    return new PackDestinationOutputInfluxdbExtraHttpHeadersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface PackDestinationOutputInfluxdbOauthHeaders {
  /**
  * OAuth header name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#name PackDestination#name}
  */
  readonly name: string;
  /**
  * OAuth header value
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/pack_destination#value PackDestination#value}
  */
  readonly value: string;
}

export function packDestinationOutputInfluxdbOauthHeadersToTerraform(struct?: PackDestinationOutputInfluxdbOauthHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function packDestinationOutputInfluxdbOauthHeadersToHclTerraform(struct?: PackDestinationOutputInfluxdbOauthHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class PackDestinationOutputInfluxdbOauthHeadersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): PackDestinationOutputInfluxdbOauthHeaders | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: PackDestinationOutputInfluxdbOauthHeaders | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class PackDestinationOutputInfluxdbOauthHeadersList extends cdktf.ComplexList {
  public internalValue? : PackDestinationOutputInfluxdbOauthHeaders[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): PackDestinationOutputInfluxdbOauthHeadersOutputReference {
    return new PackDestinationOutputInfluxdbOauthHeadersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
