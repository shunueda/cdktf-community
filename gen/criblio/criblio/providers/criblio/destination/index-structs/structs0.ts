import * as cdktf from 'cdktf';
export interface DestinationOutputAzureBlobCertificate {
  /**
  * The certificate you registered as credentials for your app in the Azure portal
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#certificate_name Destination#certificate_name}
  */
  readonly certificateName: string;
}

export function destinationOutputAzureBlobCertificateToTerraform(struct?: DestinationOutputAzureBlobCertificate | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    certificate_name: cdktf.stringToTerraform(struct!.certificateName),
  }
}


export function destinationOutputAzureBlobCertificateToHclTerraform(struct?: DestinationOutputAzureBlobCertificate | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    certificate_name: {
      value: cdktf.stringToHclTerraform(struct!.certificateName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputAzureBlobCertificateOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DestinationOutputAzureBlobCertificate | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._certificateName !== undefined) {
      hasAnyValues = true;
      internalValueResult.certificateName = this._certificateName;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputAzureBlobCertificate | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._certificateName = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._certificateName = value.certificateName;
    }
  }

  // certificate_name - computed: false, optional: false, required: true
  private _certificateName?: string; 
  public get certificateName() {
    return this.getStringAttribute('certificate_name');
  }
  public set certificateName(value: string) {
    this._certificateName = value;
  }
  // Temporarily expose input value. Use with caution.
  public get certificateNameInput() {
    return this._certificateName;
  }
}
export interface DestinationOutputAzureBlobKeyValueMetadata {
  /**
  * Default: ""
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#key Destination#key}
  */
  readonly key?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#value Destination#value}
  */
  readonly value: string;
}

export function destinationOutputAzureBlobKeyValueMetadataToTerraform(struct?: DestinationOutputAzureBlobKeyValueMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function destinationOutputAzureBlobKeyValueMetadataToHclTerraform(struct?: DestinationOutputAzureBlobKeyValueMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputAzureBlobKeyValueMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DestinationOutputAzureBlobKeyValueMetadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputAzureBlobKeyValueMetadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._value = value.value;
    }
  }

  // key - computed: true, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DestinationOutputAzureBlobKeyValueMetadataList extends cdktf.ComplexList {
  public internalValue? : DestinationOutputAzureBlobKeyValueMetadata[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DestinationOutputAzureBlobKeyValueMetadataOutputReference {
    return new DestinationOutputAzureBlobKeyValueMetadataOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DestinationOutputAzureBlob {
  /**
  * Add the Output ID value to staging location. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#add_id_to_stage_path Destination#add_id_to_stage_path}
  */
  readonly addIdToStagePath?: boolean | cdktf.IResolvable;
  /**
  * Default: "manual"; must be one of ["manual", "secret", "clientSecret", "clientCert"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#auth_type Destination#auth_type}
  */
  readonly authType?: string;
  /**
  * Automatically calculate the schema based on the events of each Parquet file generated. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#automatic_schema Destination#automatic_schema}
  */
  readonly automaticSchema?: boolean | cdktf.IResolvable;
  /**
  * The Azure cloud to use. Defaults to Azure Public Cloud.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#azure_cloud Destination#azure_cloud}
  */
  readonly azureCloud?: string;
  /**
  * JavaScript expression to define the output filename prefix (can be constant). Default: "`CriblOut`"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#base_file_name Destination#base_file_name}
  */
  readonly baseFileName?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#certificate Destination#certificate}
  */
  readonly certificate?: DestinationOutputAzureBlobCertificate;
  /**
  * The service principal's client ID
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#client_id Destination#client_id}
  */
  readonly clientId?: string;
  /**
  * Select or create a stored text secret
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#client_text_secret Destination#client_text_secret}
  */
  readonly clientTextSecret?: string;
  /**
  * Data compression format to apply to HTTP content before it is delivered. Default: "gzip"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#compress Destination#compress}
  */
  readonly compress?: string;
  /**
  * Compression level to apply before moving files to final destination. Default: "best_speed"; must be one of ["best_speed", "normal", "best_compression"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#compression_level Destination#compression_level}
  */
  readonly compressionLevel?: string;
  /**
  * Enter your Azure Storage account connection string. If left blank, Stream will fall back to env.AZURE_STORAGE_CONNECTION_STRING.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#connection_string Destination#connection_string}
  */
  readonly connectionString?: string;
  /**
  * The Azure Blob Storage container name. Name can include only lowercase letters, numbers, and hyphens. For dynamic container names, enter a JavaScript expression within quotes or backtickss, to be evaluated at initialization. The expression can evaluate to a constant value and can reference Global Variables, such as `myContainer-${C.env["CRIBL_WORKER_ID"]}`.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#container_name Destination#container_name}
  */
  readonly containerName: string;
  /**
  * Create the configured container in Azure Blob Storage if it does not already exist. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#create_container Destination#create_container}
  */
  readonly createContainer?: boolean | cdktf.IResolvable;
  /**
  * If a file fails to move to its final destination after the maximum number of retries, move it to a designated directory to prevent further errors. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#deadletter_enabled Destination#deadletter_enabled}
  */
  readonly deadletterEnabled?: boolean | cdktf.IResolvable;
  /**
  * Storage location for files that fail to reach their final destination after maximum retries are exceeded. Default: "$CRIBL_HOME/state/outputs/dead-letter"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#deadletter_path Destination#deadletter_path}
  */
  readonly deadletterPath?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#description Destination#description}
  */
  readonly description?: string;
  /**
  * Root directory prepended to path before uploading. Value can be a JavaScript expression enclosed in quotes or backticks, to be evaluated at initialization. The expression can evaluate to a constant value and can reference Global Variables, such as `myBlobPrefix-${C.env["CRIBL_WORKER_ID"]}`.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#dest_path Destination#dest_path}
  */
  readonly destPath?: string;
  /**
  * How frequently, in seconds, to clean up empty directories. Default: 300
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#empty_dir_cleanup_sec Destination#empty_dir_cleanup_sec}
  */
  readonly emptyDirCleanupSec?: number;
  /**
  * Parquet tools can use the checksum of a Parquet page to verify data integrity. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#enable_page_checksum Destination#enable_page_checksum}
  */
  readonly enablePageChecksum?: boolean | cdktf.IResolvable;
  /**
  * Statistics profile an entire file in terms of minimum/maximum values within data, numbers of nulls, etc. You can use Parquet tools to view statistics. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#enable_statistics Destination#enable_statistics}
  */
  readonly enableStatistics?: boolean | cdktf.IResolvable;
  /**
  * One page index contains statistics for one data page. Parquet readers use statistics to enable page skipping. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#enable_write_page_index Destination#enable_write_page_index}
  */
  readonly enableWritePageIndex?: boolean | cdktf.IResolvable;
  /**
  * Endpoint suffix for the service URL. Takes precedence over the Azure Cloud setting. Defaults to core.windows.net.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#endpoint_suffix Destination#endpoint_suffix}
  */
  readonly endpointSuffix?: string;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#environment Destination#environment}
  */
  readonly environment?: string;
  /**
  * JavaScript expression to define the output filename suffix (can be constant).  The `__format` variable refers to the value of the `Data format` field (`json` or `raw`).  The `__compression` field refers to the kind of compression being used (`none` or `gzip`). Default: "`.${C.env[\"CRIBL_WORKER_ID\"]}.${__format}${__compression === \"gzip\" ? \".gz\" : \"\"}`"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#file_name_suffix Destination#file_name_suffix}
  */
  readonly fileNameSuffix?: string;
  /**
  * Format of the output data. Default: "json"; must be one of ["json", "raw", "parquet"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#format Destination#format}
  */
  readonly format?: string;
  /**
  * If set, this line will be written to the beginning of each output file. Default: ""
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#header_line Destination#header_line}
  */
  readonly headerLine?: string;
  /**
  * Unique ID for this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#id Destination#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * The metadata of files the Destination writes will include the properties you add here as key-value pairs. Useful for tagging. Examples: "key":"OCSF Event Class", "value":"9001"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#key_value_metadata Destination#key_value_metadata}
  */
  readonly keyValueMetadata?: DestinationOutputAzureBlobKeyValueMetadata[] | cdktf.IResolvable;
  /**
  * Maximum number of parts to upload in parallel per file. Default: 1
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#max_concurrent_file_parts Destination#max_concurrent_file_parts}
  */
  readonly maxConcurrentFileParts?: number;
  /**
  * Maximum amount of time to keep inactive files open. Files open for longer than this will be closed and moved to final output location. Default: 30
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#max_file_idle_time_sec Destination#max_file_idle_time_sec}
  */
  readonly maxFileIdleTimeSec?: number;
  /**
  * Maximum amount of time to write to a file. Files open for longer than this will be closed and moved to final output location. Default: 300
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#max_file_open_time_sec Destination#max_file_open_time_sec}
  */
  readonly maxFileOpenTimeSec?: number;
  /**
  * Maximum uncompressed output file size. Files of this size will be closed and moved to final output location. Default: 32
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#max_file_size_mb Destination#max_file_size_mb}
  */
  readonly maxFileSizeMb?: number;
  /**
  * Maximum number of files to keep open concurrently. When exceeded, @{product} will close the oldest open files and move them to the final output location. Default: 100
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#max_open_files Destination#max_open_files}
  */
  readonly maxOpenFiles?: number;
  /**
  * The maximum number of times a file will attempt to move to its final destination before being dead-lettered. Default: 20
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#max_retry_num Destination#max_retry_num}
  */
  readonly maxRetryNum?: number;
  /**
  * How to handle events when all receivers are exerting backpressure. Default: "block"; must be one of ["block", "drop"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#on_backpressure Destination#on_backpressure}
  */
  readonly onBackpressure?: string;
  /**
  * How to handle events when disk space is below the global 'Min free disk space' limit. Default: "block"; must be one of ["block", "drop"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#on_disk_full_backpressure Destination#on_disk_full_backpressure}
  */
  readonly onDiskFullBackpressure?: string;
  /**
  * Serialization format of data pages. Note that some reader implementations use Data page V2's attributes to work more efficiently, while others ignore it. Default: "DATA_PAGE_V2"; must be one of ["DATA_PAGE_V1", "DATA_PAGE_V2"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#parquet_data_page_version Destination#parquet_data_page_version}
  */
  readonly parquetDataPageVersion?: string;
  /**
  * Target memory size for page segments, such as 1MB or 128MB. Generally, lower values improve reading speed, while higher values improve compression. Default: "1MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#parquet_page_size Destination#parquet_page_size}
  */
  readonly parquetPageSize?: string;
  /**
  * The number of rows that every group will contain. The final group can contain a smaller number of rows. Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#parquet_row_group_length Destination#parquet_row_group_length}
  */
  readonly parquetRowGroupLength?: number;
  /**
  * Determines which data types are supported and how they are represented. Default: "PARQUET_2_6"; must be one of ["PARQUET_1_0", "PARQUET_2_4", "PARQUET_2_6"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#parquet_version Destination#parquet_version}
  */
  readonly parquetVersion?: string;
  /**
  * JavaScript expression defining how files are partitioned and organized. Default is date-based. If blank, Stream will fall back to the event's __partition field value – if present – otherwise to each location's root directory. Default: "C.Time.strftime(_time ? _time : Date.now()/1000, '%Y/%m/%d')"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#partition_expr Destination#partition_expr}
  */
  readonly partitionExpr?: string;
  /**
  * Pipeline to process data before sending out to this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pipeline Destination#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Remove empty staging directories after moving files. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#remove_empty_dirs Destination#remove_empty_dirs}
  */
  readonly removeEmptyDirs?: boolean | cdktf.IResolvable;
  /**
  * Log up to 3 rows that @{product} skips due to data mismatch
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#should_log_invalid_rows Destination#should_log_invalid_rows}
  */
  readonly shouldLogInvalidRows?: boolean | cdktf.IResolvable;
  /**
  * Filesystem location in which to buffer files before compressing and moving to final destination. Use performant and stable storage. Default: "$CRIBL_HOME/state/outputs/staging"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#stage_path Destination#stage_path}
  */
  readonly stagePath?: string;
  /**
  * The name of your Azure storage account
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#storage_account_name Destination#storage_account_name}
  */
  readonly storageAccountName?: string;
  /**
  * Default: "Inferred"; must be one of ["Inferred", "Hot", "Cool", "Cold", "Archive"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#storage_class Destination#storage_class}
  */
  readonly storageClass?: string;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#streamtags Destination#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Fields to automatically add to events, such as cribl_pipe. Supports wildcards. Default: ["cribl_pipe"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#system_fields Destination#system_fields}
  */
  readonly systemFields?: string[];
  /**
  * The service principal's tenant ID
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#tenant_id Destination#tenant_id}
  */
  readonly tenantId?: string;
  /**
  * Select or create a stored text secret
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#text_secret Destination#text_secret}
  */
  readonly textSecret?: string;
  /**
  * must be "azure_blob"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#type Destination#type}
  */
  readonly type?: string;
  /**
  * Buffer size used to write to a file. Default: 64
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#write_high_water_mark Destination#write_high_water_mark}
  */
  readonly writeHighWaterMark?: number;
}

export function destinationOutputAzureBlobToTerraform(struct?: DestinationOutputAzureBlob | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    add_id_to_stage_path: cdktf.booleanToTerraform(struct!.addIdToStagePath),
    auth_type: cdktf.stringToTerraform(struct!.authType),
    automatic_schema: cdktf.booleanToTerraform(struct!.automaticSchema),
    azure_cloud: cdktf.stringToTerraform(struct!.azureCloud),
    base_file_name: cdktf.stringToTerraform(struct!.baseFileName),
    certificate: destinationOutputAzureBlobCertificateToTerraform(struct!.certificate),
    client_id: cdktf.stringToTerraform(struct!.clientId),
    client_text_secret: cdktf.stringToTerraform(struct!.clientTextSecret),
    compress: cdktf.stringToTerraform(struct!.compress),
    compression_level: cdktf.stringToTerraform(struct!.compressionLevel),
    connection_string: cdktf.stringToTerraform(struct!.connectionString),
    container_name: cdktf.stringToTerraform(struct!.containerName),
    create_container: cdktf.booleanToTerraform(struct!.createContainer),
    deadletter_enabled: cdktf.booleanToTerraform(struct!.deadletterEnabled),
    deadletter_path: cdktf.stringToTerraform(struct!.deadletterPath),
    description: cdktf.stringToTerraform(struct!.description),
    dest_path: cdktf.stringToTerraform(struct!.destPath),
    empty_dir_cleanup_sec: cdktf.numberToTerraform(struct!.emptyDirCleanupSec),
    enable_page_checksum: cdktf.booleanToTerraform(struct!.enablePageChecksum),
    enable_statistics: cdktf.booleanToTerraform(struct!.enableStatistics),
    enable_write_page_index: cdktf.booleanToTerraform(struct!.enableWritePageIndex),
    endpoint_suffix: cdktf.stringToTerraform(struct!.endpointSuffix),
    environment: cdktf.stringToTerraform(struct!.environment),
    file_name_suffix: cdktf.stringToTerraform(struct!.fileNameSuffix),
    format: cdktf.stringToTerraform(struct!.format),
    header_line: cdktf.stringToTerraform(struct!.headerLine),
    id: cdktf.stringToTerraform(struct!.id),
    key_value_metadata: cdktf.listMapper(destinationOutputAzureBlobKeyValueMetadataToTerraform, false)(struct!.keyValueMetadata),
    max_concurrent_file_parts: cdktf.numberToTerraform(struct!.maxConcurrentFileParts),
    max_file_idle_time_sec: cdktf.numberToTerraform(struct!.maxFileIdleTimeSec),
    max_file_open_time_sec: cdktf.numberToTerraform(struct!.maxFileOpenTimeSec),
    max_file_size_mb: cdktf.numberToTerraform(struct!.maxFileSizeMb),
    max_open_files: cdktf.numberToTerraform(struct!.maxOpenFiles),
    max_retry_num: cdktf.numberToTerraform(struct!.maxRetryNum),
    on_backpressure: cdktf.stringToTerraform(struct!.onBackpressure),
    on_disk_full_backpressure: cdktf.stringToTerraform(struct!.onDiskFullBackpressure),
    parquet_data_page_version: cdktf.stringToTerraform(struct!.parquetDataPageVersion),
    parquet_page_size: cdktf.stringToTerraform(struct!.parquetPageSize),
    parquet_row_group_length: cdktf.numberToTerraform(struct!.parquetRowGroupLength),
    parquet_version: cdktf.stringToTerraform(struct!.parquetVersion),
    partition_expr: cdktf.stringToTerraform(struct!.partitionExpr),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    remove_empty_dirs: cdktf.booleanToTerraform(struct!.removeEmptyDirs),
    should_log_invalid_rows: cdktf.booleanToTerraform(struct!.shouldLogInvalidRows),
    stage_path: cdktf.stringToTerraform(struct!.stagePath),
    storage_account_name: cdktf.stringToTerraform(struct!.storageAccountName),
    storage_class: cdktf.stringToTerraform(struct!.storageClass),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    system_fields: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.systemFields),
    tenant_id: cdktf.stringToTerraform(struct!.tenantId),
    text_secret: cdktf.stringToTerraform(struct!.textSecret),
    type: cdktf.stringToTerraform(struct!.type),
    write_high_water_mark: cdktf.numberToTerraform(struct!.writeHighWaterMark),
  }
}


export function destinationOutputAzureBlobToHclTerraform(struct?: DestinationOutputAzureBlob | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    add_id_to_stage_path: {
      value: cdktf.booleanToHclTerraform(struct!.addIdToStagePath),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    auth_type: {
      value: cdktf.stringToHclTerraform(struct!.authType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    automatic_schema: {
      value: cdktf.booleanToHclTerraform(struct!.automaticSchema),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    azure_cloud: {
      value: cdktf.stringToHclTerraform(struct!.azureCloud),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    base_file_name: {
      value: cdktf.stringToHclTerraform(struct!.baseFileName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    certificate: {
      value: destinationOutputAzureBlobCertificateToHclTerraform(struct!.certificate),
      isBlock: true,
      type: "struct",
      storageClassType: "DestinationOutputAzureBlobCertificate",
    },
    client_id: {
      value: cdktf.stringToHclTerraform(struct!.clientId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    client_text_secret: {
      value: cdktf.stringToHclTerraform(struct!.clientTextSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    compress: {
      value: cdktf.stringToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    compression_level: {
      value: cdktf.stringToHclTerraform(struct!.compressionLevel),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    connection_string: {
      value: cdktf.stringToHclTerraform(struct!.connectionString),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    container_name: {
      value: cdktf.stringToHclTerraform(struct!.containerName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    create_container: {
      value: cdktf.booleanToHclTerraform(struct!.createContainer),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    deadletter_enabled: {
      value: cdktf.booleanToHclTerraform(struct!.deadletterEnabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    deadletter_path: {
      value: cdktf.stringToHclTerraform(struct!.deadletterPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    dest_path: {
      value: cdktf.stringToHclTerraform(struct!.destPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    empty_dir_cleanup_sec: {
      value: cdktf.numberToHclTerraform(struct!.emptyDirCleanupSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    enable_page_checksum: {
      value: cdktf.booleanToHclTerraform(struct!.enablePageChecksum),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    enable_statistics: {
      value: cdktf.booleanToHclTerraform(struct!.enableStatistics),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    enable_write_page_index: {
      value: cdktf.booleanToHclTerraform(struct!.enableWritePageIndex),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    endpoint_suffix: {
      value: cdktf.stringToHclTerraform(struct!.endpointSuffix),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    file_name_suffix: {
      value: cdktf.stringToHclTerraform(struct!.fileNameSuffix),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    format: {
      value: cdktf.stringToHclTerraform(struct!.format),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    header_line: {
      value: cdktf.stringToHclTerraform(struct!.headerLine),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    key_value_metadata: {
      value: cdktf.listMapperHcl(destinationOutputAzureBlobKeyValueMetadataToHclTerraform, false)(struct!.keyValueMetadata),
      isBlock: true,
      type: "list",
      storageClassType: "DestinationOutputAzureBlobKeyValueMetadataList",
    },
    max_concurrent_file_parts: {
      value: cdktf.numberToHclTerraform(struct!.maxConcurrentFileParts),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_file_idle_time_sec: {
      value: cdktf.numberToHclTerraform(struct!.maxFileIdleTimeSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_file_open_time_sec: {
      value: cdktf.numberToHclTerraform(struct!.maxFileOpenTimeSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_file_size_mb: {
      value: cdktf.numberToHclTerraform(struct!.maxFileSizeMb),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_open_files: {
      value: cdktf.numberToHclTerraform(struct!.maxOpenFiles),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_retry_num: {
      value: cdktf.numberToHclTerraform(struct!.maxRetryNum),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.onBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    on_disk_full_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.onDiskFullBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    parquet_data_page_version: {
      value: cdktf.stringToHclTerraform(struct!.parquetDataPageVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    parquet_page_size: {
      value: cdktf.stringToHclTerraform(struct!.parquetPageSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    parquet_row_group_length: {
      value: cdktf.numberToHclTerraform(struct!.parquetRowGroupLength),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    parquet_version: {
      value: cdktf.stringToHclTerraform(struct!.parquetVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    partition_expr: {
      value: cdktf.stringToHclTerraform(struct!.partitionExpr),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    remove_empty_dirs: {
      value: cdktf.booleanToHclTerraform(struct!.removeEmptyDirs),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    should_log_invalid_rows: {
      value: cdktf.booleanToHclTerraform(struct!.shouldLogInvalidRows),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    stage_path: {
      value: cdktf.stringToHclTerraform(struct!.stagePath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    storage_account_name: {
      value: cdktf.stringToHclTerraform(struct!.storageAccountName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    storage_class: {
      value: cdktf.stringToHclTerraform(struct!.storageClass),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    system_fields: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.systemFields),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    tenant_id: {
      value: cdktf.stringToHclTerraform(struct!.tenantId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    text_secret: {
      value: cdktf.stringToHclTerraform(struct!.textSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    write_high_water_mark: {
      value: cdktf.numberToHclTerraform(struct!.writeHighWaterMark),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputAzureBlobOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DestinationOutputAzureBlob | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._addIdToStagePath !== undefined) {
      hasAnyValues = true;
      internalValueResult.addIdToStagePath = this._addIdToStagePath;
    }
    if (this._authType !== undefined) {
      hasAnyValues = true;
      internalValueResult.authType = this._authType;
    }
    if (this._automaticSchema !== undefined) {
      hasAnyValues = true;
      internalValueResult.automaticSchema = this._automaticSchema;
    }
    if (this._azureCloud !== undefined) {
      hasAnyValues = true;
      internalValueResult.azureCloud = this._azureCloud;
    }
    if (this._baseFileName !== undefined) {
      hasAnyValues = true;
      internalValueResult.baseFileName = this._baseFileName;
    }
    if (this._certificate?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.certificate = this._certificate?.internalValue;
    }
    if (this._clientId !== undefined) {
      hasAnyValues = true;
      internalValueResult.clientId = this._clientId;
    }
    if (this._clientTextSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.clientTextSecret = this._clientTextSecret;
    }
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._compressionLevel !== undefined) {
      hasAnyValues = true;
      internalValueResult.compressionLevel = this._compressionLevel;
    }
    if (this._connectionString !== undefined) {
      hasAnyValues = true;
      internalValueResult.connectionString = this._connectionString;
    }
    if (this._containerName !== undefined) {
      hasAnyValues = true;
      internalValueResult.containerName = this._containerName;
    }
    if (this._createContainer !== undefined) {
      hasAnyValues = true;
      internalValueResult.createContainer = this._createContainer;
    }
    if (this._deadletterEnabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.deadletterEnabled = this._deadletterEnabled;
    }
    if (this._deadletterPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.deadletterPath = this._deadletterPath;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._destPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.destPath = this._destPath;
    }
    if (this._emptyDirCleanupSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.emptyDirCleanupSec = this._emptyDirCleanupSec;
    }
    if (this._enablePageChecksum !== undefined) {
      hasAnyValues = true;
      internalValueResult.enablePageChecksum = this._enablePageChecksum;
    }
    if (this._enableStatistics !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableStatistics = this._enableStatistics;
    }
    if (this._enableWritePageIndex !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableWritePageIndex = this._enableWritePageIndex;
    }
    if (this._endpointSuffix !== undefined) {
      hasAnyValues = true;
      internalValueResult.endpointSuffix = this._endpointSuffix;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._fileNameSuffix !== undefined) {
      hasAnyValues = true;
      internalValueResult.fileNameSuffix = this._fileNameSuffix;
    }
    if (this._format !== undefined) {
      hasAnyValues = true;
      internalValueResult.format = this._format;
    }
    if (this._headerLine !== undefined) {
      hasAnyValues = true;
      internalValueResult.headerLine = this._headerLine;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._keyValueMetadata?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.keyValueMetadata = this._keyValueMetadata?.internalValue;
    }
    if (this._maxConcurrentFileParts !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxConcurrentFileParts = this._maxConcurrentFileParts;
    }
    if (this._maxFileIdleTimeSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxFileIdleTimeSec = this._maxFileIdleTimeSec;
    }
    if (this._maxFileOpenTimeSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxFileOpenTimeSec = this._maxFileOpenTimeSec;
    }
    if (this._maxFileSizeMb !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxFileSizeMb = this._maxFileSizeMb;
    }
    if (this._maxOpenFiles !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxOpenFiles = this._maxOpenFiles;
    }
    if (this._maxRetryNum !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxRetryNum = this._maxRetryNum;
    }
    if (this._onBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.onBackpressure = this._onBackpressure;
    }
    if (this._onDiskFullBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.onDiskFullBackpressure = this._onDiskFullBackpressure;
    }
    if (this._parquetDataPageVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.parquetDataPageVersion = this._parquetDataPageVersion;
    }
    if (this._parquetPageSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.parquetPageSize = this._parquetPageSize;
    }
    if (this._parquetRowGroupLength !== undefined) {
      hasAnyValues = true;
      internalValueResult.parquetRowGroupLength = this._parquetRowGroupLength;
    }
    if (this._parquetVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.parquetVersion = this._parquetVersion;
    }
    if (this._partitionExpr !== undefined) {
      hasAnyValues = true;
      internalValueResult.partitionExpr = this._partitionExpr;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._removeEmptyDirs !== undefined) {
      hasAnyValues = true;
      internalValueResult.removeEmptyDirs = this._removeEmptyDirs;
    }
    if (this._shouldLogInvalidRows !== undefined) {
      hasAnyValues = true;
      internalValueResult.shouldLogInvalidRows = this._shouldLogInvalidRows;
    }
    if (this._stagePath !== undefined) {
      hasAnyValues = true;
      internalValueResult.stagePath = this._stagePath;
    }
    if (this._storageAccountName !== undefined) {
      hasAnyValues = true;
      internalValueResult.storageAccountName = this._storageAccountName;
    }
    if (this._storageClass !== undefined) {
      hasAnyValues = true;
      internalValueResult.storageClass = this._storageClass;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._systemFields !== undefined) {
      hasAnyValues = true;
      internalValueResult.systemFields = this._systemFields;
    }
    if (this._tenantId !== undefined) {
      hasAnyValues = true;
      internalValueResult.tenantId = this._tenantId;
    }
    if (this._textSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.textSecret = this._textSecret;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._writeHighWaterMark !== undefined) {
      hasAnyValues = true;
      internalValueResult.writeHighWaterMark = this._writeHighWaterMark;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputAzureBlob | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._addIdToStagePath = undefined;
      this._authType = undefined;
      this._automaticSchema = undefined;
      this._azureCloud = undefined;
      this._baseFileName = undefined;
      this._certificate.internalValue = undefined;
      this._clientId = undefined;
      this._clientTextSecret = undefined;
      this._compress = undefined;
      this._compressionLevel = undefined;
      this._connectionString = undefined;
      this._containerName = undefined;
      this._createContainer = undefined;
      this._deadletterEnabled = undefined;
      this._deadletterPath = undefined;
      this._description = undefined;
      this._destPath = undefined;
      this._emptyDirCleanupSec = undefined;
      this._enablePageChecksum = undefined;
      this._enableStatistics = undefined;
      this._enableWritePageIndex = undefined;
      this._endpointSuffix = undefined;
      this._environment = undefined;
      this._fileNameSuffix = undefined;
      this._format = undefined;
      this._headerLine = undefined;
      this._id = undefined;
      this._keyValueMetadata.internalValue = undefined;
      this._maxConcurrentFileParts = undefined;
      this._maxFileIdleTimeSec = undefined;
      this._maxFileOpenTimeSec = undefined;
      this._maxFileSizeMb = undefined;
      this._maxOpenFiles = undefined;
      this._maxRetryNum = undefined;
      this._onBackpressure = undefined;
      this._onDiskFullBackpressure = undefined;
      this._parquetDataPageVersion = undefined;
      this._parquetPageSize = undefined;
      this._parquetRowGroupLength = undefined;
      this._parquetVersion = undefined;
      this._partitionExpr = undefined;
      this._pipeline = undefined;
      this._removeEmptyDirs = undefined;
      this._shouldLogInvalidRows = undefined;
      this._stagePath = undefined;
      this._storageAccountName = undefined;
      this._storageClass = undefined;
      this._streamtags = undefined;
      this._systemFields = undefined;
      this._tenantId = undefined;
      this._textSecret = undefined;
      this._type = undefined;
      this._writeHighWaterMark = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._addIdToStagePath = value.addIdToStagePath;
      this._authType = value.authType;
      this._automaticSchema = value.automaticSchema;
      this._azureCloud = value.azureCloud;
      this._baseFileName = value.baseFileName;
      this._certificate.internalValue = value.certificate;
      this._clientId = value.clientId;
      this._clientTextSecret = value.clientTextSecret;
      this._compress = value.compress;
      this._compressionLevel = value.compressionLevel;
      this._connectionString = value.connectionString;
      this._containerName = value.containerName;
      this._createContainer = value.createContainer;
      this._deadletterEnabled = value.deadletterEnabled;
      this._deadletterPath = value.deadletterPath;
      this._description = value.description;
      this._destPath = value.destPath;
      this._emptyDirCleanupSec = value.emptyDirCleanupSec;
      this._enablePageChecksum = value.enablePageChecksum;
      this._enableStatistics = value.enableStatistics;
      this._enableWritePageIndex = value.enableWritePageIndex;
      this._endpointSuffix = value.endpointSuffix;
      this._environment = value.environment;
      this._fileNameSuffix = value.fileNameSuffix;
      this._format = value.format;
      this._headerLine = value.headerLine;
      this._id = value.id;
      this._keyValueMetadata.internalValue = value.keyValueMetadata;
      this._maxConcurrentFileParts = value.maxConcurrentFileParts;
      this._maxFileIdleTimeSec = value.maxFileIdleTimeSec;
      this._maxFileOpenTimeSec = value.maxFileOpenTimeSec;
      this._maxFileSizeMb = value.maxFileSizeMb;
      this._maxOpenFiles = value.maxOpenFiles;
      this._maxRetryNum = value.maxRetryNum;
      this._onBackpressure = value.onBackpressure;
      this._onDiskFullBackpressure = value.onDiskFullBackpressure;
      this._parquetDataPageVersion = value.parquetDataPageVersion;
      this._parquetPageSize = value.parquetPageSize;
      this._parquetRowGroupLength = value.parquetRowGroupLength;
      this._parquetVersion = value.parquetVersion;
      this._partitionExpr = value.partitionExpr;
      this._pipeline = value.pipeline;
      this._removeEmptyDirs = value.removeEmptyDirs;
      this._shouldLogInvalidRows = value.shouldLogInvalidRows;
      this._stagePath = value.stagePath;
      this._storageAccountName = value.storageAccountName;
      this._storageClass = value.storageClass;
      this._streamtags = value.streamtags;
      this._systemFields = value.systemFields;
      this._tenantId = value.tenantId;
      this._textSecret = value.textSecret;
      this._type = value.type;
      this._writeHighWaterMark = value.writeHighWaterMark;
    }
  }

  // add_id_to_stage_path - computed: true, optional: true, required: false
  private _addIdToStagePath?: boolean | cdktf.IResolvable; 
  public get addIdToStagePath() {
    return this.getBooleanAttribute('add_id_to_stage_path');
  }
  public set addIdToStagePath(value: boolean | cdktf.IResolvable) {
    this._addIdToStagePath = value;
  }
  public resetAddIdToStagePath() {
    this._addIdToStagePath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addIdToStagePathInput() {
    return this._addIdToStagePath;
  }

  // auth_type - computed: true, optional: true, required: false
  private _authType?: string; 
  public get authType() {
    return this.getStringAttribute('auth_type');
  }
  public set authType(value: string) {
    this._authType = value;
  }
  public resetAuthType() {
    this._authType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authTypeInput() {
    return this._authType;
  }

  // automatic_schema - computed: true, optional: true, required: false
  private _automaticSchema?: boolean | cdktf.IResolvable; 
  public get automaticSchema() {
    return this.getBooleanAttribute('automatic_schema');
  }
  public set automaticSchema(value: boolean | cdktf.IResolvable) {
    this._automaticSchema = value;
  }
  public resetAutomaticSchema() {
    this._automaticSchema = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get automaticSchemaInput() {
    return this._automaticSchema;
  }

  // azure_cloud - computed: false, optional: true, required: false
  private _azureCloud?: string; 
  public get azureCloud() {
    return this.getStringAttribute('azure_cloud');
  }
  public set azureCloud(value: string) {
    this._azureCloud = value;
  }
  public resetAzureCloud() {
    this._azureCloud = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get azureCloudInput() {
    return this._azureCloud;
  }

  // base_file_name - computed: true, optional: true, required: false
  private _baseFileName?: string; 
  public get baseFileName() {
    return this.getStringAttribute('base_file_name');
  }
  public set baseFileName(value: string) {
    this._baseFileName = value;
  }
  public resetBaseFileName() {
    this._baseFileName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get baseFileNameInput() {
    return this._baseFileName;
  }

  // certificate - computed: false, optional: true, required: false
  private _certificate = new DestinationOutputAzureBlobCertificateOutputReference(this, "certificate");
  public get certificate() {
    return this._certificate;
  }
  public putCertificate(value: DestinationOutputAzureBlobCertificate) {
    this._certificate.internalValue = value;
  }
  public resetCertificate() {
    this._certificate.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certificateInput() {
    return this._certificate.internalValue;
  }

  // client_id - computed: false, optional: true, required: false
  private _clientId?: string; 
  public get clientId() {
    return this.getStringAttribute('client_id');
  }
  public set clientId(value: string) {
    this._clientId = value;
  }
  public resetClientId() {
    this._clientId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clientIdInput() {
    return this._clientId;
  }

  // client_text_secret - computed: false, optional: true, required: false
  private _clientTextSecret?: string; 
  public get clientTextSecret() {
    return this.getStringAttribute('client_text_secret');
  }
  public set clientTextSecret(value: string) {
    this._clientTextSecret = value;
  }
  public resetClientTextSecret() {
    this._clientTextSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clientTextSecretInput() {
    return this._clientTextSecret;
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: string; 
  public get compress() {
    return this.getStringAttribute('compress');
  }
  public set compress(value: string) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // compression_level - computed: true, optional: true, required: false
  private _compressionLevel?: string; 
  public get compressionLevel() {
    return this.getStringAttribute('compression_level');
  }
  public set compressionLevel(value: string) {
    this._compressionLevel = value;
  }
  public resetCompressionLevel() {
    this._compressionLevel = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressionLevelInput() {
    return this._compressionLevel;
  }

  // connection_string - computed: false, optional: true, required: false
  private _connectionString?: string; 
  public get connectionString() {
    return this.getStringAttribute('connection_string');
  }
  public set connectionString(value: string) {
    this._connectionString = value;
  }
  public resetConnectionString() {
    this._connectionString = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectionStringInput() {
    return this._connectionString;
  }

  // container_name - computed: false, optional: false, required: true
  private _containerName?: string; 
  public get containerName() {
    return this.getStringAttribute('container_name');
  }
  public set containerName(value: string) {
    this._containerName = value;
  }
  // Temporarily expose input value. Use with caution.
  public get containerNameInput() {
    return this._containerName;
  }

  // create_container - computed: true, optional: true, required: false
  private _createContainer?: boolean | cdktf.IResolvable; 
  public get createContainer() {
    return this.getBooleanAttribute('create_container');
  }
  public set createContainer(value: boolean | cdktf.IResolvable) {
    this._createContainer = value;
  }
  public resetCreateContainer() {
    this._createContainer = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get createContainerInput() {
    return this._createContainer;
  }

  // deadletter_enabled - computed: true, optional: true, required: false
  private _deadletterEnabled?: boolean | cdktf.IResolvable; 
  public get deadletterEnabled() {
    return this.getBooleanAttribute('deadletter_enabled');
  }
  public set deadletterEnabled(value: boolean | cdktf.IResolvable) {
    this._deadletterEnabled = value;
  }
  public resetDeadletterEnabled() {
    this._deadletterEnabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get deadletterEnabledInput() {
    return this._deadletterEnabled;
  }

  // deadletter_path - computed: true, optional: true, required: false
  private _deadletterPath?: string; 
  public get deadletterPath() {
    return this.getStringAttribute('deadletter_path');
  }
  public set deadletterPath(value: string) {
    this._deadletterPath = value;
  }
  public resetDeadletterPath() {
    this._deadletterPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get deadletterPathInput() {
    return this._deadletterPath;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // dest_path - computed: false, optional: true, required: false
  private _destPath?: string; 
  public get destPath() {
    return this.getStringAttribute('dest_path');
  }
  public set destPath(value: string) {
    this._destPath = value;
  }
  public resetDestPath() {
    this._destPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get destPathInput() {
    return this._destPath;
  }

  // empty_dir_cleanup_sec - computed: true, optional: true, required: false
  private _emptyDirCleanupSec?: number; 
  public get emptyDirCleanupSec() {
    return this.getNumberAttribute('empty_dir_cleanup_sec');
  }
  public set emptyDirCleanupSec(value: number) {
    this._emptyDirCleanupSec = value;
  }
  public resetEmptyDirCleanupSec() {
    this._emptyDirCleanupSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get emptyDirCleanupSecInput() {
    return this._emptyDirCleanupSec;
  }

  // enable_page_checksum - computed: true, optional: true, required: false
  private _enablePageChecksum?: boolean | cdktf.IResolvable; 
  public get enablePageChecksum() {
    return this.getBooleanAttribute('enable_page_checksum');
  }
  public set enablePageChecksum(value: boolean | cdktf.IResolvable) {
    this._enablePageChecksum = value;
  }
  public resetEnablePageChecksum() {
    this._enablePageChecksum = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enablePageChecksumInput() {
    return this._enablePageChecksum;
  }

  // enable_statistics - computed: true, optional: true, required: false
  private _enableStatistics?: boolean | cdktf.IResolvable; 
  public get enableStatistics() {
    return this.getBooleanAttribute('enable_statistics');
  }
  public set enableStatistics(value: boolean | cdktf.IResolvable) {
    this._enableStatistics = value;
  }
  public resetEnableStatistics() {
    this._enableStatistics = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableStatisticsInput() {
    return this._enableStatistics;
  }

  // enable_write_page_index - computed: true, optional: true, required: false
  private _enableWritePageIndex?: boolean | cdktf.IResolvable; 
  public get enableWritePageIndex() {
    return this.getBooleanAttribute('enable_write_page_index');
  }
  public set enableWritePageIndex(value: boolean | cdktf.IResolvable) {
    this._enableWritePageIndex = value;
  }
  public resetEnableWritePageIndex() {
    this._enableWritePageIndex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableWritePageIndexInput() {
    return this._enableWritePageIndex;
  }

  // endpoint_suffix - computed: false, optional: true, required: false
  private _endpointSuffix?: string; 
  public get endpointSuffix() {
    return this.getStringAttribute('endpoint_suffix');
  }
  public set endpointSuffix(value: string) {
    this._endpointSuffix = value;
  }
  public resetEndpointSuffix() {
    this._endpointSuffix = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get endpointSuffixInput() {
    return this._endpointSuffix;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // file_name_suffix - computed: true, optional: true, required: false
  private _fileNameSuffix?: string; 
  public get fileNameSuffix() {
    return this.getStringAttribute('file_name_suffix');
  }
  public set fileNameSuffix(value: string) {
    this._fileNameSuffix = value;
  }
  public resetFileNameSuffix() {
    this._fileNameSuffix = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fileNameSuffixInput() {
    return this._fileNameSuffix;
  }

  // format - computed: true, optional: true, required: false
  private _format?: string; 
  public get format() {
    return this.getStringAttribute('format');
  }
  public set format(value: string) {
    this._format = value;
  }
  public resetFormat() {
    this._format = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get formatInput() {
    return this._format;
  }

  // header_line - computed: true, optional: true, required: false
  private _headerLine?: string; 
  public get headerLine() {
    return this.getStringAttribute('header_line');
  }
  public set headerLine(value: string) {
    this._headerLine = value;
  }
  public resetHeaderLine() {
    this._headerLine = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get headerLineInput() {
    return this._headerLine;
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // key_value_metadata - computed: false, optional: true, required: false
  private _keyValueMetadata = new DestinationOutputAzureBlobKeyValueMetadataList(this, "key_value_metadata", false);
  public get keyValueMetadata() {
    return this._keyValueMetadata;
  }
  public putKeyValueMetadata(value: DestinationOutputAzureBlobKeyValueMetadata[] | cdktf.IResolvable) {
    this._keyValueMetadata.internalValue = value;
  }
  public resetKeyValueMetadata() {
    this._keyValueMetadata.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyValueMetadataInput() {
    return this._keyValueMetadata.internalValue;
  }

  // max_concurrent_file_parts - computed: true, optional: true, required: false
  private _maxConcurrentFileParts?: number; 
  public get maxConcurrentFileParts() {
    return this.getNumberAttribute('max_concurrent_file_parts');
  }
  public set maxConcurrentFileParts(value: number) {
    this._maxConcurrentFileParts = value;
  }
  public resetMaxConcurrentFileParts() {
    this._maxConcurrentFileParts = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxConcurrentFilePartsInput() {
    return this._maxConcurrentFileParts;
  }

  // max_file_idle_time_sec - computed: true, optional: true, required: false
  private _maxFileIdleTimeSec?: number; 
  public get maxFileIdleTimeSec() {
    return this.getNumberAttribute('max_file_idle_time_sec');
  }
  public set maxFileIdleTimeSec(value: number) {
    this._maxFileIdleTimeSec = value;
  }
  public resetMaxFileIdleTimeSec() {
    this._maxFileIdleTimeSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxFileIdleTimeSecInput() {
    return this._maxFileIdleTimeSec;
  }

  // max_file_open_time_sec - computed: true, optional: true, required: false
  private _maxFileOpenTimeSec?: number; 
  public get maxFileOpenTimeSec() {
    return this.getNumberAttribute('max_file_open_time_sec');
  }
  public set maxFileOpenTimeSec(value: number) {
    this._maxFileOpenTimeSec = value;
  }
  public resetMaxFileOpenTimeSec() {
    this._maxFileOpenTimeSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxFileOpenTimeSecInput() {
    return this._maxFileOpenTimeSec;
  }

  // max_file_size_mb - computed: true, optional: true, required: false
  private _maxFileSizeMb?: number; 
  public get maxFileSizeMb() {
    return this.getNumberAttribute('max_file_size_mb');
  }
  public set maxFileSizeMb(value: number) {
    this._maxFileSizeMb = value;
  }
  public resetMaxFileSizeMb() {
    this._maxFileSizeMb = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxFileSizeMbInput() {
    return this._maxFileSizeMb;
  }

  // max_open_files - computed: true, optional: true, required: false
  private _maxOpenFiles?: number; 
  public get maxOpenFiles() {
    return this.getNumberAttribute('max_open_files');
  }
  public set maxOpenFiles(value: number) {
    this._maxOpenFiles = value;
  }
  public resetMaxOpenFiles() {
    this._maxOpenFiles = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxOpenFilesInput() {
    return this._maxOpenFiles;
  }

  // max_retry_num - computed: true, optional: true, required: false
  private _maxRetryNum?: number; 
  public get maxRetryNum() {
    return this.getNumberAttribute('max_retry_num');
  }
  public set maxRetryNum(value: number) {
    this._maxRetryNum = value;
  }
  public resetMaxRetryNum() {
    this._maxRetryNum = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxRetryNumInput() {
    return this._maxRetryNum;
  }

  // on_backpressure - computed: true, optional: true, required: false
  private _onBackpressure?: string; 
  public get onBackpressure() {
    return this.getStringAttribute('on_backpressure');
  }
  public set onBackpressure(value: string) {
    this._onBackpressure = value;
  }
  public resetOnBackpressure() {
    this._onBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get onBackpressureInput() {
    return this._onBackpressure;
  }

  // on_disk_full_backpressure - computed: true, optional: true, required: false
  private _onDiskFullBackpressure?: string; 
  public get onDiskFullBackpressure() {
    return this.getStringAttribute('on_disk_full_backpressure');
  }
  public set onDiskFullBackpressure(value: string) {
    this._onDiskFullBackpressure = value;
  }
  public resetOnDiskFullBackpressure() {
    this._onDiskFullBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get onDiskFullBackpressureInput() {
    return this._onDiskFullBackpressure;
  }

  // parquet_data_page_version - computed: true, optional: true, required: false
  private _parquetDataPageVersion?: string; 
  public get parquetDataPageVersion() {
    return this.getStringAttribute('parquet_data_page_version');
  }
  public set parquetDataPageVersion(value: string) {
    this._parquetDataPageVersion = value;
  }
  public resetParquetDataPageVersion() {
    this._parquetDataPageVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get parquetDataPageVersionInput() {
    return this._parquetDataPageVersion;
  }

  // parquet_page_size - computed: true, optional: true, required: false
  private _parquetPageSize?: string; 
  public get parquetPageSize() {
    return this.getStringAttribute('parquet_page_size');
  }
  public set parquetPageSize(value: string) {
    this._parquetPageSize = value;
  }
  public resetParquetPageSize() {
    this._parquetPageSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get parquetPageSizeInput() {
    return this._parquetPageSize;
  }

  // parquet_row_group_length - computed: true, optional: true, required: false
  private _parquetRowGroupLength?: number; 
  public get parquetRowGroupLength() {
    return this.getNumberAttribute('parquet_row_group_length');
  }
  public set parquetRowGroupLength(value: number) {
    this._parquetRowGroupLength = value;
  }
  public resetParquetRowGroupLength() {
    this._parquetRowGroupLength = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get parquetRowGroupLengthInput() {
    return this._parquetRowGroupLength;
  }

  // parquet_version - computed: true, optional: true, required: false
  private _parquetVersion?: string; 
  public get parquetVersion() {
    return this.getStringAttribute('parquet_version');
  }
  public set parquetVersion(value: string) {
    this._parquetVersion = value;
  }
  public resetParquetVersion() {
    this._parquetVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get parquetVersionInput() {
    return this._parquetVersion;
  }

  // partition_expr - computed: true, optional: true, required: false
  private _partitionExpr?: string; 
  public get partitionExpr() {
    return this.getStringAttribute('partition_expr');
  }
  public set partitionExpr(value: string) {
    this._partitionExpr = value;
  }
  public resetPartitionExpr() {
    this._partitionExpr = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get partitionExprInput() {
    return this._partitionExpr;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // remove_empty_dirs - computed: true, optional: true, required: false
  private _removeEmptyDirs?: boolean | cdktf.IResolvable; 
  public get removeEmptyDirs() {
    return this.getBooleanAttribute('remove_empty_dirs');
  }
  public set removeEmptyDirs(value: boolean | cdktf.IResolvable) {
    this._removeEmptyDirs = value;
  }
  public resetRemoveEmptyDirs() {
    this._removeEmptyDirs = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get removeEmptyDirsInput() {
    return this._removeEmptyDirs;
  }

  // should_log_invalid_rows - computed: false, optional: true, required: false
  private _shouldLogInvalidRows?: boolean | cdktf.IResolvable; 
  public get shouldLogInvalidRows() {
    return this.getBooleanAttribute('should_log_invalid_rows');
  }
  public set shouldLogInvalidRows(value: boolean | cdktf.IResolvable) {
    this._shouldLogInvalidRows = value;
  }
  public resetShouldLogInvalidRows() {
    this._shouldLogInvalidRows = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get shouldLogInvalidRowsInput() {
    return this._shouldLogInvalidRows;
  }

  // stage_path - computed: true, optional: true, required: false
  private _stagePath?: string; 
  public get stagePath() {
    return this.getStringAttribute('stage_path');
  }
  public set stagePath(value: string) {
    this._stagePath = value;
  }
  public resetStagePath() {
    this._stagePath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get stagePathInput() {
    return this._stagePath;
  }

  // storage_account_name - computed: false, optional: true, required: false
  private _storageAccountName?: string; 
  public get storageAccountName() {
    return this.getStringAttribute('storage_account_name');
  }
  public set storageAccountName(value: string) {
    this._storageAccountName = value;
  }
  public resetStorageAccountName() {
    this._storageAccountName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get storageAccountNameInput() {
    return this._storageAccountName;
  }

  // storage_class - computed: true, optional: true, required: false
  private _storageClass?: string; 
  public get storageClass() {
    return this.getStringAttribute('storage_class');
  }
  public set storageClass(value: string) {
    this._storageClass = value;
  }
  public resetStorageClass() {
    this._storageClass = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get storageClassInput() {
    return this._storageClass;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // system_fields - computed: true, optional: true, required: false
  private _systemFields?: string[]; 
  public get systemFields() {
    return this.getListAttribute('system_fields');
  }
  public set systemFields(value: string[]) {
    this._systemFields = value;
  }
  public resetSystemFields() {
    this._systemFields = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get systemFieldsInput() {
    return this._systemFields;
  }

  // tenant_id - computed: false, optional: true, required: false
  private _tenantId?: string; 
  public get tenantId() {
    return this.getStringAttribute('tenant_id');
  }
  public set tenantId(value: string) {
    this._tenantId = value;
  }
  public resetTenantId() {
    this._tenantId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tenantIdInput() {
    return this._tenantId;
  }

  // text_secret - computed: false, optional: true, required: false
  private _textSecret?: string; 
  public get textSecret() {
    return this.getStringAttribute('text_secret');
  }
  public set textSecret(value: string) {
    this._textSecret = value;
  }
  public resetTextSecret() {
    this._textSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get textSecretInput() {
    return this._textSecret;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // write_high_water_mark - computed: true, optional: true, required: false
  private _writeHighWaterMark?: number; 
  public get writeHighWaterMark() {
    return this.getNumberAttribute('write_high_water_mark');
  }
  public set writeHighWaterMark(value: number) {
    this._writeHighWaterMark = value;
  }
  public resetWriteHighWaterMark() {
    this._writeHighWaterMark = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get writeHighWaterMarkInput() {
    return this._writeHighWaterMark;
  }
}
export interface DestinationOutputAzureDataExplorerAdditionalProperties {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#key Destination#key}
  */
  readonly key: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#value Destination#value}
  */
  readonly value: string;
}

export function destinationOutputAzureDataExplorerAdditionalPropertiesToTerraform(struct?: DestinationOutputAzureDataExplorerAdditionalProperties | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function destinationOutputAzureDataExplorerAdditionalPropertiesToHclTerraform(struct?: DestinationOutputAzureDataExplorerAdditionalProperties | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputAzureDataExplorerAdditionalPropertiesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DestinationOutputAzureDataExplorerAdditionalProperties | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputAzureDataExplorerAdditionalProperties | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._value = value.value;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DestinationOutputAzureDataExplorerAdditionalPropertiesList extends cdktf.ComplexList {
  public internalValue? : DestinationOutputAzureDataExplorerAdditionalProperties[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DestinationOutputAzureDataExplorerAdditionalPropertiesOutputReference {
    return new DestinationOutputAzureDataExplorerAdditionalPropertiesOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DestinationOutputAzureDataExplorerCertificate {
  /**
  * The certificate you registered as credentials for your app in the Azure portal
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#certificate_name Destination#certificate_name}
  */
  readonly certificateName?: string;
}

export function destinationOutputAzureDataExplorerCertificateToTerraform(struct?: DestinationOutputAzureDataExplorerCertificate | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    certificate_name: cdktf.stringToTerraform(struct!.certificateName),
  }
}


export function destinationOutputAzureDataExplorerCertificateToHclTerraform(struct?: DestinationOutputAzureDataExplorerCertificate | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    certificate_name: {
      value: cdktf.stringToHclTerraform(struct!.certificateName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputAzureDataExplorerCertificateOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DestinationOutputAzureDataExplorerCertificate | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._certificateName !== undefined) {
      hasAnyValues = true;
      internalValueResult.certificateName = this._certificateName;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputAzureDataExplorerCertificate | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._certificateName = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._certificateName = value.certificateName;
    }
  }

  // certificate_name - computed: false, optional: true, required: false
  private _certificateName?: string; 
  public get certificateName() {
    return this.getStringAttribute('certificate_name');
  }
  public set certificateName(value: string) {
    this._certificateName = value;
  }
  public resetCertificateName() {
    this._certificateName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certificateNameInput() {
    return this._certificateName;
  }
}
export interface DestinationOutputAzureDataExplorerExtentTags {
  /**
  * must be one of ["dropBy", "ingestBy"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#prefix Destination#prefix}
  */
  readonly prefix?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#value Destination#value}
  */
  readonly value: string;
}

export function destinationOutputAzureDataExplorerExtentTagsToTerraform(struct?: DestinationOutputAzureDataExplorerExtentTags | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    prefix: cdktf.stringToTerraform(struct!.prefix),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function destinationOutputAzureDataExplorerExtentTagsToHclTerraform(struct?: DestinationOutputAzureDataExplorerExtentTags | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    prefix: {
      value: cdktf.stringToHclTerraform(struct!.prefix),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputAzureDataExplorerExtentTagsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DestinationOutputAzureDataExplorerExtentTags | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._prefix !== undefined) {
      hasAnyValues = true;
      internalValueResult.prefix = this._prefix;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputAzureDataExplorerExtentTags | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._prefix = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._prefix = value.prefix;
      this._value = value.value;
    }
  }

  // prefix - computed: false, optional: true, required: false
  private _prefix?: string; 
  public get prefix() {
    return this.getStringAttribute('prefix');
  }
  public set prefix(value: string) {
    this._prefix = value;
  }
  public resetPrefix() {
    this._prefix = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get prefixInput() {
    return this._prefix;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DestinationOutputAzureDataExplorerExtentTagsList extends cdktf.ComplexList {
  public internalValue? : DestinationOutputAzureDataExplorerExtentTags[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DestinationOutputAzureDataExplorerExtentTagsOutputReference {
    return new DestinationOutputAzureDataExplorerExtentTagsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DestinationOutputAzureDataExplorerIngestIfNotExists {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#value Destination#value}
  */
  readonly value: string;
}

export function destinationOutputAzureDataExplorerIngestIfNotExistsToTerraform(struct?: DestinationOutputAzureDataExplorerIngestIfNotExists | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function destinationOutputAzureDataExplorerIngestIfNotExistsToHclTerraform(struct?: DestinationOutputAzureDataExplorerIngestIfNotExists | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputAzureDataExplorerIngestIfNotExistsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DestinationOutputAzureDataExplorerIngestIfNotExists | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputAzureDataExplorerIngestIfNotExists | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._value = value.value;
    }
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DestinationOutputAzureDataExplorerIngestIfNotExistsList extends cdktf.ComplexList {
  public internalValue? : DestinationOutputAzureDataExplorerIngestIfNotExists[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DestinationOutputAzureDataExplorerIngestIfNotExistsOutputReference {
    return new DestinationOutputAzureDataExplorerIngestIfNotExistsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DestinationOutputAzureDataExplorerPqControls {
}

export function destinationOutputAzureDataExplorerPqControlsToTerraform(struct?: DestinationOutputAzureDataExplorerPqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function destinationOutputAzureDataExplorerPqControlsToHclTerraform(struct?: DestinationOutputAzureDataExplorerPqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class DestinationOutputAzureDataExplorerPqControlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DestinationOutputAzureDataExplorerPqControls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputAzureDataExplorerPqControls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface DestinationOutputAzureDataExplorerResponseRetrySettings {
  /**
  * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc. Default: 2
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#backoff_rate Destination#backoff_rate}
  */
  readonly backoffRate?: number;
  /**
  * The HTTP response status code that will trigger retries
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#http_status Destination#http_status}
  */
  readonly httpStatus: number;
  /**
  * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes). Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#initial_backoff Destination#initial_backoff}
  */
  readonly initialBackoff?: number;
  /**
  * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds). Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#max_backoff Destination#max_backoff}
  */
  readonly maxBackoff?: number;
}

export function destinationOutputAzureDataExplorerResponseRetrySettingsToTerraform(struct?: DestinationOutputAzureDataExplorerResponseRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    backoff_rate: cdktf.numberToTerraform(struct!.backoffRate),
    http_status: cdktf.numberToTerraform(struct!.httpStatus),
    initial_backoff: cdktf.numberToTerraform(struct!.initialBackoff),
    max_backoff: cdktf.numberToTerraform(struct!.maxBackoff),
  }
}


export function destinationOutputAzureDataExplorerResponseRetrySettingsToHclTerraform(struct?: DestinationOutputAzureDataExplorerResponseRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    backoff_rate: {
      value: cdktf.numberToHclTerraform(struct!.backoffRate),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    http_status: {
      value: cdktf.numberToHclTerraform(struct!.httpStatus),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    initial_backoff: {
      value: cdktf.numberToHclTerraform(struct!.initialBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_backoff: {
      value: cdktf.numberToHclTerraform(struct!.maxBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputAzureDataExplorerResponseRetrySettingsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DestinationOutputAzureDataExplorerResponseRetrySettings | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._backoffRate !== undefined) {
      hasAnyValues = true;
      internalValueResult.backoffRate = this._backoffRate;
    }
    if (this._httpStatus !== undefined) {
      hasAnyValues = true;
      internalValueResult.httpStatus = this._httpStatus;
    }
    if (this._initialBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.initialBackoff = this._initialBackoff;
    }
    if (this._maxBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBackoff = this._maxBackoff;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputAzureDataExplorerResponseRetrySettings | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._backoffRate = undefined;
      this._httpStatus = undefined;
      this._initialBackoff = undefined;
      this._maxBackoff = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._backoffRate = value.backoffRate;
      this._httpStatus = value.httpStatus;
      this._initialBackoff = value.initialBackoff;
      this._maxBackoff = value.maxBackoff;
    }
  }

  // backoff_rate - computed: true, optional: true, required: false
  private _backoffRate?: number; 
  public get backoffRate() {
    return this.getNumberAttribute('backoff_rate');
  }
  public set backoffRate(value: number) {
    this._backoffRate = value;
  }
  public resetBackoffRate() {
    this._backoffRate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get backoffRateInput() {
    return this._backoffRate;
  }

  // http_status - computed: false, optional: false, required: true
  private _httpStatus?: number; 
  public get httpStatus() {
    return this.getNumberAttribute('http_status');
  }
  public set httpStatus(value: number) {
    this._httpStatus = value;
  }
  // Temporarily expose input value. Use with caution.
  public get httpStatusInput() {
    return this._httpStatus;
  }

  // initial_backoff - computed: true, optional: true, required: false
  private _initialBackoff?: number; 
  public get initialBackoff() {
    return this.getNumberAttribute('initial_backoff');
  }
  public set initialBackoff(value: number) {
    this._initialBackoff = value;
  }
  public resetInitialBackoff() {
    this._initialBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get initialBackoffInput() {
    return this._initialBackoff;
  }

  // max_backoff - computed: true, optional: true, required: false
  private _maxBackoff?: number; 
  public get maxBackoff() {
    return this.getNumberAttribute('max_backoff');
  }
  public set maxBackoff(value: number) {
    this._maxBackoff = value;
  }
  public resetMaxBackoff() {
    this._maxBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBackoffInput() {
    return this._maxBackoff;
  }
}

export class DestinationOutputAzureDataExplorerResponseRetrySettingsList extends cdktf.ComplexList {
  public internalValue? : DestinationOutputAzureDataExplorerResponseRetrySettings[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DestinationOutputAzureDataExplorerResponseRetrySettingsOutputReference {
    return new DestinationOutputAzureDataExplorerResponseRetrySettingsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DestinationOutputAzureDataExplorerTimeoutRetrySettings {
  /**
  * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc. Default: 2
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#backoff_rate Destination#backoff_rate}
  */
  readonly backoffRate?: number;
  /**
  * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes). Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#initial_backoff Destination#initial_backoff}
  */
  readonly initialBackoff?: number;
  /**
  * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds). Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#max_backoff Destination#max_backoff}
  */
  readonly maxBackoff?: number;
  /**
  * Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#timeout_retry Destination#timeout_retry}
  */
  readonly timeoutRetry?: boolean | cdktf.IResolvable;
}

export function destinationOutputAzureDataExplorerTimeoutRetrySettingsToTerraform(struct?: DestinationOutputAzureDataExplorerTimeoutRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    backoff_rate: cdktf.numberToTerraform(struct!.backoffRate),
    initial_backoff: cdktf.numberToTerraform(struct!.initialBackoff),
    max_backoff: cdktf.numberToTerraform(struct!.maxBackoff),
    timeout_retry: cdktf.booleanToTerraform(struct!.timeoutRetry),
  }
}


export function destinationOutputAzureDataExplorerTimeoutRetrySettingsToHclTerraform(struct?: DestinationOutputAzureDataExplorerTimeoutRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    backoff_rate: {
      value: cdktf.numberToHclTerraform(struct!.backoffRate),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    initial_backoff: {
      value: cdktf.numberToHclTerraform(struct!.initialBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_backoff: {
      value: cdktf.numberToHclTerraform(struct!.maxBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    timeout_retry: {
      value: cdktf.booleanToHclTerraform(struct!.timeoutRetry),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputAzureDataExplorerTimeoutRetrySettingsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DestinationOutputAzureDataExplorerTimeoutRetrySettings | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._backoffRate !== undefined) {
      hasAnyValues = true;
      internalValueResult.backoffRate = this._backoffRate;
    }
    if (this._initialBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.initialBackoff = this._initialBackoff;
    }
    if (this._maxBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBackoff = this._maxBackoff;
    }
    if (this._timeoutRetry !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutRetry = this._timeoutRetry;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputAzureDataExplorerTimeoutRetrySettings | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._backoffRate = undefined;
      this._initialBackoff = undefined;
      this._maxBackoff = undefined;
      this._timeoutRetry = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._backoffRate = value.backoffRate;
      this._initialBackoff = value.initialBackoff;
      this._maxBackoff = value.maxBackoff;
      this._timeoutRetry = value.timeoutRetry;
    }
  }

  // backoff_rate - computed: true, optional: true, required: false
  private _backoffRate?: number; 
  public get backoffRate() {
    return this.getNumberAttribute('backoff_rate');
  }
  public set backoffRate(value: number) {
    this._backoffRate = value;
  }
  public resetBackoffRate() {
    this._backoffRate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get backoffRateInput() {
    return this._backoffRate;
  }

  // initial_backoff - computed: true, optional: true, required: false
  private _initialBackoff?: number; 
  public get initialBackoff() {
    return this.getNumberAttribute('initial_backoff');
  }
  public set initialBackoff(value: number) {
    this._initialBackoff = value;
  }
  public resetInitialBackoff() {
    this._initialBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get initialBackoffInput() {
    return this._initialBackoff;
  }

  // max_backoff - computed: true, optional: true, required: false
  private _maxBackoff?: number; 
  public get maxBackoff() {
    return this.getNumberAttribute('max_backoff');
  }
  public set maxBackoff(value: number) {
    this._maxBackoff = value;
  }
  public resetMaxBackoff() {
    this._maxBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBackoffInput() {
    return this._maxBackoff;
  }

  // timeout_retry - computed: true, optional: true, required: false
  private _timeoutRetry?: boolean | cdktf.IResolvable; 
  public get timeoutRetry() {
    return this.getBooleanAttribute('timeout_retry');
  }
  public set timeoutRetry(value: boolean | cdktf.IResolvable) {
    this._timeoutRetry = value;
  }
  public resetTimeoutRetry() {
    this._timeoutRetry = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutRetryInput() {
    return this._timeoutRetry;
  }
}
export interface DestinationOutputAzureDataExplorer {
  /**
  * Add the Output ID value to staging location. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#add_id_to_stage_path Destination#add_id_to_stage_path}
  */
  readonly addIdToStagePath?: boolean | cdktf.IResolvable;
  /**
  * Optionally, enter additional configuration properties to send to the ingestion service
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#additional_properties Destination#additional_properties}
  */
  readonly additionalProperties?: DestinationOutputAzureDataExplorerAdditionalProperties[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#certificate Destination#certificate}
  */
  readonly certificate?: DestinationOutputAzureDataExplorerCertificate;
  /**
  * client_id to pass in the OAuth request parameter
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#client_id Destination#client_id}
  */
  readonly clientId: string;
  /**
  * The client secret that you generated for your app in the Azure portal
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#client_secret Destination#client_secret}
  */
  readonly clientSecret?: string;
  /**
  * The base URI for your cluster. Typically, `https://<cluster>.<region>.kusto.windows.net`.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#cluster_url Destination#cluster_url}
  */
  readonly clusterUrl: string;
  /**
  * Data compression format to apply to HTTP content before it is delivered. Default: "gzip"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#compress Destination#compress}
  */
  readonly compress?: string;
  /**
  * Maximum number of ongoing requests before blocking. Default: 5
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#concurrency Destination#concurrency}
  */
  readonly concurrency?: number;
  /**
  * Name of the database containing the table where data will be ingested
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#database Destination#database}
  */
  readonly database: string;
  /**
  * If a file fails to move to its final destination after the maximum number of retries, move it to a designated directory to prevent further errors. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#deadletter_enabled Destination#deadletter_enabled}
  */
  readonly deadletterEnabled?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#description Destination#description}
  */
  readonly description?: string;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#environment Destination#environment}
  */
  readonly environment?: string;
  /**
  * Strings or tags associated with the extent (ingested data shard)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#extent_tags Destination#extent_tags}
  */
  readonly extentTags?: DestinationOutputAzureDataExplorerExtentTags[] | cdktf.IResolvable;
  /**
  * JavaScript expression to define the output filename suffix (can be constant).  The `__format` variable refers to the value of the `Data format` field (`json` or `raw`).  The `__compression` field refers to the kind of compression being used (`none` or `gzip`). Default: "`.${C.env[\"CRIBL_WORKER_ID\"]}.${__format}${__compression === \"gzip\" ? \".gz\" : \"\"}`"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#file_name_suffix Destination#file_name_suffix}
  */
  readonly fileNameSuffix?: string;
  /**
  * Bypass the data management service's aggregation mechanism. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#flush_immediately Destination#flush_immediately}
  */
  readonly flushImmediately?: boolean | cdktf.IResolvable;
  /**
  * Maximum time between requests. Small values could cause the payload size to be smaller than the configured Body size limit. Default: 1
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#flush_period_sec Destination#flush_period_sec}
  */
  readonly flushPeriodSec?: number;
  /**
  * Format of the output data. Default: "json"; must be one of ["json", "raw", "parquet"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#format Destination#format}
  */
  readonly format?: string;
  /**
  * Unique ID for this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#id Destination#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * Prevents duplicate ingestion by verifying whether an extent with the specified ingest-by tag already exists
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#ingest_if_not_exists Destination#ingest_if_not_exists}
  */
  readonly ingestIfNotExists?: DestinationOutputAzureDataExplorerIngestIfNotExists[] | cdktf.IResolvable;
  /**
  * Default: "batching"; must be one of ["batching", "streaming"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#ingest_mode Destination#ingest_mode}
  */
  readonly ingestMode?: string;
  /**
  * The ingestion service URI for your cluster. Typically, `https://ingest-<cluster>.<region>.kusto.windows.net`.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#ingest_url Destination#ingest_url}
  */
  readonly ingestUrl?: string;
  /**
  * Send a JSON mapping object instead of specifying an existing named data mapping. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#is_mapping_obj Destination#is_mapping_obj}
  */
  readonly isMappingObj?: boolean | cdktf.IResolvable;
  /**
  * Disable to close the connection immediately after sending the outgoing request. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#keep_alive Destination#keep_alive}
  */
  readonly keepAlive?: boolean | cdktf.IResolvable;
  /**
  * Enter the name of a data mapping associated with your target table. Or, if incoming event and target table fields match exactly, you can leave the field empty.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#mapping_ref Destination#mapping_ref}
  */
  readonly mappingRef?: string;
  /**
  * Maximum number of parts to upload in parallel per file. Default: 1
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#max_concurrent_file_parts Destination#max_concurrent_file_parts}
  */
  readonly maxConcurrentFileParts?: number;
  /**
  * Maximum amount of time to keep inactive files open. Files open for longer than this will be closed and moved to final output location. Default: 30
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#max_file_idle_time_sec Destination#max_file_idle_time_sec}
  */
  readonly maxFileIdleTimeSec?: number;
  /**
  * Maximum amount of time to write to a file. Files open for longer than this will be closed and moved to final output location. Default: 300
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#max_file_open_time_sec Destination#max_file_open_time_sec}
  */
  readonly maxFileOpenTimeSec?: number;
  /**
  * Maximum uncompressed output file size. Files of this size will be closed and moved to final output location. Default: 32
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#max_file_size_mb Destination#max_file_size_mb}
  */
  readonly maxFileSizeMb?: number;
  /**
  * Maximum number of files to keep open concurrently. When exceeded, @{product} will close the oldest open files and move them to the final output location. Default: 100
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#max_open_files Destination#max_open_files}
  */
  readonly maxOpenFiles?: number;
  /**
  * Maximum number of events to include in the request body. Default is 0 (unlimited). Default: 0
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#max_payload_events Destination#max_payload_events}
  */
  readonly maxPayloadEvents?: number;
  /**
  * Maximum size, in KB, of the request body. Default: 4096
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#max_payload_size_kb Destination#max_payload_size_kb}
  */
  readonly maxPayloadSizeKb?: number;
  /**
  * Endpoint used to acquire authentication tokens from Azure. Default: "https://login.microsoftonline.com"; must be one of ["https://login.microsoftonline.com", "https://login.microsoftonline.us", "https://login.partner.microsoftonline.cn"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#oauth_endpoint Destination#oauth_endpoint}
  */
  readonly oauthEndpoint?: string;
  /**
  * The type of OAuth 2.0 client credentials grant flow to use. Default: "clientSecret"; must be one of ["clientSecret", "clientTextSecret", "certificate"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#oauth_type Destination#oauth_type}
  */
  readonly oauthType?: string;
  /**
  * How to handle events when all receivers are exerting backpressure. Default: "block"; must be one of ["block", "drop", "queue"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#on_backpressure Destination#on_backpressure}
  */
  readonly onBackpressure?: string;
  /**
  * How to handle events when disk space is below the global 'Min free disk space' limit. Default: "block"; must be one of ["block", "drop"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#on_disk_full_backpressure Destination#on_disk_full_backpressure}
  */
  readonly onDiskFullBackpressure?: string;
  /**
  * Pipeline to process data before sending out to this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pipeline Destination#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pq_compress Destination#pq_compress}
  */
  readonly pqCompress?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pq_controls Destination#pq_controls}
  */
  readonly pqControls?: DestinationOutputAzureDataExplorerPqControls;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.). Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pq_max_file_size Destination#pq_max_file_size}
  */
  readonly pqMaxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pq_max_size Destination#pq_max_size}
  */
  readonly pqMaxSize?: string;
  /**
  * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem. Default: "error"; must be one of ["error", "backpressure", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pq_mode Destination#pq_mode}
  */
  readonly pqMode?: string;
  /**
  * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged. Default: "block"; must be one of ["block", "drop"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pq_on_backpressure Destination#pq_on_backpressure}
  */
  readonly pqOnBackpressure?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pq_path Destination#pq_path}
  */
  readonly pqPath?: string;
  /**
  * Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's).
  * 
  * 
  *         Enabled by default. When this setting is also present in TLS Settings (Client Side),
  *         that value will take precedence.
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#reject_unauthorized Destination#reject_unauthorized}
  */
  readonly rejectUnauthorized?: boolean | cdktf.IResolvable;
  /**
  * Remove empty staging directories after moving files. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#remove_empty_dirs Destination#remove_empty_dirs}
  */
  readonly removeEmptyDirs?: boolean | cdktf.IResolvable;
  /**
  * Level of ingestion status reporting. Defaults to FailuresOnly. Default: "failuresOnly"; must be one of ["failuresOnly", "doNotReport", "failuresAndSuccesses"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#report_level Destination#report_level}
  */
  readonly reportLevel?: string;
  /**
  * Target of the ingestion status reporting. Defaults to Queue. Default: "queue"; must be one of ["queue", "table", "queueAndTable"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#report_method Destination#report_method}
  */
  readonly reportMethod?: string;
  /**
  * Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#response_honor_retry_after_header Destination#response_honor_retry_after_header}
  */
  readonly responseHonorRetryAfterHeader?: boolean | cdktf.IResolvable;
  /**
  * Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#response_retry_settings Destination#response_retry_settings}
  */
  readonly responseRetrySettings?: DestinationOutputAzureDataExplorerResponseRetrySettings[] | cdktf.IResolvable;
  /**
  * Prevent blob deletion after ingestion is complete. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#retain_blob_on_success Destination#retain_blob_on_success}
  */
  readonly retainBlobOnSuccess?: boolean | cdktf.IResolvable;
  /**
  * Scope to pass in the OAuth request parameter
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#scope Destination#scope}
  */
  readonly scope: string;
  /**
  * Filesystem location in which to buffer files before compressing and moving to final destination. Use performant and stable storage. Default: "$CRIBL_HOME/state/outputs/staging"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#stage_path Destination#stage_path}
  */
  readonly stagePath?: string;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#streamtags Destination#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Fields to automatically add to events, such as cribl_pipe. Supports wildcards. Default: ["cribl_pipe"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#system_fields Destination#system_fields}
  */
  readonly systemFields?: string[];
  /**
  * Name of the table to ingest data into
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#table Destination#table}
  */
  readonly table: string;
  /**
  * Directory ID (tenant identifier) in Azure Active Directory
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#tenant_id Destination#tenant_id}
  */
  readonly tenantId: string;
  /**
  * Select or create a stored text secret
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#text_secret Destination#text_secret}
  */
  readonly textSecret?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#timeout_retry_settings Destination#timeout_retry_settings}
  */
  readonly timeoutRetrySettings?: DestinationOutputAzureDataExplorerTimeoutRetrySettings;
  /**
  * Amount of time, in seconds, to wait for a request to complete before canceling it. Default: 30
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#timeout_sec Destination#timeout_sec}
  */
  readonly timeoutSec?: number;
  /**
  * must be "azure_data_explorer"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#type Destination#type}
  */
  readonly type?: string;
  /**
  * Enable round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. For optimal performance, consider enabling this setting for non-load balanced destinations. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#use_round_robin_dns Destination#use_round_robin_dns}
  */
  readonly useRoundRobinDns?: boolean | cdktf.IResolvable;
  /**
  * When saving or starting the Destination, validate the database name and credentials; also validate table name, except when creating a new table. Disable if your Azure app does not have both the Database Viewer and the Table Viewer role. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#validate_database_settings Destination#validate_database_settings}
  */
  readonly validateDatabaseSettings?: boolean | cdktf.IResolvable;
}

export function destinationOutputAzureDataExplorerToTerraform(struct?: DestinationOutputAzureDataExplorer | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    add_id_to_stage_path: cdktf.booleanToTerraform(struct!.addIdToStagePath),
    additional_properties: cdktf.listMapper(destinationOutputAzureDataExplorerAdditionalPropertiesToTerraform, false)(struct!.additionalProperties),
    certificate: destinationOutputAzureDataExplorerCertificateToTerraform(struct!.certificate),
    client_id: cdktf.stringToTerraform(struct!.clientId),
    client_secret: cdktf.stringToTerraform(struct!.clientSecret),
    cluster_url: cdktf.stringToTerraform(struct!.clusterUrl),
    compress: cdktf.stringToTerraform(struct!.compress),
    concurrency: cdktf.numberToTerraform(struct!.concurrency),
    database: cdktf.stringToTerraform(struct!.database),
    deadletter_enabled: cdktf.booleanToTerraform(struct!.deadletterEnabled),
    description: cdktf.stringToTerraform(struct!.description),
    environment: cdktf.stringToTerraform(struct!.environment),
    extent_tags: cdktf.listMapper(destinationOutputAzureDataExplorerExtentTagsToTerraform, false)(struct!.extentTags),
    file_name_suffix: cdktf.stringToTerraform(struct!.fileNameSuffix),
    flush_immediately: cdktf.booleanToTerraform(struct!.flushImmediately),
    flush_period_sec: cdktf.numberToTerraform(struct!.flushPeriodSec),
    format: cdktf.stringToTerraform(struct!.format),
    id: cdktf.stringToTerraform(struct!.id),
    ingest_if_not_exists: cdktf.listMapper(destinationOutputAzureDataExplorerIngestIfNotExistsToTerraform, false)(struct!.ingestIfNotExists),
    ingest_mode: cdktf.stringToTerraform(struct!.ingestMode),
    ingest_url: cdktf.stringToTerraform(struct!.ingestUrl),
    is_mapping_obj: cdktf.booleanToTerraform(struct!.isMappingObj),
    keep_alive: cdktf.booleanToTerraform(struct!.keepAlive),
    mapping_ref: cdktf.stringToTerraform(struct!.mappingRef),
    max_concurrent_file_parts: cdktf.numberToTerraform(struct!.maxConcurrentFileParts),
    max_file_idle_time_sec: cdktf.numberToTerraform(struct!.maxFileIdleTimeSec),
    max_file_open_time_sec: cdktf.numberToTerraform(struct!.maxFileOpenTimeSec),
    max_file_size_mb: cdktf.numberToTerraform(struct!.maxFileSizeMb),
    max_open_files: cdktf.numberToTerraform(struct!.maxOpenFiles),
    max_payload_events: cdktf.numberToTerraform(struct!.maxPayloadEvents),
    max_payload_size_kb: cdktf.numberToTerraform(struct!.maxPayloadSizeKb),
    oauth_endpoint: cdktf.stringToTerraform(struct!.oauthEndpoint),
    oauth_type: cdktf.stringToTerraform(struct!.oauthType),
    on_backpressure: cdktf.stringToTerraform(struct!.onBackpressure),
    on_disk_full_backpressure: cdktf.stringToTerraform(struct!.onDiskFullBackpressure),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    pq_compress: cdktf.stringToTerraform(struct!.pqCompress),
    pq_controls: destinationOutputAzureDataExplorerPqControlsToTerraform(struct!.pqControls),
    pq_max_file_size: cdktf.stringToTerraform(struct!.pqMaxFileSize),
    pq_max_size: cdktf.stringToTerraform(struct!.pqMaxSize),
    pq_mode: cdktf.stringToTerraform(struct!.pqMode),
    pq_on_backpressure: cdktf.stringToTerraform(struct!.pqOnBackpressure),
    pq_path: cdktf.stringToTerraform(struct!.pqPath),
    reject_unauthorized: cdktf.booleanToTerraform(struct!.rejectUnauthorized),
    remove_empty_dirs: cdktf.booleanToTerraform(struct!.removeEmptyDirs),
    report_level: cdktf.stringToTerraform(struct!.reportLevel),
    report_method: cdktf.stringToTerraform(struct!.reportMethod),
    response_honor_retry_after_header: cdktf.booleanToTerraform(struct!.responseHonorRetryAfterHeader),
    response_retry_settings: cdktf.listMapper(destinationOutputAzureDataExplorerResponseRetrySettingsToTerraform, false)(struct!.responseRetrySettings),
    retain_blob_on_success: cdktf.booleanToTerraform(struct!.retainBlobOnSuccess),
    scope: cdktf.stringToTerraform(struct!.scope),
    stage_path: cdktf.stringToTerraform(struct!.stagePath),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    system_fields: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.systemFields),
    table: cdktf.stringToTerraform(struct!.table),
    tenant_id: cdktf.stringToTerraform(struct!.tenantId),
    text_secret: cdktf.stringToTerraform(struct!.textSecret),
    timeout_retry_settings: destinationOutputAzureDataExplorerTimeoutRetrySettingsToTerraform(struct!.timeoutRetrySettings),
    timeout_sec: cdktf.numberToTerraform(struct!.timeoutSec),
    type: cdktf.stringToTerraform(struct!.type),
    use_round_robin_dns: cdktf.booleanToTerraform(struct!.useRoundRobinDns),
    validate_database_settings: cdktf.booleanToTerraform(struct!.validateDatabaseSettings),
  }
}


export function destinationOutputAzureDataExplorerToHclTerraform(struct?: DestinationOutputAzureDataExplorer | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    add_id_to_stage_path: {
      value: cdktf.booleanToHclTerraform(struct!.addIdToStagePath),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    additional_properties: {
      value: cdktf.listMapperHcl(destinationOutputAzureDataExplorerAdditionalPropertiesToHclTerraform, false)(struct!.additionalProperties),
      isBlock: true,
      type: "list",
      storageClassType: "DestinationOutputAzureDataExplorerAdditionalPropertiesList",
    },
    certificate: {
      value: destinationOutputAzureDataExplorerCertificateToHclTerraform(struct!.certificate),
      isBlock: true,
      type: "struct",
      storageClassType: "DestinationOutputAzureDataExplorerCertificate",
    },
    client_id: {
      value: cdktf.stringToHclTerraform(struct!.clientId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    client_secret: {
      value: cdktf.stringToHclTerraform(struct!.clientSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    cluster_url: {
      value: cdktf.stringToHclTerraform(struct!.clusterUrl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    compress: {
      value: cdktf.stringToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    concurrency: {
      value: cdktf.numberToHclTerraform(struct!.concurrency),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    database: {
      value: cdktf.stringToHclTerraform(struct!.database),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    deadletter_enabled: {
      value: cdktf.booleanToHclTerraform(struct!.deadletterEnabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    extent_tags: {
      value: cdktf.listMapperHcl(destinationOutputAzureDataExplorerExtentTagsToHclTerraform, false)(struct!.extentTags),
      isBlock: true,
      type: "list",
      storageClassType: "DestinationOutputAzureDataExplorerExtentTagsList",
    },
    file_name_suffix: {
      value: cdktf.stringToHclTerraform(struct!.fileNameSuffix),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    flush_immediately: {
      value: cdktf.booleanToHclTerraform(struct!.flushImmediately),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    flush_period_sec: {
      value: cdktf.numberToHclTerraform(struct!.flushPeriodSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    format: {
      value: cdktf.stringToHclTerraform(struct!.format),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ingest_if_not_exists: {
      value: cdktf.listMapperHcl(destinationOutputAzureDataExplorerIngestIfNotExistsToHclTerraform, false)(struct!.ingestIfNotExists),
      isBlock: true,
      type: "list",
      storageClassType: "DestinationOutputAzureDataExplorerIngestIfNotExistsList",
    },
    ingest_mode: {
      value: cdktf.stringToHclTerraform(struct!.ingestMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ingest_url: {
      value: cdktf.stringToHclTerraform(struct!.ingestUrl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    is_mapping_obj: {
      value: cdktf.booleanToHclTerraform(struct!.isMappingObj),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    keep_alive: {
      value: cdktf.booleanToHclTerraform(struct!.keepAlive),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    mapping_ref: {
      value: cdktf.stringToHclTerraform(struct!.mappingRef),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_concurrent_file_parts: {
      value: cdktf.numberToHclTerraform(struct!.maxConcurrentFileParts),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_file_idle_time_sec: {
      value: cdktf.numberToHclTerraform(struct!.maxFileIdleTimeSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_file_open_time_sec: {
      value: cdktf.numberToHclTerraform(struct!.maxFileOpenTimeSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_file_size_mb: {
      value: cdktf.numberToHclTerraform(struct!.maxFileSizeMb),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_open_files: {
      value: cdktf.numberToHclTerraform(struct!.maxOpenFiles),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_payload_events: {
      value: cdktf.numberToHclTerraform(struct!.maxPayloadEvents),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_payload_size_kb: {
      value: cdktf.numberToHclTerraform(struct!.maxPayloadSizeKb),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    oauth_endpoint: {
      value: cdktf.stringToHclTerraform(struct!.oauthEndpoint),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    oauth_type: {
      value: cdktf.stringToHclTerraform(struct!.oauthType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.onBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    on_disk_full_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.onDiskFullBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_compress: {
      value: cdktf.stringToHclTerraform(struct!.pqCompress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_controls: {
      value: destinationOutputAzureDataExplorerPqControlsToHclTerraform(struct!.pqControls),
      isBlock: true,
      type: "struct",
      storageClassType: "DestinationOutputAzureDataExplorerPqControls",
    },
    pq_max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_max_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_mode: {
      value: cdktf.stringToHclTerraform(struct!.pqMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.pqOnBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_path: {
      value: cdktf.stringToHclTerraform(struct!.pqPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reject_unauthorized: {
      value: cdktf.booleanToHclTerraform(struct!.rejectUnauthorized),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    remove_empty_dirs: {
      value: cdktf.booleanToHclTerraform(struct!.removeEmptyDirs),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    report_level: {
      value: cdktf.stringToHclTerraform(struct!.reportLevel),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    report_method: {
      value: cdktf.stringToHclTerraform(struct!.reportMethod),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    response_honor_retry_after_header: {
      value: cdktf.booleanToHclTerraform(struct!.responseHonorRetryAfterHeader),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    response_retry_settings: {
      value: cdktf.listMapperHcl(destinationOutputAzureDataExplorerResponseRetrySettingsToHclTerraform, false)(struct!.responseRetrySettings),
      isBlock: true,
      type: "list",
      storageClassType: "DestinationOutputAzureDataExplorerResponseRetrySettingsList",
    },
    retain_blob_on_success: {
      value: cdktf.booleanToHclTerraform(struct!.retainBlobOnSuccess),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    scope: {
      value: cdktf.stringToHclTerraform(struct!.scope),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    stage_path: {
      value: cdktf.stringToHclTerraform(struct!.stagePath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    system_fields: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.systemFields),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    table: {
      value: cdktf.stringToHclTerraform(struct!.table),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tenant_id: {
      value: cdktf.stringToHclTerraform(struct!.tenantId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    text_secret: {
      value: cdktf.stringToHclTerraform(struct!.textSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    timeout_retry_settings: {
      value: destinationOutputAzureDataExplorerTimeoutRetrySettingsToHclTerraform(struct!.timeoutRetrySettings),
      isBlock: true,
      type: "struct",
      storageClassType: "DestinationOutputAzureDataExplorerTimeoutRetrySettings",
    },
    timeout_sec: {
      value: cdktf.numberToHclTerraform(struct!.timeoutSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    use_round_robin_dns: {
      value: cdktf.booleanToHclTerraform(struct!.useRoundRobinDns),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    validate_database_settings: {
      value: cdktf.booleanToHclTerraform(struct!.validateDatabaseSettings),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputAzureDataExplorerOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DestinationOutputAzureDataExplorer | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._addIdToStagePath !== undefined) {
      hasAnyValues = true;
      internalValueResult.addIdToStagePath = this._addIdToStagePath;
    }
    if (this._additionalProperties?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.additionalProperties = this._additionalProperties?.internalValue;
    }
    if (this._certificate?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.certificate = this._certificate?.internalValue;
    }
    if (this._clientId !== undefined) {
      hasAnyValues = true;
      internalValueResult.clientId = this._clientId;
    }
    if (this._clientSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.clientSecret = this._clientSecret;
    }
    if (this._clusterUrl !== undefined) {
      hasAnyValues = true;
      internalValueResult.clusterUrl = this._clusterUrl;
    }
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._concurrency !== undefined) {
      hasAnyValues = true;
      internalValueResult.concurrency = this._concurrency;
    }
    if (this._database !== undefined) {
      hasAnyValues = true;
      internalValueResult.database = this._database;
    }
    if (this._deadletterEnabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.deadletterEnabled = this._deadletterEnabled;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._extentTags?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.extentTags = this._extentTags?.internalValue;
    }
    if (this._fileNameSuffix !== undefined) {
      hasAnyValues = true;
      internalValueResult.fileNameSuffix = this._fileNameSuffix;
    }
    if (this._flushImmediately !== undefined) {
      hasAnyValues = true;
      internalValueResult.flushImmediately = this._flushImmediately;
    }
    if (this._flushPeriodSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.flushPeriodSec = this._flushPeriodSec;
    }
    if (this._format !== undefined) {
      hasAnyValues = true;
      internalValueResult.format = this._format;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._ingestIfNotExists?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.ingestIfNotExists = this._ingestIfNotExists?.internalValue;
    }
    if (this._ingestMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.ingestMode = this._ingestMode;
    }
    if (this._ingestUrl !== undefined) {
      hasAnyValues = true;
      internalValueResult.ingestUrl = this._ingestUrl;
    }
    if (this._isMappingObj !== undefined) {
      hasAnyValues = true;
      internalValueResult.isMappingObj = this._isMappingObj;
    }
    if (this._keepAlive !== undefined) {
      hasAnyValues = true;
      internalValueResult.keepAlive = this._keepAlive;
    }
    if (this._mappingRef !== undefined) {
      hasAnyValues = true;
      internalValueResult.mappingRef = this._mappingRef;
    }
    if (this._maxConcurrentFileParts !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxConcurrentFileParts = this._maxConcurrentFileParts;
    }
    if (this._maxFileIdleTimeSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxFileIdleTimeSec = this._maxFileIdleTimeSec;
    }
    if (this._maxFileOpenTimeSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxFileOpenTimeSec = this._maxFileOpenTimeSec;
    }
    if (this._maxFileSizeMb !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxFileSizeMb = this._maxFileSizeMb;
    }
    if (this._maxOpenFiles !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxOpenFiles = this._maxOpenFiles;
    }
    if (this._maxPayloadEvents !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxPayloadEvents = this._maxPayloadEvents;
    }
    if (this._maxPayloadSizeKb !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxPayloadSizeKb = this._maxPayloadSizeKb;
    }
    if (this._oauthEndpoint !== undefined) {
      hasAnyValues = true;
      internalValueResult.oauthEndpoint = this._oauthEndpoint;
    }
    if (this._oauthType !== undefined) {
      hasAnyValues = true;
      internalValueResult.oauthType = this._oauthType;
    }
    if (this._onBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.onBackpressure = this._onBackpressure;
    }
    if (this._onDiskFullBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.onDiskFullBackpressure = this._onDiskFullBackpressure;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._pqCompress !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqCompress = this._pqCompress;
    }
    if (this._pqControls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqControls = this._pqControls?.internalValue;
    }
    if (this._pqMaxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxFileSize = this._pqMaxFileSize;
    }
    if (this._pqMaxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxSize = this._pqMaxSize;
    }
    if (this._pqMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMode = this._pqMode;
    }
    if (this._pqOnBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqOnBackpressure = this._pqOnBackpressure;
    }
    if (this._pqPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqPath = this._pqPath;
    }
    if (this._rejectUnauthorized !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectUnauthorized = this._rejectUnauthorized;
    }
    if (this._removeEmptyDirs !== undefined) {
      hasAnyValues = true;
      internalValueResult.removeEmptyDirs = this._removeEmptyDirs;
    }
    if (this._reportLevel !== undefined) {
      hasAnyValues = true;
      internalValueResult.reportLevel = this._reportLevel;
    }
    if (this._reportMethod !== undefined) {
      hasAnyValues = true;
      internalValueResult.reportMethod = this._reportMethod;
    }
    if (this._responseHonorRetryAfterHeader !== undefined) {
      hasAnyValues = true;
      internalValueResult.responseHonorRetryAfterHeader = this._responseHonorRetryAfterHeader;
    }
    if (this._responseRetrySettings?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.responseRetrySettings = this._responseRetrySettings?.internalValue;
    }
    if (this._retainBlobOnSuccess !== undefined) {
      hasAnyValues = true;
      internalValueResult.retainBlobOnSuccess = this._retainBlobOnSuccess;
    }
    if (this._scope !== undefined) {
      hasAnyValues = true;
      internalValueResult.scope = this._scope;
    }
    if (this._stagePath !== undefined) {
      hasAnyValues = true;
      internalValueResult.stagePath = this._stagePath;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._systemFields !== undefined) {
      hasAnyValues = true;
      internalValueResult.systemFields = this._systemFields;
    }
    if (this._table !== undefined) {
      hasAnyValues = true;
      internalValueResult.table = this._table;
    }
    if (this._tenantId !== undefined) {
      hasAnyValues = true;
      internalValueResult.tenantId = this._tenantId;
    }
    if (this._textSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.textSecret = this._textSecret;
    }
    if (this._timeoutRetrySettings?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutRetrySettings = this._timeoutRetrySettings?.internalValue;
    }
    if (this._timeoutSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutSec = this._timeoutSec;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._useRoundRobinDns !== undefined) {
      hasAnyValues = true;
      internalValueResult.useRoundRobinDns = this._useRoundRobinDns;
    }
    if (this._validateDatabaseSettings !== undefined) {
      hasAnyValues = true;
      internalValueResult.validateDatabaseSettings = this._validateDatabaseSettings;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputAzureDataExplorer | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._addIdToStagePath = undefined;
      this._additionalProperties.internalValue = undefined;
      this._certificate.internalValue = undefined;
      this._clientId = undefined;
      this._clientSecret = undefined;
      this._clusterUrl = undefined;
      this._compress = undefined;
      this._concurrency = undefined;
      this._database = undefined;
      this._deadletterEnabled = undefined;
      this._description = undefined;
      this._environment = undefined;
      this._extentTags.internalValue = undefined;
      this._fileNameSuffix = undefined;
      this._flushImmediately = undefined;
      this._flushPeriodSec = undefined;
      this._format = undefined;
      this._id = undefined;
      this._ingestIfNotExists.internalValue = undefined;
      this._ingestMode = undefined;
      this._ingestUrl = undefined;
      this._isMappingObj = undefined;
      this._keepAlive = undefined;
      this._mappingRef = undefined;
      this._maxConcurrentFileParts = undefined;
      this._maxFileIdleTimeSec = undefined;
      this._maxFileOpenTimeSec = undefined;
      this._maxFileSizeMb = undefined;
      this._maxOpenFiles = undefined;
      this._maxPayloadEvents = undefined;
      this._maxPayloadSizeKb = undefined;
      this._oauthEndpoint = undefined;
      this._oauthType = undefined;
      this._onBackpressure = undefined;
      this._onDiskFullBackpressure = undefined;
      this._pipeline = undefined;
      this._pqCompress = undefined;
      this._pqControls.internalValue = undefined;
      this._pqMaxFileSize = undefined;
      this._pqMaxSize = undefined;
      this._pqMode = undefined;
      this._pqOnBackpressure = undefined;
      this._pqPath = undefined;
      this._rejectUnauthorized = undefined;
      this._removeEmptyDirs = undefined;
      this._reportLevel = undefined;
      this._reportMethod = undefined;
      this._responseHonorRetryAfterHeader = undefined;
      this._responseRetrySettings.internalValue = undefined;
      this._retainBlobOnSuccess = undefined;
      this._scope = undefined;
      this._stagePath = undefined;
      this._streamtags = undefined;
      this._systemFields = undefined;
      this._table = undefined;
      this._tenantId = undefined;
      this._textSecret = undefined;
      this._timeoutRetrySettings.internalValue = undefined;
      this._timeoutSec = undefined;
      this._type = undefined;
      this._useRoundRobinDns = undefined;
      this._validateDatabaseSettings = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._addIdToStagePath = value.addIdToStagePath;
      this._additionalProperties.internalValue = value.additionalProperties;
      this._certificate.internalValue = value.certificate;
      this._clientId = value.clientId;
      this._clientSecret = value.clientSecret;
      this._clusterUrl = value.clusterUrl;
      this._compress = value.compress;
      this._concurrency = value.concurrency;
      this._database = value.database;
      this._deadletterEnabled = value.deadletterEnabled;
      this._description = value.description;
      this._environment = value.environment;
      this._extentTags.internalValue = value.extentTags;
      this._fileNameSuffix = value.fileNameSuffix;
      this._flushImmediately = value.flushImmediately;
      this._flushPeriodSec = value.flushPeriodSec;
      this._format = value.format;
      this._id = value.id;
      this._ingestIfNotExists.internalValue = value.ingestIfNotExists;
      this._ingestMode = value.ingestMode;
      this._ingestUrl = value.ingestUrl;
      this._isMappingObj = value.isMappingObj;
      this._keepAlive = value.keepAlive;
      this._mappingRef = value.mappingRef;
      this._maxConcurrentFileParts = value.maxConcurrentFileParts;
      this._maxFileIdleTimeSec = value.maxFileIdleTimeSec;
      this._maxFileOpenTimeSec = value.maxFileOpenTimeSec;
      this._maxFileSizeMb = value.maxFileSizeMb;
      this._maxOpenFiles = value.maxOpenFiles;
      this._maxPayloadEvents = value.maxPayloadEvents;
      this._maxPayloadSizeKb = value.maxPayloadSizeKb;
      this._oauthEndpoint = value.oauthEndpoint;
      this._oauthType = value.oauthType;
      this._onBackpressure = value.onBackpressure;
      this._onDiskFullBackpressure = value.onDiskFullBackpressure;
      this._pipeline = value.pipeline;
      this._pqCompress = value.pqCompress;
      this._pqControls.internalValue = value.pqControls;
      this._pqMaxFileSize = value.pqMaxFileSize;
      this._pqMaxSize = value.pqMaxSize;
      this._pqMode = value.pqMode;
      this._pqOnBackpressure = value.pqOnBackpressure;
      this._pqPath = value.pqPath;
      this._rejectUnauthorized = value.rejectUnauthorized;
      this._removeEmptyDirs = value.removeEmptyDirs;
      this._reportLevel = value.reportLevel;
      this._reportMethod = value.reportMethod;
      this._responseHonorRetryAfterHeader = value.responseHonorRetryAfterHeader;
      this._responseRetrySettings.internalValue = value.responseRetrySettings;
      this._retainBlobOnSuccess = value.retainBlobOnSuccess;
      this._scope = value.scope;
      this._stagePath = value.stagePath;
      this._streamtags = value.streamtags;
      this._systemFields = value.systemFields;
      this._table = value.table;
      this._tenantId = value.tenantId;
      this._textSecret = value.textSecret;
      this._timeoutRetrySettings.internalValue = value.timeoutRetrySettings;
      this._timeoutSec = value.timeoutSec;
      this._type = value.type;
      this._useRoundRobinDns = value.useRoundRobinDns;
      this._validateDatabaseSettings = value.validateDatabaseSettings;
    }
  }

  // add_id_to_stage_path - computed: true, optional: true, required: false
  private _addIdToStagePath?: boolean | cdktf.IResolvable; 
  public get addIdToStagePath() {
    return this.getBooleanAttribute('add_id_to_stage_path');
  }
  public set addIdToStagePath(value: boolean | cdktf.IResolvable) {
    this._addIdToStagePath = value;
  }
  public resetAddIdToStagePath() {
    this._addIdToStagePath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addIdToStagePathInput() {
    return this._addIdToStagePath;
  }

  // additional_properties - computed: false, optional: true, required: false
  private _additionalProperties = new DestinationOutputAzureDataExplorerAdditionalPropertiesList(this, "additional_properties", false);
  public get additionalProperties() {
    return this._additionalProperties;
  }
  public putAdditionalProperties(value: DestinationOutputAzureDataExplorerAdditionalProperties[] | cdktf.IResolvable) {
    this._additionalProperties.internalValue = value;
  }
  public resetAdditionalProperties() {
    this._additionalProperties.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get additionalPropertiesInput() {
    return this._additionalProperties.internalValue;
  }

  // certificate - computed: false, optional: true, required: false
  private _certificate = new DestinationOutputAzureDataExplorerCertificateOutputReference(this, "certificate");
  public get certificate() {
    return this._certificate;
  }
  public putCertificate(value: DestinationOutputAzureDataExplorerCertificate) {
    this._certificate.internalValue = value;
  }
  public resetCertificate() {
    this._certificate.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certificateInput() {
    return this._certificate.internalValue;
  }

  // client_id - computed: false, optional: false, required: true
  private _clientId?: string; 
  public get clientId() {
    return this.getStringAttribute('client_id');
  }
  public set clientId(value: string) {
    this._clientId = value;
  }
  // Temporarily expose input value. Use with caution.
  public get clientIdInput() {
    return this._clientId;
  }

  // client_secret - computed: false, optional: true, required: false
  private _clientSecret?: string; 
  public get clientSecret() {
    return this.getStringAttribute('client_secret');
  }
  public set clientSecret(value: string) {
    this._clientSecret = value;
  }
  public resetClientSecret() {
    this._clientSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clientSecretInput() {
    return this._clientSecret;
  }

  // cluster_url - computed: false, optional: false, required: true
  private _clusterUrl?: string; 
  public get clusterUrl() {
    return this.getStringAttribute('cluster_url');
  }
  public set clusterUrl(value: string) {
    this._clusterUrl = value;
  }
  // Temporarily expose input value. Use with caution.
  public get clusterUrlInput() {
    return this._clusterUrl;
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: string; 
  public get compress() {
    return this.getStringAttribute('compress');
  }
  public set compress(value: string) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // concurrency - computed: true, optional: true, required: false
  private _concurrency?: number; 
  public get concurrency() {
    return this.getNumberAttribute('concurrency');
  }
  public set concurrency(value: number) {
    this._concurrency = value;
  }
  public resetConcurrency() {
    this._concurrency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get concurrencyInput() {
    return this._concurrency;
  }

  // database - computed: false, optional: false, required: true
  private _database?: string; 
  public get database() {
    return this.getStringAttribute('database');
  }
  public set database(value: string) {
    this._database = value;
  }
  // Temporarily expose input value. Use with caution.
  public get databaseInput() {
    return this._database;
  }

  // deadletter_enabled - computed: true, optional: true, required: false
  private _deadletterEnabled?: boolean | cdktf.IResolvable; 
  public get deadletterEnabled() {
    return this.getBooleanAttribute('deadletter_enabled');
  }
  public set deadletterEnabled(value: boolean | cdktf.IResolvable) {
    this._deadletterEnabled = value;
  }
  public resetDeadletterEnabled() {
    this._deadletterEnabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get deadletterEnabledInput() {
    return this._deadletterEnabled;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // extent_tags - computed: false, optional: true, required: false
  private _extentTags = new DestinationOutputAzureDataExplorerExtentTagsList(this, "extent_tags", false);
  public get extentTags() {
    return this._extentTags;
  }
  public putExtentTags(value: DestinationOutputAzureDataExplorerExtentTags[] | cdktf.IResolvable) {
    this._extentTags.internalValue = value;
  }
  public resetExtentTags() {
    this._extentTags.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get extentTagsInput() {
    return this._extentTags.internalValue;
  }

  // file_name_suffix - computed: true, optional: true, required: false
  private _fileNameSuffix?: string; 
  public get fileNameSuffix() {
    return this.getStringAttribute('file_name_suffix');
  }
  public set fileNameSuffix(value: string) {
    this._fileNameSuffix = value;
  }
  public resetFileNameSuffix() {
    this._fileNameSuffix = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fileNameSuffixInput() {
    return this._fileNameSuffix;
  }

  // flush_immediately - computed: true, optional: true, required: false
  private _flushImmediately?: boolean | cdktf.IResolvable; 
  public get flushImmediately() {
    return this.getBooleanAttribute('flush_immediately');
  }
  public set flushImmediately(value: boolean | cdktf.IResolvable) {
    this._flushImmediately = value;
  }
  public resetFlushImmediately() {
    this._flushImmediately = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get flushImmediatelyInput() {
    return this._flushImmediately;
  }

  // flush_period_sec - computed: true, optional: true, required: false
  private _flushPeriodSec?: number; 
  public get flushPeriodSec() {
    return this.getNumberAttribute('flush_period_sec');
  }
  public set flushPeriodSec(value: number) {
    this._flushPeriodSec = value;
  }
  public resetFlushPeriodSec() {
    this._flushPeriodSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get flushPeriodSecInput() {
    return this._flushPeriodSec;
  }

  // format - computed: true, optional: true, required: false
  private _format?: string; 
  public get format() {
    return this.getStringAttribute('format');
  }
  public set format(value: string) {
    this._format = value;
  }
  public resetFormat() {
    this._format = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get formatInput() {
    return this._format;
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // ingest_if_not_exists - computed: false, optional: true, required: false
  private _ingestIfNotExists = new DestinationOutputAzureDataExplorerIngestIfNotExistsList(this, "ingest_if_not_exists", false);
  public get ingestIfNotExists() {
    return this._ingestIfNotExists;
  }
  public putIngestIfNotExists(value: DestinationOutputAzureDataExplorerIngestIfNotExists[] | cdktf.IResolvable) {
    this._ingestIfNotExists.internalValue = value;
  }
  public resetIngestIfNotExists() {
    this._ingestIfNotExists.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ingestIfNotExistsInput() {
    return this._ingestIfNotExists.internalValue;
  }

  // ingest_mode - computed: true, optional: true, required: false
  private _ingestMode?: string; 
  public get ingestMode() {
    return this.getStringAttribute('ingest_mode');
  }
  public set ingestMode(value: string) {
    this._ingestMode = value;
  }
  public resetIngestMode() {
    this._ingestMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ingestModeInput() {
    return this._ingestMode;
  }

  // ingest_url - computed: false, optional: true, required: false
  private _ingestUrl?: string; 
  public get ingestUrl() {
    return this.getStringAttribute('ingest_url');
  }
  public set ingestUrl(value: string) {
    this._ingestUrl = value;
  }
  public resetIngestUrl() {
    this._ingestUrl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ingestUrlInput() {
    return this._ingestUrl;
  }

  // is_mapping_obj - computed: true, optional: true, required: false
  private _isMappingObj?: boolean | cdktf.IResolvable; 
  public get isMappingObj() {
    return this.getBooleanAttribute('is_mapping_obj');
  }
  public set isMappingObj(value: boolean | cdktf.IResolvable) {
    this._isMappingObj = value;
  }
  public resetIsMappingObj() {
    this._isMappingObj = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get isMappingObjInput() {
    return this._isMappingObj;
  }

  // keep_alive - computed: true, optional: true, required: false
  private _keepAlive?: boolean | cdktf.IResolvable; 
  public get keepAlive() {
    return this.getBooleanAttribute('keep_alive');
  }
  public set keepAlive(value: boolean | cdktf.IResolvable) {
    this._keepAlive = value;
  }
  public resetKeepAlive() {
    this._keepAlive = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keepAliveInput() {
    return this._keepAlive;
  }

  // mapping_ref - computed: false, optional: true, required: false
  private _mappingRef?: string; 
  public get mappingRef() {
    return this.getStringAttribute('mapping_ref');
  }
  public set mappingRef(value: string) {
    this._mappingRef = value;
  }
  public resetMappingRef() {
    this._mappingRef = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get mappingRefInput() {
    return this._mappingRef;
  }

  // max_concurrent_file_parts - computed: true, optional: true, required: false
  private _maxConcurrentFileParts?: number; 
  public get maxConcurrentFileParts() {
    return this.getNumberAttribute('max_concurrent_file_parts');
  }
  public set maxConcurrentFileParts(value: number) {
    this._maxConcurrentFileParts = value;
  }
  public resetMaxConcurrentFileParts() {
    this._maxConcurrentFileParts = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxConcurrentFilePartsInput() {
    return this._maxConcurrentFileParts;
  }

  // max_file_idle_time_sec - computed: true, optional: true, required: false
  private _maxFileIdleTimeSec?: number; 
  public get maxFileIdleTimeSec() {
    return this.getNumberAttribute('max_file_idle_time_sec');
  }
  public set maxFileIdleTimeSec(value: number) {
    this._maxFileIdleTimeSec = value;
  }
  public resetMaxFileIdleTimeSec() {
    this._maxFileIdleTimeSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxFileIdleTimeSecInput() {
    return this._maxFileIdleTimeSec;
  }

  // max_file_open_time_sec - computed: true, optional: true, required: false
  private _maxFileOpenTimeSec?: number; 
  public get maxFileOpenTimeSec() {
    return this.getNumberAttribute('max_file_open_time_sec');
  }
  public set maxFileOpenTimeSec(value: number) {
    this._maxFileOpenTimeSec = value;
  }
  public resetMaxFileOpenTimeSec() {
    this._maxFileOpenTimeSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxFileOpenTimeSecInput() {
    return this._maxFileOpenTimeSec;
  }

  // max_file_size_mb - computed: true, optional: true, required: false
  private _maxFileSizeMb?: number; 
  public get maxFileSizeMb() {
    return this.getNumberAttribute('max_file_size_mb');
  }
  public set maxFileSizeMb(value: number) {
    this._maxFileSizeMb = value;
  }
  public resetMaxFileSizeMb() {
    this._maxFileSizeMb = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxFileSizeMbInput() {
    return this._maxFileSizeMb;
  }

  // max_open_files - computed: true, optional: true, required: false
  private _maxOpenFiles?: number; 
  public get maxOpenFiles() {
    return this.getNumberAttribute('max_open_files');
  }
  public set maxOpenFiles(value: number) {
    this._maxOpenFiles = value;
  }
  public resetMaxOpenFiles() {
    this._maxOpenFiles = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxOpenFilesInput() {
    return this._maxOpenFiles;
  }

  // max_payload_events - computed: true, optional: true, required: false
  private _maxPayloadEvents?: number; 
  public get maxPayloadEvents() {
    return this.getNumberAttribute('max_payload_events');
  }
  public set maxPayloadEvents(value: number) {
    this._maxPayloadEvents = value;
  }
  public resetMaxPayloadEvents() {
    this._maxPayloadEvents = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxPayloadEventsInput() {
    return this._maxPayloadEvents;
  }

  // max_payload_size_kb - computed: true, optional: true, required: false
  private _maxPayloadSizeKb?: number; 
  public get maxPayloadSizeKb() {
    return this.getNumberAttribute('max_payload_size_kb');
  }
  public set maxPayloadSizeKb(value: number) {
    this._maxPayloadSizeKb = value;
  }
  public resetMaxPayloadSizeKb() {
    this._maxPayloadSizeKb = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxPayloadSizeKbInput() {
    return this._maxPayloadSizeKb;
  }

  // oauth_endpoint - computed: true, optional: true, required: false
  private _oauthEndpoint?: string; 
  public get oauthEndpoint() {
    return this.getStringAttribute('oauth_endpoint');
  }
  public set oauthEndpoint(value: string) {
    this._oauthEndpoint = value;
  }
  public resetOauthEndpoint() {
    this._oauthEndpoint = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get oauthEndpointInput() {
    return this._oauthEndpoint;
  }

  // oauth_type - computed: true, optional: true, required: false
  private _oauthType?: string; 
  public get oauthType() {
    return this.getStringAttribute('oauth_type');
  }
  public set oauthType(value: string) {
    this._oauthType = value;
  }
  public resetOauthType() {
    this._oauthType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get oauthTypeInput() {
    return this._oauthType;
  }

  // on_backpressure - computed: true, optional: true, required: false
  private _onBackpressure?: string; 
  public get onBackpressure() {
    return this.getStringAttribute('on_backpressure');
  }
  public set onBackpressure(value: string) {
    this._onBackpressure = value;
  }
  public resetOnBackpressure() {
    this._onBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get onBackpressureInput() {
    return this._onBackpressure;
  }

  // on_disk_full_backpressure - computed: true, optional: true, required: false
  private _onDiskFullBackpressure?: string; 
  public get onDiskFullBackpressure() {
    return this.getStringAttribute('on_disk_full_backpressure');
  }
  public set onDiskFullBackpressure(value: string) {
    this._onDiskFullBackpressure = value;
  }
  public resetOnDiskFullBackpressure() {
    this._onDiskFullBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get onDiskFullBackpressureInput() {
    return this._onDiskFullBackpressure;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // pq_compress - computed: true, optional: true, required: false
  private _pqCompress?: string; 
  public get pqCompress() {
    return this.getStringAttribute('pq_compress');
  }
  public set pqCompress(value: string) {
    this._pqCompress = value;
  }
  public resetPqCompress() {
    this._pqCompress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqCompressInput() {
    return this._pqCompress;
  }

  // pq_controls - computed: false, optional: true, required: false
  private _pqControls = new DestinationOutputAzureDataExplorerPqControlsOutputReference(this, "pq_controls");
  public get pqControls() {
    return this._pqControls;
  }
  public putPqControls(value: DestinationOutputAzureDataExplorerPqControls) {
    this._pqControls.internalValue = value;
  }
  public resetPqControls() {
    this._pqControls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqControlsInput() {
    return this._pqControls.internalValue;
  }

  // pq_max_file_size - computed: true, optional: true, required: false
  private _pqMaxFileSize?: string; 
  public get pqMaxFileSize() {
    return this.getStringAttribute('pq_max_file_size');
  }
  public set pqMaxFileSize(value: string) {
    this._pqMaxFileSize = value;
  }
  public resetPqMaxFileSize() {
    this._pqMaxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxFileSizeInput() {
    return this._pqMaxFileSize;
  }

  // pq_max_size - computed: true, optional: true, required: false
  private _pqMaxSize?: string; 
  public get pqMaxSize() {
    return this.getStringAttribute('pq_max_size');
  }
  public set pqMaxSize(value: string) {
    this._pqMaxSize = value;
  }
  public resetPqMaxSize() {
    this._pqMaxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxSizeInput() {
    return this._pqMaxSize;
  }

  // pq_mode - computed: true, optional: true, required: false
  private _pqMode?: string; 
  public get pqMode() {
    return this.getStringAttribute('pq_mode');
  }
  public set pqMode(value: string) {
    this._pqMode = value;
  }
  public resetPqMode() {
    this._pqMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqModeInput() {
    return this._pqMode;
  }

  // pq_on_backpressure - computed: true, optional: true, required: false
  private _pqOnBackpressure?: string; 
  public get pqOnBackpressure() {
    return this.getStringAttribute('pq_on_backpressure');
  }
  public set pqOnBackpressure(value: string) {
    this._pqOnBackpressure = value;
  }
  public resetPqOnBackpressure() {
    this._pqOnBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqOnBackpressureInput() {
    return this._pqOnBackpressure;
  }

  // pq_path - computed: true, optional: true, required: false
  private _pqPath?: string; 
  public get pqPath() {
    return this.getStringAttribute('pq_path');
  }
  public set pqPath(value: string) {
    this._pqPath = value;
  }
  public resetPqPath() {
    this._pqPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqPathInput() {
    return this._pqPath;
  }

  // reject_unauthorized - computed: true, optional: true, required: false
  private _rejectUnauthorized?: boolean | cdktf.IResolvable; 
  public get rejectUnauthorized() {
    return this.getBooleanAttribute('reject_unauthorized');
  }
  public set rejectUnauthorized(value: boolean | cdktf.IResolvable) {
    this._rejectUnauthorized = value;
  }
  public resetRejectUnauthorized() {
    this._rejectUnauthorized = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectUnauthorizedInput() {
    return this._rejectUnauthorized;
  }

  // remove_empty_dirs - computed: true, optional: true, required: false
  private _removeEmptyDirs?: boolean | cdktf.IResolvable; 
  public get removeEmptyDirs() {
    return this.getBooleanAttribute('remove_empty_dirs');
  }
  public set removeEmptyDirs(value: boolean | cdktf.IResolvable) {
    this._removeEmptyDirs = value;
  }
  public resetRemoveEmptyDirs() {
    this._removeEmptyDirs = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get removeEmptyDirsInput() {
    return this._removeEmptyDirs;
  }

  // report_level - computed: true, optional: true, required: false
  private _reportLevel?: string; 
  public get reportLevel() {
    return this.getStringAttribute('report_level');
  }
  public set reportLevel(value: string) {
    this._reportLevel = value;
  }
  public resetReportLevel() {
    this._reportLevel = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get reportLevelInput() {
    return this._reportLevel;
  }

  // report_method - computed: true, optional: true, required: false
  private _reportMethod?: string; 
  public get reportMethod() {
    return this.getStringAttribute('report_method');
  }
  public set reportMethod(value: string) {
    this._reportMethod = value;
  }
  public resetReportMethod() {
    this._reportMethod = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get reportMethodInput() {
    return this._reportMethod;
  }

  // response_honor_retry_after_header - computed: true, optional: true, required: false
  private _responseHonorRetryAfterHeader?: boolean | cdktf.IResolvable; 
  public get responseHonorRetryAfterHeader() {
    return this.getBooleanAttribute('response_honor_retry_after_header');
  }
  public set responseHonorRetryAfterHeader(value: boolean | cdktf.IResolvable) {
    this._responseHonorRetryAfterHeader = value;
  }
  public resetResponseHonorRetryAfterHeader() {
    this._responseHonorRetryAfterHeader = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get responseHonorRetryAfterHeaderInput() {
    return this._responseHonorRetryAfterHeader;
  }

  // response_retry_settings - computed: false, optional: true, required: false
  private _responseRetrySettings = new DestinationOutputAzureDataExplorerResponseRetrySettingsList(this, "response_retry_settings", false);
  public get responseRetrySettings() {
    return this._responseRetrySettings;
  }
  public putResponseRetrySettings(value: DestinationOutputAzureDataExplorerResponseRetrySettings[] | cdktf.IResolvable) {
    this._responseRetrySettings.internalValue = value;
  }
  public resetResponseRetrySettings() {
    this._responseRetrySettings.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get responseRetrySettingsInput() {
    return this._responseRetrySettings.internalValue;
  }

  // retain_blob_on_success - computed: true, optional: true, required: false
  private _retainBlobOnSuccess?: boolean | cdktf.IResolvable; 
  public get retainBlobOnSuccess() {
    return this.getBooleanAttribute('retain_blob_on_success');
  }
  public set retainBlobOnSuccess(value: boolean | cdktf.IResolvable) {
    this._retainBlobOnSuccess = value;
  }
  public resetRetainBlobOnSuccess() {
    this._retainBlobOnSuccess = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get retainBlobOnSuccessInput() {
    return this._retainBlobOnSuccess;
  }

  // scope - computed: false, optional: false, required: true
  private _scope?: string; 
  public get scope() {
    return this.getStringAttribute('scope');
  }
  public set scope(value: string) {
    this._scope = value;
  }
  // Temporarily expose input value. Use with caution.
  public get scopeInput() {
    return this._scope;
  }

  // stage_path - computed: true, optional: true, required: false
  private _stagePath?: string; 
  public get stagePath() {
    return this.getStringAttribute('stage_path');
  }
  public set stagePath(value: string) {
    this._stagePath = value;
  }
  public resetStagePath() {
    this._stagePath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get stagePathInput() {
    return this._stagePath;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // system_fields - computed: true, optional: true, required: false
  private _systemFields?: string[]; 
  public get systemFields() {
    return this.getListAttribute('system_fields');
  }
  public set systemFields(value: string[]) {
    this._systemFields = value;
  }
  public resetSystemFields() {
    this._systemFields = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get systemFieldsInput() {
    return this._systemFields;
  }

  // table - computed: false, optional: false, required: true
  private _table?: string; 
  public get table() {
    return this.getStringAttribute('table');
  }
  public set table(value: string) {
    this._table = value;
  }
  // Temporarily expose input value. Use with caution.
  public get tableInput() {
    return this._table;
  }

  // tenant_id - computed: false, optional: false, required: true
  private _tenantId?: string; 
  public get tenantId() {
    return this.getStringAttribute('tenant_id');
  }
  public set tenantId(value: string) {
    this._tenantId = value;
  }
  // Temporarily expose input value. Use with caution.
  public get tenantIdInput() {
    return this._tenantId;
  }

  // text_secret - computed: false, optional: true, required: false
  private _textSecret?: string; 
  public get textSecret() {
    return this.getStringAttribute('text_secret');
  }
  public set textSecret(value: string) {
    this._textSecret = value;
  }
  public resetTextSecret() {
    this._textSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get textSecretInput() {
    return this._textSecret;
  }

  // timeout_retry_settings - computed: false, optional: true, required: false
  private _timeoutRetrySettings = new DestinationOutputAzureDataExplorerTimeoutRetrySettingsOutputReference(this, "timeout_retry_settings");
  public get timeoutRetrySettings() {
    return this._timeoutRetrySettings;
  }
  public putTimeoutRetrySettings(value: DestinationOutputAzureDataExplorerTimeoutRetrySettings) {
    this._timeoutRetrySettings.internalValue = value;
  }
  public resetTimeoutRetrySettings() {
    this._timeoutRetrySettings.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutRetrySettingsInput() {
    return this._timeoutRetrySettings.internalValue;
  }

  // timeout_sec - computed: true, optional: true, required: false
  private _timeoutSec?: number; 
  public get timeoutSec() {
    return this.getNumberAttribute('timeout_sec');
  }
  public set timeoutSec(value: number) {
    this._timeoutSec = value;
  }
  public resetTimeoutSec() {
    this._timeoutSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutSecInput() {
    return this._timeoutSec;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // use_round_robin_dns - computed: true, optional: true, required: false
  private _useRoundRobinDns?: boolean | cdktf.IResolvable; 
  public get useRoundRobinDns() {
    return this.getBooleanAttribute('use_round_robin_dns');
  }
  public set useRoundRobinDns(value: boolean | cdktf.IResolvable) {
    this._useRoundRobinDns = value;
  }
  public resetUseRoundRobinDns() {
    this._useRoundRobinDns = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get useRoundRobinDnsInput() {
    return this._useRoundRobinDns;
  }

  // validate_database_settings - computed: true, optional: true, required: false
  private _validateDatabaseSettings?: boolean | cdktf.IResolvable; 
  public get validateDatabaseSettings() {
    return this.getBooleanAttribute('validate_database_settings');
  }
  public set validateDatabaseSettings(value: boolean | cdktf.IResolvable) {
    this._validateDatabaseSettings = value;
  }
  public resetValidateDatabaseSettings() {
    this._validateDatabaseSettings = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get validateDatabaseSettingsInput() {
    return this._validateDatabaseSettings;
  }
}
export interface DestinationOutputAzureEventhubPqControls {
}

export function destinationOutputAzureEventhubPqControlsToTerraform(struct?: DestinationOutputAzureEventhubPqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function destinationOutputAzureEventhubPqControlsToHclTerraform(struct?: DestinationOutputAzureEventhubPqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class DestinationOutputAzureEventhubPqControlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DestinationOutputAzureEventhubPqControls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputAzureEventhubPqControls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface DestinationOutputAzureEventhubSasl {
  /**
  * Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#disabled Destination#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * Default: "plain"; must be one of ["plain", "oauthbearer"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#mechanism Destination#mechanism}
  */
  readonly mechanism?: string;
}

export function destinationOutputAzureEventhubSaslToTerraform(struct?: DestinationOutputAzureEventhubSasl | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    mechanism: cdktf.stringToTerraform(struct!.mechanism),
  }
}


export function destinationOutputAzureEventhubSaslToHclTerraform(struct?: DestinationOutputAzureEventhubSasl | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    mechanism: {
      value: cdktf.stringToHclTerraform(struct!.mechanism),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputAzureEventhubSaslOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DestinationOutputAzureEventhubSasl | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._mechanism !== undefined) {
      hasAnyValues = true;
      internalValueResult.mechanism = this._mechanism;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputAzureEventhubSasl | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._disabled = undefined;
      this._mechanism = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._disabled = value.disabled;
      this._mechanism = value.mechanism;
    }
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // mechanism - computed: true, optional: true, required: false
  private _mechanism?: string; 
  public get mechanism() {
    return this.getStringAttribute('mechanism');
  }
  public set mechanism(value: string) {
    this._mechanism = value;
  }
  public resetMechanism() {
    this._mechanism = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get mechanismInput() {
    return this._mechanism;
  }
}
export interface DestinationOutputAzureEventhubTls {
  /**
  * Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#disabled Destination#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * Reject certificates that are not authorized by a CA in the CA certificate path, or by another trusted CA (such as the system's). Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#reject_unauthorized Destination#reject_unauthorized}
  */
  readonly rejectUnauthorized?: boolean | cdktf.IResolvable;
}

export function destinationOutputAzureEventhubTlsToTerraform(struct?: DestinationOutputAzureEventhubTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    reject_unauthorized: cdktf.booleanToTerraform(struct!.rejectUnauthorized),
  }
}


export function destinationOutputAzureEventhubTlsToHclTerraform(struct?: DestinationOutputAzureEventhubTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    reject_unauthorized: {
      value: cdktf.booleanToHclTerraform(struct!.rejectUnauthorized),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputAzureEventhubTlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DestinationOutputAzureEventhubTls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._rejectUnauthorized !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectUnauthorized = this._rejectUnauthorized;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputAzureEventhubTls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._disabled = undefined;
      this._rejectUnauthorized = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._disabled = value.disabled;
      this._rejectUnauthorized = value.rejectUnauthorized;
    }
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // reject_unauthorized - computed: true, optional: true, required: false
  private _rejectUnauthorized?: boolean | cdktf.IResolvable; 
  public get rejectUnauthorized() {
    return this.getBooleanAttribute('reject_unauthorized');
  }
  public set rejectUnauthorized(value: boolean | cdktf.IResolvable) {
    this._rejectUnauthorized = value;
  }
  public resetRejectUnauthorized() {
    this._rejectUnauthorized = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectUnauthorizedInput() {
    return this._rejectUnauthorized;
  }
}
export interface DestinationOutputAzureEventhub {
  /**
  * Control the number of required acknowledgments. Default: 1; must be one of ["1", "0", "-1"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#ack Destination#ack}
  */
  readonly ack?: number;
  /**
  * Maximum time to wait for Kafka to respond to an authentication request. Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#authentication_timeout Destination#authentication_timeout}
  */
  readonly authenticationTimeout?: number;
  /**
  * Set the backoff multiplier (2-20) to control the retry frequency for failed messages. For faster retries, use a lower multiplier. For slower retries with more delay between attempts, use a higher multiplier. The multiplier is used in an exponential backoff formula; see the Kafka [documentation](https://kafka.js.org/docs/retry-detailed) for details. Default: 2
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#backoff_rate Destination#backoff_rate}
  */
  readonly backoffRate?: number;
  /**
  * List of Event Hubs Kafka brokers to connect to, eg. yourdomain.servicebus.windows.net:9093. The hostname can be found in the host portion of the primary or secondary connection string in Shared Access Policies.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#brokers Destination#brokers}
  */
  readonly brokers: string[];
  /**
  * Maximum time to wait for a connection to complete successfully. Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#connection_timeout Destination#connection_timeout}
  */
  readonly connectionTimeout?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#description Destination#description}
  */
  readonly description?: string;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#environment Destination#environment}
  */
  readonly environment?: string;
  /**
  * Maximum number of events in a batch before forcing a flush. Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#flush_event_count Destination#flush_event_count}
  */
  readonly flushEventCount?: number;
  /**
  * Maximum time between requests. Small values could cause the payload size to be smaller than the configured Max record size. Default: 1
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#flush_period_sec Destination#flush_period_sec}
  */
  readonly flushPeriodSec?: number;
  /**
  * Format to use to serialize events before writing to the Event Hubs Kafka brokers. Default: "json"; must be one of ["json", "raw"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#format Destination#format}
  */
  readonly format?: string;
  /**
  * Unique ID for this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#id Destination#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * Initial value used to calculate the retry, in milliseconds. Maximum is 600,000 ms (10 minutes). Default: 300
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#initial_backoff Destination#initial_backoff}
  */
  readonly initialBackoff?: number;
  /**
  * The maximum wait time for a retry, in milliseconds. Default (and minimum) is 30,000 ms (30 seconds); maximum is 180,000 ms (180 seconds). Default: 30000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#max_back_off Destination#max_back_off}
  */
  readonly maxBackOff?: number;
  /**
  * Maximum size of each record batch before compression. Setting should be < message.max.bytes settings in Event Hubs brokers. Default: 768
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#max_record_size_kb Destination#max_record_size_kb}
  */
  readonly maxRecordSizeKb?: number;
  /**
  * If messages are failing, you can set the maximum number of retries as high as 100 to prevent loss of data. Default: 5
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#max_retries Destination#max_retries}
  */
  readonly maxRetries?: number;
  /**
  * How to handle events when all receivers are exerting backpressure. Default: "block"; must be one of ["block", "drop", "queue"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#on_backpressure Destination#on_backpressure}
  */
  readonly onBackpressure?: string;
  /**
  * Pipeline to process data before sending out to this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pipeline Destination#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pq_compress Destination#pq_compress}
  */
  readonly pqCompress?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pq_controls Destination#pq_controls}
  */
  readonly pqControls?: DestinationOutputAzureEventhubPqControls;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.). Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pq_max_file_size Destination#pq_max_file_size}
  */
  readonly pqMaxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pq_max_size Destination#pq_max_size}
  */
  readonly pqMaxSize?: string;
  /**
  * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem. Default: "error"; must be one of ["error", "backpressure", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pq_mode Destination#pq_mode}
  */
  readonly pqMode?: string;
  /**
  * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged. Default: "block"; must be one of ["block", "drop"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pq_on_backpressure Destination#pq_on_backpressure}
  */
  readonly pqOnBackpressure?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pq_path Destination#pq_path}
  */
  readonly pqPath?: string;
  /**
  * Specifies a time window during which @{product} can reauthenticate if needed. Creates the window measuring backward from the moment when credentials are set to expire. Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#reauthentication_threshold Destination#reauthentication_threshold}
  */
  readonly reauthenticationThreshold?: number;
  /**
  * Maximum time to wait for Kafka to respond to a request. Default: 60000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#request_timeout Destination#request_timeout}
  */
  readonly requestTimeout?: number;
  /**
  * Authentication parameters to use when connecting to brokers. Using TLS is highly recommended.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#sasl Destination#sasl}
  */
  readonly sasl?: DestinationOutputAzureEventhubSasl;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#streamtags Destination#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Fields to automatically add to events, such as cribl_pipe. Supports wildcards. Default: ["cribl_pipe"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#system_fields Destination#system_fields}
  */
  readonly systemFields?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#tls Destination#tls}
  */
  readonly tls?: DestinationOutputAzureEventhubTls;
  /**
  * The name of the Event Hub (Kafka Topic) to publish events. Can be overwritten using field __topicOut.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#topic Destination#topic}
  */
  readonly topic: string;
  /**
  * must be "azure_eventhub"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#type Destination#type}
  */
  readonly type?: string;
}

export function destinationOutputAzureEventhubToTerraform(struct?: DestinationOutputAzureEventhub | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ack: cdktf.numberToTerraform(struct!.ack),
    authentication_timeout: cdktf.numberToTerraform(struct!.authenticationTimeout),
    backoff_rate: cdktf.numberToTerraform(struct!.backoffRate),
    brokers: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.brokers),
    connection_timeout: cdktf.numberToTerraform(struct!.connectionTimeout),
    description: cdktf.stringToTerraform(struct!.description),
    environment: cdktf.stringToTerraform(struct!.environment),
    flush_event_count: cdktf.numberToTerraform(struct!.flushEventCount),
    flush_period_sec: cdktf.numberToTerraform(struct!.flushPeriodSec),
    format: cdktf.stringToTerraform(struct!.format),
    id: cdktf.stringToTerraform(struct!.id),
    initial_backoff: cdktf.numberToTerraform(struct!.initialBackoff),
    max_back_off: cdktf.numberToTerraform(struct!.maxBackOff),
    max_record_size_kb: cdktf.numberToTerraform(struct!.maxRecordSizeKb),
    max_retries: cdktf.numberToTerraform(struct!.maxRetries),
    on_backpressure: cdktf.stringToTerraform(struct!.onBackpressure),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    pq_compress: cdktf.stringToTerraform(struct!.pqCompress),
    pq_controls: destinationOutputAzureEventhubPqControlsToTerraform(struct!.pqControls),
    pq_max_file_size: cdktf.stringToTerraform(struct!.pqMaxFileSize),
    pq_max_size: cdktf.stringToTerraform(struct!.pqMaxSize),
    pq_mode: cdktf.stringToTerraform(struct!.pqMode),
    pq_on_backpressure: cdktf.stringToTerraform(struct!.pqOnBackpressure),
    pq_path: cdktf.stringToTerraform(struct!.pqPath),
    reauthentication_threshold: cdktf.numberToTerraform(struct!.reauthenticationThreshold),
    request_timeout: cdktf.numberToTerraform(struct!.requestTimeout),
    sasl: destinationOutputAzureEventhubSaslToTerraform(struct!.sasl),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    system_fields: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.systemFields),
    tls: destinationOutputAzureEventhubTlsToTerraform(struct!.tls),
    topic: cdktf.stringToTerraform(struct!.topic),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function destinationOutputAzureEventhubToHclTerraform(struct?: DestinationOutputAzureEventhub | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ack: {
      value: cdktf.numberToHclTerraform(struct!.ack),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    authentication_timeout: {
      value: cdktf.numberToHclTerraform(struct!.authenticationTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    backoff_rate: {
      value: cdktf.numberToHclTerraform(struct!.backoffRate),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    brokers: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.brokers),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    connection_timeout: {
      value: cdktf.numberToHclTerraform(struct!.connectionTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    flush_event_count: {
      value: cdktf.numberToHclTerraform(struct!.flushEventCount),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    flush_period_sec: {
      value: cdktf.numberToHclTerraform(struct!.flushPeriodSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    format: {
      value: cdktf.stringToHclTerraform(struct!.format),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    initial_backoff: {
      value: cdktf.numberToHclTerraform(struct!.initialBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_back_off: {
      value: cdktf.numberToHclTerraform(struct!.maxBackOff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_record_size_kb: {
      value: cdktf.numberToHclTerraform(struct!.maxRecordSizeKb),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_retries: {
      value: cdktf.numberToHclTerraform(struct!.maxRetries),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.onBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_compress: {
      value: cdktf.stringToHclTerraform(struct!.pqCompress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_controls: {
      value: destinationOutputAzureEventhubPqControlsToHclTerraform(struct!.pqControls),
      isBlock: true,
      type: "struct",
      storageClassType: "DestinationOutputAzureEventhubPqControls",
    },
    pq_max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_max_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_mode: {
      value: cdktf.stringToHclTerraform(struct!.pqMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.pqOnBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_path: {
      value: cdktf.stringToHclTerraform(struct!.pqPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reauthentication_threshold: {
      value: cdktf.numberToHclTerraform(struct!.reauthenticationThreshold),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    request_timeout: {
      value: cdktf.numberToHclTerraform(struct!.requestTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    sasl: {
      value: destinationOutputAzureEventhubSaslToHclTerraform(struct!.sasl),
      isBlock: true,
      type: "struct",
      storageClassType: "DestinationOutputAzureEventhubSasl",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    system_fields: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.systemFields),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    tls: {
      value: destinationOutputAzureEventhubTlsToHclTerraform(struct!.tls),
      isBlock: true,
      type: "struct",
      storageClassType: "DestinationOutputAzureEventhubTls",
    },
    topic: {
      value: cdktf.stringToHclTerraform(struct!.topic),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputAzureEventhubOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DestinationOutputAzureEventhub | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._ack !== undefined) {
      hasAnyValues = true;
      internalValueResult.ack = this._ack;
    }
    if (this._authenticationTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.authenticationTimeout = this._authenticationTimeout;
    }
    if (this._backoffRate !== undefined) {
      hasAnyValues = true;
      internalValueResult.backoffRate = this._backoffRate;
    }
    if (this._brokers !== undefined) {
      hasAnyValues = true;
      internalValueResult.brokers = this._brokers;
    }
    if (this._connectionTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.connectionTimeout = this._connectionTimeout;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._flushEventCount !== undefined) {
      hasAnyValues = true;
      internalValueResult.flushEventCount = this._flushEventCount;
    }
    if (this._flushPeriodSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.flushPeriodSec = this._flushPeriodSec;
    }
    if (this._format !== undefined) {
      hasAnyValues = true;
      internalValueResult.format = this._format;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._initialBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.initialBackoff = this._initialBackoff;
    }
    if (this._maxBackOff !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBackOff = this._maxBackOff;
    }
    if (this._maxRecordSizeKb !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxRecordSizeKb = this._maxRecordSizeKb;
    }
    if (this._maxRetries !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxRetries = this._maxRetries;
    }
    if (this._onBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.onBackpressure = this._onBackpressure;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._pqCompress !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqCompress = this._pqCompress;
    }
    if (this._pqControls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqControls = this._pqControls?.internalValue;
    }
    if (this._pqMaxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxFileSize = this._pqMaxFileSize;
    }
    if (this._pqMaxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxSize = this._pqMaxSize;
    }
    if (this._pqMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMode = this._pqMode;
    }
    if (this._pqOnBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqOnBackpressure = this._pqOnBackpressure;
    }
    if (this._pqPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqPath = this._pqPath;
    }
    if (this._reauthenticationThreshold !== undefined) {
      hasAnyValues = true;
      internalValueResult.reauthenticationThreshold = this._reauthenticationThreshold;
    }
    if (this._requestTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.requestTimeout = this._requestTimeout;
    }
    if (this._sasl?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.sasl = this._sasl?.internalValue;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._systemFields !== undefined) {
      hasAnyValues = true;
      internalValueResult.systemFields = this._systemFields;
    }
    if (this._tls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tls = this._tls?.internalValue;
    }
    if (this._topic !== undefined) {
      hasAnyValues = true;
      internalValueResult.topic = this._topic;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputAzureEventhub | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._ack = undefined;
      this._authenticationTimeout = undefined;
      this._backoffRate = undefined;
      this._brokers = undefined;
      this._connectionTimeout = undefined;
      this._description = undefined;
      this._environment = undefined;
      this._flushEventCount = undefined;
      this._flushPeriodSec = undefined;
      this._format = undefined;
      this._id = undefined;
      this._initialBackoff = undefined;
      this._maxBackOff = undefined;
      this._maxRecordSizeKb = undefined;
      this._maxRetries = undefined;
      this._onBackpressure = undefined;
      this._pipeline = undefined;
      this._pqCompress = undefined;
      this._pqControls.internalValue = undefined;
      this._pqMaxFileSize = undefined;
      this._pqMaxSize = undefined;
      this._pqMode = undefined;
      this._pqOnBackpressure = undefined;
      this._pqPath = undefined;
      this._reauthenticationThreshold = undefined;
      this._requestTimeout = undefined;
      this._sasl.internalValue = undefined;
      this._streamtags = undefined;
      this._systemFields = undefined;
      this._tls.internalValue = undefined;
      this._topic = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._ack = value.ack;
      this._authenticationTimeout = value.authenticationTimeout;
      this._backoffRate = value.backoffRate;
      this._brokers = value.brokers;
      this._connectionTimeout = value.connectionTimeout;
      this._description = value.description;
      this._environment = value.environment;
      this._flushEventCount = value.flushEventCount;
      this._flushPeriodSec = value.flushPeriodSec;
      this._format = value.format;
      this._id = value.id;
      this._initialBackoff = value.initialBackoff;
      this._maxBackOff = value.maxBackOff;
      this._maxRecordSizeKb = value.maxRecordSizeKb;
      this._maxRetries = value.maxRetries;
      this._onBackpressure = value.onBackpressure;
      this._pipeline = value.pipeline;
      this._pqCompress = value.pqCompress;
      this._pqControls.internalValue = value.pqControls;
      this._pqMaxFileSize = value.pqMaxFileSize;
      this._pqMaxSize = value.pqMaxSize;
      this._pqMode = value.pqMode;
      this._pqOnBackpressure = value.pqOnBackpressure;
      this._pqPath = value.pqPath;
      this._reauthenticationThreshold = value.reauthenticationThreshold;
      this._requestTimeout = value.requestTimeout;
      this._sasl.internalValue = value.sasl;
      this._streamtags = value.streamtags;
      this._systemFields = value.systemFields;
      this._tls.internalValue = value.tls;
      this._topic = value.topic;
      this._type = value.type;
    }
  }

  // ack - computed: true, optional: true, required: false
  private _ack?: number; 
  public get ack() {
    return this.getNumberAttribute('ack');
  }
  public set ack(value: number) {
    this._ack = value;
  }
  public resetAck() {
    this._ack = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ackInput() {
    return this._ack;
  }

  // authentication_timeout - computed: true, optional: true, required: false
  private _authenticationTimeout?: number; 
  public get authenticationTimeout() {
    return this.getNumberAttribute('authentication_timeout');
  }
  public set authenticationTimeout(value: number) {
    this._authenticationTimeout = value;
  }
  public resetAuthenticationTimeout() {
    this._authenticationTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authenticationTimeoutInput() {
    return this._authenticationTimeout;
  }

  // backoff_rate - computed: true, optional: true, required: false
  private _backoffRate?: number; 
  public get backoffRate() {
    return this.getNumberAttribute('backoff_rate');
  }
  public set backoffRate(value: number) {
    this._backoffRate = value;
  }
  public resetBackoffRate() {
    this._backoffRate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get backoffRateInput() {
    return this._backoffRate;
  }

  // brokers - computed: false, optional: false, required: true
  private _brokers?: string[]; 
  public get brokers() {
    return this.getListAttribute('brokers');
  }
  public set brokers(value: string[]) {
    this._brokers = value;
  }
  // Temporarily expose input value. Use with caution.
  public get brokersInput() {
    return this._brokers;
  }

  // connection_timeout - computed: true, optional: true, required: false
  private _connectionTimeout?: number; 
  public get connectionTimeout() {
    return this.getNumberAttribute('connection_timeout');
  }
  public set connectionTimeout(value: number) {
    this._connectionTimeout = value;
  }
  public resetConnectionTimeout() {
    this._connectionTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectionTimeoutInput() {
    return this._connectionTimeout;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // flush_event_count - computed: true, optional: true, required: false
  private _flushEventCount?: number; 
  public get flushEventCount() {
    return this.getNumberAttribute('flush_event_count');
  }
  public set flushEventCount(value: number) {
    this._flushEventCount = value;
  }
  public resetFlushEventCount() {
    this._flushEventCount = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get flushEventCountInput() {
    return this._flushEventCount;
  }

  // flush_period_sec - computed: true, optional: true, required: false
  private _flushPeriodSec?: number; 
  public get flushPeriodSec() {
    return this.getNumberAttribute('flush_period_sec');
  }
  public set flushPeriodSec(value: number) {
    this._flushPeriodSec = value;
  }
  public resetFlushPeriodSec() {
    this._flushPeriodSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get flushPeriodSecInput() {
    return this._flushPeriodSec;
  }

  // format - computed: true, optional: true, required: false
  private _format?: string; 
  public get format() {
    return this.getStringAttribute('format');
  }
  public set format(value: string) {
    this._format = value;
  }
  public resetFormat() {
    this._format = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get formatInput() {
    return this._format;
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // initial_backoff - computed: true, optional: true, required: false
  private _initialBackoff?: number; 
  public get initialBackoff() {
    return this.getNumberAttribute('initial_backoff');
  }
  public set initialBackoff(value: number) {
    this._initialBackoff = value;
  }
  public resetInitialBackoff() {
    this._initialBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get initialBackoffInput() {
    return this._initialBackoff;
  }

  // max_back_off - computed: true, optional: true, required: false
  private _maxBackOff?: number; 
  public get maxBackOff() {
    return this.getNumberAttribute('max_back_off');
  }
  public set maxBackOff(value: number) {
    this._maxBackOff = value;
  }
  public resetMaxBackOff() {
    this._maxBackOff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBackOffInput() {
    return this._maxBackOff;
  }

  // max_record_size_kb - computed: true, optional: true, required: false
  private _maxRecordSizeKb?: number; 
  public get maxRecordSizeKb() {
    return this.getNumberAttribute('max_record_size_kb');
  }
  public set maxRecordSizeKb(value: number) {
    this._maxRecordSizeKb = value;
  }
  public resetMaxRecordSizeKb() {
    this._maxRecordSizeKb = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxRecordSizeKbInput() {
    return this._maxRecordSizeKb;
  }

  // max_retries - computed: true, optional: true, required: false
  private _maxRetries?: number; 
  public get maxRetries() {
    return this.getNumberAttribute('max_retries');
  }
  public set maxRetries(value: number) {
    this._maxRetries = value;
  }
  public resetMaxRetries() {
    this._maxRetries = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxRetriesInput() {
    return this._maxRetries;
  }

  // on_backpressure - computed: true, optional: true, required: false
  private _onBackpressure?: string; 
  public get onBackpressure() {
    return this.getStringAttribute('on_backpressure');
  }
  public set onBackpressure(value: string) {
    this._onBackpressure = value;
  }
  public resetOnBackpressure() {
    this._onBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get onBackpressureInput() {
    return this._onBackpressure;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // pq_compress - computed: true, optional: true, required: false
  private _pqCompress?: string; 
  public get pqCompress() {
    return this.getStringAttribute('pq_compress');
  }
  public set pqCompress(value: string) {
    this._pqCompress = value;
  }
  public resetPqCompress() {
    this._pqCompress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqCompressInput() {
    return this._pqCompress;
  }

  // pq_controls - computed: false, optional: true, required: false
  private _pqControls = new DestinationOutputAzureEventhubPqControlsOutputReference(this, "pq_controls");
  public get pqControls() {
    return this._pqControls;
  }
  public putPqControls(value: DestinationOutputAzureEventhubPqControls) {
    this._pqControls.internalValue = value;
  }
  public resetPqControls() {
    this._pqControls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqControlsInput() {
    return this._pqControls.internalValue;
  }

  // pq_max_file_size - computed: true, optional: true, required: false
  private _pqMaxFileSize?: string; 
  public get pqMaxFileSize() {
    return this.getStringAttribute('pq_max_file_size');
  }
  public set pqMaxFileSize(value: string) {
    this._pqMaxFileSize = value;
  }
  public resetPqMaxFileSize() {
    this._pqMaxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxFileSizeInput() {
    return this._pqMaxFileSize;
  }

  // pq_max_size - computed: true, optional: true, required: false
  private _pqMaxSize?: string; 
  public get pqMaxSize() {
    return this.getStringAttribute('pq_max_size');
  }
  public set pqMaxSize(value: string) {
    this._pqMaxSize = value;
  }
  public resetPqMaxSize() {
    this._pqMaxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxSizeInput() {
    return this._pqMaxSize;
  }

  // pq_mode - computed: true, optional: true, required: false
  private _pqMode?: string; 
  public get pqMode() {
    return this.getStringAttribute('pq_mode');
  }
  public set pqMode(value: string) {
    this._pqMode = value;
  }
  public resetPqMode() {
    this._pqMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqModeInput() {
    return this._pqMode;
  }

  // pq_on_backpressure - computed: true, optional: true, required: false
  private _pqOnBackpressure?: string; 
  public get pqOnBackpressure() {
    return this.getStringAttribute('pq_on_backpressure');
  }
  public set pqOnBackpressure(value: string) {
    this._pqOnBackpressure = value;
  }
  public resetPqOnBackpressure() {
    this._pqOnBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqOnBackpressureInput() {
    return this._pqOnBackpressure;
  }

  // pq_path - computed: true, optional: true, required: false
  private _pqPath?: string; 
  public get pqPath() {
    return this.getStringAttribute('pq_path');
  }
  public set pqPath(value: string) {
    this._pqPath = value;
  }
  public resetPqPath() {
    this._pqPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqPathInput() {
    return this._pqPath;
  }

  // reauthentication_threshold - computed: true, optional: true, required: false
  private _reauthenticationThreshold?: number; 
  public get reauthenticationThreshold() {
    return this.getNumberAttribute('reauthentication_threshold');
  }
  public set reauthenticationThreshold(value: number) {
    this._reauthenticationThreshold = value;
  }
  public resetReauthenticationThreshold() {
    this._reauthenticationThreshold = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get reauthenticationThresholdInput() {
    return this._reauthenticationThreshold;
  }

  // request_timeout - computed: true, optional: true, required: false
  private _requestTimeout?: number; 
  public get requestTimeout() {
    return this.getNumberAttribute('request_timeout');
  }
  public set requestTimeout(value: number) {
    this._requestTimeout = value;
  }
  public resetRequestTimeout() {
    this._requestTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestTimeoutInput() {
    return this._requestTimeout;
  }

  // sasl - computed: false, optional: true, required: false
  private _sasl = new DestinationOutputAzureEventhubSaslOutputReference(this, "sasl");
  public get sasl() {
    return this._sasl;
  }
  public putSasl(value: DestinationOutputAzureEventhubSasl) {
    this._sasl.internalValue = value;
  }
  public resetSasl() {
    this._sasl.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get saslInput() {
    return this._sasl.internalValue;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // system_fields - computed: true, optional: true, required: false
  private _systemFields?: string[]; 
  public get systemFields() {
    return this.getListAttribute('system_fields');
  }
  public set systemFields(value: string[]) {
    this._systemFields = value;
  }
  public resetSystemFields() {
    this._systemFields = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get systemFieldsInput() {
    return this._systemFields;
  }

  // tls - computed: false, optional: true, required: false
  private _tls = new DestinationOutputAzureEventhubTlsOutputReference(this, "tls");
  public get tls() {
    return this._tls;
  }
  public putTls(value: DestinationOutputAzureEventhubTls) {
    this._tls.internalValue = value;
  }
  public resetTls() {
    this._tls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsInput() {
    return this._tls.internalValue;
  }

  // topic - computed: false, optional: false, required: true
  private _topic?: string; 
  public get topic() {
    return this.getStringAttribute('topic');
  }
  public set topic(value: string) {
    this._topic = value;
  }
  // Temporarily expose input value. Use with caution.
  public get topicInput() {
    return this._topic;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface DestinationOutputAzureLogsExtraHttpHeaders {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#name Destination#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#value Destination#value}
  */
  readonly value: string;
}

export function destinationOutputAzureLogsExtraHttpHeadersToTerraform(struct?: DestinationOutputAzureLogsExtraHttpHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function destinationOutputAzureLogsExtraHttpHeadersToHclTerraform(struct?: DestinationOutputAzureLogsExtraHttpHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputAzureLogsExtraHttpHeadersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DestinationOutputAzureLogsExtraHttpHeaders | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputAzureLogsExtraHttpHeaders | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DestinationOutputAzureLogsExtraHttpHeadersList extends cdktf.ComplexList {
  public internalValue? : DestinationOutputAzureLogsExtraHttpHeaders[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DestinationOutputAzureLogsExtraHttpHeadersOutputReference {
    return new DestinationOutputAzureLogsExtraHttpHeadersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DestinationOutputAzureLogsPqControls {
}

export function destinationOutputAzureLogsPqControlsToTerraform(struct?: DestinationOutputAzureLogsPqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function destinationOutputAzureLogsPqControlsToHclTerraform(struct?: DestinationOutputAzureLogsPqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class DestinationOutputAzureLogsPqControlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DestinationOutputAzureLogsPqControls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputAzureLogsPqControls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface DestinationOutputAzureLogsResponseRetrySettings {
  /**
  * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc. Default: 2
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#backoff_rate Destination#backoff_rate}
  */
  readonly backoffRate?: number;
  /**
  * The HTTP response status code that will trigger retries
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#http_status Destination#http_status}
  */
  readonly httpStatus: number;
  /**
  * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes). Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#initial_backoff Destination#initial_backoff}
  */
  readonly initialBackoff?: number;
  /**
  * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds). Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#max_backoff Destination#max_backoff}
  */
  readonly maxBackoff?: number;
}

export function destinationOutputAzureLogsResponseRetrySettingsToTerraform(struct?: DestinationOutputAzureLogsResponseRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    backoff_rate: cdktf.numberToTerraform(struct!.backoffRate),
    http_status: cdktf.numberToTerraform(struct!.httpStatus),
    initial_backoff: cdktf.numberToTerraform(struct!.initialBackoff),
    max_backoff: cdktf.numberToTerraform(struct!.maxBackoff),
  }
}


export function destinationOutputAzureLogsResponseRetrySettingsToHclTerraform(struct?: DestinationOutputAzureLogsResponseRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    backoff_rate: {
      value: cdktf.numberToHclTerraform(struct!.backoffRate),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    http_status: {
      value: cdktf.numberToHclTerraform(struct!.httpStatus),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    initial_backoff: {
      value: cdktf.numberToHclTerraform(struct!.initialBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_backoff: {
      value: cdktf.numberToHclTerraform(struct!.maxBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputAzureLogsResponseRetrySettingsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DestinationOutputAzureLogsResponseRetrySettings | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._backoffRate !== undefined) {
      hasAnyValues = true;
      internalValueResult.backoffRate = this._backoffRate;
    }
    if (this._httpStatus !== undefined) {
      hasAnyValues = true;
      internalValueResult.httpStatus = this._httpStatus;
    }
    if (this._initialBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.initialBackoff = this._initialBackoff;
    }
    if (this._maxBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBackoff = this._maxBackoff;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputAzureLogsResponseRetrySettings | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._backoffRate = undefined;
      this._httpStatus = undefined;
      this._initialBackoff = undefined;
      this._maxBackoff = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._backoffRate = value.backoffRate;
      this._httpStatus = value.httpStatus;
      this._initialBackoff = value.initialBackoff;
      this._maxBackoff = value.maxBackoff;
    }
  }

  // backoff_rate - computed: true, optional: true, required: false
  private _backoffRate?: number; 
  public get backoffRate() {
    return this.getNumberAttribute('backoff_rate');
  }
  public set backoffRate(value: number) {
    this._backoffRate = value;
  }
  public resetBackoffRate() {
    this._backoffRate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get backoffRateInput() {
    return this._backoffRate;
  }

  // http_status - computed: false, optional: false, required: true
  private _httpStatus?: number; 
  public get httpStatus() {
    return this.getNumberAttribute('http_status');
  }
  public set httpStatus(value: number) {
    this._httpStatus = value;
  }
  // Temporarily expose input value. Use with caution.
  public get httpStatusInput() {
    return this._httpStatus;
  }

  // initial_backoff - computed: true, optional: true, required: false
  private _initialBackoff?: number; 
  public get initialBackoff() {
    return this.getNumberAttribute('initial_backoff');
  }
  public set initialBackoff(value: number) {
    this._initialBackoff = value;
  }
  public resetInitialBackoff() {
    this._initialBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get initialBackoffInput() {
    return this._initialBackoff;
  }

  // max_backoff - computed: true, optional: true, required: false
  private _maxBackoff?: number; 
  public get maxBackoff() {
    return this.getNumberAttribute('max_backoff');
  }
  public set maxBackoff(value: number) {
    this._maxBackoff = value;
  }
  public resetMaxBackoff() {
    this._maxBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBackoffInput() {
    return this._maxBackoff;
  }
}

export class DestinationOutputAzureLogsResponseRetrySettingsList extends cdktf.ComplexList {
  public internalValue? : DestinationOutputAzureLogsResponseRetrySettings[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DestinationOutputAzureLogsResponseRetrySettingsOutputReference {
    return new DestinationOutputAzureLogsResponseRetrySettingsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DestinationOutputAzureLogsTimeoutRetrySettings {
  /**
  * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc. Default: 2
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#backoff_rate Destination#backoff_rate}
  */
  readonly backoffRate?: number;
  /**
  * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes). Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#initial_backoff Destination#initial_backoff}
  */
  readonly initialBackoff?: number;
  /**
  * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds). Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#max_backoff Destination#max_backoff}
  */
  readonly maxBackoff?: number;
  /**
  * Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#timeout_retry Destination#timeout_retry}
  */
  readonly timeoutRetry?: boolean | cdktf.IResolvable;
}

export function destinationOutputAzureLogsTimeoutRetrySettingsToTerraform(struct?: DestinationOutputAzureLogsTimeoutRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    backoff_rate: cdktf.numberToTerraform(struct!.backoffRate),
    initial_backoff: cdktf.numberToTerraform(struct!.initialBackoff),
    max_backoff: cdktf.numberToTerraform(struct!.maxBackoff),
    timeout_retry: cdktf.booleanToTerraform(struct!.timeoutRetry),
  }
}


export function destinationOutputAzureLogsTimeoutRetrySettingsToHclTerraform(struct?: DestinationOutputAzureLogsTimeoutRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    backoff_rate: {
      value: cdktf.numberToHclTerraform(struct!.backoffRate),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    initial_backoff: {
      value: cdktf.numberToHclTerraform(struct!.initialBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_backoff: {
      value: cdktf.numberToHclTerraform(struct!.maxBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    timeout_retry: {
      value: cdktf.booleanToHclTerraform(struct!.timeoutRetry),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputAzureLogsTimeoutRetrySettingsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DestinationOutputAzureLogsTimeoutRetrySettings | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._backoffRate !== undefined) {
      hasAnyValues = true;
      internalValueResult.backoffRate = this._backoffRate;
    }
    if (this._initialBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.initialBackoff = this._initialBackoff;
    }
    if (this._maxBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBackoff = this._maxBackoff;
    }
    if (this._timeoutRetry !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutRetry = this._timeoutRetry;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputAzureLogsTimeoutRetrySettings | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._backoffRate = undefined;
      this._initialBackoff = undefined;
      this._maxBackoff = undefined;
      this._timeoutRetry = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._backoffRate = value.backoffRate;
      this._initialBackoff = value.initialBackoff;
      this._maxBackoff = value.maxBackoff;
      this._timeoutRetry = value.timeoutRetry;
    }
  }

  // backoff_rate - computed: true, optional: true, required: false
  private _backoffRate?: number; 
  public get backoffRate() {
    return this.getNumberAttribute('backoff_rate');
  }
  public set backoffRate(value: number) {
    this._backoffRate = value;
  }
  public resetBackoffRate() {
    this._backoffRate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get backoffRateInput() {
    return this._backoffRate;
  }

  // initial_backoff - computed: true, optional: true, required: false
  private _initialBackoff?: number; 
  public get initialBackoff() {
    return this.getNumberAttribute('initial_backoff');
  }
  public set initialBackoff(value: number) {
    this._initialBackoff = value;
  }
  public resetInitialBackoff() {
    this._initialBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get initialBackoffInput() {
    return this._initialBackoff;
  }

  // max_backoff - computed: true, optional: true, required: false
  private _maxBackoff?: number; 
  public get maxBackoff() {
    return this.getNumberAttribute('max_backoff');
  }
  public set maxBackoff(value: number) {
    this._maxBackoff = value;
  }
  public resetMaxBackoff() {
    this._maxBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBackoffInput() {
    return this._maxBackoff;
  }

  // timeout_retry - computed: true, optional: true, required: false
  private _timeoutRetry?: boolean | cdktf.IResolvable; 
  public get timeoutRetry() {
    return this.getBooleanAttribute('timeout_retry');
  }
  public set timeoutRetry(value: boolean | cdktf.IResolvable) {
    this._timeoutRetry = value;
  }
  public resetTimeoutRetry() {
    this._timeoutRetry = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutRetryInput() {
    return this._timeoutRetry;
  }
}
export interface DestinationOutputAzureLogs {
  /**
  * The DNS name of the Log API endpoint that sends log data to a Log Analytics workspace in Azure Monitor. Defaults to .ods.opinsights.azure.com. @{product} will add a prefix and suffix to construct a URI in this format: <https://<Workspace_ID><your_DNS_name>/api/logs?api-version=<API version>. Default: ".ods.opinsights.azure.com"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#api_url Destination#api_url}
  */
  readonly apiUrl?: string;
  /**
  * Enter workspace ID and workspace key directly, or select a stored secret. Default: "manual"; must be one of ["manual", "secret"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#auth_type Destination#auth_type}
  */
  readonly authType?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#compress Destination#compress}
  */
  readonly compress?: boolean | cdktf.IResolvable;
  /**
  * Maximum number of ongoing requests before blocking. Default: 5
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#concurrency Destination#concurrency}
  */
  readonly concurrency?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#description Destination#description}
  */
  readonly description?: string;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#environment Destination#environment}
  */
  readonly environment?: string;
  /**
  * Headers to add to all events
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#extra_http_headers Destination#extra_http_headers}
  */
  readonly extraHttpHeaders?: DestinationOutputAzureLogsExtraHttpHeaders[] | cdktf.IResolvable;
  /**
  * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below. Default: "none"; must be one of ["payload", "payloadAndHeaders", "none"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#failed_request_logging_mode Destination#failed_request_logging_mode}
  */
  readonly failedRequestLoggingMode?: string;
  /**
  * Maximum time between requests. Small values could cause the payload size to be smaller than the configured Body size limit. Default: 1
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#flush_period_sec Destination#flush_period_sec}
  */
  readonly flushPeriodSec?: number;
  /**
  * Unique ID for this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#id Destination#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * Select or create a stored secret that references your access key and secret key
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#keypair_secret Destination#keypair_secret}
  */
  readonly keypairSecret?: string;
  /**
  * The Log Type of events sent to this LogAnalytics workspace. Defaults to `Cribl`. Use only letters, numbers, and `_` characters, and can't exceed 100 characters. Can be overwritten by event field __logType. Default: "Cribl"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#log_type Destination#log_type}
  */
  readonly logType?: string;
  /**
  * Maximum number of events to include in the request body. Default is 0 (unlimited). Default: 0
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#max_payload_events Destination#max_payload_events}
  */
  readonly maxPayloadEvents?: number;
  /**
  * Maximum size, in KB, of the request body. Default: 1024
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#max_payload_size_kb Destination#max_payload_size_kb}
  */
  readonly maxPayloadSizeKb?: number;
  /**
  * How to handle events when all receivers are exerting backpressure. Default: "block"; must be one of ["block", "drop", "queue"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#on_backpressure Destination#on_backpressure}
  */
  readonly onBackpressure?: string;
  /**
  * Pipeline to process data before sending out to this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pipeline Destination#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pq_compress Destination#pq_compress}
  */
  readonly pqCompress?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pq_controls Destination#pq_controls}
  */
  readonly pqControls?: DestinationOutputAzureLogsPqControls;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.). Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pq_max_file_size Destination#pq_max_file_size}
  */
  readonly pqMaxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pq_max_size Destination#pq_max_size}
  */
  readonly pqMaxSize?: string;
  /**
  * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem. Default: "error"; must be one of ["error", "backpressure", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pq_mode Destination#pq_mode}
  */
  readonly pqMode?: string;
  /**
  * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged. Default: "block"; must be one of ["block", "drop"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pq_on_backpressure Destination#pq_on_backpressure}
  */
  readonly pqOnBackpressure?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pq_path Destination#pq_path}
  */
  readonly pqPath?: string;
  /**
  * Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's). 
  *         Enabled by default. When this setting is also present in TLS Settings (Client Side), 
  *         that value will take precedence.
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#reject_unauthorized Destination#reject_unauthorized}
  */
  readonly rejectUnauthorized?: boolean | cdktf.IResolvable;
  /**
  * Optional Resource ID of the Azure resource to associate the data with. Can be overridden by the __resourceId event field. This ID populates the _ResourceId property, allowing the data to be included in resource-centric queries. If the ID is neither specified nor overridden, resource-centric queries will omit the data.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#resource_id Destination#resource_id}
  */
  readonly resourceId?: string;
  /**
  * Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#response_honor_retry_after_header Destination#response_honor_retry_after_header}
  */
  readonly responseHonorRetryAfterHeader?: boolean | cdktf.IResolvable;
  /**
  * Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#response_retry_settings Destination#response_retry_settings}
  */
  readonly responseRetrySettings?: DestinationOutputAzureLogsResponseRetrySettings[] | cdktf.IResolvable;
  /**
  * List of headers that are safe to log in plain text. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#safe_headers Destination#safe_headers}
  */
  readonly safeHeaders?: string[];
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#streamtags Destination#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Fields to automatically add to events, such as cribl_pipe. Supports wildcards. Default: ["cribl_pipe"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#system_fields Destination#system_fields}
  */
  readonly systemFields?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#timeout_retry_settings Destination#timeout_retry_settings}
  */
  readonly timeoutRetrySettings?: DestinationOutputAzureLogsTimeoutRetrySettings;
  /**
  * Amount of time, in seconds, to wait for a request to complete before canceling it. Default: 30
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#timeout_sec Destination#timeout_sec}
  */
  readonly timeoutSec?: number;
  /**
  * must be "azure_logs"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#type Destination#type}
  */
  readonly type: string;
  /**
  * Enable round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. For optimal performance, consider enabling this setting for non-load balanced destinations. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#use_round_robin_dns Destination#use_round_robin_dns}
  */
  readonly useRoundRobinDns?: boolean | cdktf.IResolvable;
  /**
  * Azure Log Analytics Workspace ID. See Azure Dashboard Workspace > Advanced settings.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#workspace_id Destination#workspace_id}
  */
  readonly workspaceId?: string;
  /**
  * Azure Log Analytics Workspace Primary or Secondary Shared Key. See Azure Dashboard Workspace > Advanced settings.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#workspace_key Destination#workspace_key}
  */
  readonly workspaceKey?: string;
}

export function destinationOutputAzureLogsToTerraform(struct?: DestinationOutputAzureLogs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    api_url: cdktf.stringToTerraform(struct!.apiUrl),
    auth_type: cdktf.stringToTerraform(struct!.authType),
    compress: cdktf.booleanToTerraform(struct!.compress),
    concurrency: cdktf.numberToTerraform(struct!.concurrency),
    description: cdktf.stringToTerraform(struct!.description),
    environment: cdktf.stringToTerraform(struct!.environment),
    extra_http_headers: cdktf.listMapper(destinationOutputAzureLogsExtraHttpHeadersToTerraform, false)(struct!.extraHttpHeaders),
    failed_request_logging_mode: cdktf.stringToTerraform(struct!.failedRequestLoggingMode),
    flush_period_sec: cdktf.numberToTerraform(struct!.flushPeriodSec),
    id: cdktf.stringToTerraform(struct!.id),
    keypair_secret: cdktf.stringToTerraform(struct!.keypairSecret),
    log_type: cdktf.stringToTerraform(struct!.logType),
    max_payload_events: cdktf.numberToTerraform(struct!.maxPayloadEvents),
    max_payload_size_kb: cdktf.numberToTerraform(struct!.maxPayloadSizeKb),
    on_backpressure: cdktf.stringToTerraform(struct!.onBackpressure),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    pq_compress: cdktf.stringToTerraform(struct!.pqCompress),
    pq_controls: destinationOutputAzureLogsPqControlsToTerraform(struct!.pqControls),
    pq_max_file_size: cdktf.stringToTerraform(struct!.pqMaxFileSize),
    pq_max_size: cdktf.stringToTerraform(struct!.pqMaxSize),
    pq_mode: cdktf.stringToTerraform(struct!.pqMode),
    pq_on_backpressure: cdktf.stringToTerraform(struct!.pqOnBackpressure),
    pq_path: cdktf.stringToTerraform(struct!.pqPath),
    reject_unauthorized: cdktf.booleanToTerraform(struct!.rejectUnauthorized),
    resource_id: cdktf.stringToTerraform(struct!.resourceId),
    response_honor_retry_after_header: cdktf.booleanToTerraform(struct!.responseHonorRetryAfterHeader),
    response_retry_settings: cdktf.listMapper(destinationOutputAzureLogsResponseRetrySettingsToTerraform, false)(struct!.responseRetrySettings),
    safe_headers: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.safeHeaders),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    system_fields: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.systemFields),
    timeout_retry_settings: destinationOutputAzureLogsTimeoutRetrySettingsToTerraform(struct!.timeoutRetrySettings),
    timeout_sec: cdktf.numberToTerraform(struct!.timeoutSec),
    type: cdktf.stringToTerraform(struct!.type),
    use_round_robin_dns: cdktf.booleanToTerraform(struct!.useRoundRobinDns),
    workspace_id: cdktf.stringToTerraform(struct!.workspaceId),
    workspace_key: cdktf.stringToTerraform(struct!.workspaceKey),
  }
}


export function destinationOutputAzureLogsToHclTerraform(struct?: DestinationOutputAzureLogs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    api_url: {
      value: cdktf.stringToHclTerraform(struct!.apiUrl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    auth_type: {
      value: cdktf.stringToHclTerraform(struct!.authType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    compress: {
      value: cdktf.booleanToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    concurrency: {
      value: cdktf.numberToHclTerraform(struct!.concurrency),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    extra_http_headers: {
      value: cdktf.listMapperHcl(destinationOutputAzureLogsExtraHttpHeadersToHclTerraform, false)(struct!.extraHttpHeaders),
      isBlock: true,
      type: "list",
      storageClassType: "DestinationOutputAzureLogsExtraHttpHeadersList",
    },
    failed_request_logging_mode: {
      value: cdktf.stringToHclTerraform(struct!.failedRequestLoggingMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    flush_period_sec: {
      value: cdktf.numberToHclTerraform(struct!.flushPeriodSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    keypair_secret: {
      value: cdktf.stringToHclTerraform(struct!.keypairSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    log_type: {
      value: cdktf.stringToHclTerraform(struct!.logType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_payload_events: {
      value: cdktf.numberToHclTerraform(struct!.maxPayloadEvents),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_payload_size_kb: {
      value: cdktf.numberToHclTerraform(struct!.maxPayloadSizeKb),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.onBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_compress: {
      value: cdktf.stringToHclTerraform(struct!.pqCompress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_controls: {
      value: destinationOutputAzureLogsPqControlsToHclTerraform(struct!.pqControls),
      isBlock: true,
      type: "struct",
      storageClassType: "DestinationOutputAzureLogsPqControls",
    },
    pq_max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_max_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_mode: {
      value: cdktf.stringToHclTerraform(struct!.pqMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.pqOnBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_path: {
      value: cdktf.stringToHclTerraform(struct!.pqPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reject_unauthorized: {
      value: cdktf.booleanToHclTerraform(struct!.rejectUnauthorized),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    resource_id: {
      value: cdktf.stringToHclTerraform(struct!.resourceId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    response_honor_retry_after_header: {
      value: cdktf.booleanToHclTerraform(struct!.responseHonorRetryAfterHeader),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    response_retry_settings: {
      value: cdktf.listMapperHcl(destinationOutputAzureLogsResponseRetrySettingsToHclTerraform, false)(struct!.responseRetrySettings),
      isBlock: true,
      type: "list",
      storageClassType: "DestinationOutputAzureLogsResponseRetrySettingsList",
    },
    safe_headers: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.safeHeaders),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    system_fields: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.systemFields),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    timeout_retry_settings: {
      value: destinationOutputAzureLogsTimeoutRetrySettingsToHclTerraform(struct!.timeoutRetrySettings),
      isBlock: true,
      type: "struct",
      storageClassType: "DestinationOutputAzureLogsTimeoutRetrySettings",
    },
    timeout_sec: {
      value: cdktf.numberToHclTerraform(struct!.timeoutSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    use_round_robin_dns: {
      value: cdktf.booleanToHclTerraform(struct!.useRoundRobinDns),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    workspace_id: {
      value: cdktf.stringToHclTerraform(struct!.workspaceId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    workspace_key: {
      value: cdktf.stringToHclTerraform(struct!.workspaceKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputAzureLogsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DestinationOutputAzureLogs | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._apiUrl !== undefined) {
      hasAnyValues = true;
      internalValueResult.apiUrl = this._apiUrl;
    }
    if (this._authType !== undefined) {
      hasAnyValues = true;
      internalValueResult.authType = this._authType;
    }
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._concurrency !== undefined) {
      hasAnyValues = true;
      internalValueResult.concurrency = this._concurrency;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._extraHttpHeaders?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.extraHttpHeaders = this._extraHttpHeaders?.internalValue;
    }
    if (this._failedRequestLoggingMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.failedRequestLoggingMode = this._failedRequestLoggingMode;
    }
    if (this._flushPeriodSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.flushPeriodSec = this._flushPeriodSec;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._keypairSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.keypairSecret = this._keypairSecret;
    }
    if (this._logType !== undefined) {
      hasAnyValues = true;
      internalValueResult.logType = this._logType;
    }
    if (this._maxPayloadEvents !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxPayloadEvents = this._maxPayloadEvents;
    }
    if (this._maxPayloadSizeKb !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxPayloadSizeKb = this._maxPayloadSizeKb;
    }
    if (this._onBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.onBackpressure = this._onBackpressure;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._pqCompress !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqCompress = this._pqCompress;
    }
    if (this._pqControls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqControls = this._pqControls?.internalValue;
    }
    if (this._pqMaxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxFileSize = this._pqMaxFileSize;
    }
    if (this._pqMaxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxSize = this._pqMaxSize;
    }
    if (this._pqMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMode = this._pqMode;
    }
    if (this._pqOnBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqOnBackpressure = this._pqOnBackpressure;
    }
    if (this._pqPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqPath = this._pqPath;
    }
    if (this._rejectUnauthorized !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectUnauthorized = this._rejectUnauthorized;
    }
    if (this._resourceId !== undefined) {
      hasAnyValues = true;
      internalValueResult.resourceId = this._resourceId;
    }
    if (this._responseHonorRetryAfterHeader !== undefined) {
      hasAnyValues = true;
      internalValueResult.responseHonorRetryAfterHeader = this._responseHonorRetryAfterHeader;
    }
    if (this._responseRetrySettings?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.responseRetrySettings = this._responseRetrySettings?.internalValue;
    }
    if (this._safeHeaders !== undefined) {
      hasAnyValues = true;
      internalValueResult.safeHeaders = this._safeHeaders;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._systemFields !== undefined) {
      hasAnyValues = true;
      internalValueResult.systemFields = this._systemFields;
    }
    if (this._timeoutRetrySettings?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutRetrySettings = this._timeoutRetrySettings?.internalValue;
    }
    if (this._timeoutSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutSec = this._timeoutSec;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._useRoundRobinDns !== undefined) {
      hasAnyValues = true;
      internalValueResult.useRoundRobinDns = this._useRoundRobinDns;
    }
    if (this._workspaceId !== undefined) {
      hasAnyValues = true;
      internalValueResult.workspaceId = this._workspaceId;
    }
    if (this._workspaceKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.workspaceKey = this._workspaceKey;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputAzureLogs | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._apiUrl = undefined;
      this._authType = undefined;
      this._compress = undefined;
      this._concurrency = undefined;
      this._description = undefined;
      this._environment = undefined;
      this._extraHttpHeaders.internalValue = undefined;
      this._failedRequestLoggingMode = undefined;
      this._flushPeriodSec = undefined;
      this._id = undefined;
      this._keypairSecret = undefined;
      this._logType = undefined;
      this._maxPayloadEvents = undefined;
      this._maxPayloadSizeKb = undefined;
      this._onBackpressure = undefined;
      this._pipeline = undefined;
      this._pqCompress = undefined;
      this._pqControls.internalValue = undefined;
      this._pqMaxFileSize = undefined;
      this._pqMaxSize = undefined;
      this._pqMode = undefined;
      this._pqOnBackpressure = undefined;
      this._pqPath = undefined;
      this._rejectUnauthorized = undefined;
      this._resourceId = undefined;
      this._responseHonorRetryAfterHeader = undefined;
      this._responseRetrySettings.internalValue = undefined;
      this._safeHeaders = undefined;
      this._streamtags = undefined;
      this._systemFields = undefined;
      this._timeoutRetrySettings.internalValue = undefined;
      this._timeoutSec = undefined;
      this._type = undefined;
      this._useRoundRobinDns = undefined;
      this._workspaceId = undefined;
      this._workspaceKey = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._apiUrl = value.apiUrl;
      this._authType = value.authType;
      this._compress = value.compress;
      this._concurrency = value.concurrency;
      this._description = value.description;
      this._environment = value.environment;
      this._extraHttpHeaders.internalValue = value.extraHttpHeaders;
      this._failedRequestLoggingMode = value.failedRequestLoggingMode;
      this._flushPeriodSec = value.flushPeriodSec;
      this._id = value.id;
      this._keypairSecret = value.keypairSecret;
      this._logType = value.logType;
      this._maxPayloadEvents = value.maxPayloadEvents;
      this._maxPayloadSizeKb = value.maxPayloadSizeKb;
      this._onBackpressure = value.onBackpressure;
      this._pipeline = value.pipeline;
      this._pqCompress = value.pqCompress;
      this._pqControls.internalValue = value.pqControls;
      this._pqMaxFileSize = value.pqMaxFileSize;
      this._pqMaxSize = value.pqMaxSize;
      this._pqMode = value.pqMode;
      this._pqOnBackpressure = value.pqOnBackpressure;
      this._pqPath = value.pqPath;
      this._rejectUnauthorized = value.rejectUnauthorized;
      this._resourceId = value.resourceId;
      this._responseHonorRetryAfterHeader = value.responseHonorRetryAfterHeader;
      this._responseRetrySettings.internalValue = value.responseRetrySettings;
      this._safeHeaders = value.safeHeaders;
      this._streamtags = value.streamtags;
      this._systemFields = value.systemFields;
      this._timeoutRetrySettings.internalValue = value.timeoutRetrySettings;
      this._timeoutSec = value.timeoutSec;
      this._type = value.type;
      this._useRoundRobinDns = value.useRoundRobinDns;
      this._workspaceId = value.workspaceId;
      this._workspaceKey = value.workspaceKey;
    }
  }

  // api_url - computed: true, optional: true, required: false
  private _apiUrl?: string; 
  public get apiUrl() {
    return this.getStringAttribute('api_url');
  }
  public set apiUrl(value: string) {
    this._apiUrl = value;
  }
  public resetApiUrl() {
    this._apiUrl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get apiUrlInput() {
    return this._apiUrl;
  }

  // auth_type - computed: true, optional: true, required: false
  private _authType?: string; 
  public get authType() {
    return this.getStringAttribute('auth_type');
  }
  public set authType(value: string) {
    this._authType = value;
  }
  public resetAuthType() {
    this._authType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authTypeInput() {
    return this._authType;
  }

  // compress - computed: false, optional: true, required: false
  private _compress?: boolean | cdktf.IResolvable; 
  public get compress() {
    return this.getBooleanAttribute('compress');
  }
  public set compress(value: boolean | cdktf.IResolvable) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // concurrency - computed: true, optional: true, required: false
  private _concurrency?: number; 
  public get concurrency() {
    return this.getNumberAttribute('concurrency');
  }
  public set concurrency(value: number) {
    this._concurrency = value;
  }
  public resetConcurrency() {
    this._concurrency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get concurrencyInput() {
    return this._concurrency;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // extra_http_headers - computed: false, optional: true, required: false
  private _extraHttpHeaders = new DestinationOutputAzureLogsExtraHttpHeadersList(this, "extra_http_headers", false);
  public get extraHttpHeaders() {
    return this._extraHttpHeaders;
  }
  public putExtraHttpHeaders(value: DestinationOutputAzureLogsExtraHttpHeaders[] | cdktf.IResolvable) {
    this._extraHttpHeaders.internalValue = value;
  }
  public resetExtraHttpHeaders() {
    this._extraHttpHeaders.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get extraHttpHeadersInput() {
    return this._extraHttpHeaders.internalValue;
  }

  // failed_request_logging_mode - computed: true, optional: true, required: false
  private _failedRequestLoggingMode?: string; 
  public get failedRequestLoggingMode() {
    return this.getStringAttribute('failed_request_logging_mode');
  }
  public set failedRequestLoggingMode(value: string) {
    this._failedRequestLoggingMode = value;
  }
  public resetFailedRequestLoggingMode() {
    this._failedRequestLoggingMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get failedRequestLoggingModeInput() {
    return this._failedRequestLoggingMode;
  }

  // flush_period_sec - computed: true, optional: true, required: false
  private _flushPeriodSec?: number; 
  public get flushPeriodSec() {
    return this.getNumberAttribute('flush_period_sec');
  }
  public set flushPeriodSec(value: number) {
    this._flushPeriodSec = value;
  }
  public resetFlushPeriodSec() {
    this._flushPeriodSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get flushPeriodSecInput() {
    return this._flushPeriodSec;
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // keypair_secret - computed: false, optional: true, required: false
  private _keypairSecret?: string; 
  public get keypairSecret() {
    return this.getStringAttribute('keypair_secret');
  }
  public set keypairSecret(value: string) {
    this._keypairSecret = value;
  }
  public resetKeypairSecret() {
    this._keypairSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keypairSecretInput() {
    return this._keypairSecret;
  }

  // log_type - computed: true, optional: true, required: false
  private _logType?: string; 
  public get logType() {
    return this.getStringAttribute('log_type');
  }
  public set logType(value: string) {
    this._logType = value;
  }
  public resetLogType() {
    this._logType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get logTypeInput() {
    return this._logType;
  }

  // max_payload_events - computed: true, optional: true, required: false
  private _maxPayloadEvents?: number; 
  public get maxPayloadEvents() {
    return this.getNumberAttribute('max_payload_events');
  }
  public set maxPayloadEvents(value: number) {
    this._maxPayloadEvents = value;
  }
  public resetMaxPayloadEvents() {
    this._maxPayloadEvents = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxPayloadEventsInput() {
    return this._maxPayloadEvents;
  }

  // max_payload_size_kb - computed: true, optional: true, required: false
  private _maxPayloadSizeKb?: number; 
  public get maxPayloadSizeKb() {
    return this.getNumberAttribute('max_payload_size_kb');
  }
  public set maxPayloadSizeKb(value: number) {
    this._maxPayloadSizeKb = value;
  }
  public resetMaxPayloadSizeKb() {
    this._maxPayloadSizeKb = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxPayloadSizeKbInput() {
    return this._maxPayloadSizeKb;
  }

  // on_backpressure - computed: true, optional: true, required: false
  private _onBackpressure?: string; 
  public get onBackpressure() {
    return this.getStringAttribute('on_backpressure');
  }
  public set onBackpressure(value: string) {
    this._onBackpressure = value;
  }
  public resetOnBackpressure() {
    this._onBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get onBackpressureInput() {
    return this._onBackpressure;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // pq_compress - computed: true, optional: true, required: false
  private _pqCompress?: string; 
  public get pqCompress() {
    return this.getStringAttribute('pq_compress');
  }
  public set pqCompress(value: string) {
    this._pqCompress = value;
  }
  public resetPqCompress() {
    this._pqCompress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqCompressInput() {
    return this._pqCompress;
  }

  // pq_controls - computed: false, optional: true, required: false
  private _pqControls = new DestinationOutputAzureLogsPqControlsOutputReference(this, "pq_controls");
  public get pqControls() {
    return this._pqControls;
  }
  public putPqControls(value: DestinationOutputAzureLogsPqControls) {
    this._pqControls.internalValue = value;
  }
  public resetPqControls() {
    this._pqControls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqControlsInput() {
    return this._pqControls.internalValue;
  }

  // pq_max_file_size - computed: true, optional: true, required: false
  private _pqMaxFileSize?: string; 
  public get pqMaxFileSize() {
    return this.getStringAttribute('pq_max_file_size');
  }
  public set pqMaxFileSize(value: string) {
    this._pqMaxFileSize = value;
  }
  public resetPqMaxFileSize() {
    this._pqMaxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxFileSizeInput() {
    return this._pqMaxFileSize;
  }

  // pq_max_size - computed: true, optional: true, required: false
  private _pqMaxSize?: string; 
  public get pqMaxSize() {
    return this.getStringAttribute('pq_max_size');
  }
  public set pqMaxSize(value: string) {
    this._pqMaxSize = value;
  }
  public resetPqMaxSize() {
    this._pqMaxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxSizeInput() {
    return this._pqMaxSize;
  }

  // pq_mode - computed: true, optional: true, required: false
  private _pqMode?: string; 
  public get pqMode() {
    return this.getStringAttribute('pq_mode');
  }
  public set pqMode(value: string) {
    this._pqMode = value;
  }
  public resetPqMode() {
    this._pqMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqModeInput() {
    return this._pqMode;
  }

  // pq_on_backpressure - computed: true, optional: true, required: false
  private _pqOnBackpressure?: string; 
  public get pqOnBackpressure() {
    return this.getStringAttribute('pq_on_backpressure');
  }
  public set pqOnBackpressure(value: string) {
    this._pqOnBackpressure = value;
  }
  public resetPqOnBackpressure() {
    this._pqOnBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqOnBackpressureInput() {
    return this._pqOnBackpressure;
  }

  // pq_path - computed: true, optional: true, required: false
  private _pqPath?: string; 
  public get pqPath() {
    return this.getStringAttribute('pq_path');
  }
  public set pqPath(value: string) {
    this._pqPath = value;
  }
  public resetPqPath() {
    this._pqPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqPathInput() {
    return this._pqPath;
  }

  // reject_unauthorized - computed: true, optional: true, required: false
  private _rejectUnauthorized?: boolean | cdktf.IResolvable; 
  public get rejectUnauthorized() {
    return this.getBooleanAttribute('reject_unauthorized');
  }
  public set rejectUnauthorized(value: boolean | cdktf.IResolvable) {
    this._rejectUnauthorized = value;
  }
  public resetRejectUnauthorized() {
    this._rejectUnauthorized = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectUnauthorizedInput() {
    return this._rejectUnauthorized;
  }

  // resource_id - computed: false, optional: true, required: false
  private _resourceId?: string; 
  public get resourceId() {
    return this.getStringAttribute('resource_id');
  }
  public set resourceId(value: string) {
    this._resourceId = value;
  }
  public resetResourceId() {
    this._resourceId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get resourceIdInput() {
    return this._resourceId;
  }

  // response_honor_retry_after_header - computed: true, optional: true, required: false
  private _responseHonorRetryAfterHeader?: boolean | cdktf.IResolvable; 
  public get responseHonorRetryAfterHeader() {
    return this.getBooleanAttribute('response_honor_retry_after_header');
  }
  public set responseHonorRetryAfterHeader(value: boolean | cdktf.IResolvable) {
    this._responseHonorRetryAfterHeader = value;
  }
  public resetResponseHonorRetryAfterHeader() {
    this._responseHonorRetryAfterHeader = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get responseHonorRetryAfterHeaderInput() {
    return this._responseHonorRetryAfterHeader;
  }

  // response_retry_settings - computed: false, optional: true, required: false
  private _responseRetrySettings = new DestinationOutputAzureLogsResponseRetrySettingsList(this, "response_retry_settings", false);
  public get responseRetrySettings() {
    return this._responseRetrySettings;
  }
  public putResponseRetrySettings(value: DestinationOutputAzureLogsResponseRetrySettings[] | cdktf.IResolvable) {
    this._responseRetrySettings.internalValue = value;
  }
  public resetResponseRetrySettings() {
    this._responseRetrySettings.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get responseRetrySettingsInput() {
    return this._responseRetrySettings.internalValue;
  }

  // safe_headers - computed: true, optional: true, required: false
  private _safeHeaders?: string[]; 
  public get safeHeaders() {
    return this.getListAttribute('safe_headers');
  }
  public set safeHeaders(value: string[]) {
    this._safeHeaders = value;
  }
  public resetSafeHeaders() {
    this._safeHeaders = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get safeHeadersInput() {
    return this._safeHeaders;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // system_fields - computed: true, optional: true, required: false
  private _systemFields?: string[]; 
  public get systemFields() {
    return this.getListAttribute('system_fields');
  }
  public set systemFields(value: string[]) {
    this._systemFields = value;
  }
  public resetSystemFields() {
    this._systemFields = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get systemFieldsInput() {
    return this._systemFields;
  }

  // timeout_retry_settings - computed: false, optional: true, required: false
  private _timeoutRetrySettings = new DestinationOutputAzureLogsTimeoutRetrySettingsOutputReference(this, "timeout_retry_settings");
  public get timeoutRetrySettings() {
    return this._timeoutRetrySettings;
  }
  public putTimeoutRetrySettings(value: DestinationOutputAzureLogsTimeoutRetrySettings) {
    this._timeoutRetrySettings.internalValue = value;
  }
  public resetTimeoutRetrySettings() {
    this._timeoutRetrySettings.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutRetrySettingsInput() {
    return this._timeoutRetrySettings.internalValue;
  }

  // timeout_sec - computed: true, optional: true, required: false
  private _timeoutSec?: number; 
  public get timeoutSec() {
    return this.getNumberAttribute('timeout_sec');
  }
  public set timeoutSec(value: number) {
    this._timeoutSec = value;
  }
  public resetTimeoutSec() {
    this._timeoutSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutSecInput() {
    return this._timeoutSec;
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // use_round_robin_dns - computed: true, optional: true, required: false
  private _useRoundRobinDns?: boolean | cdktf.IResolvable; 
  public get useRoundRobinDns() {
    return this.getBooleanAttribute('use_round_robin_dns');
  }
  public set useRoundRobinDns(value: boolean | cdktf.IResolvable) {
    this._useRoundRobinDns = value;
  }
  public resetUseRoundRobinDns() {
    this._useRoundRobinDns = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get useRoundRobinDnsInput() {
    return this._useRoundRobinDns;
  }

  // workspace_id - computed: false, optional: true, required: false
  private _workspaceId?: string; 
  public get workspaceId() {
    return this.getStringAttribute('workspace_id');
  }
  public set workspaceId(value: string) {
    this._workspaceId = value;
  }
  public resetWorkspaceId() {
    this._workspaceId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get workspaceIdInput() {
    return this._workspaceId;
  }

  // workspace_key - computed: false, optional: true, required: false
  private _workspaceKey?: string; 
  public get workspaceKey() {
    return this.getStringAttribute('workspace_key');
  }
  public set workspaceKey(value: string) {
    this._workspaceKey = value;
  }
  public resetWorkspaceKey() {
    this._workspaceKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get workspaceKeyInput() {
    return this._workspaceKey;
  }
}
export interface DestinationOutputClickHouseColumnMappings {
  /**
  * Name of the column in ClickHouse that will store field value
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#column_name Destination#column_name}
  */
  readonly columnName: string;
  /**
  * Type of the column in the ClickHouse database
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#column_type Destination#column_type}
  */
  readonly columnType?: string;
  /**
  * JavaScript expression to compute value to be inserted into ClickHouse table
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#column_value_expression Destination#column_value_expression}
  */
  readonly columnValueExpression: string;
}

export function destinationOutputClickHouseColumnMappingsToTerraform(struct?: DestinationOutputClickHouseColumnMappings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    column_name: cdktf.stringToTerraform(struct!.columnName),
    column_type: cdktf.stringToTerraform(struct!.columnType),
    column_value_expression: cdktf.stringToTerraform(struct!.columnValueExpression),
  }
}


export function destinationOutputClickHouseColumnMappingsToHclTerraform(struct?: DestinationOutputClickHouseColumnMappings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    column_name: {
      value: cdktf.stringToHclTerraform(struct!.columnName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    column_type: {
      value: cdktf.stringToHclTerraform(struct!.columnType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    column_value_expression: {
      value: cdktf.stringToHclTerraform(struct!.columnValueExpression),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputClickHouseColumnMappingsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DestinationOutputClickHouseColumnMappings | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._columnName !== undefined) {
      hasAnyValues = true;
      internalValueResult.columnName = this._columnName;
    }
    if (this._columnType !== undefined) {
      hasAnyValues = true;
      internalValueResult.columnType = this._columnType;
    }
    if (this._columnValueExpression !== undefined) {
      hasAnyValues = true;
      internalValueResult.columnValueExpression = this._columnValueExpression;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputClickHouseColumnMappings | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._columnName = undefined;
      this._columnType = undefined;
      this._columnValueExpression = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._columnName = value.columnName;
      this._columnType = value.columnType;
      this._columnValueExpression = value.columnValueExpression;
    }
  }

  // column_name - computed: false, optional: false, required: true
  private _columnName?: string; 
  public get columnName() {
    return this.getStringAttribute('column_name');
  }
  public set columnName(value: string) {
    this._columnName = value;
  }
  // Temporarily expose input value. Use with caution.
  public get columnNameInput() {
    return this._columnName;
  }

  // column_type - computed: false, optional: true, required: false
  private _columnType?: string; 
  public get columnType() {
    return this.getStringAttribute('column_type');
  }
  public set columnType(value: string) {
    this._columnType = value;
  }
  public resetColumnType() {
    this._columnType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get columnTypeInput() {
    return this._columnType;
  }

  // column_value_expression - computed: false, optional: false, required: true
  private _columnValueExpression?: string; 
  public get columnValueExpression() {
    return this.getStringAttribute('column_value_expression');
  }
  public set columnValueExpression(value: string) {
    this._columnValueExpression = value;
  }
  // Temporarily expose input value. Use with caution.
  public get columnValueExpressionInput() {
    return this._columnValueExpression;
  }
}

export class DestinationOutputClickHouseColumnMappingsList extends cdktf.ComplexList {
  public internalValue? : DestinationOutputClickHouseColumnMappings[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DestinationOutputClickHouseColumnMappingsOutputReference {
    return new DestinationOutputClickHouseColumnMappingsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DestinationOutputClickHouseExtraHttpHeaders {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#name Destination#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#value Destination#value}
  */
  readonly value: string;
}

export function destinationOutputClickHouseExtraHttpHeadersToTerraform(struct?: DestinationOutputClickHouseExtraHttpHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function destinationOutputClickHouseExtraHttpHeadersToHclTerraform(struct?: DestinationOutputClickHouseExtraHttpHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputClickHouseExtraHttpHeadersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DestinationOutputClickHouseExtraHttpHeaders | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputClickHouseExtraHttpHeaders | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DestinationOutputClickHouseExtraHttpHeadersList extends cdktf.ComplexList {
  public internalValue? : DestinationOutputClickHouseExtraHttpHeaders[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DestinationOutputClickHouseExtraHttpHeadersOutputReference {
    return new DestinationOutputClickHouseExtraHttpHeadersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DestinationOutputClickHouseOauthHeaders {
  /**
  * OAuth header name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#name Destination#name}
  */
  readonly name: string;
  /**
  * OAuth header value
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#value Destination#value}
  */
  readonly value: string;
}

export function destinationOutputClickHouseOauthHeadersToTerraform(struct?: DestinationOutputClickHouseOauthHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function destinationOutputClickHouseOauthHeadersToHclTerraform(struct?: DestinationOutputClickHouseOauthHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputClickHouseOauthHeadersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DestinationOutputClickHouseOauthHeaders | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputClickHouseOauthHeaders | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DestinationOutputClickHouseOauthHeadersList extends cdktf.ComplexList {
  public internalValue? : DestinationOutputClickHouseOauthHeaders[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DestinationOutputClickHouseOauthHeadersOutputReference {
    return new DestinationOutputClickHouseOauthHeadersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DestinationOutputClickHouseOauthParams {
  /**
  * OAuth parameter name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#name Destination#name}
  */
  readonly name: string;
  /**
  * OAuth parameter value
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#value Destination#value}
  */
  readonly value: string;
}

export function destinationOutputClickHouseOauthParamsToTerraform(struct?: DestinationOutputClickHouseOauthParams | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function destinationOutputClickHouseOauthParamsToHclTerraform(struct?: DestinationOutputClickHouseOauthParams | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputClickHouseOauthParamsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DestinationOutputClickHouseOauthParams | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputClickHouseOauthParams | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DestinationOutputClickHouseOauthParamsList extends cdktf.ComplexList {
  public internalValue? : DestinationOutputClickHouseOauthParams[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DestinationOutputClickHouseOauthParamsOutputReference {
    return new DestinationOutputClickHouseOauthParamsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DestinationOutputClickHousePqControls {
}

export function destinationOutputClickHousePqControlsToTerraform(struct?: DestinationOutputClickHousePqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function destinationOutputClickHousePqControlsToHclTerraform(struct?: DestinationOutputClickHousePqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class DestinationOutputClickHousePqControlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DestinationOutputClickHousePqControls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputClickHousePqControls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface DestinationOutputClickHouseResponseRetrySettings {
  /**
  * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc. Default: 2
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#backoff_rate Destination#backoff_rate}
  */
  readonly backoffRate?: number;
  /**
  * The HTTP response status code that will trigger retries
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#http_status Destination#http_status}
  */
  readonly httpStatus: number;
  /**
  * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes). Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#initial_backoff Destination#initial_backoff}
  */
  readonly initialBackoff?: number;
  /**
  * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds). Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#max_backoff Destination#max_backoff}
  */
  readonly maxBackoff?: number;
}

export function destinationOutputClickHouseResponseRetrySettingsToTerraform(struct?: DestinationOutputClickHouseResponseRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    backoff_rate: cdktf.numberToTerraform(struct!.backoffRate),
    http_status: cdktf.numberToTerraform(struct!.httpStatus),
    initial_backoff: cdktf.numberToTerraform(struct!.initialBackoff),
    max_backoff: cdktf.numberToTerraform(struct!.maxBackoff),
  }
}


export function destinationOutputClickHouseResponseRetrySettingsToHclTerraform(struct?: DestinationOutputClickHouseResponseRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    backoff_rate: {
      value: cdktf.numberToHclTerraform(struct!.backoffRate),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    http_status: {
      value: cdktf.numberToHclTerraform(struct!.httpStatus),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    initial_backoff: {
      value: cdktf.numberToHclTerraform(struct!.initialBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_backoff: {
      value: cdktf.numberToHclTerraform(struct!.maxBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputClickHouseResponseRetrySettingsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DestinationOutputClickHouseResponseRetrySettings | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._backoffRate !== undefined) {
      hasAnyValues = true;
      internalValueResult.backoffRate = this._backoffRate;
    }
    if (this._httpStatus !== undefined) {
      hasAnyValues = true;
      internalValueResult.httpStatus = this._httpStatus;
    }
    if (this._initialBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.initialBackoff = this._initialBackoff;
    }
    if (this._maxBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBackoff = this._maxBackoff;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputClickHouseResponseRetrySettings | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._backoffRate = undefined;
      this._httpStatus = undefined;
      this._initialBackoff = undefined;
      this._maxBackoff = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._backoffRate = value.backoffRate;
      this._httpStatus = value.httpStatus;
      this._initialBackoff = value.initialBackoff;
      this._maxBackoff = value.maxBackoff;
    }
  }

  // backoff_rate - computed: true, optional: true, required: false
  private _backoffRate?: number; 
  public get backoffRate() {
    return this.getNumberAttribute('backoff_rate');
  }
  public set backoffRate(value: number) {
    this._backoffRate = value;
  }
  public resetBackoffRate() {
    this._backoffRate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get backoffRateInput() {
    return this._backoffRate;
  }

  // http_status - computed: false, optional: false, required: true
  private _httpStatus?: number; 
  public get httpStatus() {
    return this.getNumberAttribute('http_status');
  }
  public set httpStatus(value: number) {
    this._httpStatus = value;
  }
  // Temporarily expose input value. Use with caution.
  public get httpStatusInput() {
    return this._httpStatus;
  }

  // initial_backoff - computed: true, optional: true, required: false
  private _initialBackoff?: number; 
  public get initialBackoff() {
    return this.getNumberAttribute('initial_backoff');
  }
  public set initialBackoff(value: number) {
    this._initialBackoff = value;
  }
  public resetInitialBackoff() {
    this._initialBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get initialBackoffInput() {
    return this._initialBackoff;
  }

  // max_backoff - computed: true, optional: true, required: false
  private _maxBackoff?: number; 
  public get maxBackoff() {
    return this.getNumberAttribute('max_backoff');
  }
  public set maxBackoff(value: number) {
    this._maxBackoff = value;
  }
  public resetMaxBackoff() {
    this._maxBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBackoffInput() {
    return this._maxBackoff;
  }
}

export class DestinationOutputClickHouseResponseRetrySettingsList extends cdktf.ComplexList {
  public internalValue? : DestinationOutputClickHouseResponseRetrySettings[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DestinationOutputClickHouseResponseRetrySettingsOutputReference {
    return new DestinationOutputClickHouseResponseRetrySettingsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DestinationOutputClickHouseTimeoutRetrySettings {
  /**
  * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc. Default: 2
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#backoff_rate Destination#backoff_rate}
  */
  readonly backoffRate?: number;
  /**
  * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes). Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#initial_backoff Destination#initial_backoff}
  */
  readonly initialBackoff?: number;
  /**
  * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds). Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#max_backoff Destination#max_backoff}
  */
  readonly maxBackoff?: number;
  /**
  * Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#timeout_retry Destination#timeout_retry}
  */
  readonly timeoutRetry?: boolean | cdktf.IResolvable;
}

export function destinationOutputClickHouseTimeoutRetrySettingsToTerraform(struct?: DestinationOutputClickHouseTimeoutRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    backoff_rate: cdktf.numberToTerraform(struct!.backoffRate),
    initial_backoff: cdktf.numberToTerraform(struct!.initialBackoff),
    max_backoff: cdktf.numberToTerraform(struct!.maxBackoff),
    timeout_retry: cdktf.booleanToTerraform(struct!.timeoutRetry),
  }
}


export function destinationOutputClickHouseTimeoutRetrySettingsToHclTerraform(struct?: DestinationOutputClickHouseTimeoutRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    backoff_rate: {
      value: cdktf.numberToHclTerraform(struct!.backoffRate),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    initial_backoff: {
      value: cdktf.numberToHclTerraform(struct!.initialBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_backoff: {
      value: cdktf.numberToHclTerraform(struct!.maxBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    timeout_retry: {
      value: cdktf.booleanToHclTerraform(struct!.timeoutRetry),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputClickHouseTimeoutRetrySettingsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DestinationOutputClickHouseTimeoutRetrySettings | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._backoffRate !== undefined) {
      hasAnyValues = true;
      internalValueResult.backoffRate = this._backoffRate;
    }
    if (this._initialBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.initialBackoff = this._initialBackoff;
    }
    if (this._maxBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBackoff = this._maxBackoff;
    }
    if (this._timeoutRetry !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutRetry = this._timeoutRetry;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputClickHouseTimeoutRetrySettings | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._backoffRate = undefined;
      this._initialBackoff = undefined;
      this._maxBackoff = undefined;
      this._timeoutRetry = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._backoffRate = value.backoffRate;
      this._initialBackoff = value.initialBackoff;
      this._maxBackoff = value.maxBackoff;
      this._timeoutRetry = value.timeoutRetry;
    }
  }

  // backoff_rate - computed: true, optional: true, required: false
  private _backoffRate?: number; 
  public get backoffRate() {
    return this.getNumberAttribute('backoff_rate');
  }
  public set backoffRate(value: number) {
    this._backoffRate = value;
  }
  public resetBackoffRate() {
    this._backoffRate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get backoffRateInput() {
    return this._backoffRate;
  }

  // initial_backoff - computed: true, optional: true, required: false
  private _initialBackoff?: number; 
  public get initialBackoff() {
    return this.getNumberAttribute('initial_backoff');
  }
  public set initialBackoff(value: number) {
    this._initialBackoff = value;
  }
  public resetInitialBackoff() {
    this._initialBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get initialBackoffInput() {
    return this._initialBackoff;
  }

  // max_backoff - computed: true, optional: true, required: false
  private _maxBackoff?: number; 
  public get maxBackoff() {
    return this.getNumberAttribute('max_backoff');
  }
  public set maxBackoff(value: number) {
    this._maxBackoff = value;
  }
  public resetMaxBackoff() {
    this._maxBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBackoffInput() {
    return this._maxBackoff;
  }

  // timeout_retry - computed: true, optional: true, required: false
  private _timeoutRetry?: boolean | cdktf.IResolvable; 
  public get timeoutRetry() {
    return this.getBooleanAttribute('timeout_retry');
  }
  public set timeoutRetry(value: boolean | cdktf.IResolvable) {
    this._timeoutRetry = value;
  }
  public resetTimeoutRetry() {
    this._timeoutRetry = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutRetryInput() {
    return this._timeoutRetry;
  }
}
export interface DestinationOutputClickHouseTls {
  /**
  * Path on client in which to find CA certificates to verify the server's cert. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#ca_path Destination#ca_path}
  */
  readonly caPath?: string;
  /**
  * Path on client in which to find certificates to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#cert_path Destination#cert_path}
  */
  readonly certPath?: string;
  /**
  * The name of the predefined certificate
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#certificate_name Destination#certificate_name}
  */
  readonly certificateName?: string;
  /**
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#disabled Destination#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#max_version Destination#max_version}
  */
  readonly maxVersion?: string;
  /**
  * must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#min_version Destination#min_version}
  */
  readonly minVersion?: string;
  /**
  * Passphrase to use to decrypt private key
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#passphrase Destination#passphrase}
  */
  readonly passphrase?: string;
  /**
  * Path on client in which to find the private key to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#priv_key_path Destination#priv_key_path}
  */
  readonly privKeyPath?: string;
  /**
  * Server name for the SNI (Server Name Indication) TLS extension. It must be a host name, and not an IP address.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#servername Destination#servername}
  */
  readonly servername?: string;
}

export function destinationOutputClickHouseTlsToTerraform(struct?: DestinationOutputClickHouseTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ca_path: cdktf.stringToTerraform(struct!.caPath),
    cert_path: cdktf.stringToTerraform(struct!.certPath),
    certificate_name: cdktf.stringToTerraform(struct!.certificateName),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    max_version: cdktf.stringToTerraform(struct!.maxVersion),
    min_version: cdktf.stringToTerraform(struct!.minVersion),
    passphrase: cdktf.stringToTerraform(struct!.passphrase),
    priv_key_path: cdktf.stringToTerraform(struct!.privKeyPath),
    servername: cdktf.stringToTerraform(struct!.servername),
  }
}


export function destinationOutputClickHouseTlsToHclTerraform(struct?: DestinationOutputClickHouseTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ca_path: {
      value: cdktf.stringToHclTerraform(struct!.caPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    cert_path: {
      value: cdktf.stringToHclTerraform(struct!.certPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    certificate_name: {
      value: cdktf.stringToHclTerraform(struct!.certificateName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    max_version: {
      value: cdktf.stringToHclTerraform(struct!.maxVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    min_version: {
      value: cdktf.stringToHclTerraform(struct!.minVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    passphrase: {
      value: cdktf.stringToHclTerraform(struct!.passphrase),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    priv_key_path: {
      value: cdktf.stringToHclTerraform(struct!.privKeyPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    servername: {
      value: cdktf.stringToHclTerraform(struct!.servername),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputClickHouseTlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DestinationOutputClickHouseTls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._caPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.caPath = this._caPath;
    }
    if (this._certPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.certPath = this._certPath;
    }
    if (this._certificateName !== undefined) {
      hasAnyValues = true;
      internalValueResult.certificateName = this._certificateName;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._maxVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxVersion = this._maxVersion;
    }
    if (this._minVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.minVersion = this._minVersion;
    }
    if (this._passphrase !== undefined) {
      hasAnyValues = true;
      internalValueResult.passphrase = this._passphrase;
    }
    if (this._privKeyPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.privKeyPath = this._privKeyPath;
    }
    if (this._servername !== undefined) {
      hasAnyValues = true;
      internalValueResult.servername = this._servername;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputClickHouseTls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._caPath = undefined;
      this._certPath = undefined;
      this._certificateName = undefined;
      this._disabled = undefined;
      this._maxVersion = undefined;
      this._minVersion = undefined;
      this._passphrase = undefined;
      this._privKeyPath = undefined;
      this._servername = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._caPath = value.caPath;
      this._certPath = value.certPath;
      this._certificateName = value.certificateName;
      this._disabled = value.disabled;
      this._maxVersion = value.maxVersion;
      this._minVersion = value.minVersion;
      this._passphrase = value.passphrase;
      this._privKeyPath = value.privKeyPath;
      this._servername = value.servername;
    }
  }

  // ca_path - computed: false, optional: true, required: false
  private _caPath?: string; 
  public get caPath() {
    return this.getStringAttribute('ca_path');
  }
  public set caPath(value: string) {
    this._caPath = value;
  }
  public resetCaPath() {
    this._caPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get caPathInput() {
    return this._caPath;
  }

  // cert_path - computed: false, optional: true, required: false
  private _certPath?: string; 
  public get certPath() {
    return this.getStringAttribute('cert_path');
  }
  public set certPath(value: string) {
    this._certPath = value;
  }
  public resetCertPath() {
    this._certPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certPathInput() {
    return this._certPath;
  }

  // certificate_name - computed: false, optional: true, required: false
  private _certificateName?: string; 
  public get certificateName() {
    return this.getStringAttribute('certificate_name');
  }
  public set certificateName(value: string) {
    this._certificateName = value;
  }
  public resetCertificateName() {
    this._certificateName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certificateNameInput() {
    return this._certificateName;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // max_version - computed: false, optional: true, required: false
  private _maxVersion?: string; 
  public get maxVersion() {
    return this.getStringAttribute('max_version');
  }
  public set maxVersion(value: string) {
    this._maxVersion = value;
  }
  public resetMaxVersion() {
    this._maxVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxVersionInput() {
    return this._maxVersion;
  }

  // min_version - computed: false, optional: true, required: false
  private _minVersion?: string; 
  public get minVersion() {
    return this.getStringAttribute('min_version');
  }
  public set minVersion(value: string) {
    this._minVersion = value;
  }
  public resetMinVersion() {
    this._minVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get minVersionInput() {
    return this._minVersion;
  }

  // passphrase - computed: false, optional: true, required: false
  private _passphrase?: string; 
  public get passphrase() {
    return this.getStringAttribute('passphrase');
  }
  public set passphrase(value: string) {
    this._passphrase = value;
  }
  public resetPassphrase() {
    this._passphrase = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passphraseInput() {
    return this._passphrase;
  }

  // priv_key_path - computed: false, optional: true, required: false
  private _privKeyPath?: string; 
  public get privKeyPath() {
    return this.getStringAttribute('priv_key_path');
  }
  public set privKeyPath(value: string) {
    this._privKeyPath = value;
  }
  public resetPrivKeyPath() {
    this._privKeyPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get privKeyPathInput() {
    return this._privKeyPath;
  }

  // servername - computed: false, optional: true, required: false
  private _servername?: string; 
  public get servername() {
    return this.getStringAttribute('servername');
  }
  public set servername(value: string) {
    this._servername = value;
  }
  public resetServername() {
    this._servername = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get servernameInput() {
    return this._servername;
  }
}
export interface DestinationOutputClickHouse {
  /**
  * Collect data into batches for later processing. Disable to write to a ClickHouse table immediately. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#async_inserts Destination#async_inserts}
  */
  readonly asyncInserts?: boolean | cdktf.IResolvable;
  /**
  * JavaScript expression to compute the Authorization header value to pass in requests. The value `${token}` is used to reference the token obtained from authentication, e.g.: `Bearer ${token}`. Default: "`Bearer ${token}`"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#auth_header_expr Destination#auth_header_expr}
  */
  readonly authHeaderExpr?: string;
  /**
  * Default: "none"; must be one of ["none", "basic", "credentialsSecret", "sslUserCertificate", "token", "textSecret", "oauth"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#auth_type Destination#auth_type}
  */
  readonly authType?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#column_mappings Destination#column_mappings}
  */
  readonly columnMappings?: DestinationOutputClickHouseColumnMappings[] | cdktf.IResolvable;
  /**
  * Compress the payload body before sending. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#compress Destination#compress}
  */
  readonly compress?: boolean | cdktf.IResolvable;
  /**
  * Maximum number of ongoing requests before blocking. Default: 5
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#concurrency Destination#concurrency}
  */
  readonly concurrency?: number;
  /**
  * Select or create a secret that references your credentials
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#credentials_secret Destination#credentials_secret}
  */
  readonly credentialsSecret?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#database Destination#database}
  */
  readonly database: string;
  /**
  * Retrieves the table schema from ClickHouse and populates the Column Mapping table
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#describe_table Destination#describe_table}
  */
  readonly describeTable?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#description Destination#description}
  */
  readonly description?: string;
  /**
  * Log the most recent event that fails to match the table schema. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#dump_format_errors_to_disk Destination#dump_format_errors_to_disk}
  */
  readonly dumpFormatErrorsToDisk?: boolean | cdktf.IResolvable;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#environment Destination#environment}
  */
  readonly environment?: string;
  /**
  * Fields to exclude from sending to ClickHouse. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#exclude_mapping_fields Destination#exclude_mapping_fields}
  */
  readonly excludeMappingFields?: string[];
  /**
  * Headers to add to all events
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#extra_http_headers Destination#extra_http_headers}
  */
  readonly extraHttpHeaders?: DestinationOutputClickHouseExtraHttpHeaders[] | cdktf.IResolvable;
  /**
  * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below. Default: "none"; must be one of ["payload", "payloadAndHeaders", "none"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#failed_request_logging_mode Destination#failed_request_logging_mode}
  */
  readonly failedRequestLoggingMode?: string;
  /**
  * Maximum time between requests. Small values could cause the payload size to be smaller than the configured Body size limit. Default: 1
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#flush_period_sec Destination#flush_period_sec}
  */
  readonly flushPeriodSec?: number;
  /**
  * Data format to use when sending data to ClickHouse. Defaults to JSON Compact. Default: "json-compact-each-row-with-names"; must be one of ["json-compact-each-row-with-names", "json-each-row"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#format Destination#format}
  */
  readonly format?: string;
  /**
  * Unique ID for this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#id Destination#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * URL for OAuth
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#login_url Destination#login_url}
  */
  readonly loginUrl?: string;
  /**
  * How event fields are mapped to ClickHouse columns. Default: "automatic"; must be one of ["automatic", "custom"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#mapping_type Destination#mapping_type}
  */
  readonly mappingType?: string;
  /**
  * Maximum number of events to include in the request body. Default is 0 (unlimited). Default: 0
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#max_payload_events Destination#max_payload_events}
  */
  readonly maxPayloadEvents?: number;
  /**
  * Maximum size, in KB, of the request body. Default: 4096
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#max_payload_size_kb Destination#max_payload_size_kb}
  */
  readonly maxPayloadSizeKb?: number;
  /**
  * Additional headers to send in the OAuth login request. @{product} will automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#oauth_headers Destination#oauth_headers}
  */
  readonly oauthHeaders?: DestinationOutputClickHouseOauthHeaders[] | cdktf.IResolvable;
  /**
  * Additional parameters to send in the OAuth login request. @{product} will combine the secret with these parameters, and will send the URL-encoded result in a POST request to the endpoint specified in the 'Login URL'. We'll automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#oauth_params Destination#oauth_params}
  */
  readonly oauthParams?: DestinationOutputClickHouseOauthParams[] | cdktf.IResolvable;
  /**
  * How to handle events when all receivers are exerting backpressure. Default: "block"; must be one of ["block", "drop", "queue"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#on_backpressure Destination#on_backpressure}
  */
  readonly onBackpressure?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#password Destination#password}
  */
  readonly password?: string;
  /**
  * Pipeline to process data before sending out to this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pipeline Destination#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pq_compress Destination#pq_compress}
  */
  readonly pqCompress?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pq_controls Destination#pq_controls}
  */
  readonly pqControls?: DestinationOutputClickHousePqControls;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.). Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pq_max_file_size Destination#pq_max_file_size}
  */
  readonly pqMaxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pq_max_size Destination#pq_max_size}
  */
  readonly pqMaxSize?: string;
  /**
  * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem. Default: "error"; must be one of ["error", "backpressure", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pq_mode Destination#pq_mode}
  */
  readonly pqMode?: string;
  /**
  * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged. Default: "block"; must be one of ["block", "drop"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pq_on_backpressure Destination#pq_on_backpressure}
  */
  readonly pqOnBackpressure?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pq_path Destination#pq_path}
  */
  readonly pqPath?: string;
  /**
  * Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's).
  * 
  * 
  *         Enabled by default. When this setting is also present in TLS Settings (Client Side),
  *         that value will take precedence.
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#reject_unauthorized Destination#reject_unauthorized}
  */
  readonly rejectUnauthorized?: boolean | cdktf.IResolvable;
  /**
  * Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#response_honor_retry_after_header Destination#response_honor_retry_after_header}
  */
  readonly responseHonorRetryAfterHeader?: boolean | cdktf.IResolvable;
  /**
  * Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#response_retry_settings Destination#response_retry_settings}
  */
  readonly responseRetrySettings?: DestinationOutputClickHouseResponseRetrySettings[] | cdktf.IResolvable;
  /**
  * List of headers that are safe to log in plain text. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#safe_headers Destination#safe_headers}
  */
  readonly safeHeaders?: string[];
  /**
  * Secret parameter value to pass in request body
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#secret Destination#secret}
  */
  readonly secret?: string;
  /**
  * Secret parameter name to pass in request body
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#secret_param_name Destination#secret_param_name}
  */
  readonly secretParamName?: string;
  /**
  * Username for certificate authentication
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#sql_username Destination#sql_username}
  */
  readonly sqlUsername?: string;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#streamtags Destination#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Fields to automatically add to events, such as cribl_pipe. Supports wildcards. Default: ["cribl_pipe"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#system_fields Destination#system_fields}
  */
  readonly systemFields?: string[];
  /**
  * Name of the ClickHouse table where data will be inserted. Name can contain letters (A-Z, a-z), numbers (0-9), and the character "_", and must start with either a letter or the character "_".
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#table_name Destination#table_name}
  */
  readonly tableName: string;
  /**
  * Select or create a stored text secret
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#text_secret Destination#text_secret}
  */
  readonly textSecret?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#timeout_retry_settings Destination#timeout_retry_settings}
  */
  readonly timeoutRetrySettings?: DestinationOutputClickHouseTimeoutRetrySettings;
  /**
  * Amount of time, in seconds, to wait for a request to complete before canceling it. Default: 30
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#timeout_sec Destination#timeout_sec}
  */
  readonly timeoutSec?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#tls Destination#tls}
  */
  readonly tls?: DestinationOutputClickHouseTls;
  /**
  * Bearer token to include in the authorization header
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#token Destination#token}
  */
  readonly token?: string;
  /**
  * Name of the auth token attribute in the OAuth response. Can be top-level (e.g., 'token'); or nested, using a period (e.g., 'data.token').
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#token_attribute_name Destination#token_attribute_name}
  */
  readonly tokenAttributeName?: string;
  /**
  * How often the OAuth token should be refreshed. Default: 3600
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#token_timeout_secs Destination#token_timeout_secs}
  */
  readonly tokenTimeoutSecs?: number;
  /**
  * must be "click_house"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#type Destination#type}
  */
  readonly type?: string;
  /**
  * URL of the ClickHouse instance. Example: http://localhost:8123/
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#url Destination#url}
  */
  readonly url: string;
  /**
  * Enable round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. For optimal performance, consider enabling this setting for non-load balanced destinations. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#use_round_robin_dns Destination#use_round_robin_dns}
  */
  readonly useRoundRobinDns?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#username Destination#username}
  */
  readonly username?: string;
  /**
  * Cribl will wait for confirmation that data has been fully inserted into the ClickHouse database before proceeding. Disabling this option can increase throughput, but Cribl won’t be able to verify data has been completely inserted. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#wait_for_async_inserts Destination#wait_for_async_inserts}
  */
  readonly waitForAsyncInserts?: boolean | cdktf.IResolvable;
}

export function destinationOutputClickHouseToTerraform(struct?: DestinationOutputClickHouse | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    async_inserts: cdktf.booleanToTerraform(struct!.asyncInserts),
    auth_header_expr: cdktf.stringToTerraform(struct!.authHeaderExpr),
    auth_type: cdktf.stringToTerraform(struct!.authType),
    column_mappings: cdktf.listMapper(destinationOutputClickHouseColumnMappingsToTerraform, false)(struct!.columnMappings),
    compress: cdktf.booleanToTerraform(struct!.compress),
    concurrency: cdktf.numberToTerraform(struct!.concurrency),
    credentials_secret: cdktf.stringToTerraform(struct!.credentialsSecret),
    database: cdktf.stringToTerraform(struct!.database),
    describe_table: cdktf.stringToTerraform(struct!.describeTable),
    description: cdktf.stringToTerraform(struct!.description),
    dump_format_errors_to_disk: cdktf.booleanToTerraform(struct!.dumpFormatErrorsToDisk),
    environment: cdktf.stringToTerraform(struct!.environment),
    exclude_mapping_fields: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.excludeMappingFields),
    extra_http_headers: cdktf.listMapper(destinationOutputClickHouseExtraHttpHeadersToTerraform, false)(struct!.extraHttpHeaders),
    failed_request_logging_mode: cdktf.stringToTerraform(struct!.failedRequestLoggingMode),
    flush_period_sec: cdktf.numberToTerraform(struct!.flushPeriodSec),
    format: cdktf.stringToTerraform(struct!.format),
    id: cdktf.stringToTerraform(struct!.id),
    login_url: cdktf.stringToTerraform(struct!.loginUrl),
    mapping_type: cdktf.stringToTerraform(struct!.mappingType),
    max_payload_events: cdktf.numberToTerraform(struct!.maxPayloadEvents),
    max_payload_size_kb: cdktf.numberToTerraform(struct!.maxPayloadSizeKb),
    oauth_headers: cdktf.listMapper(destinationOutputClickHouseOauthHeadersToTerraform, false)(struct!.oauthHeaders),
    oauth_params: cdktf.listMapper(destinationOutputClickHouseOauthParamsToTerraform, false)(struct!.oauthParams),
    on_backpressure: cdktf.stringToTerraform(struct!.onBackpressure),
    password: cdktf.stringToTerraform(struct!.password),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    pq_compress: cdktf.stringToTerraform(struct!.pqCompress),
    pq_controls: destinationOutputClickHousePqControlsToTerraform(struct!.pqControls),
    pq_max_file_size: cdktf.stringToTerraform(struct!.pqMaxFileSize),
    pq_max_size: cdktf.stringToTerraform(struct!.pqMaxSize),
    pq_mode: cdktf.stringToTerraform(struct!.pqMode),
    pq_on_backpressure: cdktf.stringToTerraform(struct!.pqOnBackpressure),
    pq_path: cdktf.stringToTerraform(struct!.pqPath),
    reject_unauthorized: cdktf.booleanToTerraform(struct!.rejectUnauthorized),
    response_honor_retry_after_header: cdktf.booleanToTerraform(struct!.responseHonorRetryAfterHeader),
    response_retry_settings: cdktf.listMapper(destinationOutputClickHouseResponseRetrySettingsToTerraform, false)(struct!.responseRetrySettings),
    safe_headers: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.safeHeaders),
    secret: cdktf.stringToTerraform(struct!.secret),
    secret_param_name: cdktf.stringToTerraform(struct!.secretParamName),
    sql_username: cdktf.stringToTerraform(struct!.sqlUsername),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    system_fields: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.systemFields),
    table_name: cdktf.stringToTerraform(struct!.tableName),
    text_secret: cdktf.stringToTerraform(struct!.textSecret),
    timeout_retry_settings: destinationOutputClickHouseTimeoutRetrySettingsToTerraform(struct!.timeoutRetrySettings),
    timeout_sec: cdktf.numberToTerraform(struct!.timeoutSec),
    tls: destinationOutputClickHouseTlsToTerraform(struct!.tls),
    token: cdktf.stringToTerraform(struct!.token),
    token_attribute_name: cdktf.stringToTerraform(struct!.tokenAttributeName),
    token_timeout_secs: cdktf.numberToTerraform(struct!.tokenTimeoutSecs),
    type: cdktf.stringToTerraform(struct!.type),
    url: cdktf.stringToTerraform(struct!.url),
    use_round_robin_dns: cdktf.booleanToTerraform(struct!.useRoundRobinDns),
    username: cdktf.stringToTerraform(struct!.username),
    wait_for_async_inserts: cdktf.booleanToTerraform(struct!.waitForAsyncInserts),
  }
}


export function destinationOutputClickHouseToHclTerraform(struct?: DestinationOutputClickHouse | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    async_inserts: {
      value: cdktf.booleanToHclTerraform(struct!.asyncInserts),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    auth_header_expr: {
      value: cdktf.stringToHclTerraform(struct!.authHeaderExpr),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    auth_type: {
      value: cdktf.stringToHclTerraform(struct!.authType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    column_mappings: {
      value: cdktf.listMapperHcl(destinationOutputClickHouseColumnMappingsToHclTerraform, false)(struct!.columnMappings),
      isBlock: true,
      type: "list",
      storageClassType: "DestinationOutputClickHouseColumnMappingsList",
    },
    compress: {
      value: cdktf.booleanToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    concurrency: {
      value: cdktf.numberToHclTerraform(struct!.concurrency),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    credentials_secret: {
      value: cdktf.stringToHclTerraform(struct!.credentialsSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    database: {
      value: cdktf.stringToHclTerraform(struct!.database),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    describe_table: {
      value: cdktf.stringToHclTerraform(struct!.describeTable),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    dump_format_errors_to_disk: {
      value: cdktf.booleanToHclTerraform(struct!.dumpFormatErrorsToDisk),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    exclude_mapping_fields: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.excludeMappingFields),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    extra_http_headers: {
      value: cdktf.listMapperHcl(destinationOutputClickHouseExtraHttpHeadersToHclTerraform, false)(struct!.extraHttpHeaders),
      isBlock: true,
      type: "list",
      storageClassType: "DestinationOutputClickHouseExtraHttpHeadersList",
    },
    failed_request_logging_mode: {
      value: cdktf.stringToHclTerraform(struct!.failedRequestLoggingMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    flush_period_sec: {
      value: cdktf.numberToHclTerraform(struct!.flushPeriodSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    format: {
      value: cdktf.stringToHclTerraform(struct!.format),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    login_url: {
      value: cdktf.stringToHclTerraform(struct!.loginUrl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    mapping_type: {
      value: cdktf.stringToHclTerraform(struct!.mappingType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_payload_events: {
      value: cdktf.numberToHclTerraform(struct!.maxPayloadEvents),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_payload_size_kb: {
      value: cdktf.numberToHclTerraform(struct!.maxPayloadSizeKb),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    oauth_headers: {
      value: cdktf.listMapperHcl(destinationOutputClickHouseOauthHeadersToHclTerraform, false)(struct!.oauthHeaders),
      isBlock: true,
      type: "list",
      storageClassType: "DestinationOutputClickHouseOauthHeadersList",
    },
    oauth_params: {
      value: cdktf.listMapperHcl(destinationOutputClickHouseOauthParamsToHclTerraform, false)(struct!.oauthParams),
      isBlock: true,
      type: "list",
      storageClassType: "DestinationOutputClickHouseOauthParamsList",
    },
    on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.onBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    password: {
      value: cdktf.stringToHclTerraform(struct!.password),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_compress: {
      value: cdktf.stringToHclTerraform(struct!.pqCompress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_controls: {
      value: destinationOutputClickHousePqControlsToHclTerraform(struct!.pqControls),
      isBlock: true,
      type: "struct",
      storageClassType: "DestinationOutputClickHousePqControls",
    },
    pq_max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_max_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_mode: {
      value: cdktf.stringToHclTerraform(struct!.pqMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.pqOnBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_path: {
      value: cdktf.stringToHclTerraform(struct!.pqPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reject_unauthorized: {
      value: cdktf.booleanToHclTerraform(struct!.rejectUnauthorized),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    response_honor_retry_after_header: {
      value: cdktf.booleanToHclTerraform(struct!.responseHonorRetryAfterHeader),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    response_retry_settings: {
      value: cdktf.listMapperHcl(destinationOutputClickHouseResponseRetrySettingsToHclTerraform, false)(struct!.responseRetrySettings),
      isBlock: true,
      type: "list",
      storageClassType: "DestinationOutputClickHouseResponseRetrySettingsList",
    },
    safe_headers: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.safeHeaders),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    secret: {
      value: cdktf.stringToHclTerraform(struct!.secret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_param_name: {
      value: cdktf.stringToHclTerraform(struct!.secretParamName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    sql_username: {
      value: cdktf.stringToHclTerraform(struct!.sqlUsername),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    system_fields: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.systemFields),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    table_name: {
      value: cdktf.stringToHclTerraform(struct!.tableName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    text_secret: {
      value: cdktf.stringToHclTerraform(struct!.textSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    timeout_retry_settings: {
      value: destinationOutputClickHouseTimeoutRetrySettingsToHclTerraform(struct!.timeoutRetrySettings),
      isBlock: true,
      type: "struct",
      storageClassType: "DestinationOutputClickHouseTimeoutRetrySettings",
    },
    timeout_sec: {
      value: cdktf.numberToHclTerraform(struct!.timeoutSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    tls: {
      value: destinationOutputClickHouseTlsToHclTerraform(struct!.tls),
      isBlock: true,
      type: "struct",
      storageClassType: "DestinationOutputClickHouseTls",
    },
    token: {
      value: cdktf.stringToHclTerraform(struct!.token),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    token_attribute_name: {
      value: cdktf.stringToHclTerraform(struct!.tokenAttributeName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    token_timeout_secs: {
      value: cdktf.numberToHclTerraform(struct!.tokenTimeoutSecs),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    url: {
      value: cdktf.stringToHclTerraform(struct!.url),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    use_round_robin_dns: {
      value: cdktf.booleanToHclTerraform(struct!.useRoundRobinDns),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    username: {
      value: cdktf.stringToHclTerraform(struct!.username),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    wait_for_async_inserts: {
      value: cdktf.booleanToHclTerraform(struct!.waitForAsyncInserts),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputClickHouseOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DestinationOutputClickHouse | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._asyncInserts !== undefined) {
      hasAnyValues = true;
      internalValueResult.asyncInserts = this._asyncInserts;
    }
    if (this._authHeaderExpr !== undefined) {
      hasAnyValues = true;
      internalValueResult.authHeaderExpr = this._authHeaderExpr;
    }
    if (this._authType !== undefined) {
      hasAnyValues = true;
      internalValueResult.authType = this._authType;
    }
    if (this._columnMappings?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.columnMappings = this._columnMappings?.internalValue;
    }
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._concurrency !== undefined) {
      hasAnyValues = true;
      internalValueResult.concurrency = this._concurrency;
    }
    if (this._credentialsSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.credentialsSecret = this._credentialsSecret;
    }
    if (this._database !== undefined) {
      hasAnyValues = true;
      internalValueResult.database = this._database;
    }
    if (this._describeTable !== undefined) {
      hasAnyValues = true;
      internalValueResult.describeTable = this._describeTable;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._dumpFormatErrorsToDisk !== undefined) {
      hasAnyValues = true;
      internalValueResult.dumpFormatErrorsToDisk = this._dumpFormatErrorsToDisk;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._excludeMappingFields !== undefined) {
      hasAnyValues = true;
      internalValueResult.excludeMappingFields = this._excludeMappingFields;
    }
    if (this._extraHttpHeaders?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.extraHttpHeaders = this._extraHttpHeaders?.internalValue;
    }
    if (this._failedRequestLoggingMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.failedRequestLoggingMode = this._failedRequestLoggingMode;
    }
    if (this._flushPeriodSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.flushPeriodSec = this._flushPeriodSec;
    }
    if (this._format !== undefined) {
      hasAnyValues = true;
      internalValueResult.format = this._format;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._loginUrl !== undefined) {
      hasAnyValues = true;
      internalValueResult.loginUrl = this._loginUrl;
    }
    if (this._mappingType !== undefined) {
      hasAnyValues = true;
      internalValueResult.mappingType = this._mappingType;
    }
    if (this._maxPayloadEvents !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxPayloadEvents = this._maxPayloadEvents;
    }
    if (this._maxPayloadSizeKb !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxPayloadSizeKb = this._maxPayloadSizeKb;
    }
    if (this._oauthHeaders?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.oauthHeaders = this._oauthHeaders?.internalValue;
    }
    if (this._oauthParams?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.oauthParams = this._oauthParams?.internalValue;
    }
    if (this._onBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.onBackpressure = this._onBackpressure;
    }
    if (this._password !== undefined) {
      hasAnyValues = true;
      internalValueResult.password = this._password;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._pqCompress !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqCompress = this._pqCompress;
    }
    if (this._pqControls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqControls = this._pqControls?.internalValue;
    }
    if (this._pqMaxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxFileSize = this._pqMaxFileSize;
    }
    if (this._pqMaxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxSize = this._pqMaxSize;
    }
    if (this._pqMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMode = this._pqMode;
    }
    if (this._pqOnBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqOnBackpressure = this._pqOnBackpressure;
    }
    if (this._pqPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqPath = this._pqPath;
    }
    if (this._rejectUnauthorized !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectUnauthorized = this._rejectUnauthorized;
    }
    if (this._responseHonorRetryAfterHeader !== undefined) {
      hasAnyValues = true;
      internalValueResult.responseHonorRetryAfterHeader = this._responseHonorRetryAfterHeader;
    }
    if (this._responseRetrySettings?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.responseRetrySettings = this._responseRetrySettings?.internalValue;
    }
    if (this._safeHeaders !== undefined) {
      hasAnyValues = true;
      internalValueResult.safeHeaders = this._safeHeaders;
    }
    if (this._secret !== undefined) {
      hasAnyValues = true;
      internalValueResult.secret = this._secret;
    }
    if (this._secretParamName !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretParamName = this._secretParamName;
    }
    if (this._sqlUsername !== undefined) {
      hasAnyValues = true;
      internalValueResult.sqlUsername = this._sqlUsername;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._systemFields !== undefined) {
      hasAnyValues = true;
      internalValueResult.systemFields = this._systemFields;
    }
    if (this._tableName !== undefined) {
      hasAnyValues = true;
      internalValueResult.tableName = this._tableName;
    }
    if (this._textSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.textSecret = this._textSecret;
    }
    if (this._timeoutRetrySettings?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutRetrySettings = this._timeoutRetrySettings?.internalValue;
    }
    if (this._timeoutSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutSec = this._timeoutSec;
    }
    if (this._tls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tls = this._tls?.internalValue;
    }
    if (this._token !== undefined) {
      hasAnyValues = true;
      internalValueResult.token = this._token;
    }
    if (this._tokenAttributeName !== undefined) {
      hasAnyValues = true;
      internalValueResult.tokenAttributeName = this._tokenAttributeName;
    }
    if (this._tokenTimeoutSecs !== undefined) {
      hasAnyValues = true;
      internalValueResult.tokenTimeoutSecs = this._tokenTimeoutSecs;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._url !== undefined) {
      hasAnyValues = true;
      internalValueResult.url = this._url;
    }
    if (this._useRoundRobinDns !== undefined) {
      hasAnyValues = true;
      internalValueResult.useRoundRobinDns = this._useRoundRobinDns;
    }
    if (this._username !== undefined) {
      hasAnyValues = true;
      internalValueResult.username = this._username;
    }
    if (this._waitForAsyncInserts !== undefined) {
      hasAnyValues = true;
      internalValueResult.waitForAsyncInserts = this._waitForAsyncInserts;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputClickHouse | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._asyncInserts = undefined;
      this._authHeaderExpr = undefined;
      this._authType = undefined;
      this._columnMappings.internalValue = undefined;
      this._compress = undefined;
      this._concurrency = undefined;
      this._credentialsSecret = undefined;
      this._database = undefined;
      this._describeTable = undefined;
      this._description = undefined;
      this._dumpFormatErrorsToDisk = undefined;
      this._environment = undefined;
      this._excludeMappingFields = undefined;
      this._extraHttpHeaders.internalValue = undefined;
      this._failedRequestLoggingMode = undefined;
      this._flushPeriodSec = undefined;
      this._format = undefined;
      this._id = undefined;
      this._loginUrl = undefined;
      this._mappingType = undefined;
      this._maxPayloadEvents = undefined;
      this._maxPayloadSizeKb = undefined;
      this._oauthHeaders.internalValue = undefined;
      this._oauthParams.internalValue = undefined;
      this._onBackpressure = undefined;
      this._password = undefined;
      this._pipeline = undefined;
      this._pqCompress = undefined;
      this._pqControls.internalValue = undefined;
      this._pqMaxFileSize = undefined;
      this._pqMaxSize = undefined;
      this._pqMode = undefined;
      this._pqOnBackpressure = undefined;
      this._pqPath = undefined;
      this._rejectUnauthorized = undefined;
      this._responseHonorRetryAfterHeader = undefined;
      this._responseRetrySettings.internalValue = undefined;
      this._safeHeaders = undefined;
      this._secret = undefined;
      this._secretParamName = undefined;
      this._sqlUsername = undefined;
      this._streamtags = undefined;
      this._systemFields = undefined;
      this._tableName = undefined;
      this._textSecret = undefined;
      this._timeoutRetrySettings.internalValue = undefined;
      this._timeoutSec = undefined;
      this._tls.internalValue = undefined;
      this._token = undefined;
      this._tokenAttributeName = undefined;
      this._tokenTimeoutSecs = undefined;
      this._type = undefined;
      this._url = undefined;
      this._useRoundRobinDns = undefined;
      this._username = undefined;
      this._waitForAsyncInserts = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._asyncInserts = value.asyncInserts;
      this._authHeaderExpr = value.authHeaderExpr;
      this._authType = value.authType;
      this._columnMappings.internalValue = value.columnMappings;
      this._compress = value.compress;
      this._concurrency = value.concurrency;
      this._credentialsSecret = value.credentialsSecret;
      this._database = value.database;
      this._describeTable = value.describeTable;
      this._description = value.description;
      this._dumpFormatErrorsToDisk = value.dumpFormatErrorsToDisk;
      this._environment = value.environment;
      this._excludeMappingFields = value.excludeMappingFields;
      this._extraHttpHeaders.internalValue = value.extraHttpHeaders;
      this._failedRequestLoggingMode = value.failedRequestLoggingMode;
      this._flushPeriodSec = value.flushPeriodSec;
      this._format = value.format;
      this._id = value.id;
      this._loginUrl = value.loginUrl;
      this._mappingType = value.mappingType;
      this._maxPayloadEvents = value.maxPayloadEvents;
      this._maxPayloadSizeKb = value.maxPayloadSizeKb;
      this._oauthHeaders.internalValue = value.oauthHeaders;
      this._oauthParams.internalValue = value.oauthParams;
      this._onBackpressure = value.onBackpressure;
      this._password = value.password;
      this._pipeline = value.pipeline;
      this._pqCompress = value.pqCompress;
      this._pqControls.internalValue = value.pqControls;
      this._pqMaxFileSize = value.pqMaxFileSize;
      this._pqMaxSize = value.pqMaxSize;
      this._pqMode = value.pqMode;
      this._pqOnBackpressure = value.pqOnBackpressure;
      this._pqPath = value.pqPath;
      this._rejectUnauthorized = value.rejectUnauthorized;
      this._responseHonorRetryAfterHeader = value.responseHonorRetryAfterHeader;
      this._responseRetrySettings.internalValue = value.responseRetrySettings;
      this._safeHeaders = value.safeHeaders;
      this._secret = value.secret;
      this._secretParamName = value.secretParamName;
      this._sqlUsername = value.sqlUsername;
      this._streamtags = value.streamtags;
      this._systemFields = value.systemFields;
      this._tableName = value.tableName;
      this._textSecret = value.textSecret;
      this._timeoutRetrySettings.internalValue = value.timeoutRetrySettings;
      this._timeoutSec = value.timeoutSec;
      this._tls.internalValue = value.tls;
      this._token = value.token;
      this._tokenAttributeName = value.tokenAttributeName;
      this._tokenTimeoutSecs = value.tokenTimeoutSecs;
      this._type = value.type;
      this._url = value.url;
      this._useRoundRobinDns = value.useRoundRobinDns;
      this._username = value.username;
      this._waitForAsyncInserts = value.waitForAsyncInserts;
    }
  }

  // async_inserts - computed: true, optional: true, required: false
  private _asyncInserts?: boolean | cdktf.IResolvable; 
  public get asyncInserts() {
    return this.getBooleanAttribute('async_inserts');
  }
  public set asyncInserts(value: boolean | cdktf.IResolvable) {
    this._asyncInserts = value;
  }
  public resetAsyncInserts() {
    this._asyncInserts = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get asyncInsertsInput() {
    return this._asyncInserts;
  }

  // auth_header_expr - computed: true, optional: true, required: false
  private _authHeaderExpr?: string; 
  public get authHeaderExpr() {
    return this.getStringAttribute('auth_header_expr');
  }
  public set authHeaderExpr(value: string) {
    this._authHeaderExpr = value;
  }
  public resetAuthHeaderExpr() {
    this._authHeaderExpr = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authHeaderExprInput() {
    return this._authHeaderExpr;
  }

  // auth_type - computed: true, optional: true, required: false
  private _authType?: string; 
  public get authType() {
    return this.getStringAttribute('auth_type');
  }
  public set authType(value: string) {
    this._authType = value;
  }
  public resetAuthType() {
    this._authType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authTypeInput() {
    return this._authType;
  }

  // column_mappings - computed: false, optional: true, required: false
  private _columnMappings = new DestinationOutputClickHouseColumnMappingsList(this, "column_mappings", false);
  public get columnMappings() {
    return this._columnMappings;
  }
  public putColumnMappings(value: DestinationOutputClickHouseColumnMappings[] | cdktf.IResolvable) {
    this._columnMappings.internalValue = value;
  }
  public resetColumnMappings() {
    this._columnMappings.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get columnMappingsInput() {
    return this._columnMappings.internalValue;
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: boolean | cdktf.IResolvable; 
  public get compress() {
    return this.getBooleanAttribute('compress');
  }
  public set compress(value: boolean | cdktf.IResolvable) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // concurrency - computed: true, optional: true, required: false
  private _concurrency?: number; 
  public get concurrency() {
    return this.getNumberAttribute('concurrency');
  }
  public set concurrency(value: number) {
    this._concurrency = value;
  }
  public resetConcurrency() {
    this._concurrency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get concurrencyInput() {
    return this._concurrency;
  }

  // credentials_secret - computed: false, optional: true, required: false
  private _credentialsSecret?: string; 
  public get credentialsSecret() {
    return this.getStringAttribute('credentials_secret');
  }
  public set credentialsSecret(value: string) {
    this._credentialsSecret = value;
  }
  public resetCredentialsSecret() {
    this._credentialsSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get credentialsSecretInput() {
    return this._credentialsSecret;
  }

  // database - computed: false, optional: false, required: true
  private _database?: string; 
  public get database() {
    return this.getStringAttribute('database');
  }
  public set database(value: string) {
    this._database = value;
  }
  // Temporarily expose input value. Use with caution.
  public get databaseInput() {
    return this._database;
  }

  // describe_table - computed: false, optional: true, required: false
  private _describeTable?: string; 
  public get describeTable() {
    return this.getStringAttribute('describe_table');
  }
  public set describeTable(value: string) {
    this._describeTable = value;
  }
  public resetDescribeTable() {
    this._describeTable = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get describeTableInput() {
    return this._describeTable;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // dump_format_errors_to_disk - computed: true, optional: true, required: false
  private _dumpFormatErrorsToDisk?: boolean | cdktf.IResolvable; 
  public get dumpFormatErrorsToDisk() {
    return this.getBooleanAttribute('dump_format_errors_to_disk');
  }
  public set dumpFormatErrorsToDisk(value: boolean | cdktf.IResolvable) {
    this._dumpFormatErrorsToDisk = value;
  }
  public resetDumpFormatErrorsToDisk() {
    this._dumpFormatErrorsToDisk = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dumpFormatErrorsToDiskInput() {
    return this._dumpFormatErrorsToDisk;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // exclude_mapping_fields - computed: true, optional: true, required: false
  private _excludeMappingFields?: string[]; 
  public get excludeMappingFields() {
    return this.getListAttribute('exclude_mapping_fields');
  }
  public set excludeMappingFields(value: string[]) {
    this._excludeMappingFields = value;
  }
  public resetExcludeMappingFields() {
    this._excludeMappingFields = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get excludeMappingFieldsInput() {
    return this._excludeMappingFields;
  }

  // extra_http_headers - computed: false, optional: true, required: false
  private _extraHttpHeaders = new DestinationOutputClickHouseExtraHttpHeadersList(this, "extra_http_headers", false);
  public get extraHttpHeaders() {
    return this._extraHttpHeaders;
  }
  public putExtraHttpHeaders(value: DestinationOutputClickHouseExtraHttpHeaders[] | cdktf.IResolvable) {
    this._extraHttpHeaders.internalValue = value;
  }
  public resetExtraHttpHeaders() {
    this._extraHttpHeaders.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get extraHttpHeadersInput() {
    return this._extraHttpHeaders.internalValue;
  }

  // failed_request_logging_mode - computed: true, optional: true, required: false
  private _failedRequestLoggingMode?: string; 
  public get failedRequestLoggingMode() {
    return this.getStringAttribute('failed_request_logging_mode');
  }
  public set failedRequestLoggingMode(value: string) {
    this._failedRequestLoggingMode = value;
  }
  public resetFailedRequestLoggingMode() {
    this._failedRequestLoggingMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get failedRequestLoggingModeInput() {
    return this._failedRequestLoggingMode;
  }

  // flush_period_sec - computed: true, optional: true, required: false
  private _flushPeriodSec?: number; 
  public get flushPeriodSec() {
    return this.getNumberAttribute('flush_period_sec');
  }
  public set flushPeriodSec(value: number) {
    this._flushPeriodSec = value;
  }
  public resetFlushPeriodSec() {
    this._flushPeriodSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get flushPeriodSecInput() {
    return this._flushPeriodSec;
  }

  // format - computed: true, optional: true, required: false
  private _format?: string; 
  public get format() {
    return this.getStringAttribute('format');
  }
  public set format(value: string) {
    this._format = value;
  }
  public resetFormat() {
    this._format = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get formatInput() {
    return this._format;
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // login_url - computed: false, optional: true, required: false
  private _loginUrl?: string; 
  public get loginUrl() {
    return this.getStringAttribute('login_url');
  }
  public set loginUrl(value: string) {
    this._loginUrl = value;
  }
  public resetLoginUrl() {
    this._loginUrl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get loginUrlInput() {
    return this._loginUrl;
  }

  // mapping_type - computed: true, optional: true, required: false
  private _mappingType?: string; 
  public get mappingType() {
    return this.getStringAttribute('mapping_type');
  }
  public set mappingType(value: string) {
    this._mappingType = value;
  }
  public resetMappingType() {
    this._mappingType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get mappingTypeInput() {
    return this._mappingType;
  }

  // max_payload_events - computed: true, optional: true, required: false
  private _maxPayloadEvents?: number; 
  public get maxPayloadEvents() {
    return this.getNumberAttribute('max_payload_events');
  }
  public set maxPayloadEvents(value: number) {
    this._maxPayloadEvents = value;
  }
  public resetMaxPayloadEvents() {
    this._maxPayloadEvents = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxPayloadEventsInput() {
    return this._maxPayloadEvents;
  }

  // max_payload_size_kb - computed: true, optional: true, required: false
  private _maxPayloadSizeKb?: number; 
  public get maxPayloadSizeKb() {
    return this.getNumberAttribute('max_payload_size_kb');
  }
  public set maxPayloadSizeKb(value: number) {
    this._maxPayloadSizeKb = value;
  }
  public resetMaxPayloadSizeKb() {
    this._maxPayloadSizeKb = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxPayloadSizeKbInput() {
    return this._maxPayloadSizeKb;
  }

  // oauth_headers - computed: false, optional: true, required: false
  private _oauthHeaders = new DestinationOutputClickHouseOauthHeadersList(this, "oauth_headers", false);
  public get oauthHeaders() {
    return this._oauthHeaders;
  }
  public putOauthHeaders(value: DestinationOutputClickHouseOauthHeaders[] | cdktf.IResolvable) {
    this._oauthHeaders.internalValue = value;
  }
  public resetOauthHeaders() {
    this._oauthHeaders.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get oauthHeadersInput() {
    return this._oauthHeaders.internalValue;
  }

  // oauth_params - computed: false, optional: true, required: false
  private _oauthParams = new DestinationOutputClickHouseOauthParamsList(this, "oauth_params", false);
  public get oauthParams() {
    return this._oauthParams;
  }
  public putOauthParams(value: DestinationOutputClickHouseOauthParams[] | cdktf.IResolvable) {
    this._oauthParams.internalValue = value;
  }
  public resetOauthParams() {
    this._oauthParams.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get oauthParamsInput() {
    return this._oauthParams.internalValue;
  }

  // on_backpressure - computed: true, optional: true, required: false
  private _onBackpressure?: string; 
  public get onBackpressure() {
    return this.getStringAttribute('on_backpressure');
  }
  public set onBackpressure(value: string) {
    this._onBackpressure = value;
  }
  public resetOnBackpressure() {
    this._onBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get onBackpressureInput() {
    return this._onBackpressure;
  }

  // password - computed: false, optional: true, required: false
  private _password?: string; 
  public get password() {
    return this.getStringAttribute('password');
  }
  public set password(value: string) {
    this._password = value;
  }
  public resetPassword() {
    this._password = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passwordInput() {
    return this._password;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // pq_compress - computed: true, optional: true, required: false
  private _pqCompress?: string; 
  public get pqCompress() {
    return this.getStringAttribute('pq_compress');
  }
  public set pqCompress(value: string) {
    this._pqCompress = value;
  }
  public resetPqCompress() {
    this._pqCompress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqCompressInput() {
    return this._pqCompress;
  }

  // pq_controls - computed: false, optional: true, required: false
  private _pqControls = new DestinationOutputClickHousePqControlsOutputReference(this, "pq_controls");
  public get pqControls() {
    return this._pqControls;
  }
  public putPqControls(value: DestinationOutputClickHousePqControls) {
    this._pqControls.internalValue = value;
  }
  public resetPqControls() {
    this._pqControls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqControlsInput() {
    return this._pqControls.internalValue;
  }

  // pq_max_file_size - computed: true, optional: true, required: false
  private _pqMaxFileSize?: string; 
  public get pqMaxFileSize() {
    return this.getStringAttribute('pq_max_file_size');
  }
  public set pqMaxFileSize(value: string) {
    this._pqMaxFileSize = value;
  }
  public resetPqMaxFileSize() {
    this._pqMaxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxFileSizeInput() {
    return this._pqMaxFileSize;
  }

  // pq_max_size - computed: true, optional: true, required: false
  private _pqMaxSize?: string; 
  public get pqMaxSize() {
    return this.getStringAttribute('pq_max_size');
  }
  public set pqMaxSize(value: string) {
    this._pqMaxSize = value;
  }
  public resetPqMaxSize() {
    this._pqMaxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxSizeInput() {
    return this._pqMaxSize;
  }

  // pq_mode - computed: true, optional: true, required: false
  private _pqMode?: string; 
  public get pqMode() {
    return this.getStringAttribute('pq_mode');
  }
  public set pqMode(value: string) {
    this._pqMode = value;
  }
  public resetPqMode() {
    this._pqMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqModeInput() {
    return this._pqMode;
  }

  // pq_on_backpressure - computed: true, optional: true, required: false
  private _pqOnBackpressure?: string; 
  public get pqOnBackpressure() {
    return this.getStringAttribute('pq_on_backpressure');
  }
  public set pqOnBackpressure(value: string) {
    this._pqOnBackpressure = value;
  }
  public resetPqOnBackpressure() {
    this._pqOnBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqOnBackpressureInput() {
    return this._pqOnBackpressure;
  }

  // pq_path - computed: true, optional: true, required: false
  private _pqPath?: string; 
  public get pqPath() {
    return this.getStringAttribute('pq_path');
  }
  public set pqPath(value: string) {
    this._pqPath = value;
  }
  public resetPqPath() {
    this._pqPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqPathInput() {
    return this._pqPath;
  }

  // reject_unauthorized - computed: true, optional: true, required: false
  private _rejectUnauthorized?: boolean | cdktf.IResolvable; 
  public get rejectUnauthorized() {
    return this.getBooleanAttribute('reject_unauthorized');
  }
  public set rejectUnauthorized(value: boolean | cdktf.IResolvable) {
    this._rejectUnauthorized = value;
  }
  public resetRejectUnauthorized() {
    this._rejectUnauthorized = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectUnauthorizedInput() {
    return this._rejectUnauthorized;
  }

  // response_honor_retry_after_header - computed: true, optional: true, required: false
  private _responseHonorRetryAfterHeader?: boolean | cdktf.IResolvable; 
  public get responseHonorRetryAfterHeader() {
    return this.getBooleanAttribute('response_honor_retry_after_header');
  }
  public set responseHonorRetryAfterHeader(value: boolean | cdktf.IResolvable) {
    this._responseHonorRetryAfterHeader = value;
  }
  public resetResponseHonorRetryAfterHeader() {
    this._responseHonorRetryAfterHeader = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get responseHonorRetryAfterHeaderInput() {
    return this._responseHonorRetryAfterHeader;
  }

  // response_retry_settings - computed: false, optional: true, required: false
  private _responseRetrySettings = new DestinationOutputClickHouseResponseRetrySettingsList(this, "response_retry_settings", false);
  public get responseRetrySettings() {
    return this._responseRetrySettings;
  }
  public putResponseRetrySettings(value: DestinationOutputClickHouseResponseRetrySettings[] | cdktf.IResolvable) {
    this._responseRetrySettings.internalValue = value;
  }
  public resetResponseRetrySettings() {
    this._responseRetrySettings.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get responseRetrySettingsInput() {
    return this._responseRetrySettings.internalValue;
  }

  // safe_headers - computed: true, optional: true, required: false
  private _safeHeaders?: string[]; 
  public get safeHeaders() {
    return this.getListAttribute('safe_headers');
  }
  public set safeHeaders(value: string[]) {
    this._safeHeaders = value;
  }
  public resetSafeHeaders() {
    this._safeHeaders = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get safeHeadersInput() {
    return this._safeHeaders;
  }

  // secret - computed: false, optional: true, required: false
  private _secret?: string; 
  public get secret() {
    return this.getStringAttribute('secret');
  }
  public set secret(value: string) {
    this._secret = value;
  }
  public resetSecret() {
    this._secret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretInput() {
    return this._secret;
  }

  // secret_param_name - computed: false, optional: true, required: false
  private _secretParamName?: string; 
  public get secretParamName() {
    return this.getStringAttribute('secret_param_name');
  }
  public set secretParamName(value: string) {
    this._secretParamName = value;
  }
  public resetSecretParamName() {
    this._secretParamName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretParamNameInput() {
    return this._secretParamName;
  }

  // sql_username - computed: false, optional: true, required: false
  private _sqlUsername?: string; 
  public get sqlUsername() {
    return this.getStringAttribute('sql_username');
  }
  public set sqlUsername(value: string) {
    this._sqlUsername = value;
  }
  public resetSqlUsername() {
    this._sqlUsername = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sqlUsernameInput() {
    return this._sqlUsername;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // system_fields - computed: true, optional: true, required: false
  private _systemFields?: string[]; 
  public get systemFields() {
    return this.getListAttribute('system_fields');
  }
  public set systemFields(value: string[]) {
    this._systemFields = value;
  }
  public resetSystemFields() {
    this._systemFields = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get systemFieldsInput() {
    return this._systemFields;
  }

  // table_name - computed: false, optional: false, required: true
  private _tableName?: string; 
  public get tableName() {
    return this.getStringAttribute('table_name');
  }
  public set tableName(value: string) {
    this._tableName = value;
  }
  // Temporarily expose input value. Use with caution.
  public get tableNameInput() {
    return this._tableName;
  }

  // text_secret - computed: false, optional: true, required: false
  private _textSecret?: string; 
  public get textSecret() {
    return this.getStringAttribute('text_secret');
  }
  public set textSecret(value: string) {
    this._textSecret = value;
  }
  public resetTextSecret() {
    this._textSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get textSecretInput() {
    return this._textSecret;
  }

  // timeout_retry_settings - computed: false, optional: true, required: false
  private _timeoutRetrySettings = new DestinationOutputClickHouseTimeoutRetrySettingsOutputReference(this, "timeout_retry_settings");
  public get timeoutRetrySettings() {
    return this._timeoutRetrySettings;
  }
  public putTimeoutRetrySettings(value: DestinationOutputClickHouseTimeoutRetrySettings) {
    this._timeoutRetrySettings.internalValue = value;
  }
  public resetTimeoutRetrySettings() {
    this._timeoutRetrySettings.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutRetrySettingsInput() {
    return this._timeoutRetrySettings.internalValue;
  }

  // timeout_sec - computed: true, optional: true, required: false
  private _timeoutSec?: number; 
  public get timeoutSec() {
    return this.getNumberAttribute('timeout_sec');
  }
  public set timeoutSec(value: number) {
    this._timeoutSec = value;
  }
  public resetTimeoutSec() {
    this._timeoutSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutSecInput() {
    return this._timeoutSec;
  }

  // tls - computed: false, optional: true, required: false
  private _tls = new DestinationOutputClickHouseTlsOutputReference(this, "tls");
  public get tls() {
    return this._tls;
  }
  public putTls(value: DestinationOutputClickHouseTls) {
    this._tls.internalValue = value;
  }
  public resetTls() {
    this._tls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsInput() {
    return this._tls.internalValue;
  }

  // token - computed: false, optional: true, required: false
  private _token?: string; 
  public get token() {
    return this.getStringAttribute('token');
  }
  public set token(value: string) {
    this._token = value;
  }
  public resetToken() {
    this._token = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tokenInput() {
    return this._token;
  }

  // token_attribute_name - computed: false, optional: true, required: false
  private _tokenAttributeName?: string; 
  public get tokenAttributeName() {
    return this.getStringAttribute('token_attribute_name');
  }
  public set tokenAttributeName(value: string) {
    this._tokenAttributeName = value;
  }
  public resetTokenAttributeName() {
    this._tokenAttributeName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tokenAttributeNameInput() {
    return this._tokenAttributeName;
  }

  // token_timeout_secs - computed: true, optional: true, required: false
  private _tokenTimeoutSecs?: number; 
  public get tokenTimeoutSecs() {
    return this.getNumberAttribute('token_timeout_secs');
  }
  public set tokenTimeoutSecs(value: number) {
    this._tokenTimeoutSecs = value;
  }
  public resetTokenTimeoutSecs() {
    this._tokenTimeoutSecs = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tokenTimeoutSecsInput() {
    return this._tokenTimeoutSecs;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // url - computed: false, optional: false, required: true
  private _url?: string; 
  public get url() {
    return this.getStringAttribute('url');
  }
  public set url(value: string) {
    this._url = value;
  }
  // Temporarily expose input value. Use with caution.
  public get urlInput() {
    return this._url;
  }

  // use_round_robin_dns - computed: true, optional: true, required: false
  private _useRoundRobinDns?: boolean | cdktf.IResolvable; 
  public get useRoundRobinDns() {
    return this.getBooleanAttribute('use_round_robin_dns');
  }
  public set useRoundRobinDns(value: boolean | cdktf.IResolvable) {
    this._useRoundRobinDns = value;
  }
  public resetUseRoundRobinDns() {
    this._useRoundRobinDns = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get useRoundRobinDnsInput() {
    return this._useRoundRobinDns;
  }

  // username - computed: false, optional: true, required: false
  private _username?: string; 
  public get username() {
    return this.getStringAttribute('username');
  }
  public set username(value: string) {
    this._username = value;
  }
  public resetUsername() {
    this._username = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usernameInput() {
    return this._username;
  }

  // wait_for_async_inserts - computed: true, optional: true, required: false
  private _waitForAsyncInserts?: boolean | cdktf.IResolvable; 
  public get waitForAsyncInserts() {
    return this.getBooleanAttribute('wait_for_async_inserts');
  }
  public set waitForAsyncInserts(value: boolean | cdktf.IResolvable) {
    this._waitForAsyncInserts = value;
  }
  public resetWaitForAsyncInserts() {
    this._waitForAsyncInserts = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get waitForAsyncInsertsInput() {
    return this._waitForAsyncInserts;
  }
}
export interface DestinationOutputCloudwatchPqControls {
}

export function destinationOutputCloudwatchPqControlsToTerraform(struct?: DestinationOutputCloudwatchPqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function destinationOutputCloudwatchPqControlsToHclTerraform(struct?: DestinationOutputCloudwatchPqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class DestinationOutputCloudwatchPqControlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DestinationOutputCloudwatchPqControls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputCloudwatchPqControls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface DestinationOutputCloudwatch {
  /**
  * Amazon Resource Name (ARN) of the role to assume
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#assume_role_arn Destination#assume_role_arn}
  */
  readonly assumeRoleArn?: string;
  /**
  * External ID to use when assuming role
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#assume_role_external_id Destination#assume_role_external_id}
  */
  readonly assumeRoleExternalId?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#aws_api_key Destination#aws_api_key}
  */
  readonly awsApiKey?: string;
  /**
  * AWS authentication method. Choose Auto to use IAM roles. Default: "auto"; must be one of ["auto", "manual", "secret"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#aws_authentication_method Destination#aws_authentication_method}
  */
  readonly awsAuthenticationMethod?: string;
  /**
  * Select or create a stored secret that references your access key and secret key
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#aws_secret Destination#aws_secret}
  */
  readonly awsSecret?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#aws_secret_key Destination#aws_secret_key}
  */
  readonly awsSecretKey?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#description Destination#description}
  */
  readonly description?: string;
  /**
  * Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours). Default: 3600
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#duration_seconds Destination#duration_seconds}
  */
  readonly durationSeconds?: number;
  /**
  * Use Assume Role credentials to access CloudWatchLogs. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#enable_assume_role Destination#enable_assume_role}
  */
  readonly enableAssumeRole?: boolean | cdktf.IResolvable;
  /**
  * CloudWatchLogs service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to CloudWatchLogs-compatible endpoint.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#endpoint Destination#endpoint}
  */
  readonly endpoint?: string;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#environment Destination#environment}
  */
  readonly environment?: string;
  /**
  * Maximum time between requests. Small values could cause the payload size to be smaller than the configured Max record size. Default: 1
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#flush_period_sec Destination#flush_period_sec}
  */
  readonly flushPeriodSec?: number;
  /**
  * Unique ID for this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#id Destination#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * CloudWatch log group to associate events with
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#log_group_name Destination#log_group_name}
  */
  readonly logGroupName: string;
  /**
  * Prefix for CloudWatch log stream name. This prefix will be used to generate a unique log stream name per cribl instance, for example: myStream_myHost_myOutputId
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#log_stream_name Destination#log_stream_name}
  */
  readonly logStreamName: string;
  /**
  * Maximum number of queued batches before blocking. Default: 5
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#max_queue_size Destination#max_queue_size}
  */
  readonly maxQueueSize?: number;
  /**
  * Maximum size (KB) of each individual record before compression. For non compressible data 1MB is the max recommended size. Default: 1024
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#max_record_size_kb Destination#max_record_size_kb}
  */
  readonly maxRecordSizeKb?: number;
  /**
  * How to handle events when all receivers are exerting backpressure. Default: "block"; must be one of ["block", "drop", "queue"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#on_backpressure Destination#on_backpressure}
  */
  readonly onBackpressure?: string;
  /**
  * Pipeline to process data before sending out to this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pipeline Destination#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pq_compress Destination#pq_compress}
  */
  readonly pqCompress?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pq_controls Destination#pq_controls}
  */
  readonly pqControls?: DestinationOutputCloudwatchPqControls;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.). Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pq_max_file_size Destination#pq_max_file_size}
  */
  readonly pqMaxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pq_max_size Destination#pq_max_size}
  */
  readonly pqMaxSize?: string;
  /**
  * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem. Default: "error"; must be one of ["error", "backpressure", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pq_mode Destination#pq_mode}
  */
  readonly pqMode?: string;
  /**
  * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged. Default: "block"; must be one of ["block", "drop"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pq_on_backpressure Destination#pq_on_backpressure}
  */
  readonly pqOnBackpressure?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pq_path Destination#pq_path}
  */
  readonly pqPath?: string;
  /**
  * Region where the CloudWatchLogs is located
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#region Destination#region}
  */
  readonly region: string;
  /**
  * Reject certificates that cannot be verified against a valid CA, such as self-signed certificates. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#reject_unauthorized Destination#reject_unauthorized}
  */
  readonly rejectUnauthorized?: boolean | cdktf.IResolvable;
  /**
  * Reuse connections between requests, which can improve performance. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#reuse_connections Destination#reuse_connections}
  */
  readonly reuseConnections?: boolean | cdktf.IResolvable;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#streamtags Destination#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Fields to automatically add to events, such as cribl_pipe. Supports wildcards. Default: ["cribl_pipe"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#system_fields Destination#system_fields}
  */
  readonly systemFields?: string[];
  /**
  * must be "cloudwatch"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#type Destination#type}
  */
  readonly type?: string;
}

export function destinationOutputCloudwatchToTerraform(struct?: DestinationOutputCloudwatch | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    assume_role_arn: cdktf.stringToTerraform(struct!.assumeRoleArn),
    assume_role_external_id: cdktf.stringToTerraform(struct!.assumeRoleExternalId),
    aws_api_key: cdktf.stringToTerraform(struct!.awsApiKey),
    aws_authentication_method: cdktf.stringToTerraform(struct!.awsAuthenticationMethod),
    aws_secret: cdktf.stringToTerraform(struct!.awsSecret),
    aws_secret_key: cdktf.stringToTerraform(struct!.awsSecretKey),
    description: cdktf.stringToTerraform(struct!.description),
    duration_seconds: cdktf.numberToTerraform(struct!.durationSeconds),
    enable_assume_role: cdktf.booleanToTerraform(struct!.enableAssumeRole),
    endpoint: cdktf.stringToTerraform(struct!.endpoint),
    environment: cdktf.stringToTerraform(struct!.environment),
    flush_period_sec: cdktf.numberToTerraform(struct!.flushPeriodSec),
    id: cdktf.stringToTerraform(struct!.id),
    log_group_name: cdktf.stringToTerraform(struct!.logGroupName),
    log_stream_name: cdktf.stringToTerraform(struct!.logStreamName),
    max_queue_size: cdktf.numberToTerraform(struct!.maxQueueSize),
    max_record_size_kb: cdktf.numberToTerraform(struct!.maxRecordSizeKb),
    on_backpressure: cdktf.stringToTerraform(struct!.onBackpressure),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    pq_compress: cdktf.stringToTerraform(struct!.pqCompress),
    pq_controls: destinationOutputCloudwatchPqControlsToTerraform(struct!.pqControls),
    pq_max_file_size: cdktf.stringToTerraform(struct!.pqMaxFileSize),
    pq_max_size: cdktf.stringToTerraform(struct!.pqMaxSize),
    pq_mode: cdktf.stringToTerraform(struct!.pqMode),
    pq_on_backpressure: cdktf.stringToTerraform(struct!.pqOnBackpressure),
    pq_path: cdktf.stringToTerraform(struct!.pqPath),
    region: cdktf.stringToTerraform(struct!.region),
    reject_unauthorized: cdktf.booleanToTerraform(struct!.rejectUnauthorized),
    reuse_connections: cdktf.booleanToTerraform(struct!.reuseConnections),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    system_fields: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.systemFields),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function destinationOutputCloudwatchToHclTerraform(struct?: DestinationOutputCloudwatch | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    assume_role_arn: {
      value: cdktf.stringToHclTerraform(struct!.assumeRoleArn),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    assume_role_external_id: {
      value: cdktf.stringToHclTerraform(struct!.assumeRoleExternalId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    aws_api_key: {
      value: cdktf.stringToHclTerraform(struct!.awsApiKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    aws_authentication_method: {
      value: cdktf.stringToHclTerraform(struct!.awsAuthenticationMethod),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    aws_secret: {
      value: cdktf.stringToHclTerraform(struct!.awsSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    aws_secret_key: {
      value: cdktf.stringToHclTerraform(struct!.awsSecretKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    duration_seconds: {
      value: cdktf.numberToHclTerraform(struct!.durationSeconds),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    enable_assume_role: {
      value: cdktf.booleanToHclTerraform(struct!.enableAssumeRole),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    endpoint: {
      value: cdktf.stringToHclTerraform(struct!.endpoint),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    flush_period_sec: {
      value: cdktf.numberToHclTerraform(struct!.flushPeriodSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    log_group_name: {
      value: cdktf.stringToHclTerraform(struct!.logGroupName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    log_stream_name: {
      value: cdktf.stringToHclTerraform(struct!.logStreamName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_queue_size: {
      value: cdktf.numberToHclTerraform(struct!.maxQueueSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_record_size_kb: {
      value: cdktf.numberToHclTerraform(struct!.maxRecordSizeKb),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.onBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_compress: {
      value: cdktf.stringToHclTerraform(struct!.pqCompress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_controls: {
      value: destinationOutputCloudwatchPqControlsToHclTerraform(struct!.pqControls),
      isBlock: true,
      type: "struct",
      storageClassType: "DestinationOutputCloudwatchPqControls",
    },
    pq_max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_max_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_mode: {
      value: cdktf.stringToHclTerraform(struct!.pqMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.pqOnBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_path: {
      value: cdktf.stringToHclTerraform(struct!.pqPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    region: {
      value: cdktf.stringToHclTerraform(struct!.region),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reject_unauthorized: {
      value: cdktf.booleanToHclTerraform(struct!.rejectUnauthorized),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    reuse_connections: {
      value: cdktf.booleanToHclTerraform(struct!.reuseConnections),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    system_fields: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.systemFields),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputCloudwatchOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DestinationOutputCloudwatch | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._assumeRoleArn !== undefined) {
      hasAnyValues = true;
      internalValueResult.assumeRoleArn = this._assumeRoleArn;
    }
    if (this._assumeRoleExternalId !== undefined) {
      hasAnyValues = true;
      internalValueResult.assumeRoleExternalId = this._assumeRoleExternalId;
    }
    if (this._awsApiKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.awsApiKey = this._awsApiKey;
    }
    if (this._awsAuthenticationMethod !== undefined) {
      hasAnyValues = true;
      internalValueResult.awsAuthenticationMethod = this._awsAuthenticationMethod;
    }
    if (this._awsSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.awsSecret = this._awsSecret;
    }
    if (this._awsSecretKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.awsSecretKey = this._awsSecretKey;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._durationSeconds !== undefined) {
      hasAnyValues = true;
      internalValueResult.durationSeconds = this._durationSeconds;
    }
    if (this._enableAssumeRole !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableAssumeRole = this._enableAssumeRole;
    }
    if (this._endpoint !== undefined) {
      hasAnyValues = true;
      internalValueResult.endpoint = this._endpoint;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._flushPeriodSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.flushPeriodSec = this._flushPeriodSec;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._logGroupName !== undefined) {
      hasAnyValues = true;
      internalValueResult.logGroupName = this._logGroupName;
    }
    if (this._logStreamName !== undefined) {
      hasAnyValues = true;
      internalValueResult.logStreamName = this._logStreamName;
    }
    if (this._maxQueueSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxQueueSize = this._maxQueueSize;
    }
    if (this._maxRecordSizeKb !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxRecordSizeKb = this._maxRecordSizeKb;
    }
    if (this._onBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.onBackpressure = this._onBackpressure;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._pqCompress !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqCompress = this._pqCompress;
    }
    if (this._pqControls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqControls = this._pqControls?.internalValue;
    }
    if (this._pqMaxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxFileSize = this._pqMaxFileSize;
    }
    if (this._pqMaxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxSize = this._pqMaxSize;
    }
    if (this._pqMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMode = this._pqMode;
    }
    if (this._pqOnBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqOnBackpressure = this._pqOnBackpressure;
    }
    if (this._pqPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqPath = this._pqPath;
    }
    if (this._region !== undefined) {
      hasAnyValues = true;
      internalValueResult.region = this._region;
    }
    if (this._rejectUnauthorized !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectUnauthorized = this._rejectUnauthorized;
    }
    if (this._reuseConnections !== undefined) {
      hasAnyValues = true;
      internalValueResult.reuseConnections = this._reuseConnections;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._systemFields !== undefined) {
      hasAnyValues = true;
      internalValueResult.systemFields = this._systemFields;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputCloudwatch | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._assumeRoleArn = undefined;
      this._assumeRoleExternalId = undefined;
      this._awsApiKey = undefined;
      this._awsAuthenticationMethod = undefined;
      this._awsSecret = undefined;
      this._awsSecretKey = undefined;
      this._description = undefined;
      this._durationSeconds = undefined;
      this._enableAssumeRole = undefined;
      this._endpoint = undefined;
      this._environment = undefined;
      this._flushPeriodSec = undefined;
      this._id = undefined;
      this._logGroupName = undefined;
      this._logStreamName = undefined;
      this._maxQueueSize = undefined;
      this._maxRecordSizeKb = undefined;
      this._onBackpressure = undefined;
      this._pipeline = undefined;
      this._pqCompress = undefined;
      this._pqControls.internalValue = undefined;
      this._pqMaxFileSize = undefined;
      this._pqMaxSize = undefined;
      this._pqMode = undefined;
      this._pqOnBackpressure = undefined;
      this._pqPath = undefined;
      this._region = undefined;
      this._rejectUnauthorized = undefined;
      this._reuseConnections = undefined;
      this._streamtags = undefined;
      this._systemFields = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._assumeRoleArn = value.assumeRoleArn;
      this._assumeRoleExternalId = value.assumeRoleExternalId;
      this._awsApiKey = value.awsApiKey;
      this._awsAuthenticationMethod = value.awsAuthenticationMethod;
      this._awsSecret = value.awsSecret;
      this._awsSecretKey = value.awsSecretKey;
      this._description = value.description;
      this._durationSeconds = value.durationSeconds;
      this._enableAssumeRole = value.enableAssumeRole;
      this._endpoint = value.endpoint;
      this._environment = value.environment;
      this._flushPeriodSec = value.flushPeriodSec;
      this._id = value.id;
      this._logGroupName = value.logGroupName;
      this._logStreamName = value.logStreamName;
      this._maxQueueSize = value.maxQueueSize;
      this._maxRecordSizeKb = value.maxRecordSizeKb;
      this._onBackpressure = value.onBackpressure;
      this._pipeline = value.pipeline;
      this._pqCompress = value.pqCompress;
      this._pqControls.internalValue = value.pqControls;
      this._pqMaxFileSize = value.pqMaxFileSize;
      this._pqMaxSize = value.pqMaxSize;
      this._pqMode = value.pqMode;
      this._pqOnBackpressure = value.pqOnBackpressure;
      this._pqPath = value.pqPath;
      this._region = value.region;
      this._rejectUnauthorized = value.rejectUnauthorized;
      this._reuseConnections = value.reuseConnections;
      this._streamtags = value.streamtags;
      this._systemFields = value.systemFields;
      this._type = value.type;
    }
  }

  // assume_role_arn - computed: false, optional: true, required: false
  private _assumeRoleArn?: string; 
  public get assumeRoleArn() {
    return this.getStringAttribute('assume_role_arn');
  }
  public set assumeRoleArn(value: string) {
    this._assumeRoleArn = value;
  }
  public resetAssumeRoleArn() {
    this._assumeRoleArn = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get assumeRoleArnInput() {
    return this._assumeRoleArn;
  }

  // assume_role_external_id - computed: false, optional: true, required: false
  private _assumeRoleExternalId?: string; 
  public get assumeRoleExternalId() {
    return this.getStringAttribute('assume_role_external_id');
  }
  public set assumeRoleExternalId(value: string) {
    this._assumeRoleExternalId = value;
  }
  public resetAssumeRoleExternalId() {
    this._assumeRoleExternalId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get assumeRoleExternalIdInput() {
    return this._assumeRoleExternalId;
  }

  // aws_api_key - computed: false, optional: true, required: false
  private _awsApiKey?: string; 
  public get awsApiKey() {
    return this.getStringAttribute('aws_api_key');
  }
  public set awsApiKey(value: string) {
    this._awsApiKey = value;
  }
  public resetAwsApiKey() {
    this._awsApiKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsApiKeyInput() {
    return this._awsApiKey;
  }

  // aws_authentication_method - computed: true, optional: true, required: false
  private _awsAuthenticationMethod?: string; 
  public get awsAuthenticationMethod() {
    return this.getStringAttribute('aws_authentication_method');
  }
  public set awsAuthenticationMethod(value: string) {
    this._awsAuthenticationMethod = value;
  }
  public resetAwsAuthenticationMethod() {
    this._awsAuthenticationMethod = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsAuthenticationMethodInput() {
    return this._awsAuthenticationMethod;
  }

  // aws_secret - computed: false, optional: true, required: false
  private _awsSecret?: string; 
  public get awsSecret() {
    return this.getStringAttribute('aws_secret');
  }
  public set awsSecret(value: string) {
    this._awsSecret = value;
  }
  public resetAwsSecret() {
    this._awsSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsSecretInput() {
    return this._awsSecret;
  }

  // aws_secret_key - computed: false, optional: true, required: false
  private _awsSecretKey?: string; 
  public get awsSecretKey() {
    return this.getStringAttribute('aws_secret_key');
  }
  public set awsSecretKey(value: string) {
    this._awsSecretKey = value;
  }
  public resetAwsSecretKey() {
    this._awsSecretKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsSecretKeyInput() {
    return this._awsSecretKey;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // duration_seconds - computed: true, optional: true, required: false
  private _durationSeconds?: number; 
  public get durationSeconds() {
    return this.getNumberAttribute('duration_seconds');
  }
  public set durationSeconds(value: number) {
    this._durationSeconds = value;
  }
  public resetDurationSeconds() {
    this._durationSeconds = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get durationSecondsInput() {
    return this._durationSeconds;
  }

  // enable_assume_role - computed: true, optional: true, required: false
  private _enableAssumeRole?: boolean | cdktf.IResolvable; 
  public get enableAssumeRole() {
    return this.getBooleanAttribute('enable_assume_role');
  }
  public set enableAssumeRole(value: boolean | cdktf.IResolvable) {
    this._enableAssumeRole = value;
  }
  public resetEnableAssumeRole() {
    this._enableAssumeRole = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableAssumeRoleInput() {
    return this._enableAssumeRole;
  }

  // endpoint - computed: false, optional: true, required: false
  private _endpoint?: string; 
  public get endpoint() {
    return this.getStringAttribute('endpoint');
  }
  public set endpoint(value: string) {
    this._endpoint = value;
  }
  public resetEndpoint() {
    this._endpoint = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get endpointInput() {
    return this._endpoint;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // flush_period_sec - computed: true, optional: true, required: false
  private _flushPeriodSec?: number; 
  public get flushPeriodSec() {
    return this.getNumberAttribute('flush_period_sec');
  }
  public set flushPeriodSec(value: number) {
    this._flushPeriodSec = value;
  }
  public resetFlushPeriodSec() {
    this._flushPeriodSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get flushPeriodSecInput() {
    return this._flushPeriodSec;
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // log_group_name - computed: false, optional: false, required: true
  private _logGroupName?: string; 
  public get logGroupName() {
    return this.getStringAttribute('log_group_name');
  }
  public set logGroupName(value: string) {
    this._logGroupName = value;
  }
  // Temporarily expose input value. Use with caution.
  public get logGroupNameInput() {
    return this._logGroupName;
  }

  // log_stream_name - computed: false, optional: false, required: true
  private _logStreamName?: string; 
  public get logStreamName() {
    return this.getStringAttribute('log_stream_name');
  }
  public set logStreamName(value: string) {
    this._logStreamName = value;
  }
  // Temporarily expose input value. Use with caution.
  public get logStreamNameInput() {
    return this._logStreamName;
  }

  // max_queue_size - computed: true, optional: true, required: false
  private _maxQueueSize?: number; 
  public get maxQueueSize() {
    return this.getNumberAttribute('max_queue_size');
  }
  public set maxQueueSize(value: number) {
    this._maxQueueSize = value;
  }
  public resetMaxQueueSize() {
    this._maxQueueSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxQueueSizeInput() {
    return this._maxQueueSize;
  }

  // max_record_size_kb - computed: true, optional: true, required: false
  private _maxRecordSizeKb?: number; 
  public get maxRecordSizeKb() {
    return this.getNumberAttribute('max_record_size_kb');
  }
  public set maxRecordSizeKb(value: number) {
    this._maxRecordSizeKb = value;
  }
  public resetMaxRecordSizeKb() {
    this._maxRecordSizeKb = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxRecordSizeKbInput() {
    return this._maxRecordSizeKb;
  }

  // on_backpressure - computed: true, optional: true, required: false
  private _onBackpressure?: string; 
  public get onBackpressure() {
    return this.getStringAttribute('on_backpressure');
  }
  public set onBackpressure(value: string) {
    this._onBackpressure = value;
  }
  public resetOnBackpressure() {
    this._onBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get onBackpressureInput() {
    return this._onBackpressure;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // pq_compress - computed: true, optional: true, required: false
  private _pqCompress?: string; 
  public get pqCompress() {
    return this.getStringAttribute('pq_compress');
  }
  public set pqCompress(value: string) {
    this._pqCompress = value;
  }
  public resetPqCompress() {
    this._pqCompress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqCompressInput() {
    return this._pqCompress;
  }

  // pq_controls - computed: false, optional: true, required: false
  private _pqControls = new DestinationOutputCloudwatchPqControlsOutputReference(this, "pq_controls");
  public get pqControls() {
    return this._pqControls;
  }
  public putPqControls(value: DestinationOutputCloudwatchPqControls) {
    this._pqControls.internalValue = value;
  }
  public resetPqControls() {
    this._pqControls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqControlsInput() {
    return this._pqControls.internalValue;
  }

  // pq_max_file_size - computed: true, optional: true, required: false
  private _pqMaxFileSize?: string; 
  public get pqMaxFileSize() {
    return this.getStringAttribute('pq_max_file_size');
  }
  public set pqMaxFileSize(value: string) {
    this._pqMaxFileSize = value;
  }
  public resetPqMaxFileSize() {
    this._pqMaxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxFileSizeInput() {
    return this._pqMaxFileSize;
  }

  // pq_max_size - computed: true, optional: true, required: false
  private _pqMaxSize?: string; 
  public get pqMaxSize() {
    return this.getStringAttribute('pq_max_size');
  }
  public set pqMaxSize(value: string) {
    this._pqMaxSize = value;
  }
  public resetPqMaxSize() {
    this._pqMaxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxSizeInput() {
    return this._pqMaxSize;
  }

  // pq_mode - computed: true, optional: true, required: false
  private _pqMode?: string; 
  public get pqMode() {
    return this.getStringAttribute('pq_mode');
  }
  public set pqMode(value: string) {
    this._pqMode = value;
  }
  public resetPqMode() {
    this._pqMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqModeInput() {
    return this._pqMode;
  }

  // pq_on_backpressure - computed: true, optional: true, required: false
  private _pqOnBackpressure?: string; 
  public get pqOnBackpressure() {
    return this.getStringAttribute('pq_on_backpressure');
  }
  public set pqOnBackpressure(value: string) {
    this._pqOnBackpressure = value;
  }
  public resetPqOnBackpressure() {
    this._pqOnBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqOnBackpressureInput() {
    return this._pqOnBackpressure;
  }

  // pq_path - computed: true, optional: true, required: false
  private _pqPath?: string; 
  public get pqPath() {
    return this.getStringAttribute('pq_path');
  }
  public set pqPath(value: string) {
    this._pqPath = value;
  }
  public resetPqPath() {
    this._pqPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqPathInput() {
    return this._pqPath;
  }

  // region - computed: false, optional: false, required: true
  private _region?: string; 
  public get region() {
    return this.getStringAttribute('region');
  }
  public set region(value: string) {
    this._region = value;
  }
  // Temporarily expose input value. Use with caution.
  public get regionInput() {
    return this._region;
  }

  // reject_unauthorized - computed: true, optional: true, required: false
  private _rejectUnauthorized?: boolean | cdktf.IResolvable; 
  public get rejectUnauthorized() {
    return this.getBooleanAttribute('reject_unauthorized');
  }
  public set rejectUnauthorized(value: boolean | cdktf.IResolvable) {
    this._rejectUnauthorized = value;
  }
  public resetRejectUnauthorized() {
    this._rejectUnauthorized = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectUnauthorizedInput() {
    return this._rejectUnauthorized;
  }

  // reuse_connections - computed: true, optional: true, required: false
  private _reuseConnections?: boolean | cdktf.IResolvable; 
  public get reuseConnections() {
    return this.getBooleanAttribute('reuse_connections');
  }
  public set reuseConnections(value: boolean | cdktf.IResolvable) {
    this._reuseConnections = value;
  }
  public resetReuseConnections() {
    this._reuseConnections = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get reuseConnectionsInput() {
    return this._reuseConnections;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // system_fields - computed: true, optional: true, required: false
  private _systemFields?: string[]; 
  public get systemFields() {
    return this.getListAttribute('system_fields');
  }
  public set systemFields(value: string[]) {
    this._systemFields = value;
  }
  public resetSystemFields() {
    this._systemFields = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get systemFieldsInput() {
    return this._systemFields;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface DestinationOutputConfluentCloudKafkaSchemaRegistryAuth {
  /**
  * Select or create a secret that references your credentials
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#credentials_secret Destination#credentials_secret}
  */
  readonly credentialsSecret?: string;
  /**
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#disabled Destination#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
}

export function destinationOutputConfluentCloudKafkaSchemaRegistryAuthToTerraform(struct?: DestinationOutputConfluentCloudKafkaSchemaRegistryAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    credentials_secret: cdktf.stringToTerraform(struct!.credentialsSecret),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
  }
}


export function destinationOutputConfluentCloudKafkaSchemaRegistryAuthToHclTerraform(struct?: DestinationOutputConfluentCloudKafkaSchemaRegistryAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    credentials_secret: {
      value: cdktf.stringToHclTerraform(struct!.credentialsSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputConfluentCloudKafkaSchemaRegistryAuthOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DestinationOutputConfluentCloudKafkaSchemaRegistryAuth | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._credentialsSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.credentialsSecret = this._credentialsSecret;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputConfluentCloudKafkaSchemaRegistryAuth | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._credentialsSecret = undefined;
      this._disabled = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._credentialsSecret = value.credentialsSecret;
      this._disabled = value.disabled;
    }
  }

  // credentials_secret - computed: false, optional: true, required: false
  private _credentialsSecret?: string; 
  public get credentialsSecret() {
    return this.getStringAttribute('credentials_secret');
  }
  public set credentialsSecret(value: string) {
    this._credentialsSecret = value;
  }
  public resetCredentialsSecret() {
    this._credentialsSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get credentialsSecretInput() {
    return this._credentialsSecret;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }
}
export interface DestinationOutputConfluentCloudKafkaSchemaRegistryTls {
  /**
  * Path on client in which to find CA certificates to verify the server's cert. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#ca_path Destination#ca_path}
  */
  readonly caPath?: string;
  /**
  * Path on client in which to find certificates to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#cert_path Destination#cert_path}
  */
  readonly certPath?: string;
  /**
  * The name of the predefined certificate
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#certificate_name Destination#certificate_name}
  */
  readonly certificateName?: string;
  /**
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#disabled Destination#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#max_version Destination#max_version}
  */
  readonly maxVersion?: string;
  /**
  * must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#min_version Destination#min_version}
  */
  readonly minVersion?: string;
  /**
  * Passphrase to use to decrypt private key
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#passphrase Destination#passphrase}
  */
  readonly passphrase?: string;
  /**
  * Path on client in which to find the private key to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#priv_key_path Destination#priv_key_path}
  */
  readonly privKeyPath?: string;
  /**
  * Reject certificates that are not authorized by a CA in the CA certificate path, or by another 
  *                     trusted CA (such as the system's). Defaults to Enabled. Overrides the toggle from Advanced Settings, when also present.
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#reject_unauthorized Destination#reject_unauthorized}
  */
  readonly rejectUnauthorized?: boolean | cdktf.IResolvable;
  /**
  * Server name for the SNI (Server Name Indication) TLS extension. It must be a host name, and not an IP address.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#servername Destination#servername}
  */
  readonly servername?: string;
}

export function destinationOutputConfluentCloudKafkaSchemaRegistryTlsToTerraform(struct?: DestinationOutputConfluentCloudKafkaSchemaRegistryTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ca_path: cdktf.stringToTerraform(struct!.caPath),
    cert_path: cdktf.stringToTerraform(struct!.certPath),
    certificate_name: cdktf.stringToTerraform(struct!.certificateName),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    max_version: cdktf.stringToTerraform(struct!.maxVersion),
    min_version: cdktf.stringToTerraform(struct!.minVersion),
    passphrase: cdktf.stringToTerraform(struct!.passphrase),
    priv_key_path: cdktf.stringToTerraform(struct!.privKeyPath),
    reject_unauthorized: cdktf.booleanToTerraform(struct!.rejectUnauthorized),
    servername: cdktf.stringToTerraform(struct!.servername),
  }
}


export function destinationOutputConfluentCloudKafkaSchemaRegistryTlsToHclTerraform(struct?: DestinationOutputConfluentCloudKafkaSchemaRegistryTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ca_path: {
      value: cdktf.stringToHclTerraform(struct!.caPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    cert_path: {
      value: cdktf.stringToHclTerraform(struct!.certPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    certificate_name: {
      value: cdktf.stringToHclTerraform(struct!.certificateName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    max_version: {
      value: cdktf.stringToHclTerraform(struct!.maxVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    min_version: {
      value: cdktf.stringToHclTerraform(struct!.minVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    passphrase: {
      value: cdktf.stringToHclTerraform(struct!.passphrase),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    priv_key_path: {
      value: cdktf.stringToHclTerraform(struct!.privKeyPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reject_unauthorized: {
      value: cdktf.booleanToHclTerraform(struct!.rejectUnauthorized),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    servername: {
      value: cdktf.stringToHclTerraform(struct!.servername),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputConfluentCloudKafkaSchemaRegistryTlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DestinationOutputConfluentCloudKafkaSchemaRegistryTls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._caPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.caPath = this._caPath;
    }
    if (this._certPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.certPath = this._certPath;
    }
    if (this._certificateName !== undefined) {
      hasAnyValues = true;
      internalValueResult.certificateName = this._certificateName;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._maxVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxVersion = this._maxVersion;
    }
    if (this._minVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.minVersion = this._minVersion;
    }
    if (this._passphrase !== undefined) {
      hasAnyValues = true;
      internalValueResult.passphrase = this._passphrase;
    }
    if (this._privKeyPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.privKeyPath = this._privKeyPath;
    }
    if (this._rejectUnauthorized !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectUnauthorized = this._rejectUnauthorized;
    }
    if (this._servername !== undefined) {
      hasAnyValues = true;
      internalValueResult.servername = this._servername;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputConfluentCloudKafkaSchemaRegistryTls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._caPath = undefined;
      this._certPath = undefined;
      this._certificateName = undefined;
      this._disabled = undefined;
      this._maxVersion = undefined;
      this._minVersion = undefined;
      this._passphrase = undefined;
      this._privKeyPath = undefined;
      this._rejectUnauthorized = undefined;
      this._servername = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._caPath = value.caPath;
      this._certPath = value.certPath;
      this._certificateName = value.certificateName;
      this._disabled = value.disabled;
      this._maxVersion = value.maxVersion;
      this._minVersion = value.minVersion;
      this._passphrase = value.passphrase;
      this._privKeyPath = value.privKeyPath;
      this._rejectUnauthorized = value.rejectUnauthorized;
      this._servername = value.servername;
    }
  }

  // ca_path - computed: false, optional: true, required: false
  private _caPath?: string; 
  public get caPath() {
    return this.getStringAttribute('ca_path');
  }
  public set caPath(value: string) {
    this._caPath = value;
  }
  public resetCaPath() {
    this._caPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get caPathInput() {
    return this._caPath;
  }

  // cert_path - computed: false, optional: true, required: false
  private _certPath?: string; 
  public get certPath() {
    return this.getStringAttribute('cert_path');
  }
  public set certPath(value: string) {
    this._certPath = value;
  }
  public resetCertPath() {
    this._certPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certPathInput() {
    return this._certPath;
  }

  // certificate_name - computed: false, optional: true, required: false
  private _certificateName?: string; 
  public get certificateName() {
    return this.getStringAttribute('certificate_name');
  }
  public set certificateName(value: string) {
    this._certificateName = value;
  }
  public resetCertificateName() {
    this._certificateName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certificateNameInput() {
    return this._certificateName;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // max_version - computed: false, optional: true, required: false
  private _maxVersion?: string; 
  public get maxVersion() {
    return this.getStringAttribute('max_version');
  }
  public set maxVersion(value: string) {
    this._maxVersion = value;
  }
  public resetMaxVersion() {
    this._maxVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxVersionInput() {
    return this._maxVersion;
  }

  // min_version - computed: false, optional: true, required: false
  private _minVersion?: string; 
  public get minVersion() {
    return this.getStringAttribute('min_version');
  }
  public set minVersion(value: string) {
    this._minVersion = value;
  }
  public resetMinVersion() {
    this._minVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get minVersionInput() {
    return this._minVersion;
  }

  // passphrase - computed: false, optional: true, required: false
  private _passphrase?: string; 
  public get passphrase() {
    return this.getStringAttribute('passphrase');
  }
  public set passphrase(value: string) {
    this._passphrase = value;
  }
  public resetPassphrase() {
    this._passphrase = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passphraseInput() {
    return this._passphrase;
  }

  // priv_key_path - computed: false, optional: true, required: false
  private _privKeyPath?: string; 
  public get privKeyPath() {
    return this.getStringAttribute('priv_key_path');
  }
  public set privKeyPath(value: string) {
    this._privKeyPath = value;
  }
  public resetPrivKeyPath() {
    this._privKeyPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get privKeyPathInput() {
    return this._privKeyPath;
  }

  // reject_unauthorized - computed: true, optional: true, required: false
  private _rejectUnauthorized?: boolean | cdktf.IResolvable; 
  public get rejectUnauthorized() {
    return this.getBooleanAttribute('reject_unauthorized');
  }
  public set rejectUnauthorized(value: boolean | cdktf.IResolvable) {
    this._rejectUnauthorized = value;
  }
  public resetRejectUnauthorized() {
    this._rejectUnauthorized = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectUnauthorizedInput() {
    return this._rejectUnauthorized;
  }

  // servername - computed: false, optional: true, required: false
  private _servername?: string; 
  public get servername() {
    return this.getStringAttribute('servername');
  }
  public set servername(value: string) {
    this._servername = value;
  }
  public resetServername() {
    this._servername = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get servernameInput() {
    return this._servername;
  }
}
export interface DestinationOutputConfluentCloudKafkaSchemaRegistry {
  /**
  * Credentials to use when authenticating with the schema registry using basic HTTP authentication
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#auth Destination#auth}
  */
  readonly auth?: DestinationOutputConfluentCloudKafkaSchemaRegistryAuth;
  /**
  * Maximum time to wait for a Schema Registry connection to complete successfully. Default: 30000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#connection_timeout Destination#connection_timeout}
  */
  readonly connectionTimeout?: number;
  /**
  * Used when __keySchemaIdOut is not present, to transform key values, leave blank if key transformation is not required by default.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#default_key_schema_id Destination#default_key_schema_id}
  */
  readonly defaultKeySchemaId?: number;
  /**
  * Used when __valueSchemaIdOut is not present, to transform _raw, leave blank if value transformation is not required by default.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#default_value_schema_id Destination#default_value_schema_id}
  */
  readonly defaultValueSchemaId?: number;
  /**
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#disabled Destination#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * Maximum number of times to try fetching schemas from the Schema Registry. Default: 1
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#max_retries Destination#max_retries}
  */
  readonly maxRetries?: number;
  /**
  * Maximum time to wait for the Schema Registry to respond to a request. Default: 30000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#request_timeout Destination#request_timeout}
  */
  readonly requestTimeout?: number;
  /**
  * URL for accessing the Confluent Schema Registry. Example: http://localhost:8081. To connect over TLS, use https instead of http. Default: "http://localhost:8081"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#schema_registry_url Destination#schema_registry_url}
  */
  readonly schemaRegistryUrl?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#tls Destination#tls}
  */
  readonly tls?: DestinationOutputConfluentCloudKafkaSchemaRegistryTls;
}

export function destinationOutputConfluentCloudKafkaSchemaRegistryToTerraform(struct?: DestinationOutputConfluentCloudKafkaSchemaRegistry | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    auth: destinationOutputConfluentCloudKafkaSchemaRegistryAuthToTerraform(struct!.auth),
    connection_timeout: cdktf.numberToTerraform(struct!.connectionTimeout),
    default_key_schema_id: cdktf.numberToTerraform(struct!.defaultKeySchemaId),
    default_value_schema_id: cdktf.numberToTerraform(struct!.defaultValueSchemaId),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    max_retries: cdktf.numberToTerraform(struct!.maxRetries),
    request_timeout: cdktf.numberToTerraform(struct!.requestTimeout),
    schema_registry_url: cdktf.stringToTerraform(struct!.schemaRegistryUrl),
    tls: destinationOutputConfluentCloudKafkaSchemaRegistryTlsToTerraform(struct!.tls),
  }
}


export function destinationOutputConfluentCloudKafkaSchemaRegistryToHclTerraform(struct?: DestinationOutputConfluentCloudKafkaSchemaRegistry | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    auth: {
      value: destinationOutputConfluentCloudKafkaSchemaRegistryAuthToHclTerraform(struct!.auth),
      isBlock: true,
      type: "struct",
      storageClassType: "DestinationOutputConfluentCloudKafkaSchemaRegistryAuth",
    },
    connection_timeout: {
      value: cdktf.numberToHclTerraform(struct!.connectionTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    default_key_schema_id: {
      value: cdktf.numberToHclTerraform(struct!.defaultKeySchemaId),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    default_value_schema_id: {
      value: cdktf.numberToHclTerraform(struct!.defaultValueSchemaId),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    max_retries: {
      value: cdktf.numberToHclTerraform(struct!.maxRetries),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    request_timeout: {
      value: cdktf.numberToHclTerraform(struct!.requestTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    schema_registry_url: {
      value: cdktf.stringToHclTerraform(struct!.schemaRegistryUrl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tls: {
      value: destinationOutputConfluentCloudKafkaSchemaRegistryTlsToHclTerraform(struct!.tls),
      isBlock: true,
      type: "struct",
      storageClassType: "DestinationOutputConfluentCloudKafkaSchemaRegistryTls",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputConfluentCloudKafkaSchemaRegistryOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DestinationOutputConfluentCloudKafkaSchemaRegistry | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._auth?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.auth = this._auth?.internalValue;
    }
    if (this._connectionTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.connectionTimeout = this._connectionTimeout;
    }
    if (this._defaultKeySchemaId !== undefined) {
      hasAnyValues = true;
      internalValueResult.defaultKeySchemaId = this._defaultKeySchemaId;
    }
    if (this._defaultValueSchemaId !== undefined) {
      hasAnyValues = true;
      internalValueResult.defaultValueSchemaId = this._defaultValueSchemaId;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._maxRetries !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxRetries = this._maxRetries;
    }
    if (this._requestTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.requestTimeout = this._requestTimeout;
    }
    if (this._schemaRegistryUrl !== undefined) {
      hasAnyValues = true;
      internalValueResult.schemaRegistryUrl = this._schemaRegistryUrl;
    }
    if (this._tls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tls = this._tls?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputConfluentCloudKafkaSchemaRegistry | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._auth.internalValue = undefined;
      this._connectionTimeout = undefined;
      this._defaultKeySchemaId = undefined;
      this._defaultValueSchemaId = undefined;
      this._disabled = undefined;
      this._maxRetries = undefined;
      this._requestTimeout = undefined;
      this._schemaRegistryUrl = undefined;
      this._tls.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._auth.internalValue = value.auth;
      this._connectionTimeout = value.connectionTimeout;
      this._defaultKeySchemaId = value.defaultKeySchemaId;
      this._defaultValueSchemaId = value.defaultValueSchemaId;
      this._disabled = value.disabled;
      this._maxRetries = value.maxRetries;
      this._requestTimeout = value.requestTimeout;
      this._schemaRegistryUrl = value.schemaRegistryUrl;
      this._tls.internalValue = value.tls;
    }
  }

  // auth - computed: false, optional: true, required: false
  private _auth = new DestinationOutputConfluentCloudKafkaSchemaRegistryAuthOutputReference(this, "auth");
  public get auth() {
    return this._auth;
  }
  public putAuth(value: DestinationOutputConfluentCloudKafkaSchemaRegistryAuth) {
    this._auth.internalValue = value;
  }
  public resetAuth() {
    this._auth.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authInput() {
    return this._auth.internalValue;
  }

  // connection_timeout - computed: true, optional: true, required: false
  private _connectionTimeout?: number; 
  public get connectionTimeout() {
    return this.getNumberAttribute('connection_timeout');
  }
  public set connectionTimeout(value: number) {
    this._connectionTimeout = value;
  }
  public resetConnectionTimeout() {
    this._connectionTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectionTimeoutInput() {
    return this._connectionTimeout;
  }

  // default_key_schema_id - computed: false, optional: true, required: false
  private _defaultKeySchemaId?: number; 
  public get defaultKeySchemaId() {
    return this.getNumberAttribute('default_key_schema_id');
  }
  public set defaultKeySchemaId(value: number) {
    this._defaultKeySchemaId = value;
  }
  public resetDefaultKeySchemaId() {
    this._defaultKeySchemaId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get defaultKeySchemaIdInput() {
    return this._defaultKeySchemaId;
  }

  // default_value_schema_id - computed: false, optional: true, required: false
  private _defaultValueSchemaId?: number; 
  public get defaultValueSchemaId() {
    return this.getNumberAttribute('default_value_schema_id');
  }
  public set defaultValueSchemaId(value: number) {
    this._defaultValueSchemaId = value;
  }
  public resetDefaultValueSchemaId() {
    this._defaultValueSchemaId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get defaultValueSchemaIdInput() {
    return this._defaultValueSchemaId;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // max_retries - computed: true, optional: true, required: false
  private _maxRetries?: number; 
  public get maxRetries() {
    return this.getNumberAttribute('max_retries');
  }
  public set maxRetries(value: number) {
    this._maxRetries = value;
  }
  public resetMaxRetries() {
    this._maxRetries = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxRetriesInput() {
    return this._maxRetries;
  }

  // request_timeout - computed: true, optional: true, required: false
  private _requestTimeout?: number; 
  public get requestTimeout() {
    return this.getNumberAttribute('request_timeout');
  }
  public set requestTimeout(value: number) {
    this._requestTimeout = value;
  }
  public resetRequestTimeout() {
    this._requestTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestTimeoutInput() {
    return this._requestTimeout;
  }

  // schema_registry_url - computed: true, optional: true, required: false
  private _schemaRegistryUrl?: string; 
  public get schemaRegistryUrl() {
    return this.getStringAttribute('schema_registry_url');
  }
  public set schemaRegistryUrl(value: string) {
    this._schemaRegistryUrl = value;
  }
  public resetSchemaRegistryUrl() {
    this._schemaRegistryUrl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get schemaRegistryUrlInput() {
    return this._schemaRegistryUrl;
  }

  // tls - computed: false, optional: true, required: false
  private _tls = new DestinationOutputConfluentCloudKafkaSchemaRegistryTlsOutputReference(this, "tls");
  public get tls() {
    return this._tls;
  }
  public putTls(value: DestinationOutputConfluentCloudKafkaSchemaRegistryTls) {
    this._tls.internalValue = value;
  }
  public resetTls() {
    this._tls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsInput() {
    return this._tls.internalValue;
  }
}
export interface DestinationOutputConfluentCloudPqControls {
}

export function destinationOutputConfluentCloudPqControlsToTerraform(struct?: DestinationOutputConfluentCloudPqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function destinationOutputConfluentCloudPqControlsToHclTerraform(struct?: DestinationOutputConfluentCloudPqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class DestinationOutputConfluentCloudPqControlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DestinationOutputConfluentCloudPqControls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputConfluentCloudPqControls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface DestinationOutputConfluentCloudSasl {
  /**
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#disabled Destination#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * Default: "plain"; must be one of ["plain", "scram-sha-256", "scram-sha-512", "kerberos"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#mechanism Destination#mechanism}
  */
  readonly mechanism?: string;
}

export function destinationOutputConfluentCloudSaslToTerraform(struct?: DestinationOutputConfluentCloudSasl | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    mechanism: cdktf.stringToTerraform(struct!.mechanism),
  }
}


export function destinationOutputConfluentCloudSaslToHclTerraform(struct?: DestinationOutputConfluentCloudSasl | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    mechanism: {
      value: cdktf.stringToHclTerraform(struct!.mechanism),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputConfluentCloudSaslOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DestinationOutputConfluentCloudSasl | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._mechanism !== undefined) {
      hasAnyValues = true;
      internalValueResult.mechanism = this._mechanism;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputConfluentCloudSasl | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._disabled = undefined;
      this._mechanism = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._disabled = value.disabled;
      this._mechanism = value.mechanism;
    }
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // mechanism - computed: true, optional: true, required: false
  private _mechanism?: string; 
  public get mechanism() {
    return this.getStringAttribute('mechanism');
  }
  public set mechanism(value: string) {
    this._mechanism = value;
  }
  public resetMechanism() {
    this._mechanism = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get mechanismInput() {
    return this._mechanism;
  }
}
export interface DestinationOutputConfluentCloudTls {
  /**
  * Path on client in which to find CA certificates to verify the server's cert. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#ca_path Destination#ca_path}
  */
  readonly caPath?: string;
  /**
  * Path on client in which to find certificates to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#cert_path Destination#cert_path}
  */
  readonly certPath?: string;
  /**
  * The name of the predefined certificate
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#certificate_name Destination#certificate_name}
  */
  readonly certificateName?: string;
  /**
  * Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#disabled Destination#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#max_version Destination#max_version}
  */
  readonly maxVersion?: string;
  /**
  * must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#min_version Destination#min_version}
  */
  readonly minVersion?: string;
  /**
  * Passphrase to use to decrypt private key
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#passphrase Destination#passphrase}
  */
  readonly passphrase?: string;
  /**
  * Path on client in which to find the private key to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#priv_key_path Destination#priv_key_path}
  */
  readonly privKeyPath?: string;
  /**
  * Reject certificates that are not authorized by a CA in the CA certificate path, or by another 
  *                     trusted CA (such as the system's). Defaults to Enabled. Overrides the toggle from Advanced Settings, when also present.
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#reject_unauthorized Destination#reject_unauthorized}
  */
  readonly rejectUnauthorized?: boolean | cdktf.IResolvable;
  /**
  * Server name for the SNI (Server Name Indication) TLS extension. It must be a host name, and not an IP address.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#servername Destination#servername}
  */
  readonly servername?: string;
}

export function destinationOutputConfluentCloudTlsToTerraform(struct?: DestinationOutputConfluentCloudTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ca_path: cdktf.stringToTerraform(struct!.caPath),
    cert_path: cdktf.stringToTerraform(struct!.certPath),
    certificate_name: cdktf.stringToTerraform(struct!.certificateName),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    max_version: cdktf.stringToTerraform(struct!.maxVersion),
    min_version: cdktf.stringToTerraform(struct!.minVersion),
    passphrase: cdktf.stringToTerraform(struct!.passphrase),
    priv_key_path: cdktf.stringToTerraform(struct!.privKeyPath),
    reject_unauthorized: cdktf.booleanToTerraform(struct!.rejectUnauthorized),
    servername: cdktf.stringToTerraform(struct!.servername),
  }
}


export function destinationOutputConfluentCloudTlsToHclTerraform(struct?: DestinationOutputConfluentCloudTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ca_path: {
      value: cdktf.stringToHclTerraform(struct!.caPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    cert_path: {
      value: cdktf.stringToHclTerraform(struct!.certPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    certificate_name: {
      value: cdktf.stringToHclTerraform(struct!.certificateName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    max_version: {
      value: cdktf.stringToHclTerraform(struct!.maxVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    min_version: {
      value: cdktf.stringToHclTerraform(struct!.minVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    passphrase: {
      value: cdktf.stringToHclTerraform(struct!.passphrase),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    priv_key_path: {
      value: cdktf.stringToHclTerraform(struct!.privKeyPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reject_unauthorized: {
      value: cdktf.booleanToHclTerraform(struct!.rejectUnauthorized),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    servername: {
      value: cdktf.stringToHclTerraform(struct!.servername),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputConfluentCloudTlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DestinationOutputConfluentCloudTls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._caPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.caPath = this._caPath;
    }
    if (this._certPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.certPath = this._certPath;
    }
    if (this._certificateName !== undefined) {
      hasAnyValues = true;
      internalValueResult.certificateName = this._certificateName;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._maxVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxVersion = this._maxVersion;
    }
    if (this._minVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.minVersion = this._minVersion;
    }
    if (this._passphrase !== undefined) {
      hasAnyValues = true;
      internalValueResult.passphrase = this._passphrase;
    }
    if (this._privKeyPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.privKeyPath = this._privKeyPath;
    }
    if (this._rejectUnauthorized !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectUnauthorized = this._rejectUnauthorized;
    }
    if (this._servername !== undefined) {
      hasAnyValues = true;
      internalValueResult.servername = this._servername;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputConfluentCloudTls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._caPath = undefined;
      this._certPath = undefined;
      this._certificateName = undefined;
      this._disabled = undefined;
      this._maxVersion = undefined;
      this._minVersion = undefined;
      this._passphrase = undefined;
      this._privKeyPath = undefined;
      this._rejectUnauthorized = undefined;
      this._servername = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._caPath = value.caPath;
      this._certPath = value.certPath;
      this._certificateName = value.certificateName;
      this._disabled = value.disabled;
      this._maxVersion = value.maxVersion;
      this._minVersion = value.minVersion;
      this._passphrase = value.passphrase;
      this._privKeyPath = value.privKeyPath;
      this._rejectUnauthorized = value.rejectUnauthorized;
      this._servername = value.servername;
    }
  }

  // ca_path - computed: false, optional: true, required: false
  private _caPath?: string; 
  public get caPath() {
    return this.getStringAttribute('ca_path');
  }
  public set caPath(value: string) {
    this._caPath = value;
  }
  public resetCaPath() {
    this._caPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get caPathInput() {
    return this._caPath;
  }

  // cert_path - computed: false, optional: true, required: false
  private _certPath?: string; 
  public get certPath() {
    return this.getStringAttribute('cert_path');
  }
  public set certPath(value: string) {
    this._certPath = value;
  }
  public resetCertPath() {
    this._certPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certPathInput() {
    return this._certPath;
  }

  // certificate_name - computed: false, optional: true, required: false
  private _certificateName?: string; 
  public get certificateName() {
    return this.getStringAttribute('certificate_name');
  }
  public set certificateName(value: string) {
    this._certificateName = value;
  }
  public resetCertificateName() {
    this._certificateName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certificateNameInput() {
    return this._certificateName;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // max_version - computed: false, optional: true, required: false
  private _maxVersion?: string; 
  public get maxVersion() {
    return this.getStringAttribute('max_version');
  }
  public set maxVersion(value: string) {
    this._maxVersion = value;
  }
  public resetMaxVersion() {
    this._maxVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxVersionInput() {
    return this._maxVersion;
  }

  // min_version - computed: false, optional: true, required: false
  private _minVersion?: string; 
  public get minVersion() {
    return this.getStringAttribute('min_version');
  }
  public set minVersion(value: string) {
    this._minVersion = value;
  }
  public resetMinVersion() {
    this._minVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get minVersionInput() {
    return this._minVersion;
  }

  // passphrase - computed: false, optional: true, required: false
  private _passphrase?: string; 
  public get passphrase() {
    return this.getStringAttribute('passphrase');
  }
  public set passphrase(value: string) {
    this._passphrase = value;
  }
  public resetPassphrase() {
    this._passphrase = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passphraseInput() {
    return this._passphrase;
  }

  // priv_key_path - computed: false, optional: true, required: false
  private _privKeyPath?: string; 
  public get privKeyPath() {
    return this.getStringAttribute('priv_key_path');
  }
  public set privKeyPath(value: string) {
    this._privKeyPath = value;
  }
  public resetPrivKeyPath() {
    this._privKeyPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get privKeyPathInput() {
    return this._privKeyPath;
  }

  // reject_unauthorized - computed: true, optional: true, required: false
  private _rejectUnauthorized?: boolean | cdktf.IResolvable; 
  public get rejectUnauthorized() {
    return this.getBooleanAttribute('reject_unauthorized');
  }
  public set rejectUnauthorized(value: boolean | cdktf.IResolvable) {
    this._rejectUnauthorized = value;
  }
  public resetRejectUnauthorized() {
    this._rejectUnauthorized = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectUnauthorizedInput() {
    return this._rejectUnauthorized;
  }

  // servername - computed: false, optional: true, required: false
  private _servername?: string; 
  public get servername() {
    return this.getStringAttribute('servername');
  }
  public set servername(value: string) {
    this._servername = value;
  }
  public resetServername() {
    this._servername = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get servernameInput() {
    return this._servername;
  }
}
export interface DestinationOutputConfluentCloud {
  /**
  * Control the number of required acknowledgments. Default: 1; must be one of ["1", "0", "-1"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#ack Destination#ack}
  */
  readonly ack?: number;
  /**
  * Maximum time to wait for Kafka to respond to an authentication request. Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#authentication_timeout Destination#authentication_timeout}
  */
  readonly authenticationTimeout?: number;
  /**
  * Set the backoff multiplier (2-20) to control the retry frequency for failed messages. For faster retries, use a lower multiplier. For slower retries with more delay between attempts, use a higher multiplier. The multiplier is used in an exponential backoff formula; see the Kafka [documentation](https://kafka.js.org/docs/retry-detailed) for details. Default: 2
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#backoff_rate Destination#backoff_rate}
  */
  readonly backoffRate?: number;
  /**
  * List of Confluent Cloud bootstrap servers to use, such as yourAccount.confluent.cloud:9092.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#brokers Destination#brokers}
  */
  readonly brokers: string[];
  /**
  * Codec to use to compress the data before sending to Kafka. Default: "gzip"; must be one of ["none", "gzip", "snappy", "lz4"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#compression Destination#compression}
  */
  readonly compression?: string;
  /**
  * Maximum time to wait for a connection to complete successfully. Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#connection_timeout Destination#connection_timeout}
  */
  readonly connectionTimeout?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#description Destination#description}
  */
  readonly description?: string;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#environment Destination#environment}
  */
  readonly environment?: string;
  /**
  * The maximum number of events you want the Destination to allow in a batch before forcing a flush. Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#flush_event_count Destination#flush_event_count}
  */
  readonly flushEventCount?: number;
  /**
  * The maximum amount of time you want the Destination to wait before forcing a flush. Shorter intervals tend to result in smaller batches being sent. Default: 1
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#flush_period_sec Destination#flush_period_sec}
  */
  readonly flushPeriodSec?: number;
  /**
  * Format to use to serialize events before writing to Kafka. Default: "json"; must be one of ["json", "raw", "protobuf"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#format Destination#format}
  */
  readonly format?: string;
  /**
  * Unique ID for this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#id Destination#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * Initial value used to calculate the retry, in milliseconds. Maximum is 600,000 ms (10 minutes). Default: 300
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#initial_backoff Destination#initial_backoff}
  */
  readonly initialBackoff?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#kafka_schema_registry Destination#kafka_schema_registry}
  */
  readonly kafkaSchemaRegistry?: DestinationOutputConfluentCloudKafkaSchemaRegistry;
  /**
  * The maximum wait time for a retry, in milliseconds. Default (and minimum) is 30,000 ms (30 seconds); maximum is 180,000 ms (180 seconds). Default: 30000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#max_back_off Destination#max_back_off}
  */
  readonly maxBackOff?: number;
  /**
  * Maximum size of each record batch before compression. The value must not exceed the Kafka brokers' message.max.bytes setting. Default: 768
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#max_record_size_kb Destination#max_record_size_kb}
  */
  readonly maxRecordSizeKb?: number;
  /**
  * If messages are failing, you can set the maximum number of retries as high as 100 to prevent loss of data. Default: 5
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#max_retries Destination#max_retries}
  */
  readonly maxRetries?: number;
  /**
  * How to handle events when all receivers are exerting backpressure. Default: "block"; must be one of ["block", "drop", "queue"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#on_backpressure Destination#on_backpressure}
  */
  readonly onBackpressure?: string;
  /**
  * Pipeline to process data before sending out to this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pipeline Destination#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pq_compress Destination#pq_compress}
  */
  readonly pqCompress?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pq_controls Destination#pq_controls}
  */
  readonly pqControls?: DestinationOutputConfluentCloudPqControls;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.). Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pq_max_file_size Destination#pq_max_file_size}
  */
  readonly pqMaxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pq_max_size Destination#pq_max_size}
  */
  readonly pqMaxSize?: string;
  /**
  * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem. Default: "error"; must be one of ["error", "backpressure", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pq_mode Destination#pq_mode}
  */
  readonly pqMode?: string;
  /**
  * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged. Default: "block"; must be one of ["block", "drop"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pq_on_backpressure Destination#pq_on_backpressure}
  */
  readonly pqOnBackpressure?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pq_path Destination#pq_path}
  */
  readonly pqPath?: string;
  /**
  * Select a set of Protobuf definitions for the events you want to send
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#protobuf_library_id Destination#protobuf_library_id}
  */
  readonly protobufLibraryId?: string;
  /**
  * Specifies a time window during which @{product} can reauthenticate if needed. Creates the window measuring backward from the moment when credentials are set to expire. Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#reauthentication_threshold Destination#reauthentication_threshold}
  */
  readonly reauthenticationThreshold?: number;
  /**
  * Maximum time to wait for Kafka to respond to a request. Default: 60000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#request_timeout Destination#request_timeout}
  */
  readonly requestTimeout?: number;
  /**
  * Authentication parameters to use when connecting to brokers. Using TLS is highly recommended.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#sasl Destination#sasl}
  */
  readonly sasl?: DestinationOutputConfluentCloudSasl;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#streamtags Destination#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Fields to automatically add to events, such as cribl_pipe. Supports wildcards. Default: ["cribl_pipe"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#system_fields Destination#system_fields}
  */
  readonly systemFields?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#tls Destination#tls}
  */
  readonly tls?: DestinationOutputConfluentCloudTls;
  /**
  * The topic to publish events to. Can be overridden using the __topicOut field.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#topic Destination#topic}
  */
  readonly topic: string;
  /**
  * must be "confluent_cloud"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#type Destination#type}
  */
  readonly type?: string;
}

export function destinationOutputConfluentCloudToTerraform(struct?: DestinationOutputConfluentCloud | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ack: cdktf.numberToTerraform(struct!.ack),
    authentication_timeout: cdktf.numberToTerraform(struct!.authenticationTimeout),
    backoff_rate: cdktf.numberToTerraform(struct!.backoffRate),
    brokers: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.brokers),
    compression: cdktf.stringToTerraform(struct!.compression),
    connection_timeout: cdktf.numberToTerraform(struct!.connectionTimeout),
    description: cdktf.stringToTerraform(struct!.description),
    environment: cdktf.stringToTerraform(struct!.environment),
    flush_event_count: cdktf.numberToTerraform(struct!.flushEventCount),
    flush_period_sec: cdktf.numberToTerraform(struct!.flushPeriodSec),
    format: cdktf.stringToTerraform(struct!.format),
    id: cdktf.stringToTerraform(struct!.id),
    initial_backoff: cdktf.numberToTerraform(struct!.initialBackoff),
    kafka_schema_registry: destinationOutputConfluentCloudKafkaSchemaRegistryToTerraform(struct!.kafkaSchemaRegistry),
    max_back_off: cdktf.numberToTerraform(struct!.maxBackOff),
    max_record_size_kb: cdktf.numberToTerraform(struct!.maxRecordSizeKb),
    max_retries: cdktf.numberToTerraform(struct!.maxRetries),
    on_backpressure: cdktf.stringToTerraform(struct!.onBackpressure),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    pq_compress: cdktf.stringToTerraform(struct!.pqCompress),
    pq_controls: destinationOutputConfluentCloudPqControlsToTerraform(struct!.pqControls),
    pq_max_file_size: cdktf.stringToTerraform(struct!.pqMaxFileSize),
    pq_max_size: cdktf.stringToTerraform(struct!.pqMaxSize),
    pq_mode: cdktf.stringToTerraform(struct!.pqMode),
    pq_on_backpressure: cdktf.stringToTerraform(struct!.pqOnBackpressure),
    pq_path: cdktf.stringToTerraform(struct!.pqPath),
    protobuf_library_id: cdktf.stringToTerraform(struct!.protobufLibraryId),
    reauthentication_threshold: cdktf.numberToTerraform(struct!.reauthenticationThreshold),
    request_timeout: cdktf.numberToTerraform(struct!.requestTimeout),
    sasl: destinationOutputConfluentCloudSaslToTerraform(struct!.sasl),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    system_fields: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.systemFields),
    tls: destinationOutputConfluentCloudTlsToTerraform(struct!.tls),
    topic: cdktf.stringToTerraform(struct!.topic),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function destinationOutputConfluentCloudToHclTerraform(struct?: DestinationOutputConfluentCloud | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ack: {
      value: cdktf.numberToHclTerraform(struct!.ack),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    authentication_timeout: {
      value: cdktf.numberToHclTerraform(struct!.authenticationTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    backoff_rate: {
      value: cdktf.numberToHclTerraform(struct!.backoffRate),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    brokers: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.brokers),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    compression: {
      value: cdktf.stringToHclTerraform(struct!.compression),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    connection_timeout: {
      value: cdktf.numberToHclTerraform(struct!.connectionTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    flush_event_count: {
      value: cdktf.numberToHclTerraform(struct!.flushEventCount),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    flush_period_sec: {
      value: cdktf.numberToHclTerraform(struct!.flushPeriodSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    format: {
      value: cdktf.stringToHclTerraform(struct!.format),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    initial_backoff: {
      value: cdktf.numberToHclTerraform(struct!.initialBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    kafka_schema_registry: {
      value: destinationOutputConfluentCloudKafkaSchemaRegistryToHclTerraform(struct!.kafkaSchemaRegistry),
      isBlock: true,
      type: "struct",
      storageClassType: "DestinationOutputConfluentCloudKafkaSchemaRegistry",
    },
    max_back_off: {
      value: cdktf.numberToHclTerraform(struct!.maxBackOff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_record_size_kb: {
      value: cdktf.numberToHclTerraform(struct!.maxRecordSizeKb),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_retries: {
      value: cdktf.numberToHclTerraform(struct!.maxRetries),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.onBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_compress: {
      value: cdktf.stringToHclTerraform(struct!.pqCompress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_controls: {
      value: destinationOutputConfluentCloudPqControlsToHclTerraform(struct!.pqControls),
      isBlock: true,
      type: "struct",
      storageClassType: "DestinationOutputConfluentCloudPqControls",
    },
    pq_max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_max_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_mode: {
      value: cdktf.stringToHclTerraform(struct!.pqMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.pqOnBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_path: {
      value: cdktf.stringToHclTerraform(struct!.pqPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    protobuf_library_id: {
      value: cdktf.stringToHclTerraform(struct!.protobufLibraryId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reauthentication_threshold: {
      value: cdktf.numberToHclTerraform(struct!.reauthenticationThreshold),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    request_timeout: {
      value: cdktf.numberToHclTerraform(struct!.requestTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    sasl: {
      value: destinationOutputConfluentCloudSaslToHclTerraform(struct!.sasl),
      isBlock: true,
      type: "struct",
      storageClassType: "DestinationOutputConfluentCloudSasl",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    system_fields: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.systemFields),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    tls: {
      value: destinationOutputConfluentCloudTlsToHclTerraform(struct!.tls),
      isBlock: true,
      type: "struct",
      storageClassType: "DestinationOutputConfluentCloudTls",
    },
    topic: {
      value: cdktf.stringToHclTerraform(struct!.topic),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputConfluentCloudOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DestinationOutputConfluentCloud | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._ack !== undefined) {
      hasAnyValues = true;
      internalValueResult.ack = this._ack;
    }
    if (this._authenticationTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.authenticationTimeout = this._authenticationTimeout;
    }
    if (this._backoffRate !== undefined) {
      hasAnyValues = true;
      internalValueResult.backoffRate = this._backoffRate;
    }
    if (this._brokers !== undefined) {
      hasAnyValues = true;
      internalValueResult.brokers = this._brokers;
    }
    if (this._compression !== undefined) {
      hasAnyValues = true;
      internalValueResult.compression = this._compression;
    }
    if (this._connectionTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.connectionTimeout = this._connectionTimeout;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._flushEventCount !== undefined) {
      hasAnyValues = true;
      internalValueResult.flushEventCount = this._flushEventCount;
    }
    if (this._flushPeriodSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.flushPeriodSec = this._flushPeriodSec;
    }
    if (this._format !== undefined) {
      hasAnyValues = true;
      internalValueResult.format = this._format;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._initialBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.initialBackoff = this._initialBackoff;
    }
    if (this._kafkaSchemaRegistry?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.kafkaSchemaRegistry = this._kafkaSchemaRegistry?.internalValue;
    }
    if (this._maxBackOff !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBackOff = this._maxBackOff;
    }
    if (this._maxRecordSizeKb !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxRecordSizeKb = this._maxRecordSizeKb;
    }
    if (this._maxRetries !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxRetries = this._maxRetries;
    }
    if (this._onBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.onBackpressure = this._onBackpressure;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._pqCompress !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqCompress = this._pqCompress;
    }
    if (this._pqControls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqControls = this._pqControls?.internalValue;
    }
    if (this._pqMaxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxFileSize = this._pqMaxFileSize;
    }
    if (this._pqMaxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxSize = this._pqMaxSize;
    }
    if (this._pqMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMode = this._pqMode;
    }
    if (this._pqOnBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqOnBackpressure = this._pqOnBackpressure;
    }
    if (this._pqPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqPath = this._pqPath;
    }
    if (this._protobufLibraryId !== undefined) {
      hasAnyValues = true;
      internalValueResult.protobufLibraryId = this._protobufLibraryId;
    }
    if (this._reauthenticationThreshold !== undefined) {
      hasAnyValues = true;
      internalValueResult.reauthenticationThreshold = this._reauthenticationThreshold;
    }
    if (this._requestTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.requestTimeout = this._requestTimeout;
    }
    if (this._sasl?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.sasl = this._sasl?.internalValue;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._systemFields !== undefined) {
      hasAnyValues = true;
      internalValueResult.systemFields = this._systemFields;
    }
    if (this._tls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tls = this._tls?.internalValue;
    }
    if (this._topic !== undefined) {
      hasAnyValues = true;
      internalValueResult.topic = this._topic;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputConfluentCloud | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._ack = undefined;
      this._authenticationTimeout = undefined;
      this._backoffRate = undefined;
      this._brokers = undefined;
      this._compression = undefined;
      this._connectionTimeout = undefined;
      this._description = undefined;
      this._environment = undefined;
      this._flushEventCount = undefined;
      this._flushPeriodSec = undefined;
      this._format = undefined;
      this._id = undefined;
      this._initialBackoff = undefined;
      this._kafkaSchemaRegistry.internalValue = undefined;
      this._maxBackOff = undefined;
      this._maxRecordSizeKb = undefined;
      this._maxRetries = undefined;
      this._onBackpressure = undefined;
      this._pipeline = undefined;
      this._pqCompress = undefined;
      this._pqControls.internalValue = undefined;
      this._pqMaxFileSize = undefined;
      this._pqMaxSize = undefined;
      this._pqMode = undefined;
      this._pqOnBackpressure = undefined;
      this._pqPath = undefined;
      this._protobufLibraryId = undefined;
      this._reauthenticationThreshold = undefined;
      this._requestTimeout = undefined;
      this._sasl.internalValue = undefined;
      this._streamtags = undefined;
      this._systemFields = undefined;
      this._tls.internalValue = undefined;
      this._topic = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._ack = value.ack;
      this._authenticationTimeout = value.authenticationTimeout;
      this._backoffRate = value.backoffRate;
      this._brokers = value.brokers;
      this._compression = value.compression;
      this._connectionTimeout = value.connectionTimeout;
      this._description = value.description;
      this._environment = value.environment;
      this._flushEventCount = value.flushEventCount;
      this._flushPeriodSec = value.flushPeriodSec;
      this._format = value.format;
      this._id = value.id;
      this._initialBackoff = value.initialBackoff;
      this._kafkaSchemaRegistry.internalValue = value.kafkaSchemaRegistry;
      this._maxBackOff = value.maxBackOff;
      this._maxRecordSizeKb = value.maxRecordSizeKb;
      this._maxRetries = value.maxRetries;
      this._onBackpressure = value.onBackpressure;
      this._pipeline = value.pipeline;
      this._pqCompress = value.pqCompress;
      this._pqControls.internalValue = value.pqControls;
      this._pqMaxFileSize = value.pqMaxFileSize;
      this._pqMaxSize = value.pqMaxSize;
      this._pqMode = value.pqMode;
      this._pqOnBackpressure = value.pqOnBackpressure;
      this._pqPath = value.pqPath;
      this._protobufLibraryId = value.protobufLibraryId;
      this._reauthenticationThreshold = value.reauthenticationThreshold;
      this._requestTimeout = value.requestTimeout;
      this._sasl.internalValue = value.sasl;
      this._streamtags = value.streamtags;
      this._systemFields = value.systemFields;
      this._tls.internalValue = value.tls;
      this._topic = value.topic;
      this._type = value.type;
    }
  }

  // ack - computed: true, optional: true, required: false
  private _ack?: number; 
  public get ack() {
    return this.getNumberAttribute('ack');
  }
  public set ack(value: number) {
    this._ack = value;
  }
  public resetAck() {
    this._ack = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ackInput() {
    return this._ack;
  }

  // authentication_timeout - computed: true, optional: true, required: false
  private _authenticationTimeout?: number; 
  public get authenticationTimeout() {
    return this.getNumberAttribute('authentication_timeout');
  }
  public set authenticationTimeout(value: number) {
    this._authenticationTimeout = value;
  }
  public resetAuthenticationTimeout() {
    this._authenticationTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authenticationTimeoutInput() {
    return this._authenticationTimeout;
  }

  // backoff_rate - computed: true, optional: true, required: false
  private _backoffRate?: number; 
  public get backoffRate() {
    return this.getNumberAttribute('backoff_rate');
  }
  public set backoffRate(value: number) {
    this._backoffRate = value;
  }
  public resetBackoffRate() {
    this._backoffRate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get backoffRateInput() {
    return this._backoffRate;
  }

  // brokers - computed: false, optional: false, required: true
  private _brokers?: string[]; 
  public get brokers() {
    return this.getListAttribute('brokers');
  }
  public set brokers(value: string[]) {
    this._brokers = value;
  }
  // Temporarily expose input value. Use with caution.
  public get brokersInput() {
    return this._brokers;
  }

  // compression - computed: true, optional: true, required: false
  private _compression?: string; 
  public get compression() {
    return this.getStringAttribute('compression');
  }
  public set compression(value: string) {
    this._compression = value;
  }
  public resetCompression() {
    this._compression = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressionInput() {
    return this._compression;
  }

  // connection_timeout - computed: true, optional: true, required: false
  private _connectionTimeout?: number; 
  public get connectionTimeout() {
    return this.getNumberAttribute('connection_timeout');
  }
  public set connectionTimeout(value: number) {
    this._connectionTimeout = value;
  }
  public resetConnectionTimeout() {
    this._connectionTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectionTimeoutInput() {
    return this._connectionTimeout;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // flush_event_count - computed: true, optional: true, required: false
  private _flushEventCount?: number; 
  public get flushEventCount() {
    return this.getNumberAttribute('flush_event_count');
  }
  public set flushEventCount(value: number) {
    this._flushEventCount = value;
  }
  public resetFlushEventCount() {
    this._flushEventCount = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get flushEventCountInput() {
    return this._flushEventCount;
  }

  // flush_period_sec - computed: true, optional: true, required: false
  private _flushPeriodSec?: number; 
  public get flushPeriodSec() {
    return this.getNumberAttribute('flush_period_sec');
  }
  public set flushPeriodSec(value: number) {
    this._flushPeriodSec = value;
  }
  public resetFlushPeriodSec() {
    this._flushPeriodSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get flushPeriodSecInput() {
    return this._flushPeriodSec;
  }

  // format - computed: true, optional: true, required: false
  private _format?: string; 
  public get format() {
    return this.getStringAttribute('format');
  }
  public set format(value: string) {
    this._format = value;
  }
  public resetFormat() {
    this._format = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get formatInput() {
    return this._format;
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // initial_backoff - computed: true, optional: true, required: false
  private _initialBackoff?: number; 
  public get initialBackoff() {
    return this.getNumberAttribute('initial_backoff');
  }
  public set initialBackoff(value: number) {
    this._initialBackoff = value;
  }
  public resetInitialBackoff() {
    this._initialBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get initialBackoffInput() {
    return this._initialBackoff;
  }

  // kafka_schema_registry - computed: false, optional: true, required: false
  private _kafkaSchemaRegistry = new DestinationOutputConfluentCloudKafkaSchemaRegistryOutputReference(this, "kafka_schema_registry");
  public get kafkaSchemaRegistry() {
    return this._kafkaSchemaRegistry;
  }
  public putKafkaSchemaRegistry(value: DestinationOutputConfluentCloudKafkaSchemaRegistry) {
    this._kafkaSchemaRegistry.internalValue = value;
  }
  public resetKafkaSchemaRegistry() {
    this._kafkaSchemaRegistry.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get kafkaSchemaRegistryInput() {
    return this._kafkaSchemaRegistry.internalValue;
  }

  // max_back_off - computed: true, optional: true, required: false
  private _maxBackOff?: number; 
  public get maxBackOff() {
    return this.getNumberAttribute('max_back_off');
  }
  public set maxBackOff(value: number) {
    this._maxBackOff = value;
  }
  public resetMaxBackOff() {
    this._maxBackOff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBackOffInput() {
    return this._maxBackOff;
  }

  // max_record_size_kb - computed: true, optional: true, required: false
  private _maxRecordSizeKb?: number; 
  public get maxRecordSizeKb() {
    return this.getNumberAttribute('max_record_size_kb');
  }
  public set maxRecordSizeKb(value: number) {
    this._maxRecordSizeKb = value;
  }
  public resetMaxRecordSizeKb() {
    this._maxRecordSizeKb = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxRecordSizeKbInput() {
    return this._maxRecordSizeKb;
  }

  // max_retries - computed: true, optional: true, required: false
  private _maxRetries?: number; 
  public get maxRetries() {
    return this.getNumberAttribute('max_retries');
  }
  public set maxRetries(value: number) {
    this._maxRetries = value;
  }
  public resetMaxRetries() {
    this._maxRetries = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxRetriesInput() {
    return this._maxRetries;
  }

  // on_backpressure - computed: true, optional: true, required: false
  private _onBackpressure?: string; 
  public get onBackpressure() {
    return this.getStringAttribute('on_backpressure');
  }
  public set onBackpressure(value: string) {
    this._onBackpressure = value;
  }
  public resetOnBackpressure() {
    this._onBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get onBackpressureInput() {
    return this._onBackpressure;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // pq_compress - computed: true, optional: true, required: false
  private _pqCompress?: string; 
  public get pqCompress() {
    return this.getStringAttribute('pq_compress');
  }
  public set pqCompress(value: string) {
    this._pqCompress = value;
  }
  public resetPqCompress() {
    this._pqCompress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqCompressInput() {
    return this._pqCompress;
  }

  // pq_controls - computed: false, optional: true, required: false
  private _pqControls = new DestinationOutputConfluentCloudPqControlsOutputReference(this, "pq_controls");
  public get pqControls() {
    return this._pqControls;
  }
  public putPqControls(value: DestinationOutputConfluentCloudPqControls) {
    this._pqControls.internalValue = value;
  }
  public resetPqControls() {
    this._pqControls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqControlsInput() {
    return this._pqControls.internalValue;
  }

  // pq_max_file_size - computed: true, optional: true, required: false
  private _pqMaxFileSize?: string; 
  public get pqMaxFileSize() {
    return this.getStringAttribute('pq_max_file_size');
  }
  public set pqMaxFileSize(value: string) {
    this._pqMaxFileSize = value;
  }
  public resetPqMaxFileSize() {
    this._pqMaxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxFileSizeInput() {
    return this._pqMaxFileSize;
  }

  // pq_max_size - computed: true, optional: true, required: false
  private _pqMaxSize?: string; 
  public get pqMaxSize() {
    return this.getStringAttribute('pq_max_size');
  }
  public set pqMaxSize(value: string) {
    this._pqMaxSize = value;
  }
  public resetPqMaxSize() {
    this._pqMaxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxSizeInput() {
    return this._pqMaxSize;
  }

  // pq_mode - computed: true, optional: true, required: false
  private _pqMode?: string; 
  public get pqMode() {
    return this.getStringAttribute('pq_mode');
  }
  public set pqMode(value: string) {
    this._pqMode = value;
  }
  public resetPqMode() {
    this._pqMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqModeInput() {
    return this._pqMode;
  }

  // pq_on_backpressure - computed: true, optional: true, required: false
  private _pqOnBackpressure?: string; 
  public get pqOnBackpressure() {
    return this.getStringAttribute('pq_on_backpressure');
  }
  public set pqOnBackpressure(value: string) {
    this._pqOnBackpressure = value;
  }
  public resetPqOnBackpressure() {
    this._pqOnBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqOnBackpressureInput() {
    return this._pqOnBackpressure;
  }

  // pq_path - computed: true, optional: true, required: false
  private _pqPath?: string; 
  public get pqPath() {
    return this.getStringAttribute('pq_path');
  }
  public set pqPath(value: string) {
    this._pqPath = value;
  }
  public resetPqPath() {
    this._pqPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqPathInput() {
    return this._pqPath;
  }

  // protobuf_library_id - computed: false, optional: true, required: false
  private _protobufLibraryId?: string; 
  public get protobufLibraryId() {
    return this.getStringAttribute('protobuf_library_id');
  }
  public set protobufLibraryId(value: string) {
    this._protobufLibraryId = value;
  }
  public resetProtobufLibraryId() {
    this._protobufLibraryId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get protobufLibraryIdInput() {
    return this._protobufLibraryId;
  }

  // reauthentication_threshold - computed: true, optional: true, required: false
  private _reauthenticationThreshold?: number; 
  public get reauthenticationThreshold() {
    return this.getNumberAttribute('reauthentication_threshold');
  }
  public set reauthenticationThreshold(value: number) {
    this._reauthenticationThreshold = value;
  }
  public resetReauthenticationThreshold() {
    this._reauthenticationThreshold = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get reauthenticationThresholdInput() {
    return this._reauthenticationThreshold;
  }

  // request_timeout - computed: true, optional: true, required: false
  private _requestTimeout?: number; 
  public get requestTimeout() {
    return this.getNumberAttribute('request_timeout');
  }
  public set requestTimeout(value: number) {
    this._requestTimeout = value;
  }
  public resetRequestTimeout() {
    this._requestTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestTimeoutInput() {
    return this._requestTimeout;
  }

  // sasl - computed: false, optional: true, required: false
  private _sasl = new DestinationOutputConfluentCloudSaslOutputReference(this, "sasl");
  public get sasl() {
    return this._sasl;
  }
  public putSasl(value: DestinationOutputConfluentCloudSasl) {
    this._sasl.internalValue = value;
  }
  public resetSasl() {
    this._sasl.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get saslInput() {
    return this._sasl.internalValue;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // system_fields - computed: true, optional: true, required: false
  private _systemFields?: string[]; 
  public get systemFields() {
    return this.getListAttribute('system_fields');
  }
  public set systemFields(value: string[]) {
    this._systemFields = value;
  }
  public resetSystemFields() {
    this._systemFields = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get systemFieldsInput() {
    return this._systemFields;
  }

  // tls - computed: false, optional: true, required: false
  private _tls = new DestinationOutputConfluentCloudTlsOutputReference(this, "tls");
  public get tls() {
    return this._tls;
  }
  public putTls(value: DestinationOutputConfluentCloudTls) {
    this._tls.internalValue = value;
  }
  public resetTls() {
    this._tls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsInput() {
    return this._tls.internalValue;
  }

  // topic - computed: false, optional: false, required: true
  private _topic?: string; 
  public get topic() {
    return this.getStringAttribute('topic');
  }
  public set topic(value: string) {
    this._topic = value;
  }
  // Temporarily expose input value. Use with caution.
  public get topicInput() {
    return this._topic;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface DestinationOutputCriblHttpExtraHttpHeaders {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#name Destination#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#value Destination#value}
  */
  readonly value: string;
}

export function destinationOutputCriblHttpExtraHttpHeadersToTerraform(struct?: DestinationOutputCriblHttpExtraHttpHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function destinationOutputCriblHttpExtraHttpHeadersToHclTerraform(struct?: DestinationOutputCriblHttpExtraHttpHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputCriblHttpExtraHttpHeadersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DestinationOutputCriblHttpExtraHttpHeaders | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputCriblHttpExtraHttpHeaders | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DestinationOutputCriblHttpExtraHttpHeadersList extends cdktf.ComplexList {
  public internalValue? : DestinationOutputCriblHttpExtraHttpHeaders[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DestinationOutputCriblHttpExtraHttpHeadersOutputReference {
    return new DestinationOutputCriblHttpExtraHttpHeadersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DestinationOutputCriblHttpPqControls {
}

export function destinationOutputCriblHttpPqControlsToTerraform(struct?: DestinationOutputCriblHttpPqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function destinationOutputCriblHttpPqControlsToHclTerraform(struct?: DestinationOutputCriblHttpPqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class DestinationOutputCriblHttpPqControlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DestinationOutputCriblHttpPqControls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputCriblHttpPqControls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface DestinationOutputCriblHttpResponseRetrySettings {
  /**
  * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc. Default: 2
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#backoff_rate Destination#backoff_rate}
  */
  readonly backoffRate?: number;
  /**
  * The HTTP response status code that will trigger retries
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#http_status Destination#http_status}
  */
  readonly httpStatus: number;
  /**
  * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes). Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#initial_backoff Destination#initial_backoff}
  */
  readonly initialBackoff?: number;
  /**
  * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds). Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#max_backoff Destination#max_backoff}
  */
  readonly maxBackoff?: number;
}

export function destinationOutputCriblHttpResponseRetrySettingsToTerraform(struct?: DestinationOutputCriblHttpResponseRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    backoff_rate: cdktf.numberToTerraform(struct!.backoffRate),
    http_status: cdktf.numberToTerraform(struct!.httpStatus),
    initial_backoff: cdktf.numberToTerraform(struct!.initialBackoff),
    max_backoff: cdktf.numberToTerraform(struct!.maxBackoff),
  }
}


export function destinationOutputCriblHttpResponseRetrySettingsToHclTerraform(struct?: DestinationOutputCriblHttpResponseRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    backoff_rate: {
      value: cdktf.numberToHclTerraform(struct!.backoffRate),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    http_status: {
      value: cdktf.numberToHclTerraform(struct!.httpStatus),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    initial_backoff: {
      value: cdktf.numberToHclTerraform(struct!.initialBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_backoff: {
      value: cdktf.numberToHclTerraform(struct!.maxBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputCriblHttpResponseRetrySettingsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DestinationOutputCriblHttpResponseRetrySettings | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._backoffRate !== undefined) {
      hasAnyValues = true;
      internalValueResult.backoffRate = this._backoffRate;
    }
    if (this._httpStatus !== undefined) {
      hasAnyValues = true;
      internalValueResult.httpStatus = this._httpStatus;
    }
    if (this._initialBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.initialBackoff = this._initialBackoff;
    }
    if (this._maxBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBackoff = this._maxBackoff;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputCriblHttpResponseRetrySettings | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._backoffRate = undefined;
      this._httpStatus = undefined;
      this._initialBackoff = undefined;
      this._maxBackoff = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._backoffRate = value.backoffRate;
      this._httpStatus = value.httpStatus;
      this._initialBackoff = value.initialBackoff;
      this._maxBackoff = value.maxBackoff;
    }
  }

  // backoff_rate - computed: true, optional: true, required: false
  private _backoffRate?: number; 
  public get backoffRate() {
    return this.getNumberAttribute('backoff_rate');
  }
  public set backoffRate(value: number) {
    this._backoffRate = value;
  }
  public resetBackoffRate() {
    this._backoffRate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get backoffRateInput() {
    return this._backoffRate;
  }

  // http_status - computed: false, optional: false, required: true
  private _httpStatus?: number; 
  public get httpStatus() {
    return this.getNumberAttribute('http_status');
  }
  public set httpStatus(value: number) {
    this._httpStatus = value;
  }
  // Temporarily expose input value. Use with caution.
  public get httpStatusInput() {
    return this._httpStatus;
  }

  // initial_backoff - computed: true, optional: true, required: false
  private _initialBackoff?: number; 
  public get initialBackoff() {
    return this.getNumberAttribute('initial_backoff');
  }
  public set initialBackoff(value: number) {
    this._initialBackoff = value;
  }
  public resetInitialBackoff() {
    this._initialBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get initialBackoffInput() {
    return this._initialBackoff;
  }

  // max_backoff - computed: true, optional: true, required: false
  private _maxBackoff?: number; 
  public get maxBackoff() {
    return this.getNumberAttribute('max_backoff');
  }
  public set maxBackoff(value: number) {
    this._maxBackoff = value;
  }
  public resetMaxBackoff() {
    this._maxBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBackoffInput() {
    return this._maxBackoff;
  }
}

export class DestinationOutputCriblHttpResponseRetrySettingsList extends cdktf.ComplexList {
  public internalValue? : DestinationOutputCriblHttpResponseRetrySettings[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DestinationOutputCriblHttpResponseRetrySettingsOutputReference {
    return new DestinationOutputCriblHttpResponseRetrySettingsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DestinationOutputCriblHttpTimeoutRetrySettings {
  /**
  * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc. Default: 2
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#backoff_rate Destination#backoff_rate}
  */
  readonly backoffRate?: number;
  /**
  * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes). Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#initial_backoff Destination#initial_backoff}
  */
  readonly initialBackoff?: number;
  /**
  * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds). Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#max_backoff Destination#max_backoff}
  */
  readonly maxBackoff?: number;
  /**
  * Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#timeout_retry Destination#timeout_retry}
  */
  readonly timeoutRetry?: boolean | cdktf.IResolvable;
}

export function destinationOutputCriblHttpTimeoutRetrySettingsToTerraform(struct?: DestinationOutputCriblHttpTimeoutRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    backoff_rate: cdktf.numberToTerraform(struct!.backoffRate),
    initial_backoff: cdktf.numberToTerraform(struct!.initialBackoff),
    max_backoff: cdktf.numberToTerraform(struct!.maxBackoff),
    timeout_retry: cdktf.booleanToTerraform(struct!.timeoutRetry),
  }
}


export function destinationOutputCriblHttpTimeoutRetrySettingsToHclTerraform(struct?: DestinationOutputCriblHttpTimeoutRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    backoff_rate: {
      value: cdktf.numberToHclTerraform(struct!.backoffRate),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    initial_backoff: {
      value: cdktf.numberToHclTerraform(struct!.initialBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_backoff: {
      value: cdktf.numberToHclTerraform(struct!.maxBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    timeout_retry: {
      value: cdktf.booleanToHclTerraform(struct!.timeoutRetry),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputCriblHttpTimeoutRetrySettingsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DestinationOutputCriblHttpTimeoutRetrySettings | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._backoffRate !== undefined) {
      hasAnyValues = true;
      internalValueResult.backoffRate = this._backoffRate;
    }
    if (this._initialBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.initialBackoff = this._initialBackoff;
    }
    if (this._maxBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBackoff = this._maxBackoff;
    }
    if (this._timeoutRetry !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutRetry = this._timeoutRetry;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputCriblHttpTimeoutRetrySettings | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._backoffRate = undefined;
      this._initialBackoff = undefined;
      this._maxBackoff = undefined;
      this._timeoutRetry = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._backoffRate = value.backoffRate;
      this._initialBackoff = value.initialBackoff;
      this._maxBackoff = value.maxBackoff;
      this._timeoutRetry = value.timeoutRetry;
    }
  }

  // backoff_rate - computed: true, optional: true, required: false
  private _backoffRate?: number; 
  public get backoffRate() {
    return this.getNumberAttribute('backoff_rate');
  }
  public set backoffRate(value: number) {
    this._backoffRate = value;
  }
  public resetBackoffRate() {
    this._backoffRate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get backoffRateInput() {
    return this._backoffRate;
  }

  // initial_backoff - computed: true, optional: true, required: false
  private _initialBackoff?: number; 
  public get initialBackoff() {
    return this.getNumberAttribute('initial_backoff');
  }
  public set initialBackoff(value: number) {
    this._initialBackoff = value;
  }
  public resetInitialBackoff() {
    this._initialBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get initialBackoffInput() {
    return this._initialBackoff;
  }

  // max_backoff - computed: true, optional: true, required: false
  private _maxBackoff?: number; 
  public get maxBackoff() {
    return this.getNumberAttribute('max_backoff');
  }
  public set maxBackoff(value: number) {
    this._maxBackoff = value;
  }
  public resetMaxBackoff() {
    this._maxBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBackoffInput() {
    return this._maxBackoff;
  }

  // timeout_retry - computed: true, optional: true, required: false
  private _timeoutRetry?: boolean | cdktf.IResolvable; 
  public get timeoutRetry() {
    return this.getBooleanAttribute('timeout_retry');
  }
  public set timeoutRetry(value: boolean | cdktf.IResolvable) {
    this._timeoutRetry = value;
  }
  public resetTimeoutRetry() {
    this._timeoutRetry = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutRetryInput() {
    return this._timeoutRetry;
  }
}
export interface DestinationOutputCriblHttpTls {
  /**
  * Path on client in which to find CA certificates to verify the server's cert. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#ca_path Destination#ca_path}
  */
  readonly caPath?: string;
  /**
  * Path on client in which to find certificates to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#cert_path Destination#cert_path}
  */
  readonly certPath?: string;
  /**
  * The name of the predefined certificate
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#certificate_name Destination#certificate_name}
  */
  readonly certificateName?: string;
  /**
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#disabled Destination#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#max_version Destination#max_version}
  */
  readonly maxVersion?: string;
  /**
  * must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#min_version Destination#min_version}
  */
  readonly minVersion?: string;
  /**
  * Passphrase to use to decrypt private key
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#passphrase Destination#passphrase}
  */
  readonly passphrase?: string;
  /**
  * Path on client in which to find the private key to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#priv_key_path Destination#priv_key_path}
  */
  readonly privKeyPath?: string;
  /**
  * Reject certificates that are not authorized by a CA in the CA certificate path, or by another 
  *                     trusted CA (such as the system's). Defaults to Enabled. Overrides the toggle from Advanced Settings, when also present.
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#reject_unauthorized Destination#reject_unauthorized}
  */
  readonly rejectUnauthorized?: boolean | cdktf.IResolvable;
  /**
  * Server name for the SNI (Server Name Indication) TLS extension. It must be a host name, and not an IP address.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#servername Destination#servername}
  */
  readonly servername?: string;
}

export function destinationOutputCriblHttpTlsToTerraform(struct?: DestinationOutputCriblHttpTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ca_path: cdktf.stringToTerraform(struct!.caPath),
    cert_path: cdktf.stringToTerraform(struct!.certPath),
    certificate_name: cdktf.stringToTerraform(struct!.certificateName),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    max_version: cdktf.stringToTerraform(struct!.maxVersion),
    min_version: cdktf.stringToTerraform(struct!.minVersion),
    passphrase: cdktf.stringToTerraform(struct!.passphrase),
    priv_key_path: cdktf.stringToTerraform(struct!.privKeyPath),
    reject_unauthorized: cdktf.booleanToTerraform(struct!.rejectUnauthorized),
    servername: cdktf.stringToTerraform(struct!.servername),
  }
}


export function destinationOutputCriblHttpTlsToHclTerraform(struct?: DestinationOutputCriblHttpTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ca_path: {
      value: cdktf.stringToHclTerraform(struct!.caPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    cert_path: {
      value: cdktf.stringToHclTerraform(struct!.certPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    certificate_name: {
      value: cdktf.stringToHclTerraform(struct!.certificateName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    max_version: {
      value: cdktf.stringToHclTerraform(struct!.maxVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    min_version: {
      value: cdktf.stringToHclTerraform(struct!.minVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    passphrase: {
      value: cdktf.stringToHclTerraform(struct!.passphrase),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    priv_key_path: {
      value: cdktf.stringToHclTerraform(struct!.privKeyPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reject_unauthorized: {
      value: cdktf.booleanToHclTerraform(struct!.rejectUnauthorized),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    servername: {
      value: cdktf.stringToHclTerraform(struct!.servername),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputCriblHttpTlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DestinationOutputCriblHttpTls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._caPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.caPath = this._caPath;
    }
    if (this._certPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.certPath = this._certPath;
    }
    if (this._certificateName !== undefined) {
      hasAnyValues = true;
      internalValueResult.certificateName = this._certificateName;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._maxVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxVersion = this._maxVersion;
    }
    if (this._minVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.minVersion = this._minVersion;
    }
    if (this._passphrase !== undefined) {
      hasAnyValues = true;
      internalValueResult.passphrase = this._passphrase;
    }
    if (this._privKeyPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.privKeyPath = this._privKeyPath;
    }
    if (this._rejectUnauthorized !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectUnauthorized = this._rejectUnauthorized;
    }
    if (this._servername !== undefined) {
      hasAnyValues = true;
      internalValueResult.servername = this._servername;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputCriblHttpTls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._caPath = undefined;
      this._certPath = undefined;
      this._certificateName = undefined;
      this._disabled = undefined;
      this._maxVersion = undefined;
      this._minVersion = undefined;
      this._passphrase = undefined;
      this._privKeyPath = undefined;
      this._rejectUnauthorized = undefined;
      this._servername = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._caPath = value.caPath;
      this._certPath = value.certPath;
      this._certificateName = value.certificateName;
      this._disabled = value.disabled;
      this._maxVersion = value.maxVersion;
      this._minVersion = value.minVersion;
      this._passphrase = value.passphrase;
      this._privKeyPath = value.privKeyPath;
      this._rejectUnauthorized = value.rejectUnauthorized;
      this._servername = value.servername;
    }
  }

  // ca_path - computed: false, optional: true, required: false
  private _caPath?: string; 
  public get caPath() {
    return this.getStringAttribute('ca_path');
  }
  public set caPath(value: string) {
    this._caPath = value;
  }
  public resetCaPath() {
    this._caPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get caPathInput() {
    return this._caPath;
  }

  // cert_path - computed: false, optional: true, required: false
  private _certPath?: string; 
  public get certPath() {
    return this.getStringAttribute('cert_path');
  }
  public set certPath(value: string) {
    this._certPath = value;
  }
  public resetCertPath() {
    this._certPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certPathInput() {
    return this._certPath;
  }

  // certificate_name - computed: false, optional: true, required: false
  private _certificateName?: string; 
  public get certificateName() {
    return this.getStringAttribute('certificate_name');
  }
  public set certificateName(value: string) {
    this._certificateName = value;
  }
  public resetCertificateName() {
    this._certificateName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certificateNameInput() {
    return this._certificateName;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // max_version - computed: false, optional: true, required: false
  private _maxVersion?: string; 
  public get maxVersion() {
    return this.getStringAttribute('max_version');
  }
  public set maxVersion(value: string) {
    this._maxVersion = value;
  }
  public resetMaxVersion() {
    this._maxVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxVersionInput() {
    return this._maxVersion;
  }

  // min_version - computed: false, optional: true, required: false
  private _minVersion?: string; 
  public get minVersion() {
    return this.getStringAttribute('min_version');
  }
  public set minVersion(value: string) {
    this._minVersion = value;
  }
  public resetMinVersion() {
    this._minVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get minVersionInput() {
    return this._minVersion;
  }

  // passphrase - computed: false, optional: true, required: false
  private _passphrase?: string; 
  public get passphrase() {
    return this.getStringAttribute('passphrase');
  }
  public set passphrase(value: string) {
    this._passphrase = value;
  }
  public resetPassphrase() {
    this._passphrase = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passphraseInput() {
    return this._passphrase;
  }

  // priv_key_path - computed: false, optional: true, required: false
  private _privKeyPath?: string; 
  public get privKeyPath() {
    return this.getStringAttribute('priv_key_path');
  }
  public set privKeyPath(value: string) {
    this._privKeyPath = value;
  }
  public resetPrivKeyPath() {
    this._privKeyPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get privKeyPathInput() {
    return this._privKeyPath;
  }

  // reject_unauthorized - computed: true, optional: true, required: false
  private _rejectUnauthorized?: boolean | cdktf.IResolvable; 
  public get rejectUnauthorized() {
    return this.getBooleanAttribute('reject_unauthorized');
  }
  public set rejectUnauthorized(value: boolean | cdktf.IResolvable) {
    this._rejectUnauthorized = value;
  }
  public resetRejectUnauthorized() {
    this._rejectUnauthorized = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectUnauthorizedInput() {
    return this._rejectUnauthorized;
  }

  // servername - computed: false, optional: true, required: false
  private _servername?: string; 
  public get servername() {
    return this.getStringAttribute('servername');
  }
  public set servername(value: string) {
    this._servername = value;
  }
  public resetServername() {
    this._servername = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get servernameInput() {
    return this._servername;
  }
}
export interface DestinationOutputCriblHttpUrls {
  /**
  * URL of a Cribl Worker to send events to, such as http://localhost:10200
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#url Destination#url}
  */
  readonly url: string;
  /**
  * Assign a weight (>0) to each endpoint to indicate its traffic-handling capability. Default: 1
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#weight Destination#weight}
  */
  readonly weight?: number;
}

export function destinationOutputCriblHttpUrlsToTerraform(struct?: DestinationOutputCriblHttpUrls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    url: cdktf.stringToTerraform(struct!.url),
    weight: cdktf.numberToTerraform(struct!.weight),
  }
}


export function destinationOutputCriblHttpUrlsToHclTerraform(struct?: DestinationOutputCriblHttpUrls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    url: {
      value: cdktf.stringToHclTerraform(struct!.url),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    weight: {
      value: cdktf.numberToHclTerraform(struct!.weight),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputCriblHttpUrlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DestinationOutputCriblHttpUrls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._url !== undefined) {
      hasAnyValues = true;
      internalValueResult.url = this._url;
    }
    if (this._weight !== undefined) {
      hasAnyValues = true;
      internalValueResult.weight = this._weight;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputCriblHttpUrls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._url = undefined;
      this._weight = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._url = value.url;
      this._weight = value.weight;
    }
  }

  // url - computed: false, optional: false, required: true
  private _url?: string; 
  public get url() {
    return this.getStringAttribute('url');
  }
  public set url(value: string) {
    this._url = value;
  }
  // Temporarily expose input value. Use with caution.
  public get urlInput() {
    return this._url;
  }

  // weight - computed: true, optional: true, required: false
  private _weight?: number; 
  public get weight() {
    return this.getNumberAttribute('weight');
  }
  public set weight(value: number) {
    this._weight = value;
  }
  public resetWeight() {
    this._weight = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get weightInput() {
    return this._weight;
  }
}

export class DestinationOutputCriblHttpUrlsList extends cdktf.ComplexList {
  public internalValue? : DestinationOutputCriblHttpUrls[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DestinationOutputCriblHttpUrlsOutputReference {
    return new DestinationOutputCriblHttpUrlsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DestinationOutputCriblHttp {
  /**
  * Codec to use to compress the data before sending. Default: "gzip"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#compression Destination#compression}
  */
  readonly compression?: string;
  /**
  * Maximum number of ongoing requests before blocking. Default: 5
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#concurrency Destination#concurrency}
  */
  readonly concurrency?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#description Destination#description}
  */
  readonly description?: string;
  /**
  * The interval in which to re-resolve any hostnames and pick up destinations from A records. Default: 600
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#dns_resolve_period_sec Destination#dns_resolve_period_sec}
  */
  readonly dnsResolvePeriodSec?: number;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#environment Destination#environment}
  */
  readonly environment?: string;
  /**
  * Fields to exclude from the event. By default, all internal fields except `__output` are sent. Example: `cribl_pipe`, `c*`. Wildcards supported. Default: ["__kube_*","__metadata","__winEvent"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#exclude_fields Destination#exclude_fields}
  */
  readonly excludeFields?: string[];
  /**
  * Exclude all IPs of the current host from the list of any resolved hostnames. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#exclude_self Destination#exclude_self}
  */
  readonly excludeSelf?: boolean | cdktf.IResolvable;
  /**
  * Headers to add to all events
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#extra_http_headers Destination#extra_http_headers}
  */
  readonly extraHttpHeaders?: DestinationOutputCriblHttpExtraHttpHeaders[] | cdktf.IResolvable;
  /**
  * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below. Default: "none"; must be one of ["payload", "payloadAndHeaders", "none"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#failed_request_logging_mode Destination#failed_request_logging_mode}
  */
  readonly failedRequestLoggingMode?: string;
  /**
  * Maximum time between requests. Small values could cause the payload size to be smaller than the configured Body size limit. Default: 1
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#flush_period_sec Destination#flush_period_sec}
  */
  readonly flushPeriodSec?: number;
  /**
  * Unique ID for this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#id Destination#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id: string;
  /**
  * How far back in time to keep traffic stats for load balancing purposes. Default: 300
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#load_balance_stats_period_sec Destination#load_balance_stats_period_sec}
  */
  readonly loadBalanceStatsPeriodSec?: number;
  /**
  * For optimal performance, enable load balancing even if you have one hostname, as it can expand to multiple IPs. If this setting is disabled, consider enabling round-robin DNS. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#load_balanced Destination#load_balanced}
  */
  readonly loadBalanced?: boolean | cdktf.IResolvable;
  /**
  * Maximum number of events to include in the request body. Default is 0 (unlimited). Default: 0
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#max_payload_events Destination#max_payload_events}
  */
  readonly maxPayloadEvents?: number;
  /**
  * Maximum size, in KB, of the request body. Default: 4096
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#max_payload_size_kb Destination#max_payload_size_kb}
  */
  readonly maxPayloadSizeKb?: number;
  /**
  * How to handle events when all receivers are exerting backpressure. Default: "block"; must be one of ["block", "drop", "queue"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#on_backpressure Destination#on_backpressure}
  */
  readonly onBackpressure?: string;
  /**
  * Pipeline to process data before sending out to this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pipeline Destination#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pq_compress Destination#pq_compress}
  */
  readonly pqCompress?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pq_controls Destination#pq_controls}
  */
  readonly pqControls?: DestinationOutputCriblHttpPqControls;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.). Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pq_max_file_size Destination#pq_max_file_size}
  */
  readonly pqMaxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pq_max_size Destination#pq_max_size}
  */
  readonly pqMaxSize?: string;
  /**
  * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem. Default: "error"; must be one of ["error", "backpressure", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pq_mode Destination#pq_mode}
  */
  readonly pqMode?: string;
  /**
  * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged. Default: "block"; must be one of ["block", "drop"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pq_on_backpressure Destination#pq_on_backpressure}
  */
  readonly pqOnBackpressure?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pq_path Destination#pq_path}
  */
  readonly pqPath?: string;
  /**
  * Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's). 
  *         Enabled by default. When this setting is also present in TLS Settings (Client Side), 
  *         that value will take precedence.
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#reject_unauthorized Destination#reject_unauthorized}
  */
  readonly rejectUnauthorized?: boolean | cdktf.IResolvable;
  /**
  * Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#response_honor_retry_after_header Destination#response_honor_retry_after_header}
  */
  readonly responseHonorRetryAfterHeader?: boolean | cdktf.IResolvable;
  /**
  * Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#response_retry_settings Destination#response_retry_settings}
  */
  readonly responseRetrySettings?: DestinationOutputCriblHttpResponseRetrySettings[] | cdktf.IResolvable;
  /**
  * List of headers that are safe to log in plain text. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#safe_headers Destination#safe_headers}
  */
  readonly safeHeaders?: string[];
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#streamtags Destination#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Fields to automatically add to events, such as cribl_pipe. Supports wildcards. Default: ["cribl_pipe"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#system_fields Destination#system_fields}
  */
  readonly systemFields?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#timeout_retry_settings Destination#timeout_retry_settings}
  */
  readonly timeoutRetrySettings?: DestinationOutputCriblHttpTimeoutRetrySettings;
  /**
  * Amount of time, in seconds, to wait for a request to complete before canceling it. Default: 30
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#timeout_sec Destination#timeout_sec}
  */
  readonly timeoutSec?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#tls Destination#tls}
  */
  readonly tls?: DestinationOutputCriblHttpTls;
  /**
  * The number of minutes before the internally generated authentication token expires. Valid values are between 1 and 60. Default: 60
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#token_ttl_minutes Destination#token_ttl_minutes}
  */
  readonly tokenTtlMinutes?: number;
  /**
  * must be "cribl_http"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#type Destination#type}
  */
  readonly type: string;
  /**
  * URL of a Cribl Worker to send events to, such as http://localhost:10200
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#url Destination#url}
  */
  readonly url?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#urls Destination#urls}
  */
  readonly urls?: DestinationOutputCriblHttpUrls[] | cdktf.IResolvable;
  /**
  * Enable round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. For optimal performance, consider enabling this setting for non-load balanced destinations. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#use_round_robin_dns Destination#use_round_robin_dns}
  */
  readonly useRoundRobinDns?: boolean | cdktf.IResolvable;
}

export function destinationOutputCriblHttpToTerraform(struct?: DestinationOutputCriblHttp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    compression: cdktf.stringToTerraform(struct!.compression),
    concurrency: cdktf.numberToTerraform(struct!.concurrency),
    description: cdktf.stringToTerraform(struct!.description),
    dns_resolve_period_sec: cdktf.numberToTerraform(struct!.dnsResolvePeriodSec),
    environment: cdktf.stringToTerraform(struct!.environment),
    exclude_fields: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.excludeFields),
    exclude_self: cdktf.booleanToTerraform(struct!.excludeSelf),
    extra_http_headers: cdktf.listMapper(destinationOutputCriblHttpExtraHttpHeadersToTerraform, false)(struct!.extraHttpHeaders),
    failed_request_logging_mode: cdktf.stringToTerraform(struct!.failedRequestLoggingMode),
    flush_period_sec: cdktf.numberToTerraform(struct!.flushPeriodSec),
    id: cdktf.stringToTerraform(struct!.id),
    load_balance_stats_period_sec: cdktf.numberToTerraform(struct!.loadBalanceStatsPeriodSec),
    load_balanced: cdktf.booleanToTerraform(struct!.loadBalanced),
    max_payload_events: cdktf.numberToTerraform(struct!.maxPayloadEvents),
    max_payload_size_kb: cdktf.numberToTerraform(struct!.maxPayloadSizeKb),
    on_backpressure: cdktf.stringToTerraform(struct!.onBackpressure),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    pq_compress: cdktf.stringToTerraform(struct!.pqCompress),
    pq_controls: destinationOutputCriblHttpPqControlsToTerraform(struct!.pqControls),
    pq_max_file_size: cdktf.stringToTerraform(struct!.pqMaxFileSize),
    pq_max_size: cdktf.stringToTerraform(struct!.pqMaxSize),
    pq_mode: cdktf.stringToTerraform(struct!.pqMode),
    pq_on_backpressure: cdktf.stringToTerraform(struct!.pqOnBackpressure),
    pq_path: cdktf.stringToTerraform(struct!.pqPath),
    reject_unauthorized: cdktf.booleanToTerraform(struct!.rejectUnauthorized),
    response_honor_retry_after_header: cdktf.booleanToTerraform(struct!.responseHonorRetryAfterHeader),
    response_retry_settings: cdktf.listMapper(destinationOutputCriblHttpResponseRetrySettingsToTerraform, false)(struct!.responseRetrySettings),
    safe_headers: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.safeHeaders),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    system_fields: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.systemFields),
    timeout_retry_settings: destinationOutputCriblHttpTimeoutRetrySettingsToTerraform(struct!.timeoutRetrySettings),
    timeout_sec: cdktf.numberToTerraform(struct!.timeoutSec),
    tls: destinationOutputCriblHttpTlsToTerraform(struct!.tls),
    token_ttl_minutes: cdktf.numberToTerraform(struct!.tokenTtlMinutes),
    type: cdktf.stringToTerraform(struct!.type),
    url: cdktf.stringToTerraform(struct!.url),
    urls: cdktf.listMapper(destinationOutputCriblHttpUrlsToTerraform, false)(struct!.urls),
    use_round_robin_dns: cdktf.booleanToTerraform(struct!.useRoundRobinDns),
  }
}


export function destinationOutputCriblHttpToHclTerraform(struct?: DestinationOutputCriblHttp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    compression: {
      value: cdktf.stringToHclTerraform(struct!.compression),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    concurrency: {
      value: cdktf.numberToHclTerraform(struct!.concurrency),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    dns_resolve_period_sec: {
      value: cdktf.numberToHclTerraform(struct!.dnsResolvePeriodSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    exclude_fields: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.excludeFields),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    exclude_self: {
      value: cdktf.booleanToHclTerraform(struct!.excludeSelf),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    extra_http_headers: {
      value: cdktf.listMapperHcl(destinationOutputCriblHttpExtraHttpHeadersToHclTerraform, false)(struct!.extraHttpHeaders),
      isBlock: true,
      type: "list",
      storageClassType: "DestinationOutputCriblHttpExtraHttpHeadersList",
    },
    failed_request_logging_mode: {
      value: cdktf.stringToHclTerraform(struct!.failedRequestLoggingMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    flush_period_sec: {
      value: cdktf.numberToHclTerraform(struct!.flushPeriodSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    load_balance_stats_period_sec: {
      value: cdktf.numberToHclTerraform(struct!.loadBalanceStatsPeriodSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    load_balanced: {
      value: cdktf.booleanToHclTerraform(struct!.loadBalanced),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    max_payload_events: {
      value: cdktf.numberToHclTerraform(struct!.maxPayloadEvents),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_payload_size_kb: {
      value: cdktf.numberToHclTerraform(struct!.maxPayloadSizeKb),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.onBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_compress: {
      value: cdktf.stringToHclTerraform(struct!.pqCompress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_controls: {
      value: destinationOutputCriblHttpPqControlsToHclTerraform(struct!.pqControls),
      isBlock: true,
      type: "struct",
      storageClassType: "DestinationOutputCriblHttpPqControls",
    },
    pq_max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_max_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_mode: {
      value: cdktf.stringToHclTerraform(struct!.pqMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.pqOnBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_path: {
      value: cdktf.stringToHclTerraform(struct!.pqPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reject_unauthorized: {
      value: cdktf.booleanToHclTerraform(struct!.rejectUnauthorized),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    response_honor_retry_after_header: {
      value: cdktf.booleanToHclTerraform(struct!.responseHonorRetryAfterHeader),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    response_retry_settings: {
      value: cdktf.listMapperHcl(destinationOutputCriblHttpResponseRetrySettingsToHclTerraform, false)(struct!.responseRetrySettings),
      isBlock: true,
      type: "list",
      storageClassType: "DestinationOutputCriblHttpResponseRetrySettingsList",
    },
    safe_headers: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.safeHeaders),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    system_fields: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.systemFields),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    timeout_retry_settings: {
      value: destinationOutputCriblHttpTimeoutRetrySettingsToHclTerraform(struct!.timeoutRetrySettings),
      isBlock: true,
      type: "struct",
      storageClassType: "DestinationOutputCriblHttpTimeoutRetrySettings",
    },
    timeout_sec: {
      value: cdktf.numberToHclTerraform(struct!.timeoutSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    tls: {
      value: destinationOutputCriblHttpTlsToHclTerraform(struct!.tls),
      isBlock: true,
      type: "struct",
      storageClassType: "DestinationOutputCriblHttpTls",
    },
    token_ttl_minutes: {
      value: cdktf.numberToHclTerraform(struct!.tokenTtlMinutes),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    url: {
      value: cdktf.stringToHclTerraform(struct!.url),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    urls: {
      value: cdktf.listMapperHcl(destinationOutputCriblHttpUrlsToHclTerraform, false)(struct!.urls),
      isBlock: true,
      type: "list",
      storageClassType: "DestinationOutputCriblHttpUrlsList",
    },
    use_round_robin_dns: {
      value: cdktf.booleanToHclTerraform(struct!.useRoundRobinDns),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputCriblHttpOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DestinationOutputCriblHttp | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._compression !== undefined) {
      hasAnyValues = true;
      internalValueResult.compression = this._compression;
    }
    if (this._concurrency !== undefined) {
      hasAnyValues = true;
      internalValueResult.concurrency = this._concurrency;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._dnsResolvePeriodSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.dnsResolvePeriodSec = this._dnsResolvePeriodSec;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._excludeFields !== undefined) {
      hasAnyValues = true;
      internalValueResult.excludeFields = this._excludeFields;
    }
    if (this._excludeSelf !== undefined) {
      hasAnyValues = true;
      internalValueResult.excludeSelf = this._excludeSelf;
    }
    if (this._extraHttpHeaders?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.extraHttpHeaders = this._extraHttpHeaders?.internalValue;
    }
    if (this._failedRequestLoggingMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.failedRequestLoggingMode = this._failedRequestLoggingMode;
    }
    if (this._flushPeriodSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.flushPeriodSec = this._flushPeriodSec;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._loadBalanceStatsPeriodSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.loadBalanceStatsPeriodSec = this._loadBalanceStatsPeriodSec;
    }
    if (this._loadBalanced !== undefined) {
      hasAnyValues = true;
      internalValueResult.loadBalanced = this._loadBalanced;
    }
    if (this._maxPayloadEvents !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxPayloadEvents = this._maxPayloadEvents;
    }
    if (this._maxPayloadSizeKb !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxPayloadSizeKb = this._maxPayloadSizeKb;
    }
    if (this._onBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.onBackpressure = this._onBackpressure;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._pqCompress !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqCompress = this._pqCompress;
    }
    if (this._pqControls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqControls = this._pqControls?.internalValue;
    }
    if (this._pqMaxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxFileSize = this._pqMaxFileSize;
    }
    if (this._pqMaxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxSize = this._pqMaxSize;
    }
    if (this._pqMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMode = this._pqMode;
    }
    if (this._pqOnBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqOnBackpressure = this._pqOnBackpressure;
    }
    if (this._pqPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqPath = this._pqPath;
    }
    if (this._rejectUnauthorized !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectUnauthorized = this._rejectUnauthorized;
    }
    if (this._responseHonorRetryAfterHeader !== undefined) {
      hasAnyValues = true;
      internalValueResult.responseHonorRetryAfterHeader = this._responseHonorRetryAfterHeader;
    }
    if (this._responseRetrySettings?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.responseRetrySettings = this._responseRetrySettings?.internalValue;
    }
    if (this._safeHeaders !== undefined) {
      hasAnyValues = true;
      internalValueResult.safeHeaders = this._safeHeaders;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._systemFields !== undefined) {
      hasAnyValues = true;
      internalValueResult.systemFields = this._systemFields;
    }
    if (this._timeoutRetrySettings?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutRetrySettings = this._timeoutRetrySettings?.internalValue;
    }
    if (this._timeoutSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutSec = this._timeoutSec;
    }
    if (this._tls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tls = this._tls?.internalValue;
    }
    if (this._tokenTtlMinutes !== undefined) {
      hasAnyValues = true;
      internalValueResult.tokenTtlMinutes = this._tokenTtlMinutes;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._url !== undefined) {
      hasAnyValues = true;
      internalValueResult.url = this._url;
    }
    if (this._urls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.urls = this._urls?.internalValue;
    }
    if (this._useRoundRobinDns !== undefined) {
      hasAnyValues = true;
      internalValueResult.useRoundRobinDns = this._useRoundRobinDns;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputCriblHttp | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._compression = undefined;
      this._concurrency = undefined;
      this._description = undefined;
      this._dnsResolvePeriodSec = undefined;
      this._environment = undefined;
      this._excludeFields = undefined;
      this._excludeSelf = undefined;
      this._extraHttpHeaders.internalValue = undefined;
      this._failedRequestLoggingMode = undefined;
      this._flushPeriodSec = undefined;
      this._id = undefined;
      this._loadBalanceStatsPeriodSec = undefined;
      this._loadBalanced = undefined;
      this._maxPayloadEvents = undefined;
      this._maxPayloadSizeKb = undefined;
      this._onBackpressure = undefined;
      this._pipeline = undefined;
      this._pqCompress = undefined;
      this._pqControls.internalValue = undefined;
      this._pqMaxFileSize = undefined;
      this._pqMaxSize = undefined;
      this._pqMode = undefined;
      this._pqOnBackpressure = undefined;
      this._pqPath = undefined;
      this._rejectUnauthorized = undefined;
      this._responseHonorRetryAfterHeader = undefined;
      this._responseRetrySettings.internalValue = undefined;
      this._safeHeaders = undefined;
      this._streamtags = undefined;
      this._systemFields = undefined;
      this._timeoutRetrySettings.internalValue = undefined;
      this._timeoutSec = undefined;
      this._tls.internalValue = undefined;
      this._tokenTtlMinutes = undefined;
      this._type = undefined;
      this._url = undefined;
      this._urls.internalValue = undefined;
      this._useRoundRobinDns = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._compression = value.compression;
      this._concurrency = value.concurrency;
      this._description = value.description;
      this._dnsResolvePeriodSec = value.dnsResolvePeriodSec;
      this._environment = value.environment;
      this._excludeFields = value.excludeFields;
      this._excludeSelf = value.excludeSelf;
      this._extraHttpHeaders.internalValue = value.extraHttpHeaders;
      this._failedRequestLoggingMode = value.failedRequestLoggingMode;
      this._flushPeriodSec = value.flushPeriodSec;
      this._id = value.id;
      this._loadBalanceStatsPeriodSec = value.loadBalanceStatsPeriodSec;
      this._loadBalanced = value.loadBalanced;
      this._maxPayloadEvents = value.maxPayloadEvents;
      this._maxPayloadSizeKb = value.maxPayloadSizeKb;
      this._onBackpressure = value.onBackpressure;
      this._pipeline = value.pipeline;
      this._pqCompress = value.pqCompress;
      this._pqControls.internalValue = value.pqControls;
      this._pqMaxFileSize = value.pqMaxFileSize;
      this._pqMaxSize = value.pqMaxSize;
      this._pqMode = value.pqMode;
      this._pqOnBackpressure = value.pqOnBackpressure;
      this._pqPath = value.pqPath;
      this._rejectUnauthorized = value.rejectUnauthorized;
      this._responseHonorRetryAfterHeader = value.responseHonorRetryAfterHeader;
      this._responseRetrySettings.internalValue = value.responseRetrySettings;
      this._safeHeaders = value.safeHeaders;
      this._streamtags = value.streamtags;
      this._systemFields = value.systemFields;
      this._timeoutRetrySettings.internalValue = value.timeoutRetrySettings;
      this._timeoutSec = value.timeoutSec;
      this._tls.internalValue = value.tls;
      this._tokenTtlMinutes = value.tokenTtlMinutes;
      this._type = value.type;
      this._url = value.url;
      this._urls.internalValue = value.urls;
      this._useRoundRobinDns = value.useRoundRobinDns;
    }
  }

  // compression - computed: true, optional: true, required: false
  private _compression?: string; 
  public get compression() {
    return this.getStringAttribute('compression');
  }
  public set compression(value: string) {
    this._compression = value;
  }
  public resetCompression() {
    this._compression = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressionInput() {
    return this._compression;
  }

  // concurrency - computed: true, optional: true, required: false
  private _concurrency?: number; 
  public get concurrency() {
    return this.getNumberAttribute('concurrency');
  }
  public set concurrency(value: number) {
    this._concurrency = value;
  }
  public resetConcurrency() {
    this._concurrency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get concurrencyInput() {
    return this._concurrency;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // dns_resolve_period_sec - computed: true, optional: true, required: false
  private _dnsResolvePeriodSec?: number; 
  public get dnsResolvePeriodSec() {
    return this.getNumberAttribute('dns_resolve_period_sec');
  }
  public set dnsResolvePeriodSec(value: number) {
    this._dnsResolvePeriodSec = value;
  }
  public resetDnsResolvePeriodSec() {
    this._dnsResolvePeriodSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dnsResolvePeriodSecInput() {
    return this._dnsResolvePeriodSec;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // exclude_fields - computed: true, optional: true, required: false
  private _excludeFields?: string[]; 
  public get excludeFields() {
    return this.getListAttribute('exclude_fields');
  }
  public set excludeFields(value: string[]) {
    this._excludeFields = value;
  }
  public resetExcludeFields() {
    this._excludeFields = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get excludeFieldsInput() {
    return this._excludeFields;
  }

  // exclude_self - computed: true, optional: true, required: false
  private _excludeSelf?: boolean | cdktf.IResolvable; 
  public get excludeSelf() {
    return this.getBooleanAttribute('exclude_self');
  }
  public set excludeSelf(value: boolean | cdktf.IResolvable) {
    this._excludeSelf = value;
  }
  public resetExcludeSelf() {
    this._excludeSelf = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get excludeSelfInput() {
    return this._excludeSelf;
  }

  // extra_http_headers - computed: false, optional: true, required: false
  private _extraHttpHeaders = new DestinationOutputCriblHttpExtraHttpHeadersList(this, "extra_http_headers", false);
  public get extraHttpHeaders() {
    return this._extraHttpHeaders;
  }
  public putExtraHttpHeaders(value: DestinationOutputCriblHttpExtraHttpHeaders[] | cdktf.IResolvable) {
    this._extraHttpHeaders.internalValue = value;
  }
  public resetExtraHttpHeaders() {
    this._extraHttpHeaders.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get extraHttpHeadersInput() {
    return this._extraHttpHeaders.internalValue;
  }

  // failed_request_logging_mode - computed: true, optional: true, required: false
  private _failedRequestLoggingMode?: string; 
  public get failedRequestLoggingMode() {
    return this.getStringAttribute('failed_request_logging_mode');
  }
  public set failedRequestLoggingMode(value: string) {
    this._failedRequestLoggingMode = value;
  }
  public resetFailedRequestLoggingMode() {
    this._failedRequestLoggingMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get failedRequestLoggingModeInput() {
    return this._failedRequestLoggingMode;
  }

  // flush_period_sec - computed: true, optional: true, required: false
  private _flushPeriodSec?: number; 
  public get flushPeriodSec() {
    return this.getNumberAttribute('flush_period_sec');
  }
  public set flushPeriodSec(value: number) {
    this._flushPeriodSec = value;
  }
  public resetFlushPeriodSec() {
    this._flushPeriodSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get flushPeriodSecInput() {
    return this._flushPeriodSec;
  }

  // id - computed: false, optional: false, required: true
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // load_balance_stats_period_sec - computed: true, optional: true, required: false
  private _loadBalanceStatsPeriodSec?: number; 
  public get loadBalanceStatsPeriodSec() {
    return this.getNumberAttribute('load_balance_stats_period_sec');
  }
  public set loadBalanceStatsPeriodSec(value: number) {
    this._loadBalanceStatsPeriodSec = value;
  }
  public resetLoadBalanceStatsPeriodSec() {
    this._loadBalanceStatsPeriodSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get loadBalanceStatsPeriodSecInput() {
    return this._loadBalanceStatsPeriodSec;
  }

  // load_balanced - computed: true, optional: true, required: false
  private _loadBalanced?: boolean | cdktf.IResolvable; 
  public get loadBalanced() {
    return this.getBooleanAttribute('load_balanced');
  }
  public set loadBalanced(value: boolean | cdktf.IResolvable) {
    this._loadBalanced = value;
  }
  public resetLoadBalanced() {
    this._loadBalanced = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get loadBalancedInput() {
    return this._loadBalanced;
  }

  // max_payload_events - computed: true, optional: true, required: false
  private _maxPayloadEvents?: number; 
  public get maxPayloadEvents() {
    return this.getNumberAttribute('max_payload_events');
  }
  public set maxPayloadEvents(value: number) {
    this._maxPayloadEvents = value;
  }
  public resetMaxPayloadEvents() {
    this._maxPayloadEvents = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxPayloadEventsInput() {
    return this._maxPayloadEvents;
  }

  // max_payload_size_kb - computed: true, optional: true, required: false
  private _maxPayloadSizeKb?: number; 
  public get maxPayloadSizeKb() {
    return this.getNumberAttribute('max_payload_size_kb');
  }
  public set maxPayloadSizeKb(value: number) {
    this._maxPayloadSizeKb = value;
  }
  public resetMaxPayloadSizeKb() {
    this._maxPayloadSizeKb = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxPayloadSizeKbInput() {
    return this._maxPayloadSizeKb;
  }

  // on_backpressure - computed: true, optional: true, required: false
  private _onBackpressure?: string; 
  public get onBackpressure() {
    return this.getStringAttribute('on_backpressure');
  }
  public set onBackpressure(value: string) {
    this._onBackpressure = value;
  }
  public resetOnBackpressure() {
    this._onBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get onBackpressureInput() {
    return this._onBackpressure;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // pq_compress - computed: true, optional: true, required: false
  private _pqCompress?: string; 
  public get pqCompress() {
    return this.getStringAttribute('pq_compress');
  }
  public set pqCompress(value: string) {
    this._pqCompress = value;
  }
  public resetPqCompress() {
    this._pqCompress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqCompressInput() {
    return this._pqCompress;
  }

  // pq_controls - computed: false, optional: true, required: false
  private _pqControls = new DestinationOutputCriblHttpPqControlsOutputReference(this, "pq_controls");
  public get pqControls() {
    return this._pqControls;
  }
  public putPqControls(value: DestinationOutputCriblHttpPqControls) {
    this._pqControls.internalValue = value;
  }
  public resetPqControls() {
    this._pqControls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqControlsInput() {
    return this._pqControls.internalValue;
  }

  // pq_max_file_size - computed: true, optional: true, required: false
  private _pqMaxFileSize?: string; 
  public get pqMaxFileSize() {
    return this.getStringAttribute('pq_max_file_size');
  }
  public set pqMaxFileSize(value: string) {
    this._pqMaxFileSize = value;
  }
  public resetPqMaxFileSize() {
    this._pqMaxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxFileSizeInput() {
    return this._pqMaxFileSize;
  }

  // pq_max_size - computed: true, optional: true, required: false
  private _pqMaxSize?: string; 
  public get pqMaxSize() {
    return this.getStringAttribute('pq_max_size');
  }
  public set pqMaxSize(value: string) {
    this._pqMaxSize = value;
  }
  public resetPqMaxSize() {
    this._pqMaxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxSizeInput() {
    return this._pqMaxSize;
  }

  // pq_mode - computed: true, optional: true, required: false
  private _pqMode?: string; 
  public get pqMode() {
    return this.getStringAttribute('pq_mode');
  }
  public set pqMode(value: string) {
    this._pqMode = value;
  }
  public resetPqMode() {
    this._pqMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqModeInput() {
    return this._pqMode;
  }

  // pq_on_backpressure - computed: true, optional: true, required: false
  private _pqOnBackpressure?: string; 
  public get pqOnBackpressure() {
    return this.getStringAttribute('pq_on_backpressure');
  }
  public set pqOnBackpressure(value: string) {
    this._pqOnBackpressure = value;
  }
  public resetPqOnBackpressure() {
    this._pqOnBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqOnBackpressureInput() {
    return this._pqOnBackpressure;
  }

  // pq_path - computed: true, optional: true, required: false
  private _pqPath?: string; 
  public get pqPath() {
    return this.getStringAttribute('pq_path');
  }
  public set pqPath(value: string) {
    this._pqPath = value;
  }
  public resetPqPath() {
    this._pqPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqPathInput() {
    return this._pqPath;
  }

  // reject_unauthorized - computed: true, optional: true, required: false
  private _rejectUnauthorized?: boolean | cdktf.IResolvable; 
  public get rejectUnauthorized() {
    return this.getBooleanAttribute('reject_unauthorized');
  }
  public set rejectUnauthorized(value: boolean | cdktf.IResolvable) {
    this._rejectUnauthorized = value;
  }
  public resetRejectUnauthorized() {
    this._rejectUnauthorized = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectUnauthorizedInput() {
    return this._rejectUnauthorized;
  }

  // response_honor_retry_after_header - computed: true, optional: true, required: false
  private _responseHonorRetryAfterHeader?: boolean | cdktf.IResolvable; 
  public get responseHonorRetryAfterHeader() {
    return this.getBooleanAttribute('response_honor_retry_after_header');
  }
  public set responseHonorRetryAfterHeader(value: boolean | cdktf.IResolvable) {
    this._responseHonorRetryAfterHeader = value;
  }
  public resetResponseHonorRetryAfterHeader() {
    this._responseHonorRetryAfterHeader = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get responseHonorRetryAfterHeaderInput() {
    return this._responseHonorRetryAfterHeader;
  }

  // response_retry_settings - computed: false, optional: true, required: false
  private _responseRetrySettings = new DestinationOutputCriblHttpResponseRetrySettingsList(this, "response_retry_settings", false);
  public get responseRetrySettings() {
    return this._responseRetrySettings;
  }
  public putResponseRetrySettings(value: DestinationOutputCriblHttpResponseRetrySettings[] | cdktf.IResolvable) {
    this._responseRetrySettings.internalValue = value;
  }
  public resetResponseRetrySettings() {
    this._responseRetrySettings.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get responseRetrySettingsInput() {
    return this._responseRetrySettings.internalValue;
  }

  // safe_headers - computed: true, optional: true, required: false
  private _safeHeaders?: string[]; 
  public get safeHeaders() {
    return this.getListAttribute('safe_headers');
  }
  public set safeHeaders(value: string[]) {
    this._safeHeaders = value;
  }
  public resetSafeHeaders() {
    this._safeHeaders = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get safeHeadersInput() {
    return this._safeHeaders;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // system_fields - computed: true, optional: true, required: false
  private _systemFields?: string[]; 
  public get systemFields() {
    return this.getListAttribute('system_fields');
  }
  public set systemFields(value: string[]) {
    this._systemFields = value;
  }
  public resetSystemFields() {
    this._systemFields = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get systemFieldsInput() {
    return this._systemFields;
  }

  // timeout_retry_settings - computed: false, optional: true, required: false
  private _timeoutRetrySettings = new DestinationOutputCriblHttpTimeoutRetrySettingsOutputReference(this, "timeout_retry_settings");
  public get timeoutRetrySettings() {
    return this._timeoutRetrySettings;
  }
  public putTimeoutRetrySettings(value: DestinationOutputCriblHttpTimeoutRetrySettings) {
    this._timeoutRetrySettings.internalValue = value;
  }
  public resetTimeoutRetrySettings() {
    this._timeoutRetrySettings.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutRetrySettingsInput() {
    return this._timeoutRetrySettings.internalValue;
  }

  // timeout_sec - computed: true, optional: true, required: false
  private _timeoutSec?: number; 
  public get timeoutSec() {
    return this.getNumberAttribute('timeout_sec');
  }
  public set timeoutSec(value: number) {
    this._timeoutSec = value;
  }
  public resetTimeoutSec() {
    this._timeoutSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutSecInput() {
    return this._timeoutSec;
  }

  // tls - computed: false, optional: true, required: false
  private _tls = new DestinationOutputCriblHttpTlsOutputReference(this, "tls");
  public get tls() {
    return this._tls;
  }
  public putTls(value: DestinationOutputCriblHttpTls) {
    this._tls.internalValue = value;
  }
  public resetTls() {
    this._tls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsInput() {
    return this._tls.internalValue;
  }

  // token_ttl_minutes - computed: true, optional: true, required: false
  private _tokenTtlMinutes?: number; 
  public get tokenTtlMinutes() {
    return this.getNumberAttribute('token_ttl_minutes');
  }
  public set tokenTtlMinutes(value: number) {
    this._tokenTtlMinutes = value;
  }
  public resetTokenTtlMinutes() {
    this._tokenTtlMinutes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tokenTtlMinutesInput() {
    return this._tokenTtlMinutes;
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // url - computed: false, optional: true, required: false
  private _url?: string; 
  public get url() {
    return this.getStringAttribute('url');
  }
  public set url(value: string) {
    this._url = value;
  }
  public resetUrl() {
    this._url = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get urlInput() {
    return this._url;
  }

  // urls - computed: false, optional: true, required: false
  private _urls = new DestinationOutputCriblHttpUrlsList(this, "urls", false);
  public get urls() {
    return this._urls;
  }
  public putUrls(value: DestinationOutputCriblHttpUrls[] | cdktf.IResolvable) {
    this._urls.internalValue = value;
  }
  public resetUrls() {
    this._urls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get urlsInput() {
    return this._urls.internalValue;
  }

  // use_round_robin_dns - computed: true, optional: true, required: false
  private _useRoundRobinDns?: boolean | cdktf.IResolvable; 
  public get useRoundRobinDns() {
    return this.getBooleanAttribute('use_round_robin_dns');
  }
  public set useRoundRobinDns(value: boolean | cdktf.IResolvable) {
    this._useRoundRobinDns = value;
  }
  public resetUseRoundRobinDns() {
    this._useRoundRobinDns = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get useRoundRobinDnsInput() {
    return this._useRoundRobinDns;
  }
}
export interface DestinationOutputCriblLake {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#description Destination#description}
  */
  readonly description?: string;
  /**
  * Lake dataset to send the data to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#dest_path Destination#dest_path}
  */
  readonly destPath?: string;
  /**
  * Unique ID for this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#id Destination#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id: string;
  /**
  * must be "cribl_lake"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#type Destination#type}
  */
  readonly type: string;
}

export function destinationOutputCriblLakeToTerraform(struct?: DestinationOutputCriblLake | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    description: cdktf.stringToTerraform(struct!.description),
    dest_path: cdktf.stringToTerraform(struct!.destPath),
    id: cdktf.stringToTerraform(struct!.id),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function destinationOutputCriblLakeToHclTerraform(struct?: DestinationOutputCriblLake | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    dest_path: {
      value: cdktf.stringToHclTerraform(struct!.destPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputCriblLakeOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DestinationOutputCriblLake | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._destPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.destPath = this._destPath;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputCriblLake | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._description = undefined;
      this._destPath = undefined;
      this._id = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._description = value.description;
      this._destPath = value.destPath;
      this._id = value.id;
      this._type = value.type;
    }
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // dest_path - computed: false, optional: true, required: false
  private _destPath?: string; 
  public get destPath() {
    return this.getStringAttribute('dest_path');
  }
  public set destPath(value: string) {
    this._destPath = value;
  }
  public resetDestPath() {
    this._destPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get destPathInput() {
    return this._destPath;
  }

  // id - computed: false, optional: false, required: true
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface DestinationOutputCriblTcpHosts {
  /**
  * The hostname of the receiver
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#host Destination#host}
  */
  readonly host: string;
  /**
  * The port to connect to on the provided host. Default: 10300
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#port Destination#port}
  */
  readonly port?: number;
  /**
  * Servername to use if establishing a TLS connection. If not specified, defaults to connection host (if not an IP); otherwise, uses the global TLS settings.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#servername Destination#servername}
  */
  readonly servername?: string;
  /**
  * Whether to inherit TLS configs from group setting or disable TLS. Default: "inherit"; must be one of ["inherit", "off"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#tls Destination#tls}
  */
  readonly tls?: string;
  /**
  * Assign a weight (>0) to each endpoint to indicate its traffic-handling capability. Default: 1
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#weight Destination#weight}
  */
  readonly weight?: number;
}

export function destinationOutputCriblTcpHostsToTerraform(struct?: DestinationOutputCriblTcpHosts | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    host: cdktf.stringToTerraform(struct!.host),
    port: cdktf.numberToTerraform(struct!.port),
    servername: cdktf.stringToTerraform(struct!.servername),
    tls: cdktf.stringToTerraform(struct!.tls),
    weight: cdktf.numberToTerraform(struct!.weight),
  }
}


export function destinationOutputCriblTcpHostsToHclTerraform(struct?: DestinationOutputCriblTcpHosts | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    host: {
      value: cdktf.stringToHclTerraform(struct!.host),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    servername: {
      value: cdktf.stringToHclTerraform(struct!.servername),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tls: {
      value: cdktf.stringToHclTerraform(struct!.tls),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    weight: {
      value: cdktf.numberToHclTerraform(struct!.weight),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputCriblTcpHostsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DestinationOutputCriblTcpHosts | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._host !== undefined) {
      hasAnyValues = true;
      internalValueResult.host = this._host;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._servername !== undefined) {
      hasAnyValues = true;
      internalValueResult.servername = this._servername;
    }
    if (this._tls !== undefined) {
      hasAnyValues = true;
      internalValueResult.tls = this._tls;
    }
    if (this._weight !== undefined) {
      hasAnyValues = true;
      internalValueResult.weight = this._weight;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputCriblTcpHosts | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._host = undefined;
      this._port = undefined;
      this._servername = undefined;
      this._tls = undefined;
      this._weight = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._host = value.host;
      this._port = value.port;
      this._servername = value.servername;
      this._tls = value.tls;
      this._weight = value.weight;
    }
  }

  // host - computed: false, optional: false, required: true
  private _host?: string; 
  public get host() {
    return this.getStringAttribute('host');
  }
  public set host(value: string) {
    this._host = value;
  }
  // Temporarily expose input value. Use with caution.
  public get hostInput() {
    return this._host;
  }

  // port - computed: true, optional: true, required: false
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // servername - computed: false, optional: true, required: false
  private _servername?: string; 
  public get servername() {
    return this.getStringAttribute('servername');
  }
  public set servername(value: string) {
    this._servername = value;
  }
  public resetServername() {
    this._servername = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get servernameInput() {
    return this._servername;
  }

  // tls - computed: true, optional: true, required: false
  private _tls?: string; 
  public get tls() {
    return this.getStringAttribute('tls');
  }
  public set tls(value: string) {
    this._tls = value;
  }
  public resetTls() {
    this._tls = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsInput() {
    return this._tls;
  }

  // weight - computed: true, optional: true, required: false
  private _weight?: number; 
  public get weight() {
    return this.getNumberAttribute('weight');
  }
  public set weight(value: number) {
    this._weight = value;
  }
  public resetWeight() {
    this._weight = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get weightInput() {
    return this._weight;
  }
}

export class DestinationOutputCriblTcpHostsList extends cdktf.ComplexList {
  public internalValue? : DestinationOutputCriblTcpHosts[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DestinationOutputCriblTcpHostsOutputReference {
    return new DestinationOutputCriblTcpHostsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DestinationOutputCriblTcpPqControls {
}

export function destinationOutputCriblTcpPqControlsToTerraform(struct?: DestinationOutputCriblTcpPqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function destinationOutputCriblTcpPqControlsToHclTerraform(struct?: DestinationOutputCriblTcpPqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class DestinationOutputCriblTcpPqControlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DestinationOutputCriblTcpPqControls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputCriblTcpPqControls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface DestinationOutputCriblTcpTls {
  /**
  * Path on client in which to find CA certificates to verify the server's cert. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#ca_path Destination#ca_path}
  */
  readonly caPath?: string;
  /**
  * Path on client in which to find certificates to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#cert_path Destination#cert_path}
  */
  readonly certPath?: string;
  /**
  * The name of the predefined certificate
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#certificate_name Destination#certificate_name}
  */
  readonly certificateName?: string;
  /**
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#disabled Destination#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#max_version Destination#max_version}
  */
  readonly maxVersion?: string;
  /**
  * must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#min_version Destination#min_version}
  */
  readonly minVersion?: string;
  /**
  * Passphrase to use to decrypt private key
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#passphrase Destination#passphrase}
  */
  readonly passphrase?: string;
  /**
  * Path on client in which to find the private key to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#priv_key_path Destination#priv_key_path}
  */
  readonly privKeyPath?: string;
  /**
  * Reject certificates that are not authorized by a CA in the CA certificate path, or by another 
  *                     trusted CA (such as the system's). Defaults to Enabled. Overrides the toggle from Advanced Settings, when also present.
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#reject_unauthorized Destination#reject_unauthorized}
  */
  readonly rejectUnauthorized?: boolean | cdktf.IResolvable;
  /**
  * Server name for the SNI (Server Name Indication) TLS extension. It must be a host name, and not an IP address.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#servername Destination#servername}
  */
  readonly servername?: string;
}

export function destinationOutputCriblTcpTlsToTerraform(struct?: DestinationOutputCriblTcpTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ca_path: cdktf.stringToTerraform(struct!.caPath),
    cert_path: cdktf.stringToTerraform(struct!.certPath),
    certificate_name: cdktf.stringToTerraform(struct!.certificateName),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    max_version: cdktf.stringToTerraform(struct!.maxVersion),
    min_version: cdktf.stringToTerraform(struct!.minVersion),
    passphrase: cdktf.stringToTerraform(struct!.passphrase),
    priv_key_path: cdktf.stringToTerraform(struct!.privKeyPath),
    reject_unauthorized: cdktf.booleanToTerraform(struct!.rejectUnauthorized),
    servername: cdktf.stringToTerraform(struct!.servername),
  }
}


export function destinationOutputCriblTcpTlsToHclTerraform(struct?: DestinationOutputCriblTcpTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ca_path: {
      value: cdktf.stringToHclTerraform(struct!.caPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    cert_path: {
      value: cdktf.stringToHclTerraform(struct!.certPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    certificate_name: {
      value: cdktf.stringToHclTerraform(struct!.certificateName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    max_version: {
      value: cdktf.stringToHclTerraform(struct!.maxVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    min_version: {
      value: cdktf.stringToHclTerraform(struct!.minVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    passphrase: {
      value: cdktf.stringToHclTerraform(struct!.passphrase),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    priv_key_path: {
      value: cdktf.stringToHclTerraform(struct!.privKeyPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reject_unauthorized: {
      value: cdktf.booleanToHclTerraform(struct!.rejectUnauthorized),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    servername: {
      value: cdktf.stringToHclTerraform(struct!.servername),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputCriblTcpTlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DestinationOutputCriblTcpTls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._caPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.caPath = this._caPath;
    }
    if (this._certPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.certPath = this._certPath;
    }
    if (this._certificateName !== undefined) {
      hasAnyValues = true;
      internalValueResult.certificateName = this._certificateName;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._maxVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxVersion = this._maxVersion;
    }
    if (this._minVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.minVersion = this._minVersion;
    }
    if (this._passphrase !== undefined) {
      hasAnyValues = true;
      internalValueResult.passphrase = this._passphrase;
    }
    if (this._privKeyPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.privKeyPath = this._privKeyPath;
    }
    if (this._rejectUnauthorized !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectUnauthorized = this._rejectUnauthorized;
    }
    if (this._servername !== undefined) {
      hasAnyValues = true;
      internalValueResult.servername = this._servername;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputCriblTcpTls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._caPath = undefined;
      this._certPath = undefined;
      this._certificateName = undefined;
      this._disabled = undefined;
      this._maxVersion = undefined;
      this._minVersion = undefined;
      this._passphrase = undefined;
      this._privKeyPath = undefined;
      this._rejectUnauthorized = undefined;
      this._servername = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._caPath = value.caPath;
      this._certPath = value.certPath;
      this._certificateName = value.certificateName;
      this._disabled = value.disabled;
      this._maxVersion = value.maxVersion;
      this._minVersion = value.minVersion;
      this._passphrase = value.passphrase;
      this._privKeyPath = value.privKeyPath;
      this._rejectUnauthorized = value.rejectUnauthorized;
      this._servername = value.servername;
    }
  }

  // ca_path - computed: false, optional: true, required: false
  private _caPath?: string; 
  public get caPath() {
    return this.getStringAttribute('ca_path');
  }
  public set caPath(value: string) {
    this._caPath = value;
  }
  public resetCaPath() {
    this._caPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get caPathInput() {
    return this._caPath;
  }

  // cert_path - computed: false, optional: true, required: false
  private _certPath?: string; 
  public get certPath() {
    return this.getStringAttribute('cert_path');
  }
  public set certPath(value: string) {
    this._certPath = value;
  }
  public resetCertPath() {
    this._certPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certPathInput() {
    return this._certPath;
  }

  // certificate_name - computed: false, optional: true, required: false
  private _certificateName?: string; 
  public get certificateName() {
    return this.getStringAttribute('certificate_name');
  }
  public set certificateName(value: string) {
    this._certificateName = value;
  }
  public resetCertificateName() {
    this._certificateName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certificateNameInput() {
    return this._certificateName;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // max_version - computed: false, optional: true, required: false
  private _maxVersion?: string; 
  public get maxVersion() {
    return this.getStringAttribute('max_version');
  }
  public set maxVersion(value: string) {
    this._maxVersion = value;
  }
  public resetMaxVersion() {
    this._maxVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxVersionInput() {
    return this._maxVersion;
  }

  // min_version - computed: false, optional: true, required: false
  private _minVersion?: string; 
  public get minVersion() {
    return this.getStringAttribute('min_version');
  }
  public set minVersion(value: string) {
    this._minVersion = value;
  }
  public resetMinVersion() {
    this._minVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get minVersionInput() {
    return this._minVersion;
  }

  // passphrase - computed: false, optional: true, required: false
  private _passphrase?: string; 
  public get passphrase() {
    return this.getStringAttribute('passphrase');
  }
  public set passphrase(value: string) {
    this._passphrase = value;
  }
  public resetPassphrase() {
    this._passphrase = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passphraseInput() {
    return this._passphrase;
  }

  // priv_key_path - computed: false, optional: true, required: false
  private _privKeyPath?: string; 
  public get privKeyPath() {
    return this.getStringAttribute('priv_key_path');
  }
  public set privKeyPath(value: string) {
    this._privKeyPath = value;
  }
  public resetPrivKeyPath() {
    this._privKeyPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get privKeyPathInput() {
    return this._privKeyPath;
  }

  // reject_unauthorized - computed: true, optional: true, required: false
  private _rejectUnauthorized?: boolean | cdktf.IResolvable; 
  public get rejectUnauthorized() {
    return this.getBooleanAttribute('reject_unauthorized');
  }
  public set rejectUnauthorized(value: boolean | cdktf.IResolvable) {
    this._rejectUnauthorized = value;
  }
  public resetRejectUnauthorized() {
    this._rejectUnauthorized = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectUnauthorizedInput() {
    return this._rejectUnauthorized;
  }

  // servername - computed: false, optional: true, required: false
  private _servername?: string; 
  public get servername() {
    return this.getStringAttribute('servername');
  }
  public set servername(value: string) {
    this._servername = value;
  }
  public resetServername() {
    this._servername = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get servernameInput() {
    return this._servername;
  }
}
export interface DestinationOutputCriblTcp {
  /**
  * Codec to use to compress the data before sending. Default: "gzip"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#compression Destination#compression}
  */
  readonly compression?: string;
  /**
  * Amount of time (milliseconds) to wait for the connection to establish before retrying. Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#connection_timeout Destination#connection_timeout}
  */
  readonly connectionTimeout?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#description Destination#description}
  */
  readonly description?: string;
  /**
  * The interval in which to re-resolve any hostnames and pick up destinations from A records. Default: 600
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#dns_resolve_period_sec Destination#dns_resolve_period_sec}
  */
  readonly dnsResolvePeriodSec?: number;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#environment Destination#environment}
  */
  readonly environment?: string;
  /**
  * Fields to exclude from the event. By default, all internal fields except `__output` are sent. Example: `cribl_pipe`, `c*`. Wildcards supported. Default: ["__kube_*","__metadata","__winEvent"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#exclude_fields Destination#exclude_fields}
  */
  readonly excludeFields?: string[];
  /**
  * Exclude all IPs of the current host from the list of any resolved hostnames. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#exclude_self Destination#exclude_self}
  */
  readonly excludeSelf?: boolean | cdktf.IResolvable;
  /**
  * The hostname of the receiver
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#host Destination#host}
  */
  readonly host?: string;
  /**
  * Set of hosts to load-balance data to
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#hosts Destination#hosts}
  */
  readonly hosts?: DestinationOutputCriblTcpHosts[] | cdktf.IResolvable;
  /**
  * Unique ID for this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#id Destination#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id: string;
  /**
  * How far back in time to keep traffic stats for load balancing purposes. Default: 300
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#load_balance_stats_period_sec Destination#load_balance_stats_period_sec}
  */
  readonly loadBalanceStatsPeriodSec?: number;
  /**
  * Use load-balanced destinations. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#load_balanced Destination#load_balanced}
  */
  readonly loadBalanced?: boolean | cdktf.IResolvable;
  /**
  * Use to troubleshoot issues with sending data. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#log_failed_requests Destination#log_failed_requests}
  */
  readonly logFailedRequests?: boolean | cdktf.IResolvable;
  /**
  * Maximum number of concurrent connections (per Worker Process). A random set of IPs will be picked on every DNS resolution period. Use 0 for unlimited. Default: 0
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#max_concurrent_senders Destination#max_concurrent_senders}
  */
  readonly maxConcurrentSenders?: number;
  /**
  * How to handle events when all receivers are exerting backpressure. Default: "block"; must be one of ["block", "drop", "queue"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#on_backpressure Destination#on_backpressure}
  */
  readonly onBackpressure?: string;
  /**
  * Pipeline to process data before sending out to this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pipeline Destination#pipeline}
  */
  readonly pipeline?: string;
  /**
  * The port to connect to on the provided host. Default: 10300
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#port Destination#port}
  */
  readonly port?: number;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pq_compress Destination#pq_compress}
  */
  readonly pqCompress?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pq_controls Destination#pq_controls}
  */
  readonly pqControls?: DestinationOutputCriblTcpPqControls;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.). Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pq_max_file_size Destination#pq_max_file_size}
  */
  readonly pqMaxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pq_max_size Destination#pq_max_size}
  */
  readonly pqMaxSize?: string;
  /**
  * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem. Default: "error"; must be one of ["error", "backpressure", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pq_mode Destination#pq_mode}
  */
  readonly pqMode?: string;
  /**
  * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged. Default: "block"; must be one of ["block", "drop"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pq_on_backpressure Destination#pq_on_backpressure}
  */
  readonly pqOnBackpressure?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pq_path Destination#pq_path}
  */
  readonly pqPath?: string;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#streamtags Destination#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Fields to automatically add to events, such as cribl_pipe. Supports wildcards. Default: ["cribl_pipe"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#system_fields Destination#system_fields}
  */
  readonly systemFields?: string[];
  /**
  * Rate (in bytes per second) to throttle while writing to an output. Accepts values with multiple-byte units, such as KB, MB, and GB. (Example: 42 MB) Default value of 0 specifies no throttling. Default: "0"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#throttle_rate_per_sec Destination#throttle_rate_per_sec}
  */
  readonly throttleRatePerSec?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#tls Destination#tls}
  */
  readonly tls?: DestinationOutputCriblTcpTls;
  /**
  * The number of minutes before the internally generated authentication token expires, valid values between 1 and 60. Default: 60
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#token_ttl_minutes Destination#token_ttl_minutes}
  */
  readonly tokenTtlMinutes?: number;
  /**
  * must be "cribl_tcp"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#type Destination#type}
  */
  readonly type: string;
  /**
  * Amount of time (milliseconds) to wait for a write to complete before assuming connection is dead. Default: 60000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#write_timeout Destination#write_timeout}
  */
  readonly writeTimeout?: number;
}

export function destinationOutputCriblTcpToTerraform(struct?: DestinationOutputCriblTcp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    compression: cdktf.stringToTerraform(struct!.compression),
    connection_timeout: cdktf.numberToTerraform(struct!.connectionTimeout),
    description: cdktf.stringToTerraform(struct!.description),
    dns_resolve_period_sec: cdktf.numberToTerraform(struct!.dnsResolvePeriodSec),
    environment: cdktf.stringToTerraform(struct!.environment),
    exclude_fields: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.excludeFields),
    exclude_self: cdktf.booleanToTerraform(struct!.excludeSelf),
    host: cdktf.stringToTerraform(struct!.host),
    hosts: cdktf.listMapper(destinationOutputCriblTcpHostsToTerraform, false)(struct!.hosts),
    id: cdktf.stringToTerraform(struct!.id),
    load_balance_stats_period_sec: cdktf.numberToTerraform(struct!.loadBalanceStatsPeriodSec),
    load_balanced: cdktf.booleanToTerraform(struct!.loadBalanced),
    log_failed_requests: cdktf.booleanToTerraform(struct!.logFailedRequests),
    max_concurrent_senders: cdktf.numberToTerraform(struct!.maxConcurrentSenders),
    on_backpressure: cdktf.stringToTerraform(struct!.onBackpressure),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    port: cdktf.numberToTerraform(struct!.port),
    pq_compress: cdktf.stringToTerraform(struct!.pqCompress),
    pq_controls: destinationOutputCriblTcpPqControlsToTerraform(struct!.pqControls),
    pq_max_file_size: cdktf.stringToTerraform(struct!.pqMaxFileSize),
    pq_max_size: cdktf.stringToTerraform(struct!.pqMaxSize),
    pq_mode: cdktf.stringToTerraform(struct!.pqMode),
    pq_on_backpressure: cdktf.stringToTerraform(struct!.pqOnBackpressure),
    pq_path: cdktf.stringToTerraform(struct!.pqPath),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    system_fields: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.systemFields),
    throttle_rate_per_sec: cdktf.stringToTerraform(struct!.throttleRatePerSec),
    tls: destinationOutputCriblTcpTlsToTerraform(struct!.tls),
    token_ttl_minutes: cdktf.numberToTerraform(struct!.tokenTtlMinutes),
    type: cdktf.stringToTerraform(struct!.type),
    write_timeout: cdktf.numberToTerraform(struct!.writeTimeout),
  }
}


export function destinationOutputCriblTcpToHclTerraform(struct?: DestinationOutputCriblTcp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    compression: {
      value: cdktf.stringToHclTerraform(struct!.compression),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    connection_timeout: {
      value: cdktf.numberToHclTerraform(struct!.connectionTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    dns_resolve_period_sec: {
      value: cdktf.numberToHclTerraform(struct!.dnsResolvePeriodSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    exclude_fields: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.excludeFields),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    exclude_self: {
      value: cdktf.booleanToHclTerraform(struct!.excludeSelf),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    host: {
      value: cdktf.stringToHclTerraform(struct!.host),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    hosts: {
      value: cdktf.listMapperHcl(destinationOutputCriblTcpHostsToHclTerraform, false)(struct!.hosts),
      isBlock: true,
      type: "list",
      storageClassType: "DestinationOutputCriblTcpHostsList",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    load_balance_stats_period_sec: {
      value: cdktf.numberToHclTerraform(struct!.loadBalanceStatsPeriodSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    load_balanced: {
      value: cdktf.booleanToHclTerraform(struct!.loadBalanced),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    log_failed_requests: {
      value: cdktf.booleanToHclTerraform(struct!.logFailedRequests),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    max_concurrent_senders: {
      value: cdktf.numberToHclTerraform(struct!.maxConcurrentSenders),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.onBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    pq_compress: {
      value: cdktf.stringToHclTerraform(struct!.pqCompress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_controls: {
      value: destinationOutputCriblTcpPqControlsToHclTerraform(struct!.pqControls),
      isBlock: true,
      type: "struct",
      storageClassType: "DestinationOutputCriblTcpPqControls",
    },
    pq_max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_max_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_mode: {
      value: cdktf.stringToHclTerraform(struct!.pqMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.pqOnBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_path: {
      value: cdktf.stringToHclTerraform(struct!.pqPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    system_fields: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.systemFields),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    throttle_rate_per_sec: {
      value: cdktf.stringToHclTerraform(struct!.throttleRatePerSec),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tls: {
      value: destinationOutputCriblTcpTlsToHclTerraform(struct!.tls),
      isBlock: true,
      type: "struct",
      storageClassType: "DestinationOutputCriblTcpTls",
    },
    token_ttl_minutes: {
      value: cdktf.numberToHclTerraform(struct!.tokenTtlMinutes),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    write_timeout: {
      value: cdktf.numberToHclTerraform(struct!.writeTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputCriblTcpOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DestinationOutputCriblTcp | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._compression !== undefined) {
      hasAnyValues = true;
      internalValueResult.compression = this._compression;
    }
    if (this._connectionTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.connectionTimeout = this._connectionTimeout;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._dnsResolvePeriodSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.dnsResolvePeriodSec = this._dnsResolvePeriodSec;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._excludeFields !== undefined) {
      hasAnyValues = true;
      internalValueResult.excludeFields = this._excludeFields;
    }
    if (this._excludeSelf !== undefined) {
      hasAnyValues = true;
      internalValueResult.excludeSelf = this._excludeSelf;
    }
    if (this._host !== undefined) {
      hasAnyValues = true;
      internalValueResult.host = this._host;
    }
    if (this._hosts?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.hosts = this._hosts?.internalValue;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._loadBalanceStatsPeriodSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.loadBalanceStatsPeriodSec = this._loadBalanceStatsPeriodSec;
    }
    if (this._loadBalanced !== undefined) {
      hasAnyValues = true;
      internalValueResult.loadBalanced = this._loadBalanced;
    }
    if (this._logFailedRequests !== undefined) {
      hasAnyValues = true;
      internalValueResult.logFailedRequests = this._logFailedRequests;
    }
    if (this._maxConcurrentSenders !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxConcurrentSenders = this._maxConcurrentSenders;
    }
    if (this._onBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.onBackpressure = this._onBackpressure;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._pqCompress !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqCompress = this._pqCompress;
    }
    if (this._pqControls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqControls = this._pqControls?.internalValue;
    }
    if (this._pqMaxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxFileSize = this._pqMaxFileSize;
    }
    if (this._pqMaxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxSize = this._pqMaxSize;
    }
    if (this._pqMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMode = this._pqMode;
    }
    if (this._pqOnBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqOnBackpressure = this._pqOnBackpressure;
    }
    if (this._pqPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqPath = this._pqPath;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._systemFields !== undefined) {
      hasAnyValues = true;
      internalValueResult.systemFields = this._systemFields;
    }
    if (this._throttleRatePerSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.throttleRatePerSec = this._throttleRatePerSec;
    }
    if (this._tls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tls = this._tls?.internalValue;
    }
    if (this._tokenTtlMinutes !== undefined) {
      hasAnyValues = true;
      internalValueResult.tokenTtlMinutes = this._tokenTtlMinutes;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._writeTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.writeTimeout = this._writeTimeout;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputCriblTcp | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._compression = undefined;
      this._connectionTimeout = undefined;
      this._description = undefined;
      this._dnsResolvePeriodSec = undefined;
      this._environment = undefined;
      this._excludeFields = undefined;
      this._excludeSelf = undefined;
      this._host = undefined;
      this._hosts.internalValue = undefined;
      this._id = undefined;
      this._loadBalanceStatsPeriodSec = undefined;
      this._loadBalanced = undefined;
      this._logFailedRequests = undefined;
      this._maxConcurrentSenders = undefined;
      this._onBackpressure = undefined;
      this._pipeline = undefined;
      this._port = undefined;
      this._pqCompress = undefined;
      this._pqControls.internalValue = undefined;
      this._pqMaxFileSize = undefined;
      this._pqMaxSize = undefined;
      this._pqMode = undefined;
      this._pqOnBackpressure = undefined;
      this._pqPath = undefined;
      this._streamtags = undefined;
      this._systemFields = undefined;
      this._throttleRatePerSec = undefined;
      this._tls.internalValue = undefined;
      this._tokenTtlMinutes = undefined;
      this._type = undefined;
      this._writeTimeout = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._compression = value.compression;
      this._connectionTimeout = value.connectionTimeout;
      this._description = value.description;
      this._dnsResolvePeriodSec = value.dnsResolvePeriodSec;
      this._environment = value.environment;
      this._excludeFields = value.excludeFields;
      this._excludeSelf = value.excludeSelf;
      this._host = value.host;
      this._hosts.internalValue = value.hosts;
      this._id = value.id;
      this._loadBalanceStatsPeriodSec = value.loadBalanceStatsPeriodSec;
      this._loadBalanced = value.loadBalanced;
      this._logFailedRequests = value.logFailedRequests;
      this._maxConcurrentSenders = value.maxConcurrentSenders;
      this._onBackpressure = value.onBackpressure;
      this._pipeline = value.pipeline;
      this._port = value.port;
      this._pqCompress = value.pqCompress;
      this._pqControls.internalValue = value.pqControls;
      this._pqMaxFileSize = value.pqMaxFileSize;
      this._pqMaxSize = value.pqMaxSize;
      this._pqMode = value.pqMode;
      this._pqOnBackpressure = value.pqOnBackpressure;
      this._pqPath = value.pqPath;
      this._streamtags = value.streamtags;
      this._systemFields = value.systemFields;
      this._throttleRatePerSec = value.throttleRatePerSec;
      this._tls.internalValue = value.tls;
      this._tokenTtlMinutes = value.tokenTtlMinutes;
      this._type = value.type;
      this._writeTimeout = value.writeTimeout;
    }
  }

  // compression - computed: true, optional: true, required: false
  private _compression?: string; 
  public get compression() {
    return this.getStringAttribute('compression');
  }
  public set compression(value: string) {
    this._compression = value;
  }
  public resetCompression() {
    this._compression = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressionInput() {
    return this._compression;
  }

  // connection_timeout - computed: true, optional: true, required: false
  private _connectionTimeout?: number; 
  public get connectionTimeout() {
    return this.getNumberAttribute('connection_timeout');
  }
  public set connectionTimeout(value: number) {
    this._connectionTimeout = value;
  }
  public resetConnectionTimeout() {
    this._connectionTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectionTimeoutInput() {
    return this._connectionTimeout;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // dns_resolve_period_sec - computed: true, optional: true, required: false
  private _dnsResolvePeriodSec?: number; 
  public get dnsResolvePeriodSec() {
    return this.getNumberAttribute('dns_resolve_period_sec');
  }
  public set dnsResolvePeriodSec(value: number) {
    this._dnsResolvePeriodSec = value;
  }
  public resetDnsResolvePeriodSec() {
    this._dnsResolvePeriodSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dnsResolvePeriodSecInput() {
    return this._dnsResolvePeriodSec;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // exclude_fields - computed: true, optional: true, required: false
  private _excludeFields?: string[]; 
  public get excludeFields() {
    return this.getListAttribute('exclude_fields');
  }
  public set excludeFields(value: string[]) {
    this._excludeFields = value;
  }
  public resetExcludeFields() {
    this._excludeFields = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get excludeFieldsInput() {
    return this._excludeFields;
  }

  // exclude_self - computed: true, optional: true, required: false
  private _excludeSelf?: boolean | cdktf.IResolvable; 
  public get excludeSelf() {
    return this.getBooleanAttribute('exclude_self');
  }
  public set excludeSelf(value: boolean | cdktf.IResolvable) {
    this._excludeSelf = value;
  }
  public resetExcludeSelf() {
    this._excludeSelf = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get excludeSelfInput() {
    return this._excludeSelf;
  }

  // host - computed: false, optional: true, required: false
  private _host?: string; 
  public get host() {
    return this.getStringAttribute('host');
  }
  public set host(value: string) {
    this._host = value;
  }
  public resetHost() {
    this._host = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostInput() {
    return this._host;
  }

  // hosts - computed: false, optional: true, required: false
  private _hosts = new DestinationOutputCriblTcpHostsList(this, "hosts", false);
  public get hosts() {
    return this._hosts;
  }
  public putHosts(value: DestinationOutputCriblTcpHosts[] | cdktf.IResolvable) {
    this._hosts.internalValue = value;
  }
  public resetHosts() {
    this._hosts.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostsInput() {
    return this._hosts.internalValue;
  }

  // id - computed: false, optional: false, required: true
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // load_balance_stats_period_sec - computed: true, optional: true, required: false
  private _loadBalanceStatsPeriodSec?: number; 
  public get loadBalanceStatsPeriodSec() {
    return this.getNumberAttribute('load_balance_stats_period_sec');
  }
  public set loadBalanceStatsPeriodSec(value: number) {
    this._loadBalanceStatsPeriodSec = value;
  }
  public resetLoadBalanceStatsPeriodSec() {
    this._loadBalanceStatsPeriodSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get loadBalanceStatsPeriodSecInput() {
    return this._loadBalanceStatsPeriodSec;
  }

  // load_balanced - computed: true, optional: true, required: false
  private _loadBalanced?: boolean | cdktf.IResolvable; 
  public get loadBalanced() {
    return this.getBooleanAttribute('load_balanced');
  }
  public set loadBalanced(value: boolean | cdktf.IResolvable) {
    this._loadBalanced = value;
  }
  public resetLoadBalanced() {
    this._loadBalanced = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get loadBalancedInput() {
    return this._loadBalanced;
  }

  // log_failed_requests - computed: true, optional: true, required: false
  private _logFailedRequests?: boolean | cdktf.IResolvable; 
  public get logFailedRequests() {
    return this.getBooleanAttribute('log_failed_requests');
  }
  public set logFailedRequests(value: boolean | cdktf.IResolvable) {
    this._logFailedRequests = value;
  }
  public resetLogFailedRequests() {
    this._logFailedRequests = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get logFailedRequestsInput() {
    return this._logFailedRequests;
  }

  // max_concurrent_senders - computed: true, optional: true, required: false
  private _maxConcurrentSenders?: number; 
  public get maxConcurrentSenders() {
    return this.getNumberAttribute('max_concurrent_senders');
  }
  public set maxConcurrentSenders(value: number) {
    this._maxConcurrentSenders = value;
  }
  public resetMaxConcurrentSenders() {
    this._maxConcurrentSenders = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxConcurrentSendersInput() {
    return this._maxConcurrentSenders;
  }

  // on_backpressure - computed: true, optional: true, required: false
  private _onBackpressure?: string; 
  public get onBackpressure() {
    return this.getStringAttribute('on_backpressure');
  }
  public set onBackpressure(value: string) {
    this._onBackpressure = value;
  }
  public resetOnBackpressure() {
    this._onBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get onBackpressureInput() {
    return this._onBackpressure;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // port - computed: true, optional: true, required: false
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // pq_compress - computed: true, optional: true, required: false
  private _pqCompress?: string; 
  public get pqCompress() {
    return this.getStringAttribute('pq_compress');
  }
  public set pqCompress(value: string) {
    this._pqCompress = value;
  }
  public resetPqCompress() {
    this._pqCompress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqCompressInput() {
    return this._pqCompress;
  }

  // pq_controls - computed: false, optional: true, required: false
  private _pqControls = new DestinationOutputCriblTcpPqControlsOutputReference(this, "pq_controls");
  public get pqControls() {
    return this._pqControls;
  }
  public putPqControls(value: DestinationOutputCriblTcpPqControls) {
    this._pqControls.internalValue = value;
  }
  public resetPqControls() {
    this._pqControls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqControlsInput() {
    return this._pqControls.internalValue;
  }

  // pq_max_file_size - computed: true, optional: true, required: false
  private _pqMaxFileSize?: string; 
  public get pqMaxFileSize() {
    return this.getStringAttribute('pq_max_file_size');
  }
  public set pqMaxFileSize(value: string) {
    this._pqMaxFileSize = value;
  }
  public resetPqMaxFileSize() {
    this._pqMaxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxFileSizeInput() {
    return this._pqMaxFileSize;
  }

  // pq_max_size - computed: true, optional: true, required: false
  private _pqMaxSize?: string; 
  public get pqMaxSize() {
    return this.getStringAttribute('pq_max_size');
  }
  public set pqMaxSize(value: string) {
    this._pqMaxSize = value;
  }
  public resetPqMaxSize() {
    this._pqMaxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxSizeInput() {
    return this._pqMaxSize;
  }

  // pq_mode - computed: true, optional: true, required: false
  private _pqMode?: string; 
  public get pqMode() {
    return this.getStringAttribute('pq_mode');
  }
  public set pqMode(value: string) {
    this._pqMode = value;
  }
  public resetPqMode() {
    this._pqMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqModeInput() {
    return this._pqMode;
  }

  // pq_on_backpressure - computed: true, optional: true, required: false
  private _pqOnBackpressure?: string; 
  public get pqOnBackpressure() {
    return this.getStringAttribute('pq_on_backpressure');
  }
  public set pqOnBackpressure(value: string) {
    this._pqOnBackpressure = value;
  }
  public resetPqOnBackpressure() {
    this._pqOnBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqOnBackpressureInput() {
    return this._pqOnBackpressure;
  }

  // pq_path - computed: true, optional: true, required: false
  private _pqPath?: string; 
  public get pqPath() {
    return this.getStringAttribute('pq_path');
  }
  public set pqPath(value: string) {
    this._pqPath = value;
  }
  public resetPqPath() {
    this._pqPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqPathInput() {
    return this._pqPath;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // system_fields - computed: true, optional: true, required: false
  private _systemFields?: string[]; 
  public get systemFields() {
    return this.getListAttribute('system_fields');
  }
  public set systemFields(value: string[]) {
    this._systemFields = value;
  }
  public resetSystemFields() {
    this._systemFields = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get systemFieldsInput() {
    return this._systemFields;
  }

  // throttle_rate_per_sec - computed: true, optional: true, required: false
  private _throttleRatePerSec?: string; 
  public get throttleRatePerSec() {
    return this.getStringAttribute('throttle_rate_per_sec');
  }
  public set throttleRatePerSec(value: string) {
    this._throttleRatePerSec = value;
  }
  public resetThrottleRatePerSec() {
    this._throttleRatePerSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get throttleRatePerSecInput() {
    return this._throttleRatePerSec;
  }

  // tls - computed: false, optional: true, required: false
  private _tls = new DestinationOutputCriblTcpTlsOutputReference(this, "tls");
  public get tls() {
    return this._tls;
  }
  public putTls(value: DestinationOutputCriblTcpTls) {
    this._tls.internalValue = value;
  }
  public resetTls() {
    this._tls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsInput() {
    return this._tls.internalValue;
  }

  // token_ttl_minutes - computed: true, optional: true, required: false
  private _tokenTtlMinutes?: number; 
  public get tokenTtlMinutes() {
    return this.getNumberAttribute('token_ttl_minutes');
  }
  public set tokenTtlMinutes(value: number) {
    this._tokenTtlMinutes = value;
  }
  public resetTokenTtlMinutes() {
    this._tokenTtlMinutes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tokenTtlMinutesInput() {
    return this._tokenTtlMinutes;
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // write_timeout - computed: true, optional: true, required: false
  private _writeTimeout?: number; 
  public get writeTimeout() {
    return this.getNumberAttribute('write_timeout');
  }
  public set writeTimeout(value: number) {
    this._writeTimeout = value;
  }
  public resetWriteTimeout() {
    this._writeTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get writeTimeoutInput() {
    return this._writeTimeout;
  }
}
export interface DestinationOutputCrowdstrikeNextGenSiemExtraHttpHeaders {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#name Destination#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#value Destination#value}
  */
  readonly value: string;
}

export function destinationOutputCrowdstrikeNextGenSiemExtraHttpHeadersToTerraform(struct?: DestinationOutputCrowdstrikeNextGenSiemExtraHttpHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function destinationOutputCrowdstrikeNextGenSiemExtraHttpHeadersToHclTerraform(struct?: DestinationOutputCrowdstrikeNextGenSiemExtraHttpHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputCrowdstrikeNextGenSiemExtraHttpHeadersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DestinationOutputCrowdstrikeNextGenSiemExtraHttpHeaders | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputCrowdstrikeNextGenSiemExtraHttpHeaders | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DestinationOutputCrowdstrikeNextGenSiemExtraHttpHeadersList extends cdktf.ComplexList {
  public internalValue? : DestinationOutputCrowdstrikeNextGenSiemExtraHttpHeaders[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DestinationOutputCrowdstrikeNextGenSiemExtraHttpHeadersOutputReference {
    return new DestinationOutputCrowdstrikeNextGenSiemExtraHttpHeadersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DestinationOutputCrowdstrikeNextGenSiemPqControls {
}

export function destinationOutputCrowdstrikeNextGenSiemPqControlsToTerraform(struct?: DestinationOutputCrowdstrikeNextGenSiemPqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function destinationOutputCrowdstrikeNextGenSiemPqControlsToHclTerraform(struct?: DestinationOutputCrowdstrikeNextGenSiemPqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class DestinationOutputCrowdstrikeNextGenSiemPqControlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DestinationOutputCrowdstrikeNextGenSiemPqControls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputCrowdstrikeNextGenSiemPqControls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface DestinationOutputCrowdstrikeNextGenSiemResponseRetrySettings {
  /**
  * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc. Default: 2
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#backoff_rate Destination#backoff_rate}
  */
  readonly backoffRate?: number;
  /**
  * The HTTP response status code that will trigger retries
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#http_status Destination#http_status}
  */
  readonly httpStatus: number;
  /**
  * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes). Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#initial_backoff Destination#initial_backoff}
  */
  readonly initialBackoff?: number;
  /**
  * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds). Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#max_backoff Destination#max_backoff}
  */
  readonly maxBackoff?: number;
}

export function destinationOutputCrowdstrikeNextGenSiemResponseRetrySettingsToTerraform(struct?: DestinationOutputCrowdstrikeNextGenSiemResponseRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    backoff_rate: cdktf.numberToTerraform(struct!.backoffRate),
    http_status: cdktf.numberToTerraform(struct!.httpStatus),
    initial_backoff: cdktf.numberToTerraform(struct!.initialBackoff),
    max_backoff: cdktf.numberToTerraform(struct!.maxBackoff),
  }
}


export function destinationOutputCrowdstrikeNextGenSiemResponseRetrySettingsToHclTerraform(struct?: DestinationOutputCrowdstrikeNextGenSiemResponseRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    backoff_rate: {
      value: cdktf.numberToHclTerraform(struct!.backoffRate),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    http_status: {
      value: cdktf.numberToHclTerraform(struct!.httpStatus),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    initial_backoff: {
      value: cdktf.numberToHclTerraform(struct!.initialBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_backoff: {
      value: cdktf.numberToHclTerraform(struct!.maxBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputCrowdstrikeNextGenSiemResponseRetrySettingsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DestinationOutputCrowdstrikeNextGenSiemResponseRetrySettings | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._backoffRate !== undefined) {
      hasAnyValues = true;
      internalValueResult.backoffRate = this._backoffRate;
    }
    if (this._httpStatus !== undefined) {
      hasAnyValues = true;
      internalValueResult.httpStatus = this._httpStatus;
    }
    if (this._initialBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.initialBackoff = this._initialBackoff;
    }
    if (this._maxBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBackoff = this._maxBackoff;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputCrowdstrikeNextGenSiemResponseRetrySettings | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._backoffRate = undefined;
      this._httpStatus = undefined;
      this._initialBackoff = undefined;
      this._maxBackoff = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._backoffRate = value.backoffRate;
      this._httpStatus = value.httpStatus;
      this._initialBackoff = value.initialBackoff;
      this._maxBackoff = value.maxBackoff;
    }
  }

  // backoff_rate - computed: true, optional: true, required: false
  private _backoffRate?: number; 
  public get backoffRate() {
    return this.getNumberAttribute('backoff_rate');
  }
  public set backoffRate(value: number) {
    this._backoffRate = value;
  }
  public resetBackoffRate() {
    this._backoffRate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get backoffRateInput() {
    return this._backoffRate;
  }

  // http_status - computed: false, optional: false, required: true
  private _httpStatus?: number; 
  public get httpStatus() {
    return this.getNumberAttribute('http_status');
  }
  public set httpStatus(value: number) {
    this._httpStatus = value;
  }
  // Temporarily expose input value. Use with caution.
  public get httpStatusInput() {
    return this._httpStatus;
  }

  // initial_backoff - computed: true, optional: true, required: false
  private _initialBackoff?: number; 
  public get initialBackoff() {
    return this.getNumberAttribute('initial_backoff');
  }
  public set initialBackoff(value: number) {
    this._initialBackoff = value;
  }
  public resetInitialBackoff() {
    this._initialBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get initialBackoffInput() {
    return this._initialBackoff;
  }

  // max_backoff - computed: true, optional: true, required: false
  private _maxBackoff?: number; 
  public get maxBackoff() {
    return this.getNumberAttribute('max_backoff');
  }
  public set maxBackoff(value: number) {
    this._maxBackoff = value;
  }
  public resetMaxBackoff() {
    this._maxBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBackoffInput() {
    return this._maxBackoff;
  }
}

export class DestinationOutputCrowdstrikeNextGenSiemResponseRetrySettingsList extends cdktf.ComplexList {
  public internalValue? : DestinationOutputCrowdstrikeNextGenSiemResponseRetrySettings[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DestinationOutputCrowdstrikeNextGenSiemResponseRetrySettingsOutputReference {
    return new DestinationOutputCrowdstrikeNextGenSiemResponseRetrySettingsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DestinationOutputCrowdstrikeNextGenSiemTimeoutRetrySettings {
  /**
  * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc. Default: 2
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#backoff_rate Destination#backoff_rate}
  */
  readonly backoffRate?: number;
  /**
  * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes). Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#initial_backoff Destination#initial_backoff}
  */
  readonly initialBackoff?: number;
  /**
  * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds). Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#max_backoff Destination#max_backoff}
  */
  readonly maxBackoff?: number;
  /**
  * Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#timeout_retry Destination#timeout_retry}
  */
  readonly timeoutRetry?: boolean | cdktf.IResolvable;
}

export function destinationOutputCrowdstrikeNextGenSiemTimeoutRetrySettingsToTerraform(struct?: DestinationOutputCrowdstrikeNextGenSiemTimeoutRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    backoff_rate: cdktf.numberToTerraform(struct!.backoffRate),
    initial_backoff: cdktf.numberToTerraform(struct!.initialBackoff),
    max_backoff: cdktf.numberToTerraform(struct!.maxBackoff),
    timeout_retry: cdktf.booleanToTerraform(struct!.timeoutRetry),
  }
}


export function destinationOutputCrowdstrikeNextGenSiemTimeoutRetrySettingsToHclTerraform(struct?: DestinationOutputCrowdstrikeNextGenSiemTimeoutRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    backoff_rate: {
      value: cdktf.numberToHclTerraform(struct!.backoffRate),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    initial_backoff: {
      value: cdktf.numberToHclTerraform(struct!.initialBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_backoff: {
      value: cdktf.numberToHclTerraform(struct!.maxBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    timeout_retry: {
      value: cdktf.booleanToHclTerraform(struct!.timeoutRetry),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputCrowdstrikeNextGenSiemTimeoutRetrySettingsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DestinationOutputCrowdstrikeNextGenSiemTimeoutRetrySettings | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._backoffRate !== undefined) {
      hasAnyValues = true;
      internalValueResult.backoffRate = this._backoffRate;
    }
    if (this._initialBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.initialBackoff = this._initialBackoff;
    }
    if (this._maxBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBackoff = this._maxBackoff;
    }
    if (this._timeoutRetry !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutRetry = this._timeoutRetry;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputCrowdstrikeNextGenSiemTimeoutRetrySettings | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._backoffRate = undefined;
      this._initialBackoff = undefined;
      this._maxBackoff = undefined;
      this._timeoutRetry = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._backoffRate = value.backoffRate;
      this._initialBackoff = value.initialBackoff;
      this._maxBackoff = value.maxBackoff;
      this._timeoutRetry = value.timeoutRetry;
    }
  }

  // backoff_rate - computed: true, optional: true, required: false
  private _backoffRate?: number; 
  public get backoffRate() {
    return this.getNumberAttribute('backoff_rate');
  }
  public set backoffRate(value: number) {
    this._backoffRate = value;
  }
  public resetBackoffRate() {
    this._backoffRate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get backoffRateInput() {
    return this._backoffRate;
  }

  // initial_backoff - computed: true, optional: true, required: false
  private _initialBackoff?: number; 
  public get initialBackoff() {
    return this.getNumberAttribute('initial_backoff');
  }
  public set initialBackoff(value: number) {
    this._initialBackoff = value;
  }
  public resetInitialBackoff() {
    this._initialBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get initialBackoffInput() {
    return this._initialBackoff;
  }

  // max_backoff - computed: true, optional: true, required: false
  private _maxBackoff?: number; 
  public get maxBackoff() {
    return this.getNumberAttribute('max_backoff');
  }
  public set maxBackoff(value: number) {
    this._maxBackoff = value;
  }
  public resetMaxBackoff() {
    this._maxBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBackoffInput() {
    return this._maxBackoff;
  }

  // timeout_retry - computed: true, optional: true, required: false
  private _timeoutRetry?: boolean | cdktf.IResolvable; 
  public get timeoutRetry() {
    return this.getBooleanAttribute('timeout_retry');
  }
  public set timeoutRetry(value: boolean | cdktf.IResolvable) {
    this._timeoutRetry = value;
  }
  public resetTimeoutRetry() {
    this._timeoutRetry = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutRetryInput() {
    return this._timeoutRetry;
  }
}
export interface DestinationOutputCrowdstrikeNextGenSiem {
  /**
  * Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate. Default: "manual"; must be one of ["manual", "secret"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#auth_type Destination#auth_type}
  */
  readonly authType?: string;
  /**
  * Compress the payload body before sending. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#compress Destination#compress}
  */
  readonly compress?: boolean | cdktf.IResolvable;
  /**
  * Maximum number of ongoing requests before blocking. Default: 5
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#concurrency Destination#concurrency}
  */
  readonly concurrency?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#description Destination#description}
  */
  readonly description?: string;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#environment Destination#environment}
  */
  readonly environment?: string;
  /**
  * Headers to add to all events
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#extra_http_headers Destination#extra_http_headers}
  */
  readonly extraHttpHeaders?: DestinationOutputCrowdstrikeNextGenSiemExtraHttpHeaders[] | cdktf.IResolvable;
  /**
  * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below. Default: "none"; must be one of ["payload", "payloadAndHeaders", "none"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#failed_request_logging_mode Destination#failed_request_logging_mode}
  */
  readonly failedRequestLoggingMode?: string;
  /**
  * Maximum time between requests. Small values could cause the payload size to be smaller than the configured Body size limit. Default: 1
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#flush_period_sec Destination#flush_period_sec}
  */
  readonly flushPeriodSec?: number;
  /**
  * When set to JSON, the event is automatically formatted with required fields before sending. When set to Raw, only the event's `_raw` value is sent. Default: "raw"; must be one of ["JSON", "raw"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#format Destination#format}
  */
  readonly format?: string;
  /**
  * Unique ID for this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#id Destination#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * Maximum number of events to include in the request body. Default is 0 (unlimited). Default: 0
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#max_payload_events Destination#max_payload_events}
  */
  readonly maxPayloadEvents?: number;
  /**
  * Maximum size, in KB, of the request body. Default: 4096
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#max_payload_size_kb Destination#max_payload_size_kb}
  */
  readonly maxPayloadSizeKb?: number;
  /**
  * How to handle events when all receivers are exerting backpressure. Default: "block"; must be one of ["block", "drop", "queue"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#on_backpressure Destination#on_backpressure}
  */
  readonly onBackpressure?: string;
  /**
  * Pipeline to process data before sending out to this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pipeline Destination#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pq_compress Destination#pq_compress}
  */
  readonly pqCompress?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pq_controls Destination#pq_controls}
  */
  readonly pqControls?: DestinationOutputCrowdstrikeNextGenSiemPqControls;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.). Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pq_max_file_size Destination#pq_max_file_size}
  */
  readonly pqMaxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pq_max_size Destination#pq_max_size}
  */
  readonly pqMaxSize?: string;
  /**
  * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem. Default: "error"; must be one of ["error", "backpressure", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pq_mode Destination#pq_mode}
  */
  readonly pqMode?: string;
  /**
  * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged. Default: "block"; must be one of ["block", "drop"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pq_on_backpressure Destination#pq_on_backpressure}
  */
  readonly pqOnBackpressure?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pq_path Destination#pq_path}
  */
  readonly pqPath?: string;
  /**
  * Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's). 
  *         Enabled by default. When this setting is also present in TLS Settings (Client Side), 
  *         that value will take precedence.
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#reject_unauthorized Destination#reject_unauthorized}
  */
  readonly rejectUnauthorized?: boolean | cdktf.IResolvable;
  /**
  * Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#response_honor_retry_after_header Destination#response_honor_retry_after_header}
  */
  readonly responseHonorRetryAfterHeader?: boolean | cdktf.IResolvable;
  /**
  * Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#response_retry_settings Destination#response_retry_settings}
  */
  readonly responseRetrySettings?: DestinationOutputCrowdstrikeNextGenSiemResponseRetrySettings[] | cdktf.IResolvable;
  /**
  * List of headers that are safe to log in plain text. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#safe_headers Destination#safe_headers}
  */
  readonly safeHeaders?: string[];
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#streamtags Destination#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Fields to automatically add to events, such as cribl_pipe. Supports wildcards. Default: ["cribl_pipe"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#system_fields Destination#system_fields}
  */
  readonly systemFields?: string[];
  /**
  * Select or create a stored text secret
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#text_secret Destination#text_secret}
  */
  readonly textSecret?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#timeout_retry_settings Destination#timeout_retry_settings}
  */
  readonly timeoutRetrySettings?: DestinationOutputCrowdstrikeNextGenSiemTimeoutRetrySettings;
  /**
  * Amount of time, in seconds, to wait for a request to complete before canceling it. Default: 30
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#timeout_sec Destination#timeout_sec}
  */
  readonly timeoutSec?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#token Destination#token}
  */
  readonly token?: string;
  /**
  * must be "crowdstrike_next_gen_siem"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#type Destination#type}
  */
  readonly type?: string;
  /**
  * URL provided from a CrowdStrike data connector. 
  * Example: https://ingest.<region>.crowdstrike.com/api/ingest/hec/<connection-id>/v1/services/collector
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#url Destination#url}
  */
  readonly url: string;
  /**
  * Enable round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. For optimal performance, consider enabling this setting for non-load balanced destinations. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#use_round_robin_dns Destination#use_round_robin_dns}
  */
  readonly useRoundRobinDns?: boolean | cdktf.IResolvable;
}

export function destinationOutputCrowdstrikeNextGenSiemToTerraform(struct?: DestinationOutputCrowdstrikeNextGenSiem | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    auth_type: cdktf.stringToTerraform(struct!.authType),
    compress: cdktf.booleanToTerraform(struct!.compress),
    concurrency: cdktf.numberToTerraform(struct!.concurrency),
    description: cdktf.stringToTerraform(struct!.description),
    environment: cdktf.stringToTerraform(struct!.environment),
    extra_http_headers: cdktf.listMapper(destinationOutputCrowdstrikeNextGenSiemExtraHttpHeadersToTerraform, false)(struct!.extraHttpHeaders),
    failed_request_logging_mode: cdktf.stringToTerraform(struct!.failedRequestLoggingMode),
    flush_period_sec: cdktf.numberToTerraform(struct!.flushPeriodSec),
    format: cdktf.stringToTerraform(struct!.format),
    id: cdktf.stringToTerraform(struct!.id),
    max_payload_events: cdktf.numberToTerraform(struct!.maxPayloadEvents),
    max_payload_size_kb: cdktf.numberToTerraform(struct!.maxPayloadSizeKb),
    on_backpressure: cdktf.stringToTerraform(struct!.onBackpressure),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    pq_compress: cdktf.stringToTerraform(struct!.pqCompress),
    pq_controls: destinationOutputCrowdstrikeNextGenSiemPqControlsToTerraform(struct!.pqControls),
    pq_max_file_size: cdktf.stringToTerraform(struct!.pqMaxFileSize),
    pq_max_size: cdktf.stringToTerraform(struct!.pqMaxSize),
    pq_mode: cdktf.stringToTerraform(struct!.pqMode),
    pq_on_backpressure: cdktf.stringToTerraform(struct!.pqOnBackpressure),
    pq_path: cdktf.stringToTerraform(struct!.pqPath),
    reject_unauthorized: cdktf.booleanToTerraform(struct!.rejectUnauthorized),
    response_honor_retry_after_header: cdktf.booleanToTerraform(struct!.responseHonorRetryAfterHeader),
    response_retry_settings: cdktf.listMapper(destinationOutputCrowdstrikeNextGenSiemResponseRetrySettingsToTerraform, false)(struct!.responseRetrySettings),
    safe_headers: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.safeHeaders),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    system_fields: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.systemFields),
    text_secret: cdktf.stringToTerraform(struct!.textSecret),
    timeout_retry_settings: destinationOutputCrowdstrikeNextGenSiemTimeoutRetrySettingsToTerraform(struct!.timeoutRetrySettings),
    timeout_sec: cdktf.numberToTerraform(struct!.timeoutSec),
    token: cdktf.stringToTerraform(struct!.token),
    type: cdktf.stringToTerraform(struct!.type),
    url: cdktf.stringToTerraform(struct!.url),
    use_round_robin_dns: cdktf.booleanToTerraform(struct!.useRoundRobinDns),
  }
}


export function destinationOutputCrowdstrikeNextGenSiemToHclTerraform(struct?: DestinationOutputCrowdstrikeNextGenSiem | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    auth_type: {
      value: cdktf.stringToHclTerraform(struct!.authType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    compress: {
      value: cdktf.booleanToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    concurrency: {
      value: cdktf.numberToHclTerraform(struct!.concurrency),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    extra_http_headers: {
      value: cdktf.listMapperHcl(destinationOutputCrowdstrikeNextGenSiemExtraHttpHeadersToHclTerraform, false)(struct!.extraHttpHeaders),
      isBlock: true,
      type: "list",
      storageClassType: "DestinationOutputCrowdstrikeNextGenSiemExtraHttpHeadersList",
    },
    failed_request_logging_mode: {
      value: cdktf.stringToHclTerraform(struct!.failedRequestLoggingMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    flush_period_sec: {
      value: cdktf.numberToHclTerraform(struct!.flushPeriodSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    format: {
      value: cdktf.stringToHclTerraform(struct!.format),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_payload_events: {
      value: cdktf.numberToHclTerraform(struct!.maxPayloadEvents),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_payload_size_kb: {
      value: cdktf.numberToHclTerraform(struct!.maxPayloadSizeKb),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.onBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_compress: {
      value: cdktf.stringToHclTerraform(struct!.pqCompress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_controls: {
      value: destinationOutputCrowdstrikeNextGenSiemPqControlsToHclTerraform(struct!.pqControls),
      isBlock: true,
      type: "struct",
      storageClassType: "DestinationOutputCrowdstrikeNextGenSiemPqControls",
    },
    pq_max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_max_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_mode: {
      value: cdktf.stringToHclTerraform(struct!.pqMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.pqOnBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_path: {
      value: cdktf.stringToHclTerraform(struct!.pqPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reject_unauthorized: {
      value: cdktf.booleanToHclTerraform(struct!.rejectUnauthorized),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    response_honor_retry_after_header: {
      value: cdktf.booleanToHclTerraform(struct!.responseHonorRetryAfterHeader),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    response_retry_settings: {
      value: cdktf.listMapperHcl(destinationOutputCrowdstrikeNextGenSiemResponseRetrySettingsToHclTerraform, false)(struct!.responseRetrySettings),
      isBlock: true,
      type: "list",
      storageClassType: "DestinationOutputCrowdstrikeNextGenSiemResponseRetrySettingsList",
    },
    safe_headers: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.safeHeaders),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    system_fields: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.systemFields),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    text_secret: {
      value: cdktf.stringToHclTerraform(struct!.textSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    timeout_retry_settings: {
      value: destinationOutputCrowdstrikeNextGenSiemTimeoutRetrySettingsToHclTerraform(struct!.timeoutRetrySettings),
      isBlock: true,
      type: "struct",
      storageClassType: "DestinationOutputCrowdstrikeNextGenSiemTimeoutRetrySettings",
    },
    timeout_sec: {
      value: cdktf.numberToHclTerraform(struct!.timeoutSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    token: {
      value: cdktf.stringToHclTerraform(struct!.token),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    url: {
      value: cdktf.stringToHclTerraform(struct!.url),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    use_round_robin_dns: {
      value: cdktf.booleanToHclTerraform(struct!.useRoundRobinDns),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputCrowdstrikeNextGenSiemOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DestinationOutputCrowdstrikeNextGenSiem | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._authType !== undefined) {
      hasAnyValues = true;
      internalValueResult.authType = this._authType;
    }
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._concurrency !== undefined) {
      hasAnyValues = true;
      internalValueResult.concurrency = this._concurrency;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._extraHttpHeaders?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.extraHttpHeaders = this._extraHttpHeaders?.internalValue;
    }
    if (this._failedRequestLoggingMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.failedRequestLoggingMode = this._failedRequestLoggingMode;
    }
    if (this._flushPeriodSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.flushPeriodSec = this._flushPeriodSec;
    }
    if (this._format !== undefined) {
      hasAnyValues = true;
      internalValueResult.format = this._format;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._maxPayloadEvents !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxPayloadEvents = this._maxPayloadEvents;
    }
    if (this._maxPayloadSizeKb !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxPayloadSizeKb = this._maxPayloadSizeKb;
    }
    if (this._onBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.onBackpressure = this._onBackpressure;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._pqCompress !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqCompress = this._pqCompress;
    }
    if (this._pqControls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqControls = this._pqControls?.internalValue;
    }
    if (this._pqMaxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxFileSize = this._pqMaxFileSize;
    }
    if (this._pqMaxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxSize = this._pqMaxSize;
    }
    if (this._pqMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMode = this._pqMode;
    }
    if (this._pqOnBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqOnBackpressure = this._pqOnBackpressure;
    }
    if (this._pqPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqPath = this._pqPath;
    }
    if (this._rejectUnauthorized !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectUnauthorized = this._rejectUnauthorized;
    }
    if (this._responseHonorRetryAfterHeader !== undefined) {
      hasAnyValues = true;
      internalValueResult.responseHonorRetryAfterHeader = this._responseHonorRetryAfterHeader;
    }
    if (this._responseRetrySettings?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.responseRetrySettings = this._responseRetrySettings?.internalValue;
    }
    if (this._safeHeaders !== undefined) {
      hasAnyValues = true;
      internalValueResult.safeHeaders = this._safeHeaders;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._systemFields !== undefined) {
      hasAnyValues = true;
      internalValueResult.systemFields = this._systemFields;
    }
    if (this._textSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.textSecret = this._textSecret;
    }
    if (this._timeoutRetrySettings?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutRetrySettings = this._timeoutRetrySettings?.internalValue;
    }
    if (this._timeoutSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutSec = this._timeoutSec;
    }
    if (this._token !== undefined) {
      hasAnyValues = true;
      internalValueResult.token = this._token;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._url !== undefined) {
      hasAnyValues = true;
      internalValueResult.url = this._url;
    }
    if (this._useRoundRobinDns !== undefined) {
      hasAnyValues = true;
      internalValueResult.useRoundRobinDns = this._useRoundRobinDns;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputCrowdstrikeNextGenSiem | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._authType = undefined;
      this._compress = undefined;
      this._concurrency = undefined;
      this._description = undefined;
      this._environment = undefined;
      this._extraHttpHeaders.internalValue = undefined;
      this._failedRequestLoggingMode = undefined;
      this._flushPeriodSec = undefined;
      this._format = undefined;
      this._id = undefined;
      this._maxPayloadEvents = undefined;
      this._maxPayloadSizeKb = undefined;
      this._onBackpressure = undefined;
      this._pipeline = undefined;
      this._pqCompress = undefined;
      this._pqControls.internalValue = undefined;
      this._pqMaxFileSize = undefined;
      this._pqMaxSize = undefined;
      this._pqMode = undefined;
      this._pqOnBackpressure = undefined;
      this._pqPath = undefined;
      this._rejectUnauthorized = undefined;
      this._responseHonorRetryAfterHeader = undefined;
      this._responseRetrySettings.internalValue = undefined;
      this._safeHeaders = undefined;
      this._streamtags = undefined;
      this._systemFields = undefined;
      this._textSecret = undefined;
      this._timeoutRetrySettings.internalValue = undefined;
      this._timeoutSec = undefined;
      this._token = undefined;
      this._type = undefined;
      this._url = undefined;
      this._useRoundRobinDns = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._authType = value.authType;
      this._compress = value.compress;
      this._concurrency = value.concurrency;
      this._description = value.description;
      this._environment = value.environment;
      this._extraHttpHeaders.internalValue = value.extraHttpHeaders;
      this._failedRequestLoggingMode = value.failedRequestLoggingMode;
      this._flushPeriodSec = value.flushPeriodSec;
      this._format = value.format;
      this._id = value.id;
      this._maxPayloadEvents = value.maxPayloadEvents;
      this._maxPayloadSizeKb = value.maxPayloadSizeKb;
      this._onBackpressure = value.onBackpressure;
      this._pipeline = value.pipeline;
      this._pqCompress = value.pqCompress;
      this._pqControls.internalValue = value.pqControls;
      this._pqMaxFileSize = value.pqMaxFileSize;
      this._pqMaxSize = value.pqMaxSize;
      this._pqMode = value.pqMode;
      this._pqOnBackpressure = value.pqOnBackpressure;
      this._pqPath = value.pqPath;
      this._rejectUnauthorized = value.rejectUnauthorized;
      this._responseHonorRetryAfterHeader = value.responseHonorRetryAfterHeader;
      this._responseRetrySettings.internalValue = value.responseRetrySettings;
      this._safeHeaders = value.safeHeaders;
      this._streamtags = value.streamtags;
      this._systemFields = value.systemFields;
      this._textSecret = value.textSecret;
      this._timeoutRetrySettings.internalValue = value.timeoutRetrySettings;
      this._timeoutSec = value.timeoutSec;
      this._token = value.token;
      this._type = value.type;
      this._url = value.url;
      this._useRoundRobinDns = value.useRoundRobinDns;
    }
  }

  // auth_type - computed: true, optional: true, required: false
  private _authType?: string; 
  public get authType() {
    return this.getStringAttribute('auth_type');
  }
  public set authType(value: string) {
    this._authType = value;
  }
  public resetAuthType() {
    this._authType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authTypeInput() {
    return this._authType;
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: boolean | cdktf.IResolvable; 
  public get compress() {
    return this.getBooleanAttribute('compress');
  }
  public set compress(value: boolean | cdktf.IResolvable) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // concurrency - computed: true, optional: true, required: false
  private _concurrency?: number; 
  public get concurrency() {
    return this.getNumberAttribute('concurrency');
  }
  public set concurrency(value: number) {
    this._concurrency = value;
  }
  public resetConcurrency() {
    this._concurrency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get concurrencyInput() {
    return this._concurrency;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // extra_http_headers - computed: false, optional: true, required: false
  private _extraHttpHeaders = new DestinationOutputCrowdstrikeNextGenSiemExtraHttpHeadersList(this, "extra_http_headers", false);
  public get extraHttpHeaders() {
    return this._extraHttpHeaders;
  }
  public putExtraHttpHeaders(value: DestinationOutputCrowdstrikeNextGenSiemExtraHttpHeaders[] | cdktf.IResolvable) {
    this._extraHttpHeaders.internalValue = value;
  }
  public resetExtraHttpHeaders() {
    this._extraHttpHeaders.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get extraHttpHeadersInput() {
    return this._extraHttpHeaders.internalValue;
  }

  // failed_request_logging_mode - computed: true, optional: true, required: false
  private _failedRequestLoggingMode?: string; 
  public get failedRequestLoggingMode() {
    return this.getStringAttribute('failed_request_logging_mode');
  }
  public set failedRequestLoggingMode(value: string) {
    this._failedRequestLoggingMode = value;
  }
  public resetFailedRequestLoggingMode() {
    this._failedRequestLoggingMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get failedRequestLoggingModeInput() {
    return this._failedRequestLoggingMode;
  }

  // flush_period_sec - computed: true, optional: true, required: false
  private _flushPeriodSec?: number; 
  public get flushPeriodSec() {
    return this.getNumberAttribute('flush_period_sec');
  }
  public set flushPeriodSec(value: number) {
    this._flushPeriodSec = value;
  }
  public resetFlushPeriodSec() {
    this._flushPeriodSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get flushPeriodSecInput() {
    return this._flushPeriodSec;
  }

  // format - computed: true, optional: true, required: false
  private _format?: string; 
  public get format() {
    return this.getStringAttribute('format');
  }
  public set format(value: string) {
    this._format = value;
  }
  public resetFormat() {
    this._format = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get formatInput() {
    return this._format;
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // max_payload_events - computed: true, optional: true, required: false
  private _maxPayloadEvents?: number; 
  public get maxPayloadEvents() {
    return this.getNumberAttribute('max_payload_events');
  }
  public set maxPayloadEvents(value: number) {
    this._maxPayloadEvents = value;
  }
  public resetMaxPayloadEvents() {
    this._maxPayloadEvents = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxPayloadEventsInput() {
    return this._maxPayloadEvents;
  }

  // max_payload_size_kb - computed: true, optional: true, required: false
  private _maxPayloadSizeKb?: number; 
  public get maxPayloadSizeKb() {
    return this.getNumberAttribute('max_payload_size_kb');
  }
  public set maxPayloadSizeKb(value: number) {
    this._maxPayloadSizeKb = value;
  }
  public resetMaxPayloadSizeKb() {
    this._maxPayloadSizeKb = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxPayloadSizeKbInput() {
    return this._maxPayloadSizeKb;
  }

  // on_backpressure - computed: true, optional: true, required: false
  private _onBackpressure?: string; 
  public get onBackpressure() {
    return this.getStringAttribute('on_backpressure');
  }
  public set onBackpressure(value: string) {
    this._onBackpressure = value;
  }
  public resetOnBackpressure() {
    this._onBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get onBackpressureInput() {
    return this._onBackpressure;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // pq_compress - computed: true, optional: true, required: false
  private _pqCompress?: string; 
  public get pqCompress() {
    return this.getStringAttribute('pq_compress');
  }
  public set pqCompress(value: string) {
    this._pqCompress = value;
  }
  public resetPqCompress() {
    this._pqCompress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqCompressInput() {
    return this._pqCompress;
  }

  // pq_controls - computed: false, optional: true, required: false
  private _pqControls = new DestinationOutputCrowdstrikeNextGenSiemPqControlsOutputReference(this, "pq_controls");
  public get pqControls() {
    return this._pqControls;
  }
  public putPqControls(value: DestinationOutputCrowdstrikeNextGenSiemPqControls) {
    this._pqControls.internalValue = value;
  }
  public resetPqControls() {
    this._pqControls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqControlsInput() {
    return this._pqControls.internalValue;
  }

  // pq_max_file_size - computed: true, optional: true, required: false
  private _pqMaxFileSize?: string; 
  public get pqMaxFileSize() {
    return this.getStringAttribute('pq_max_file_size');
  }
  public set pqMaxFileSize(value: string) {
    this._pqMaxFileSize = value;
  }
  public resetPqMaxFileSize() {
    this._pqMaxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxFileSizeInput() {
    return this._pqMaxFileSize;
  }

  // pq_max_size - computed: true, optional: true, required: false
  private _pqMaxSize?: string; 
  public get pqMaxSize() {
    return this.getStringAttribute('pq_max_size');
  }
  public set pqMaxSize(value: string) {
    this._pqMaxSize = value;
  }
  public resetPqMaxSize() {
    this._pqMaxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxSizeInput() {
    return this._pqMaxSize;
  }

  // pq_mode - computed: true, optional: true, required: false
  private _pqMode?: string; 
  public get pqMode() {
    return this.getStringAttribute('pq_mode');
  }
  public set pqMode(value: string) {
    this._pqMode = value;
  }
  public resetPqMode() {
    this._pqMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqModeInput() {
    return this._pqMode;
  }

  // pq_on_backpressure - computed: true, optional: true, required: false
  private _pqOnBackpressure?: string; 
  public get pqOnBackpressure() {
    return this.getStringAttribute('pq_on_backpressure');
  }
  public set pqOnBackpressure(value: string) {
    this._pqOnBackpressure = value;
  }
  public resetPqOnBackpressure() {
    this._pqOnBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqOnBackpressureInput() {
    return this._pqOnBackpressure;
  }

  // pq_path - computed: true, optional: true, required: false
  private _pqPath?: string; 
  public get pqPath() {
    return this.getStringAttribute('pq_path');
  }
  public set pqPath(value: string) {
    this._pqPath = value;
  }
  public resetPqPath() {
    this._pqPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqPathInput() {
    return this._pqPath;
  }

  // reject_unauthorized - computed: true, optional: true, required: false
  private _rejectUnauthorized?: boolean | cdktf.IResolvable; 
  public get rejectUnauthorized() {
    return this.getBooleanAttribute('reject_unauthorized');
  }
  public set rejectUnauthorized(value: boolean | cdktf.IResolvable) {
    this._rejectUnauthorized = value;
  }
  public resetRejectUnauthorized() {
    this._rejectUnauthorized = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectUnauthorizedInput() {
    return this._rejectUnauthorized;
  }

  // response_honor_retry_after_header - computed: true, optional: true, required: false
  private _responseHonorRetryAfterHeader?: boolean | cdktf.IResolvable; 
  public get responseHonorRetryAfterHeader() {
    return this.getBooleanAttribute('response_honor_retry_after_header');
  }
  public set responseHonorRetryAfterHeader(value: boolean | cdktf.IResolvable) {
    this._responseHonorRetryAfterHeader = value;
  }
  public resetResponseHonorRetryAfterHeader() {
    this._responseHonorRetryAfterHeader = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get responseHonorRetryAfterHeaderInput() {
    return this._responseHonorRetryAfterHeader;
  }

  // response_retry_settings - computed: false, optional: true, required: false
  private _responseRetrySettings = new DestinationOutputCrowdstrikeNextGenSiemResponseRetrySettingsList(this, "response_retry_settings", false);
  public get responseRetrySettings() {
    return this._responseRetrySettings;
  }
  public putResponseRetrySettings(value: DestinationOutputCrowdstrikeNextGenSiemResponseRetrySettings[] | cdktf.IResolvable) {
    this._responseRetrySettings.internalValue = value;
  }
  public resetResponseRetrySettings() {
    this._responseRetrySettings.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get responseRetrySettingsInput() {
    return this._responseRetrySettings.internalValue;
  }

  // safe_headers - computed: true, optional: true, required: false
  private _safeHeaders?: string[]; 
  public get safeHeaders() {
    return this.getListAttribute('safe_headers');
  }
  public set safeHeaders(value: string[]) {
    this._safeHeaders = value;
  }
  public resetSafeHeaders() {
    this._safeHeaders = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get safeHeadersInput() {
    return this._safeHeaders;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // system_fields - computed: true, optional: true, required: false
  private _systemFields?: string[]; 
  public get systemFields() {
    return this.getListAttribute('system_fields');
  }
  public set systemFields(value: string[]) {
    this._systemFields = value;
  }
  public resetSystemFields() {
    this._systemFields = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get systemFieldsInput() {
    return this._systemFields;
  }

  // text_secret - computed: false, optional: true, required: false
  private _textSecret?: string; 
  public get textSecret() {
    return this.getStringAttribute('text_secret');
  }
  public set textSecret(value: string) {
    this._textSecret = value;
  }
  public resetTextSecret() {
    this._textSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get textSecretInput() {
    return this._textSecret;
  }

  // timeout_retry_settings - computed: false, optional: true, required: false
  private _timeoutRetrySettings = new DestinationOutputCrowdstrikeNextGenSiemTimeoutRetrySettingsOutputReference(this, "timeout_retry_settings");
  public get timeoutRetrySettings() {
    return this._timeoutRetrySettings;
  }
  public putTimeoutRetrySettings(value: DestinationOutputCrowdstrikeNextGenSiemTimeoutRetrySettings) {
    this._timeoutRetrySettings.internalValue = value;
  }
  public resetTimeoutRetrySettings() {
    this._timeoutRetrySettings.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutRetrySettingsInput() {
    return this._timeoutRetrySettings.internalValue;
  }

  // timeout_sec - computed: true, optional: true, required: false
  private _timeoutSec?: number; 
  public get timeoutSec() {
    return this.getNumberAttribute('timeout_sec');
  }
  public set timeoutSec(value: number) {
    this._timeoutSec = value;
  }
  public resetTimeoutSec() {
    this._timeoutSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutSecInput() {
    return this._timeoutSec;
  }

  // token - computed: false, optional: true, required: false
  private _token?: string; 
  public get token() {
    return this.getStringAttribute('token');
  }
  public set token(value: string) {
    this._token = value;
  }
  public resetToken() {
    this._token = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tokenInput() {
    return this._token;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // url - computed: false, optional: false, required: true
  private _url?: string; 
  public get url() {
    return this.getStringAttribute('url');
  }
  public set url(value: string) {
    this._url = value;
  }
  // Temporarily expose input value. Use with caution.
  public get urlInput() {
    return this._url;
  }

  // use_round_robin_dns - computed: true, optional: true, required: false
  private _useRoundRobinDns?: boolean | cdktf.IResolvable; 
  public get useRoundRobinDns() {
    return this.getBooleanAttribute('use_round_robin_dns');
  }
  public set useRoundRobinDns(value: boolean | cdktf.IResolvable) {
    this._useRoundRobinDns = value;
  }
  public resetUseRoundRobinDns() {
    this._useRoundRobinDns = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get useRoundRobinDnsInput() {
    return this._useRoundRobinDns;
  }
}
export interface DestinationOutputDatadogExtraHttpHeaders {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#name Destination#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#value Destination#value}
  */
  readonly value: string;
}

export function destinationOutputDatadogExtraHttpHeadersToTerraform(struct?: DestinationOutputDatadogExtraHttpHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function destinationOutputDatadogExtraHttpHeadersToHclTerraform(struct?: DestinationOutputDatadogExtraHttpHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputDatadogExtraHttpHeadersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DestinationOutputDatadogExtraHttpHeaders | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputDatadogExtraHttpHeaders | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DestinationOutputDatadogExtraHttpHeadersList extends cdktf.ComplexList {
  public internalValue? : DestinationOutputDatadogExtraHttpHeaders[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DestinationOutputDatadogExtraHttpHeadersOutputReference {
    return new DestinationOutputDatadogExtraHttpHeadersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DestinationOutputDatadogPqControls {
}

export function destinationOutputDatadogPqControlsToTerraform(struct?: DestinationOutputDatadogPqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function destinationOutputDatadogPqControlsToHclTerraform(struct?: DestinationOutputDatadogPqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class DestinationOutputDatadogPqControlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DestinationOutputDatadogPqControls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputDatadogPqControls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface DestinationOutputDatadogResponseRetrySettings {
  /**
  * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc. Default: 2
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#backoff_rate Destination#backoff_rate}
  */
  readonly backoffRate?: number;
  /**
  * The HTTP response status code that will trigger retries
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#http_status Destination#http_status}
  */
  readonly httpStatus: number;
  /**
  * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes). Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#initial_backoff Destination#initial_backoff}
  */
  readonly initialBackoff?: number;
  /**
  * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds). Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#max_backoff Destination#max_backoff}
  */
  readonly maxBackoff?: number;
}

export function destinationOutputDatadogResponseRetrySettingsToTerraform(struct?: DestinationOutputDatadogResponseRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    backoff_rate: cdktf.numberToTerraform(struct!.backoffRate),
    http_status: cdktf.numberToTerraform(struct!.httpStatus),
    initial_backoff: cdktf.numberToTerraform(struct!.initialBackoff),
    max_backoff: cdktf.numberToTerraform(struct!.maxBackoff),
  }
}


export function destinationOutputDatadogResponseRetrySettingsToHclTerraform(struct?: DestinationOutputDatadogResponseRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    backoff_rate: {
      value: cdktf.numberToHclTerraform(struct!.backoffRate),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    http_status: {
      value: cdktf.numberToHclTerraform(struct!.httpStatus),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    initial_backoff: {
      value: cdktf.numberToHclTerraform(struct!.initialBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_backoff: {
      value: cdktf.numberToHclTerraform(struct!.maxBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputDatadogResponseRetrySettingsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DestinationOutputDatadogResponseRetrySettings | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._backoffRate !== undefined) {
      hasAnyValues = true;
      internalValueResult.backoffRate = this._backoffRate;
    }
    if (this._httpStatus !== undefined) {
      hasAnyValues = true;
      internalValueResult.httpStatus = this._httpStatus;
    }
    if (this._initialBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.initialBackoff = this._initialBackoff;
    }
    if (this._maxBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBackoff = this._maxBackoff;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputDatadogResponseRetrySettings | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._backoffRate = undefined;
      this._httpStatus = undefined;
      this._initialBackoff = undefined;
      this._maxBackoff = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._backoffRate = value.backoffRate;
      this._httpStatus = value.httpStatus;
      this._initialBackoff = value.initialBackoff;
      this._maxBackoff = value.maxBackoff;
    }
  }

  // backoff_rate - computed: true, optional: true, required: false
  private _backoffRate?: number; 
  public get backoffRate() {
    return this.getNumberAttribute('backoff_rate');
  }
  public set backoffRate(value: number) {
    this._backoffRate = value;
  }
  public resetBackoffRate() {
    this._backoffRate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get backoffRateInput() {
    return this._backoffRate;
  }

  // http_status - computed: false, optional: false, required: true
  private _httpStatus?: number; 
  public get httpStatus() {
    return this.getNumberAttribute('http_status');
  }
  public set httpStatus(value: number) {
    this._httpStatus = value;
  }
  // Temporarily expose input value. Use with caution.
  public get httpStatusInput() {
    return this._httpStatus;
  }

  // initial_backoff - computed: true, optional: true, required: false
  private _initialBackoff?: number; 
  public get initialBackoff() {
    return this.getNumberAttribute('initial_backoff');
  }
  public set initialBackoff(value: number) {
    this._initialBackoff = value;
  }
  public resetInitialBackoff() {
    this._initialBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get initialBackoffInput() {
    return this._initialBackoff;
  }

  // max_backoff - computed: true, optional: true, required: false
  private _maxBackoff?: number; 
  public get maxBackoff() {
    return this.getNumberAttribute('max_backoff');
  }
  public set maxBackoff(value: number) {
    this._maxBackoff = value;
  }
  public resetMaxBackoff() {
    this._maxBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBackoffInput() {
    return this._maxBackoff;
  }
}

export class DestinationOutputDatadogResponseRetrySettingsList extends cdktf.ComplexList {
  public internalValue? : DestinationOutputDatadogResponseRetrySettings[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DestinationOutputDatadogResponseRetrySettingsOutputReference {
    return new DestinationOutputDatadogResponseRetrySettingsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DestinationOutputDatadogTimeoutRetrySettings {
  /**
  * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc. Default: 2
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#backoff_rate Destination#backoff_rate}
  */
  readonly backoffRate?: number;
  /**
  * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes). Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#initial_backoff Destination#initial_backoff}
  */
  readonly initialBackoff?: number;
  /**
  * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds). Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#max_backoff Destination#max_backoff}
  */
  readonly maxBackoff?: number;
  /**
  * Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#timeout_retry Destination#timeout_retry}
  */
  readonly timeoutRetry?: boolean | cdktf.IResolvable;
}

export function destinationOutputDatadogTimeoutRetrySettingsToTerraform(struct?: DestinationOutputDatadogTimeoutRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    backoff_rate: cdktf.numberToTerraform(struct!.backoffRate),
    initial_backoff: cdktf.numberToTerraform(struct!.initialBackoff),
    max_backoff: cdktf.numberToTerraform(struct!.maxBackoff),
    timeout_retry: cdktf.booleanToTerraform(struct!.timeoutRetry),
  }
}


export function destinationOutputDatadogTimeoutRetrySettingsToHclTerraform(struct?: DestinationOutputDatadogTimeoutRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    backoff_rate: {
      value: cdktf.numberToHclTerraform(struct!.backoffRate),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    initial_backoff: {
      value: cdktf.numberToHclTerraform(struct!.initialBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_backoff: {
      value: cdktf.numberToHclTerraform(struct!.maxBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    timeout_retry: {
      value: cdktf.booleanToHclTerraform(struct!.timeoutRetry),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputDatadogTimeoutRetrySettingsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DestinationOutputDatadogTimeoutRetrySettings | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._backoffRate !== undefined) {
      hasAnyValues = true;
      internalValueResult.backoffRate = this._backoffRate;
    }
    if (this._initialBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.initialBackoff = this._initialBackoff;
    }
    if (this._maxBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBackoff = this._maxBackoff;
    }
    if (this._timeoutRetry !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutRetry = this._timeoutRetry;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputDatadogTimeoutRetrySettings | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._backoffRate = undefined;
      this._initialBackoff = undefined;
      this._maxBackoff = undefined;
      this._timeoutRetry = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._backoffRate = value.backoffRate;
      this._initialBackoff = value.initialBackoff;
      this._maxBackoff = value.maxBackoff;
      this._timeoutRetry = value.timeoutRetry;
    }
  }

  // backoff_rate - computed: true, optional: true, required: false
  private _backoffRate?: number; 
  public get backoffRate() {
    return this.getNumberAttribute('backoff_rate');
  }
  public set backoffRate(value: number) {
    this._backoffRate = value;
  }
  public resetBackoffRate() {
    this._backoffRate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get backoffRateInput() {
    return this._backoffRate;
  }

  // initial_backoff - computed: true, optional: true, required: false
  private _initialBackoff?: number; 
  public get initialBackoff() {
    return this.getNumberAttribute('initial_backoff');
  }
  public set initialBackoff(value: number) {
    this._initialBackoff = value;
  }
  public resetInitialBackoff() {
    this._initialBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get initialBackoffInput() {
    return this._initialBackoff;
  }

  // max_backoff - computed: true, optional: true, required: false
  private _maxBackoff?: number; 
  public get maxBackoff() {
    return this.getNumberAttribute('max_backoff');
  }
  public set maxBackoff(value: number) {
    this._maxBackoff = value;
  }
  public resetMaxBackoff() {
    this._maxBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBackoffInput() {
    return this._maxBackoff;
  }

  // timeout_retry - computed: true, optional: true, required: false
  private _timeoutRetry?: boolean | cdktf.IResolvable; 
  public get timeoutRetry() {
    return this.getBooleanAttribute('timeout_retry');
  }
  public set timeoutRetry(value: boolean | cdktf.IResolvable) {
    this._timeoutRetry = value;
  }
  public resetTimeoutRetry() {
    this._timeoutRetry = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutRetryInput() {
    return this._timeoutRetry;
  }
}
export interface DestinationOutputDatadog {
  /**
  * Allow API key to be set from the event's '__agent_api_key' field. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#allow_api_key_from_events Destination#allow_api_key_from_events}
  */
  readonly allowApiKeyFromEvents?: boolean | cdktf.IResolvable;
  /**
  * Organization's API key in Datadog
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#api_key Destination#api_key}
  */
  readonly apiKey?: string;
  /**
  * Enter API key directly, or select a stored secret. Default: "manual"; must be one of ["manual", "secret"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#auth_type Destination#auth_type}
  */
  readonly authType?: string;
  /**
  * Batch events by API key and the ddtags field on the event. When disabled, batches events only by API key. If incoming events have high cardinality in the ddtags field, disabling this setting may improve Destination performance. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#batch_by_tags Destination#batch_by_tags}
  */
  readonly batchByTags?: boolean | cdktf.IResolvable;
  /**
  * Compress the payload body before sending. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#compress Destination#compress}
  */
  readonly compress?: boolean | cdktf.IResolvable;
  /**
  * Maximum number of ongoing requests before blocking. Default: 5
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#concurrency Destination#concurrency}
  */
  readonly concurrency?: number;
  /**
  * The content type to use when sending logs. Default: "json"; must be one of ["text", "json"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#content_type Destination#content_type}
  */
  readonly contentType?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#custom_url Destination#custom_url}
  */
  readonly customUrl?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#description Destination#description}
  */
  readonly description?: string;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#environment Destination#environment}
  */
  readonly environment?: string;
  /**
  * Headers to add to all events
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#extra_http_headers Destination#extra_http_headers}
  */
  readonly extraHttpHeaders?: DestinationOutputDatadogExtraHttpHeaders[] | cdktf.IResolvable;
  /**
  * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below. Default: "none"; must be one of ["payload", "payloadAndHeaders", "none"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#failed_request_logging_mode Destination#failed_request_logging_mode}
  */
  readonly failedRequestLoggingMode?: string;
  /**
  * Maximum time between requests. Small values could cause the payload size to be smaller than the configured Body size limit. Default: 1
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#flush_period_sec Destination#flush_period_sec}
  */
  readonly flushPeriodSec?: number;
  /**
  * Name of the host to send with logs. When you send logs as JSON objects, the event's 'host' field (if set) will override this value.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#host Destination#host}
  */
  readonly host?: string;
  /**
  * Unique ID for this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#id Destination#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id: string;
  /**
  * Maximum number of events to include in the request body. Default is 0 (unlimited). Default: 0
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#max_payload_events Destination#max_payload_events}
  */
  readonly maxPayloadEvents?: number;
  /**
  * Maximum size, in KB, of the request body. Default: 4096
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#max_payload_size_kb Destination#max_payload_size_kb}
  */
  readonly maxPayloadSizeKb?: number;
  /**
  * Name of the event field that contains the message to send. If not specified, Stream sends a JSON representation of the whole event.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#message Destination#message}
  */
  readonly message?: string;
  /**
  * How to handle events when all receivers are exerting backpressure. Default: "block"; must be one of ["block", "drop", "queue"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#on_backpressure Destination#on_backpressure}
  */
  readonly onBackpressure?: string;
  /**
  * Pipeline to process data before sending out to this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pipeline Destination#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pq_compress Destination#pq_compress}
  */
  readonly pqCompress?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pq_controls Destination#pq_controls}
  */
  readonly pqControls?: DestinationOutputDatadogPqControls;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.). Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pq_max_file_size Destination#pq_max_file_size}
  */
  readonly pqMaxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pq_max_size Destination#pq_max_size}
  */
  readonly pqMaxSize?: string;
  /**
  * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem. Default: "error"; must be one of ["error", "backpressure", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pq_mode Destination#pq_mode}
  */
  readonly pqMode?: string;
  /**
  * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged. Default: "block"; must be one of ["block", "drop"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pq_on_backpressure Destination#pq_on_backpressure}
  */
  readonly pqOnBackpressure?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pq_path Destination#pq_path}
  */
  readonly pqPath?: string;
  /**
  * Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's). 
  *         Enabled by default. When this setting is also present in TLS Settings (Client Side), 
  *         that value will take precedence.
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#reject_unauthorized Destination#reject_unauthorized}
  */
  readonly rejectUnauthorized?: boolean | cdktf.IResolvable;
  /**
  * Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#response_honor_retry_after_header Destination#response_honor_retry_after_header}
  */
  readonly responseHonorRetryAfterHeader?: boolean | cdktf.IResolvable;
  /**
  * Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#response_retry_settings Destination#response_retry_settings}
  */
  readonly responseRetrySettings?: DestinationOutputDatadogResponseRetrySettings[] | cdktf.IResolvable;
  /**
  * List of headers that are safe to log in plain text. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#safe_headers Destination#safe_headers}
  */
  readonly safeHeaders?: string[];
  /**
  * If not enabled, Datadog will transform 'counter' metrics to 'gauge'. [Learn more about Datadog metrics types.](https://docs.datadoghq.com/metrics/types/?tab=count). Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#send_counters_as_count Destination#send_counters_as_count}
  */
  readonly sendCountersAsCount?: boolean | cdktf.IResolvable;
  /**
  * Name of the service to send with logs. When you send logs as JSON objects, the event's '__service' field (if set) will override this value.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#service Destination#service}
  */
  readonly service?: string;
  /**
  * Default value for message severity. When you send logs as JSON objects, the event's '__severity' field (if set) will override this value. must be one of ["emergency", "alert", "critical", "error", "warning", "notice", "info", "debug"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#severity Destination#severity}
  */
  readonly severity?: string;
  /**
  * Datadog site to which events should be sent. Default: "us"; must be one of ["us", "us3", "us5", "eu", "fed1", "ap1", "custom"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#site Destination#site}
  */
  readonly site?: string;
  /**
  * Name of the source to send with logs. When you send logs as JSON objects, the event's 'source' field (if set) will override this value.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#source Destination#source}
  */
  readonly source?: string;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#streamtags Destination#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Fields to automatically add to events, such as cribl_pipe. Supports wildcards. Default: ["cribl_pipe"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#system_fields Destination#system_fields}
  */
  readonly systemFields?: string[];
  /**
  * List of tags to send with logs, such as 'env:prod' and 'env_staging:east'. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#tags Destination#tags}
  */
  readonly tags?: string[];
  /**
  * Select or create a stored text secret
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#text_secret Destination#text_secret}
  */
  readonly textSecret?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#timeout_retry_settings Destination#timeout_retry_settings}
  */
  readonly timeoutRetrySettings?: DestinationOutputDatadogTimeoutRetrySettings;
  /**
  * Amount of time, in seconds, to wait for a request to complete before canceling it. Default: 30
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#timeout_sec Destination#timeout_sec}
  */
  readonly timeoutSec?: number;
  /**
  * Maximum total size of the batches waiting to be sent. If left blank, defaults to 5 times the max body size (if set). If 0, no limit is enforced.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#total_memory_limit_kb Destination#total_memory_limit_kb}
  */
  readonly totalMemoryLimitKb?: number;
  /**
  * must be "datadog"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#type Destination#type}
  */
  readonly type: string;
  /**
  * Enable round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. For optimal performance, consider enabling this setting for non-load balanced destinations. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#use_round_robin_dns Destination#use_round_robin_dns}
  */
  readonly useRoundRobinDns?: boolean | cdktf.IResolvable;
}

export function destinationOutputDatadogToTerraform(struct?: DestinationOutputDatadog | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    allow_api_key_from_events: cdktf.booleanToTerraform(struct!.allowApiKeyFromEvents),
    api_key: cdktf.stringToTerraform(struct!.apiKey),
    auth_type: cdktf.stringToTerraform(struct!.authType),
    batch_by_tags: cdktf.booleanToTerraform(struct!.batchByTags),
    compress: cdktf.booleanToTerraform(struct!.compress),
    concurrency: cdktf.numberToTerraform(struct!.concurrency),
    content_type: cdktf.stringToTerraform(struct!.contentType),
    custom_url: cdktf.stringToTerraform(struct!.customUrl),
    description: cdktf.stringToTerraform(struct!.description),
    environment: cdktf.stringToTerraform(struct!.environment),
    extra_http_headers: cdktf.listMapper(destinationOutputDatadogExtraHttpHeadersToTerraform, false)(struct!.extraHttpHeaders),
    failed_request_logging_mode: cdktf.stringToTerraform(struct!.failedRequestLoggingMode),
    flush_period_sec: cdktf.numberToTerraform(struct!.flushPeriodSec),
    host: cdktf.stringToTerraform(struct!.host),
    id: cdktf.stringToTerraform(struct!.id),
    max_payload_events: cdktf.numberToTerraform(struct!.maxPayloadEvents),
    max_payload_size_kb: cdktf.numberToTerraform(struct!.maxPayloadSizeKb),
    message: cdktf.stringToTerraform(struct!.message),
    on_backpressure: cdktf.stringToTerraform(struct!.onBackpressure),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    pq_compress: cdktf.stringToTerraform(struct!.pqCompress),
    pq_controls: destinationOutputDatadogPqControlsToTerraform(struct!.pqControls),
    pq_max_file_size: cdktf.stringToTerraform(struct!.pqMaxFileSize),
    pq_max_size: cdktf.stringToTerraform(struct!.pqMaxSize),
    pq_mode: cdktf.stringToTerraform(struct!.pqMode),
    pq_on_backpressure: cdktf.stringToTerraform(struct!.pqOnBackpressure),
    pq_path: cdktf.stringToTerraform(struct!.pqPath),
    reject_unauthorized: cdktf.booleanToTerraform(struct!.rejectUnauthorized),
    response_honor_retry_after_header: cdktf.booleanToTerraform(struct!.responseHonorRetryAfterHeader),
    response_retry_settings: cdktf.listMapper(destinationOutputDatadogResponseRetrySettingsToTerraform, false)(struct!.responseRetrySettings),
    safe_headers: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.safeHeaders),
    send_counters_as_count: cdktf.booleanToTerraform(struct!.sendCountersAsCount),
    service: cdktf.stringToTerraform(struct!.service),
    severity: cdktf.stringToTerraform(struct!.severity),
    site: cdktf.stringToTerraform(struct!.site),
    source: cdktf.stringToTerraform(struct!.source),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    system_fields: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.systemFields),
    tags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.tags),
    text_secret: cdktf.stringToTerraform(struct!.textSecret),
    timeout_retry_settings: destinationOutputDatadogTimeoutRetrySettingsToTerraform(struct!.timeoutRetrySettings),
    timeout_sec: cdktf.numberToTerraform(struct!.timeoutSec),
    total_memory_limit_kb: cdktf.numberToTerraform(struct!.totalMemoryLimitKb),
    type: cdktf.stringToTerraform(struct!.type),
    use_round_robin_dns: cdktf.booleanToTerraform(struct!.useRoundRobinDns),
  }
}


export function destinationOutputDatadogToHclTerraform(struct?: DestinationOutputDatadog | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    allow_api_key_from_events: {
      value: cdktf.booleanToHclTerraform(struct!.allowApiKeyFromEvents),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    api_key: {
      value: cdktf.stringToHclTerraform(struct!.apiKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    auth_type: {
      value: cdktf.stringToHclTerraform(struct!.authType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    batch_by_tags: {
      value: cdktf.booleanToHclTerraform(struct!.batchByTags),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    compress: {
      value: cdktf.booleanToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    concurrency: {
      value: cdktf.numberToHclTerraform(struct!.concurrency),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    content_type: {
      value: cdktf.stringToHclTerraform(struct!.contentType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    custom_url: {
      value: cdktf.stringToHclTerraform(struct!.customUrl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    extra_http_headers: {
      value: cdktf.listMapperHcl(destinationOutputDatadogExtraHttpHeadersToHclTerraform, false)(struct!.extraHttpHeaders),
      isBlock: true,
      type: "list",
      storageClassType: "DestinationOutputDatadogExtraHttpHeadersList",
    },
    failed_request_logging_mode: {
      value: cdktf.stringToHclTerraform(struct!.failedRequestLoggingMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    flush_period_sec: {
      value: cdktf.numberToHclTerraform(struct!.flushPeriodSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    host: {
      value: cdktf.stringToHclTerraform(struct!.host),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_payload_events: {
      value: cdktf.numberToHclTerraform(struct!.maxPayloadEvents),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_payload_size_kb: {
      value: cdktf.numberToHclTerraform(struct!.maxPayloadSizeKb),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    message: {
      value: cdktf.stringToHclTerraform(struct!.message),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.onBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_compress: {
      value: cdktf.stringToHclTerraform(struct!.pqCompress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_controls: {
      value: destinationOutputDatadogPqControlsToHclTerraform(struct!.pqControls),
      isBlock: true,
      type: "struct",
      storageClassType: "DestinationOutputDatadogPqControls",
    },
    pq_max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_max_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_mode: {
      value: cdktf.stringToHclTerraform(struct!.pqMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.pqOnBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_path: {
      value: cdktf.stringToHclTerraform(struct!.pqPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reject_unauthorized: {
      value: cdktf.booleanToHclTerraform(struct!.rejectUnauthorized),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    response_honor_retry_after_header: {
      value: cdktf.booleanToHclTerraform(struct!.responseHonorRetryAfterHeader),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    response_retry_settings: {
      value: cdktf.listMapperHcl(destinationOutputDatadogResponseRetrySettingsToHclTerraform, false)(struct!.responseRetrySettings),
      isBlock: true,
      type: "list",
      storageClassType: "DestinationOutputDatadogResponseRetrySettingsList",
    },
    safe_headers: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.safeHeaders),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    send_counters_as_count: {
      value: cdktf.booleanToHclTerraform(struct!.sendCountersAsCount),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    service: {
      value: cdktf.stringToHclTerraform(struct!.service),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    severity: {
      value: cdktf.stringToHclTerraform(struct!.severity),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    site: {
      value: cdktf.stringToHclTerraform(struct!.site),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    source: {
      value: cdktf.stringToHclTerraform(struct!.source),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    system_fields: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.systemFields),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    tags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.tags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    text_secret: {
      value: cdktf.stringToHclTerraform(struct!.textSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    timeout_retry_settings: {
      value: destinationOutputDatadogTimeoutRetrySettingsToHclTerraform(struct!.timeoutRetrySettings),
      isBlock: true,
      type: "struct",
      storageClassType: "DestinationOutputDatadogTimeoutRetrySettings",
    },
    timeout_sec: {
      value: cdktf.numberToHclTerraform(struct!.timeoutSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    total_memory_limit_kb: {
      value: cdktf.numberToHclTerraform(struct!.totalMemoryLimitKb),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    use_round_robin_dns: {
      value: cdktf.booleanToHclTerraform(struct!.useRoundRobinDns),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputDatadogOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DestinationOutputDatadog | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._allowApiKeyFromEvents !== undefined) {
      hasAnyValues = true;
      internalValueResult.allowApiKeyFromEvents = this._allowApiKeyFromEvents;
    }
    if (this._apiKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.apiKey = this._apiKey;
    }
    if (this._authType !== undefined) {
      hasAnyValues = true;
      internalValueResult.authType = this._authType;
    }
    if (this._batchByTags !== undefined) {
      hasAnyValues = true;
      internalValueResult.batchByTags = this._batchByTags;
    }
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._concurrency !== undefined) {
      hasAnyValues = true;
      internalValueResult.concurrency = this._concurrency;
    }
    if (this._contentType !== undefined) {
      hasAnyValues = true;
      internalValueResult.contentType = this._contentType;
    }
    if (this._customUrl !== undefined) {
      hasAnyValues = true;
      internalValueResult.customUrl = this._customUrl;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._extraHttpHeaders?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.extraHttpHeaders = this._extraHttpHeaders?.internalValue;
    }
    if (this._failedRequestLoggingMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.failedRequestLoggingMode = this._failedRequestLoggingMode;
    }
    if (this._flushPeriodSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.flushPeriodSec = this._flushPeriodSec;
    }
    if (this._host !== undefined) {
      hasAnyValues = true;
      internalValueResult.host = this._host;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._maxPayloadEvents !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxPayloadEvents = this._maxPayloadEvents;
    }
    if (this._maxPayloadSizeKb !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxPayloadSizeKb = this._maxPayloadSizeKb;
    }
    if (this._message !== undefined) {
      hasAnyValues = true;
      internalValueResult.message = this._message;
    }
    if (this._onBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.onBackpressure = this._onBackpressure;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._pqCompress !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqCompress = this._pqCompress;
    }
    if (this._pqControls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqControls = this._pqControls?.internalValue;
    }
    if (this._pqMaxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxFileSize = this._pqMaxFileSize;
    }
    if (this._pqMaxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxSize = this._pqMaxSize;
    }
    if (this._pqMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMode = this._pqMode;
    }
    if (this._pqOnBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqOnBackpressure = this._pqOnBackpressure;
    }
    if (this._pqPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqPath = this._pqPath;
    }
    if (this._rejectUnauthorized !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectUnauthorized = this._rejectUnauthorized;
    }
    if (this._responseHonorRetryAfterHeader !== undefined) {
      hasAnyValues = true;
      internalValueResult.responseHonorRetryAfterHeader = this._responseHonorRetryAfterHeader;
    }
    if (this._responseRetrySettings?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.responseRetrySettings = this._responseRetrySettings?.internalValue;
    }
    if (this._safeHeaders !== undefined) {
      hasAnyValues = true;
      internalValueResult.safeHeaders = this._safeHeaders;
    }
    if (this._sendCountersAsCount !== undefined) {
      hasAnyValues = true;
      internalValueResult.sendCountersAsCount = this._sendCountersAsCount;
    }
    if (this._service !== undefined) {
      hasAnyValues = true;
      internalValueResult.service = this._service;
    }
    if (this._severity !== undefined) {
      hasAnyValues = true;
      internalValueResult.severity = this._severity;
    }
    if (this._site !== undefined) {
      hasAnyValues = true;
      internalValueResult.site = this._site;
    }
    if (this._source !== undefined) {
      hasAnyValues = true;
      internalValueResult.source = this._source;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._systemFields !== undefined) {
      hasAnyValues = true;
      internalValueResult.systemFields = this._systemFields;
    }
    if (this._tags !== undefined) {
      hasAnyValues = true;
      internalValueResult.tags = this._tags;
    }
    if (this._textSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.textSecret = this._textSecret;
    }
    if (this._timeoutRetrySettings?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutRetrySettings = this._timeoutRetrySettings?.internalValue;
    }
    if (this._timeoutSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutSec = this._timeoutSec;
    }
    if (this._totalMemoryLimitKb !== undefined) {
      hasAnyValues = true;
      internalValueResult.totalMemoryLimitKb = this._totalMemoryLimitKb;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._useRoundRobinDns !== undefined) {
      hasAnyValues = true;
      internalValueResult.useRoundRobinDns = this._useRoundRobinDns;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputDatadog | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._allowApiKeyFromEvents = undefined;
      this._apiKey = undefined;
      this._authType = undefined;
      this._batchByTags = undefined;
      this._compress = undefined;
      this._concurrency = undefined;
      this._contentType = undefined;
      this._customUrl = undefined;
      this._description = undefined;
      this._environment = undefined;
      this._extraHttpHeaders.internalValue = undefined;
      this._failedRequestLoggingMode = undefined;
      this._flushPeriodSec = undefined;
      this._host = undefined;
      this._id = undefined;
      this._maxPayloadEvents = undefined;
      this._maxPayloadSizeKb = undefined;
      this._message = undefined;
      this._onBackpressure = undefined;
      this._pipeline = undefined;
      this._pqCompress = undefined;
      this._pqControls.internalValue = undefined;
      this._pqMaxFileSize = undefined;
      this._pqMaxSize = undefined;
      this._pqMode = undefined;
      this._pqOnBackpressure = undefined;
      this._pqPath = undefined;
      this._rejectUnauthorized = undefined;
      this._responseHonorRetryAfterHeader = undefined;
      this._responseRetrySettings.internalValue = undefined;
      this._safeHeaders = undefined;
      this._sendCountersAsCount = undefined;
      this._service = undefined;
      this._severity = undefined;
      this._site = undefined;
      this._source = undefined;
      this._streamtags = undefined;
      this._systemFields = undefined;
      this._tags = undefined;
      this._textSecret = undefined;
      this._timeoutRetrySettings.internalValue = undefined;
      this._timeoutSec = undefined;
      this._totalMemoryLimitKb = undefined;
      this._type = undefined;
      this._useRoundRobinDns = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._allowApiKeyFromEvents = value.allowApiKeyFromEvents;
      this._apiKey = value.apiKey;
      this._authType = value.authType;
      this._batchByTags = value.batchByTags;
      this._compress = value.compress;
      this._concurrency = value.concurrency;
      this._contentType = value.contentType;
      this._customUrl = value.customUrl;
      this._description = value.description;
      this._environment = value.environment;
      this._extraHttpHeaders.internalValue = value.extraHttpHeaders;
      this._failedRequestLoggingMode = value.failedRequestLoggingMode;
      this._flushPeriodSec = value.flushPeriodSec;
      this._host = value.host;
      this._id = value.id;
      this._maxPayloadEvents = value.maxPayloadEvents;
      this._maxPayloadSizeKb = value.maxPayloadSizeKb;
      this._message = value.message;
      this._onBackpressure = value.onBackpressure;
      this._pipeline = value.pipeline;
      this._pqCompress = value.pqCompress;
      this._pqControls.internalValue = value.pqControls;
      this._pqMaxFileSize = value.pqMaxFileSize;
      this._pqMaxSize = value.pqMaxSize;
      this._pqMode = value.pqMode;
      this._pqOnBackpressure = value.pqOnBackpressure;
      this._pqPath = value.pqPath;
      this._rejectUnauthorized = value.rejectUnauthorized;
      this._responseHonorRetryAfterHeader = value.responseHonorRetryAfterHeader;
      this._responseRetrySettings.internalValue = value.responseRetrySettings;
      this._safeHeaders = value.safeHeaders;
      this._sendCountersAsCount = value.sendCountersAsCount;
      this._service = value.service;
      this._severity = value.severity;
      this._site = value.site;
      this._source = value.source;
      this._streamtags = value.streamtags;
      this._systemFields = value.systemFields;
      this._tags = value.tags;
      this._textSecret = value.textSecret;
      this._timeoutRetrySettings.internalValue = value.timeoutRetrySettings;
      this._timeoutSec = value.timeoutSec;
      this._totalMemoryLimitKb = value.totalMemoryLimitKb;
      this._type = value.type;
      this._useRoundRobinDns = value.useRoundRobinDns;
    }
  }

  // allow_api_key_from_events - computed: true, optional: true, required: false
  private _allowApiKeyFromEvents?: boolean | cdktf.IResolvable; 
  public get allowApiKeyFromEvents() {
    return this.getBooleanAttribute('allow_api_key_from_events');
  }
  public set allowApiKeyFromEvents(value: boolean | cdktf.IResolvable) {
    this._allowApiKeyFromEvents = value;
  }
  public resetAllowApiKeyFromEvents() {
    this._allowApiKeyFromEvents = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get allowApiKeyFromEventsInput() {
    return this._allowApiKeyFromEvents;
  }

  // api_key - computed: false, optional: true, required: false
  private _apiKey?: string; 
  public get apiKey() {
    return this.getStringAttribute('api_key');
  }
  public set apiKey(value: string) {
    this._apiKey = value;
  }
  public resetApiKey() {
    this._apiKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get apiKeyInput() {
    return this._apiKey;
  }

  // auth_type - computed: true, optional: true, required: false
  private _authType?: string; 
  public get authType() {
    return this.getStringAttribute('auth_type');
  }
  public set authType(value: string) {
    this._authType = value;
  }
  public resetAuthType() {
    this._authType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authTypeInput() {
    return this._authType;
  }

  // batch_by_tags - computed: true, optional: true, required: false
  private _batchByTags?: boolean | cdktf.IResolvable; 
  public get batchByTags() {
    return this.getBooleanAttribute('batch_by_tags');
  }
  public set batchByTags(value: boolean | cdktf.IResolvable) {
    this._batchByTags = value;
  }
  public resetBatchByTags() {
    this._batchByTags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get batchByTagsInput() {
    return this._batchByTags;
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: boolean | cdktf.IResolvable; 
  public get compress() {
    return this.getBooleanAttribute('compress');
  }
  public set compress(value: boolean | cdktf.IResolvable) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // concurrency - computed: true, optional: true, required: false
  private _concurrency?: number; 
  public get concurrency() {
    return this.getNumberAttribute('concurrency');
  }
  public set concurrency(value: number) {
    this._concurrency = value;
  }
  public resetConcurrency() {
    this._concurrency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get concurrencyInput() {
    return this._concurrency;
  }

  // content_type - computed: true, optional: true, required: false
  private _contentType?: string; 
  public get contentType() {
    return this.getStringAttribute('content_type');
  }
  public set contentType(value: string) {
    this._contentType = value;
  }
  public resetContentType() {
    this._contentType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get contentTypeInput() {
    return this._contentType;
  }

  // custom_url - computed: false, optional: true, required: false
  private _customUrl?: string; 
  public get customUrl() {
    return this.getStringAttribute('custom_url');
  }
  public set customUrl(value: string) {
    this._customUrl = value;
  }
  public resetCustomUrl() {
    this._customUrl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get customUrlInput() {
    return this._customUrl;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // extra_http_headers - computed: false, optional: true, required: false
  private _extraHttpHeaders = new DestinationOutputDatadogExtraHttpHeadersList(this, "extra_http_headers", false);
  public get extraHttpHeaders() {
    return this._extraHttpHeaders;
  }
  public putExtraHttpHeaders(value: DestinationOutputDatadogExtraHttpHeaders[] | cdktf.IResolvable) {
    this._extraHttpHeaders.internalValue = value;
  }
  public resetExtraHttpHeaders() {
    this._extraHttpHeaders.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get extraHttpHeadersInput() {
    return this._extraHttpHeaders.internalValue;
  }

  // failed_request_logging_mode - computed: true, optional: true, required: false
  private _failedRequestLoggingMode?: string; 
  public get failedRequestLoggingMode() {
    return this.getStringAttribute('failed_request_logging_mode');
  }
  public set failedRequestLoggingMode(value: string) {
    this._failedRequestLoggingMode = value;
  }
  public resetFailedRequestLoggingMode() {
    this._failedRequestLoggingMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get failedRequestLoggingModeInput() {
    return this._failedRequestLoggingMode;
  }

  // flush_period_sec - computed: true, optional: true, required: false
  private _flushPeriodSec?: number; 
  public get flushPeriodSec() {
    return this.getNumberAttribute('flush_period_sec');
  }
  public set flushPeriodSec(value: number) {
    this._flushPeriodSec = value;
  }
  public resetFlushPeriodSec() {
    this._flushPeriodSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get flushPeriodSecInput() {
    return this._flushPeriodSec;
  }

  // host - computed: false, optional: true, required: false
  private _host?: string; 
  public get host() {
    return this.getStringAttribute('host');
  }
  public set host(value: string) {
    this._host = value;
  }
  public resetHost() {
    this._host = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostInput() {
    return this._host;
  }

  // id - computed: false, optional: false, required: true
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // max_payload_events - computed: true, optional: true, required: false
  private _maxPayloadEvents?: number; 
  public get maxPayloadEvents() {
    return this.getNumberAttribute('max_payload_events');
  }
  public set maxPayloadEvents(value: number) {
    this._maxPayloadEvents = value;
  }
  public resetMaxPayloadEvents() {
    this._maxPayloadEvents = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxPayloadEventsInput() {
    return this._maxPayloadEvents;
  }

  // max_payload_size_kb - computed: true, optional: true, required: false
  private _maxPayloadSizeKb?: number; 
  public get maxPayloadSizeKb() {
    return this.getNumberAttribute('max_payload_size_kb');
  }
  public set maxPayloadSizeKb(value: number) {
    this._maxPayloadSizeKb = value;
  }
  public resetMaxPayloadSizeKb() {
    this._maxPayloadSizeKb = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxPayloadSizeKbInput() {
    return this._maxPayloadSizeKb;
  }

  // message - computed: false, optional: true, required: false
  private _message?: string; 
  public get message() {
    return this.getStringAttribute('message');
  }
  public set message(value: string) {
    this._message = value;
  }
  public resetMessage() {
    this._message = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get messageInput() {
    return this._message;
  }

  // on_backpressure - computed: true, optional: true, required: false
  private _onBackpressure?: string; 
  public get onBackpressure() {
    return this.getStringAttribute('on_backpressure');
  }
  public set onBackpressure(value: string) {
    this._onBackpressure = value;
  }
  public resetOnBackpressure() {
    this._onBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get onBackpressureInput() {
    return this._onBackpressure;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // pq_compress - computed: true, optional: true, required: false
  private _pqCompress?: string; 
  public get pqCompress() {
    return this.getStringAttribute('pq_compress');
  }
  public set pqCompress(value: string) {
    this._pqCompress = value;
  }
  public resetPqCompress() {
    this._pqCompress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqCompressInput() {
    return this._pqCompress;
  }

  // pq_controls - computed: false, optional: true, required: false
  private _pqControls = new DestinationOutputDatadogPqControlsOutputReference(this, "pq_controls");
  public get pqControls() {
    return this._pqControls;
  }
  public putPqControls(value: DestinationOutputDatadogPqControls) {
    this._pqControls.internalValue = value;
  }
  public resetPqControls() {
    this._pqControls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqControlsInput() {
    return this._pqControls.internalValue;
  }

  // pq_max_file_size - computed: true, optional: true, required: false
  private _pqMaxFileSize?: string; 
  public get pqMaxFileSize() {
    return this.getStringAttribute('pq_max_file_size');
  }
  public set pqMaxFileSize(value: string) {
    this._pqMaxFileSize = value;
  }
  public resetPqMaxFileSize() {
    this._pqMaxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxFileSizeInput() {
    return this._pqMaxFileSize;
  }

  // pq_max_size - computed: true, optional: true, required: false
  private _pqMaxSize?: string; 
  public get pqMaxSize() {
    return this.getStringAttribute('pq_max_size');
  }
  public set pqMaxSize(value: string) {
    this._pqMaxSize = value;
  }
  public resetPqMaxSize() {
    this._pqMaxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxSizeInput() {
    return this._pqMaxSize;
  }

  // pq_mode - computed: true, optional: true, required: false
  private _pqMode?: string; 
  public get pqMode() {
    return this.getStringAttribute('pq_mode');
  }
  public set pqMode(value: string) {
    this._pqMode = value;
  }
  public resetPqMode() {
    this._pqMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqModeInput() {
    return this._pqMode;
  }

  // pq_on_backpressure - computed: true, optional: true, required: false
  private _pqOnBackpressure?: string; 
  public get pqOnBackpressure() {
    return this.getStringAttribute('pq_on_backpressure');
  }
  public set pqOnBackpressure(value: string) {
    this._pqOnBackpressure = value;
  }
  public resetPqOnBackpressure() {
    this._pqOnBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqOnBackpressureInput() {
    return this._pqOnBackpressure;
  }

  // pq_path - computed: true, optional: true, required: false
  private _pqPath?: string; 
  public get pqPath() {
    return this.getStringAttribute('pq_path');
  }
  public set pqPath(value: string) {
    this._pqPath = value;
  }
  public resetPqPath() {
    this._pqPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqPathInput() {
    return this._pqPath;
  }

  // reject_unauthorized - computed: true, optional: true, required: false
  private _rejectUnauthorized?: boolean | cdktf.IResolvable; 
  public get rejectUnauthorized() {
    return this.getBooleanAttribute('reject_unauthorized');
  }
  public set rejectUnauthorized(value: boolean | cdktf.IResolvable) {
    this._rejectUnauthorized = value;
  }
  public resetRejectUnauthorized() {
    this._rejectUnauthorized = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectUnauthorizedInput() {
    return this._rejectUnauthorized;
  }

  // response_honor_retry_after_header - computed: true, optional: true, required: false
  private _responseHonorRetryAfterHeader?: boolean | cdktf.IResolvable; 
  public get responseHonorRetryAfterHeader() {
    return this.getBooleanAttribute('response_honor_retry_after_header');
  }
  public set responseHonorRetryAfterHeader(value: boolean | cdktf.IResolvable) {
    this._responseHonorRetryAfterHeader = value;
  }
  public resetResponseHonorRetryAfterHeader() {
    this._responseHonorRetryAfterHeader = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get responseHonorRetryAfterHeaderInput() {
    return this._responseHonorRetryAfterHeader;
  }

  // response_retry_settings - computed: false, optional: true, required: false
  private _responseRetrySettings = new DestinationOutputDatadogResponseRetrySettingsList(this, "response_retry_settings", false);
  public get responseRetrySettings() {
    return this._responseRetrySettings;
  }
  public putResponseRetrySettings(value: DestinationOutputDatadogResponseRetrySettings[] | cdktf.IResolvable) {
    this._responseRetrySettings.internalValue = value;
  }
  public resetResponseRetrySettings() {
    this._responseRetrySettings.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get responseRetrySettingsInput() {
    return this._responseRetrySettings.internalValue;
  }

  // safe_headers - computed: true, optional: true, required: false
  private _safeHeaders?: string[]; 
  public get safeHeaders() {
    return this.getListAttribute('safe_headers');
  }
  public set safeHeaders(value: string[]) {
    this._safeHeaders = value;
  }
  public resetSafeHeaders() {
    this._safeHeaders = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get safeHeadersInput() {
    return this._safeHeaders;
  }

  // send_counters_as_count - computed: true, optional: true, required: false
  private _sendCountersAsCount?: boolean | cdktf.IResolvable; 
  public get sendCountersAsCount() {
    return this.getBooleanAttribute('send_counters_as_count');
  }
  public set sendCountersAsCount(value: boolean | cdktf.IResolvable) {
    this._sendCountersAsCount = value;
  }
  public resetSendCountersAsCount() {
    this._sendCountersAsCount = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sendCountersAsCountInput() {
    return this._sendCountersAsCount;
  }

  // service - computed: false, optional: true, required: false
  private _service?: string; 
  public get service() {
    return this.getStringAttribute('service');
  }
  public set service(value: string) {
    this._service = value;
  }
  public resetService() {
    this._service = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serviceInput() {
    return this._service;
  }

  // severity - computed: false, optional: true, required: false
  private _severity?: string; 
  public get severity() {
    return this.getStringAttribute('severity');
  }
  public set severity(value: string) {
    this._severity = value;
  }
  public resetSeverity() {
    this._severity = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get severityInput() {
    return this._severity;
  }

  // site - computed: true, optional: true, required: false
  private _site?: string; 
  public get site() {
    return this.getStringAttribute('site');
  }
  public set site(value: string) {
    this._site = value;
  }
  public resetSite() {
    this._site = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get siteInput() {
    return this._site;
  }

  // source - computed: false, optional: true, required: false
  private _source?: string; 
  public get source() {
    return this.getStringAttribute('source');
  }
  public set source(value: string) {
    this._source = value;
  }
  public resetSource() {
    this._source = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sourceInput() {
    return this._source;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // system_fields - computed: true, optional: true, required: false
  private _systemFields?: string[]; 
  public get systemFields() {
    return this.getListAttribute('system_fields');
  }
  public set systemFields(value: string[]) {
    this._systemFields = value;
  }
  public resetSystemFields() {
    this._systemFields = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get systemFieldsInput() {
    return this._systemFields;
  }

  // tags - computed: true, optional: true, required: false
  private _tags?: string[]; 
  public get tags() {
    return this.getListAttribute('tags');
  }
  public set tags(value: string[]) {
    this._tags = value;
  }
  public resetTags() {
    this._tags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tagsInput() {
    return this._tags;
  }

  // text_secret - computed: false, optional: true, required: false
  private _textSecret?: string; 
  public get textSecret() {
    return this.getStringAttribute('text_secret');
  }
  public set textSecret(value: string) {
    this._textSecret = value;
  }
  public resetTextSecret() {
    this._textSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get textSecretInput() {
    return this._textSecret;
  }

  // timeout_retry_settings - computed: false, optional: true, required: false
  private _timeoutRetrySettings = new DestinationOutputDatadogTimeoutRetrySettingsOutputReference(this, "timeout_retry_settings");
  public get timeoutRetrySettings() {
    return this._timeoutRetrySettings;
  }
  public putTimeoutRetrySettings(value: DestinationOutputDatadogTimeoutRetrySettings) {
    this._timeoutRetrySettings.internalValue = value;
  }
  public resetTimeoutRetrySettings() {
    this._timeoutRetrySettings.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutRetrySettingsInput() {
    return this._timeoutRetrySettings.internalValue;
  }

  // timeout_sec - computed: true, optional: true, required: false
  private _timeoutSec?: number; 
  public get timeoutSec() {
    return this.getNumberAttribute('timeout_sec');
  }
  public set timeoutSec(value: number) {
    this._timeoutSec = value;
  }
  public resetTimeoutSec() {
    this._timeoutSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutSecInput() {
    return this._timeoutSec;
  }

  // total_memory_limit_kb - computed: false, optional: true, required: false
  private _totalMemoryLimitKb?: number; 
  public get totalMemoryLimitKb() {
    return this.getNumberAttribute('total_memory_limit_kb');
  }
  public set totalMemoryLimitKb(value: number) {
    this._totalMemoryLimitKb = value;
  }
  public resetTotalMemoryLimitKb() {
    this._totalMemoryLimitKb = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get totalMemoryLimitKbInput() {
    return this._totalMemoryLimitKb;
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // use_round_robin_dns - computed: true, optional: true, required: false
  private _useRoundRobinDns?: boolean | cdktf.IResolvable; 
  public get useRoundRobinDns() {
    return this.getBooleanAttribute('use_round_robin_dns');
  }
  public set useRoundRobinDns(value: boolean | cdktf.IResolvable) {
    this._useRoundRobinDns = value;
  }
  public resetUseRoundRobinDns() {
    this._useRoundRobinDns = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get useRoundRobinDnsInput() {
    return this._useRoundRobinDns;
  }
}
export interface DestinationOutputDatasetExtraHttpHeaders {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#name Destination#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#value Destination#value}
  */
  readonly value: string;
}

export function destinationOutputDatasetExtraHttpHeadersToTerraform(struct?: DestinationOutputDatasetExtraHttpHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function destinationOutputDatasetExtraHttpHeadersToHclTerraform(struct?: DestinationOutputDatasetExtraHttpHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputDatasetExtraHttpHeadersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DestinationOutputDatasetExtraHttpHeaders | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputDatasetExtraHttpHeaders | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DestinationOutputDatasetExtraHttpHeadersList extends cdktf.ComplexList {
  public internalValue? : DestinationOutputDatasetExtraHttpHeaders[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DestinationOutputDatasetExtraHttpHeadersOutputReference {
    return new DestinationOutputDatasetExtraHttpHeadersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DestinationOutputDatasetPqControls {
}

export function destinationOutputDatasetPqControlsToTerraform(struct?: DestinationOutputDatasetPqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function destinationOutputDatasetPqControlsToHclTerraform(struct?: DestinationOutputDatasetPqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class DestinationOutputDatasetPqControlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DestinationOutputDatasetPqControls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputDatasetPqControls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface DestinationOutputDatasetResponseRetrySettings {
  /**
  * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc. Default: 2
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#backoff_rate Destination#backoff_rate}
  */
  readonly backoffRate?: number;
  /**
  * The HTTP response status code that will trigger retries
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#http_status Destination#http_status}
  */
  readonly httpStatus: number;
  /**
  * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes). Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#initial_backoff Destination#initial_backoff}
  */
  readonly initialBackoff?: number;
  /**
  * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds). Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#max_backoff Destination#max_backoff}
  */
  readonly maxBackoff?: number;
}

export function destinationOutputDatasetResponseRetrySettingsToTerraform(struct?: DestinationOutputDatasetResponseRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    backoff_rate: cdktf.numberToTerraform(struct!.backoffRate),
    http_status: cdktf.numberToTerraform(struct!.httpStatus),
    initial_backoff: cdktf.numberToTerraform(struct!.initialBackoff),
    max_backoff: cdktf.numberToTerraform(struct!.maxBackoff),
  }
}


export function destinationOutputDatasetResponseRetrySettingsToHclTerraform(struct?: DestinationOutputDatasetResponseRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    backoff_rate: {
      value: cdktf.numberToHclTerraform(struct!.backoffRate),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    http_status: {
      value: cdktf.numberToHclTerraform(struct!.httpStatus),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    initial_backoff: {
      value: cdktf.numberToHclTerraform(struct!.initialBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_backoff: {
      value: cdktf.numberToHclTerraform(struct!.maxBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputDatasetResponseRetrySettingsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DestinationOutputDatasetResponseRetrySettings | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._backoffRate !== undefined) {
      hasAnyValues = true;
      internalValueResult.backoffRate = this._backoffRate;
    }
    if (this._httpStatus !== undefined) {
      hasAnyValues = true;
      internalValueResult.httpStatus = this._httpStatus;
    }
    if (this._initialBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.initialBackoff = this._initialBackoff;
    }
    if (this._maxBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBackoff = this._maxBackoff;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputDatasetResponseRetrySettings | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._backoffRate = undefined;
      this._httpStatus = undefined;
      this._initialBackoff = undefined;
      this._maxBackoff = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._backoffRate = value.backoffRate;
      this._httpStatus = value.httpStatus;
      this._initialBackoff = value.initialBackoff;
      this._maxBackoff = value.maxBackoff;
    }
  }

  // backoff_rate - computed: true, optional: true, required: false
  private _backoffRate?: number; 
  public get backoffRate() {
    return this.getNumberAttribute('backoff_rate');
  }
  public set backoffRate(value: number) {
    this._backoffRate = value;
  }
  public resetBackoffRate() {
    this._backoffRate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get backoffRateInput() {
    return this._backoffRate;
  }

  // http_status - computed: false, optional: false, required: true
  private _httpStatus?: number; 
  public get httpStatus() {
    return this.getNumberAttribute('http_status');
  }
  public set httpStatus(value: number) {
    this._httpStatus = value;
  }
  // Temporarily expose input value. Use with caution.
  public get httpStatusInput() {
    return this._httpStatus;
  }

  // initial_backoff - computed: true, optional: true, required: false
  private _initialBackoff?: number; 
  public get initialBackoff() {
    return this.getNumberAttribute('initial_backoff');
  }
  public set initialBackoff(value: number) {
    this._initialBackoff = value;
  }
  public resetInitialBackoff() {
    this._initialBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get initialBackoffInput() {
    return this._initialBackoff;
  }

  // max_backoff - computed: true, optional: true, required: false
  private _maxBackoff?: number; 
  public get maxBackoff() {
    return this.getNumberAttribute('max_backoff');
  }
  public set maxBackoff(value: number) {
    this._maxBackoff = value;
  }
  public resetMaxBackoff() {
    this._maxBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBackoffInput() {
    return this._maxBackoff;
  }
}

export class DestinationOutputDatasetResponseRetrySettingsList extends cdktf.ComplexList {
  public internalValue? : DestinationOutputDatasetResponseRetrySettings[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DestinationOutputDatasetResponseRetrySettingsOutputReference {
    return new DestinationOutputDatasetResponseRetrySettingsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DestinationOutputDatasetTimeoutRetrySettings {
  /**
  * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc. Default: 2
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#backoff_rate Destination#backoff_rate}
  */
  readonly backoffRate?: number;
  /**
  * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes). Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#initial_backoff Destination#initial_backoff}
  */
  readonly initialBackoff?: number;
  /**
  * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds). Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#max_backoff Destination#max_backoff}
  */
  readonly maxBackoff?: number;
  /**
  * Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#timeout_retry Destination#timeout_retry}
  */
  readonly timeoutRetry?: boolean | cdktf.IResolvable;
}

export function destinationOutputDatasetTimeoutRetrySettingsToTerraform(struct?: DestinationOutputDatasetTimeoutRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    backoff_rate: cdktf.numberToTerraform(struct!.backoffRate),
    initial_backoff: cdktf.numberToTerraform(struct!.initialBackoff),
    max_backoff: cdktf.numberToTerraform(struct!.maxBackoff),
    timeout_retry: cdktf.booleanToTerraform(struct!.timeoutRetry),
  }
}


export function destinationOutputDatasetTimeoutRetrySettingsToHclTerraform(struct?: DestinationOutputDatasetTimeoutRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    backoff_rate: {
      value: cdktf.numberToHclTerraform(struct!.backoffRate),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    initial_backoff: {
      value: cdktf.numberToHclTerraform(struct!.initialBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_backoff: {
      value: cdktf.numberToHclTerraform(struct!.maxBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    timeout_retry: {
      value: cdktf.booleanToHclTerraform(struct!.timeoutRetry),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputDatasetTimeoutRetrySettingsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DestinationOutputDatasetTimeoutRetrySettings | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._backoffRate !== undefined) {
      hasAnyValues = true;
      internalValueResult.backoffRate = this._backoffRate;
    }
    if (this._initialBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.initialBackoff = this._initialBackoff;
    }
    if (this._maxBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBackoff = this._maxBackoff;
    }
    if (this._timeoutRetry !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutRetry = this._timeoutRetry;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputDatasetTimeoutRetrySettings | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._backoffRate = undefined;
      this._initialBackoff = undefined;
      this._maxBackoff = undefined;
      this._timeoutRetry = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._backoffRate = value.backoffRate;
      this._initialBackoff = value.initialBackoff;
      this._maxBackoff = value.maxBackoff;
      this._timeoutRetry = value.timeoutRetry;
    }
  }

  // backoff_rate - computed: true, optional: true, required: false
  private _backoffRate?: number; 
  public get backoffRate() {
    return this.getNumberAttribute('backoff_rate');
  }
  public set backoffRate(value: number) {
    this._backoffRate = value;
  }
  public resetBackoffRate() {
    this._backoffRate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get backoffRateInput() {
    return this._backoffRate;
  }

  // initial_backoff - computed: true, optional: true, required: false
  private _initialBackoff?: number; 
  public get initialBackoff() {
    return this.getNumberAttribute('initial_backoff');
  }
  public set initialBackoff(value: number) {
    this._initialBackoff = value;
  }
  public resetInitialBackoff() {
    this._initialBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get initialBackoffInput() {
    return this._initialBackoff;
  }

  // max_backoff - computed: true, optional: true, required: false
  private _maxBackoff?: number; 
  public get maxBackoff() {
    return this.getNumberAttribute('max_backoff');
  }
  public set maxBackoff(value: number) {
    this._maxBackoff = value;
  }
  public resetMaxBackoff() {
    this._maxBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBackoffInput() {
    return this._maxBackoff;
  }

  // timeout_retry - computed: true, optional: true, required: false
  private _timeoutRetry?: boolean | cdktf.IResolvable; 
  public get timeoutRetry() {
    return this.getBooleanAttribute('timeout_retry');
  }
  public set timeoutRetry(value: boolean | cdktf.IResolvable) {
    this._timeoutRetry = value;
  }
  public resetTimeoutRetry() {
    this._timeoutRetry = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutRetryInput() {
    return this._timeoutRetry;
  }
}
export interface DestinationOutputDataset {
  /**
  * A 'Log Write Access' API key for the DataSet account
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#api_key Destination#api_key}
  */
  readonly apiKey?: string;
  /**
  * Enter API key directly, or select a stored secret. Default: "manual"; must be one of ["manual", "secret"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#auth_type Destination#auth_type}
  */
  readonly authType?: string;
  /**
  * Compress the payload body before sending. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#compress Destination#compress}
  */
  readonly compress?: boolean | cdktf.IResolvable;
  /**
  * Maximum number of ongoing requests before blocking. Default: 5
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#concurrency Destination#concurrency}
  */
  readonly concurrency?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#custom_url Destination#custom_url}
  */
  readonly customUrl?: string;
  /**
  * Default value for event severity. If the `sev` or `__severity` fields are set on an event, the first one matching will override this value. Default: "info"; must be one of ["finest", "finer", "fine", "info", "warning", "error", "fatal"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#default_severity Destination#default_severity}
  */
  readonly defaultSeverity?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#description Destination#description}
  */
  readonly description?: string;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#environment Destination#environment}
  */
  readonly environment?: string;
  /**
  * Fields to exclude from the event if the Message field is either unspecified or refers to an object. Ignored if the Message field is a string. If empty, we send all non-internal fields. Default: ["sev","_time","ts","thread"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#exclude_fields Destination#exclude_fields}
  */
  readonly excludeFields?: string[];
  /**
  * Headers to add to all events
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#extra_http_headers Destination#extra_http_headers}
  */
  readonly extraHttpHeaders?: DestinationOutputDatasetExtraHttpHeaders[] | cdktf.IResolvable;
  /**
  * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below. Default: "none"; must be one of ["payload", "payloadAndHeaders", "none"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#failed_request_logging_mode Destination#failed_request_logging_mode}
  */
  readonly failedRequestLoggingMode?: string;
  /**
  * Maximum time between requests. Small values could cause the payload size to be smaller than the configured Body size limit. Default: 1
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#flush_period_sec Destination#flush_period_sec}
  */
  readonly flushPeriodSec?: number;
  /**
  * Unique ID for this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#id Destination#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id: string;
  /**
  * Maximum number of events to include in the request body. Default is 0 (unlimited). Default: 0
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#max_payload_events Destination#max_payload_events}
  */
  readonly maxPayloadEvents?: number;
  /**
  * Maximum size, in KB, of the request body. Default: 4096
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#max_payload_size_kb Destination#max_payload_size_kb}
  */
  readonly maxPayloadSizeKb?: number;
  /**
  * Name of the event field that contains the message or attributes to send. If not specified, all of the event's non-internal fields will be sent as attributes.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#message_field Destination#message_field}
  */
  readonly messageField?: string;
  /**
  * How to handle events when all receivers are exerting backpressure. Default: "block"; must be one of ["block", "drop", "queue"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#on_backpressure Destination#on_backpressure}
  */
  readonly onBackpressure?: string;
  /**
  * Pipeline to process data before sending out to this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pipeline Destination#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pq_compress Destination#pq_compress}
  */
  readonly pqCompress?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pq_controls Destination#pq_controls}
  */
  readonly pqControls?: DestinationOutputDatasetPqControls;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.). Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pq_max_file_size Destination#pq_max_file_size}
  */
  readonly pqMaxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pq_max_size Destination#pq_max_size}
  */
  readonly pqMaxSize?: string;
  /**
  * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem. Default: "error"; must be one of ["error", "backpressure", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pq_mode Destination#pq_mode}
  */
  readonly pqMode?: string;
  /**
  * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged. Default: "block"; must be one of ["block", "drop"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pq_on_backpressure Destination#pq_on_backpressure}
  */
  readonly pqOnBackpressure?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pq_path Destination#pq_path}
  */
  readonly pqPath?: string;
  /**
  * Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's). 
  *         Enabled by default. When this setting is also present in TLS Settings (Client Side), 
  *         that value will take precedence.
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#reject_unauthorized Destination#reject_unauthorized}
  */
  readonly rejectUnauthorized?: boolean | cdktf.IResolvable;
  /**
  * Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#response_honor_retry_after_header Destination#response_honor_retry_after_header}
  */
  readonly responseHonorRetryAfterHeader?: boolean | cdktf.IResolvable;
  /**
  * Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#response_retry_settings Destination#response_retry_settings}
  */
  readonly responseRetrySettings?: DestinationOutputDatasetResponseRetrySettings[] | cdktf.IResolvable;
  /**
  * List of headers that are safe to log in plain text. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#safe_headers Destination#safe_headers}
  */
  readonly safeHeaders?: string[];
  /**
  * Name of the event field that contains the `serverHost` identifier. If not specified, defaults to `cribl_<outputId>`.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#server_host_field Destination#server_host_field}
  */
  readonly serverHostField?: string;
  /**
  * DataSet site to which events should be sent. Default: "us"; must be one of ["us", "eu", "custom"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#site Destination#site}
  */
  readonly site?: string;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#streamtags Destination#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Fields to automatically add to events, such as cribl_pipe. Supports wildcards. Default: ["cribl_pipe"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#system_fields Destination#system_fields}
  */
  readonly systemFields?: string[];
  /**
  * Select or create a stored text secret
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#text_secret Destination#text_secret}
  */
  readonly textSecret?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#timeout_retry_settings Destination#timeout_retry_settings}
  */
  readonly timeoutRetrySettings?: DestinationOutputDatasetTimeoutRetrySettings;
  /**
  * Amount of time, in seconds, to wait for a request to complete before canceling it. Default: 30
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#timeout_sec Destination#timeout_sec}
  */
  readonly timeoutSec?: number;
  /**
  * Name of the event field that contains the timestamp. If not specified, defaults to `ts`, `_time`, or `Date.now()`, in that order.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#timestamp_field Destination#timestamp_field}
  */
  readonly timestampField?: string;
  /**
  * Maximum total size of the batches waiting to be sent. If left blank, defaults to 5 times the max body size (if set). If 0, no limit is enforced.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#total_memory_limit_kb Destination#total_memory_limit_kb}
  */
  readonly totalMemoryLimitKb?: number;
  /**
  * must be "dataset"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#type Destination#type}
  */
  readonly type: string;
  /**
  * Enable round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. For optimal performance, consider enabling this setting for non-load balanced destinations. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#use_round_robin_dns Destination#use_round_robin_dns}
  */
  readonly useRoundRobinDns?: boolean | cdktf.IResolvable;
}

export function destinationOutputDatasetToTerraform(struct?: DestinationOutputDataset | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    api_key: cdktf.stringToTerraform(struct!.apiKey),
    auth_type: cdktf.stringToTerraform(struct!.authType),
    compress: cdktf.booleanToTerraform(struct!.compress),
    concurrency: cdktf.numberToTerraform(struct!.concurrency),
    custom_url: cdktf.stringToTerraform(struct!.customUrl),
    default_severity: cdktf.stringToTerraform(struct!.defaultSeverity),
    description: cdktf.stringToTerraform(struct!.description),
    environment: cdktf.stringToTerraform(struct!.environment),
    exclude_fields: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.excludeFields),
    extra_http_headers: cdktf.listMapper(destinationOutputDatasetExtraHttpHeadersToTerraform, false)(struct!.extraHttpHeaders),
    failed_request_logging_mode: cdktf.stringToTerraform(struct!.failedRequestLoggingMode),
    flush_period_sec: cdktf.numberToTerraform(struct!.flushPeriodSec),
    id: cdktf.stringToTerraform(struct!.id),
    max_payload_events: cdktf.numberToTerraform(struct!.maxPayloadEvents),
    max_payload_size_kb: cdktf.numberToTerraform(struct!.maxPayloadSizeKb),
    message_field: cdktf.stringToTerraform(struct!.messageField),
    on_backpressure: cdktf.stringToTerraform(struct!.onBackpressure),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    pq_compress: cdktf.stringToTerraform(struct!.pqCompress),
    pq_controls: destinationOutputDatasetPqControlsToTerraform(struct!.pqControls),
    pq_max_file_size: cdktf.stringToTerraform(struct!.pqMaxFileSize),
    pq_max_size: cdktf.stringToTerraform(struct!.pqMaxSize),
    pq_mode: cdktf.stringToTerraform(struct!.pqMode),
    pq_on_backpressure: cdktf.stringToTerraform(struct!.pqOnBackpressure),
    pq_path: cdktf.stringToTerraform(struct!.pqPath),
    reject_unauthorized: cdktf.booleanToTerraform(struct!.rejectUnauthorized),
    response_honor_retry_after_header: cdktf.booleanToTerraform(struct!.responseHonorRetryAfterHeader),
    response_retry_settings: cdktf.listMapper(destinationOutputDatasetResponseRetrySettingsToTerraform, false)(struct!.responseRetrySettings),
    safe_headers: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.safeHeaders),
    server_host_field: cdktf.stringToTerraform(struct!.serverHostField),
    site: cdktf.stringToTerraform(struct!.site),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    system_fields: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.systemFields),
    text_secret: cdktf.stringToTerraform(struct!.textSecret),
    timeout_retry_settings: destinationOutputDatasetTimeoutRetrySettingsToTerraform(struct!.timeoutRetrySettings),
    timeout_sec: cdktf.numberToTerraform(struct!.timeoutSec),
    timestamp_field: cdktf.stringToTerraform(struct!.timestampField),
    total_memory_limit_kb: cdktf.numberToTerraform(struct!.totalMemoryLimitKb),
    type: cdktf.stringToTerraform(struct!.type),
    use_round_robin_dns: cdktf.booleanToTerraform(struct!.useRoundRobinDns),
  }
}


export function destinationOutputDatasetToHclTerraform(struct?: DestinationOutputDataset | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    api_key: {
      value: cdktf.stringToHclTerraform(struct!.apiKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    auth_type: {
      value: cdktf.stringToHclTerraform(struct!.authType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    compress: {
      value: cdktf.booleanToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    concurrency: {
      value: cdktf.numberToHclTerraform(struct!.concurrency),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    custom_url: {
      value: cdktf.stringToHclTerraform(struct!.customUrl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    default_severity: {
      value: cdktf.stringToHclTerraform(struct!.defaultSeverity),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    exclude_fields: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.excludeFields),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    extra_http_headers: {
      value: cdktf.listMapperHcl(destinationOutputDatasetExtraHttpHeadersToHclTerraform, false)(struct!.extraHttpHeaders),
      isBlock: true,
      type: "list",
      storageClassType: "DestinationOutputDatasetExtraHttpHeadersList",
    },
    failed_request_logging_mode: {
      value: cdktf.stringToHclTerraform(struct!.failedRequestLoggingMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    flush_period_sec: {
      value: cdktf.numberToHclTerraform(struct!.flushPeriodSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_payload_events: {
      value: cdktf.numberToHclTerraform(struct!.maxPayloadEvents),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_payload_size_kb: {
      value: cdktf.numberToHclTerraform(struct!.maxPayloadSizeKb),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    message_field: {
      value: cdktf.stringToHclTerraform(struct!.messageField),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.onBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_compress: {
      value: cdktf.stringToHclTerraform(struct!.pqCompress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_controls: {
      value: destinationOutputDatasetPqControlsToHclTerraform(struct!.pqControls),
      isBlock: true,
      type: "struct",
      storageClassType: "DestinationOutputDatasetPqControls",
    },
    pq_max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_max_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_mode: {
      value: cdktf.stringToHclTerraform(struct!.pqMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.pqOnBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_path: {
      value: cdktf.stringToHclTerraform(struct!.pqPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reject_unauthorized: {
      value: cdktf.booleanToHclTerraform(struct!.rejectUnauthorized),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    response_honor_retry_after_header: {
      value: cdktf.booleanToHclTerraform(struct!.responseHonorRetryAfterHeader),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    response_retry_settings: {
      value: cdktf.listMapperHcl(destinationOutputDatasetResponseRetrySettingsToHclTerraform, false)(struct!.responseRetrySettings),
      isBlock: true,
      type: "list",
      storageClassType: "DestinationOutputDatasetResponseRetrySettingsList",
    },
    safe_headers: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.safeHeaders),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    server_host_field: {
      value: cdktf.stringToHclTerraform(struct!.serverHostField),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    site: {
      value: cdktf.stringToHclTerraform(struct!.site),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    system_fields: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.systemFields),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    text_secret: {
      value: cdktf.stringToHclTerraform(struct!.textSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    timeout_retry_settings: {
      value: destinationOutputDatasetTimeoutRetrySettingsToHclTerraform(struct!.timeoutRetrySettings),
      isBlock: true,
      type: "struct",
      storageClassType: "DestinationOutputDatasetTimeoutRetrySettings",
    },
    timeout_sec: {
      value: cdktf.numberToHclTerraform(struct!.timeoutSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    timestamp_field: {
      value: cdktf.stringToHclTerraform(struct!.timestampField),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    total_memory_limit_kb: {
      value: cdktf.numberToHclTerraform(struct!.totalMemoryLimitKb),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    use_round_robin_dns: {
      value: cdktf.booleanToHclTerraform(struct!.useRoundRobinDns),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputDatasetOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DestinationOutputDataset | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._apiKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.apiKey = this._apiKey;
    }
    if (this._authType !== undefined) {
      hasAnyValues = true;
      internalValueResult.authType = this._authType;
    }
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._concurrency !== undefined) {
      hasAnyValues = true;
      internalValueResult.concurrency = this._concurrency;
    }
    if (this._customUrl !== undefined) {
      hasAnyValues = true;
      internalValueResult.customUrl = this._customUrl;
    }
    if (this._defaultSeverity !== undefined) {
      hasAnyValues = true;
      internalValueResult.defaultSeverity = this._defaultSeverity;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._excludeFields !== undefined) {
      hasAnyValues = true;
      internalValueResult.excludeFields = this._excludeFields;
    }
    if (this._extraHttpHeaders?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.extraHttpHeaders = this._extraHttpHeaders?.internalValue;
    }
    if (this._failedRequestLoggingMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.failedRequestLoggingMode = this._failedRequestLoggingMode;
    }
    if (this._flushPeriodSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.flushPeriodSec = this._flushPeriodSec;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._maxPayloadEvents !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxPayloadEvents = this._maxPayloadEvents;
    }
    if (this._maxPayloadSizeKb !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxPayloadSizeKb = this._maxPayloadSizeKb;
    }
    if (this._messageField !== undefined) {
      hasAnyValues = true;
      internalValueResult.messageField = this._messageField;
    }
    if (this._onBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.onBackpressure = this._onBackpressure;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._pqCompress !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqCompress = this._pqCompress;
    }
    if (this._pqControls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqControls = this._pqControls?.internalValue;
    }
    if (this._pqMaxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxFileSize = this._pqMaxFileSize;
    }
    if (this._pqMaxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxSize = this._pqMaxSize;
    }
    if (this._pqMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMode = this._pqMode;
    }
    if (this._pqOnBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqOnBackpressure = this._pqOnBackpressure;
    }
    if (this._pqPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqPath = this._pqPath;
    }
    if (this._rejectUnauthorized !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectUnauthorized = this._rejectUnauthorized;
    }
    if (this._responseHonorRetryAfterHeader !== undefined) {
      hasAnyValues = true;
      internalValueResult.responseHonorRetryAfterHeader = this._responseHonorRetryAfterHeader;
    }
    if (this._responseRetrySettings?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.responseRetrySettings = this._responseRetrySettings?.internalValue;
    }
    if (this._safeHeaders !== undefined) {
      hasAnyValues = true;
      internalValueResult.safeHeaders = this._safeHeaders;
    }
    if (this._serverHostField !== undefined) {
      hasAnyValues = true;
      internalValueResult.serverHostField = this._serverHostField;
    }
    if (this._site !== undefined) {
      hasAnyValues = true;
      internalValueResult.site = this._site;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._systemFields !== undefined) {
      hasAnyValues = true;
      internalValueResult.systemFields = this._systemFields;
    }
    if (this._textSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.textSecret = this._textSecret;
    }
    if (this._timeoutRetrySettings?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutRetrySettings = this._timeoutRetrySettings?.internalValue;
    }
    if (this._timeoutSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutSec = this._timeoutSec;
    }
    if (this._timestampField !== undefined) {
      hasAnyValues = true;
      internalValueResult.timestampField = this._timestampField;
    }
    if (this._totalMemoryLimitKb !== undefined) {
      hasAnyValues = true;
      internalValueResult.totalMemoryLimitKb = this._totalMemoryLimitKb;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._useRoundRobinDns !== undefined) {
      hasAnyValues = true;
      internalValueResult.useRoundRobinDns = this._useRoundRobinDns;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputDataset | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._apiKey = undefined;
      this._authType = undefined;
      this._compress = undefined;
      this._concurrency = undefined;
      this._customUrl = undefined;
      this._defaultSeverity = undefined;
      this._description = undefined;
      this._environment = undefined;
      this._excludeFields = undefined;
      this._extraHttpHeaders.internalValue = undefined;
      this._failedRequestLoggingMode = undefined;
      this._flushPeriodSec = undefined;
      this._id = undefined;
      this._maxPayloadEvents = undefined;
      this._maxPayloadSizeKb = undefined;
      this._messageField = undefined;
      this._onBackpressure = undefined;
      this._pipeline = undefined;
      this._pqCompress = undefined;
      this._pqControls.internalValue = undefined;
      this._pqMaxFileSize = undefined;
      this._pqMaxSize = undefined;
      this._pqMode = undefined;
      this._pqOnBackpressure = undefined;
      this._pqPath = undefined;
      this._rejectUnauthorized = undefined;
      this._responseHonorRetryAfterHeader = undefined;
      this._responseRetrySettings.internalValue = undefined;
      this._safeHeaders = undefined;
      this._serverHostField = undefined;
      this._site = undefined;
      this._streamtags = undefined;
      this._systemFields = undefined;
      this._textSecret = undefined;
      this._timeoutRetrySettings.internalValue = undefined;
      this._timeoutSec = undefined;
      this._timestampField = undefined;
      this._totalMemoryLimitKb = undefined;
      this._type = undefined;
      this._useRoundRobinDns = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._apiKey = value.apiKey;
      this._authType = value.authType;
      this._compress = value.compress;
      this._concurrency = value.concurrency;
      this._customUrl = value.customUrl;
      this._defaultSeverity = value.defaultSeverity;
      this._description = value.description;
      this._environment = value.environment;
      this._excludeFields = value.excludeFields;
      this._extraHttpHeaders.internalValue = value.extraHttpHeaders;
      this._failedRequestLoggingMode = value.failedRequestLoggingMode;
      this._flushPeriodSec = value.flushPeriodSec;
      this._id = value.id;
      this._maxPayloadEvents = value.maxPayloadEvents;
      this._maxPayloadSizeKb = value.maxPayloadSizeKb;
      this._messageField = value.messageField;
      this._onBackpressure = value.onBackpressure;
      this._pipeline = value.pipeline;
      this._pqCompress = value.pqCompress;
      this._pqControls.internalValue = value.pqControls;
      this._pqMaxFileSize = value.pqMaxFileSize;
      this._pqMaxSize = value.pqMaxSize;
      this._pqMode = value.pqMode;
      this._pqOnBackpressure = value.pqOnBackpressure;
      this._pqPath = value.pqPath;
      this._rejectUnauthorized = value.rejectUnauthorized;
      this._responseHonorRetryAfterHeader = value.responseHonorRetryAfterHeader;
      this._responseRetrySettings.internalValue = value.responseRetrySettings;
      this._safeHeaders = value.safeHeaders;
      this._serverHostField = value.serverHostField;
      this._site = value.site;
      this._streamtags = value.streamtags;
      this._systemFields = value.systemFields;
      this._textSecret = value.textSecret;
      this._timeoutRetrySettings.internalValue = value.timeoutRetrySettings;
      this._timeoutSec = value.timeoutSec;
      this._timestampField = value.timestampField;
      this._totalMemoryLimitKb = value.totalMemoryLimitKb;
      this._type = value.type;
      this._useRoundRobinDns = value.useRoundRobinDns;
    }
  }

  // api_key - computed: false, optional: true, required: false
  private _apiKey?: string; 
  public get apiKey() {
    return this.getStringAttribute('api_key');
  }
  public set apiKey(value: string) {
    this._apiKey = value;
  }
  public resetApiKey() {
    this._apiKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get apiKeyInput() {
    return this._apiKey;
  }

  // auth_type - computed: true, optional: true, required: false
  private _authType?: string; 
  public get authType() {
    return this.getStringAttribute('auth_type');
  }
  public set authType(value: string) {
    this._authType = value;
  }
  public resetAuthType() {
    this._authType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authTypeInput() {
    return this._authType;
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: boolean | cdktf.IResolvable; 
  public get compress() {
    return this.getBooleanAttribute('compress');
  }
  public set compress(value: boolean | cdktf.IResolvable) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // concurrency - computed: true, optional: true, required: false
  private _concurrency?: number; 
  public get concurrency() {
    return this.getNumberAttribute('concurrency');
  }
  public set concurrency(value: number) {
    this._concurrency = value;
  }
  public resetConcurrency() {
    this._concurrency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get concurrencyInput() {
    return this._concurrency;
  }

  // custom_url - computed: false, optional: true, required: false
  private _customUrl?: string; 
  public get customUrl() {
    return this.getStringAttribute('custom_url');
  }
  public set customUrl(value: string) {
    this._customUrl = value;
  }
  public resetCustomUrl() {
    this._customUrl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get customUrlInput() {
    return this._customUrl;
  }

  // default_severity - computed: true, optional: true, required: false
  private _defaultSeverity?: string; 
  public get defaultSeverity() {
    return this.getStringAttribute('default_severity');
  }
  public set defaultSeverity(value: string) {
    this._defaultSeverity = value;
  }
  public resetDefaultSeverity() {
    this._defaultSeverity = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get defaultSeverityInput() {
    return this._defaultSeverity;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // exclude_fields - computed: true, optional: true, required: false
  private _excludeFields?: string[]; 
  public get excludeFields() {
    return this.getListAttribute('exclude_fields');
  }
  public set excludeFields(value: string[]) {
    this._excludeFields = value;
  }
  public resetExcludeFields() {
    this._excludeFields = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get excludeFieldsInput() {
    return this._excludeFields;
  }

  // extra_http_headers - computed: false, optional: true, required: false
  private _extraHttpHeaders = new DestinationOutputDatasetExtraHttpHeadersList(this, "extra_http_headers", false);
  public get extraHttpHeaders() {
    return this._extraHttpHeaders;
  }
  public putExtraHttpHeaders(value: DestinationOutputDatasetExtraHttpHeaders[] | cdktf.IResolvable) {
    this._extraHttpHeaders.internalValue = value;
  }
  public resetExtraHttpHeaders() {
    this._extraHttpHeaders.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get extraHttpHeadersInput() {
    return this._extraHttpHeaders.internalValue;
  }

  // failed_request_logging_mode - computed: true, optional: true, required: false
  private _failedRequestLoggingMode?: string; 
  public get failedRequestLoggingMode() {
    return this.getStringAttribute('failed_request_logging_mode');
  }
  public set failedRequestLoggingMode(value: string) {
    this._failedRequestLoggingMode = value;
  }
  public resetFailedRequestLoggingMode() {
    this._failedRequestLoggingMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get failedRequestLoggingModeInput() {
    return this._failedRequestLoggingMode;
  }

  // flush_period_sec - computed: true, optional: true, required: false
  private _flushPeriodSec?: number; 
  public get flushPeriodSec() {
    return this.getNumberAttribute('flush_period_sec');
  }
  public set flushPeriodSec(value: number) {
    this._flushPeriodSec = value;
  }
  public resetFlushPeriodSec() {
    this._flushPeriodSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get flushPeriodSecInput() {
    return this._flushPeriodSec;
  }

  // id - computed: false, optional: false, required: true
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // max_payload_events - computed: true, optional: true, required: false
  private _maxPayloadEvents?: number; 
  public get maxPayloadEvents() {
    return this.getNumberAttribute('max_payload_events');
  }
  public set maxPayloadEvents(value: number) {
    this._maxPayloadEvents = value;
  }
  public resetMaxPayloadEvents() {
    this._maxPayloadEvents = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxPayloadEventsInput() {
    return this._maxPayloadEvents;
  }

  // max_payload_size_kb - computed: true, optional: true, required: false
  private _maxPayloadSizeKb?: number; 
  public get maxPayloadSizeKb() {
    return this.getNumberAttribute('max_payload_size_kb');
  }
  public set maxPayloadSizeKb(value: number) {
    this._maxPayloadSizeKb = value;
  }
  public resetMaxPayloadSizeKb() {
    this._maxPayloadSizeKb = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxPayloadSizeKbInput() {
    return this._maxPayloadSizeKb;
  }

  // message_field - computed: false, optional: true, required: false
  private _messageField?: string; 
  public get messageField() {
    return this.getStringAttribute('message_field');
  }
  public set messageField(value: string) {
    this._messageField = value;
  }
  public resetMessageField() {
    this._messageField = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get messageFieldInput() {
    return this._messageField;
  }

  // on_backpressure - computed: true, optional: true, required: false
  private _onBackpressure?: string; 
  public get onBackpressure() {
    return this.getStringAttribute('on_backpressure');
  }
  public set onBackpressure(value: string) {
    this._onBackpressure = value;
  }
  public resetOnBackpressure() {
    this._onBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get onBackpressureInput() {
    return this._onBackpressure;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // pq_compress - computed: true, optional: true, required: false
  private _pqCompress?: string; 
  public get pqCompress() {
    return this.getStringAttribute('pq_compress');
  }
  public set pqCompress(value: string) {
    this._pqCompress = value;
  }
  public resetPqCompress() {
    this._pqCompress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqCompressInput() {
    return this._pqCompress;
  }

  // pq_controls - computed: false, optional: true, required: false
  private _pqControls = new DestinationOutputDatasetPqControlsOutputReference(this, "pq_controls");
  public get pqControls() {
    return this._pqControls;
  }
  public putPqControls(value: DestinationOutputDatasetPqControls) {
    this._pqControls.internalValue = value;
  }
  public resetPqControls() {
    this._pqControls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqControlsInput() {
    return this._pqControls.internalValue;
  }

  // pq_max_file_size - computed: true, optional: true, required: false
  private _pqMaxFileSize?: string; 
  public get pqMaxFileSize() {
    return this.getStringAttribute('pq_max_file_size');
  }
  public set pqMaxFileSize(value: string) {
    this._pqMaxFileSize = value;
  }
  public resetPqMaxFileSize() {
    this._pqMaxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxFileSizeInput() {
    return this._pqMaxFileSize;
  }

  // pq_max_size - computed: true, optional: true, required: false
  private _pqMaxSize?: string; 
  public get pqMaxSize() {
    return this.getStringAttribute('pq_max_size');
  }
  public set pqMaxSize(value: string) {
    this._pqMaxSize = value;
  }
  public resetPqMaxSize() {
    this._pqMaxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxSizeInput() {
    return this._pqMaxSize;
  }

  // pq_mode - computed: true, optional: true, required: false
  private _pqMode?: string; 
  public get pqMode() {
    return this.getStringAttribute('pq_mode');
  }
  public set pqMode(value: string) {
    this._pqMode = value;
  }
  public resetPqMode() {
    this._pqMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqModeInput() {
    return this._pqMode;
  }

  // pq_on_backpressure - computed: true, optional: true, required: false
  private _pqOnBackpressure?: string; 
  public get pqOnBackpressure() {
    return this.getStringAttribute('pq_on_backpressure');
  }
  public set pqOnBackpressure(value: string) {
    this._pqOnBackpressure = value;
  }
  public resetPqOnBackpressure() {
    this._pqOnBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqOnBackpressureInput() {
    return this._pqOnBackpressure;
  }

  // pq_path - computed: true, optional: true, required: false
  private _pqPath?: string; 
  public get pqPath() {
    return this.getStringAttribute('pq_path');
  }
  public set pqPath(value: string) {
    this._pqPath = value;
  }
  public resetPqPath() {
    this._pqPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqPathInput() {
    return this._pqPath;
  }

  // reject_unauthorized - computed: true, optional: true, required: false
  private _rejectUnauthorized?: boolean | cdktf.IResolvable; 
  public get rejectUnauthorized() {
    return this.getBooleanAttribute('reject_unauthorized');
  }
  public set rejectUnauthorized(value: boolean | cdktf.IResolvable) {
    this._rejectUnauthorized = value;
  }
  public resetRejectUnauthorized() {
    this._rejectUnauthorized = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectUnauthorizedInput() {
    return this._rejectUnauthorized;
  }

  // response_honor_retry_after_header - computed: true, optional: true, required: false
  private _responseHonorRetryAfterHeader?: boolean | cdktf.IResolvable; 
  public get responseHonorRetryAfterHeader() {
    return this.getBooleanAttribute('response_honor_retry_after_header');
  }
  public set responseHonorRetryAfterHeader(value: boolean | cdktf.IResolvable) {
    this._responseHonorRetryAfterHeader = value;
  }
  public resetResponseHonorRetryAfterHeader() {
    this._responseHonorRetryAfterHeader = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get responseHonorRetryAfterHeaderInput() {
    return this._responseHonorRetryAfterHeader;
  }

  // response_retry_settings - computed: false, optional: true, required: false
  private _responseRetrySettings = new DestinationOutputDatasetResponseRetrySettingsList(this, "response_retry_settings", false);
  public get responseRetrySettings() {
    return this._responseRetrySettings;
  }
  public putResponseRetrySettings(value: DestinationOutputDatasetResponseRetrySettings[] | cdktf.IResolvable) {
    this._responseRetrySettings.internalValue = value;
  }
  public resetResponseRetrySettings() {
    this._responseRetrySettings.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get responseRetrySettingsInput() {
    return this._responseRetrySettings.internalValue;
  }

  // safe_headers - computed: true, optional: true, required: false
  private _safeHeaders?: string[]; 
  public get safeHeaders() {
    return this.getListAttribute('safe_headers');
  }
  public set safeHeaders(value: string[]) {
    this._safeHeaders = value;
  }
  public resetSafeHeaders() {
    this._safeHeaders = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get safeHeadersInput() {
    return this._safeHeaders;
  }

  // server_host_field - computed: false, optional: true, required: false
  private _serverHostField?: string; 
  public get serverHostField() {
    return this.getStringAttribute('server_host_field');
  }
  public set serverHostField(value: string) {
    this._serverHostField = value;
  }
  public resetServerHostField() {
    this._serverHostField = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serverHostFieldInput() {
    return this._serverHostField;
  }

  // site - computed: true, optional: true, required: false
  private _site?: string; 
  public get site() {
    return this.getStringAttribute('site');
  }
  public set site(value: string) {
    this._site = value;
  }
  public resetSite() {
    this._site = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get siteInput() {
    return this._site;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // system_fields - computed: true, optional: true, required: false
  private _systemFields?: string[]; 
  public get systemFields() {
    return this.getListAttribute('system_fields');
  }
  public set systemFields(value: string[]) {
    this._systemFields = value;
  }
  public resetSystemFields() {
    this._systemFields = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get systemFieldsInput() {
    return this._systemFields;
  }

  // text_secret - computed: false, optional: true, required: false
  private _textSecret?: string; 
  public get textSecret() {
    return this.getStringAttribute('text_secret');
  }
  public set textSecret(value: string) {
    this._textSecret = value;
  }
  public resetTextSecret() {
    this._textSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get textSecretInput() {
    return this._textSecret;
  }

  // timeout_retry_settings - computed: false, optional: true, required: false
  private _timeoutRetrySettings = new DestinationOutputDatasetTimeoutRetrySettingsOutputReference(this, "timeout_retry_settings");
  public get timeoutRetrySettings() {
    return this._timeoutRetrySettings;
  }
  public putTimeoutRetrySettings(value: DestinationOutputDatasetTimeoutRetrySettings) {
    this._timeoutRetrySettings.internalValue = value;
  }
  public resetTimeoutRetrySettings() {
    this._timeoutRetrySettings.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutRetrySettingsInput() {
    return this._timeoutRetrySettings.internalValue;
  }

  // timeout_sec - computed: true, optional: true, required: false
  private _timeoutSec?: number; 
  public get timeoutSec() {
    return this.getNumberAttribute('timeout_sec');
  }
  public set timeoutSec(value: number) {
    this._timeoutSec = value;
  }
  public resetTimeoutSec() {
    this._timeoutSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutSecInput() {
    return this._timeoutSec;
  }

  // timestamp_field - computed: false, optional: true, required: false
  private _timestampField?: string; 
  public get timestampField() {
    return this.getStringAttribute('timestamp_field');
  }
  public set timestampField(value: string) {
    this._timestampField = value;
  }
  public resetTimestampField() {
    this._timestampField = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timestampFieldInput() {
    return this._timestampField;
  }

  // total_memory_limit_kb - computed: false, optional: true, required: false
  private _totalMemoryLimitKb?: number; 
  public get totalMemoryLimitKb() {
    return this.getNumberAttribute('total_memory_limit_kb');
  }
  public set totalMemoryLimitKb(value: number) {
    this._totalMemoryLimitKb = value;
  }
  public resetTotalMemoryLimitKb() {
    this._totalMemoryLimitKb = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get totalMemoryLimitKbInput() {
    return this._totalMemoryLimitKb;
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // use_round_robin_dns - computed: true, optional: true, required: false
  private _useRoundRobinDns?: boolean | cdktf.IResolvable; 
  public get useRoundRobinDns() {
    return this.getBooleanAttribute('use_round_robin_dns');
  }
  public set useRoundRobinDns(value: boolean | cdktf.IResolvable) {
    this._useRoundRobinDns = value;
  }
  public resetUseRoundRobinDns() {
    this._useRoundRobinDns = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get useRoundRobinDnsInput() {
    return this._useRoundRobinDns;
  }
}
export interface DestinationOutputDefault {
  /**
  * ID of the default output. This will be used whenever a nonexistent/deleted output is referenced.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#default_id Destination#default_id}
  */
  readonly defaultId: string;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#environment Destination#environment}
  */
  readonly environment?: string;
  /**
  * Unique ID for this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#id Destination#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * Pipeline to process data before sending out to this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pipeline Destination#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#streamtags Destination#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Fields to automatically add to events, such as cribl_pipe. Supports wildcards. Default: ["cribl_pipe"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#system_fields Destination#system_fields}
  */
  readonly systemFields?: string[];
  /**
  * must be "default"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#type Destination#type}
  */
  readonly type: string;
}

export function destinationOutputDefaultToTerraform(struct?: DestinationOutputDefault | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    default_id: cdktf.stringToTerraform(struct!.defaultId),
    environment: cdktf.stringToTerraform(struct!.environment),
    id: cdktf.stringToTerraform(struct!.id),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    system_fields: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.systemFields),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function destinationOutputDefaultToHclTerraform(struct?: DestinationOutputDefault | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    default_id: {
      value: cdktf.stringToHclTerraform(struct!.defaultId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    system_fields: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.systemFields),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputDefaultOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DestinationOutputDefault | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._defaultId !== undefined) {
      hasAnyValues = true;
      internalValueResult.defaultId = this._defaultId;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._systemFields !== undefined) {
      hasAnyValues = true;
      internalValueResult.systemFields = this._systemFields;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputDefault | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._defaultId = undefined;
      this._environment = undefined;
      this._id = undefined;
      this._pipeline = undefined;
      this._streamtags = undefined;
      this._systemFields = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._defaultId = value.defaultId;
      this._environment = value.environment;
      this._id = value.id;
      this._pipeline = value.pipeline;
      this._streamtags = value.streamtags;
      this._systemFields = value.systemFields;
      this._type = value.type;
    }
  }

  // default_id - computed: false, optional: false, required: true
  private _defaultId?: string; 
  public get defaultId() {
    return this.getStringAttribute('default_id');
  }
  public set defaultId(value: string) {
    this._defaultId = value;
  }
  // Temporarily expose input value. Use with caution.
  public get defaultIdInput() {
    return this._defaultId;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // system_fields - computed: true, optional: true, required: false
  private _systemFields?: string[]; 
  public get systemFields() {
    return this.getListAttribute('system_fields');
  }
  public set systemFields(value: string[]) {
    this._systemFields = value;
  }
  public resetSystemFields() {
    this._systemFields = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get systemFieldsInput() {
    return this._systemFields;
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface DestinationOutputDevnull {
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#environment Destination#environment}
  */
  readonly environment?: string;
  /**
  * Unique ID for this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#id Destination#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id: string;
  /**
  * Pipeline to process data before sending out to this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pipeline Destination#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#streamtags Destination#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Fields to automatically add to events, such as cribl_pipe. Supports wildcards. Default: ["cribl_pipe"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#system_fields Destination#system_fields}
  */
  readonly systemFields?: string[];
  /**
  * must be "devnull"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#type Destination#type}
  */
  readonly type: string;
}

export function destinationOutputDevnullToTerraform(struct?: DestinationOutputDevnull | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    environment: cdktf.stringToTerraform(struct!.environment),
    id: cdktf.stringToTerraform(struct!.id),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    system_fields: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.systemFields),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function destinationOutputDevnullToHclTerraform(struct?: DestinationOutputDevnull | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    system_fields: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.systemFields),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputDevnullOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DestinationOutputDevnull | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._systemFields !== undefined) {
      hasAnyValues = true;
      internalValueResult.systemFields = this._systemFields;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputDevnull | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._environment = undefined;
      this._id = undefined;
      this._pipeline = undefined;
      this._streamtags = undefined;
      this._systemFields = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._environment = value.environment;
      this._id = value.id;
      this._pipeline = value.pipeline;
      this._streamtags = value.streamtags;
      this._systemFields = value.systemFields;
      this._type = value.type;
    }
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // id - computed: false, optional: false, required: true
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // system_fields - computed: true, optional: true, required: false
  private _systemFields?: string[]; 
  public get systemFields() {
    return this.getListAttribute('system_fields');
  }
  public set systemFields(value: string[]) {
    this._systemFields = value;
  }
  public resetSystemFields() {
    this._systemFields = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get systemFieldsInput() {
    return this._systemFields;
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface DestinationOutputDiskSpool {
  /**
  * Data compression format. Default is gzip. Default: "gzip"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#compress Destination#compress}
  */
  readonly compress?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#description Destination#description}
  */
  readonly description?: string;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#environment Destination#environment}
  */
  readonly environment?: string;
  /**
  * Unique ID for this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#id Destination#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id: string;
  /**
  * Maximum disk space that can be consumed before older buckets are deleted. Examples: 420MB, 4GB. Default is 1GB. Default: "1GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#max_data_size Destination#max_data_size}
  */
  readonly maxDataSize?: string;
  /**
  * Maximum amount of time to retain data before older buckets are deleted. Examples: 2h, 4d. Default is 24h. Default: "24h"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#max_data_time Destination#max_data_time}
  */
  readonly maxDataTime?: string;
  /**
  * JavaScript expression defining how files are partitioned and organized within the time-buckets. If blank, the event's __partition property is used and otherwise, events go directly into the time-bucket directory.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#partition_expr Destination#partition_expr}
  */
  readonly partitionExpr?: string;
  /**
  * Pipeline to process data before sending out to this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pipeline Destination#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#streamtags Destination#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Fields to automatically add to events, such as cribl_pipe. Supports wildcards. Default: ["cribl_pipe"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#system_fields Destination#system_fields}
  */
  readonly systemFields?: string[];
  /**
  * Time period for grouping spooled events. Default is 10m. Default: "10m"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#time_window Destination#time_window}
  */
  readonly timeWindow?: string;
  /**
  * must be "disk_spool"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#type Destination#type}
  */
  readonly type: string;
}

export function destinationOutputDiskSpoolToTerraform(struct?: DestinationOutputDiskSpool | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    compress: cdktf.stringToTerraform(struct!.compress),
    description: cdktf.stringToTerraform(struct!.description),
    environment: cdktf.stringToTerraform(struct!.environment),
    id: cdktf.stringToTerraform(struct!.id),
    max_data_size: cdktf.stringToTerraform(struct!.maxDataSize),
    max_data_time: cdktf.stringToTerraform(struct!.maxDataTime),
    partition_expr: cdktf.stringToTerraform(struct!.partitionExpr),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    system_fields: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.systemFields),
    time_window: cdktf.stringToTerraform(struct!.timeWindow),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function destinationOutputDiskSpoolToHclTerraform(struct?: DestinationOutputDiskSpool | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    compress: {
      value: cdktf.stringToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_data_size: {
      value: cdktf.stringToHclTerraform(struct!.maxDataSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_data_time: {
      value: cdktf.stringToHclTerraform(struct!.maxDataTime),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    partition_expr: {
      value: cdktf.stringToHclTerraform(struct!.partitionExpr),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    system_fields: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.systemFields),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    time_window: {
      value: cdktf.stringToHclTerraform(struct!.timeWindow),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputDiskSpoolOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DestinationOutputDiskSpool | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._maxDataSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxDataSize = this._maxDataSize;
    }
    if (this._maxDataTime !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxDataTime = this._maxDataTime;
    }
    if (this._partitionExpr !== undefined) {
      hasAnyValues = true;
      internalValueResult.partitionExpr = this._partitionExpr;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._systemFields !== undefined) {
      hasAnyValues = true;
      internalValueResult.systemFields = this._systemFields;
    }
    if (this._timeWindow !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeWindow = this._timeWindow;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputDiskSpool | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._compress = undefined;
      this._description = undefined;
      this._environment = undefined;
      this._id = undefined;
      this._maxDataSize = undefined;
      this._maxDataTime = undefined;
      this._partitionExpr = undefined;
      this._pipeline = undefined;
      this._streamtags = undefined;
      this._systemFields = undefined;
      this._timeWindow = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._compress = value.compress;
      this._description = value.description;
      this._environment = value.environment;
      this._id = value.id;
      this._maxDataSize = value.maxDataSize;
      this._maxDataTime = value.maxDataTime;
      this._partitionExpr = value.partitionExpr;
      this._pipeline = value.pipeline;
      this._streamtags = value.streamtags;
      this._systemFields = value.systemFields;
      this._timeWindow = value.timeWindow;
      this._type = value.type;
    }
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: string; 
  public get compress() {
    return this.getStringAttribute('compress');
  }
  public set compress(value: string) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // id - computed: false, optional: false, required: true
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // max_data_size - computed: true, optional: true, required: false
  private _maxDataSize?: string; 
  public get maxDataSize() {
    return this.getStringAttribute('max_data_size');
  }
  public set maxDataSize(value: string) {
    this._maxDataSize = value;
  }
  public resetMaxDataSize() {
    this._maxDataSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxDataSizeInput() {
    return this._maxDataSize;
  }

  // max_data_time - computed: true, optional: true, required: false
  private _maxDataTime?: string; 
  public get maxDataTime() {
    return this.getStringAttribute('max_data_time');
  }
  public set maxDataTime(value: string) {
    this._maxDataTime = value;
  }
  public resetMaxDataTime() {
    this._maxDataTime = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxDataTimeInput() {
    return this._maxDataTime;
  }

  // partition_expr - computed: false, optional: true, required: false
  private _partitionExpr?: string; 
  public get partitionExpr() {
    return this.getStringAttribute('partition_expr');
  }
  public set partitionExpr(value: string) {
    this._partitionExpr = value;
  }
  public resetPartitionExpr() {
    this._partitionExpr = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get partitionExprInput() {
    return this._partitionExpr;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // system_fields - computed: true, optional: true, required: false
  private _systemFields?: string[]; 
  public get systemFields() {
    return this.getListAttribute('system_fields');
  }
  public set systemFields(value: string[]) {
    this._systemFields = value;
  }
  public resetSystemFields() {
    this._systemFields = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get systemFieldsInput() {
    return this._systemFields;
  }

  // time_window - computed: true, optional: true, required: false
  private _timeWindow?: string; 
  public get timeWindow() {
    return this.getStringAttribute('time_window');
  }
  public set timeWindow(value: string) {
    this._timeWindow = value;
  }
  public resetTimeWindow() {
    this._timeWindow = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeWindowInput() {
    return this._timeWindow;
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface DestinationOutputDlS3KeyValueMetadata {
  /**
  * Default: ""
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#key Destination#key}
  */
  readonly key?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#value Destination#value}
  */
  readonly value: string;
}

export function destinationOutputDlS3KeyValueMetadataToTerraform(struct?: DestinationOutputDlS3KeyValueMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function destinationOutputDlS3KeyValueMetadataToHclTerraform(struct?: DestinationOutputDlS3KeyValueMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputDlS3KeyValueMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DestinationOutputDlS3KeyValueMetadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputDlS3KeyValueMetadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._value = value.value;
    }
  }

  // key - computed: true, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DestinationOutputDlS3KeyValueMetadataList extends cdktf.ComplexList {
  public internalValue? : DestinationOutputDlS3KeyValueMetadata[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DestinationOutputDlS3KeyValueMetadataOutputReference {
    return new DestinationOutputDlS3KeyValueMetadataOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DestinationOutputDlS3 {
  /**
  * Add the Output ID value to staging location. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#add_id_to_stage_path Destination#add_id_to_stage_path}
  */
  readonly addIdToStagePath?: boolean | cdktf.IResolvable;
  /**
  * Amazon Resource Name (ARN) of the role to assume
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#assume_role_arn Destination#assume_role_arn}
  */
  readonly assumeRoleArn?: string;
  /**
  * External ID to use when assuming role
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#assume_role_external_id Destination#assume_role_external_id}
  */
  readonly assumeRoleExternalId?: string;
  /**
  * Automatically calculate the schema based on the events of each Parquet file generated. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#automatic_schema Destination#automatic_schema}
  */
  readonly automaticSchema?: boolean | cdktf.IResolvable;
  /**
  * This value can be a constant or a JavaScript expression (`${C.env.SOME_ACCESS_KEY}`)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#aws_api_key Destination#aws_api_key}
  */
  readonly awsApiKey?: string;
  /**
  * AWS authentication method. Choose Auto to use IAM roles. Default: "auto"; must be one of ["auto", "manual", "secret"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#aws_authentication_method Destination#aws_authentication_method}
  */
  readonly awsAuthenticationMethod?: string;
  /**
  * Select or create a stored secret that references your access key and secret key
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#aws_secret Destination#aws_secret}
  */
  readonly awsSecret?: string;
  /**
  * Secret key. This value can be a constant or a JavaScript expression. Example: `${C.env.SOME_SECRET}`)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#aws_secret_key Destination#aws_secret_key}
  */
  readonly awsSecretKey?: string;
  /**
  * JavaScript expression to define the output filename prefix (can be constant). Default: "`CriblOut`"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#base_file_name Destination#base_file_name}
  */
  readonly baseFileName?: string;
  /**
  * Name of the destination S3 bucket. Must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can be evaluated only at initialization time. Example referencing a Global Variable: `myBucket-${C.vars.myVar}`
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#bucket Destination#bucket}
  */
  readonly bucket: string;
  /**
  * Data compression format to apply to HTTP content before it is delivered. Default: "gzip"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#compress Destination#compress}
  */
  readonly compress?: string;
  /**
  * Compression level to apply before moving files to final destination. Default: "best_speed"; must be one of ["best_speed", "normal", "best_compression"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#compression_level Destination#compression_level}
  */
  readonly compressionLevel?: string;
  /**
  * If a file fails to move to its final destination after the maximum number of retries, move it to a designated directory to prevent further errors. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#deadletter_enabled Destination#deadletter_enabled}
  */
  readonly deadletterEnabled?: boolean | cdktf.IResolvable;
  /**
  * Storage location for files that fail to reach their final destination after maximum retries are exceeded. Default: "$CRIBL_HOME/state/outputs/dead-letter"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#deadletter_path Destination#deadletter_path}
  */
  readonly deadletterPath?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#description Destination#description}
  */
  readonly description?: string;
  /**
  * Prefix to append to files before uploading. Must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can be evaluated only at init time. Example referencing a Global Variable: `myKeyPrefix-${C.vars.myVar}`. Default: ""
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#dest_path Destination#dest_path}
  */
  readonly destPath?: string;
  /**
  * Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours). Default: 3600
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#duration_seconds Destination#duration_seconds}
  */
  readonly durationSeconds?: number;
  /**
  * How frequently, in seconds, to clean up empty directories. Default: 300
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#empty_dir_cleanup_sec Destination#empty_dir_cleanup_sec}
  */
  readonly emptyDirCleanupSec?: number;
  /**
  * Use Assume Role credentials to access S3. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#enable_assume_role Destination#enable_assume_role}
  */
  readonly enableAssumeRole?: boolean | cdktf.IResolvable;
  /**
  * Parquet tools can use the checksum of a Parquet page to verify data integrity. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#enable_page_checksum Destination#enable_page_checksum}
  */
  readonly enablePageChecksum?: boolean | cdktf.IResolvable;
  /**
  * Statistics profile an entire file in terms of minimum/maximum values within data, numbers of nulls, etc. You can use Parquet tools to view statistics. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#enable_statistics Destination#enable_statistics}
  */
  readonly enableStatistics?: boolean | cdktf.IResolvable;
  /**
  * One page index contains statistics for one data page. Parquet readers use statistics to enable page skipping. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#enable_write_page_index Destination#enable_write_page_index}
  */
  readonly enableWritePageIndex?: boolean | cdktf.IResolvable;
  /**
  * S3 service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to S3-compatible endpoint.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#endpoint Destination#endpoint}
  */
  readonly endpoint?: string;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#environment Destination#environment}
  */
  readonly environment?: string;
  /**
  * JavaScript expression to define the output filename suffix (can be constant).  The `__format` variable refers to the value of the `Data format` field (`json` or `raw`).  The `__compression` field refers to the kind of compression being used (`none` or `gzip`). Default: "`.${C.env[\"CRIBL_WORKER_ID\"]}.${__format}${__compression === \"gzip\" ? \".gz\" : \"\"}`"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#file_name_suffix Destination#file_name_suffix}
  */
  readonly fileNameSuffix?: string;
  /**
  * Format of the output data. Default: "json"; must be one of ["json", "raw", "parquet"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#format Destination#format}
  */
  readonly format?: string;
  /**
  * If set, this line will be written to the beginning of each output file. Default: ""
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#header_line Destination#header_line}
  */
  readonly headerLine?: string;
  /**
  * Unique ID for this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#id Destination#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * The metadata of files the Destination writes will include the properties you add here as key-value pairs. Useful for tagging. Examples: "key":"OCSF Event Class", "value":"9001"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#key_value_metadata Destination#key_value_metadata}
  */
  readonly keyValueMetadata?: DestinationOutputDlS3KeyValueMetadata[] | cdktf.IResolvable;
  /**
  * ID or ARN of the KMS customer-managed key to use for encryption
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#kms_key_id Destination#kms_key_id}
  */
  readonly kmsKeyId?: string;
  /**
  * Maximum number of files that can be waiting for upload before backpressure is applied. Default: 100
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#max_closing_files_to_backpressure Destination#max_closing_files_to_backpressure}
  */
  readonly maxClosingFilesToBackpressure?: number;
  /**
  * Maximum number of parts to upload in parallel per file. Minimum part size is 5MB. Default: 4
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#max_concurrent_file_parts Destination#max_concurrent_file_parts}
  */
  readonly maxConcurrentFileParts?: number;
  /**
  * Maximum amount of time to keep inactive files open. Files open for longer than this will be closed and moved to final output location. Default: 30
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#max_file_idle_time_sec Destination#max_file_idle_time_sec}
  */
  readonly maxFileIdleTimeSec?: number;
  /**
  * Maximum amount of time to write to a file. Files open for longer than this will be closed and moved to final output location. Default: 300
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#max_file_open_time_sec Destination#max_file_open_time_sec}
  */
  readonly maxFileOpenTimeSec?: number;
  /**
  * Maximum uncompressed output file size. Files of this size will be closed and moved to final output location. Default: 32
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#max_file_size_mb Destination#max_file_size_mb}
  */
  readonly maxFileSizeMb?: number;
  /**
  * Maximum number of files to keep open concurrently. When exceeded, @{product} will close the oldest open files and move them to the final output location. Default: 100
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#max_open_files Destination#max_open_files}
  */
  readonly maxOpenFiles?: number;
  /**
  * The maximum number of times a file will attempt to move to its final destination before being dead-lettered. Default: 20
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#max_retry_num Destination#max_retry_num}
  */
  readonly maxRetryNum?: number;
  /**
  * Object ACL to assign to uploaded objects. Default: "private"; must be one of ["private", "public-read", "public-read-write", "authenticated-read", "aws-exec-read", "bucket-owner-read", "bucket-owner-full-control"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#object_acl Destination#object_acl}
  */
  readonly objectAcl?: string;
  /**
  * How to handle events when disk space is below the global 'Min free disk space' limit. Default: "block"; must be one of ["block", "drop"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#on_disk_full_backpressure Destination#on_disk_full_backpressure}
  */
  readonly onDiskFullBackpressure?: string;
  /**
  * Serialization format of data pages. Note that some reader implementations use Data page V2's attributes to work more efficiently, while others ignore it. Default: "DATA_PAGE_V2"; must be one of ["DATA_PAGE_V1", "DATA_PAGE_V2"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#parquet_data_page_version Destination#parquet_data_page_version}
  */
  readonly parquetDataPageVersion?: string;
  /**
  * Target memory size for page segments, such as 1MB or 128MB. Generally, lower values improve reading speed, while higher values improve compression. Default: "1MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#parquet_page_size Destination#parquet_page_size}
  */
  readonly parquetPageSize?: string;
  /**
  * The number of rows that every group will contain. The final group can contain a smaller number of rows. Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#parquet_row_group_length Destination#parquet_row_group_length}
  */
  readonly parquetRowGroupLength?: number;
  /**
  * Determines which data types are supported and how they are represented. Default: "PARQUET_2_6"; must be one of ["PARQUET_1_0", "PARQUET_2_4", "PARQUET_2_6"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#parquet_version Destination#parquet_version}
  */
  readonly parquetVersion?: string;
  /**
  * List of fields to partition the path by, in addition to time, which is included automatically. The effective partition will be YYYY/MM/DD/HH/<list/of/fields>. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#partitioning_fields Destination#partitioning_fields}
  */
  readonly partitioningFields?: string[];
  /**
  * Pipeline to process data before sending out to this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pipeline Destination#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Region where the S3 bucket is located
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#region Destination#region}
  */
  readonly region?: string;
  /**
  * Reject certificates that cannot be verified against a valid CA, such as self-signed certificates. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#reject_unauthorized Destination#reject_unauthorized}
  */
  readonly rejectUnauthorized?: boolean | cdktf.IResolvable;
  /**
  * Remove empty staging directories after moving files. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#remove_empty_dirs Destination#remove_empty_dirs}
  */
  readonly removeEmptyDirs?: boolean | cdktf.IResolvable;
  /**
  * Reuse connections between requests, which can improve performance. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#reuse_connections Destination#reuse_connections}
  */
  readonly reuseConnections?: boolean | cdktf.IResolvable;
  /**
  * must be one of ["AES256", "aws:kms"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#server_side_encryption Destination#server_side_encryption}
  */
  readonly serverSideEncryption?: string;
  /**
  * Log up to 3 rows that @{product} skips due to data mismatch
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#should_log_invalid_rows Destination#should_log_invalid_rows}
  */
  readonly shouldLogInvalidRows?: boolean | cdktf.IResolvable;
  /**
  * Signature version to use for signing S3 requests. Default: "v4"; must be one of ["v2", "v4"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#signature_version Destination#signature_version}
  */
  readonly signatureVersion?: string;
  /**
  * Filesystem location in which to buffer files, before compressing and moving to final destination. Use performant and stable storage. Default: "$CRIBL_HOME/state/outputs/staging"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#stage_path Destination#stage_path}
  */
  readonly stagePath?: string;
  /**
  * Storage class to select for uploaded objects. must be one of ["STANDARD", "REDUCED_REDUNDANCY", "STANDARD_IA", "ONEZONE_IA", "INTELLIGENT_TIERING", "GLACIER", "GLACIER_IR", "DEEP_ARCHIVE"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#storage_class Destination#storage_class}
  */
  readonly storageClass?: string;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#streamtags Destination#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Fields to automatically add to events, such as cribl_pipe. Supports wildcards. Default: ["cribl_pipe"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#system_fields Destination#system_fields}
  */
  readonly systemFields?: string[];
  /**
  * must be "dl_s3"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#type Destination#type}
  */
  readonly type?: string;
  /**
  * Disable if you can access files within the bucket but not the bucket itself. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#verify_permissions Destination#verify_permissions}
  */
  readonly verifyPermissions?: boolean | cdktf.IResolvable;
  /**
  * Buffer size used to write to a file. Default: 64
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#write_high_water_mark Destination#write_high_water_mark}
  */
  readonly writeHighWaterMark?: number;
}

export function destinationOutputDlS3ToTerraform(struct?: DestinationOutputDlS3 | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    add_id_to_stage_path: cdktf.booleanToTerraform(struct!.addIdToStagePath),
    assume_role_arn: cdktf.stringToTerraform(struct!.assumeRoleArn),
    assume_role_external_id: cdktf.stringToTerraform(struct!.assumeRoleExternalId),
    automatic_schema: cdktf.booleanToTerraform(struct!.automaticSchema),
    aws_api_key: cdktf.stringToTerraform(struct!.awsApiKey),
    aws_authentication_method: cdktf.stringToTerraform(struct!.awsAuthenticationMethod),
    aws_secret: cdktf.stringToTerraform(struct!.awsSecret),
    aws_secret_key: cdktf.stringToTerraform(struct!.awsSecretKey),
    base_file_name: cdktf.stringToTerraform(struct!.baseFileName),
    bucket: cdktf.stringToTerraform(struct!.bucket),
    compress: cdktf.stringToTerraform(struct!.compress),
    compression_level: cdktf.stringToTerraform(struct!.compressionLevel),
    deadletter_enabled: cdktf.booleanToTerraform(struct!.deadletterEnabled),
    deadletter_path: cdktf.stringToTerraform(struct!.deadletterPath),
    description: cdktf.stringToTerraform(struct!.description),
    dest_path: cdktf.stringToTerraform(struct!.destPath),
    duration_seconds: cdktf.numberToTerraform(struct!.durationSeconds),
    empty_dir_cleanup_sec: cdktf.numberToTerraform(struct!.emptyDirCleanupSec),
    enable_assume_role: cdktf.booleanToTerraform(struct!.enableAssumeRole),
    enable_page_checksum: cdktf.booleanToTerraform(struct!.enablePageChecksum),
    enable_statistics: cdktf.booleanToTerraform(struct!.enableStatistics),
    enable_write_page_index: cdktf.booleanToTerraform(struct!.enableWritePageIndex),
    endpoint: cdktf.stringToTerraform(struct!.endpoint),
    environment: cdktf.stringToTerraform(struct!.environment),
    file_name_suffix: cdktf.stringToTerraform(struct!.fileNameSuffix),
    format: cdktf.stringToTerraform(struct!.format),
    header_line: cdktf.stringToTerraform(struct!.headerLine),
    id: cdktf.stringToTerraform(struct!.id),
    key_value_metadata: cdktf.listMapper(destinationOutputDlS3KeyValueMetadataToTerraform, false)(struct!.keyValueMetadata),
    kms_key_id: cdktf.stringToTerraform(struct!.kmsKeyId),
    max_closing_files_to_backpressure: cdktf.numberToTerraform(struct!.maxClosingFilesToBackpressure),
    max_concurrent_file_parts: cdktf.numberToTerraform(struct!.maxConcurrentFileParts),
    max_file_idle_time_sec: cdktf.numberToTerraform(struct!.maxFileIdleTimeSec),
    max_file_open_time_sec: cdktf.numberToTerraform(struct!.maxFileOpenTimeSec),
    max_file_size_mb: cdktf.numberToTerraform(struct!.maxFileSizeMb),
    max_open_files: cdktf.numberToTerraform(struct!.maxOpenFiles),
    max_retry_num: cdktf.numberToTerraform(struct!.maxRetryNum),
    object_acl: cdktf.stringToTerraform(struct!.objectAcl),
    on_disk_full_backpressure: cdktf.stringToTerraform(struct!.onDiskFullBackpressure),
    parquet_data_page_version: cdktf.stringToTerraform(struct!.parquetDataPageVersion),
    parquet_page_size: cdktf.stringToTerraform(struct!.parquetPageSize),
    parquet_row_group_length: cdktf.numberToTerraform(struct!.parquetRowGroupLength),
    parquet_version: cdktf.stringToTerraform(struct!.parquetVersion),
    partitioning_fields: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.partitioningFields),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    region: cdktf.stringToTerraform(struct!.region),
    reject_unauthorized: cdktf.booleanToTerraform(struct!.rejectUnauthorized),
    remove_empty_dirs: cdktf.booleanToTerraform(struct!.removeEmptyDirs),
    reuse_connections: cdktf.booleanToTerraform(struct!.reuseConnections),
    server_side_encryption: cdktf.stringToTerraform(struct!.serverSideEncryption),
    should_log_invalid_rows: cdktf.booleanToTerraform(struct!.shouldLogInvalidRows),
    signature_version: cdktf.stringToTerraform(struct!.signatureVersion),
    stage_path: cdktf.stringToTerraform(struct!.stagePath),
    storage_class: cdktf.stringToTerraform(struct!.storageClass),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    system_fields: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.systemFields),
    type: cdktf.stringToTerraform(struct!.type),
    verify_permissions: cdktf.booleanToTerraform(struct!.verifyPermissions),
    write_high_water_mark: cdktf.numberToTerraform(struct!.writeHighWaterMark),
  }
}


export function destinationOutputDlS3ToHclTerraform(struct?: DestinationOutputDlS3 | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    add_id_to_stage_path: {
      value: cdktf.booleanToHclTerraform(struct!.addIdToStagePath),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    assume_role_arn: {
      value: cdktf.stringToHclTerraform(struct!.assumeRoleArn),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    assume_role_external_id: {
      value: cdktf.stringToHclTerraform(struct!.assumeRoleExternalId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    automatic_schema: {
      value: cdktf.booleanToHclTerraform(struct!.automaticSchema),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    aws_api_key: {
      value: cdktf.stringToHclTerraform(struct!.awsApiKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    aws_authentication_method: {
      value: cdktf.stringToHclTerraform(struct!.awsAuthenticationMethod),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    aws_secret: {
      value: cdktf.stringToHclTerraform(struct!.awsSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    aws_secret_key: {
      value: cdktf.stringToHclTerraform(struct!.awsSecretKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    base_file_name: {
      value: cdktf.stringToHclTerraform(struct!.baseFileName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    bucket: {
      value: cdktf.stringToHclTerraform(struct!.bucket),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    compress: {
      value: cdktf.stringToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    compression_level: {
      value: cdktf.stringToHclTerraform(struct!.compressionLevel),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    deadletter_enabled: {
      value: cdktf.booleanToHclTerraform(struct!.deadletterEnabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    deadletter_path: {
      value: cdktf.stringToHclTerraform(struct!.deadletterPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    dest_path: {
      value: cdktf.stringToHclTerraform(struct!.destPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    duration_seconds: {
      value: cdktf.numberToHclTerraform(struct!.durationSeconds),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    empty_dir_cleanup_sec: {
      value: cdktf.numberToHclTerraform(struct!.emptyDirCleanupSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    enable_assume_role: {
      value: cdktf.booleanToHclTerraform(struct!.enableAssumeRole),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    enable_page_checksum: {
      value: cdktf.booleanToHclTerraform(struct!.enablePageChecksum),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    enable_statistics: {
      value: cdktf.booleanToHclTerraform(struct!.enableStatistics),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    enable_write_page_index: {
      value: cdktf.booleanToHclTerraform(struct!.enableWritePageIndex),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    endpoint: {
      value: cdktf.stringToHclTerraform(struct!.endpoint),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    file_name_suffix: {
      value: cdktf.stringToHclTerraform(struct!.fileNameSuffix),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    format: {
      value: cdktf.stringToHclTerraform(struct!.format),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    header_line: {
      value: cdktf.stringToHclTerraform(struct!.headerLine),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    key_value_metadata: {
      value: cdktf.listMapperHcl(destinationOutputDlS3KeyValueMetadataToHclTerraform, false)(struct!.keyValueMetadata),
      isBlock: true,
      type: "list",
      storageClassType: "DestinationOutputDlS3KeyValueMetadataList",
    },
    kms_key_id: {
      value: cdktf.stringToHclTerraform(struct!.kmsKeyId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_closing_files_to_backpressure: {
      value: cdktf.numberToHclTerraform(struct!.maxClosingFilesToBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_concurrent_file_parts: {
      value: cdktf.numberToHclTerraform(struct!.maxConcurrentFileParts),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_file_idle_time_sec: {
      value: cdktf.numberToHclTerraform(struct!.maxFileIdleTimeSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_file_open_time_sec: {
      value: cdktf.numberToHclTerraform(struct!.maxFileOpenTimeSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_file_size_mb: {
      value: cdktf.numberToHclTerraform(struct!.maxFileSizeMb),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_open_files: {
      value: cdktf.numberToHclTerraform(struct!.maxOpenFiles),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_retry_num: {
      value: cdktf.numberToHclTerraform(struct!.maxRetryNum),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    object_acl: {
      value: cdktf.stringToHclTerraform(struct!.objectAcl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    on_disk_full_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.onDiskFullBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    parquet_data_page_version: {
      value: cdktf.stringToHclTerraform(struct!.parquetDataPageVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    parquet_page_size: {
      value: cdktf.stringToHclTerraform(struct!.parquetPageSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    parquet_row_group_length: {
      value: cdktf.numberToHclTerraform(struct!.parquetRowGroupLength),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    parquet_version: {
      value: cdktf.stringToHclTerraform(struct!.parquetVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    partitioning_fields: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.partitioningFields),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    region: {
      value: cdktf.stringToHclTerraform(struct!.region),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reject_unauthorized: {
      value: cdktf.booleanToHclTerraform(struct!.rejectUnauthorized),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    remove_empty_dirs: {
      value: cdktf.booleanToHclTerraform(struct!.removeEmptyDirs),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    reuse_connections: {
      value: cdktf.booleanToHclTerraform(struct!.reuseConnections),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    server_side_encryption: {
      value: cdktf.stringToHclTerraform(struct!.serverSideEncryption),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    should_log_invalid_rows: {
      value: cdktf.booleanToHclTerraform(struct!.shouldLogInvalidRows),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    signature_version: {
      value: cdktf.stringToHclTerraform(struct!.signatureVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    stage_path: {
      value: cdktf.stringToHclTerraform(struct!.stagePath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    storage_class: {
      value: cdktf.stringToHclTerraform(struct!.storageClass),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    system_fields: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.systemFields),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    verify_permissions: {
      value: cdktf.booleanToHclTerraform(struct!.verifyPermissions),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    write_high_water_mark: {
      value: cdktf.numberToHclTerraform(struct!.writeHighWaterMark),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputDlS3OutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DestinationOutputDlS3 | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._addIdToStagePath !== undefined) {
      hasAnyValues = true;
      internalValueResult.addIdToStagePath = this._addIdToStagePath;
    }
    if (this._assumeRoleArn !== undefined) {
      hasAnyValues = true;
      internalValueResult.assumeRoleArn = this._assumeRoleArn;
    }
    if (this._assumeRoleExternalId !== undefined) {
      hasAnyValues = true;
      internalValueResult.assumeRoleExternalId = this._assumeRoleExternalId;
    }
    if (this._automaticSchema !== undefined) {
      hasAnyValues = true;
      internalValueResult.automaticSchema = this._automaticSchema;
    }
    if (this._awsApiKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.awsApiKey = this._awsApiKey;
    }
    if (this._awsAuthenticationMethod !== undefined) {
      hasAnyValues = true;
      internalValueResult.awsAuthenticationMethod = this._awsAuthenticationMethod;
    }
    if (this._awsSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.awsSecret = this._awsSecret;
    }
    if (this._awsSecretKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.awsSecretKey = this._awsSecretKey;
    }
    if (this._baseFileName !== undefined) {
      hasAnyValues = true;
      internalValueResult.baseFileName = this._baseFileName;
    }
    if (this._bucket !== undefined) {
      hasAnyValues = true;
      internalValueResult.bucket = this._bucket;
    }
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._compressionLevel !== undefined) {
      hasAnyValues = true;
      internalValueResult.compressionLevel = this._compressionLevel;
    }
    if (this._deadletterEnabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.deadletterEnabled = this._deadletterEnabled;
    }
    if (this._deadletterPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.deadletterPath = this._deadletterPath;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._destPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.destPath = this._destPath;
    }
    if (this._durationSeconds !== undefined) {
      hasAnyValues = true;
      internalValueResult.durationSeconds = this._durationSeconds;
    }
    if (this._emptyDirCleanupSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.emptyDirCleanupSec = this._emptyDirCleanupSec;
    }
    if (this._enableAssumeRole !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableAssumeRole = this._enableAssumeRole;
    }
    if (this._enablePageChecksum !== undefined) {
      hasAnyValues = true;
      internalValueResult.enablePageChecksum = this._enablePageChecksum;
    }
    if (this._enableStatistics !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableStatistics = this._enableStatistics;
    }
    if (this._enableWritePageIndex !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableWritePageIndex = this._enableWritePageIndex;
    }
    if (this._endpoint !== undefined) {
      hasAnyValues = true;
      internalValueResult.endpoint = this._endpoint;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._fileNameSuffix !== undefined) {
      hasAnyValues = true;
      internalValueResult.fileNameSuffix = this._fileNameSuffix;
    }
    if (this._format !== undefined) {
      hasAnyValues = true;
      internalValueResult.format = this._format;
    }
    if (this._headerLine !== undefined) {
      hasAnyValues = true;
      internalValueResult.headerLine = this._headerLine;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._keyValueMetadata?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.keyValueMetadata = this._keyValueMetadata?.internalValue;
    }
    if (this._kmsKeyId !== undefined) {
      hasAnyValues = true;
      internalValueResult.kmsKeyId = this._kmsKeyId;
    }
    if (this._maxClosingFilesToBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxClosingFilesToBackpressure = this._maxClosingFilesToBackpressure;
    }
    if (this._maxConcurrentFileParts !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxConcurrentFileParts = this._maxConcurrentFileParts;
    }
    if (this._maxFileIdleTimeSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxFileIdleTimeSec = this._maxFileIdleTimeSec;
    }
    if (this._maxFileOpenTimeSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxFileOpenTimeSec = this._maxFileOpenTimeSec;
    }
    if (this._maxFileSizeMb !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxFileSizeMb = this._maxFileSizeMb;
    }
    if (this._maxOpenFiles !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxOpenFiles = this._maxOpenFiles;
    }
    if (this._maxRetryNum !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxRetryNum = this._maxRetryNum;
    }
    if (this._objectAcl !== undefined) {
      hasAnyValues = true;
      internalValueResult.objectAcl = this._objectAcl;
    }
    if (this._onDiskFullBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.onDiskFullBackpressure = this._onDiskFullBackpressure;
    }
    if (this._parquetDataPageVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.parquetDataPageVersion = this._parquetDataPageVersion;
    }
    if (this._parquetPageSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.parquetPageSize = this._parquetPageSize;
    }
    if (this._parquetRowGroupLength !== undefined) {
      hasAnyValues = true;
      internalValueResult.parquetRowGroupLength = this._parquetRowGroupLength;
    }
    if (this._parquetVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.parquetVersion = this._parquetVersion;
    }
    if (this._partitioningFields !== undefined) {
      hasAnyValues = true;
      internalValueResult.partitioningFields = this._partitioningFields;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._region !== undefined) {
      hasAnyValues = true;
      internalValueResult.region = this._region;
    }
    if (this._rejectUnauthorized !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectUnauthorized = this._rejectUnauthorized;
    }
    if (this._removeEmptyDirs !== undefined) {
      hasAnyValues = true;
      internalValueResult.removeEmptyDirs = this._removeEmptyDirs;
    }
    if (this._reuseConnections !== undefined) {
      hasAnyValues = true;
      internalValueResult.reuseConnections = this._reuseConnections;
    }
    if (this._serverSideEncryption !== undefined) {
      hasAnyValues = true;
      internalValueResult.serverSideEncryption = this._serverSideEncryption;
    }
    if (this._shouldLogInvalidRows !== undefined) {
      hasAnyValues = true;
      internalValueResult.shouldLogInvalidRows = this._shouldLogInvalidRows;
    }
    if (this._signatureVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.signatureVersion = this._signatureVersion;
    }
    if (this._stagePath !== undefined) {
      hasAnyValues = true;
      internalValueResult.stagePath = this._stagePath;
    }
    if (this._storageClass !== undefined) {
      hasAnyValues = true;
      internalValueResult.storageClass = this._storageClass;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._systemFields !== undefined) {
      hasAnyValues = true;
      internalValueResult.systemFields = this._systemFields;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._verifyPermissions !== undefined) {
      hasAnyValues = true;
      internalValueResult.verifyPermissions = this._verifyPermissions;
    }
    if (this._writeHighWaterMark !== undefined) {
      hasAnyValues = true;
      internalValueResult.writeHighWaterMark = this._writeHighWaterMark;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputDlS3 | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._addIdToStagePath = undefined;
      this._assumeRoleArn = undefined;
      this._assumeRoleExternalId = undefined;
      this._automaticSchema = undefined;
      this._awsApiKey = undefined;
      this._awsAuthenticationMethod = undefined;
      this._awsSecret = undefined;
      this._awsSecretKey = undefined;
      this._baseFileName = undefined;
      this._bucket = undefined;
      this._compress = undefined;
      this._compressionLevel = undefined;
      this._deadletterEnabled = undefined;
      this._deadletterPath = undefined;
      this._description = undefined;
      this._destPath = undefined;
      this._durationSeconds = undefined;
      this._emptyDirCleanupSec = undefined;
      this._enableAssumeRole = undefined;
      this._enablePageChecksum = undefined;
      this._enableStatistics = undefined;
      this._enableWritePageIndex = undefined;
      this._endpoint = undefined;
      this._environment = undefined;
      this._fileNameSuffix = undefined;
      this._format = undefined;
      this._headerLine = undefined;
      this._id = undefined;
      this._keyValueMetadata.internalValue = undefined;
      this._kmsKeyId = undefined;
      this._maxClosingFilesToBackpressure = undefined;
      this._maxConcurrentFileParts = undefined;
      this._maxFileIdleTimeSec = undefined;
      this._maxFileOpenTimeSec = undefined;
      this._maxFileSizeMb = undefined;
      this._maxOpenFiles = undefined;
      this._maxRetryNum = undefined;
      this._objectAcl = undefined;
      this._onDiskFullBackpressure = undefined;
      this._parquetDataPageVersion = undefined;
      this._parquetPageSize = undefined;
      this._parquetRowGroupLength = undefined;
      this._parquetVersion = undefined;
      this._partitioningFields = undefined;
      this._pipeline = undefined;
      this._region = undefined;
      this._rejectUnauthorized = undefined;
      this._removeEmptyDirs = undefined;
      this._reuseConnections = undefined;
      this._serverSideEncryption = undefined;
      this._shouldLogInvalidRows = undefined;
      this._signatureVersion = undefined;
      this._stagePath = undefined;
      this._storageClass = undefined;
      this._streamtags = undefined;
      this._systemFields = undefined;
      this._type = undefined;
      this._verifyPermissions = undefined;
      this._writeHighWaterMark = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._addIdToStagePath = value.addIdToStagePath;
      this._assumeRoleArn = value.assumeRoleArn;
      this._assumeRoleExternalId = value.assumeRoleExternalId;
      this._automaticSchema = value.automaticSchema;
      this._awsApiKey = value.awsApiKey;
      this._awsAuthenticationMethod = value.awsAuthenticationMethod;
      this._awsSecret = value.awsSecret;
      this._awsSecretKey = value.awsSecretKey;
      this._baseFileName = value.baseFileName;
      this._bucket = value.bucket;
      this._compress = value.compress;
      this._compressionLevel = value.compressionLevel;
      this._deadletterEnabled = value.deadletterEnabled;
      this._deadletterPath = value.deadletterPath;
      this._description = value.description;
      this._destPath = value.destPath;
      this._durationSeconds = value.durationSeconds;
      this._emptyDirCleanupSec = value.emptyDirCleanupSec;
      this._enableAssumeRole = value.enableAssumeRole;
      this._enablePageChecksum = value.enablePageChecksum;
      this._enableStatistics = value.enableStatistics;
      this._enableWritePageIndex = value.enableWritePageIndex;
      this._endpoint = value.endpoint;
      this._environment = value.environment;
      this._fileNameSuffix = value.fileNameSuffix;
      this._format = value.format;
      this._headerLine = value.headerLine;
      this._id = value.id;
      this._keyValueMetadata.internalValue = value.keyValueMetadata;
      this._kmsKeyId = value.kmsKeyId;
      this._maxClosingFilesToBackpressure = value.maxClosingFilesToBackpressure;
      this._maxConcurrentFileParts = value.maxConcurrentFileParts;
      this._maxFileIdleTimeSec = value.maxFileIdleTimeSec;
      this._maxFileOpenTimeSec = value.maxFileOpenTimeSec;
      this._maxFileSizeMb = value.maxFileSizeMb;
      this._maxOpenFiles = value.maxOpenFiles;
      this._maxRetryNum = value.maxRetryNum;
      this._objectAcl = value.objectAcl;
      this._onDiskFullBackpressure = value.onDiskFullBackpressure;
      this._parquetDataPageVersion = value.parquetDataPageVersion;
      this._parquetPageSize = value.parquetPageSize;
      this._parquetRowGroupLength = value.parquetRowGroupLength;
      this._parquetVersion = value.parquetVersion;
      this._partitioningFields = value.partitioningFields;
      this._pipeline = value.pipeline;
      this._region = value.region;
      this._rejectUnauthorized = value.rejectUnauthorized;
      this._removeEmptyDirs = value.removeEmptyDirs;
      this._reuseConnections = value.reuseConnections;
      this._serverSideEncryption = value.serverSideEncryption;
      this._shouldLogInvalidRows = value.shouldLogInvalidRows;
      this._signatureVersion = value.signatureVersion;
      this._stagePath = value.stagePath;
      this._storageClass = value.storageClass;
      this._streamtags = value.streamtags;
      this._systemFields = value.systemFields;
      this._type = value.type;
      this._verifyPermissions = value.verifyPermissions;
      this._writeHighWaterMark = value.writeHighWaterMark;
    }
  }

  // add_id_to_stage_path - computed: true, optional: true, required: false
  private _addIdToStagePath?: boolean | cdktf.IResolvable; 
  public get addIdToStagePath() {
    return this.getBooleanAttribute('add_id_to_stage_path');
  }
  public set addIdToStagePath(value: boolean | cdktf.IResolvable) {
    this._addIdToStagePath = value;
  }
  public resetAddIdToStagePath() {
    this._addIdToStagePath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addIdToStagePathInput() {
    return this._addIdToStagePath;
  }

  // assume_role_arn - computed: false, optional: true, required: false
  private _assumeRoleArn?: string; 
  public get assumeRoleArn() {
    return this.getStringAttribute('assume_role_arn');
  }
  public set assumeRoleArn(value: string) {
    this._assumeRoleArn = value;
  }
  public resetAssumeRoleArn() {
    this._assumeRoleArn = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get assumeRoleArnInput() {
    return this._assumeRoleArn;
  }

  // assume_role_external_id - computed: false, optional: true, required: false
  private _assumeRoleExternalId?: string; 
  public get assumeRoleExternalId() {
    return this.getStringAttribute('assume_role_external_id');
  }
  public set assumeRoleExternalId(value: string) {
    this._assumeRoleExternalId = value;
  }
  public resetAssumeRoleExternalId() {
    this._assumeRoleExternalId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get assumeRoleExternalIdInput() {
    return this._assumeRoleExternalId;
  }

  // automatic_schema - computed: true, optional: true, required: false
  private _automaticSchema?: boolean | cdktf.IResolvable; 
  public get automaticSchema() {
    return this.getBooleanAttribute('automatic_schema');
  }
  public set automaticSchema(value: boolean | cdktf.IResolvable) {
    this._automaticSchema = value;
  }
  public resetAutomaticSchema() {
    this._automaticSchema = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get automaticSchemaInput() {
    return this._automaticSchema;
  }

  // aws_api_key - computed: false, optional: true, required: false
  private _awsApiKey?: string; 
  public get awsApiKey() {
    return this.getStringAttribute('aws_api_key');
  }
  public set awsApiKey(value: string) {
    this._awsApiKey = value;
  }
  public resetAwsApiKey() {
    this._awsApiKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsApiKeyInput() {
    return this._awsApiKey;
  }

  // aws_authentication_method - computed: true, optional: true, required: false
  private _awsAuthenticationMethod?: string; 
  public get awsAuthenticationMethod() {
    return this.getStringAttribute('aws_authentication_method');
  }
  public set awsAuthenticationMethod(value: string) {
    this._awsAuthenticationMethod = value;
  }
  public resetAwsAuthenticationMethod() {
    this._awsAuthenticationMethod = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsAuthenticationMethodInput() {
    return this._awsAuthenticationMethod;
  }

  // aws_secret - computed: false, optional: true, required: false
  private _awsSecret?: string; 
  public get awsSecret() {
    return this.getStringAttribute('aws_secret');
  }
  public set awsSecret(value: string) {
    this._awsSecret = value;
  }
  public resetAwsSecret() {
    this._awsSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsSecretInput() {
    return this._awsSecret;
  }

  // aws_secret_key - computed: false, optional: true, required: false
  private _awsSecretKey?: string; 
  public get awsSecretKey() {
    return this.getStringAttribute('aws_secret_key');
  }
  public set awsSecretKey(value: string) {
    this._awsSecretKey = value;
  }
  public resetAwsSecretKey() {
    this._awsSecretKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsSecretKeyInput() {
    return this._awsSecretKey;
  }

  // base_file_name - computed: true, optional: true, required: false
  private _baseFileName?: string; 
  public get baseFileName() {
    return this.getStringAttribute('base_file_name');
  }
  public set baseFileName(value: string) {
    this._baseFileName = value;
  }
  public resetBaseFileName() {
    this._baseFileName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get baseFileNameInput() {
    return this._baseFileName;
  }

  // bucket - computed: false, optional: false, required: true
  private _bucket?: string; 
  public get bucket() {
    return this.getStringAttribute('bucket');
  }
  public set bucket(value: string) {
    this._bucket = value;
  }
  // Temporarily expose input value. Use with caution.
  public get bucketInput() {
    return this._bucket;
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: string; 
  public get compress() {
    return this.getStringAttribute('compress');
  }
  public set compress(value: string) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // compression_level - computed: true, optional: true, required: false
  private _compressionLevel?: string; 
  public get compressionLevel() {
    return this.getStringAttribute('compression_level');
  }
  public set compressionLevel(value: string) {
    this._compressionLevel = value;
  }
  public resetCompressionLevel() {
    this._compressionLevel = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressionLevelInput() {
    return this._compressionLevel;
  }

  // deadletter_enabled - computed: true, optional: true, required: false
  private _deadletterEnabled?: boolean | cdktf.IResolvable; 
  public get deadletterEnabled() {
    return this.getBooleanAttribute('deadletter_enabled');
  }
  public set deadletterEnabled(value: boolean | cdktf.IResolvable) {
    this._deadletterEnabled = value;
  }
  public resetDeadletterEnabled() {
    this._deadletterEnabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get deadletterEnabledInput() {
    return this._deadletterEnabled;
  }

  // deadletter_path - computed: true, optional: true, required: false
  private _deadletterPath?: string; 
  public get deadletterPath() {
    return this.getStringAttribute('deadletter_path');
  }
  public set deadletterPath(value: string) {
    this._deadletterPath = value;
  }
  public resetDeadletterPath() {
    this._deadletterPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get deadletterPathInput() {
    return this._deadletterPath;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // dest_path - computed: true, optional: true, required: false
  private _destPath?: string; 
  public get destPath() {
    return this.getStringAttribute('dest_path');
  }
  public set destPath(value: string) {
    this._destPath = value;
  }
  public resetDestPath() {
    this._destPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get destPathInput() {
    return this._destPath;
  }

  // duration_seconds - computed: true, optional: true, required: false
  private _durationSeconds?: number; 
  public get durationSeconds() {
    return this.getNumberAttribute('duration_seconds');
  }
  public set durationSeconds(value: number) {
    this._durationSeconds = value;
  }
  public resetDurationSeconds() {
    this._durationSeconds = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get durationSecondsInput() {
    return this._durationSeconds;
  }

  // empty_dir_cleanup_sec - computed: true, optional: true, required: false
  private _emptyDirCleanupSec?: number; 
  public get emptyDirCleanupSec() {
    return this.getNumberAttribute('empty_dir_cleanup_sec');
  }
  public set emptyDirCleanupSec(value: number) {
    this._emptyDirCleanupSec = value;
  }
  public resetEmptyDirCleanupSec() {
    this._emptyDirCleanupSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get emptyDirCleanupSecInput() {
    return this._emptyDirCleanupSec;
  }

  // enable_assume_role - computed: true, optional: true, required: false
  private _enableAssumeRole?: boolean | cdktf.IResolvable; 
  public get enableAssumeRole() {
    return this.getBooleanAttribute('enable_assume_role');
  }
  public set enableAssumeRole(value: boolean | cdktf.IResolvable) {
    this._enableAssumeRole = value;
  }
  public resetEnableAssumeRole() {
    this._enableAssumeRole = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableAssumeRoleInput() {
    return this._enableAssumeRole;
  }

  // enable_page_checksum - computed: true, optional: true, required: false
  private _enablePageChecksum?: boolean | cdktf.IResolvable; 
  public get enablePageChecksum() {
    return this.getBooleanAttribute('enable_page_checksum');
  }
  public set enablePageChecksum(value: boolean | cdktf.IResolvable) {
    this._enablePageChecksum = value;
  }
  public resetEnablePageChecksum() {
    this._enablePageChecksum = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enablePageChecksumInput() {
    return this._enablePageChecksum;
  }

  // enable_statistics - computed: true, optional: true, required: false
  private _enableStatistics?: boolean | cdktf.IResolvable; 
  public get enableStatistics() {
    return this.getBooleanAttribute('enable_statistics');
  }
  public set enableStatistics(value: boolean | cdktf.IResolvable) {
    this._enableStatistics = value;
  }
  public resetEnableStatistics() {
    this._enableStatistics = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableStatisticsInput() {
    return this._enableStatistics;
  }

  // enable_write_page_index - computed: true, optional: true, required: false
  private _enableWritePageIndex?: boolean | cdktf.IResolvable; 
  public get enableWritePageIndex() {
    return this.getBooleanAttribute('enable_write_page_index');
  }
  public set enableWritePageIndex(value: boolean | cdktf.IResolvable) {
    this._enableWritePageIndex = value;
  }
  public resetEnableWritePageIndex() {
    this._enableWritePageIndex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableWritePageIndexInput() {
    return this._enableWritePageIndex;
  }

  // endpoint - computed: false, optional: true, required: false
  private _endpoint?: string; 
  public get endpoint() {
    return this.getStringAttribute('endpoint');
  }
  public set endpoint(value: string) {
    this._endpoint = value;
  }
  public resetEndpoint() {
    this._endpoint = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get endpointInput() {
    return this._endpoint;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // file_name_suffix - computed: true, optional: true, required: false
  private _fileNameSuffix?: string; 
  public get fileNameSuffix() {
    return this.getStringAttribute('file_name_suffix');
  }
  public set fileNameSuffix(value: string) {
    this._fileNameSuffix = value;
  }
  public resetFileNameSuffix() {
    this._fileNameSuffix = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fileNameSuffixInput() {
    return this._fileNameSuffix;
  }

  // format - computed: true, optional: true, required: false
  private _format?: string; 
  public get format() {
    return this.getStringAttribute('format');
  }
  public set format(value: string) {
    this._format = value;
  }
  public resetFormat() {
    this._format = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get formatInput() {
    return this._format;
  }

  // header_line - computed: true, optional: true, required: false
  private _headerLine?: string; 
  public get headerLine() {
    return this.getStringAttribute('header_line');
  }
  public set headerLine(value: string) {
    this._headerLine = value;
  }
  public resetHeaderLine() {
    this._headerLine = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get headerLineInput() {
    return this._headerLine;
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // key_value_metadata - computed: false, optional: true, required: false
  private _keyValueMetadata = new DestinationOutputDlS3KeyValueMetadataList(this, "key_value_metadata", false);
  public get keyValueMetadata() {
    return this._keyValueMetadata;
  }
  public putKeyValueMetadata(value: DestinationOutputDlS3KeyValueMetadata[] | cdktf.IResolvable) {
    this._keyValueMetadata.internalValue = value;
  }
  public resetKeyValueMetadata() {
    this._keyValueMetadata.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyValueMetadataInput() {
    return this._keyValueMetadata.internalValue;
  }

  // kms_key_id - computed: false, optional: true, required: false
  private _kmsKeyId?: string; 
  public get kmsKeyId() {
    return this.getStringAttribute('kms_key_id');
  }
  public set kmsKeyId(value: string) {
    this._kmsKeyId = value;
  }
  public resetKmsKeyId() {
    this._kmsKeyId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get kmsKeyIdInput() {
    return this._kmsKeyId;
  }

  // max_closing_files_to_backpressure - computed: true, optional: true, required: false
  private _maxClosingFilesToBackpressure?: number; 
  public get maxClosingFilesToBackpressure() {
    return this.getNumberAttribute('max_closing_files_to_backpressure');
  }
  public set maxClosingFilesToBackpressure(value: number) {
    this._maxClosingFilesToBackpressure = value;
  }
  public resetMaxClosingFilesToBackpressure() {
    this._maxClosingFilesToBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxClosingFilesToBackpressureInput() {
    return this._maxClosingFilesToBackpressure;
  }

  // max_concurrent_file_parts - computed: true, optional: true, required: false
  private _maxConcurrentFileParts?: number; 
  public get maxConcurrentFileParts() {
    return this.getNumberAttribute('max_concurrent_file_parts');
  }
  public set maxConcurrentFileParts(value: number) {
    this._maxConcurrentFileParts = value;
  }
  public resetMaxConcurrentFileParts() {
    this._maxConcurrentFileParts = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxConcurrentFilePartsInput() {
    return this._maxConcurrentFileParts;
  }

  // max_file_idle_time_sec - computed: true, optional: true, required: false
  private _maxFileIdleTimeSec?: number; 
  public get maxFileIdleTimeSec() {
    return this.getNumberAttribute('max_file_idle_time_sec');
  }
  public set maxFileIdleTimeSec(value: number) {
    this._maxFileIdleTimeSec = value;
  }
  public resetMaxFileIdleTimeSec() {
    this._maxFileIdleTimeSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxFileIdleTimeSecInput() {
    return this._maxFileIdleTimeSec;
  }

  // max_file_open_time_sec - computed: true, optional: true, required: false
  private _maxFileOpenTimeSec?: number; 
  public get maxFileOpenTimeSec() {
    return this.getNumberAttribute('max_file_open_time_sec');
  }
  public set maxFileOpenTimeSec(value: number) {
    this._maxFileOpenTimeSec = value;
  }
  public resetMaxFileOpenTimeSec() {
    this._maxFileOpenTimeSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxFileOpenTimeSecInput() {
    return this._maxFileOpenTimeSec;
  }

  // max_file_size_mb - computed: true, optional: true, required: false
  private _maxFileSizeMb?: number; 
  public get maxFileSizeMb() {
    return this.getNumberAttribute('max_file_size_mb');
  }
  public set maxFileSizeMb(value: number) {
    this._maxFileSizeMb = value;
  }
  public resetMaxFileSizeMb() {
    this._maxFileSizeMb = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxFileSizeMbInput() {
    return this._maxFileSizeMb;
  }

  // max_open_files - computed: true, optional: true, required: false
  private _maxOpenFiles?: number; 
  public get maxOpenFiles() {
    return this.getNumberAttribute('max_open_files');
  }
  public set maxOpenFiles(value: number) {
    this._maxOpenFiles = value;
  }
  public resetMaxOpenFiles() {
    this._maxOpenFiles = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxOpenFilesInput() {
    return this._maxOpenFiles;
  }

  // max_retry_num - computed: true, optional: true, required: false
  private _maxRetryNum?: number; 
  public get maxRetryNum() {
    return this.getNumberAttribute('max_retry_num');
  }
  public set maxRetryNum(value: number) {
    this._maxRetryNum = value;
  }
  public resetMaxRetryNum() {
    this._maxRetryNum = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxRetryNumInput() {
    return this._maxRetryNum;
  }

  // object_acl - computed: true, optional: true, required: false
  private _objectAcl?: string; 
  public get objectAcl() {
    return this.getStringAttribute('object_acl');
  }
  public set objectAcl(value: string) {
    this._objectAcl = value;
  }
  public resetObjectAcl() {
    this._objectAcl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get objectAclInput() {
    return this._objectAcl;
  }

  // on_disk_full_backpressure - computed: true, optional: true, required: false
  private _onDiskFullBackpressure?: string; 
  public get onDiskFullBackpressure() {
    return this.getStringAttribute('on_disk_full_backpressure');
  }
  public set onDiskFullBackpressure(value: string) {
    this._onDiskFullBackpressure = value;
  }
  public resetOnDiskFullBackpressure() {
    this._onDiskFullBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get onDiskFullBackpressureInput() {
    return this._onDiskFullBackpressure;
  }

  // parquet_data_page_version - computed: true, optional: true, required: false
  private _parquetDataPageVersion?: string; 
  public get parquetDataPageVersion() {
    return this.getStringAttribute('parquet_data_page_version');
  }
  public set parquetDataPageVersion(value: string) {
    this._parquetDataPageVersion = value;
  }
  public resetParquetDataPageVersion() {
    this._parquetDataPageVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get parquetDataPageVersionInput() {
    return this._parquetDataPageVersion;
  }

  // parquet_page_size - computed: true, optional: true, required: false
  private _parquetPageSize?: string; 
  public get parquetPageSize() {
    return this.getStringAttribute('parquet_page_size');
  }
  public set parquetPageSize(value: string) {
    this._parquetPageSize = value;
  }
  public resetParquetPageSize() {
    this._parquetPageSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get parquetPageSizeInput() {
    return this._parquetPageSize;
  }

  // parquet_row_group_length - computed: true, optional: true, required: false
  private _parquetRowGroupLength?: number; 
  public get parquetRowGroupLength() {
    return this.getNumberAttribute('parquet_row_group_length');
  }
  public set parquetRowGroupLength(value: number) {
    this._parquetRowGroupLength = value;
  }
  public resetParquetRowGroupLength() {
    this._parquetRowGroupLength = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get parquetRowGroupLengthInput() {
    return this._parquetRowGroupLength;
  }

  // parquet_version - computed: true, optional: true, required: false
  private _parquetVersion?: string; 
  public get parquetVersion() {
    return this.getStringAttribute('parquet_version');
  }
  public set parquetVersion(value: string) {
    this._parquetVersion = value;
  }
  public resetParquetVersion() {
    this._parquetVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get parquetVersionInput() {
    return this._parquetVersion;
  }

  // partitioning_fields - computed: true, optional: true, required: false
  private _partitioningFields?: string[]; 
  public get partitioningFields() {
    return this.getListAttribute('partitioning_fields');
  }
  public set partitioningFields(value: string[]) {
    this._partitioningFields = value;
  }
  public resetPartitioningFields() {
    this._partitioningFields = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get partitioningFieldsInput() {
    return this._partitioningFields;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // region - computed: false, optional: true, required: false
  private _region?: string; 
  public get region() {
    return this.getStringAttribute('region');
  }
  public set region(value: string) {
    this._region = value;
  }
  public resetRegion() {
    this._region = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get regionInput() {
    return this._region;
  }

  // reject_unauthorized - computed: true, optional: true, required: false
  private _rejectUnauthorized?: boolean | cdktf.IResolvable; 
  public get rejectUnauthorized() {
    return this.getBooleanAttribute('reject_unauthorized');
  }
  public set rejectUnauthorized(value: boolean | cdktf.IResolvable) {
    this._rejectUnauthorized = value;
  }
  public resetRejectUnauthorized() {
    this._rejectUnauthorized = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectUnauthorizedInput() {
    return this._rejectUnauthorized;
  }

  // remove_empty_dirs - computed: true, optional: true, required: false
  private _removeEmptyDirs?: boolean | cdktf.IResolvable; 
  public get removeEmptyDirs() {
    return this.getBooleanAttribute('remove_empty_dirs');
  }
  public set removeEmptyDirs(value: boolean | cdktf.IResolvable) {
    this._removeEmptyDirs = value;
  }
  public resetRemoveEmptyDirs() {
    this._removeEmptyDirs = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get removeEmptyDirsInput() {
    return this._removeEmptyDirs;
  }

  // reuse_connections - computed: true, optional: true, required: false
  private _reuseConnections?: boolean | cdktf.IResolvable; 
  public get reuseConnections() {
    return this.getBooleanAttribute('reuse_connections');
  }
  public set reuseConnections(value: boolean | cdktf.IResolvable) {
    this._reuseConnections = value;
  }
  public resetReuseConnections() {
    this._reuseConnections = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get reuseConnectionsInput() {
    return this._reuseConnections;
  }

  // server_side_encryption - computed: false, optional: true, required: false
  private _serverSideEncryption?: string; 
  public get serverSideEncryption() {
    return this.getStringAttribute('server_side_encryption');
  }
  public set serverSideEncryption(value: string) {
    this._serverSideEncryption = value;
  }
  public resetServerSideEncryption() {
    this._serverSideEncryption = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serverSideEncryptionInput() {
    return this._serverSideEncryption;
  }

  // should_log_invalid_rows - computed: false, optional: true, required: false
  private _shouldLogInvalidRows?: boolean | cdktf.IResolvable; 
  public get shouldLogInvalidRows() {
    return this.getBooleanAttribute('should_log_invalid_rows');
  }
  public set shouldLogInvalidRows(value: boolean | cdktf.IResolvable) {
    this._shouldLogInvalidRows = value;
  }
  public resetShouldLogInvalidRows() {
    this._shouldLogInvalidRows = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get shouldLogInvalidRowsInput() {
    return this._shouldLogInvalidRows;
  }

  // signature_version - computed: true, optional: true, required: false
  private _signatureVersion?: string; 
  public get signatureVersion() {
    return this.getStringAttribute('signature_version');
  }
  public set signatureVersion(value: string) {
    this._signatureVersion = value;
  }
  public resetSignatureVersion() {
    this._signatureVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get signatureVersionInput() {
    return this._signatureVersion;
  }

  // stage_path - computed: true, optional: true, required: false
  private _stagePath?: string; 
  public get stagePath() {
    return this.getStringAttribute('stage_path');
  }
  public set stagePath(value: string) {
    this._stagePath = value;
  }
  public resetStagePath() {
    this._stagePath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get stagePathInput() {
    return this._stagePath;
  }

  // storage_class - computed: false, optional: true, required: false
  private _storageClass?: string; 
  public get storageClass() {
    return this.getStringAttribute('storage_class');
  }
  public set storageClass(value: string) {
    this._storageClass = value;
  }
  public resetStorageClass() {
    this._storageClass = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get storageClassInput() {
    return this._storageClass;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // system_fields - computed: true, optional: true, required: false
  private _systemFields?: string[]; 
  public get systemFields() {
    return this.getListAttribute('system_fields');
  }
  public set systemFields(value: string[]) {
    this._systemFields = value;
  }
  public resetSystemFields() {
    this._systemFields = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get systemFieldsInput() {
    return this._systemFields;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // verify_permissions - computed: true, optional: true, required: false
  private _verifyPermissions?: boolean | cdktf.IResolvable; 
  public get verifyPermissions() {
    return this.getBooleanAttribute('verify_permissions');
  }
  public set verifyPermissions(value: boolean | cdktf.IResolvable) {
    this._verifyPermissions = value;
  }
  public resetVerifyPermissions() {
    this._verifyPermissions = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get verifyPermissionsInput() {
    return this._verifyPermissions;
  }

  // write_high_water_mark - computed: true, optional: true, required: false
  private _writeHighWaterMark?: number; 
  public get writeHighWaterMark() {
    return this.getNumberAttribute('write_high_water_mark');
  }
  public set writeHighWaterMark(value: number) {
    this._writeHighWaterMark = value;
  }
  public resetWriteHighWaterMark() {
    this._writeHighWaterMark = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get writeHighWaterMarkInput() {
    return this._writeHighWaterMark;
  }
}
export interface DestinationOutputDynatraceHttpExtraHttpHeaders {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#name Destination#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#value Destination#value}
  */
  readonly value: string;
}

export function destinationOutputDynatraceHttpExtraHttpHeadersToTerraform(struct?: DestinationOutputDynatraceHttpExtraHttpHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function destinationOutputDynatraceHttpExtraHttpHeadersToHclTerraform(struct?: DestinationOutputDynatraceHttpExtraHttpHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputDynatraceHttpExtraHttpHeadersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DestinationOutputDynatraceHttpExtraHttpHeaders | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputDynatraceHttpExtraHttpHeaders | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DestinationOutputDynatraceHttpExtraHttpHeadersList extends cdktf.ComplexList {
  public internalValue? : DestinationOutputDynatraceHttpExtraHttpHeaders[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DestinationOutputDynatraceHttpExtraHttpHeadersOutputReference {
    return new DestinationOutputDynatraceHttpExtraHttpHeadersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DestinationOutputDynatraceHttpPqControls {
}

export function destinationOutputDynatraceHttpPqControlsToTerraform(struct?: DestinationOutputDynatraceHttpPqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function destinationOutputDynatraceHttpPqControlsToHclTerraform(struct?: DestinationOutputDynatraceHttpPqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class DestinationOutputDynatraceHttpPqControlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DestinationOutputDynatraceHttpPqControls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputDynatraceHttpPqControls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface DestinationOutputDynatraceHttpResponseRetrySettings {
  /**
  * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc. Default: 2
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#backoff_rate Destination#backoff_rate}
  */
  readonly backoffRate?: number;
  /**
  * The HTTP response status code that will trigger retries
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#http_status Destination#http_status}
  */
  readonly httpStatus: number;
  /**
  * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes). Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#initial_backoff Destination#initial_backoff}
  */
  readonly initialBackoff?: number;
  /**
  * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds). Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#max_backoff Destination#max_backoff}
  */
  readonly maxBackoff?: number;
}

export function destinationOutputDynatraceHttpResponseRetrySettingsToTerraform(struct?: DestinationOutputDynatraceHttpResponseRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    backoff_rate: cdktf.numberToTerraform(struct!.backoffRate),
    http_status: cdktf.numberToTerraform(struct!.httpStatus),
    initial_backoff: cdktf.numberToTerraform(struct!.initialBackoff),
    max_backoff: cdktf.numberToTerraform(struct!.maxBackoff),
  }
}


export function destinationOutputDynatraceHttpResponseRetrySettingsToHclTerraform(struct?: DestinationOutputDynatraceHttpResponseRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    backoff_rate: {
      value: cdktf.numberToHclTerraform(struct!.backoffRate),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    http_status: {
      value: cdktf.numberToHclTerraform(struct!.httpStatus),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    initial_backoff: {
      value: cdktf.numberToHclTerraform(struct!.initialBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_backoff: {
      value: cdktf.numberToHclTerraform(struct!.maxBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputDynatraceHttpResponseRetrySettingsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DestinationOutputDynatraceHttpResponseRetrySettings | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._backoffRate !== undefined) {
      hasAnyValues = true;
      internalValueResult.backoffRate = this._backoffRate;
    }
    if (this._httpStatus !== undefined) {
      hasAnyValues = true;
      internalValueResult.httpStatus = this._httpStatus;
    }
    if (this._initialBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.initialBackoff = this._initialBackoff;
    }
    if (this._maxBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBackoff = this._maxBackoff;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputDynatraceHttpResponseRetrySettings | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._backoffRate = undefined;
      this._httpStatus = undefined;
      this._initialBackoff = undefined;
      this._maxBackoff = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._backoffRate = value.backoffRate;
      this._httpStatus = value.httpStatus;
      this._initialBackoff = value.initialBackoff;
      this._maxBackoff = value.maxBackoff;
    }
  }

  // backoff_rate - computed: true, optional: true, required: false
  private _backoffRate?: number; 
  public get backoffRate() {
    return this.getNumberAttribute('backoff_rate');
  }
  public set backoffRate(value: number) {
    this._backoffRate = value;
  }
  public resetBackoffRate() {
    this._backoffRate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get backoffRateInput() {
    return this._backoffRate;
  }

  // http_status - computed: false, optional: false, required: true
  private _httpStatus?: number; 
  public get httpStatus() {
    return this.getNumberAttribute('http_status');
  }
  public set httpStatus(value: number) {
    this._httpStatus = value;
  }
  // Temporarily expose input value. Use with caution.
  public get httpStatusInput() {
    return this._httpStatus;
  }

  // initial_backoff - computed: true, optional: true, required: false
  private _initialBackoff?: number; 
  public get initialBackoff() {
    return this.getNumberAttribute('initial_backoff');
  }
  public set initialBackoff(value: number) {
    this._initialBackoff = value;
  }
  public resetInitialBackoff() {
    this._initialBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get initialBackoffInput() {
    return this._initialBackoff;
  }

  // max_backoff - computed: true, optional: true, required: false
  private _maxBackoff?: number; 
  public get maxBackoff() {
    return this.getNumberAttribute('max_backoff');
  }
  public set maxBackoff(value: number) {
    this._maxBackoff = value;
  }
  public resetMaxBackoff() {
    this._maxBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBackoffInput() {
    return this._maxBackoff;
  }
}

export class DestinationOutputDynatraceHttpResponseRetrySettingsList extends cdktf.ComplexList {
  public internalValue? : DestinationOutputDynatraceHttpResponseRetrySettings[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DestinationOutputDynatraceHttpResponseRetrySettingsOutputReference {
    return new DestinationOutputDynatraceHttpResponseRetrySettingsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DestinationOutputDynatraceHttpTimeoutRetrySettings {
  /**
  * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc. Default: 2
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#backoff_rate Destination#backoff_rate}
  */
  readonly backoffRate?: number;
  /**
  * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes). Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#initial_backoff Destination#initial_backoff}
  */
  readonly initialBackoff?: number;
  /**
  * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds). Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#max_backoff Destination#max_backoff}
  */
  readonly maxBackoff?: number;
  /**
  * Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#timeout_retry Destination#timeout_retry}
  */
  readonly timeoutRetry?: boolean | cdktf.IResolvable;
}

export function destinationOutputDynatraceHttpTimeoutRetrySettingsToTerraform(struct?: DestinationOutputDynatraceHttpTimeoutRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    backoff_rate: cdktf.numberToTerraform(struct!.backoffRate),
    initial_backoff: cdktf.numberToTerraform(struct!.initialBackoff),
    max_backoff: cdktf.numberToTerraform(struct!.maxBackoff),
    timeout_retry: cdktf.booleanToTerraform(struct!.timeoutRetry),
  }
}


export function destinationOutputDynatraceHttpTimeoutRetrySettingsToHclTerraform(struct?: DestinationOutputDynatraceHttpTimeoutRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    backoff_rate: {
      value: cdktf.numberToHclTerraform(struct!.backoffRate),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    initial_backoff: {
      value: cdktf.numberToHclTerraform(struct!.initialBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_backoff: {
      value: cdktf.numberToHclTerraform(struct!.maxBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    timeout_retry: {
      value: cdktf.booleanToHclTerraform(struct!.timeoutRetry),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputDynatraceHttpTimeoutRetrySettingsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DestinationOutputDynatraceHttpTimeoutRetrySettings | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._backoffRate !== undefined) {
      hasAnyValues = true;
      internalValueResult.backoffRate = this._backoffRate;
    }
    if (this._initialBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.initialBackoff = this._initialBackoff;
    }
    if (this._maxBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBackoff = this._maxBackoff;
    }
    if (this._timeoutRetry !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutRetry = this._timeoutRetry;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputDynatraceHttpTimeoutRetrySettings | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._backoffRate = undefined;
      this._initialBackoff = undefined;
      this._maxBackoff = undefined;
      this._timeoutRetry = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._backoffRate = value.backoffRate;
      this._initialBackoff = value.initialBackoff;
      this._maxBackoff = value.maxBackoff;
      this._timeoutRetry = value.timeoutRetry;
    }
  }

  // backoff_rate - computed: true, optional: true, required: false
  private _backoffRate?: number; 
  public get backoffRate() {
    return this.getNumberAttribute('backoff_rate');
  }
  public set backoffRate(value: number) {
    this._backoffRate = value;
  }
  public resetBackoffRate() {
    this._backoffRate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get backoffRateInput() {
    return this._backoffRate;
  }

  // initial_backoff - computed: true, optional: true, required: false
  private _initialBackoff?: number; 
  public get initialBackoff() {
    return this.getNumberAttribute('initial_backoff');
  }
  public set initialBackoff(value: number) {
    this._initialBackoff = value;
  }
  public resetInitialBackoff() {
    this._initialBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get initialBackoffInput() {
    return this._initialBackoff;
  }

  // max_backoff - computed: true, optional: true, required: false
  private _maxBackoff?: number; 
  public get maxBackoff() {
    return this.getNumberAttribute('max_backoff');
  }
  public set maxBackoff(value: number) {
    this._maxBackoff = value;
  }
  public resetMaxBackoff() {
    this._maxBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBackoffInput() {
    return this._maxBackoff;
  }

  // timeout_retry - computed: true, optional: true, required: false
  private _timeoutRetry?: boolean | cdktf.IResolvable; 
  public get timeoutRetry() {
    return this.getBooleanAttribute('timeout_retry');
  }
  public set timeoutRetry(value: boolean | cdktf.IResolvable) {
    this._timeoutRetry = value;
  }
  public resetTimeoutRetry() {
    this._timeoutRetry = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutRetryInput() {
    return this._timeoutRetry;
  }
}
export interface DestinationOutputDynatraceHttp {
  /**
  * ActiveGate domain with Log analytics collector module enabled. For example https://{activeGate-domain}:9999/e/{environment-id}/api/v2/logs/ingest.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#active_gate_domain Destination#active_gate_domain}
  */
  readonly activeGateDomain?: string;
  /**
  * Default: "token"; must be one of ["token", "textSecret"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#auth_type Destination#auth_type}
  */
  readonly authType?: string;
  /**
  * Compress the payload body before sending. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#compress Destination#compress}
  */
  readonly compress?: boolean | cdktf.IResolvable;
  /**
  * Maximum number of ongoing requests before blocking. Default: 5
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#concurrency Destination#concurrency}
  */
  readonly concurrency?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#description Destination#description}
  */
  readonly description?: string;
  /**
  * Default: "cloud"; must be one of ["cloud", "activeGate", "manual"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#endpoint Destination#endpoint}
  */
  readonly endpoint?: string;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#environment Destination#environment}
  */
  readonly environment?: string;
  /**
  * ID of the environment to send to
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#environment_id Destination#environment_id}
  */
  readonly environmentId?: string;
  /**
  * Headers to add to all events. You can also add headers dynamically on a per-event basis in the __headers field, as explained in [Cribl Docs](https://docs.cribl.io/stream/destinations-webhook/#internal-fields).
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#extra_http_headers Destination#extra_http_headers}
  */
  readonly extraHttpHeaders?: DestinationOutputDynatraceHttpExtraHttpHeaders[] | cdktf.IResolvable;
  /**
  * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below. Default: "none"; must be one of ["payload", "payloadAndHeaders", "none"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#failed_request_logging_mode Destination#failed_request_logging_mode}
  */
  readonly failedRequestLoggingMode?: string;
  /**
  * Maximum time between requests. Small values could cause the payload size to be smaller than the configured Body size limit. Default: 1
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#flush_period_sec Destination#flush_period_sec}
  */
  readonly flushPeriodSec?: number;
  /**
  * How to format events before sending. Defaults to JSON. Plaintext is not currently supported. Default: "json_array"; must be one of ["json_array", "plaintext"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#format Destination#format}
  */
  readonly format?: string;
  /**
  * Unique ID for this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#id Destination#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * Disable to close the connection immediately after sending the outgoing request. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#keep_alive Destination#keep_alive}
  */
  readonly keepAlive?: boolean | cdktf.IResolvable;
  /**
  * Maximum number of events to include in the request body. Default is 0 (unlimited). Default: 0
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#max_payload_events Destination#max_payload_events}
  */
  readonly maxPayloadEvents?: number;
  /**
  * Maximum size, in KB, of the request body. Default: 4096
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#max_payload_size_kb Destination#max_payload_size_kb}
  */
  readonly maxPayloadSizeKb?: number;
  /**
  * The method to use when sending events. Default: "POST"; must be one of ["POST", "PUT", "PATCH"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#method Destination#method}
  */
  readonly method?: string;
  /**
  * How to handle events when all receivers are exerting backpressure. Default: "block"; must be one of ["block", "drop", "queue"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#on_backpressure Destination#on_backpressure}
  */
  readonly onBackpressure?: string;
  /**
  * Pipeline to process data before sending out to this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pipeline Destination#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pq_compress Destination#pq_compress}
  */
  readonly pqCompress?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pq_controls Destination#pq_controls}
  */
  readonly pqControls?: DestinationOutputDynatraceHttpPqControls;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.). Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pq_max_file_size Destination#pq_max_file_size}
  */
  readonly pqMaxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pq_max_size Destination#pq_max_size}
  */
  readonly pqMaxSize?: string;
  /**
  * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem. Default: "error"; must be one of ["error", "backpressure", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pq_mode Destination#pq_mode}
  */
  readonly pqMode?: string;
  /**
  * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged. Default: "block"; must be one of ["block", "drop"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pq_on_backpressure Destination#pq_on_backpressure}
  */
  readonly pqOnBackpressure?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pq_path Destination#pq_path}
  */
  readonly pqPath?: string;
  /**
  * Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's). 
  *         Enabled by default. When this setting is also present in TLS Settings (Client Side), 
  *         that value will take precedence.
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#reject_unauthorized Destination#reject_unauthorized}
  */
  readonly rejectUnauthorized?: boolean | cdktf.IResolvable;
  /**
  * Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#response_honor_retry_after_header Destination#response_honor_retry_after_header}
  */
  readonly responseHonorRetryAfterHeader?: boolean | cdktf.IResolvable;
  /**
  * Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#response_retry_settings Destination#response_retry_settings}
  */
  readonly responseRetrySettings?: DestinationOutputDynatraceHttpResponseRetrySettings[] | cdktf.IResolvable;
  /**
  * List of headers that are safe to log in plain text. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#safe_headers Destination#safe_headers}
  */
  readonly safeHeaders?: string[];
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#streamtags Destination#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Fields to automatically add to events, such as cribl_pipe. Supports wildcards. Default: ["cribl_pipe"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#system_fields Destination#system_fields}
  */
  readonly systemFields?: string[];
  /**
  * Default: "logs"; must be one of ["logs", "metrics"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#telemetry_type Destination#telemetry_type}
  */
  readonly telemetryType?: string;
  /**
  * Select or create a stored text secret
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#text_secret Destination#text_secret}
  */
  readonly textSecret?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#timeout_retry_settings Destination#timeout_retry_settings}
  */
  readonly timeoutRetrySettings?: DestinationOutputDynatraceHttpTimeoutRetrySettings;
  /**
  * Amount of time, in seconds, to wait for a request to complete before canceling it. Default: 30
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#timeout_sec Destination#timeout_sec}
  */
  readonly timeoutSec?: number;
  /**
  * Bearer token to include in the authorization header
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#token Destination#token}
  */
  readonly token?: string;
  /**
  * Maximum total size of the batches waiting to be sent. If left blank, defaults to 5 times the max body size (if set). If 0, no limit is enforced.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#total_memory_limit_kb Destination#total_memory_limit_kb}
  */
  readonly totalMemoryLimitKb?: number;
  /**
  * must be "dynatrace_http"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#type Destination#type}
  */
  readonly type?: string;
  /**
  * URL to send events to. Can be overwritten by an event's __url field.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#url Destination#url}
  */
  readonly url?: string;
  /**
  * Enable round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. For optimal performance, consider enabling this setting for non-load balanced destinations. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#use_round_robin_dns Destination#use_round_robin_dns}
  */
  readonly useRoundRobinDns?: boolean | cdktf.IResolvable;
}

export function destinationOutputDynatraceHttpToTerraform(struct?: DestinationOutputDynatraceHttp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    active_gate_domain: cdktf.stringToTerraform(struct!.activeGateDomain),
    auth_type: cdktf.stringToTerraform(struct!.authType),
    compress: cdktf.booleanToTerraform(struct!.compress),
    concurrency: cdktf.numberToTerraform(struct!.concurrency),
    description: cdktf.stringToTerraform(struct!.description),
    endpoint: cdktf.stringToTerraform(struct!.endpoint),
    environment: cdktf.stringToTerraform(struct!.environment),
    environment_id: cdktf.stringToTerraform(struct!.environmentId),
    extra_http_headers: cdktf.listMapper(destinationOutputDynatraceHttpExtraHttpHeadersToTerraform, false)(struct!.extraHttpHeaders),
    failed_request_logging_mode: cdktf.stringToTerraform(struct!.failedRequestLoggingMode),
    flush_period_sec: cdktf.numberToTerraform(struct!.flushPeriodSec),
    format: cdktf.stringToTerraform(struct!.format),
    id: cdktf.stringToTerraform(struct!.id),
    keep_alive: cdktf.booleanToTerraform(struct!.keepAlive),
    max_payload_events: cdktf.numberToTerraform(struct!.maxPayloadEvents),
    max_payload_size_kb: cdktf.numberToTerraform(struct!.maxPayloadSizeKb),
    method: cdktf.stringToTerraform(struct!.method),
    on_backpressure: cdktf.stringToTerraform(struct!.onBackpressure),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    pq_compress: cdktf.stringToTerraform(struct!.pqCompress),
    pq_controls: destinationOutputDynatraceHttpPqControlsToTerraform(struct!.pqControls),
    pq_max_file_size: cdktf.stringToTerraform(struct!.pqMaxFileSize),
    pq_max_size: cdktf.stringToTerraform(struct!.pqMaxSize),
    pq_mode: cdktf.stringToTerraform(struct!.pqMode),
    pq_on_backpressure: cdktf.stringToTerraform(struct!.pqOnBackpressure),
    pq_path: cdktf.stringToTerraform(struct!.pqPath),
    reject_unauthorized: cdktf.booleanToTerraform(struct!.rejectUnauthorized),
    response_honor_retry_after_header: cdktf.booleanToTerraform(struct!.responseHonorRetryAfterHeader),
    response_retry_settings: cdktf.listMapper(destinationOutputDynatraceHttpResponseRetrySettingsToTerraform, false)(struct!.responseRetrySettings),
    safe_headers: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.safeHeaders),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    system_fields: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.systemFields),
    telemetry_type: cdktf.stringToTerraform(struct!.telemetryType),
    text_secret: cdktf.stringToTerraform(struct!.textSecret),
    timeout_retry_settings: destinationOutputDynatraceHttpTimeoutRetrySettingsToTerraform(struct!.timeoutRetrySettings),
    timeout_sec: cdktf.numberToTerraform(struct!.timeoutSec),
    token: cdktf.stringToTerraform(struct!.token),
    total_memory_limit_kb: cdktf.numberToTerraform(struct!.totalMemoryLimitKb),
    type: cdktf.stringToTerraform(struct!.type),
    url: cdktf.stringToTerraform(struct!.url),
    use_round_robin_dns: cdktf.booleanToTerraform(struct!.useRoundRobinDns),
  }
}


export function destinationOutputDynatraceHttpToHclTerraform(struct?: DestinationOutputDynatraceHttp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    active_gate_domain: {
      value: cdktf.stringToHclTerraform(struct!.activeGateDomain),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    auth_type: {
      value: cdktf.stringToHclTerraform(struct!.authType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    compress: {
      value: cdktf.booleanToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    concurrency: {
      value: cdktf.numberToHclTerraform(struct!.concurrency),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    endpoint: {
      value: cdktf.stringToHclTerraform(struct!.endpoint),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    environment_id: {
      value: cdktf.stringToHclTerraform(struct!.environmentId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    extra_http_headers: {
      value: cdktf.listMapperHcl(destinationOutputDynatraceHttpExtraHttpHeadersToHclTerraform, false)(struct!.extraHttpHeaders),
      isBlock: true,
      type: "list",
      storageClassType: "DestinationOutputDynatraceHttpExtraHttpHeadersList",
    },
    failed_request_logging_mode: {
      value: cdktf.stringToHclTerraform(struct!.failedRequestLoggingMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    flush_period_sec: {
      value: cdktf.numberToHclTerraform(struct!.flushPeriodSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    format: {
      value: cdktf.stringToHclTerraform(struct!.format),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    keep_alive: {
      value: cdktf.booleanToHclTerraform(struct!.keepAlive),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    max_payload_events: {
      value: cdktf.numberToHclTerraform(struct!.maxPayloadEvents),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_payload_size_kb: {
      value: cdktf.numberToHclTerraform(struct!.maxPayloadSizeKb),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    method: {
      value: cdktf.stringToHclTerraform(struct!.method),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.onBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_compress: {
      value: cdktf.stringToHclTerraform(struct!.pqCompress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_controls: {
      value: destinationOutputDynatraceHttpPqControlsToHclTerraform(struct!.pqControls),
      isBlock: true,
      type: "struct",
      storageClassType: "DestinationOutputDynatraceHttpPqControls",
    },
    pq_max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_max_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_mode: {
      value: cdktf.stringToHclTerraform(struct!.pqMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.pqOnBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_path: {
      value: cdktf.stringToHclTerraform(struct!.pqPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reject_unauthorized: {
      value: cdktf.booleanToHclTerraform(struct!.rejectUnauthorized),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    response_honor_retry_after_header: {
      value: cdktf.booleanToHclTerraform(struct!.responseHonorRetryAfterHeader),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    response_retry_settings: {
      value: cdktf.listMapperHcl(destinationOutputDynatraceHttpResponseRetrySettingsToHclTerraform, false)(struct!.responseRetrySettings),
      isBlock: true,
      type: "list",
      storageClassType: "DestinationOutputDynatraceHttpResponseRetrySettingsList",
    },
    safe_headers: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.safeHeaders),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    system_fields: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.systemFields),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    telemetry_type: {
      value: cdktf.stringToHclTerraform(struct!.telemetryType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    text_secret: {
      value: cdktf.stringToHclTerraform(struct!.textSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    timeout_retry_settings: {
      value: destinationOutputDynatraceHttpTimeoutRetrySettingsToHclTerraform(struct!.timeoutRetrySettings),
      isBlock: true,
      type: "struct",
      storageClassType: "DestinationOutputDynatraceHttpTimeoutRetrySettings",
    },
    timeout_sec: {
      value: cdktf.numberToHclTerraform(struct!.timeoutSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    token: {
      value: cdktf.stringToHclTerraform(struct!.token),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    total_memory_limit_kb: {
      value: cdktf.numberToHclTerraform(struct!.totalMemoryLimitKb),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    url: {
      value: cdktf.stringToHclTerraform(struct!.url),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    use_round_robin_dns: {
      value: cdktf.booleanToHclTerraform(struct!.useRoundRobinDns),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputDynatraceHttpOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DestinationOutputDynatraceHttp | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._activeGateDomain !== undefined) {
      hasAnyValues = true;
      internalValueResult.activeGateDomain = this._activeGateDomain;
    }
    if (this._authType !== undefined) {
      hasAnyValues = true;
      internalValueResult.authType = this._authType;
    }
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._concurrency !== undefined) {
      hasAnyValues = true;
      internalValueResult.concurrency = this._concurrency;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._endpoint !== undefined) {
      hasAnyValues = true;
      internalValueResult.endpoint = this._endpoint;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._environmentId !== undefined) {
      hasAnyValues = true;
      internalValueResult.environmentId = this._environmentId;
    }
    if (this._extraHttpHeaders?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.extraHttpHeaders = this._extraHttpHeaders?.internalValue;
    }
    if (this._failedRequestLoggingMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.failedRequestLoggingMode = this._failedRequestLoggingMode;
    }
    if (this._flushPeriodSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.flushPeriodSec = this._flushPeriodSec;
    }
    if (this._format !== undefined) {
      hasAnyValues = true;
      internalValueResult.format = this._format;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._keepAlive !== undefined) {
      hasAnyValues = true;
      internalValueResult.keepAlive = this._keepAlive;
    }
    if (this._maxPayloadEvents !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxPayloadEvents = this._maxPayloadEvents;
    }
    if (this._maxPayloadSizeKb !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxPayloadSizeKb = this._maxPayloadSizeKb;
    }
    if (this._method !== undefined) {
      hasAnyValues = true;
      internalValueResult.method = this._method;
    }
    if (this._onBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.onBackpressure = this._onBackpressure;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._pqCompress !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqCompress = this._pqCompress;
    }
    if (this._pqControls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqControls = this._pqControls?.internalValue;
    }
    if (this._pqMaxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxFileSize = this._pqMaxFileSize;
    }
    if (this._pqMaxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxSize = this._pqMaxSize;
    }
    if (this._pqMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMode = this._pqMode;
    }
    if (this._pqOnBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqOnBackpressure = this._pqOnBackpressure;
    }
    if (this._pqPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqPath = this._pqPath;
    }
    if (this._rejectUnauthorized !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectUnauthorized = this._rejectUnauthorized;
    }
    if (this._responseHonorRetryAfterHeader !== undefined) {
      hasAnyValues = true;
      internalValueResult.responseHonorRetryAfterHeader = this._responseHonorRetryAfterHeader;
    }
    if (this._responseRetrySettings?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.responseRetrySettings = this._responseRetrySettings?.internalValue;
    }
    if (this._safeHeaders !== undefined) {
      hasAnyValues = true;
      internalValueResult.safeHeaders = this._safeHeaders;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._systemFields !== undefined) {
      hasAnyValues = true;
      internalValueResult.systemFields = this._systemFields;
    }
    if (this._telemetryType !== undefined) {
      hasAnyValues = true;
      internalValueResult.telemetryType = this._telemetryType;
    }
    if (this._textSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.textSecret = this._textSecret;
    }
    if (this._timeoutRetrySettings?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutRetrySettings = this._timeoutRetrySettings?.internalValue;
    }
    if (this._timeoutSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutSec = this._timeoutSec;
    }
    if (this._token !== undefined) {
      hasAnyValues = true;
      internalValueResult.token = this._token;
    }
    if (this._totalMemoryLimitKb !== undefined) {
      hasAnyValues = true;
      internalValueResult.totalMemoryLimitKb = this._totalMemoryLimitKb;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._url !== undefined) {
      hasAnyValues = true;
      internalValueResult.url = this._url;
    }
    if (this._useRoundRobinDns !== undefined) {
      hasAnyValues = true;
      internalValueResult.useRoundRobinDns = this._useRoundRobinDns;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputDynatraceHttp | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._activeGateDomain = undefined;
      this._authType = undefined;
      this._compress = undefined;
      this._concurrency = undefined;
      this._description = undefined;
      this._endpoint = undefined;
      this._environment = undefined;
      this._environmentId = undefined;
      this._extraHttpHeaders.internalValue = undefined;
      this._failedRequestLoggingMode = undefined;
      this._flushPeriodSec = undefined;
      this._format = undefined;
      this._id = undefined;
      this._keepAlive = undefined;
      this._maxPayloadEvents = undefined;
      this._maxPayloadSizeKb = undefined;
      this._method = undefined;
      this._onBackpressure = undefined;
      this._pipeline = undefined;
      this._pqCompress = undefined;
      this._pqControls.internalValue = undefined;
      this._pqMaxFileSize = undefined;
      this._pqMaxSize = undefined;
      this._pqMode = undefined;
      this._pqOnBackpressure = undefined;
      this._pqPath = undefined;
      this._rejectUnauthorized = undefined;
      this._responseHonorRetryAfterHeader = undefined;
      this._responseRetrySettings.internalValue = undefined;
      this._safeHeaders = undefined;
      this._streamtags = undefined;
      this._systemFields = undefined;
      this._telemetryType = undefined;
      this._textSecret = undefined;
      this._timeoutRetrySettings.internalValue = undefined;
      this._timeoutSec = undefined;
      this._token = undefined;
      this._totalMemoryLimitKb = undefined;
      this._type = undefined;
      this._url = undefined;
      this._useRoundRobinDns = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._activeGateDomain = value.activeGateDomain;
      this._authType = value.authType;
      this._compress = value.compress;
      this._concurrency = value.concurrency;
      this._description = value.description;
      this._endpoint = value.endpoint;
      this._environment = value.environment;
      this._environmentId = value.environmentId;
      this._extraHttpHeaders.internalValue = value.extraHttpHeaders;
      this._failedRequestLoggingMode = value.failedRequestLoggingMode;
      this._flushPeriodSec = value.flushPeriodSec;
      this._format = value.format;
      this._id = value.id;
      this._keepAlive = value.keepAlive;
      this._maxPayloadEvents = value.maxPayloadEvents;
      this._maxPayloadSizeKb = value.maxPayloadSizeKb;
      this._method = value.method;
      this._onBackpressure = value.onBackpressure;
      this._pipeline = value.pipeline;
      this._pqCompress = value.pqCompress;
      this._pqControls.internalValue = value.pqControls;
      this._pqMaxFileSize = value.pqMaxFileSize;
      this._pqMaxSize = value.pqMaxSize;
      this._pqMode = value.pqMode;
      this._pqOnBackpressure = value.pqOnBackpressure;
      this._pqPath = value.pqPath;
      this._rejectUnauthorized = value.rejectUnauthorized;
      this._responseHonorRetryAfterHeader = value.responseHonorRetryAfterHeader;
      this._responseRetrySettings.internalValue = value.responseRetrySettings;
      this._safeHeaders = value.safeHeaders;
      this._streamtags = value.streamtags;
      this._systemFields = value.systemFields;
      this._telemetryType = value.telemetryType;
      this._textSecret = value.textSecret;
      this._timeoutRetrySettings.internalValue = value.timeoutRetrySettings;
      this._timeoutSec = value.timeoutSec;
      this._token = value.token;
      this._totalMemoryLimitKb = value.totalMemoryLimitKb;
      this._type = value.type;
      this._url = value.url;
      this._useRoundRobinDns = value.useRoundRobinDns;
    }
  }

  // active_gate_domain - computed: false, optional: true, required: false
  private _activeGateDomain?: string; 
  public get activeGateDomain() {
    return this.getStringAttribute('active_gate_domain');
  }
  public set activeGateDomain(value: string) {
    this._activeGateDomain = value;
  }
  public resetActiveGateDomain() {
    this._activeGateDomain = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get activeGateDomainInput() {
    return this._activeGateDomain;
  }

  // auth_type - computed: true, optional: true, required: false
  private _authType?: string; 
  public get authType() {
    return this.getStringAttribute('auth_type');
  }
  public set authType(value: string) {
    this._authType = value;
  }
  public resetAuthType() {
    this._authType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authTypeInput() {
    return this._authType;
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: boolean | cdktf.IResolvable; 
  public get compress() {
    return this.getBooleanAttribute('compress');
  }
  public set compress(value: boolean | cdktf.IResolvable) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // concurrency - computed: true, optional: true, required: false
  private _concurrency?: number; 
  public get concurrency() {
    return this.getNumberAttribute('concurrency');
  }
  public set concurrency(value: number) {
    this._concurrency = value;
  }
  public resetConcurrency() {
    this._concurrency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get concurrencyInput() {
    return this._concurrency;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // endpoint - computed: true, optional: true, required: false
  private _endpoint?: string; 
  public get endpoint() {
    return this.getStringAttribute('endpoint');
  }
  public set endpoint(value: string) {
    this._endpoint = value;
  }
  public resetEndpoint() {
    this._endpoint = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get endpointInput() {
    return this._endpoint;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // environment_id - computed: false, optional: true, required: false
  private _environmentId?: string; 
  public get environmentId() {
    return this.getStringAttribute('environment_id');
  }
  public set environmentId(value: string) {
    this._environmentId = value;
  }
  public resetEnvironmentId() {
    this._environmentId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentIdInput() {
    return this._environmentId;
  }

  // extra_http_headers - computed: false, optional: true, required: false
  private _extraHttpHeaders = new DestinationOutputDynatraceHttpExtraHttpHeadersList(this, "extra_http_headers", false);
  public get extraHttpHeaders() {
    return this._extraHttpHeaders;
  }
  public putExtraHttpHeaders(value: DestinationOutputDynatraceHttpExtraHttpHeaders[] | cdktf.IResolvable) {
    this._extraHttpHeaders.internalValue = value;
  }
  public resetExtraHttpHeaders() {
    this._extraHttpHeaders.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get extraHttpHeadersInput() {
    return this._extraHttpHeaders.internalValue;
  }

  // failed_request_logging_mode - computed: true, optional: true, required: false
  private _failedRequestLoggingMode?: string; 
  public get failedRequestLoggingMode() {
    return this.getStringAttribute('failed_request_logging_mode');
  }
  public set failedRequestLoggingMode(value: string) {
    this._failedRequestLoggingMode = value;
  }
  public resetFailedRequestLoggingMode() {
    this._failedRequestLoggingMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get failedRequestLoggingModeInput() {
    return this._failedRequestLoggingMode;
  }

  // flush_period_sec - computed: true, optional: true, required: false
  private _flushPeriodSec?: number; 
  public get flushPeriodSec() {
    return this.getNumberAttribute('flush_period_sec');
  }
  public set flushPeriodSec(value: number) {
    this._flushPeriodSec = value;
  }
  public resetFlushPeriodSec() {
    this._flushPeriodSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get flushPeriodSecInput() {
    return this._flushPeriodSec;
  }

  // format - computed: true, optional: true, required: false
  private _format?: string; 
  public get format() {
    return this.getStringAttribute('format');
  }
  public set format(value: string) {
    this._format = value;
  }
  public resetFormat() {
    this._format = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get formatInput() {
    return this._format;
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // keep_alive - computed: true, optional: true, required: false
  private _keepAlive?: boolean | cdktf.IResolvable; 
  public get keepAlive() {
    return this.getBooleanAttribute('keep_alive');
  }
  public set keepAlive(value: boolean | cdktf.IResolvable) {
    this._keepAlive = value;
  }
  public resetKeepAlive() {
    this._keepAlive = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keepAliveInput() {
    return this._keepAlive;
  }

  // max_payload_events - computed: true, optional: true, required: false
  private _maxPayloadEvents?: number; 
  public get maxPayloadEvents() {
    return this.getNumberAttribute('max_payload_events');
  }
  public set maxPayloadEvents(value: number) {
    this._maxPayloadEvents = value;
  }
  public resetMaxPayloadEvents() {
    this._maxPayloadEvents = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxPayloadEventsInput() {
    return this._maxPayloadEvents;
  }

  // max_payload_size_kb - computed: true, optional: true, required: false
  private _maxPayloadSizeKb?: number; 
  public get maxPayloadSizeKb() {
    return this.getNumberAttribute('max_payload_size_kb');
  }
  public set maxPayloadSizeKb(value: number) {
    this._maxPayloadSizeKb = value;
  }
  public resetMaxPayloadSizeKb() {
    this._maxPayloadSizeKb = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxPayloadSizeKbInput() {
    return this._maxPayloadSizeKb;
  }

  // method - computed: true, optional: true, required: false
  private _method?: string; 
  public get method() {
    return this.getStringAttribute('method');
  }
  public set method(value: string) {
    this._method = value;
  }
  public resetMethod() {
    this._method = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get methodInput() {
    return this._method;
  }

  // on_backpressure - computed: true, optional: true, required: false
  private _onBackpressure?: string; 
  public get onBackpressure() {
    return this.getStringAttribute('on_backpressure');
  }
  public set onBackpressure(value: string) {
    this._onBackpressure = value;
  }
  public resetOnBackpressure() {
    this._onBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get onBackpressureInput() {
    return this._onBackpressure;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // pq_compress - computed: true, optional: true, required: false
  private _pqCompress?: string; 
  public get pqCompress() {
    return this.getStringAttribute('pq_compress');
  }
  public set pqCompress(value: string) {
    this._pqCompress = value;
  }
  public resetPqCompress() {
    this._pqCompress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqCompressInput() {
    return this._pqCompress;
  }

  // pq_controls - computed: false, optional: true, required: false
  private _pqControls = new DestinationOutputDynatraceHttpPqControlsOutputReference(this, "pq_controls");
  public get pqControls() {
    return this._pqControls;
  }
  public putPqControls(value: DestinationOutputDynatraceHttpPqControls) {
    this._pqControls.internalValue = value;
  }
  public resetPqControls() {
    this._pqControls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqControlsInput() {
    return this._pqControls.internalValue;
  }

  // pq_max_file_size - computed: true, optional: true, required: false
  private _pqMaxFileSize?: string; 
  public get pqMaxFileSize() {
    return this.getStringAttribute('pq_max_file_size');
  }
  public set pqMaxFileSize(value: string) {
    this._pqMaxFileSize = value;
  }
  public resetPqMaxFileSize() {
    this._pqMaxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxFileSizeInput() {
    return this._pqMaxFileSize;
  }

  // pq_max_size - computed: true, optional: true, required: false
  private _pqMaxSize?: string; 
  public get pqMaxSize() {
    return this.getStringAttribute('pq_max_size');
  }
  public set pqMaxSize(value: string) {
    this._pqMaxSize = value;
  }
  public resetPqMaxSize() {
    this._pqMaxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxSizeInput() {
    return this._pqMaxSize;
  }

  // pq_mode - computed: true, optional: true, required: false
  private _pqMode?: string; 
  public get pqMode() {
    return this.getStringAttribute('pq_mode');
  }
  public set pqMode(value: string) {
    this._pqMode = value;
  }
  public resetPqMode() {
    this._pqMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqModeInput() {
    return this._pqMode;
  }

  // pq_on_backpressure - computed: true, optional: true, required: false
  private _pqOnBackpressure?: string; 
  public get pqOnBackpressure() {
    return this.getStringAttribute('pq_on_backpressure');
  }
  public set pqOnBackpressure(value: string) {
    this._pqOnBackpressure = value;
  }
  public resetPqOnBackpressure() {
    this._pqOnBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqOnBackpressureInput() {
    return this._pqOnBackpressure;
  }

  // pq_path - computed: true, optional: true, required: false
  private _pqPath?: string; 
  public get pqPath() {
    return this.getStringAttribute('pq_path');
  }
  public set pqPath(value: string) {
    this._pqPath = value;
  }
  public resetPqPath() {
    this._pqPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqPathInput() {
    return this._pqPath;
  }

  // reject_unauthorized - computed: true, optional: true, required: false
  private _rejectUnauthorized?: boolean | cdktf.IResolvable; 
  public get rejectUnauthorized() {
    return this.getBooleanAttribute('reject_unauthorized');
  }
  public set rejectUnauthorized(value: boolean | cdktf.IResolvable) {
    this._rejectUnauthorized = value;
  }
  public resetRejectUnauthorized() {
    this._rejectUnauthorized = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectUnauthorizedInput() {
    return this._rejectUnauthorized;
  }

  // response_honor_retry_after_header - computed: true, optional: true, required: false
  private _responseHonorRetryAfterHeader?: boolean | cdktf.IResolvable; 
  public get responseHonorRetryAfterHeader() {
    return this.getBooleanAttribute('response_honor_retry_after_header');
  }
  public set responseHonorRetryAfterHeader(value: boolean | cdktf.IResolvable) {
    this._responseHonorRetryAfterHeader = value;
  }
  public resetResponseHonorRetryAfterHeader() {
    this._responseHonorRetryAfterHeader = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get responseHonorRetryAfterHeaderInput() {
    return this._responseHonorRetryAfterHeader;
  }

  // response_retry_settings - computed: false, optional: true, required: false
  private _responseRetrySettings = new DestinationOutputDynatraceHttpResponseRetrySettingsList(this, "response_retry_settings", false);
  public get responseRetrySettings() {
    return this._responseRetrySettings;
  }
  public putResponseRetrySettings(value: DestinationOutputDynatraceHttpResponseRetrySettings[] | cdktf.IResolvable) {
    this._responseRetrySettings.internalValue = value;
  }
  public resetResponseRetrySettings() {
    this._responseRetrySettings.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get responseRetrySettingsInput() {
    return this._responseRetrySettings.internalValue;
  }

  // safe_headers - computed: true, optional: true, required: false
  private _safeHeaders?: string[]; 
  public get safeHeaders() {
    return this.getListAttribute('safe_headers');
  }
  public set safeHeaders(value: string[]) {
    this._safeHeaders = value;
  }
  public resetSafeHeaders() {
    this._safeHeaders = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get safeHeadersInput() {
    return this._safeHeaders;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // system_fields - computed: true, optional: true, required: false
  private _systemFields?: string[]; 
  public get systemFields() {
    return this.getListAttribute('system_fields');
  }
  public set systemFields(value: string[]) {
    this._systemFields = value;
  }
  public resetSystemFields() {
    this._systemFields = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get systemFieldsInput() {
    return this._systemFields;
  }

  // telemetry_type - computed: true, optional: true, required: false
  private _telemetryType?: string; 
  public get telemetryType() {
    return this.getStringAttribute('telemetry_type');
  }
  public set telemetryType(value: string) {
    this._telemetryType = value;
  }
  public resetTelemetryType() {
    this._telemetryType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get telemetryTypeInput() {
    return this._telemetryType;
  }

  // text_secret - computed: false, optional: true, required: false
  private _textSecret?: string; 
  public get textSecret() {
    return this.getStringAttribute('text_secret');
  }
  public set textSecret(value: string) {
    this._textSecret = value;
  }
  public resetTextSecret() {
    this._textSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get textSecretInput() {
    return this._textSecret;
  }

  // timeout_retry_settings - computed: false, optional: true, required: false
  private _timeoutRetrySettings = new DestinationOutputDynatraceHttpTimeoutRetrySettingsOutputReference(this, "timeout_retry_settings");
  public get timeoutRetrySettings() {
    return this._timeoutRetrySettings;
  }
  public putTimeoutRetrySettings(value: DestinationOutputDynatraceHttpTimeoutRetrySettings) {
    this._timeoutRetrySettings.internalValue = value;
  }
  public resetTimeoutRetrySettings() {
    this._timeoutRetrySettings.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutRetrySettingsInput() {
    return this._timeoutRetrySettings.internalValue;
  }

  // timeout_sec - computed: true, optional: true, required: false
  private _timeoutSec?: number; 
  public get timeoutSec() {
    return this.getNumberAttribute('timeout_sec');
  }
  public set timeoutSec(value: number) {
    this._timeoutSec = value;
  }
  public resetTimeoutSec() {
    this._timeoutSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutSecInput() {
    return this._timeoutSec;
  }

  // token - computed: false, optional: true, required: false
  private _token?: string; 
  public get token() {
    return this.getStringAttribute('token');
  }
  public set token(value: string) {
    this._token = value;
  }
  public resetToken() {
    this._token = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tokenInput() {
    return this._token;
  }

  // total_memory_limit_kb - computed: false, optional: true, required: false
  private _totalMemoryLimitKb?: number; 
  public get totalMemoryLimitKb() {
    return this.getNumberAttribute('total_memory_limit_kb');
  }
  public set totalMemoryLimitKb(value: number) {
    this._totalMemoryLimitKb = value;
  }
  public resetTotalMemoryLimitKb() {
    this._totalMemoryLimitKb = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get totalMemoryLimitKbInput() {
    return this._totalMemoryLimitKb;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // url - computed: false, optional: true, required: false
  private _url?: string; 
  public get url() {
    return this.getStringAttribute('url');
  }
  public set url(value: string) {
    this._url = value;
  }
  public resetUrl() {
    this._url = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get urlInput() {
    return this._url;
  }

  // use_round_robin_dns - computed: true, optional: true, required: false
  private _useRoundRobinDns?: boolean | cdktf.IResolvable; 
  public get useRoundRobinDns() {
    return this.getBooleanAttribute('use_round_robin_dns');
  }
  public set useRoundRobinDns(value: boolean | cdktf.IResolvable) {
    this._useRoundRobinDns = value;
  }
  public resetUseRoundRobinDns() {
    this._useRoundRobinDns = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get useRoundRobinDnsInput() {
    return this._useRoundRobinDns;
  }
}
export interface DestinationOutputDynatraceOtlpExtraHttpHeaders {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#name Destination#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#value Destination#value}
  */
  readonly value: string;
}

export function destinationOutputDynatraceOtlpExtraHttpHeadersToTerraform(struct?: DestinationOutputDynatraceOtlpExtraHttpHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function destinationOutputDynatraceOtlpExtraHttpHeadersToHclTerraform(struct?: DestinationOutputDynatraceOtlpExtraHttpHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputDynatraceOtlpExtraHttpHeadersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DestinationOutputDynatraceOtlpExtraHttpHeaders | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputDynatraceOtlpExtraHttpHeaders | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DestinationOutputDynatraceOtlpExtraHttpHeadersList extends cdktf.ComplexList {
  public internalValue? : DestinationOutputDynatraceOtlpExtraHttpHeaders[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DestinationOutputDynatraceOtlpExtraHttpHeadersOutputReference {
    return new DestinationOutputDynatraceOtlpExtraHttpHeadersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DestinationOutputDynatraceOtlpMetadata {
  /**
  * Default: ""
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#key Destination#key}
  */
  readonly key?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#value Destination#value}
  */
  readonly value: string;
}

export function destinationOutputDynatraceOtlpMetadataToTerraform(struct?: DestinationOutputDynatraceOtlpMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function destinationOutputDynatraceOtlpMetadataToHclTerraform(struct?: DestinationOutputDynatraceOtlpMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputDynatraceOtlpMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DestinationOutputDynatraceOtlpMetadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputDynatraceOtlpMetadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._value = value.value;
    }
  }

  // key - computed: true, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DestinationOutputDynatraceOtlpMetadataList extends cdktf.ComplexList {
  public internalValue? : DestinationOutputDynatraceOtlpMetadata[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DestinationOutputDynatraceOtlpMetadataOutputReference {
    return new DestinationOutputDynatraceOtlpMetadataOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DestinationOutputDynatraceOtlpPqControls {
}

export function destinationOutputDynatraceOtlpPqControlsToTerraform(struct?: DestinationOutputDynatraceOtlpPqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function destinationOutputDynatraceOtlpPqControlsToHclTerraform(struct?: DestinationOutputDynatraceOtlpPqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class DestinationOutputDynatraceOtlpPqControlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DestinationOutputDynatraceOtlpPqControls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputDynatraceOtlpPqControls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface DestinationOutputDynatraceOtlpResponseRetrySettings {
  /**
  * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc. Default: 2
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#backoff_rate Destination#backoff_rate}
  */
  readonly backoffRate?: number;
  /**
  * The HTTP response status code that will trigger retries
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#http_status Destination#http_status}
  */
  readonly httpStatus: number;
  /**
  * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes). Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#initial_backoff Destination#initial_backoff}
  */
  readonly initialBackoff?: number;
  /**
  * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds). Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#max_backoff Destination#max_backoff}
  */
  readonly maxBackoff?: number;
}

export function destinationOutputDynatraceOtlpResponseRetrySettingsToTerraform(struct?: DestinationOutputDynatraceOtlpResponseRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    backoff_rate: cdktf.numberToTerraform(struct!.backoffRate),
    http_status: cdktf.numberToTerraform(struct!.httpStatus),
    initial_backoff: cdktf.numberToTerraform(struct!.initialBackoff),
    max_backoff: cdktf.numberToTerraform(struct!.maxBackoff),
  }
}


export function destinationOutputDynatraceOtlpResponseRetrySettingsToHclTerraform(struct?: DestinationOutputDynatraceOtlpResponseRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    backoff_rate: {
      value: cdktf.numberToHclTerraform(struct!.backoffRate),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    http_status: {
      value: cdktf.numberToHclTerraform(struct!.httpStatus),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    initial_backoff: {
      value: cdktf.numberToHclTerraform(struct!.initialBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_backoff: {
      value: cdktf.numberToHclTerraform(struct!.maxBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputDynatraceOtlpResponseRetrySettingsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DestinationOutputDynatraceOtlpResponseRetrySettings | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._backoffRate !== undefined) {
      hasAnyValues = true;
      internalValueResult.backoffRate = this._backoffRate;
    }
    if (this._httpStatus !== undefined) {
      hasAnyValues = true;
      internalValueResult.httpStatus = this._httpStatus;
    }
    if (this._initialBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.initialBackoff = this._initialBackoff;
    }
    if (this._maxBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBackoff = this._maxBackoff;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputDynatraceOtlpResponseRetrySettings | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._backoffRate = undefined;
      this._httpStatus = undefined;
      this._initialBackoff = undefined;
      this._maxBackoff = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._backoffRate = value.backoffRate;
      this._httpStatus = value.httpStatus;
      this._initialBackoff = value.initialBackoff;
      this._maxBackoff = value.maxBackoff;
    }
  }

  // backoff_rate - computed: true, optional: true, required: false
  private _backoffRate?: number; 
  public get backoffRate() {
    return this.getNumberAttribute('backoff_rate');
  }
  public set backoffRate(value: number) {
    this._backoffRate = value;
  }
  public resetBackoffRate() {
    this._backoffRate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get backoffRateInput() {
    return this._backoffRate;
  }

  // http_status - computed: false, optional: false, required: true
  private _httpStatus?: number; 
  public get httpStatus() {
    return this.getNumberAttribute('http_status');
  }
  public set httpStatus(value: number) {
    this._httpStatus = value;
  }
  // Temporarily expose input value. Use with caution.
  public get httpStatusInput() {
    return this._httpStatus;
  }

  // initial_backoff - computed: true, optional: true, required: false
  private _initialBackoff?: number; 
  public get initialBackoff() {
    return this.getNumberAttribute('initial_backoff');
  }
  public set initialBackoff(value: number) {
    this._initialBackoff = value;
  }
  public resetInitialBackoff() {
    this._initialBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get initialBackoffInput() {
    return this._initialBackoff;
  }

  // max_backoff - computed: true, optional: true, required: false
  private _maxBackoff?: number; 
  public get maxBackoff() {
    return this.getNumberAttribute('max_backoff');
  }
  public set maxBackoff(value: number) {
    this._maxBackoff = value;
  }
  public resetMaxBackoff() {
    this._maxBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBackoffInput() {
    return this._maxBackoff;
  }
}

export class DestinationOutputDynatraceOtlpResponseRetrySettingsList extends cdktf.ComplexList {
  public internalValue? : DestinationOutputDynatraceOtlpResponseRetrySettings[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DestinationOutputDynatraceOtlpResponseRetrySettingsOutputReference {
    return new DestinationOutputDynatraceOtlpResponseRetrySettingsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DestinationOutputDynatraceOtlpTimeoutRetrySettings {
  /**
  * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc. Default: 2
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#backoff_rate Destination#backoff_rate}
  */
  readonly backoffRate?: number;
  /**
  * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes). Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#initial_backoff Destination#initial_backoff}
  */
  readonly initialBackoff?: number;
  /**
  * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds). Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#max_backoff Destination#max_backoff}
  */
  readonly maxBackoff?: number;
  /**
  * Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#timeout_retry Destination#timeout_retry}
  */
  readonly timeoutRetry?: boolean | cdktf.IResolvable;
}

export function destinationOutputDynatraceOtlpTimeoutRetrySettingsToTerraform(struct?: DestinationOutputDynatraceOtlpTimeoutRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    backoff_rate: cdktf.numberToTerraform(struct!.backoffRate),
    initial_backoff: cdktf.numberToTerraform(struct!.initialBackoff),
    max_backoff: cdktf.numberToTerraform(struct!.maxBackoff),
    timeout_retry: cdktf.booleanToTerraform(struct!.timeoutRetry),
  }
}


export function destinationOutputDynatraceOtlpTimeoutRetrySettingsToHclTerraform(struct?: DestinationOutputDynatraceOtlpTimeoutRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    backoff_rate: {
      value: cdktf.numberToHclTerraform(struct!.backoffRate),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    initial_backoff: {
      value: cdktf.numberToHclTerraform(struct!.initialBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_backoff: {
      value: cdktf.numberToHclTerraform(struct!.maxBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    timeout_retry: {
      value: cdktf.booleanToHclTerraform(struct!.timeoutRetry),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputDynatraceOtlpTimeoutRetrySettingsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DestinationOutputDynatraceOtlpTimeoutRetrySettings | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._backoffRate !== undefined) {
      hasAnyValues = true;
      internalValueResult.backoffRate = this._backoffRate;
    }
    if (this._initialBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.initialBackoff = this._initialBackoff;
    }
    if (this._maxBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBackoff = this._maxBackoff;
    }
    if (this._timeoutRetry !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutRetry = this._timeoutRetry;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputDynatraceOtlpTimeoutRetrySettings | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._backoffRate = undefined;
      this._initialBackoff = undefined;
      this._maxBackoff = undefined;
      this._timeoutRetry = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._backoffRate = value.backoffRate;
      this._initialBackoff = value.initialBackoff;
      this._maxBackoff = value.maxBackoff;
      this._timeoutRetry = value.timeoutRetry;
    }
  }

  // backoff_rate - computed: true, optional: true, required: false
  private _backoffRate?: number; 
  public get backoffRate() {
    return this.getNumberAttribute('backoff_rate');
  }
  public set backoffRate(value: number) {
    this._backoffRate = value;
  }
  public resetBackoffRate() {
    this._backoffRate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get backoffRateInput() {
    return this._backoffRate;
  }

  // initial_backoff - computed: true, optional: true, required: false
  private _initialBackoff?: number; 
  public get initialBackoff() {
    return this.getNumberAttribute('initial_backoff');
  }
  public set initialBackoff(value: number) {
    this._initialBackoff = value;
  }
  public resetInitialBackoff() {
    this._initialBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get initialBackoffInput() {
    return this._initialBackoff;
  }

  // max_backoff - computed: true, optional: true, required: false
  private _maxBackoff?: number; 
  public get maxBackoff() {
    return this.getNumberAttribute('max_backoff');
  }
  public set maxBackoff(value: number) {
    this._maxBackoff = value;
  }
  public resetMaxBackoff() {
    this._maxBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBackoffInput() {
    return this._maxBackoff;
  }

  // timeout_retry - computed: true, optional: true, required: false
  private _timeoutRetry?: boolean | cdktf.IResolvable; 
  public get timeoutRetry() {
    return this.getBooleanAttribute('timeout_retry');
  }
  public set timeoutRetry(value: boolean | cdktf.IResolvable) {
    this._timeoutRetry = value;
  }
  public resetTimeoutRetry() {
    this._timeoutRetry = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutRetryInput() {
    return this._timeoutRetry;
  }
}
export interface DestinationOutputDynatraceOtlp {
  /**
  * Default: "Authorization"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#auth_token_name Destination#auth_token_name}
  */
  readonly authTokenName?: string;
  /**
  * Type of compression to apply to messages sent to the OpenTelemetry endpoint. Default: "gzip"; must be one of ["none", "deflate", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#compress Destination#compress}
  */
  readonly compress?: string;
  /**
  * Maximum number of ongoing requests before blocking. Default: 5
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#concurrency Destination#concurrency}
  */
  readonly concurrency?: number;
  /**
  * Amount of time (milliseconds) to wait for the connection to establish before retrying. Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#connection_timeout Destination#connection_timeout}
  */
  readonly connectionTimeout?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#description Destination#description}
  */
  readonly description?: string;
  /**
  * The endpoint where Dynatrace events will be sent. Enter any valid URL or an IP address (IPv4 or IPv6; enclose IPv6 addresses in square brackets). Default: "https://{your-environment-id}.live.dynatrace.com/api/v2/otlp"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#endpoint Destination#endpoint}
  */
  readonly endpoint?: string;
  /**
  * Select the type of Dynatrace endpoint configured. Default: "saas"; must be one of ["saas", "ag"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#endpoint_type Destination#endpoint_type}
  */
  readonly endpointType?: string;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#environment Destination#environment}
  */
  readonly environment?: string;
  /**
  * Headers to add to all events
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#extra_http_headers Destination#extra_http_headers}
  */
  readonly extraHttpHeaders?: DestinationOutputDynatraceOtlpExtraHttpHeaders[] | cdktf.IResolvable;
  /**
  * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below. Default: "none"; must be one of ["payload", "payloadAndHeaders", "none"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#failed_request_logging_mode Destination#failed_request_logging_mode}
  */
  readonly failedRequestLoggingMode?: string;
  /**
  * Maximum time between requests. Small values could cause the payload size to be smaller than the configured Body size limit. Default: 1
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#flush_period_sec Destination#flush_period_sec}
  */
  readonly flushPeriodSec?: number;
  /**
  * Type of compression to apply to messages sent to the OpenTelemetry endpoint. Default: "gzip"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#http_compress Destination#http_compress}
  */
  readonly httpCompress?: string;
  /**
  * If you want to send logs to the default `{endpoint}/v1/logs` endpoint, leave this field empty; otherwise, specify the desired endpoint
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#http_logs_endpoint_override Destination#http_logs_endpoint_override}
  */
  readonly httpLogsEndpointOverride?: string;
  /**
  * If you want to send metrics to the default `{endpoint}/v1/metrics` endpoint, leave this field empty; otherwise, specify the desired endpoint
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#http_metrics_endpoint_override Destination#http_metrics_endpoint_override}
  */
  readonly httpMetricsEndpointOverride?: string;
  /**
  * If you want to send traces to the default `{endpoint}/v1/traces` endpoint, leave this field empty; otherwise, specify the desired endpoint
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#http_traces_endpoint_override Destination#http_traces_endpoint_override}
  */
  readonly httpTracesEndpointOverride?: string;
  /**
  * Unique ID for this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#id Destination#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * Disable to close the connection immediately after sending the outgoing request. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#keep_alive Destination#keep_alive}
  */
  readonly keepAlive?: boolean | cdktf.IResolvable;
  /**
  * How often the sender should ping the peer to keep the connection open. Default: 30
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#keep_alive_time Destination#keep_alive_time}
  */
  readonly keepAliveTime?: number;
  /**
  * Maximum size (in KB) of the request body. The maximum payload size is 4 MB. If this limit is exceeded, the entire OTLP message is dropped. Default: 2048
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#max_payload_size_kb Destination#max_payload_size_kb}
  */
  readonly maxPayloadSizeKb?: number;
  /**
  * List of key-value pairs to send with each gRPC request. Value supports JavaScript expressions that are evaluated just once, when the destination gets started. To pass credentials as metadata, use 'C.Secret'.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#metadata Destination#metadata}
  */
  readonly metadata?: DestinationOutputDynatraceOtlpMetadata[] | cdktf.IResolvable;
  /**
  * How to handle events when all receivers are exerting backpressure. Default: "block"; must be one of ["block", "drop", "queue"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#on_backpressure Destination#on_backpressure}
  */
  readonly onBackpressure?: string;
  /**
  * The version of OTLP Protobuf definitions to use when structuring data to send. Default: "1.3.1"; must be "1.3.1"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#otlp_version Destination#otlp_version}
  */
  readonly otlpVersion?: string;
  /**
  * Pipeline to process data before sending out to this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pipeline Destination#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pq_compress Destination#pq_compress}
  */
  readonly pqCompress?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pq_controls Destination#pq_controls}
  */
  readonly pqControls?: DestinationOutputDynatraceOtlpPqControls;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.). Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pq_max_file_size Destination#pq_max_file_size}
  */
  readonly pqMaxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pq_max_size Destination#pq_max_size}
  */
  readonly pqMaxSize?: string;
  /**
  * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem. Default: "error"; must be one of ["error", "backpressure", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pq_mode Destination#pq_mode}
  */
  readonly pqMode?: string;
  /**
  * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged. Default: "block"; must be one of ["block", "drop"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pq_on_backpressure Destination#pq_on_backpressure}
  */
  readonly pqOnBackpressure?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pq_path Destination#pq_path}
  */
  readonly pqPath?: string;
  /**
  * Select a transport option for Dynatrace. Default: "http"; must be "http"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#protocol Destination#protocol}
  */
  readonly protocol?: string;
  /**
  * Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's). 
  *         Enabled by default. When this setting is also present in TLS Settings (Client Side), 
  *         that value will take precedence.
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#reject_unauthorized Destination#reject_unauthorized}
  */
  readonly rejectUnauthorized?: boolean | cdktf.IResolvable;
  /**
  * Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#response_honor_retry_after_header Destination#response_honor_retry_after_header}
  */
  readonly responseHonorRetryAfterHeader?: boolean | cdktf.IResolvable;
  /**
  * Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#response_retry_settings Destination#response_retry_settings}
  */
  readonly responseRetrySettings?: DestinationOutputDynatraceOtlpResponseRetrySettings[] | cdktf.IResolvable;
  /**
  * List of headers that are safe to log in plain text. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#safe_headers Destination#safe_headers}
  */
  readonly safeHeaders?: string[];
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#streamtags Destination#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Fields to automatically add to events, such as cribl_pipe. Supports wildcards. Default: ["cribl_pipe"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#system_fields Destination#system_fields}
  */
  readonly systemFields?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#timeout_retry_settings Destination#timeout_retry_settings}
  */
  readonly timeoutRetrySettings?: DestinationOutputDynatraceOtlpTimeoutRetrySettings;
  /**
  * Amount of time, in seconds, to wait for a request to complete before canceling it. Default: 30
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#timeout_sec Destination#timeout_sec}
  */
  readonly timeoutSec?: number;
  /**
  * Select or create a stored text secret
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#token_secret Destination#token_secret}
  */
  readonly tokenSecret: string;
  /**
  * must be "dynatrace_otlp"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#type Destination#type}
  */
  readonly type?: string;
  /**
  * Enable round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. For optimal performance, consider enabling this setting for non-load balanced destinations. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#use_round_robin_dns Destination#use_round_robin_dns}
  */
  readonly useRoundRobinDns?: boolean | cdktf.IResolvable;
}

export function destinationOutputDynatraceOtlpToTerraform(struct?: DestinationOutputDynatraceOtlp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    auth_token_name: cdktf.stringToTerraform(struct!.authTokenName),
    compress: cdktf.stringToTerraform(struct!.compress),
    concurrency: cdktf.numberToTerraform(struct!.concurrency),
    connection_timeout: cdktf.numberToTerraform(struct!.connectionTimeout),
    description: cdktf.stringToTerraform(struct!.description),
    endpoint: cdktf.stringToTerraform(struct!.endpoint),
    endpoint_type: cdktf.stringToTerraform(struct!.endpointType),
    environment: cdktf.stringToTerraform(struct!.environment),
    extra_http_headers: cdktf.listMapper(destinationOutputDynatraceOtlpExtraHttpHeadersToTerraform, false)(struct!.extraHttpHeaders),
    failed_request_logging_mode: cdktf.stringToTerraform(struct!.failedRequestLoggingMode),
    flush_period_sec: cdktf.numberToTerraform(struct!.flushPeriodSec),
    http_compress: cdktf.stringToTerraform(struct!.httpCompress),
    http_logs_endpoint_override: cdktf.stringToTerraform(struct!.httpLogsEndpointOverride),
    http_metrics_endpoint_override: cdktf.stringToTerraform(struct!.httpMetricsEndpointOverride),
    http_traces_endpoint_override: cdktf.stringToTerraform(struct!.httpTracesEndpointOverride),
    id: cdktf.stringToTerraform(struct!.id),
    keep_alive: cdktf.booleanToTerraform(struct!.keepAlive),
    keep_alive_time: cdktf.numberToTerraform(struct!.keepAliveTime),
    max_payload_size_kb: cdktf.numberToTerraform(struct!.maxPayloadSizeKb),
    metadata: cdktf.listMapper(destinationOutputDynatraceOtlpMetadataToTerraform, false)(struct!.metadata),
    on_backpressure: cdktf.stringToTerraform(struct!.onBackpressure),
    otlp_version: cdktf.stringToTerraform(struct!.otlpVersion),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    pq_compress: cdktf.stringToTerraform(struct!.pqCompress),
    pq_controls: destinationOutputDynatraceOtlpPqControlsToTerraform(struct!.pqControls),
    pq_max_file_size: cdktf.stringToTerraform(struct!.pqMaxFileSize),
    pq_max_size: cdktf.stringToTerraform(struct!.pqMaxSize),
    pq_mode: cdktf.stringToTerraform(struct!.pqMode),
    pq_on_backpressure: cdktf.stringToTerraform(struct!.pqOnBackpressure),
    pq_path: cdktf.stringToTerraform(struct!.pqPath),
    protocol: cdktf.stringToTerraform(struct!.protocol),
    reject_unauthorized: cdktf.booleanToTerraform(struct!.rejectUnauthorized),
    response_honor_retry_after_header: cdktf.booleanToTerraform(struct!.responseHonorRetryAfterHeader),
    response_retry_settings: cdktf.listMapper(destinationOutputDynatraceOtlpResponseRetrySettingsToTerraform, false)(struct!.responseRetrySettings),
    safe_headers: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.safeHeaders),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    system_fields: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.systemFields),
    timeout_retry_settings: destinationOutputDynatraceOtlpTimeoutRetrySettingsToTerraform(struct!.timeoutRetrySettings),
    timeout_sec: cdktf.numberToTerraform(struct!.timeoutSec),
    token_secret: cdktf.stringToTerraform(struct!.tokenSecret),
    type: cdktf.stringToTerraform(struct!.type),
    use_round_robin_dns: cdktf.booleanToTerraform(struct!.useRoundRobinDns),
  }
}


export function destinationOutputDynatraceOtlpToHclTerraform(struct?: DestinationOutputDynatraceOtlp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    auth_token_name: {
      value: cdktf.stringToHclTerraform(struct!.authTokenName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    compress: {
      value: cdktf.stringToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    concurrency: {
      value: cdktf.numberToHclTerraform(struct!.concurrency),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    connection_timeout: {
      value: cdktf.numberToHclTerraform(struct!.connectionTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    endpoint: {
      value: cdktf.stringToHclTerraform(struct!.endpoint),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    endpoint_type: {
      value: cdktf.stringToHclTerraform(struct!.endpointType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    extra_http_headers: {
      value: cdktf.listMapperHcl(destinationOutputDynatraceOtlpExtraHttpHeadersToHclTerraform, false)(struct!.extraHttpHeaders),
      isBlock: true,
      type: "list",
      storageClassType: "DestinationOutputDynatraceOtlpExtraHttpHeadersList",
    },
    failed_request_logging_mode: {
      value: cdktf.stringToHclTerraform(struct!.failedRequestLoggingMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    flush_period_sec: {
      value: cdktf.numberToHclTerraform(struct!.flushPeriodSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    http_compress: {
      value: cdktf.stringToHclTerraform(struct!.httpCompress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    http_logs_endpoint_override: {
      value: cdktf.stringToHclTerraform(struct!.httpLogsEndpointOverride),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    http_metrics_endpoint_override: {
      value: cdktf.stringToHclTerraform(struct!.httpMetricsEndpointOverride),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    http_traces_endpoint_override: {
      value: cdktf.stringToHclTerraform(struct!.httpTracesEndpointOverride),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    keep_alive: {
      value: cdktf.booleanToHclTerraform(struct!.keepAlive),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    keep_alive_time: {
      value: cdktf.numberToHclTerraform(struct!.keepAliveTime),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_payload_size_kb: {
      value: cdktf.numberToHclTerraform(struct!.maxPayloadSizeKb),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    metadata: {
      value: cdktf.listMapperHcl(destinationOutputDynatraceOtlpMetadataToHclTerraform, false)(struct!.metadata),
      isBlock: true,
      type: "list",
      storageClassType: "DestinationOutputDynatraceOtlpMetadataList",
    },
    on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.onBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    otlp_version: {
      value: cdktf.stringToHclTerraform(struct!.otlpVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_compress: {
      value: cdktf.stringToHclTerraform(struct!.pqCompress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_controls: {
      value: destinationOutputDynatraceOtlpPqControlsToHclTerraform(struct!.pqControls),
      isBlock: true,
      type: "struct",
      storageClassType: "DestinationOutputDynatraceOtlpPqControls",
    },
    pq_max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_max_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_mode: {
      value: cdktf.stringToHclTerraform(struct!.pqMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.pqOnBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_path: {
      value: cdktf.stringToHclTerraform(struct!.pqPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    protocol: {
      value: cdktf.stringToHclTerraform(struct!.protocol),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reject_unauthorized: {
      value: cdktf.booleanToHclTerraform(struct!.rejectUnauthorized),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    response_honor_retry_after_header: {
      value: cdktf.booleanToHclTerraform(struct!.responseHonorRetryAfterHeader),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    response_retry_settings: {
      value: cdktf.listMapperHcl(destinationOutputDynatraceOtlpResponseRetrySettingsToHclTerraform, false)(struct!.responseRetrySettings),
      isBlock: true,
      type: "list",
      storageClassType: "DestinationOutputDynatraceOtlpResponseRetrySettingsList",
    },
    safe_headers: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.safeHeaders),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    system_fields: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.systemFields),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    timeout_retry_settings: {
      value: destinationOutputDynatraceOtlpTimeoutRetrySettingsToHclTerraform(struct!.timeoutRetrySettings),
      isBlock: true,
      type: "struct",
      storageClassType: "DestinationOutputDynatraceOtlpTimeoutRetrySettings",
    },
    timeout_sec: {
      value: cdktf.numberToHclTerraform(struct!.timeoutSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    token_secret: {
      value: cdktf.stringToHclTerraform(struct!.tokenSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    use_round_robin_dns: {
      value: cdktf.booleanToHclTerraform(struct!.useRoundRobinDns),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputDynatraceOtlpOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DestinationOutputDynatraceOtlp | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._authTokenName !== undefined) {
      hasAnyValues = true;
      internalValueResult.authTokenName = this._authTokenName;
    }
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._concurrency !== undefined) {
      hasAnyValues = true;
      internalValueResult.concurrency = this._concurrency;
    }
    if (this._connectionTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.connectionTimeout = this._connectionTimeout;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._endpoint !== undefined) {
      hasAnyValues = true;
      internalValueResult.endpoint = this._endpoint;
    }
    if (this._endpointType !== undefined) {
      hasAnyValues = true;
      internalValueResult.endpointType = this._endpointType;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._extraHttpHeaders?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.extraHttpHeaders = this._extraHttpHeaders?.internalValue;
    }
    if (this._failedRequestLoggingMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.failedRequestLoggingMode = this._failedRequestLoggingMode;
    }
    if (this._flushPeriodSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.flushPeriodSec = this._flushPeriodSec;
    }
    if (this._httpCompress !== undefined) {
      hasAnyValues = true;
      internalValueResult.httpCompress = this._httpCompress;
    }
    if (this._httpLogsEndpointOverride !== undefined) {
      hasAnyValues = true;
      internalValueResult.httpLogsEndpointOverride = this._httpLogsEndpointOverride;
    }
    if (this._httpMetricsEndpointOverride !== undefined) {
      hasAnyValues = true;
      internalValueResult.httpMetricsEndpointOverride = this._httpMetricsEndpointOverride;
    }
    if (this._httpTracesEndpointOverride !== undefined) {
      hasAnyValues = true;
      internalValueResult.httpTracesEndpointOverride = this._httpTracesEndpointOverride;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._keepAlive !== undefined) {
      hasAnyValues = true;
      internalValueResult.keepAlive = this._keepAlive;
    }
    if (this._keepAliveTime !== undefined) {
      hasAnyValues = true;
      internalValueResult.keepAliveTime = this._keepAliveTime;
    }
    if (this._maxPayloadSizeKb !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxPayloadSizeKb = this._maxPayloadSizeKb;
    }
    if (this._metadata?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadata = this._metadata?.internalValue;
    }
    if (this._onBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.onBackpressure = this._onBackpressure;
    }
    if (this._otlpVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.otlpVersion = this._otlpVersion;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._pqCompress !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqCompress = this._pqCompress;
    }
    if (this._pqControls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqControls = this._pqControls?.internalValue;
    }
    if (this._pqMaxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxFileSize = this._pqMaxFileSize;
    }
    if (this._pqMaxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxSize = this._pqMaxSize;
    }
    if (this._pqMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMode = this._pqMode;
    }
    if (this._pqOnBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqOnBackpressure = this._pqOnBackpressure;
    }
    if (this._pqPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqPath = this._pqPath;
    }
    if (this._protocol !== undefined) {
      hasAnyValues = true;
      internalValueResult.protocol = this._protocol;
    }
    if (this._rejectUnauthorized !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectUnauthorized = this._rejectUnauthorized;
    }
    if (this._responseHonorRetryAfterHeader !== undefined) {
      hasAnyValues = true;
      internalValueResult.responseHonorRetryAfterHeader = this._responseHonorRetryAfterHeader;
    }
    if (this._responseRetrySettings?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.responseRetrySettings = this._responseRetrySettings?.internalValue;
    }
    if (this._safeHeaders !== undefined) {
      hasAnyValues = true;
      internalValueResult.safeHeaders = this._safeHeaders;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._systemFields !== undefined) {
      hasAnyValues = true;
      internalValueResult.systemFields = this._systemFields;
    }
    if (this._timeoutRetrySettings?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutRetrySettings = this._timeoutRetrySettings?.internalValue;
    }
    if (this._timeoutSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutSec = this._timeoutSec;
    }
    if (this._tokenSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.tokenSecret = this._tokenSecret;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._useRoundRobinDns !== undefined) {
      hasAnyValues = true;
      internalValueResult.useRoundRobinDns = this._useRoundRobinDns;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputDynatraceOtlp | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._authTokenName = undefined;
      this._compress = undefined;
      this._concurrency = undefined;
      this._connectionTimeout = undefined;
      this._description = undefined;
      this._endpoint = undefined;
      this._endpointType = undefined;
      this._environment = undefined;
      this._extraHttpHeaders.internalValue = undefined;
      this._failedRequestLoggingMode = undefined;
      this._flushPeriodSec = undefined;
      this._httpCompress = undefined;
      this._httpLogsEndpointOverride = undefined;
      this._httpMetricsEndpointOverride = undefined;
      this._httpTracesEndpointOverride = undefined;
      this._id = undefined;
      this._keepAlive = undefined;
      this._keepAliveTime = undefined;
      this._maxPayloadSizeKb = undefined;
      this._metadata.internalValue = undefined;
      this._onBackpressure = undefined;
      this._otlpVersion = undefined;
      this._pipeline = undefined;
      this._pqCompress = undefined;
      this._pqControls.internalValue = undefined;
      this._pqMaxFileSize = undefined;
      this._pqMaxSize = undefined;
      this._pqMode = undefined;
      this._pqOnBackpressure = undefined;
      this._pqPath = undefined;
      this._protocol = undefined;
      this._rejectUnauthorized = undefined;
      this._responseHonorRetryAfterHeader = undefined;
      this._responseRetrySettings.internalValue = undefined;
      this._safeHeaders = undefined;
      this._streamtags = undefined;
      this._systemFields = undefined;
      this._timeoutRetrySettings.internalValue = undefined;
      this._timeoutSec = undefined;
      this._tokenSecret = undefined;
      this._type = undefined;
      this._useRoundRobinDns = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._authTokenName = value.authTokenName;
      this._compress = value.compress;
      this._concurrency = value.concurrency;
      this._connectionTimeout = value.connectionTimeout;
      this._description = value.description;
      this._endpoint = value.endpoint;
      this._endpointType = value.endpointType;
      this._environment = value.environment;
      this._extraHttpHeaders.internalValue = value.extraHttpHeaders;
      this._failedRequestLoggingMode = value.failedRequestLoggingMode;
      this._flushPeriodSec = value.flushPeriodSec;
      this._httpCompress = value.httpCompress;
      this._httpLogsEndpointOverride = value.httpLogsEndpointOverride;
      this._httpMetricsEndpointOverride = value.httpMetricsEndpointOverride;
      this._httpTracesEndpointOverride = value.httpTracesEndpointOverride;
      this._id = value.id;
      this._keepAlive = value.keepAlive;
      this._keepAliveTime = value.keepAliveTime;
      this._maxPayloadSizeKb = value.maxPayloadSizeKb;
      this._metadata.internalValue = value.metadata;
      this._onBackpressure = value.onBackpressure;
      this._otlpVersion = value.otlpVersion;
      this._pipeline = value.pipeline;
      this._pqCompress = value.pqCompress;
      this._pqControls.internalValue = value.pqControls;
      this._pqMaxFileSize = value.pqMaxFileSize;
      this._pqMaxSize = value.pqMaxSize;
      this._pqMode = value.pqMode;
      this._pqOnBackpressure = value.pqOnBackpressure;
      this._pqPath = value.pqPath;
      this._protocol = value.protocol;
      this._rejectUnauthorized = value.rejectUnauthorized;
      this._responseHonorRetryAfterHeader = value.responseHonorRetryAfterHeader;
      this._responseRetrySettings.internalValue = value.responseRetrySettings;
      this._safeHeaders = value.safeHeaders;
      this._streamtags = value.streamtags;
      this._systemFields = value.systemFields;
      this._timeoutRetrySettings.internalValue = value.timeoutRetrySettings;
      this._timeoutSec = value.timeoutSec;
      this._tokenSecret = value.tokenSecret;
      this._type = value.type;
      this._useRoundRobinDns = value.useRoundRobinDns;
    }
  }

  // auth_token_name - computed: true, optional: true, required: false
  private _authTokenName?: string; 
  public get authTokenName() {
    return this.getStringAttribute('auth_token_name');
  }
  public set authTokenName(value: string) {
    this._authTokenName = value;
  }
  public resetAuthTokenName() {
    this._authTokenName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authTokenNameInput() {
    return this._authTokenName;
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: string; 
  public get compress() {
    return this.getStringAttribute('compress');
  }
  public set compress(value: string) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // concurrency - computed: true, optional: true, required: false
  private _concurrency?: number; 
  public get concurrency() {
    return this.getNumberAttribute('concurrency');
  }
  public set concurrency(value: number) {
    this._concurrency = value;
  }
  public resetConcurrency() {
    this._concurrency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get concurrencyInput() {
    return this._concurrency;
  }

  // connection_timeout - computed: true, optional: true, required: false
  private _connectionTimeout?: number; 
  public get connectionTimeout() {
    return this.getNumberAttribute('connection_timeout');
  }
  public set connectionTimeout(value: number) {
    this._connectionTimeout = value;
  }
  public resetConnectionTimeout() {
    this._connectionTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectionTimeoutInput() {
    return this._connectionTimeout;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // endpoint - computed: true, optional: true, required: false
  private _endpoint?: string; 
  public get endpoint() {
    return this.getStringAttribute('endpoint');
  }
  public set endpoint(value: string) {
    this._endpoint = value;
  }
  public resetEndpoint() {
    this._endpoint = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get endpointInput() {
    return this._endpoint;
  }

  // endpoint_type - computed: true, optional: true, required: false
  private _endpointType?: string; 
  public get endpointType() {
    return this.getStringAttribute('endpoint_type');
  }
  public set endpointType(value: string) {
    this._endpointType = value;
  }
  public resetEndpointType() {
    this._endpointType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get endpointTypeInput() {
    return this._endpointType;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // extra_http_headers - computed: false, optional: true, required: false
  private _extraHttpHeaders = new DestinationOutputDynatraceOtlpExtraHttpHeadersList(this, "extra_http_headers", false);
  public get extraHttpHeaders() {
    return this._extraHttpHeaders;
  }
  public putExtraHttpHeaders(value: DestinationOutputDynatraceOtlpExtraHttpHeaders[] | cdktf.IResolvable) {
    this._extraHttpHeaders.internalValue = value;
  }
  public resetExtraHttpHeaders() {
    this._extraHttpHeaders.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get extraHttpHeadersInput() {
    return this._extraHttpHeaders.internalValue;
  }

  // failed_request_logging_mode - computed: true, optional: true, required: false
  private _failedRequestLoggingMode?: string; 
  public get failedRequestLoggingMode() {
    return this.getStringAttribute('failed_request_logging_mode');
  }
  public set failedRequestLoggingMode(value: string) {
    this._failedRequestLoggingMode = value;
  }
  public resetFailedRequestLoggingMode() {
    this._failedRequestLoggingMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get failedRequestLoggingModeInput() {
    return this._failedRequestLoggingMode;
  }

  // flush_period_sec - computed: true, optional: true, required: false
  private _flushPeriodSec?: number; 
  public get flushPeriodSec() {
    return this.getNumberAttribute('flush_period_sec');
  }
  public set flushPeriodSec(value: number) {
    this._flushPeriodSec = value;
  }
  public resetFlushPeriodSec() {
    this._flushPeriodSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get flushPeriodSecInput() {
    return this._flushPeriodSec;
  }

  // http_compress - computed: true, optional: true, required: false
  private _httpCompress?: string; 
  public get httpCompress() {
    return this.getStringAttribute('http_compress');
  }
  public set httpCompress(value: string) {
    this._httpCompress = value;
  }
  public resetHttpCompress() {
    this._httpCompress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get httpCompressInput() {
    return this._httpCompress;
  }

  // http_logs_endpoint_override - computed: false, optional: true, required: false
  private _httpLogsEndpointOverride?: string; 
  public get httpLogsEndpointOverride() {
    return this.getStringAttribute('http_logs_endpoint_override');
  }
  public set httpLogsEndpointOverride(value: string) {
    this._httpLogsEndpointOverride = value;
  }
  public resetHttpLogsEndpointOverride() {
    this._httpLogsEndpointOverride = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get httpLogsEndpointOverrideInput() {
    return this._httpLogsEndpointOverride;
  }

  // http_metrics_endpoint_override - computed: false, optional: true, required: false
  private _httpMetricsEndpointOverride?: string; 
  public get httpMetricsEndpointOverride() {
    return this.getStringAttribute('http_metrics_endpoint_override');
  }
  public set httpMetricsEndpointOverride(value: string) {
    this._httpMetricsEndpointOverride = value;
  }
  public resetHttpMetricsEndpointOverride() {
    this._httpMetricsEndpointOverride = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get httpMetricsEndpointOverrideInput() {
    return this._httpMetricsEndpointOverride;
  }

  // http_traces_endpoint_override - computed: false, optional: true, required: false
  private _httpTracesEndpointOverride?: string; 
  public get httpTracesEndpointOverride() {
    return this.getStringAttribute('http_traces_endpoint_override');
  }
  public set httpTracesEndpointOverride(value: string) {
    this._httpTracesEndpointOverride = value;
  }
  public resetHttpTracesEndpointOverride() {
    this._httpTracesEndpointOverride = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get httpTracesEndpointOverrideInput() {
    return this._httpTracesEndpointOverride;
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // keep_alive - computed: true, optional: true, required: false
  private _keepAlive?: boolean | cdktf.IResolvable; 
  public get keepAlive() {
    return this.getBooleanAttribute('keep_alive');
  }
  public set keepAlive(value: boolean | cdktf.IResolvable) {
    this._keepAlive = value;
  }
  public resetKeepAlive() {
    this._keepAlive = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keepAliveInput() {
    return this._keepAlive;
  }

  // keep_alive_time - computed: true, optional: true, required: false
  private _keepAliveTime?: number; 
  public get keepAliveTime() {
    return this.getNumberAttribute('keep_alive_time');
  }
  public set keepAliveTime(value: number) {
    this._keepAliveTime = value;
  }
  public resetKeepAliveTime() {
    this._keepAliveTime = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keepAliveTimeInput() {
    return this._keepAliveTime;
  }

  // max_payload_size_kb - computed: true, optional: true, required: false
  private _maxPayloadSizeKb?: number; 
  public get maxPayloadSizeKb() {
    return this.getNumberAttribute('max_payload_size_kb');
  }
  public set maxPayloadSizeKb(value: number) {
    this._maxPayloadSizeKb = value;
  }
  public resetMaxPayloadSizeKb() {
    this._maxPayloadSizeKb = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxPayloadSizeKbInput() {
    return this._maxPayloadSizeKb;
  }

  // metadata - computed: false, optional: true, required: false
  private _metadata = new DestinationOutputDynatraceOtlpMetadataList(this, "metadata", false);
  public get metadata() {
    return this._metadata;
  }
  public putMetadata(value: DestinationOutputDynatraceOtlpMetadata[] | cdktf.IResolvable) {
    this._metadata.internalValue = value;
  }
  public resetMetadata() {
    this._metadata.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataInput() {
    return this._metadata.internalValue;
  }

  // on_backpressure - computed: true, optional: true, required: false
  private _onBackpressure?: string; 
  public get onBackpressure() {
    return this.getStringAttribute('on_backpressure');
  }
  public set onBackpressure(value: string) {
    this._onBackpressure = value;
  }
  public resetOnBackpressure() {
    this._onBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get onBackpressureInput() {
    return this._onBackpressure;
  }

  // otlp_version - computed: true, optional: true, required: false
  private _otlpVersion?: string; 
  public get otlpVersion() {
    return this.getStringAttribute('otlp_version');
  }
  public set otlpVersion(value: string) {
    this._otlpVersion = value;
  }
  public resetOtlpVersion() {
    this._otlpVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get otlpVersionInput() {
    return this._otlpVersion;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // pq_compress - computed: true, optional: true, required: false
  private _pqCompress?: string; 
  public get pqCompress() {
    return this.getStringAttribute('pq_compress');
  }
  public set pqCompress(value: string) {
    this._pqCompress = value;
  }
  public resetPqCompress() {
    this._pqCompress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqCompressInput() {
    return this._pqCompress;
  }

  // pq_controls - computed: false, optional: true, required: false
  private _pqControls = new DestinationOutputDynatraceOtlpPqControlsOutputReference(this, "pq_controls");
  public get pqControls() {
    return this._pqControls;
  }
  public putPqControls(value: DestinationOutputDynatraceOtlpPqControls) {
    this._pqControls.internalValue = value;
  }
  public resetPqControls() {
    this._pqControls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqControlsInput() {
    return this._pqControls.internalValue;
  }

  // pq_max_file_size - computed: true, optional: true, required: false
  private _pqMaxFileSize?: string; 
  public get pqMaxFileSize() {
    return this.getStringAttribute('pq_max_file_size');
  }
  public set pqMaxFileSize(value: string) {
    this._pqMaxFileSize = value;
  }
  public resetPqMaxFileSize() {
    this._pqMaxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxFileSizeInput() {
    return this._pqMaxFileSize;
  }

  // pq_max_size - computed: true, optional: true, required: false
  private _pqMaxSize?: string; 
  public get pqMaxSize() {
    return this.getStringAttribute('pq_max_size');
  }
  public set pqMaxSize(value: string) {
    this._pqMaxSize = value;
  }
  public resetPqMaxSize() {
    this._pqMaxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxSizeInput() {
    return this._pqMaxSize;
  }

  // pq_mode - computed: true, optional: true, required: false
  private _pqMode?: string; 
  public get pqMode() {
    return this.getStringAttribute('pq_mode');
  }
  public set pqMode(value: string) {
    this._pqMode = value;
  }
  public resetPqMode() {
    this._pqMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqModeInput() {
    return this._pqMode;
  }

  // pq_on_backpressure - computed: true, optional: true, required: false
  private _pqOnBackpressure?: string; 
  public get pqOnBackpressure() {
    return this.getStringAttribute('pq_on_backpressure');
  }
  public set pqOnBackpressure(value: string) {
    this._pqOnBackpressure = value;
  }
  public resetPqOnBackpressure() {
    this._pqOnBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqOnBackpressureInput() {
    return this._pqOnBackpressure;
  }

  // pq_path - computed: true, optional: true, required: false
  private _pqPath?: string; 
  public get pqPath() {
    return this.getStringAttribute('pq_path');
  }
  public set pqPath(value: string) {
    this._pqPath = value;
  }
  public resetPqPath() {
    this._pqPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqPathInput() {
    return this._pqPath;
  }

  // protocol - computed: true, optional: true, required: false
  private _protocol?: string; 
  public get protocol() {
    return this.getStringAttribute('protocol');
  }
  public set protocol(value: string) {
    this._protocol = value;
  }
  public resetProtocol() {
    this._protocol = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get protocolInput() {
    return this._protocol;
  }

  // reject_unauthorized - computed: true, optional: true, required: false
  private _rejectUnauthorized?: boolean | cdktf.IResolvable; 
  public get rejectUnauthorized() {
    return this.getBooleanAttribute('reject_unauthorized');
  }
  public set rejectUnauthorized(value: boolean | cdktf.IResolvable) {
    this._rejectUnauthorized = value;
  }
  public resetRejectUnauthorized() {
    this._rejectUnauthorized = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectUnauthorizedInput() {
    return this._rejectUnauthorized;
  }

  // response_honor_retry_after_header - computed: true, optional: true, required: false
  private _responseHonorRetryAfterHeader?: boolean | cdktf.IResolvable; 
  public get responseHonorRetryAfterHeader() {
    return this.getBooleanAttribute('response_honor_retry_after_header');
  }
  public set responseHonorRetryAfterHeader(value: boolean | cdktf.IResolvable) {
    this._responseHonorRetryAfterHeader = value;
  }
  public resetResponseHonorRetryAfterHeader() {
    this._responseHonorRetryAfterHeader = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get responseHonorRetryAfterHeaderInput() {
    return this._responseHonorRetryAfterHeader;
  }

  // response_retry_settings - computed: false, optional: true, required: false
  private _responseRetrySettings = new DestinationOutputDynatraceOtlpResponseRetrySettingsList(this, "response_retry_settings", false);
  public get responseRetrySettings() {
    return this._responseRetrySettings;
  }
  public putResponseRetrySettings(value: DestinationOutputDynatraceOtlpResponseRetrySettings[] | cdktf.IResolvable) {
    this._responseRetrySettings.internalValue = value;
  }
  public resetResponseRetrySettings() {
    this._responseRetrySettings.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get responseRetrySettingsInput() {
    return this._responseRetrySettings.internalValue;
  }

  // safe_headers - computed: true, optional: true, required: false
  private _safeHeaders?: string[]; 
  public get safeHeaders() {
    return this.getListAttribute('safe_headers');
  }
  public set safeHeaders(value: string[]) {
    this._safeHeaders = value;
  }
  public resetSafeHeaders() {
    this._safeHeaders = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get safeHeadersInput() {
    return this._safeHeaders;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // system_fields - computed: true, optional: true, required: false
  private _systemFields?: string[]; 
  public get systemFields() {
    return this.getListAttribute('system_fields');
  }
  public set systemFields(value: string[]) {
    this._systemFields = value;
  }
  public resetSystemFields() {
    this._systemFields = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get systemFieldsInput() {
    return this._systemFields;
  }

  // timeout_retry_settings - computed: false, optional: true, required: false
  private _timeoutRetrySettings = new DestinationOutputDynatraceOtlpTimeoutRetrySettingsOutputReference(this, "timeout_retry_settings");
  public get timeoutRetrySettings() {
    return this._timeoutRetrySettings;
  }
  public putTimeoutRetrySettings(value: DestinationOutputDynatraceOtlpTimeoutRetrySettings) {
    this._timeoutRetrySettings.internalValue = value;
  }
  public resetTimeoutRetrySettings() {
    this._timeoutRetrySettings.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutRetrySettingsInput() {
    return this._timeoutRetrySettings.internalValue;
  }

  // timeout_sec - computed: true, optional: true, required: false
  private _timeoutSec?: number; 
  public get timeoutSec() {
    return this.getNumberAttribute('timeout_sec');
  }
  public set timeoutSec(value: number) {
    this._timeoutSec = value;
  }
  public resetTimeoutSec() {
    this._timeoutSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutSecInput() {
    return this._timeoutSec;
  }

  // token_secret - computed: false, optional: false, required: true
  private _tokenSecret?: string; 
  public get tokenSecret() {
    return this.getStringAttribute('token_secret');
  }
  public set tokenSecret(value: string) {
    this._tokenSecret = value;
  }
  // Temporarily expose input value. Use with caution.
  public get tokenSecretInput() {
    return this._tokenSecret;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // use_round_robin_dns - computed: true, optional: true, required: false
  private _useRoundRobinDns?: boolean | cdktf.IResolvable; 
  public get useRoundRobinDns() {
    return this.getBooleanAttribute('use_round_robin_dns');
  }
  public set useRoundRobinDns(value: boolean | cdktf.IResolvable) {
    this._useRoundRobinDns = value;
  }
  public resetUseRoundRobinDns() {
    this._useRoundRobinDns = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get useRoundRobinDnsInput() {
    return this._useRoundRobinDns;
  }
}
export interface DestinationOutputElasticAuth {
  /**
  * Enter credentials directly, or select a stored secret. Default: "manual"; must be one of ["manual", "secret", "manualAPIKey", "textSecret"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#auth_type Destination#auth_type}
  */
  readonly authType?: string;
  /**
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#disabled Destination#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
}

export function destinationOutputElasticAuthToTerraform(struct?: DestinationOutputElasticAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    auth_type: cdktf.stringToTerraform(struct!.authType),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
  }
}


export function destinationOutputElasticAuthToHclTerraform(struct?: DestinationOutputElasticAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    auth_type: {
      value: cdktf.stringToHclTerraform(struct!.authType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputElasticAuthOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DestinationOutputElasticAuth | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._authType !== undefined) {
      hasAnyValues = true;
      internalValueResult.authType = this._authType;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputElasticAuth | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._authType = undefined;
      this._disabled = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._authType = value.authType;
      this._disabled = value.disabled;
    }
  }

  // auth_type - computed: true, optional: true, required: false
  private _authType?: string; 
  public get authType() {
    return this.getStringAttribute('auth_type');
  }
  public set authType(value: string) {
    this._authType = value;
  }
  public resetAuthType() {
    this._authType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authTypeInput() {
    return this._authType;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }
}
export interface DestinationOutputElasticExtraHttpHeaders {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#name Destination#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#value Destination#value}
  */
  readonly value: string;
}

export function destinationOutputElasticExtraHttpHeadersToTerraform(struct?: DestinationOutputElasticExtraHttpHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function destinationOutputElasticExtraHttpHeadersToHclTerraform(struct?: DestinationOutputElasticExtraHttpHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputElasticExtraHttpHeadersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DestinationOutputElasticExtraHttpHeaders | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputElasticExtraHttpHeaders | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DestinationOutputElasticExtraHttpHeadersList extends cdktf.ComplexList {
  public internalValue? : DestinationOutputElasticExtraHttpHeaders[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DestinationOutputElasticExtraHttpHeadersOutputReference {
    return new DestinationOutputElasticExtraHttpHeadersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DestinationOutputElasticExtraParams {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#name Destination#name}
  */
  readonly name: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#value Destination#value}
  */
  readonly value: string;
}

export function destinationOutputElasticExtraParamsToTerraform(struct?: DestinationOutputElasticExtraParams | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function destinationOutputElasticExtraParamsToHclTerraform(struct?: DestinationOutputElasticExtraParams | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputElasticExtraParamsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DestinationOutputElasticExtraParams | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputElasticExtraParams | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DestinationOutputElasticExtraParamsList extends cdktf.ComplexList {
  public internalValue? : DestinationOutputElasticExtraParams[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DestinationOutputElasticExtraParamsOutputReference {
    return new DestinationOutputElasticExtraParamsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DestinationOutputElasticPqControls {
}

export function destinationOutputElasticPqControlsToTerraform(struct?: DestinationOutputElasticPqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function destinationOutputElasticPqControlsToHclTerraform(struct?: DestinationOutputElasticPqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class DestinationOutputElasticPqControlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DestinationOutputElasticPqControls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputElasticPqControls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface DestinationOutputElasticResponseRetrySettings {
  /**
  * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc. Default: 2
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#backoff_rate Destination#backoff_rate}
  */
  readonly backoffRate?: number;
  /**
  * The HTTP response status code that will trigger retries
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#http_status Destination#http_status}
  */
  readonly httpStatus: number;
  /**
  * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes). Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#initial_backoff Destination#initial_backoff}
  */
  readonly initialBackoff?: number;
  /**
  * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds). Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#max_backoff Destination#max_backoff}
  */
  readonly maxBackoff?: number;
}

export function destinationOutputElasticResponseRetrySettingsToTerraform(struct?: DestinationOutputElasticResponseRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    backoff_rate: cdktf.numberToTerraform(struct!.backoffRate),
    http_status: cdktf.numberToTerraform(struct!.httpStatus),
    initial_backoff: cdktf.numberToTerraform(struct!.initialBackoff),
    max_backoff: cdktf.numberToTerraform(struct!.maxBackoff),
  }
}


export function destinationOutputElasticResponseRetrySettingsToHclTerraform(struct?: DestinationOutputElasticResponseRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    backoff_rate: {
      value: cdktf.numberToHclTerraform(struct!.backoffRate),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    http_status: {
      value: cdktf.numberToHclTerraform(struct!.httpStatus),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    initial_backoff: {
      value: cdktf.numberToHclTerraform(struct!.initialBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_backoff: {
      value: cdktf.numberToHclTerraform(struct!.maxBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputElasticResponseRetrySettingsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DestinationOutputElasticResponseRetrySettings | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._backoffRate !== undefined) {
      hasAnyValues = true;
      internalValueResult.backoffRate = this._backoffRate;
    }
    if (this._httpStatus !== undefined) {
      hasAnyValues = true;
      internalValueResult.httpStatus = this._httpStatus;
    }
    if (this._initialBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.initialBackoff = this._initialBackoff;
    }
    if (this._maxBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBackoff = this._maxBackoff;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputElasticResponseRetrySettings | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._backoffRate = undefined;
      this._httpStatus = undefined;
      this._initialBackoff = undefined;
      this._maxBackoff = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._backoffRate = value.backoffRate;
      this._httpStatus = value.httpStatus;
      this._initialBackoff = value.initialBackoff;
      this._maxBackoff = value.maxBackoff;
    }
  }

  // backoff_rate - computed: true, optional: true, required: false
  private _backoffRate?: number; 
  public get backoffRate() {
    return this.getNumberAttribute('backoff_rate');
  }
  public set backoffRate(value: number) {
    this._backoffRate = value;
  }
  public resetBackoffRate() {
    this._backoffRate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get backoffRateInput() {
    return this._backoffRate;
  }

  // http_status - computed: false, optional: false, required: true
  private _httpStatus?: number; 
  public get httpStatus() {
    return this.getNumberAttribute('http_status');
  }
  public set httpStatus(value: number) {
    this._httpStatus = value;
  }
  // Temporarily expose input value. Use with caution.
  public get httpStatusInput() {
    return this._httpStatus;
  }

  // initial_backoff - computed: true, optional: true, required: false
  private _initialBackoff?: number; 
  public get initialBackoff() {
    return this.getNumberAttribute('initial_backoff');
  }
  public set initialBackoff(value: number) {
    this._initialBackoff = value;
  }
  public resetInitialBackoff() {
    this._initialBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get initialBackoffInput() {
    return this._initialBackoff;
  }

  // max_backoff - computed: true, optional: true, required: false
  private _maxBackoff?: number; 
  public get maxBackoff() {
    return this.getNumberAttribute('max_backoff');
  }
  public set maxBackoff(value: number) {
    this._maxBackoff = value;
  }
  public resetMaxBackoff() {
    this._maxBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBackoffInput() {
    return this._maxBackoff;
  }
}

export class DestinationOutputElasticResponseRetrySettingsList extends cdktf.ComplexList {
  public internalValue? : DestinationOutputElasticResponseRetrySettings[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DestinationOutputElasticResponseRetrySettingsOutputReference {
    return new DestinationOutputElasticResponseRetrySettingsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DestinationOutputElasticTimeoutRetrySettings {
  /**
  * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc. Default: 2
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#backoff_rate Destination#backoff_rate}
  */
  readonly backoffRate?: number;
  /**
  * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes). Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#initial_backoff Destination#initial_backoff}
  */
  readonly initialBackoff?: number;
  /**
  * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds). Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#max_backoff Destination#max_backoff}
  */
  readonly maxBackoff?: number;
  /**
  * Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#timeout_retry Destination#timeout_retry}
  */
  readonly timeoutRetry?: boolean | cdktf.IResolvable;
}

export function destinationOutputElasticTimeoutRetrySettingsToTerraform(struct?: DestinationOutputElasticTimeoutRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    backoff_rate: cdktf.numberToTerraform(struct!.backoffRate),
    initial_backoff: cdktf.numberToTerraform(struct!.initialBackoff),
    max_backoff: cdktf.numberToTerraform(struct!.maxBackoff),
    timeout_retry: cdktf.booleanToTerraform(struct!.timeoutRetry),
  }
}


export function destinationOutputElasticTimeoutRetrySettingsToHclTerraform(struct?: DestinationOutputElasticTimeoutRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    backoff_rate: {
      value: cdktf.numberToHclTerraform(struct!.backoffRate),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    initial_backoff: {
      value: cdktf.numberToHclTerraform(struct!.initialBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_backoff: {
      value: cdktf.numberToHclTerraform(struct!.maxBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    timeout_retry: {
      value: cdktf.booleanToHclTerraform(struct!.timeoutRetry),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputElasticTimeoutRetrySettingsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DestinationOutputElasticTimeoutRetrySettings | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._backoffRate !== undefined) {
      hasAnyValues = true;
      internalValueResult.backoffRate = this._backoffRate;
    }
    if (this._initialBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.initialBackoff = this._initialBackoff;
    }
    if (this._maxBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBackoff = this._maxBackoff;
    }
    if (this._timeoutRetry !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutRetry = this._timeoutRetry;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputElasticTimeoutRetrySettings | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._backoffRate = undefined;
      this._initialBackoff = undefined;
      this._maxBackoff = undefined;
      this._timeoutRetry = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._backoffRate = value.backoffRate;
      this._initialBackoff = value.initialBackoff;
      this._maxBackoff = value.maxBackoff;
      this._timeoutRetry = value.timeoutRetry;
    }
  }

  // backoff_rate - computed: true, optional: true, required: false
  private _backoffRate?: number; 
  public get backoffRate() {
    return this.getNumberAttribute('backoff_rate');
  }
  public set backoffRate(value: number) {
    this._backoffRate = value;
  }
  public resetBackoffRate() {
    this._backoffRate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get backoffRateInput() {
    return this._backoffRate;
  }

  // initial_backoff - computed: true, optional: true, required: false
  private _initialBackoff?: number; 
  public get initialBackoff() {
    return this.getNumberAttribute('initial_backoff');
  }
  public set initialBackoff(value: number) {
    this._initialBackoff = value;
  }
  public resetInitialBackoff() {
    this._initialBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get initialBackoffInput() {
    return this._initialBackoff;
  }

  // max_backoff - computed: true, optional: true, required: false
  private _maxBackoff?: number; 
  public get maxBackoff() {
    return this.getNumberAttribute('max_backoff');
  }
  public set maxBackoff(value: number) {
    this._maxBackoff = value;
  }
  public resetMaxBackoff() {
    this._maxBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBackoffInput() {
    return this._maxBackoff;
  }

  // timeout_retry - computed: true, optional: true, required: false
  private _timeoutRetry?: boolean | cdktf.IResolvable; 
  public get timeoutRetry() {
    return this.getBooleanAttribute('timeout_retry');
  }
  public set timeoutRetry(value: boolean | cdktf.IResolvable) {
    this._timeoutRetry = value;
  }
  public resetTimeoutRetry() {
    this._timeoutRetry = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutRetryInput() {
    return this._timeoutRetry;
  }
}
export interface DestinationOutputElasticUrls {
  /**
  * The URL to an Elastic node to send events to. Example: http://elastic:9200/_bulk
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#url Destination#url}
  */
  readonly url: string;
  /**
  * Assign a weight (>0) to each endpoint to indicate its traffic-handling capability. Default: 1
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#weight Destination#weight}
  */
  readonly weight?: number;
}

export function destinationOutputElasticUrlsToTerraform(struct?: DestinationOutputElasticUrls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    url: cdktf.stringToTerraform(struct!.url),
    weight: cdktf.numberToTerraform(struct!.weight),
  }
}


export function destinationOutputElasticUrlsToHclTerraform(struct?: DestinationOutputElasticUrls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    url: {
      value: cdktf.stringToHclTerraform(struct!.url),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    weight: {
      value: cdktf.numberToHclTerraform(struct!.weight),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputElasticUrlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DestinationOutputElasticUrls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._url !== undefined) {
      hasAnyValues = true;
      internalValueResult.url = this._url;
    }
    if (this._weight !== undefined) {
      hasAnyValues = true;
      internalValueResult.weight = this._weight;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputElasticUrls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._url = undefined;
      this._weight = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._url = value.url;
      this._weight = value.weight;
    }
  }

  // url - computed: false, optional: false, required: true
  private _url?: string; 
  public get url() {
    return this.getStringAttribute('url');
  }
  public set url(value: string) {
    this._url = value;
  }
  // Temporarily expose input value. Use with caution.
  public get urlInput() {
    return this._url;
  }

  // weight - computed: true, optional: true, required: false
  private _weight?: number; 
  public get weight() {
    return this.getNumberAttribute('weight');
  }
  public set weight(value: number) {
    this._weight = value;
  }
  public resetWeight() {
    this._weight = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get weightInput() {
    return this._weight;
  }
}

export class DestinationOutputElasticUrlsList extends cdktf.ComplexList {
  public internalValue? : DestinationOutputElasticUrls[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DestinationOutputElasticUrlsOutputReference {
    return new DestinationOutputElasticUrlsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DestinationOutputElastic {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#auth Destination#auth}
  */
  readonly auth?: DestinationOutputElasticAuth;
  /**
  * Compress the payload body before sending. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#compress Destination#compress}
  */
  readonly compress?: boolean | cdktf.IResolvable;
  /**
  * Maximum number of ongoing requests before blocking. Default: 5
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#concurrency Destination#concurrency}
  */
  readonly concurrency?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#description Destination#description}
  */
  readonly description?: string;
  /**
  * The interval in which to re-resolve any hostnames and pick up destinations from A records. Default: 600
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#dns_resolve_period_sec Destination#dns_resolve_period_sec}
  */
  readonly dnsResolvePeriodSec?: number;
  /**
  * Document type to use for events. Can be overwritten by an event's __type field.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#doc_type Destination#doc_type}
  */
  readonly docType?: string;
  /**
  * Optional Elasticsearch destination pipeline
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#elastic_pipeline Destination#elastic_pipeline}
  */
  readonly elasticPipeline?: string;
  /**
  * Optional Elasticsearch version, used to format events. If not specified, will auto-discover version. Default: "auto"; must be one of ["auto", "6", "7"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#elastic_version Destination#elastic_version}
  */
  readonly elasticVersion?: string;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#environment Destination#environment}
  */
  readonly environment?: string;
  /**
  * Exclude all IPs of the current host from the list of any resolved hostnames. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#exclude_self Destination#exclude_self}
  */
  readonly excludeSelf?: boolean | cdktf.IResolvable;
  /**
  * Headers to add to all events
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#extra_http_headers Destination#extra_http_headers}
  */
  readonly extraHttpHeaders?: DestinationOutputElasticExtraHttpHeaders[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#extra_params Destination#extra_params}
  */
  readonly extraParams?: DestinationOutputElasticExtraParams[] | cdktf.IResolvable;
  /**
  * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below. Default: "none"; must be one of ["payload", "payloadAndHeaders", "none"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#failed_request_logging_mode Destination#failed_request_logging_mode}
  */
  readonly failedRequestLoggingMode?: string;
  /**
  * Maximum time between requests. Small values could cause the payload size to be smaller than the configured Body size limit. Default: 1
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#flush_period_sec Destination#flush_period_sec}
  */
  readonly flushPeriodSec?: number;
  /**
  * Unique ID for this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#id Destination#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * Include the `document_id` field when sending events to an Elastic TSDS (time series data stream). Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#include_doc_id Destination#include_doc_id}
  */
  readonly includeDocId?: boolean | cdktf.IResolvable;
  /**
  * Index or data stream to send events to. Must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can be overwritten by an event's __index field.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#index Destination#index}
  */
  readonly index: string;
  /**
  * How far back in time to keep traffic stats for load balancing purposes. Default: 300
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#load_balance_stats_period_sec Destination#load_balance_stats_period_sec}
  */
  readonly loadBalanceStatsPeriodSec?: number;
  /**
  * Enable for optimal performance. Even if you have one hostname, it can expand to multiple IPs. If disabled, consider enabling round-robin DNS. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#load_balanced Destination#load_balanced}
  */
  readonly loadBalanced?: boolean | cdktf.IResolvable;
  /**
  * Maximum number of events to include in the request body. Default is 0 (unlimited). Default: 0
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#max_payload_events Destination#max_payload_events}
  */
  readonly maxPayloadEvents?: number;
  /**
  * Maximum size, in KB, of the request body. Default: 4096
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#max_payload_size_kb Destination#max_payload_size_kb}
  */
  readonly maxPayloadSizeKb?: number;
  /**
  * How to handle events when all receivers are exerting backpressure. Default: "block"; must be one of ["block", "drop", "queue"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#on_backpressure Destination#on_backpressure}
  */
  readonly onBackpressure?: string;
  /**
  * Pipeline to process data before sending out to this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pipeline Destination#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pq_compress Destination#pq_compress}
  */
  readonly pqCompress?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pq_controls Destination#pq_controls}
  */
  readonly pqControls?: DestinationOutputElasticPqControls;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.). Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pq_max_file_size Destination#pq_max_file_size}
  */
  readonly pqMaxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pq_max_size Destination#pq_max_size}
  */
  readonly pqMaxSize?: string;
  /**
  * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem. Default: "error"; must be one of ["error", "backpressure", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pq_mode Destination#pq_mode}
  */
  readonly pqMode?: string;
  /**
  * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged. Default: "block"; must be one of ["block", "drop"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pq_on_backpressure Destination#pq_on_backpressure}
  */
  readonly pqOnBackpressure?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pq_path Destination#pq_path}
  */
  readonly pqPath?: string;
  /**
  * Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's). 
  *         Enabled by default. When this setting is also present in TLS Settings (Client Side), 
  *         that value will take precedence.
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#reject_unauthorized Destination#reject_unauthorized}
  */
  readonly rejectUnauthorized?: boolean | cdktf.IResolvable;
  /**
  * Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#response_honor_retry_after_header Destination#response_honor_retry_after_header}
  */
  readonly responseHonorRetryAfterHeader?: boolean | cdktf.IResolvable;
  /**
  * Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#response_retry_settings Destination#response_retry_settings}
  */
  readonly responseRetrySettings?: DestinationOutputElasticResponseRetrySettings[] | cdktf.IResolvable;
  /**
  * Retry failed events when a bulk request to Elastic is successful, but the response body returns an error for one or more events in the batch. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#retry_partial_errors Destination#retry_partial_errors}
  */
  readonly retryPartialErrors?: boolean | cdktf.IResolvable;
  /**
  * List of headers that are safe to log in plain text. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#safe_headers Destination#safe_headers}
  */
  readonly safeHeaders?: string[];
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#streamtags Destination#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Fields to automatically add to events, such as cribl_pipe. Supports wildcards. Default: ["cribl_pipe"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#system_fields Destination#system_fields}
  */
  readonly systemFields?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#timeout_retry_settings Destination#timeout_retry_settings}
  */
  readonly timeoutRetrySettings?: DestinationOutputElasticTimeoutRetrySettings;
  /**
  * Amount of time, in seconds, to wait for a request to complete before canceling it. Default: 30
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#timeout_sec Destination#timeout_sec}
  */
  readonly timeoutSec?: number;
  /**
  * must be "elastic"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#type Destination#type}
  */
  readonly type: string;
  /**
  * The Cloud ID or URL to an Elastic cluster to send events to. Example: http://elastic:9200/_bulk
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#url Destination#url}
  */
  readonly url?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#urls Destination#urls}
  */
  readonly urls?: DestinationOutputElasticUrls[] | cdktf.IResolvable;
  /**
  * Enable round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. For optimal performance, consider enabling this setting for non-load balanced destinations. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#use_round_robin_dns Destination#use_round_robin_dns}
  */
  readonly useRoundRobinDns?: boolean | cdktf.IResolvable;
  /**
  * Action to use when writing events. Must be set to `Create` when writing to a data stream. Default: "create"; must be one of ["index", "create"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#write_action Destination#write_action}
  */
  readonly writeAction?: string;
}

export function destinationOutputElasticToTerraform(struct?: DestinationOutputElastic | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    auth: destinationOutputElasticAuthToTerraform(struct!.auth),
    compress: cdktf.booleanToTerraform(struct!.compress),
    concurrency: cdktf.numberToTerraform(struct!.concurrency),
    description: cdktf.stringToTerraform(struct!.description),
    dns_resolve_period_sec: cdktf.numberToTerraform(struct!.dnsResolvePeriodSec),
    doc_type: cdktf.stringToTerraform(struct!.docType),
    elastic_pipeline: cdktf.stringToTerraform(struct!.elasticPipeline),
    elastic_version: cdktf.stringToTerraform(struct!.elasticVersion),
    environment: cdktf.stringToTerraform(struct!.environment),
    exclude_self: cdktf.booleanToTerraform(struct!.excludeSelf),
    extra_http_headers: cdktf.listMapper(destinationOutputElasticExtraHttpHeadersToTerraform, false)(struct!.extraHttpHeaders),
    extra_params: cdktf.listMapper(destinationOutputElasticExtraParamsToTerraform, false)(struct!.extraParams),
    failed_request_logging_mode: cdktf.stringToTerraform(struct!.failedRequestLoggingMode),
    flush_period_sec: cdktf.numberToTerraform(struct!.flushPeriodSec),
    id: cdktf.stringToTerraform(struct!.id),
    include_doc_id: cdktf.booleanToTerraform(struct!.includeDocId),
    index: cdktf.stringToTerraform(struct!.index),
    load_balance_stats_period_sec: cdktf.numberToTerraform(struct!.loadBalanceStatsPeriodSec),
    load_balanced: cdktf.booleanToTerraform(struct!.loadBalanced),
    max_payload_events: cdktf.numberToTerraform(struct!.maxPayloadEvents),
    max_payload_size_kb: cdktf.numberToTerraform(struct!.maxPayloadSizeKb),
    on_backpressure: cdktf.stringToTerraform(struct!.onBackpressure),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    pq_compress: cdktf.stringToTerraform(struct!.pqCompress),
    pq_controls: destinationOutputElasticPqControlsToTerraform(struct!.pqControls),
    pq_max_file_size: cdktf.stringToTerraform(struct!.pqMaxFileSize),
    pq_max_size: cdktf.stringToTerraform(struct!.pqMaxSize),
    pq_mode: cdktf.stringToTerraform(struct!.pqMode),
    pq_on_backpressure: cdktf.stringToTerraform(struct!.pqOnBackpressure),
    pq_path: cdktf.stringToTerraform(struct!.pqPath),
    reject_unauthorized: cdktf.booleanToTerraform(struct!.rejectUnauthorized),
    response_honor_retry_after_header: cdktf.booleanToTerraform(struct!.responseHonorRetryAfterHeader),
    response_retry_settings: cdktf.listMapper(destinationOutputElasticResponseRetrySettingsToTerraform, false)(struct!.responseRetrySettings),
    retry_partial_errors: cdktf.booleanToTerraform(struct!.retryPartialErrors),
    safe_headers: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.safeHeaders),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    system_fields: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.systemFields),
    timeout_retry_settings: destinationOutputElasticTimeoutRetrySettingsToTerraform(struct!.timeoutRetrySettings),
    timeout_sec: cdktf.numberToTerraform(struct!.timeoutSec),
    type: cdktf.stringToTerraform(struct!.type),
    url: cdktf.stringToTerraform(struct!.url),
    urls: cdktf.listMapper(destinationOutputElasticUrlsToTerraform, false)(struct!.urls),
    use_round_robin_dns: cdktf.booleanToTerraform(struct!.useRoundRobinDns),
    write_action: cdktf.stringToTerraform(struct!.writeAction),
  }
}


export function destinationOutputElasticToHclTerraform(struct?: DestinationOutputElastic | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    auth: {
      value: destinationOutputElasticAuthToHclTerraform(struct!.auth),
      isBlock: true,
      type: "struct",
      storageClassType: "DestinationOutputElasticAuth",
    },
    compress: {
      value: cdktf.booleanToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    concurrency: {
      value: cdktf.numberToHclTerraform(struct!.concurrency),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    dns_resolve_period_sec: {
      value: cdktf.numberToHclTerraform(struct!.dnsResolvePeriodSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    doc_type: {
      value: cdktf.stringToHclTerraform(struct!.docType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    elastic_pipeline: {
      value: cdktf.stringToHclTerraform(struct!.elasticPipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    elastic_version: {
      value: cdktf.stringToHclTerraform(struct!.elasticVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    exclude_self: {
      value: cdktf.booleanToHclTerraform(struct!.excludeSelf),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    extra_http_headers: {
      value: cdktf.listMapperHcl(destinationOutputElasticExtraHttpHeadersToHclTerraform, false)(struct!.extraHttpHeaders),
      isBlock: true,
      type: "list",
      storageClassType: "DestinationOutputElasticExtraHttpHeadersList",
    },
    extra_params: {
      value: cdktf.listMapperHcl(destinationOutputElasticExtraParamsToHclTerraform, false)(struct!.extraParams),
      isBlock: true,
      type: "list",
      storageClassType: "DestinationOutputElasticExtraParamsList",
    },
    failed_request_logging_mode: {
      value: cdktf.stringToHclTerraform(struct!.failedRequestLoggingMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    flush_period_sec: {
      value: cdktf.numberToHclTerraform(struct!.flushPeriodSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    include_doc_id: {
      value: cdktf.booleanToHclTerraform(struct!.includeDocId),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    index: {
      value: cdktf.stringToHclTerraform(struct!.index),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    load_balance_stats_period_sec: {
      value: cdktf.numberToHclTerraform(struct!.loadBalanceStatsPeriodSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    load_balanced: {
      value: cdktf.booleanToHclTerraform(struct!.loadBalanced),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    max_payload_events: {
      value: cdktf.numberToHclTerraform(struct!.maxPayloadEvents),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_payload_size_kb: {
      value: cdktf.numberToHclTerraform(struct!.maxPayloadSizeKb),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.onBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_compress: {
      value: cdktf.stringToHclTerraform(struct!.pqCompress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_controls: {
      value: destinationOutputElasticPqControlsToHclTerraform(struct!.pqControls),
      isBlock: true,
      type: "struct",
      storageClassType: "DestinationOutputElasticPqControls",
    },
    pq_max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_max_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_mode: {
      value: cdktf.stringToHclTerraform(struct!.pqMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.pqOnBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_path: {
      value: cdktf.stringToHclTerraform(struct!.pqPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reject_unauthorized: {
      value: cdktf.booleanToHclTerraform(struct!.rejectUnauthorized),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    response_honor_retry_after_header: {
      value: cdktf.booleanToHclTerraform(struct!.responseHonorRetryAfterHeader),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    response_retry_settings: {
      value: cdktf.listMapperHcl(destinationOutputElasticResponseRetrySettingsToHclTerraform, false)(struct!.responseRetrySettings),
      isBlock: true,
      type: "list",
      storageClassType: "DestinationOutputElasticResponseRetrySettingsList",
    },
    retry_partial_errors: {
      value: cdktf.booleanToHclTerraform(struct!.retryPartialErrors),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    safe_headers: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.safeHeaders),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    system_fields: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.systemFields),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    timeout_retry_settings: {
      value: destinationOutputElasticTimeoutRetrySettingsToHclTerraform(struct!.timeoutRetrySettings),
      isBlock: true,
      type: "struct",
      storageClassType: "DestinationOutputElasticTimeoutRetrySettings",
    },
    timeout_sec: {
      value: cdktf.numberToHclTerraform(struct!.timeoutSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    url: {
      value: cdktf.stringToHclTerraform(struct!.url),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    urls: {
      value: cdktf.listMapperHcl(destinationOutputElasticUrlsToHclTerraform, false)(struct!.urls),
      isBlock: true,
      type: "list",
      storageClassType: "DestinationOutputElasticUrlsList",
    },
    use_round_robin_dns: {
      value: cdktf.booleanToHclTerraform(struct!.useRoundRobinDns),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    write_action: {
      value: cdktf.stringToHclTerraform(struct!.writeAction),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputElasticOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DestinationOutputElastic | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._auth?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.auth = this._auth?.internalValue;
    }
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._concurrency !== undefined) {
      hasAnyValues = true;
      internalValueResult.concurrency = this._concurrency;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._dnsResolvePeriodSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.dnsResolvePeriodSec = this._dnsResolvePeriodSec;
    }
    if (this._docType !== undefined) {
      hasAnyValues = true;
      internalValueResult.docType = this._docType;
    }
    if (this._elasticPipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.elasticPipeline = this._elasticPipeline;
    }
    if (this._elasticVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.elasticVersion = this._elasticVersion;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._excludeSelf !== undefined) {
      hasAnyValues = true;
      internalValueResult.excludeSelf = this._excludeSelf;
    }
    if (this._extraHttpHeaders?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.extraHttpHeaders = this._extraHttpHeaders?.internalValue;
    }
    if (this._extraParams?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.extraParams = this._extraParams?.internalValue;
    }
    if (this._failedRequestLoggingMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.failedRequestLoggingMode = this._failedRequestLoggingMode;
    }
    if (this._flushPeriodSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.flushPeriodSec = this._flushPeriodSec;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._includeDocId !== undefined) {
      hasAnyValues = true;
      internalValueResult.includeDocId = this._includeDocId;
    }
    if (this._index !== undefined) {
      hasAnyValues = true;
      internalValueResult.index = this._index;
    }
    if (this._loadBalanceStatsPeriodSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.loadBalanceStatsPeriodSec = this._loadBalanceStatsPeriodSec;
    }
    if (this._loadBalanced !== undefined) {
      hasAnyValues = true;
      internalValueResult.loadBalanced = this._loadBalanced;
    }
    if (this._maxPayloadEvents !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxPayloadEvents = this._maxPayloadEvents;
    }
    if (this._maxPayloadSizeKb !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxPayloadSizeKb = this._maxPayloadSizeKb;
    }
    if (this._onBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.onBackpressure = this._onBackpressure;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._pqCompress !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqCompress = this._pqCompress;
    }
    if (this._pqControls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqControls = this._pqControls?.internalValue;
    }
    if (this._pqMaxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxFileSize = this._pqMaxFileSize;
    }
    if (this._pqMaxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxSize = this._pqMaxSize;
    }
    if (this._pqMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMode = this._pqMode;
    }
    if (this._pqOnBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqOnBackpressure = this._pqOnBackpressure;
    }
    if (this._pqPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqPath = this._pqPath;
    }
    if (this._rejectUnauthorized !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectUnauthorized = this._rejectUnauthorized;
    }
    if (this._responseHonorRetryAfterHeader !== undefined) {
      hasAnyValues = true;
      internalValueResult.responseHonorRetryAfterHeader = this._responseHonorRetryAfterHeader;
    }
    if (this._responseRetrySettings?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.responseRetrySettings = this._responseRetrySettings?.internalValue;
    }
    if (this._retryPartialErrors !== undefined) {
      hasAnyValues = true;
      internalValueResult.retryPartialErrors = this._retryPartialErrors;
    }
    if (this._safeHeaders !== undefined) {
      hasAnyValues = true;
      internalValueResult.safeHeaders = this._safeHeaders;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._systemFields !== undefined) {
      hasAnyValues = true;
      internalValueResult.systemFields = this._systemFields;
    }
    if (this._timeoutRetrySettings?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutRetrySettings = this._timeoutRetrySettings?.internalValue;
    }
    if (this._timeoutSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutSec = this._timeoutSec;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._url !== undefined) {
      hasAnyValues = true;
      internalValueResult.url = this._url;
    }
    if (this._urls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.urls = this._urls?.internalValue;
    }
    if (this._useRoundRobinDns !== undefined) {
      hasAnyValues = true;
      internalValueResult.useRoundRobinDns = this._useRoundRobinDns;
    }
    if (this._writeAction !== undefined) {
      hasAnyValues = true;
      internalValueResult.writeAction = this._writeAction;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputElastic | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._auth.internalValue = undefined;
      this._compress = undefined;
      this._concurrency = undefined;
      this._description = undefined;
      this._dnsResolvePeriodSec = undefined;
      this._docType = undefined;
      this._elasticPipeline = undefined;
      this._elasticVersion = undefined;
      this._environment = undefined;
      this._excludeSelf = undefined;
      this._extraHttpHeaders.internalValue = undefined;
      this._extraParams.internalValue = undefined;
      this._failedRequestLoggingMode = undefined;
      this._flushPeriodSec = undefined;
      this._id = undefined;
      this._includeDocId = undefined;
      this._index = undefined;
      this._loadBalanceStatsPeriodSec = undefined;
      this._loadBalanced = undefined;
      this._maxPayloadEvents = undefined;
      this._maxPayloadSizeKb = undefined;
      this._onBackpressure = undefined;
      this._pipeline = undefined;
      this._pqCompress = undefined;
      this._pqControls.internalValue = undefined;
      this._pqMaxFileSize = undefined;
      this._pqMaxSize = undefined;
      this._pqMode = undefined;
      this._pqOnBackpressure = undefined;
      this._pqPath = undefined;
      this._rejectUnauthorized = undefined;
      this._responseHonorRetryAfterHeader = undefined;
      this._responseRetrySettings.internalValue = undefined;
      this._retryPartialErrors = undefined;
      this._safeHeaders = undefined;
      this._streamtags = undefined;
      this._systemFields = undefined;
      this._timeoutRetrySettings.internalValue = undefined;
      this._timeoutSec = undefined;
      this._type = undefined;
      this._url = undefined;
      this._urls.internalValue = undefined;
      this._useRoundRobinDns = undefined;
      this._writeAction = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._auth.internalValue = value.auth;
      this._compress = value.compress;
      this._concurrency = value.concurrency;
      this._description = value.description;
      this._dnsResolvePeriodSec = value.dnsResolvePeriodSec;
      this._docType = value.docType;
      this._elasticPipeline = value.elasticPipeline;
      this._elasticVersion = value.elasticVersion;
      this._environment = value.environment;
      this._excludeSelf = value.excludeSelf;
      this._extraHttpHeaders.internalValue = value.extraHttpHeaders;
      this._extraParams.internalValue = value.extraParams;
      this._failedRequestLoggingMode = value.failedRequestLoggingMode;
      this._flushPeriodSec = value.flushPeriodSec;
      this._id = value.id;
      this._includeDocId = value.includeDocId;
      this._index = value.index;
      this._loadBalanceStatsPeriodSec = value.loadBalanceStatsPeriodSec;
      this._loadBalanced = value.loadBalanced;
      this._maxPayloadEvents = value.maxPayloadEvents;
      this._maxPayloadSizeKb = value.maxPayloadSizeKb;
      this._onBackpressure = value.onBackpressure;
      this._pipeline = value.pipeline;
      this._pqCompress = value.pqCompress;
      this._pqControls.internalValue = value.pqControls;
      this._pqMaxFileSize = value.pqMaxFileSize;
      this._pqMaxSize = value.pqMaxSize;
      this._pqMode = value.pqMode;
      this._pqOnBackpressure = value.pqOnBackpressure;
      this._pqPath = value.pqPath;
      this._rejectUnauthorized = value.rejectUnauthorized;
      this._responseHonorRetryAfterHeader = value.responseHonorRetryAfterHeader;
      this._responseRetrySettings.internalValue = value.responseRetrySettings;
      this._retryPartialErrors = value.retryPartialErrors;
      this._safeHeaders = value.safeHeaders;
      this._streamtags = value.streamtags;
      this._systemFields = value.systemFields;
      this._timeoutRetrySettings.internalValue = value.timeoutRetrySettings;
      this._timeoutSec = value.timeoutSec;
      this._type = value.type;
      this._url = value.url;
      this._urls.internalValue = value.urls;
      this._useRoundRobinDns = value.useRoundRobinDns;
      this._writeAction = value.writeAction;
    }
  }

  // auth - computed: false, optional: true, required: false
  private _auth = new DestinationOutputElasticAuthOutputReference(this, "auth");
  public get auth() {
    return this._auth;
  }
  public putAuth(value: DestinationOutputElasticAuth) {
    this._auth.internalValue = value;
  }
  public resetAuth() {
    this._auth.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authInput() {
    return this._auth.internalValue;
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: boolean | cdktf.IResolvable; 
  public get compress() {
    return this.getBooleanAttribute('compress');
  }
  public set compress(value: boolean | cdktf.IResolvable) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // concurrency - computed: true, optional: true, required: false
  private _concurrency?: number; 
  public get concurrency() {
    return this.getNumberAttribute('concurrency');
  }
  public set concurrency(value: number) {
    this._concurrency = value;
  }
  public resetConcurrency() {
    this._concurrency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get concurrencyInput() {
    return this._concurrency;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // dns_resolve_period_sec - computed: true, optional: true, required: false
  private _dnsResolvePeriodSec?: number; 
  public get dnsResolvePeriodSec() {
    return this.getNumberAttribute('dns_resolve_period_sec');
  }
  public set dnsResolvePeriodSec(value: number) {
    this._dnsResolvePeriodSec = value;
  }
  public resetDnsResolvePeriodSec() {
    this._dnsResolvePeriodSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dnsResolvePeriodSecInput() {
    return this._dnsResolvePeriodSec;
  }

  // doc_type - computed: false, optional: true, required: false
  private _docType?: string; 
  public get docType() {
    return this.getStringAttribute('doc_type');
  }
  public set docType(value: string) {
    this._docType = value;
  }
  public resetDocType() {
    this._docType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get docTypeInput() {
    return this._docType;
  }

  // elastic_pipeline - computed: false, optional: true, required: false
  private _elasticPipeline?: string; 
  public get elasticPipeline() {
    return this.getStringAttribute('elastic_pipeline');
  }
  public set elasticPipeline(value: string) {
    this._elasticPipeline = value;
  }
  public resetElasticPipeline() {
    this._elasticPipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get elasticPipelineInput() {
    return this._elasticPipeline;
  }

  // elastic_version - computed: true, optional: true, required: false
  private _elasticVersion?: string; 
  public get elasticVersion() {
    return this.getStringAttribute('elastic_version');
  }
  public set elasticVersion(value: string) {
    this._elasticVersion = value;
  }
  public resetElasticVersion() {
    this._elasticVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get elasticVersionInput() {
    return this._elasticVersion;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // exclude_self - computed: true, optional: true, required: false
  private _excludeSelf?: boolean | cdktf.IResolvable; 
  public get excludeSelf() {
    return this.getBooleanAttribute('exclude_self');
  }
  public set excludeSelf(value: boolean | cdktf.IResolvable) {
    this._excludeSelf = value;
  }
  public resetExcludeSelf() {
    this._excludeSelf = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get excludeSelfInput() {
    return this._excludeSelf;
  }

  // extra_http_headers - computed: false, optional: true, required: false
  private _extraHttpHeaders = new DestinationOutputElasticExtraHttpHeadersList(this, "extra_http_headers", false);
  public get extraHttpHeaders() {
    return this._extraHttpHeaders;
  }
  public putExtraHttpHeaders(value: DestinationOutputElasticExtraHttpHeaders[] | cdktf.IResolvable) {
    this._extraHttpHeaders.internalValue = value;
  }
  public resetExtraHttpHeaders() {
    this._extraHttpHeaders.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get extraHttpHeadersInput() {
    return this._extraHttpHeaders.internalValue;
  }

  // extra_params - computed: false, optional: true, required: false
  private _extraParams = new DestinationOutputElasticExtraParamsList(this, "extra_params", false);
  public get extraParams() {
    return this._extraParams;
  }
  public putExtraParams(value: DestinationOutputElasticExtraParams[] | cdktf.IResolvable) {
    this._extraParams.internalValue = value;
  }
  public resetExtraParams() {
    this._extraParams.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get extraParamsInput() {
    return this._extraParams.internalValue;
  }

  // failed_request_logging_mode - computed: true, optional: true, required: false
  private _failedRequestLoggingMode?: string; 
  public get failedRequestLoggingMode() {
    return this.getStringAttribute('failed_request_logging_mode');
  }
  public set failedRequestLoggingMode(value: string) {
    this._failedRequestLoggingMode = value;
  }
  public resetFailedRequestLoggingMode() {
    this._failedRequestLoggingMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get failedRequestLoggingModeInput() {
    return this._failedRequestLoggingMode;
  }

  // flush_period_sec - computed: true, optional: true, required: false
  private _flushPeriodSec?: number; 
  public get flushPeriodSec() {
    return this.getNumberAttribute('flush_period_sec');
  }
  public set flushPeriodSec(value: number) {
    this._flushPeriodSec = value;
  }
  public resetFlushPeriodSec() {
    this._flushPeriodSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get flushPeriodSecInput() {
    return this._flushPeriodSec;
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // include_doc_id - computed: true, optional: true, required: false
  private _includeDocId?: boolean | cdktf.IResolvable; 
  public get includeDocId() {
    return this.getBooleanAttribute('include_doc_id');
  }
  public set includeDocId(value: boolean | cdktf.IResolvable) {
    this._includeDocId = value;
  }
  public resetIncludeDocId() {
    this._includeDocId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get includeDocIdInput() {
    return this._includeDocId;
  }

  // index - computed: false, optional: false, required: true
  private _index?: string; 
  public get index() {
    return this.getStringAttribute('index');
  }
  public set index(value: string) {
    this._index = value;
  }
  // Temporarily expose input value. Use with caution.
  public get indexInput() {
    return this._index;
  }

  // load_balance_stats_period_sec - computed: true, optional: true, required: false
  private _loadBalanceStatsPeriodSec?: number; 
  public get loadBalanceStatsPeriodSec() {
    return this.getNumberAttribute('load_balance_stats_period_sec');
  }
  public set loadBalanceStatsPeriodSec(value: number) {
    this._loadBalanceStatsPeriodSec = value;
  }
  public resetLoadBalanceStatsPeriodSec() {
    this._loadBalanceStatsPeriodSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get loadBalanceStatsPeriodSecInput() {
    return this._loadBalanceStatsPeriodSec;
  }

  // load_balanced - computed: true, optional: true, required: false
  private _loadBalanced?: boolean | cdktf.IResolvable; 
  public get loadBalanced() {
    return this.getBooleanAttribute('load_balanced');
  }
  public set loadBalanced(value: boolean | cdktf.IResolvable) {
    this._loadBalanced = value;
  }
  public resetLoadBalanced() {
    this._loadBalanced = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get loadBalancedInput() {
    return this._loadBalanced;
  }

  // max_payload_events - computed: true, optional: true, required: false
  private _maxPayloadEvents?: number; 
  public get maxPayloadEvents() {
    return this.getNumberAttribute('max_payload_events');
  }
  public set maxPayloadEvents(value: number) {
    this._maxPayloadEvents = value;
  }
  public resetMaxPayloadEvents() {
    this._maxPayloadEvents = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxPayloadEventsInput() {
    return this._maxPayloadEvents;
  }

  // max_payload_size_kb - computed: true, optional: true, required: false
  private _maxPayloadSizeKb?: number; 
  public get maxPayloadSizeKb() {
    return this.getNumberAttribute('max_payload_size_kb');
  }
  public set maxPayloadSizeKb(value: number) {
    this._maxPayloadSizeKb = value;
  }
  public resetMaxPayloadSizeKb() {
    this._maxPayloadSizeKb = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxPayloadSizeKbInput() {
    return this._maxPayloadSizeKb;
  }

  // on_backpressure - computed: true, optional: true, required: false
  private _onBackpressure?: string; 
  public get onBackpressure() {
    return this.getStringAttribute('on_backpressure');
  }
  public set onBackpressure(value: string) {
    this._onBackpressure = value;
  }
  public resetOnBackpressure() {
    this._onBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get onBackpressureInput() {
    return this._onBackpressure;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // pq_compress - computed: true, optional: true, required: false
  private _pqCompress?: string; 
  public get pqCompress() {
    return this.getStringAttribute('pq_compress');
  }
  public set pqCompress(value: string) {
    this._pqCompress = value;
  }
  public resetPqCompress() {
    this._pqCompress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqCompressInput() {
    return this._pqCompress;
  }

  // pq_controls - computed: false, optional: true, required: false
  private _pqControls = new DestinationOutputElasticPqControlsOutputReference(this, "pq_controls");
  public get pqControls() {
    return this._pqControls;
  }
  public putPqControls(value: DestinationOutputElasticPqControls) {
    this._pqControls.internalValue = value;
  }
  public resetPqControls() {
    this._pqControls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqControlsInput() {
    return this._pqControls.internalValue;
  }

  // pq_max_file_size - computed: true, optional: true, required: false
  private _pqMaxFileSize?: string; 
  public get pqMaxFileSize() {
    return this.getStringAttribute('pq_max_file_size');
  }
  public set pqMaxFileSize(value: string) {
    this._pqMaxFileSize = value;
  }
  public resetPqMaxFileSize() {
    this._pqMaxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxFileSizeInput() {
    return this._pqMaxFileSize;
  }

  // pq_max_size - computed: true, optional: true, required: false
  private _pqMaxSize?: string; 
  public get pqMaxSize() {
    return this.getStringAttribute('pq_max_size');
  }
  public set pqMaxSize(value: string) {
    this._pqMaxSize = value;
  }
  public resetPqMaxSize() {
    this._pqMaxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxSizeInput() {
    return this._pqMaxSize;
  }

  // pq_mode - computed: true, optional: true, required: false
  private _pqMode?: string; 
  public get pqMode() {
    return this.getStringAttribute('pq_mode');
  }
  public set pqMode(value: string) {
    this._pqMode = value;
  }
  public resetPqMode() {
    this._pqMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqModeInput() {
    return this._pqMode;
  }

  // pq_on_backpressure - computed: true, optional: true, required: false
  private _pqOnBackpressure?: string; 
  public get pqOnBackpressure() {
    return this.getStringAttribute('pq_on_backpressure');
  }
  public set pqOnBackpressure(value: string) {
    this._pqOnBackpressure = value;
  }
  public resetPqOnBackpressure() {
    this._pqOnBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqOnBackpressureInput() {
    return this._pqOnBackpressure;
  }

  // pq_path - computed: true, optional: true, required: false
  private _pqPath?: string; 
  public get pqPath() {
    return this.getStringAttribute('pq_path');
  }
  public set pqPath(value: string) {
    this._pqPath = value;
  }
  public resetPqPath() {
    this._pqPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqPathInput() {
    return this._pqPath;
  }

  // reject_unauthorized - computed: true, optional: true, required: false
  private _rejectUnauthorized?: boolean | cdktf.IResolvable; 
  public get rejectUnauthorized() {
    return this.getBooleanAttribute('reject_unauthorized');
  }
  public set rejectUnauthorized(value: boolean | cdktf.IResolvable) {
    this._rejectUnauthorized = value;
  }
  public resetRejectUnauthorized() {
    this._rejectUnauthorized = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectUnauthorizedInput() {
    return this._rejectUnauthorized;
  }

  // response_honor_retry_after_header - computed: true, optional: true, required: false
  private _responseHonorRetryAfterHeader?: boolean | cdktf.IResolvable; 
  public get responseHonorRetryAfterHeader() {
    return this.getBooleanAttribute('response_honor_retry_after_header');
  }
  public set responseHonorRetryAfterHeader(value: boolean | cdktf.IResolvable) {
    this._responseHonorRetryAfterHeader = value;
  }
  public resetResponseHonorRetryAfterHeader() {
    this._responseHonorRetryAfterHeader = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get responseHonorRetryAfterHeaderInput() {
    return this._responseHonorRetryAfterHeader;
  }

  // response_retry_settings - computed: false, optional: true, required: false
  private _responseRetrySettings = new DestinationOutputElasticResponseRetrySettingsList(this, "response_retry_settings", false);
  public get responseRetrySettings() {
    return this._responseRetrySettings;
  }
  public putResponseRetrySettings(value: DestinationOutputElasticResponseRetrySettings[] | cdktf.IResolvable) {
    this._responseRetrySettings.internalValue = value;
  }
  public resetResponseRetrySettings() {
    this._responseRetrySettings.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get responseRetrySettingsInput() {
    return this._responseRetrySettings.internalValue;
  }

  // retry_partial_errors - computed: true, optional: true, required: false
  private _retryPartialErrors?: boolean | cdktf.IResolvable; 
  public get retryPartialErrors() {
    return this.getBooleanAttribute('retry_partial_errors');
  }
  public set retryPartialErrors(value: boolean | cdktf.IResolvable) {
    this._retryPartialErrors = value;
  }
  public resetRetryPartialErrors() {
    this._retryPartialErrors = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get retryPartialErrorsInput() {
    return this._retryPartialErrors;
  }

  // safe_headers - computed: true, optional: true, required: false
  private _safeHeaders?: string[]; 
  public get safeHeaders() {
    return this.getListAttribute('safe_headers');
  }
  public set safeHeaders(value: string[]) {
    this._safeHeaders = value;
  }
  public resetSafeHeaders() {
    this._safeHeaders = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get safeHeadersInput() {
    return this._safeHeaders;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // system_fields - computed: true, optional: true, required: false
  private _systemFields?: string[]; 
  public get systemFields() {
    return this.getListAttribute('system_fields');
  }
  public set systemFields(value: string[]) {
    this._systemFields = value;
  }
  public resetSystemFields() {
    this._systemFields = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get systemFieldsInput() {
    return this._systemFields;
  }

  // timeout_retry_settings - computed: false, optional: true, required: false
  private _timeoutRetrySettings = new DestinationOutputElasticTimeoutRetrySettingsOutputReference(this, "timeout_retry_settings");
  public get timeoutRetrySettings() {
    return this._timeoutRetrySettings;
  }
  public putTimeoutRetrySettings(value: DestinationOutputElasticTimeoutRetrySettings) {
    this._timeoutRetrySettings.internalValue = value;
  }
  public resetTimeoutRetrySettings() {
    this._timeoutRetrySettings.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutRetrySettingsInput() {
    return this._timeoutRetrySettings.internalValue;
  }

  // timeout_sec - computed: true, optional: true, required: false
  private _timeoutSec?: number; 
  public get timeoutSec() {
    return this.getNumberAttribute('timeout_sec');
  }
  public set timeoutSec(value: number) {
    this._timeoutSec = value;
  }
  public resetTimeoutSec() {
    this._timeoutSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutSecInput() {
    return this._timeoutSec;
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // url - computed: false, optional: true, required: false
  private _url?: string; 
  public get url() {
    return this.getStringAttribute('url');
  }
  public set url(value: string) {
    this._url = value;
  }
  public resetUrl() {
    this._url = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get urlInput() {
    return this._url;
  }

  // urls - computed: false, optional: true, required: false
  private _urls = new DestinationOutputElasticUrlsList(this, "urls", false);
  public get urls() {
    return this._urls;
  }
  public putUrls(value: DestinationOutputElasticUrls[] | cdktf.IResolvable) {
    this._urls.internalValue = value;
  }
  public resetUrls() {
    this._urls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get urlsInput() {
    return this._urls.internalValue;
  }

  // use_round_robin_dns - computed: true, optional: true, required: false
  private _useRoundRobinDns?: boolean | cdktf.IResolvable; 
  public get useRoundRobinDns() {
    return this.getBooleanAttribute('use_round_robin_dns');
  }
  public set useRoundRobinDns(value: boolean | cdktf.IResolvable) {
    this._useRoundRobinDns = value;
  }
  public resetUseRoundRobinDns() {
    this._useRoundRobinDns = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get useRoundRobinDnsInput() {
    return this._useRoundRobinDns;
  }

  // write_action - computed: true, optional: true, required: false
  private _writeAction?: string; 
  public get writeAction() {
    return this.getStringAttribute('write_action');
  }
  public set writeAction(value: string) {
    this._writeAction = value;
  }
  public resetWriteAction() {
    this._writeAction = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get writeActionInput() {
    return this._writeAction;
  }
}
export interface DestinationOutputElasticCloudAuth {
  /**
  * Enter credentials directly, or select a stored secret. Default: "manual"; must be one of ["manual", "secret", "manualAPIKey", "textSecret"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#auth_type Destination#auth_type}
  */
  readonly authType?: string;
  /**
  * Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#disabled Destination#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
}

export function destinationOutputElasticCloudAuthToTerraform(struct?: DestinationOutputElasticCloudAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    auth_type: cdktf.stringToTerraform(struct!.authType),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
  }
}


export function destinationOutputElasticCloudAuthToHclTerraform(struct?: DestinationOutputElasticCloudAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    auth_type: {
      value: cdktf.stringToHclTerraform(struct!.authType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputElasticCloudAuthOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DestinationOutputElasticCloudAuth | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._authType !== undefined) {
      hasAnyValues = true;
      internalValueResult.authType = this._authType;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputElasticCloudAuth | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._authType = undefined;
      this._disabled = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._authType = value.authType;
      this._disabled = value.disabled;
    }
  }

  // auth_type - computed: true, optional: true, required: false
  private _authType?: string; 
  public get authType() {
    return this.getStringAttribute('auth_type');
  }
  public set authType(value: string) {
    this._authType = value;
  }
  public resetAuthType() {
    this._authType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authTypeInput() {
    return this._authType;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }
}
export interface DestinationOutputElasticCloudExtraHttpHeaders {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#name Destination#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#value Destination#value}
  */
  readonly value: string;
}

export function destinationOutputElasticCloudExtraHttpHeadersToTerraform(struct?: DestinationOutputElasticCloudExtraHttpHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function destinationOutputElasticCloudExtraHttpHeadersToHclTerraform(struct?: DestinationOutputElasticCloudExtraHttpHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputElasticCloudExtraHttpHeadersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DestinationOutputElasticCloudExtraHttpHeaders | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputElasticCloudExtraHttpHeaders | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DestinationOutputElasticCloudExtraHttpHeadersList extends cdktf.ComplexList {
  public internalValue? : DestinationOutputElasticCloudExtraHttpHeaders[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DestinationOutputElasticCloudExtraHttpHeadersOutputReference {
    return new DestinationOutputElasticCloudExtraHttpHeadersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DestinationOutputElasticCloudExtraParams {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#name Destination#name}
  */
  readonly name: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#value Destination#value}
  */
  readonly value: string;
}

export function destinationOutputElasticCloudExtraParamsToTerraform(struct?: DestinationOutputElasticCloudExtraParams | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function destinationOutputElasticCloudExtraParamsToHclTerraform(struct?: DestinationOutputElasticCloudExtraParams | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputElasticCloudExtraParamsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DestinationOutputElasticCloudExtraParams | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputElasticCloudExtraParams | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DestinationOutputElasticCloudExtraParamsList extends cdktf.ComplexList {
  public internalValue? : DestinationOutputElasticCloudExtraParams[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DestinationOutputElasticCloudExtraParamsOutputReference {
    return new DestinationOutputElasticCloudExtraParamsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DestinationOutputElasticCloudPqControls {
}

export function destinationOutputElasticCloudPqControlsToTerraform(struct?: DestinationOutputElasticCloudPqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function destinationOutputElasticCloudPqControlsToHclTerraform(struct?: DestinationOutputElasticCloudPqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class DestinationOutputElasticCloudPqControlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DestinationOutputElasticCloudPqControls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputElasticCloudPqControls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface DestinationOutputElasticCloudResponseRetrySettings {
  /**
  * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc. Default: 2
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#backoff_rate Destination#backoff_rate}
  */
  readonly backoffRate?: number;
  /**
  * The HTTP response status code that will trigger retries
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#http_status Destination#http_status}
  */
  readonly httpStatus: number;
  /**
  * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes). Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#initial_backoff Destination#initial_backoff}
  */
  readonly initialBackoff?: number;
  /**
  * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds). Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#max_backoff Destination#max_backoff}
  */
  readonly maxBackoff?: number;
}

export function destinationOutputElasticCloudResponseRetrySettingsToTerraform(struct?: DestinationOutputElasticCloudResponseRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    backoff_rate: cdktf.numberToTerraform(struct!.backoffRate),
    http_status: cdktf.numberToTerraform(struct!.httpStatus),
    initial_backoff: cdktf.numberToTerraform(struct!.initialBackoff),
    max_backoff: cdktf.numberToTerraform(struct!.maxBackoff),
  }
}


export function destinationOutputElasticCloudResponseRetrySettingsToHclTerraform(struct?: DestinationOutputElasticCloudResponseRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    backoff_rate: {
      value: cdktf.numberToHclTerraform(struct!.backoffRate),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    http_status: {
      value: cdktf.numberToHclTerraform(struct!.httpStatus),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    initial_backoff: {
      value: cdktf.numberToHclTerraform(struct!.initialBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_backoff: {
      value: cdktf.numberToHclTerraform(struct!.maxBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputElasticCloudResponseRetrySettingsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DestinationOutputElasticCloudResponseRetrySettings | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._backoffRate !== undefined) {
      hasAnyValues = true;
      internalValueResult.backoffRate = this._backoffRate;
    }
    if (this._httpStatus !== undefined) {
      hasAnyValues = true;
      internalValueResult.httpStatus = this._httpStatus;
    }
    if (this._initialBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.initialBackoff = this._initialBackoff;
    }
    if (this._maxBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBackoff = this._maxBackoff;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputElasticCloudResponseRetrySettings | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._backoffRate = undefined;
      this._httpStatus = undefined;
      this._initialBackoff = undefined;
      this._maxBackoff = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._backoffRate = value.backoffRate;
      this._httpStatus = value.httpStatus;
      this._initialBackoff = value.initialBackoff;
      this._maxBackoff = value.maxBackoff;
    }
  }

  // backoff_rate - computed: true, optional: true, required: false
  private _backoffRate?: number; 
  public get backoffRate() {
    return this.getNumberAttribute('backoff_rate');
  }
  public set backoffRate(value: number) {
    this._backoffRate = value;
  }
  public resetBackoffRate() {
    this._backoffRate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get backoffRateInput() {
    return this._backoffRate;
  }

  // http_status - computed: false, optional: false, required: true
  private _httpStatus?: number; 
  public get httpStatus() {
    return this.getNumberAttribute('http_status');
  }
  public set httpStatus(value: number) {
    this._httpStatus = value;
  }
  // Temporarily expose input value. Use with caution.
  public get httpStatusInput() {
    return this._httpStatus;
  }

  // initial_backoff - computed: true, optional: true, required: false
  private _initialBackoff?: number; 
  public get initialBackoff() {
    return this.getNumberAttribute('initial_backoff');
  }
  public set initialBackoff(value: number) {
    this._initialBackoff = value;
  }
  public resetInitialBackoff() {
    this._initialBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get initialBackoffInput() {
    return this._initialBackoff;
  }

  // max_backoff - computed: true, optional: true, required: false
  private _maxBackoff?: number; 
  public get maxBackoff() {
    return this.getNumberAttribute('max_backoff');
  }
  public set maxBackoff(value: number) {
    this._maxBackoff = value;
  }
  public resetMaxBackoff() {
    this._maxBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBackoffInput() {
    return this._maxBackoff;
  }
}

export class DestinationOutputElasticCloudResponseRetrySettingsList extends cdktf.ComplexList {
  public internalValue? : DestinationOutputElasticCloudResponseRetrySettings[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DestinationOutputElasticCloudResponseRetrySettingsOutputReference {
    return new DestinationOutputElasticCloudResponseRetrySettingsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DestinationOutputElasticCloudTimeoutRetrySettings {
  /**
  * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc. Default: 2
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#backoff_rate Destination#backoff_rate}
  */
  readonly backoffRate?: number;
  /**
  * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes). Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#initial_backoff Destination#initial_backoff}
  */
  readonly initialBackoff?: number;
  /**
  * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds). Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#max_backoff Destination#max_backoff}
  */
  readonly maxBackoff?: number;
  /**
  * Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#timeout_retry Destination#timeout_retry}
  */
  readonly timeoutRetry?: boolean | cdktf.IResolvable;
}

export function destinationOutputElasticCloudTimeoutRetrySettingsToTerraform(struct?: DestinationOutputElasticCloudTimeoutRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    backoff_rate: cdktf.numberToTerraform(struct!.backoffRate),
    initial_backoff: cdktf.numberToTerraform(struct!.initialBackoff),
    max_backoff: cdktf.numberToTerraform(struct!.maxBackoff),
    timeout_retry: cdktf.booleanToTerraform(struct!.timeoutRetry),
  }
}


export function destinationOutputElasticCloudTimeoutRetrySettingsToHclTerraform(struct?: DestinationOutputElasticCloudTimeoutRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    backoff_rate: {
      value: cdktf.numberToHclTerraform(struct!.backoffRate),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    initial_backoff: {
      value: cdktf.numberToHclTerraform(struct!.initialBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_backoff: {
      value: cdktf.numberToHclTerraform(struct!.maxBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    timeout_retry: {
      value: cdktf.booleanToHclTerraform(struct!.timeoutRetry),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputElasticCloudTimeoutRetrySettingsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DestinationOutputElasticCloudTimeoutRetrySettings | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._backoffRate !== undefined) {
      hasAnyValues = true;
      internalValueResult.backoffRate = this._backoffRate;
    }
    if (this._initialBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.initialBackoff = this._initialBackoff;
    }
    if (this._maxBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBackoff = this._maxBackoff;
    }
    if (this._timeoutRetry !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutRetry = this._timeoutRetry;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputElasticCloudTimeoutRetrySettings | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._backoffRate = undefined;
      this._initialBackoff = undefined;
      this._maxBackoff = undefined;
      this._timeoutRetry = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._backoffRate = value.backoffRate;
      this._initialBackoff = value.initialBackoff;
      this._maxBackoff = value.maxBackoff;
      this._timeoutRetry = value.timeoutRetry;
    }
  }

  // backoff_rate - computed: true, optional: true, required: false
  private _backoffRate?: number; 
  public get backoffRate() {
    return this.getNumberAttribute('backoff_rate');
  }
  public set backoffRate(value: number) {
    this._backoffRate = value;
  }
  public resetBackoffRate() {
    this._backoffRate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get backoffRateInput() {
    return this._backoffRate;
  }

  // initial_backoff - computed: true, optional: true, required: false
  private _initialBackoff?: number; 
  public get initialBackoff() {
    return this.getNumberAttribute('initial_backoff');
  }
  public set initialBackoff(value: number) {
    this._initialBackoff = value;
  }
  public resetInitialBackoff() {
    this._initialBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get initialBackoffInput() {
    return this._initialBackoff;
  }

  // max_backoff - computed: true, optional: true, required: false
  private _maxBackoff?: number; 
  public get maxBackoff() {
    return this.getNumberAttribute('max_backoff');
  }
  public set maxBackoff(value: number) {
    this._maxBackoff = value;
  }
  public resetMaxBackoff() {
    this._maxBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBackoffInput() {
    return this._maxBackoff;
  }

  // timeout_retry - computed: true, optional: true, required: false
  private _timeoutRetry?: boolean | cdktf.IResolvable; 
  public get timeoutRetry() {
    return this.getBooleanAttribute('timeout_retry');
  }
  public set timeoutRetry(value: boolean | cdktf.IResolvable) {
    this._timeoutRetry = value;
  }
  public resetTimeoutRetry() {
    this._timeoutRetry = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutRetryInput() {
    return this._timeoutRetry;
  }
}
export interface DestinationOutputElasticCloud {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#auth Destination#auth}
  */
  readonly auth?: DestinationOutputElasticCloudAuth;
  /**
  * Compress the payload body before sending. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#compress Destination#compress}
  */
  readonly compress?: boolean | cdktf.IResolvable;
  /**
  * Maximum number of ongoing requests before blocking. Default: 5
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#concurrency Destination#concurrency}
  */
  readonly concurrency?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#description Destination#description}
  */
  readonly description?: string;
  /**
  * Optional Elastic Cloud Destination pipeline
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#elastic_pipeline Destination#elastic_pipeline}
  */
  readonly elasticPipeline?: string;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#environment Destination#environment}
  */
  readonly environment?: string;
  /**
  * Headers to add to all events
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#extra_http_headers Destination#extra_http_headers}
  */
  readonly extraHttpHeaders?: DestinationOutputElasticCloudExtraHttpHeaders[] | cdktf.IResolvable;
  /**
  * Extra parameters to use in HTTP requests
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#extra_params Destination#extra_params}
  */
  readonly extraParams?: DestinationOutputElasticCloudExtraParams[] | cdktf.IResolvable;
  /**
  * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below. Default: "none"; must be one of ["payload", "payloadAndHeaders", "none"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#failed_request_logging_mode Destination#failed_request_logging_mode}
  */
  readonly failedRequestLoggingMode?: string;
  /**
  * Maximum time between requests. Small values could cause the payload size to be smaller than the configured Body size limit. Default: 1
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#flush_period_sec Destination#flush_period_sec}
  */
  readonly flushPeriodSec?: number;
  /**
  * Unique ID for this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#id Destination#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * Include the `document_id` field when sending events to an Elastic TSDS (time series data stream). Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#include_doc_id Destination#include_doc_id}
  */
  readonly includeDocId?: boolean | cdktf.IResolvable;
  /**
  * Data stream or index to send events to. Must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can be overwritten by an event's __index field.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#index Destination#index}
  */
  readonly index: string;
  /**
  * Maximum number of events to include in the request body. Default is 0 (unlimited). Default: 0
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#max_payload_events Destination#max_payload_events}
  */
  readonly maxPayloadEvents?: number;
  /**
  * Maximum size, in KB, of the request body. Default: 4096
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#max_payload_size_kb Destination#max_payload_size_kb}
  */
  readonly maxPayloadSizeKb?: number;
  /**
  * How to handle events when all receivers are exerting backpressure. Default: "block"; must be one of ["block", "drop", "queue"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#on_backpressure Destination#on_backpressure}
  */
  readonly onBackpressure?: string;
  /**
  * Pipeline to process data before sending out to this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pipeline Destination#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pq_compress Destination#pq_compress}
  */
  readonly pqCompress?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pq_controls Destination#pq_controls}
  */
  readonly pqControls?: DestinationOutputElasticCloudPqControls;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.). Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pq_max_file_size Destination#pq_max_file_size}
  */
  readonly pqMaxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pq_max_size Destination#pq_max_size}
  */
  readonly pqMaxSize?: string;
  /**
  * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem. Default: "error"; must be one of ["error", "backpressure", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pq_mode Destination#pq_mode}
  */
  readonly pqMode?: string;
  /**
  * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged. Default: "block"; must be one of ["block", "drop"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pq_on_backpressure Destination#pq_on_backpressure}
  */
  readonly pqOnBackpressure?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pq_path Destination#pq_path}
  */
  readonly pqPath?: string;
  /**
  * Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's). 
  *         Enabled by default. When this setting is also present in TLS Settings (Client Side), 
  *         that value will take precedence.
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#reject_unauthorized Destination#reject_unauthorized}
  */
  readonly rejectUnauthorized?: boolean | cdktf.IResolvable;
  /**
  * Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#response_honor_retry_after_header Destination#response_honor_retry_after_header}
  */
  readonly responseHonorRetryAfterHeader?: boolean | cdktf.IResolvable;
  /**
  * Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#response_retry_settings Destination#response_retry_settings}
  */
  readonly responseRetrySettings?: DestinationOutputElasticCloudResponseRetrySettings[] | cdktf.IResolvable;
  /**
  * List of headers that are safe to log in plain text. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#safe_headers Destination#safe_headers}
  */
  readonly safeHeaders?: string[];
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#streamtags Destination#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Fields to automatically add to events, such as cribl_pipe. Supports wildcards. Default: ["cribl_pipe"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#system_fields Destination#system_fields}
  */
  readonly systemFields?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#timeout_retry_settings Destination#timeout_retry_settings}
  */
  readonly timeoutRetrySettings?: DestinationOutputElasticCloudTimeoutRetrySettings;
  /**
  * Amount of time, in seconds, to wait for a request to complete before canceling it. Default: 30
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#timeout_sec Destination#timeout_sec}
  */
  readonly timeoutSec?: number;
  /**
  * must be "elastic_cloud"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#type Destination#type}
  */
  readonly type?: string;
  /**
  * Enter Cloud ID of the Elastic Cloud environment to send events to
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#url Destination#url}
  */
  readonly url: string;
}

export function destinationOutputElasticCloudToTerraform(struct?: DestinationOutputElasticCloud | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    auth: destinationOutputElasticCloudAuthToTerraform(struct!.auth),
    compress: cdktf.booleanToTerraform(struct!.compress),
    concurrency: cdktf.numberToTerraform(struct!.concurrency),
    description: cdktf.stringToTerraform(struct!.description),
    elastic_pipeline: cdktf.stringToTerraform(struct!.elasticPipeline),
    environment: cdktf.stringToTerraform(struct!.environment),
    extra_http_headers: cdktf.listMapper(destinationOutputElasticCloudExtraHttpHeadersToTerraform, false)(struct!.extraHttpHeaders),
    extra_params: cdktf.listMapper(destinationOutputElasticCloudExtraParamsToTerraform, false)(struct!.extraParams),
    failed_request_logging_mode: cdktf.stringToTerraform(struct!.failedRequestLoggingMode),
    flush_period_sec: cdktf.numberToTerraform(struct!.flushPeriodSec),
    id: cdktf.stringToTerraform(struct!.id),
    include_doc_id: cdktf.booleanToTerraform(struct!.includeDocId),
    index: cdktf.stringToTerraform(struct!.index),
    max_payload_events: cdktf.numberToTerraform(struct!.maxPayloadEvents),
    max_payload_size_kb: cdktf.numberToTerraform(struct!.maxPayloadSizeKb),
    on_backpressure: cdktf.stringToTerraform(struct!.onBackpressure),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    pq_compress: cdktf.stringToTerraform(struct!.pqCompress),
    pq_controls: destinationOutputElasticCloudPqControlsToTerraform(struct!.pqControls),
    pq_max_file_size: cdktf.stringToTerraform(struct!.pqMaxFileSize),
    pq_max_size: cdktf.stringToTerraform(struct!.pqMaxSize),
    pq_mode: cdktf.stringToTerraform(struct!.pqMode),
    pq_on_backpressure: cdktf.stringToTerraform(struct!.pqOnBackpressure),
    pq_path: cdktf.stringToTerraform(struct!.pqPath),
    reject_unauthorized: cdktf.booleanToTerraform(struct!.rejectUnauthorized),
    response_honor_retry_after_header: cdktf.booleanToTerraform(struct!.responseHonorRetryAfterHeader),
    response_retry_settings: cdktf.listMapper(destinationOutputElasticCloudResponseRetrySettingsToTerraform, false)(struct!.responseRetrySettings),
    safe_headers: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.safeHeaders),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    system_fields: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.systemFields),
    timeout_retry_settings: destinationOutputElasticCloudTimeoutRetrySettingsToTerraform(struct!.timeoutRetrySettings),
    timeout_sec: cdktf.numberToTerraform(struct!.timeoutSec),
    type: cdktf.stringToTerraform(struct!.type),
    url: cdktf.stringToTerraform(struct!.url),
  }
}


export function destinationOutputElasticCloudToHclTerraform(struct?: DestinationOutputElasticCloud | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    auth: {
      value: destinationOutputElasticCloudAuthToHclTerraform(struct!.auth),
      isBlock: true,
      type: "struct",
      storageClassType: "DestinationOutputElasticCloudAuth",
    },
    compress: {
      value: cdktf.booleanToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    concurrency: {
      value: cdktf.numberToHclTerraform(struct!.concurrency),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    elastic_pipeline: {
      value: cdktf.stringToHclTerraform(struct!.elasticPipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    extra_http_headers: {
      value: cdktf.listMapperHcl(destinationOutputElasticCloudExtraHttpHeadersToHclTerraform, false)(struct!.extraHttpHeaders),
      isBlock: true,
      type: "list",
      storageClassType: "DestinationOutputElasticCloudExtraHttpHeadersList",
    },
    extra_params: {
      value: cdktf.listMapperHcl(destinationOutputElasticCloudExtraParamsToHclTerraform, false)(struct!.extraParams),
      isBlock: true,
      type: "list",
      storageClassType: "DestinationOutputElasticCloudExtraParamsList",
    },
    failed_request_logging_mode: {
      value: cdktf.stringToHclTerraform(struct!.failedRequestLoggingMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    flush_period_sec: {
      value: cdktf.numberToHclTerraform(struct!.flushPeriodSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    include_doc_id: {
      value: cdktf.booleanToHclTerraform(struct!.includeDocId),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    index: {
      value: cdktf.stringToHclTerraform(struct!.index),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_payload_events: {
      value: cdktf.numberToHclTerraform(struct!.maxPayloadEvents),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_payload_size_kb: {
      value: cdktf.numberToHclTerraform(struct!.maxPayloadSizeKb),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.onBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_compress: {
      value: cdktf.stringToHclTerraform(struct!.pqCompress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_controls: {
      value: destinationOutputElasticCloudPqControlsToHclTerraform(struct!.pqControls),
      isBlock: true,
      type: "struct",
      storageClassType: "DestinationOutputElasticCloudPqControls",
    },
    pq_max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_max_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_mode: {
      value: cdktf.stringToHclTerraform(struct!.pqMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.pqOnBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_path: {
      value: cdktf.stringToHclTerraform(struct!.pqPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reject_unauthorized: {
      value: cdktf.booleanToHclTerraform(struct!.rejectUnauthorized),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    response_honor_retry_after_header: {
      value: cdktf.booleanToHclTerraform(struct!.responseHonorRetryAfterHeader),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    response_retry_settings: {
      value: cdktf.listMapperHcl(destinationOutputElasticCloudResponseRetrySettingsToHclTerraform, false)(struct!.responseRetrySettings),
      isBlock: true,
      type: "list",
      storageClassType: "DestinationOutputElasticCloudResponseRetrySettingsList",
    },
    safe_headers: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.safeHeaders),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    system_fields: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.systemFields),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    timeout_retry_settings: {
      value: destinationOutputElasticCloudTimeoutRetrySettingsToHclTerraform(struct!.timeoutRetrySettings),
      isBlock: true,
      type: "struct",
      storageClassType: "DestinationOutputElasticCloudTimeoutRetrySettings",
    },
    timeout_sec: {
      value: cdktf.numberToHclTerraform(struct!.timeoutSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    url: {
      value: cdktf.stringToHclTerraform(struct!.url),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputElasticCloudOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DestinationOutputElasticCloud | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._auth?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.auth = this._auth?.internalValue;
    }
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._concurrency !== undefined) {
      hasAnyValues = true;
      internalValueResult.concurrency = this._concurrency;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._elasticPipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.elasticPipeline = this._elasticPipeline;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._extraHttpHeaders?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.extraHttpHeaders = this._extraHttpHeaders?.internalValue;
    }
    if (this._extraParams?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.extraParams = this._extraParams?.internalValue;
    }
    if (this._failedRequestLoggingMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.failedRequestLoggingMode = this._failedRequestLoggingMode;
    }
    if (this._flushPeriodSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.flushPeriodSec = this._flushPeriodSec;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._includeDocId !== undefined) {
      hasAnyValues = true;
      internalValueResult.includeDocId = this._includeDocId;
    }
    if (this._index !== undefined) {
      hasAnyValues = true;
      internalValueResult.index = this._index;
    }
    if (this._maxPayloadEvents !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxPayloadEvents = this._maxPayloadEvents;
    }
    if (this._maxPayloadSizeKb !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxPayloadSizeKb = this._maxPayloadSizeKb;
    }
    if (this._onBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.onBackpressure = this._onBackpressure;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._pqCompress !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqCompress = this._pqCompress;
    }
    if (this._pqControls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqControls = this._pqControls?.internalValue;
    }
    if (this._pqMaxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxFileSize = this._pqMaxFileSize;
    }
    if (this._pqMaxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxSize = this._pqMaxSize;
    }
    if (this._pqMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMode = this._pqMode;
    }
    if (this._pqOnBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqOnBackpressure = this._pqOnBackpressure;
    }
    if (this._pqPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqPath = this._pqPath;
    }
    if (this._rejectUnauthorized !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectUnauthorized = this._rejectUnauthorized;
    }
    if (this._responseHonorRetryAfterHeader !== undefined) {
      hasAnyValues = true;
      internalValueResult.responseHonorRetryAfterHeader = this._responseHonorRetryAfterHeader;
    }
    if (this._responseRetrySettings?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.responseRetrySettings = this._responseRetrySettings?.internalValue;
    }
    if (this._safeHeaders !== undefined) {
      hasAnyValues = true;
      internalValueResult.safeHeaders = this._safeHeaders;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._systemFields !== undefined) {
      hasAnyValues = true;
      internalValueResult.systemFields = this._systemFields;
    }
    if (this._timeoutRetrySettings?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutRetrySettings = this._timeoutRetrySettings?.internalValue;
    }
    if (this._timeoutSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutSec = this._timeoutSec;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._url !== undefined) {
      hasAnyValues = true;
      internalValueResult.url = this._url;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputElasticCloud | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._auth.internalValue = undefined;
      this._compress = undefined;
      this._concurrency = undefined;
      this._description = undefined;
      this._elasticPipeline = undefined;
      this._environment = undefined;
      this._extraHttpHeaders.internalValue = undefined;
      this._extraParams.internalValue = undefined;
      this._failedRequestLoggingMode = undefined;
      this._flushPeriodSec = undefined;
      this._id = undefined;
      this._includeDocId = undefined;
      this._index = undefined;
      this._maxPayloadEvents = undefined;
      this._maxPayloadSizeKb = undefined;
      this._onBackpressure = undefined;
      this._pipeline = undefined;
      this._pqCompress = undefined;
      this._pqControls.internalValue = undefined;
      this._pqMaxFileSize = undefined;
      this._pqMaxSize = undefined;
      this._pqMode = undefined;
      this._pqOnBackpressure = undefined;
      this._pqPath = undefined;
      this._rejectUnauthorized = undefined;
      this._responseHonorRetryAfterHeader = undefined;
      this._responseRetrySettings.internalValue = undefined;
      this._safeHeaders = undefined;
      this._streamtags = undefined;
      this._systemFields = undefined;
      this._timeoutRetrySettings.internalValue = undefined;
      this._timeoutSec = undefined;
      this._type = undefined;
      this._url = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._auth.internalValue = value.auth;
      this._compress = value.compress;
      this._concurrency = value.concurrency;
      this._description = value.description;
      this._elasticPipeline = value.elasticPipeline;
      this._environment = value.environment;
      this._extraHttpHeaders.internalValue = value.extraHttpHeaders;
      this._extraParams.internalValue = value.extraParams;
      this._failedRequestLoggingMode = value.failedRequestLoggingMode;
      this._flushPeriodSec = value.flushPeriodSec;
      this._id = value.id;
      this._includeDocId = value.includeDocId;
      this._index = value.index;
      this._maxPayloadEvents = value.maxPayloadEvents;
      this._maxPayloadSizeKb = value.maxPayloadSizeKb;
      this._onBackpressure = value.onBackpressure;
      this._pipeline = value.pipeline;
      this._pqCompress = value.pqCompress;
      this._pqControls.internalValue = value.pqControls;
      this._pqMaxFileSize = value.pqMaxFileSize;
      this._pqMaxSize = value.pqMaxSize;
      this._pqMode = value.pqMode;
      this._pqOnBackpressure = value.pqOnBackpressure;
      this._pqPath = value.pqPath;
      this._rejectUnauthorized = value.rejectUnauthorized;
      this._responseHonorRetryAfterHeader = value.responseHonorRetryAfterHeader;
      this._responseRetrySettings.internalValue = value.responseRetrySettings;
      this._safeHeaders = value.safeHeaders;
      this._streamtags = value.streamtags;
      this._systemFields = value.systemFields;
      this._timeoutRetrySettings.internalValue = value.timeoutRetrySettings;
      this._timeoutSec = value.timeoutSec;
      this._type = value.type;
      this._url = value.url;
    }
  }

  // auth - computed: false, optional: true, required: false
  private _auth = new DestinationOutputElasticCloudAuthOutputReference(this, "auth");
  public get auth() {
    return this._auth;
  }
  public putAuth(value: DestinationOutputElasticCloudAuth) {
    this._auth.internalValue = value;
  }
  public resetAuth() {
    this._auth.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authInput() {
    return this._auth.internalValue;
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: boolean | cdktf.IResolvable; 
  public get compress() {
    return this.getBooleanAttribute('compress');
  }
  public set compress(value: boolean | cdktf.IResolvable) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // concurrency - computed: true, optional: true, required: false
  private _concurrency?: number; 
  public get concurrency() {
    return this.getNumberAttribute('concurrency');
  }
  public set concurrency(value: number) {
    this._concurrency = value;
  }
  public resetConcurrency() {
    this._concurrency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get concurrencyInput() {
    return this._concurrency;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // elastic_pipeline - computed: false, optional: true, required: false
  private _elasticPipeline?: string; 
  public get elasticPipeline() {
    return this.getStringAttribute('elastic_pipeline');
  }
  public set elasticPipeline(value: string) {
    this._elasticPipeline = value;
  }
  public resetElasticPipeline() {
    this._elasticPipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get elasticPipelineInput() {
    return this._elasticPipeline;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // extra_http_headers - computed: false, optional: true, required: false
  private _extraHttpHeaders = new DestinationOutputElasticCloudExtraHttpHeadersList(this, "extra_http_headers", false);
  public get extraHttpHeaders() {
    return this._extraHttpHeaders;
  }
  public putExtraHttpHeaders(value: DestinationOutputElasticCloudExtraHttpHeaders[] | cdktf.IResolvable) {
    this._extraHttpHeaders.internalValue = value;
  }
  public resetExtraHttpHeaders() {
    this._extraHttpHeaders.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get extraHttpHeadersInput() {
    return this._extraHttpHeaders.internalValue;
  }

  // extra_params - computed: false, optional: true, required: false
  private _extraParams = new DestinationOutputElasticCloudExtraParamsList(this, "extra_params", false);
  public get extraParams() {
    return this._extraParams;
  }
  public putExtraParams(value: DestinationOutputElasticCloudExtraParams[] | cdktf.IResolvable) {
    this._extraParams.internalValue = value;
  }
  public resetExtraParams() {
    this._extraParams.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get extraParamsInput() {
    return this._extraParams.internalValue;
  }

  // failed_request_logging_mode - computed: true, optional: true, required: false
  private _failedRequestLoggingMode?: string; 
  public get failedRequestLoggingMode() {
    return this.getStringAttribute('failed_request_logging_mode');
  }
  public set failedRequestLoggingMode(value: string) {
    this._failedRequestLoggingMode = value;
  }
  public resetFailedRequestLoggingMode() {
    this._failedRequestLoggingMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get failedRequestLoggingModeInput() {
    return this._failedRequestLoggingMode;
  }

  // flush_period_sec - computed: true, optional: true, required: false
  private _flushPeriodSec?: number; 
  public get flushPeriodSec() {
    return this.getNumberAttribute('flush_period_sec');
  }
  public set flushPeriodSec(value: number) {
    this._flushPeriodSec = value;
  }
  public resetFlushPeriodSec() {
    this._flushPeriodSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get flushPeriodSecInput() {
    return this._flushPeriodSec;
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // include_doc_id - computed: true, optional: true, required: false
  private _includeDocId?: boolean | cdktf.IResolvable; 
  public get includeDocId() {
    return this.getBooleanAttribute('include_doc_id');
  }
  public set includeDocId(value: boolean | cdktf.IResolvable) {
    this._includeDocId = value;
  }
  public resetIncludeDocId() {
    this._includeDocId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get includeDocIdInput() {
    return this._includeDocId;
  }

  // index - computed: false, optional: false, required: true
  private _index?: string; 
  public get index() {
    return this.getStringAttribute('index');
  }
  public set index(value: string) {
    this._index = value;
  }
  // Temporarily expose input value. Use with caution.
  public get indexInput() {
    return this._index;
  }

  // max_payload_events - computed: true, optional: true, required: false
  private _maxPayloadEvents?: number; 
  public get maxPayloadEvents() {
    return this.getNumberAttribute('max_payload_events');
  }
  public set maxPayloadEvents(value: number) {
    this._maxPayloadEvents = value;
  }
  public resetMaxPayloadEvents() {
    this._maxPayloadEvents = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxPayloadEventsInput() {
    return this._maxPayloadEvents;
  }

  // max_payload_size_kb - computed: true, optional: true, required: false
  private _maxPayloadSizeKb?: number; 
  public get maxPayloadSizeKb() {
    return this.getNumberAttribute('max_payload_size_kb');
  }
  public set maxPayloadSizeKb(value: number) {
    this._maxPayloadSizeKb = value;
  }
  public resetMaxPayloadSizeKb() {
    this._maxPayloadSizeKb = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxPayloadSizeKbInput() {
    return this._maxPayloadSizeKb;
  }

  // on_backpressure - computed: true, optional: true, required: false
  private _onBackpressure?: string; 
  public get onBackpressure() {
    return this.getStringAttribute('on_backpressure');
  }
  public set onBackpressure(value: string) {
    this._onBackpressure = value;
  }
  public resetOnBackpressure() {
    this._onBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get onBackpressureInput() {
    return this._onBackpressure;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // pq_compress - computed: true, optional: true, required: false
  private _pqCompress?: string; 
  public get pqCompress() {
    return this.getStringAttribute('pq_compress');
  }
  public set pqCompress(value: string) {
    this._pqCompress = value;
  }
  public resetPqCompress() {
    this._pqCompress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqCompressInput() {
    return this._pqCompress;
  }

  // pq_controls - computed: false, optional: true, required: false
  private _pqControls = new DestinationOutputElasticCloudPqControlsOutputReference(this, "pq_controls");
  public get pqControls() {
    return this._pqControls;
  }
  public putPqControls(value: DestinationOutputElasticCloudPqControls) {
    this._pqControls.internalValue = value;
  }
  public resetPqControls() {
    this._pqControls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqControlsInput() {
    return this._pqControls.internalValue;
  }

  // pq_max_file_size - computed: true, optional: true, required: false
  private _pqMaxFileSize?: string; 
  public get pqMaxFileSize() {
    return this.getStringAttribute('pq_max_file_size');
  }
  public set pqMaxFileSize(value: string) {
    this._pqMaxFileSize = value;
  }
  public resetPqMaxFileSize() {
    this._pqMaxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxFileSizeInput() {
    return this._pqMaxFileSize;
  }

  // pq_max_size - computed: true, optional: true, required: false
  private _pqMaxSize?: string; 
  public get pqMaxSize() {
    return this.getStringAttribute('pq_max_size');
  }
  public set pqMaxSize(value: string) {
    this._pqMaxSize = value;
  }
  public resetPqMaxSize() {
    this._pqMaxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxSizeInput() {
    return this._pqMaxSize;
  }

  // pq_mode - computed: true, optional: true, required: false
  private _pqMode?: string; 
  public get pqMode() {
    return this.getStringAttribute('pq_mode');
  }
  public set pqMode(value: string) {
    this._pqMode = value;
  }
  public resetPqMode() {
    this._pqMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqModeInput() {
    return this._pqMode;
  }

  // pq_on_backpressure - computed: true, optional: true, required: false
  private _pqOnBackpressure?: string; 
  public get pqOnBackpressure() {
    return this.getStringAttribute('pq_on_backpressure');
  }
  public set pqOnBackpressure(value: string) {
    this._pqOnBackpressure = value;
  }
  public resetPqOnBackpressure() {
    this._pqOnBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqOnBackpressureInput() {
    return this._pqOnBackpressure;
  }

  // pq_path - computed: true, optional: true, required: false
  private _pqPath?: string; 
  public get pqPath() {
    return this.getStringAttribute('pq_path');
  }
  public set pqPath(value: string) {
    this._pqPath = value;
  }
  public resetPqPath() {
    this._pqPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqPathInput() {
    return this._pqPath;
  }

  // reject_unauthorized - computed: true, optional: true, required: false
  private _rejectUnauthorized?: boolean | cdktf.IResolvable; 
  public get rejectUnauthorized() {
    return this.getBooleanAttribute('reject_unauthorized');
  }
  public set rejectUnauthorized(value: boolean | cdktf.IResolvable) {
    this._rejectUnauthorized = value;
  }
  public resetRejectUnauthorized() {
    this._rejectUnauthorized = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectUnauthorizedInput() {
    return this._rejectUnauthorized;
  }

  // response_honor_retry_after_header - computed: true, optional: true, required: false
  private _responseHonorRetryAfterHeader?: boolean | cdktf.IResolvable; 
  public get responseHonorRetryAfterHeader() {
    return this.getBooleanAttribute('response_honor_retry_after_header');
  }
  public set responseHonorRetryAfterHeader(value: boolean | cdktf.IResolvable) {
    this._responseHonorRetryAfterHeader = value;
  }
  public resetResponseHonorRetryAfterHeader() {
    this._responseHonorRetryAfterHeader = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get responseHonorRetryAfterHeaderInput() {
    return this._responseHonorRetryAfterHeader;
  }

  // response_retry_settings - computed: false, optional: true, required: false
  private _responseRetrySettings = new DestinationOutputElasticCloudResponseRetrySettingsList(this, "response_retry_settings", false);
  public get responseRetrySettings() {
    return this._responseRetrySettings;
  }
  public putResponseRetrySettings(value: DestinationOutputElasticCloudResponseRetrySettings[] | cdktf.IResolvable) {
    this._responseRetrySettings.internalValue = value;
  }
  public resetResponseRetrySettings() {
    this._responseRetrySettings.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get responseRetrySettingsInput() {
    return this._responseRetrySettings.internalValue;
  }

  // safe_headers - computed: true, optional: true, required: false
  private _safeHeaders?: string[]; 
  public get safeHeaders() {
    return this.getListAttribute('safe_headers');
  }
  public set safeHeaders(value: string[]) {
    this._safeHeaders = value;
  }
  public resetSafeHeaders() {
    this._safeHeaders = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get safeHeadersInput() {
    return this._safeHeaders;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // system_fields - computed: true, optional: true, required: false
  private _systemFields?: string[]; 
  public get systemFields() {
    return this.getListAttribute('system_fields');
  }
  public set systemFields(value: string[]) {
    this._systemFields = value;
  }
  public resetSystemFields() {
    this._systemFields = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get systemFieldsInput() {
    return this._systemFields;
  }

  // timeout_retry_settings - computed: false, optional: true, required: false
  private _timeoutRetrySettings = new DestinationOutputElasticCloudTimeoutRetrySettingsOutputReference(this, "timeout_retry_settings");
  public get timeoutRetrySettings() {
    return this._timeoutRetrySettings;
  }
  public putTimeoutRetrySettings(value: DestinationOutputElasticCloudTimeoutRetrySettings) {
    this._timeoutRetrySettings.internalValue = value;
  }
  public resetTimeoutRetrySettings() {
    this._timeoutRetrySettings.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutRetrySettingsInput() {
    return this._timeoutRetrySettings.internalValue;
  }

  // timeout_sec - computed: true, optional: true, required: false
  private _timeoutSec?: number; 
  public get timeoutSec() {
    return this.getNumberAttribute('timeout_sec');
  }
  public set timeoutSec(value: number) {
    this._timeoutSec = value;
  }
  public resetTimeoutSec() {
    this._timeoutSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutSecInput() {
    return this._timeoutSec;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // url - computed: false, optional: false, required: true
  private _url?: string; 
  public get url() {
    return this.getStringAttribute('url');
  }
  public set url(value: string) {
    this._url = value;
  }
  // Temporarily expose input value. Use with caution.
  public get urlInput() {
    return this._url;
  }
}
export interface DestinationOutputExabeam {
  /**
  * Add the Output ID value to staging location. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#add_id_to_stage_path Destination#add_id_to_stage_path}
  */
  readonly addIdToStagePath?: boolean | cdktf.IResolvable;
  /**
  * HMAC access key. Can be a constant or a JavaScript expression, such as `${C.env.GCS_ACCESS_KEY}`.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#aws_api_key Destination#aws_api_key}
  */
  readonly awsApiKey?: string;
  /**
  * HMAC secret. Can be a constant or a JavaScript expression, such as `${C.env.GCS_SECRET}`.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#aws_secret_key Destination#aws_secret_key}
  */
  readonly awsSecretKey?: string;
  /**
  * Name of the destination bucket. A constant or a JavaScript expression that can only be evaluated at init time. Example of referencing a JavaScript Global Variable: `myBucket-${C.vars.myVar}`.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#bucket Destination#bucket}
  */
  readonly bucket: string;
  /**
  * ID of the Exabeam Collector where data should be sent. Example: 11112222-3333-4444-5555-666677778888
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#collector_instance_id Destination#collector_instance_id}
  */
  readonly collectorInstanceId: string;
  /**
  * If a file fails to move to its final destination after the maximum number of retries, move it to a designated directory to prevent further errors. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#deadletter_enabled Destination#deadletter_enabled}
  */
  readonly deadletterEnabled?: boolean | cdktf.IResolvable;
  /**
  * Storage location for files that fail to reach their final destination after maximum retries are exceeded. Default: "$CRIBL_HOME/state/outputs/dead-letter"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#deadletter_path Destination#deadletter_path}
  */
  readonly deadletterPath?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#description Destination#description}
  */
  readonly description?: string;
  /**
  * How frequently, in seconds, to clean up empty directories. Default: 300
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#empty_dir_cleanup_sec Destination#empty_dir_cleanup_sec}
  */
  readonly emptyDirCleanupSec?: number;
  /**
  * Enter an encoded string containing Exabeam configurations
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#encoded_configuration Destination#encoded_configuration}
  */
  readonly encodedConfiguration?: string;
  /**
  * Google Cloud Storage service endpoint. Default: "https://storage.googleapis.com"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#endpoint Destination#endpoint}
  */
  readonly endpoint?: string;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#environment Destination#environment}
  */
  readonly environment?: string;
  /**
  * Unique ID for this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#id Destination#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * Maximum amount of time to keep inactive files open. Files open for longer than this will be closed and moved to final output location. Default: 30
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#max_file_idle_time_sec Destination#max_file_idle_time_sec}
  */
  readonly maxFileIdleTimeSec?: number;
  /**
  * Maximum amount of time to write to a file. Files open for longer than this will be closed and moved to final output location. Default: 300
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#max_file_open_time_sec Destination#max_file_open_time_sec}
  */
  readonly maxFileOpenTimeSec?: number;
  /**
  * Maximum uncompressed output file size. Files of this size will be closed and moved to final output location. Default: 10
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#max_file_size_mb Destination#max_file_size_mb}
  */
  readonly maxFileSizeMb?: number;
  /**
  * Maximum number of files to keep open concurrently. When exceeded, @{product} will close the oldest open files and move them to the final output location. Default: 100
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#max_open_files Destination#max_open_files}
  */
  readonly maxOpenFiles?: number;
  /**
  * The maximum number of times a file will attempt to move to its final destination before being dead-lettered. Default: 20
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#max_retry_num Destination#max_retry_num}
  */
  readonly maxRetryNum?: number;
  /**
  * Object ACL to assign to uploaded objects. Default: "private"; must be one of ["private", "bucket-owner-read", "bucket-owner-full-control", "project-private", "authenticated-read", "public-read"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#object_acl Destination#object_acl}
  */
  readonly objectAcl?: string;
  /**
  * How to handle events when all receivers are exerting backpressure. Default: "block"; must be one of ["block", "drop"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#on_backpressure Destination#on_backpressure}
  */
  readonly onBackpressure?: string;
  /**
  * How to handle events when disk space is below the global 'Min free disk space' limit. Default: "block"; must be one of ["block", "drop"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#on_disk_full_backpressure Destination#on_disk_full_backpressure}
  */
  readonly onDiskFullBackpressure?: string;
  /**
  * Pipeline to process data before sending out to this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pipeline Destination#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Region where the bucket is located
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#region Destination#region}
  */
  readonly region: string;
  /**
  * Reject certificates that cannot be verified against a valid CA, such as self-signed certificates. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#reject_unauthorized Destination#reject_unauthorized}
  */
  readonly rejectUnauthorized?: boolean | cdktf.IResolvable;
  /**
  * Remove empty staging directories after moving files. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#remove_empty_dirs Destination#remove_empty_dirs}
  */
  readonly removeEmptyDirs?: boolean | cdktf.IResolvable;
  /**
  * Reuse connections between requests, which can improve performance. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#reuse_connections Destination#reuse_connections}
  */
  readonly reuseConnections?: boolean | cdktf.IResolvable;
  /**
  * Signature version to use for signing Google Cloud Storage requests. Default: "v4"; must be one of ["v2", "v4"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#signature_version Destination#signature_version}
  */
  readonly signatureVersion?: string;
  /**
  * Exabeam site ID. If left blank, @{product} will use the value of the Exabeam site name.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#site_id Destination#site_id}
  */
  readonly siteId?: string;
  /**
  * Constant or JavaScript expression to create an Exabeam site name. Values that aren't successfully evaluated will be treated as string constants.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#site_name Destination#site_name}
  */
  readonly siteName?: string;
  /**
  * Filesystem location in which to buffer files, before compressing and moving to final destination. Use performant and stable storage. Default: "$CRIBL_HOME/state/outputs/staging"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#stage_path Destination#stage_path}
  */
  readonly stagePath?: string;
  /**
  * Storage class to select for uploaded objects. must be one of ["STANDARD", "NEARLINE", "COLDLINE", "ARCHIVE"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#storage_class Destination#storage_class}
  */
  readonly storageClass?: string;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#streamtags Destination#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Fields to automatically add to events, such as cribl_pipe. Supports wildcards. Default: ["cribl_pipe"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#system_fields Destination#system_fields}
  */
  readonly systemFields?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#timezone_offset Destination#timezone_offset}
  */
  readonly timezoneOffset?: string;
  /**
  * must be "exabeam"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#type Destination#type}
  */
  readonly type?: string;
}

export function destinationOutputExabeamToTerraform(struct?: DestinationOutputExabeam | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    add_id_to_stage_path: cdktf.booleanToTerraform(struct!.addIdToStagePath),
    aws_api_key: cdktf.stringToTerraform(struct!.awsApiKey),
    aws_secret_key: cdktf.stringToTerraform(struct!.awsSecretKey),
    bucket: cdktf.stringToTerraform(struct!.bucket),
    collector_instance_id: cdktf.stringToTerraform(struct!.collectorInstanceId),
    deadletter_enabled: cdktf.booleanToTerraform(struct!.deadletterEnabled),
    deadletter_path: cdktf.stringToTerraform(struct!.deadletterPath),
    description: cdktf.stringToTerraform(struct!.description),
    empty_dir_cleanup_sec: cdktf.numberToTerraform(struct!.emptyDirCleanupSec),
    encoded_configuration: cdktf.stringToTerraform(struct!.encodedConfiguration),
    endpoint: cdktf.stringToTerraform(struct!.endpoint),
    environment: cdktf.stringToTerraform(struct!.environment),
    id: cdktf.stringToTerraform(struct!.id),
    max_file_idle_time_sec: cdktf.numberToTerraform(struct!.maxFileIdleTimeSec),
    max_file_open_time_sec: cdktf.numberToTerraform(struct!.maxFileOpenTimeSec),
    max_file_size_mb: cdktf.numberToTerraform(struct!.maxFileSizeMb),
    max_open_files: cdktf.numberToTerraform(struct!.maxOpenFiles),
    max_retry_num: cdktf.numberToTerraform(struct!.maxRetryNum),
    object_acl: cdktf.stringToTerraform(struct!.objectAcl),
    on_backpressure: cdktf.stringToTerraform(struct!.onBackpressure),
    on_disk_full_backpressure: cdktf.stringToTerraform(struct!.onDiskFullBackpressure),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    region: cdktf.stringToTerraform(struct!.region),
    reject_unauthorized: cdktf.booleanToTerraform(struct!.rejectUnauthorized),
    remove_empty_dirs: cdktf.booleanToTerraform(struct!.removeEmptyDirs),
    reuse_connections: cdktf.booleanToTerraform(struct!.reuseConnections),
    signature_version: cdktf.stringToTerraform(struct!.signatureVersion),
    site_id: cdktf.stringToTerraform(struct!.siteId),
    site_name: cdktf.stringToTerraform(struct!.siteName),
    stage_path: cdktf.stringToTerraform(struct!.stagePath),
    storage_class: cdktf.stringToTerraform(struct!.storageClass),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    system_fields: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.systemFields),
    timezone_offset: cdktf.stringToTerraform(struct!.timezoneOffset),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function destinationOutputExabeamToHclTerraform(struct?: DestinationOutputExabeam | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    add_id_to_stage_path: {
      value: cdktf.booleanToHclTerraform(struct!.addIdToStagePath),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    aws_api_key: {
      value: cdktf.stringToHclTerraform(struct!.awsApiKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    aws_secret_key: {
      value: cdktf.stringToHclTerraform(struct!.awsSecretKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    bucket: {
      value: cdktf.stringToHclTerraform(struct!.bucket),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    collector_instance_id: {
      value: cdktf.stringToHclTerraform(struct!.collectorInstanceId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    deadletter_enabled: {
      value: cdktf.booleanToHclTerraform(struct!.deadletterEnabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    deadletter_path: {
      value: cdktf.stringToHclTerraform(struct!.deadletterPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    empty_dir_cleanup_sec: {
      value: cdktf.numberToHclTerraform(struct!.emptyDirCleanupSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    encoded_configuration: {
      value: cdktf.stringToHclTerraform(struct!.encodedConfiguration),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    endpoint: {
      value: cdktf.stringToHclTerraform(struct!.endpoint),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_file_idle_time_sec: {
      value: cdktf.numberToHclTerraform(struct!.maxFileIdleTimeSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_file_open_time_sec: {
      value: cdktf.numberToHclTerraform(struct!.maxFileOpenTimeSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_file_size_mb: {
      value: cdktf.numberToHclTerraform(struct!.maxFileSizeMb),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_open_files: {
      value: cdktf.numberToHclTerraform(struct!.maxOpenFiles),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_retry_num: {
      value: cdktf.numberToHclTerraform(struct!.maxRetryNum),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    object_acl: {
      value: cdktf.stringToHclTerraform(struct!.objectAcl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.onBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    on_disk_full_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.onDiskFullBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    region: {
      value: cdktf.stringToHclTerraform(struct!.region),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reject_unauthorized: {
      value: cdktf.booleanToHclTerraform(struct!.rejectUnauthorized),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    remove_empty_dirs: {
      value: cdktf.booleanToHclTerraform(struct!.removeEmptyDirs),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    reuse_connections: {
      value: cdktf.booleanToHclTerraform(struct!.reuseConnections),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    signature_version: {
      value: cdktf.stringToHclTerraform(struct!.signatureVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    site_id: {
      value: cdktf.stringToHclTerraform(struct!.siteId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    site_name: {
      value: cdktf.stringToHclTerraform(struct!.siteName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    stage_path: {
      value: cdktf.stringToHclTerraform(struct!.stagePath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    storage_class: {
      value: cdktf.stringToHclTerraform(struct!.storageClass),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    system_fields: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.systemFields),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    timezone_offset: {
      value: cdktf.stringToHclTerraform(struct!.timezoneOffset),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputExabeamOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DestinationOutputExabeam | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._addIdToStagePath !== undefined) {
      hasAnyValues = true;
      internalValueResult.addIdToStagePath = this._addIdToStagePath;
    }
    if (this._awsApiKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.awsApiKey = this._awsApiKey;
    }
    if (this._awsSecretKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.awsSecretKey = this._awsSecretKey;
    }
    if (this._bucket !== undefined) {
      hasAnyValues = true;
      internalValueResult.bucket = this._bucket;
    }
    if (this._collectorInstanceId !== undefined) {
      hasAnyValues = true;
      internalValueResult.collectorInstanceId = this._collectorInstanceId;
    }
    if (this._deadletterEnabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.deadletterEnabled = this._deadletterEnabled;
    }
    if (this._deadletterPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.deadletterPath = this._deadletterPath;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._emptyDirCleanupSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.emptyDirCleanupSec = this._emptyDirCleanupSec;
    }
    if (this._encodedConfiguration !== undefined) {
      hasAnyValues = true;
      internalValueResult.encodedConfiguration = this._encodedConfiguration;
    }
    if (this._endpoint !== undefined) {
      hasAnyValues = true;
      internalValueResult.endpoint = this._endpoint;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._maxFileIdleTimeSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxFileIdleTimeSec = this._maxFileIdleTimeSec;
    }
    if (this._maxFileOpenTimeSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxFileOpenTimeSec = this._maxFileOpenTimeSec;
    }
    if (this._maxFileSizeMb !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxFileSizeMb = this._maxFileSizeMb;
    }
    if (this._maxOpenFiles !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxOpenFiles = this._maxOpenFiles;
    }
    if (this._maxRetryNum !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxRetryNum = this._maxRetryNum;
    }
    if (this._objectAcl !== undefined) {
      hasAnyValues = true;
      internalValueResult.objectAcl = this._objectAcl;
    }
    if (this._onBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.onBackpressure = this._onBackpressure;
    }
    if (this._onDiskFullBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.onDiskFullBackpressure = this._onDiskFullBackpressure;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._region !== undefined) {
      hasAnyValues = true;
      internalValueResult.region = this._region;
    }
    if (this._rejectUnauthorized !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectUnauthorized = this._rejectUnauthorized;
    }
    if (this._removeEmptyDirs !== undefined) {
      hasAnyValues = true;
      internalValueResult.removeEmptyDirs = this._removeEmptyDirs;
    }
    if (this._reuseConnections !== undefined) {
      hasAnyValues = true;
      internalValueResult.reuseConnections = this._reuseConnections;
    }
    if (this._signatureVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.signatureVersion = this._signatureVersion;
    }
    if (this._siteId !== undefined) {
      hasAnyValues = true;
      internalValueResult.siteId = this._siteId;
    }
    if (this._siteName !== undefined) {
      hasAnyValues = true;
      internalValueResult.siteName = this._siteName;
    }
    if (this._stagePath !== undefined) {
      hasAnyValues = true;
      internalValueResult.stagePath = this._stagePath;
    }
    if (this._storageClass !== undefined) {
      hasAnyValues = true;
      internalValueResult.storageClass = this._storageClass;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._systemFields !== undefined) {
      hasAnyValues = true;
      internalValueResult.systemFields = this._systemFields;
    }
    if (this._timezoneOffset !== undefined) {
      hasAnyValues = true;
      internalValueResult.timezoneOffset = this._timezoneOffset;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputExabeam | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._addIdToStagePath = undefined;
      this._awsApiKey = undefined;
      this._awsSecretKey = undefined;
      this._bucket = undefined;
      this._collectorInstanceId = undefined;
      this._deadletterEnabled = undefined;
      this._deadletterPath = undefined;
      this._description = undefined;
      this._emptyDirCleanupSec = undefined;
      this._encodedConfiguration = undefined;
      this._endpoint = undefined;
      this._environment = undefined;
      this._id = undefined;
      this._maxFileIdleTimeSec = undefined;
      this._maxFileOpenTimeSec = undefined;
      this._maxFileSizeMb = undefined;
      this._maxOpenFiles = undefined;
      this._maxRetryNum = undefined;
      this._objectAcl = undefined;
      this._onBackpressure = undefined;
      this._onDiskFullBackpressure = undefined;
      this._pipeline = undefined;
      this._region = undefined;
      this._rejectUnauthorized = undefined;
      this._removeEmptyDirs = undefined;
      this._reuseConnections = undefined;
      this._signatureVersion = undefined;
      this._siteId = undefined;
      this._siteName = undefined;
      this._stagePath = undefined;
      this._storageClass = undefined;
      this._streamtags = undefined;
      this._systemFields = undefined;
      this._timezoneOffset = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._addIdToStagePath = value.addIdToStagePath;
      this._awsApiKey = value.awsApiKey;
      this._awsSecretKey = value.awsSecretKey;
      this._bucket = value.bucket;
      this._collectorInstanceId = value.collectorInstanceId;
      this._deadletterEnabled = value.deadletterEnabled;
      this._deadletterPath = value.deadletterPath;
      this._description = value.description;
      this._emptyDirCleanupSec = value.emptyDirCleanupSec;
      this._encodedConfiguration = value.encodedConfiguration;
      this._endpoint = value.endpoint;
      this._environment = value.environment;
      this._id = value.id;
      this._maxFileIdleTimeSec = value.maxFileIdleTimeSec;
      this._maxFileOpenTimeSec = value.maxFileOpenTimeSec;
      this._maxFileSizeMb = value.maxFileSizeMb;
      this._maxOpenFiles = value.maxOpenFiles;
      this._maxRetryNum = value.maxRetryNum;
      this._objectAcl = value.objectAcl;
      this._onBackpressure = value.onBackpressure;
      this._onDiskFullBackpressure = value.onDiskFullBackpressure;
      this._pipeline = value.pipeline;
      this._region = value.region;
      this._rejectUnauthorized = value.rejectUnauthorized;
      this._removeEmptyDirs = value.removeEmptyDirs;
      this._reuseConnections = value.reuseConnections;
      this._signatureVersion = value.signatureVersion;
      this._siteId = value.siteId;
      this._siteName = value.siteName;
      this._stagePath = value.stagePath;
      this._storageClass = value.storageClass;
      this._streamtags = value.streamtags;
      this._systemFields = value.systemFields;
      this._timezoneOffset = value.timezoneOffset;
      this._type = value.type;
    }
  }

  // add_id_to_stage_path - computed: true, optional: true, required: false
  private _addIdToStagePath?: boolean | cdktf.IResolvable; 
  public get addIdToStagePath() {
    return this.getBooleanAttribute('add_id_to_stage_path');
  }
  public set addIdToStagePath(value: boolean | cdktf.IResolvable) {
    this._addIdToStagePath = value;
  }
  public resetAddIdToStagePath() {
    this._addIdToStagePath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addIdToStagePathInput() {
    return this._addIdToStagePath;
  }

  // aws_api_key - computed: false, optional: true, required: false
  private _awsApiKey?: string; 
  public get awsApiKey() {
    return this.getStringAttribute('aws_api_key');
  }
  public set awsApiKey(value: string) {
    this._awsApiKey = value;
  }
  public resetAwsApiKey() {
    this._awsApiKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsApiKeyInput() {
    return this._awsApiKey;
  }

  // aws_secret_key - computed: false, optional: true, required: false
  private _awsSecretKey?: string; 
  public get awsSecretKey() {
    return this.getStringAttribute('aws_secret_key');
  }
  public set awsSecretKey(value: string) {
    this._awsSecretKey = value;
  }
  public resetAwsSecretKey() {
    this._awsSecretKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsSecretKeyInput() {
    return this._awsSecretKey;
  }

  // bucket - computed: false, optional: false, required: true
  private _bucket?: string; 
  public get bucket() {
    return this.getStringAttribute('bucket');
  }
  public set bucket(value: string) {
    this._bucket = value;
  }
  // Temporarily expose input value. Use with caution.
  public get bucketInput() {
    return this._bucket;
  }

  // collector_instance_id - computed: false, optional: false, required: true
  private _collectorInstanceId?: string; 
  public get collectorInstanceId() {
    return this.getStringAttribute('collector_instance_id');
  }
  public set collectorInstanceId(value: string) {
    this._collectorInstanceId = value;
  }
  // Temporarily expose input value. Use with caution.
  public get collectorInstanceIdInput() {
    return this._collectorInstanceId;
  }

  // deadletter_enabled - computed: true, optional: true, required: false
  private _deadletterEnabled?: boolean | cdktf.IResolvable; 
  public get deadletterEnabled() {
    return this.getBooleanAttribute('deadletter_enabled');
  }
  public set deadletterEnabled(value: boolean | cdktf.IResolvable) {
    this._deadletterEnabled = value;
  }
  public resetDeadletterEnabled() {
    this._deadletterEnabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get deadletterEnabledInput() {
    return this._deadletterEnabled;
  }

  // deadletter_path - computed: true, optional: true, required: false
  private _deadletterPath?: string; 
  public get deadletterPath() {
    return this.getStringAttribute('deadletter_path');
  }
  public set deadletterPath(value: string) {
    this._deadletterPath = value;
  }
  public resetDeadletterPath() {
    this._deadletterPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get deadletterPathInput() {
    return this._deadletterPath;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // empty_dir_cleanup_sec - computed: true, optional: true, required: false
  private _emptyDirCleanupSec?: number; 
  public get emptyDirCleanupSec() {
    return this.getNumberAttribute('empty_dir_cleanup_sec');
  }
  public set emptyDirCleanupSec(value: number) {
    this._emptyDirCleanupSec = value;
  }
  public resetEmptyDirCleanupSec() {
    this._emptyDirCleanupSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get emptyDirCleanupSecInput() {
    return this._emptyDirCleanupSec;
  }

  // encoded_configuration - computed: false, optional: true, required: false
  private _encodedConfiguration?: string; 
  public get encodedConfiguration() {
    return this.getStringAttribute('encoded_configuration');
  }
  public set encodedConfiguration(value: string) {
    this._encodedConfiguration = value;
  }
  public resetEncodedConfiguration() {
    this._encodedConfiguration = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get encodedConfigurationInput() {
    return this._encodedConfiguration;
  }

  // endpoint - computed: true, optional: true, required: false
  private _endpoint?: string; 
  public get endpoint() {
    return this.getStringAttribute('endpoint');
  }
  public set endpoint(value: string) {
    this._endpoint = value;
  }
  public resetEndpoint() {
    this._endpoint = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get endpointInput() {
    return this._endpoint;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // max_file_idle_time_sec - computed: true, optional: true, required: false
  private _maxFileIdleTimeSec?: number; 
  public get maxFileIdleTimeSec() {
    return this.getNumberAttribute('max_file_idle_time_sec');
  }
  public set maxFileIdleTimeSec(value: number) {
    this._maxFileIdleTimeSec = value;
  }
  public resetMaxFileIdleTimeSec() {
    this._maxFileIdleTimeSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxFileIdleTimeSecInput() {
    return this._maxFileIdleTimeSec;
  }

  // max_file_open_time_sec - computed: true, optional: true, required: false
  private _maxFileOpenTimeSec?: number; 
  public get maxFileOpenTimeSec() {
    return this.getNumberAttribute('max_file_open_time_sec');
  }
  public set maxFileOpenTimeSec(value: number) {
    this._maxFileOpenTimeSec = value;
  }
  public resetMaxFileOpenTimeSec() {
    this._maxFileOpenTimeSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxFileOpenTimeSecInput() {
    return this._maxFileOpenTimeSec;
  }

  // max_file_size_mb - computed: true, optional: true, required: false
  private _maxFileSizeMb?: number; 
  public get maxFileSizeMb() {
    return this.getNumberAttribute('max_file_size_mb');
  }
  public set maxFileSizeMb(value: number) {
    this._maxFileSizeMb = value;
  }
  public resetMaxFileSizeMb() {
    this._maxFileSizeMb = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxFileSizeMbInput() {
    return this._maxFileSizeMb;
  }

  // max_open_files - computed: true, optional: true, required: false
  private _maxOpenFiles?: number; 
  public get maxOpenFiles() {
    return this.getNumberAttribute('max_open_files');
  }
  public set maxOpenFiles(value: number) {
    this._maxOpenFiles = value;
  }
  public resetMaxOpenFiles() {
    this._maxOpenFiles = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxOpenFilesInput() {
    return this._maxOpenFiles;
  }

  // max_retry_num - computed: true, optional: true, required: false
  private _maxRetryNum?: number; 
  public get maxRetryNum() {
    return this.getNumberAttribute('max_retry_num');
  }
  public set maxRetryNum(value: number) {
    this._maxRetryNum = value;
  }
  public resetMaxRetryNum() {
    this._maxRetryNum = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxRetryNumInput() {
    return this._maxRetryNum;
  }

  // object_acl - computed: true, optional: true, required: false
  private _objectAcl?: string; 
  public get objectAcl() {
    return this.getStringAttribute('object_acl');
  }
  public set objectAcl(value: string) {
    this._objectAcl = value;
  }
  public resetObjectAcl() {
    this._objectAcl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get objectAclInput() {
    return this._objectAcl;
  }

  // on_backpressure - computed: true, optional: true, required: false
  private _onBackpressure?: string; 
  public get onBackpressure() {
    return this.getStringAttribute('on_backpressure');
  }
  public set onBackpressure(value: string) {
    this._onBackpressure = value;
  }
  public resetOnBackpressure() {
    this._onBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get onBackpressureInput() {
    return this._onBackpressure;
  }

  // on_disk_full_backpressure - computed: true, optional: true, required: false
  private _onDiskFullBackpressure?: string; 
  public get onDiskFullBackpressure() {
    return this.getStringAttribute('on_disk_full_backpressure');
  }
  public set onDiskFullBackpressure(value: string) {
    this._onDiskFullBackpressure = value;
  }
  public resetOnDiskFullBackpressure() {
    this._onDiskFullBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get onDiskFullBackpressureInput() {
    return this._onDiskFullBackpressure;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // region - computed: false, optional: false, required: true
  private _region?: string; 
  public get region() {
    return this.getStringAttribute('region');
  }
  public set region(value: string) {
    this._region = value;
  }
  // Temporarily expose input value. Use with caution.
  public get regionInput() {
    return this._region;
  }

  // reject_unauthorized - computed: true, optional: true, required: false
  private _rejectUnauthorized?: boolean | cdktf.IResolvable; 
  public get rejectUnauthorized() {
    return this.getBooleanAttribute('reject_unauthorized');
  }
  public set rejectUnauthorized(value: boolean | cdktf.IResolvable) {
    this._rejectUnauthorized = value;
  }
  public resetRejectUnauthorized() {
    this._rejectUnauthorized = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectUnauthorizedInput() {
    return this._rejectUnauthorized;
  }

  // remove_empty_dirs - computed: true, optional: true, required: false
  private _removeEmptyDirs?: boolean | cdktf.IResolvable; 
  public get removeEmptyDirs() {
    return this.getBooleanAttribute('remove_empty_dirs');
  }
  public set removeEmptyDirs(value: boolean | cdktf.IResolvable) {
    this._removeEmptyDirs = value;
  }
  public resetRemoveEmptyDirs() {
    this._removeEmptyDirs = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get removeEmptyDirsInput() {
    return this._removeEmptyDirs;
  }

  // reuse_connections - computed: true, optional: true, required: false
  private _reuseConnections?: boolean | cdktf.IResolvable; 
  public get reuseConnections() {
    return this.getBooleanAttribute('reuse_connections');
  }
  public set reuseConnections(value: boolean | cdktf.IResolvable) {
    this._reuseConnections = value;
  }
  public resetReuseConnections() {
    this._reuseConnections = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get reuseConnectionsInput() {
    return this._reuseConnections;
  }

  // signature_version - computed: true, optional: true, required: false
  private _signatureVersion?: string; 
  public get signatureVersion() {
    return this.getStringAttribute('signature_version');
  }
  public set signatureVersion(value: string) {
    this._signatureVersion = value;
  }
  public resetSignatureVersion() {
    this._signatureVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get signatureVersionInput() {
    return this._signatureVersion;
  }

  // site_id - computed: false, optional: true, required: false
  private _siteId?: string; 
  public get siteId() {
    return this.getStringAttribute('site_id');
  }
  public set siteId(value: string) {
    this._siteId = value;
  }
  public resetSiteId() {
    this._siteId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get siteIdInput() {
    return this._siteId;
  }

  // site_name - computed: false, optional: true, required: false
  private _siteName?: string; 
  public get siteName() {
    return this.getStringAttribute('site_name');
  }
  public set siteName(value: string) {
    this._siteName = value;
  }
  public resetSiteName() {
    this._siteName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get siteNameInput() {
    return this._siteName;
  }

  // stage_path - computed: true, optional: true, required: false
  private _stagePath?: string; 
  public get stagePath() {
    return this.getStringAttribute('stage_path');
  }
  public set stagePath(value: string) {
    this._stagePath = value;
  }
  public resetStagePath() {
    this._stagePath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get stagePathInput() {
    return this._stagePath;
  }

  // storage_class - computed: false, optional: true, required: false
  private _storageClass?: string; 
  public get storageClass() {
    return this.getStringAttribute('storage_class');
  }
  public set storageClass(value: string) {
    this._storageClass = value;
  }
  public resetStorageClass() {
    this._storageClass = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get storageClassInput() {
    return this._storageClass;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // system_fields - computed: true, optional: true, required: false
  private _systemFields?: string[]; 
  public get systemFields() {
    return this.getListAttribute('system_fields');
  }
  public set systemFields(value: string[]) {
    this._systemFields = value;
  }
  public resetSystemFields() {
    this._systemFields = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get systemFieldsInput() {
    return this._systemFields;
  }

  // timezone_offset - computed: false, optional: true, required: false
  private _timezoneOffset?: string; 
  public get timezoneOffset() {
    return this.getStringAttribute('timezone_offset');
  }
  public set timezoneOffset(value: string) {
    this._timezoneOffset = value;
  }
  public resetTimezoneOffset() {
    this._timezoneOffset = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timezoneOffsetInput() {
    return this._timezoneOffset;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface DestinationOutputFilesystemKeyValueMetadata {
  /**
  * Default: ""
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#key Destination#key}
  */
  readonly key?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#value Destination#value}
  */
  readonly value: string;
}

export function destinationOutputFilesystemKeyValueMetadataToTerraform(struct?: DestinationOutputFilesystemKeyValueMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function destinationOutputFilesystemKeyValueMetadataToHclTerraform(struct?: DestinationOutputFilesystemKeyValueMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputFilesystemKeyValueMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DestinationOutputFilesystemKeyValueMetadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputFilesystemKeyValueMetadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._value = value.value;
    }
  }

  // key - computed: true, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DestinationOutputFilesystemKeyValueMetadataList extends cdktf.ComplexList {
  public internalValue? : DestinationOutputFilesystemKeyValueMetadata[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DestinationOutputFilesystemKeyValueMetadataOutputReference {
    return new DestinationOutputFilesystemKeyValueMetadataOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DestinationOutputFilesystem {
  /**
  * Add the Output ID value to staging location. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#add_id_to_stage_path Destination#add_id_to_stage_path}
  */
  readonly addIdToStagePath?: boolean | cdktf.IResolvable;
  /**
  * Automatically calculate the schema based on the events of each Parquet file generated. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#automatic_schema Destination#automatic_schema}
  */
  readonly automaticSchema?: boolean | cdktf.IResolvable;
  /**
  * JavaScript expression to define the output filename prefix (can be constant). Default: "`CriblOut`"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#base_file_name Destination#base_file_name}
  */
  readonly baseFileName?: string;
  /**
  * Data compression format to apply to HTTP content before it is delivered. Default: "gzip"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#compress Destination#compress}
  */
  readonly compress?: string;
  /**
  * Compression level to apply before moving files to final destination. Default: "best_speed"; must be one of ["best_speed", "normal", "best_compression"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#compression_level Destination#compression_level}
  */
  readonly compressionLevel?: string;
  /**
  * If a file fails to move to its final destination after the maximum number of retries, move it to a designated directory to prevent further errors. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#deadletter_enabled Destination#deadletter_enabled}
  */
  readonly deadletterEnabled?: boolean | cdktf.IResolvable;
  /**
  * Storage location for files that fail to reach their final destination after maximum retries are exceeded. Default: "$CRIBL_HOME/state/outputs/dead-letter"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#deadletter_path Destination#deadletter_path}
  */
  readonly deadletterPath?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#description Destination#description}
  */
  readonly description?: string;
  /**
  * Final destination for the output files
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#dest_path Destination#dest_path}
  */
  readonly destPath: string;
  /**
  * How frequently, in seconds, to clean up empty directories. Default: 300
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#empty_dir_cleanup_sec Destination#empty_dir_cleanup_sec}
  */
  readonly emptyDirCleanupSec?: number;
  /**
  * Parquet tools can use the checksum of a Parquet page to verify data integrity. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#enable_page_checksum Destination#enable_page_checksum}
  */
  readonly enablePageChecksum?: boolean | cdktf.IResolvable;
  /**
  * Statistics profile an entire file in terms of minimum/maximum values within data, numbers of nulls, etc. You can use Parquet tools to view statistics. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#enable_statistics Destination#enable_statistics}
  */
  readonly enableStatistics?: boolean | cdktf.IResolvable;
  /**
  * One page index contains statistics for one data page. Parquet readers use statistics to enable page skipping. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#enable_write_page_index Destination#enable_write_page_index}
  */
  readonly enableWritePageIndex?: boolean | cdktf.IResolvable;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#environment Destination#environment}
  */
  readonly environment?: string;
  /**
  * JavaScript expression to define the output filename suffix (can be constant).  The `__format` variable refers to the value of the `Data format` field (`json` or `raw`).  The `__compression` field refers to the kind of compression being used (`none` or `gzip`). Default: "`.${C.env[\"CRIBL_WORKER_ID\"]}.${__format}${__compression === \"gzip\" ? \".gz\" : \"\"}`"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#file_name_suffix Destination#file_name_suffix}
  */
  readonly fileNameSuffix?: string;
  /**
  * Format of the output data. Default: "json"; must be one of ["json", "raw", "parquet"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#format Destination#format}
  */
  readonly format?: string;
  /**
  * If set, this line will be written to the beginning of each output file. Default: ""
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#header_line Destination#header_line}
  */
  readonly headerLine?: string;
  /**
  * Unique ID for this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#id Destination#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * The metadata of files the Destination writes will include the properties you add here as key-value pairs. Useful for tagging. Examples: "key":"OCSF Event Class", "value":"9001"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#key_value_metadata Destination#key_value_metadata}
  */
  readonly keyValueMetadata?: DestinationOutputFilesystemKeyValueMetadata[] | cdktf.IResolvable;
  /**
  * Maximum amount of time to keep inactive files open. Files open for longer than this will be closed and moved to final output location. Default: 30
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#max_file_idle_time_sec Destination#max_file_idle_time_sec}
  */
  readonly maxFileIdleTimeSec?: number;
  /**
  * Maximum amount of time to write to a file. Files open for longer than this will be closed and moved to final output location. Default: 300
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#max_file_open_time_sec Destination#max_file_open_time_sec}
  */
  readonly maxFileOpenTimeSec?: number;
  /**
  * Maximum uncompressed output file size. Files of this size will be closed and moved to final output location. Default: 32
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#max_file_size_mb Destination#max_file_size_mb}
  */
  readonly maxFileSizeMb?: number;
  /**
  * Maximum number of files to keep open concurrently. When exceeded, @{product} will close the oldest open files and move them to the final output location. Default: 100
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#max_open_files Destination#max_open_files}
  */
  readonly maxOpenFiles?: number;
  /**
  * The maximum number of times a file will attempt to move to its final destination before being dead-lettered. Default: 20
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#max_retry_num Destination#max_retry_num}
  */
  readonly maxRetryNum?: number;
  /**
  * How to handle events when all receivers are exerting backpressure. Default: "block"; must be one of ["block", "drop"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#on_backpressure Destination#on_backpressure}
  */
  readonly onBackpressure?: string;
  /**
  * How to handle events when disk space is below the global 'Min free disk space' limit. Default: "block"; must be one of ["block", "drop"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#on_disk_full_backpressure Destination#on_disk_full_backpressure}
  */
  readonly onDiskFullBackpressure?: string;
  /**
  * Serialization format of data pages. Note that some reader implementations use Data page V2's attributes to work more efficiently, while others ignore it. Default: "DATA_PAGE_V2"; must be one of ["DATA_PAGE_V1", "DATA_PAGE_V2"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#parquet_data_page_version Destination#parquet_data_page_version}
  */
  readonly parquetDataPageVersion?: string;
  /**
  * Target memory size for page segments, such as 1MB or 128MB. Generally, lower values improve reading speed, while higher values improve compression. Default: "1MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#parquet_page_size Destination#parquet_page_size}
  */
  readonly parquetPageSize?: string;
  /**
  * The number of rows that every group will contain. The final group can contain a smaller number of rows. Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#parquet_row_group_length Destination#parquet_row_group_length}
  */
  readonly parquetRowGroupLength?: number;
  /**
  * Determines which data types are supported and how they are represented. Default: "PARQUET_2_6"; must be one of ["PARQUET_1_0", "PARQUET_2_4", "PARQUET_2_6"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#parquet_version Destination#parquet_version}
  */
  readonly parquetVersion?: string;
  /**
  * JavaScript expression defining how files are partitioned and organized. Default is date-based. If blank, Stream will fall back to the event's __partition field value – if present – otherwise to each location's root directory. Default: "C.Time.strftime(_time ? _time : Date.now()/1000, '%Y/%m/%d')"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#partition_expr Destination#partition_expr}
  */
  readonly partitionExpr?: string;
  /**
  * Pipeline to process data before sending out to this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pipeline Destination#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Remove empty staging directories after moving files. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#remove_empty_dirs Destination#remove_empty_dirs}
  */
  readonly removeEmptyDirs?: boolean | cdktf.IResolvable;
  /**
  * Log up to 3 rows that @{product} skips due to data mismatch
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#should_log_invalid_rows Destination#should_log_invalid_rows}
  */
  readonly shouldLogInvalidRows?: boolean | cdktf.IResolvable;
  /**
  * Filesystem location in which to buffer files before compressing and moving to final destination. Use performant, stable storage.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#stage_path Destination#stage_path}
  */
  readonly stagePath?: string;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#streamtags Destination#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Fields to automatically add to events, such as cribl_pipe. Supports wildcards. Default: ["cribl_pipe"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#system_fields Destination#system_fields}
  */
  readonly systemFields?: string[];
  /**
  * must be "filesystem"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#type Destination#type}
  */
  readonly type: string;
  /**
  * Buffer size used to write to a file. Default: 64
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#write_high_water_mark Destination#write_high_water_mark}
  */
  readonly writeHighWaterMark?: number;
}

export function destinationOutputFilesystemToTerraform(struct?: DestinationOutputFilesystem | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    add_id_to_stage_path: cdktf.booleanToTerraform(struct!.addIdToStagePath),
    automatic_schema: cdktf.booleanToTerraform(struct!.automaticSchema),
    base_file_name: cdktf.stringToTerraform(struct!.baseFileName),
    compress: cdktf.stringToTerraform(struct!.compress),
    compression_level: cdktf.stringToTerraform(struct!.compressionLevel),
    deadletter_enabled: cdktf.booleanToTerraform(struct!.deadletterEnabled),
    deadletter_path: cdktf.stringToTerraform(struct!.deadletterPath),
    description: cdktf.stringToTerraform(struct!.description),
    dest_path: cdktf.stringToTerraform(struct!.destPath),
    empty_dir_cleanup_sec: cdktf.numberToTerraform(struct!.emptyDirCleanupSec),
    enable_page_checksum: cdktf.booleanToTerraform(struct!.enablePageChecksum),
    enable_statistics: cdktf.booleanToTerraform(struct!.enableStatistics),
    enable_write_page_index: cdktf.booleanToTerraform(struct!.enableWritePageIndex),
    environment: cdktf.stringToTerraform(struct!.environment),
    file_name_suffix: cdktf.stringToTerraform(struct!.fileNameSuffix),
    format: cdktf.stringToTerraform(struct!.format),
    header_line: cdktf.stringToTerraform(struct!.headerLine),
    id: cdktf.stringToTerraform(struct!.id),
    key_value_metadata: cdktf.listMapper(destinationOutputFilesystemKeyValueMetadataToTerraform, false)(struct!.keyValueMetadata),
    max_file_idle_time_sec: cdktf.numberToTerraform(struct!.maxFileIdleTimeSec),
    max_file_open_time_sec: cdktf.numberToTerraform(struct!.maxFileOpenTimeSec),
    max_file_size_mb: cdktf.numberToTerraform(struct!.maxFileSizeMb),
    max_open_files: cdktf.numberToTerraform(struct!.maxOpenFiles),
    max_retry_num: cdktf.numberToTerraform(struct!.maxRetryNum),
    on_backpressure: cdktf.stringToTerraform(struct!.onBackpressure),
    on_disk_full_backpressure: cdktf.stringToTerraform(struct!.onDiskFullBackpressure),
    parquet_data_page_version: cdktf.stringToTerraform(struct!.parquetDataPageVersion),
    parquet_page_size: cdktf.stringToTerraform(struct!.parquetPageSize),
    parquet_row_group_length: cdktf.numberToTerraform(struct!.parquetRowGroupLength),
    parquet_version: cdktf.stringToTerraform(struct!.parquetVersion),
    partition_expr: cdktf.stringToTerraform(struct!.partitionExpr),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    remove_empty_dirs: cdktf.booleanToTerraform(struct!.removeEmptyDirs),
    should_log_invalid_rows: cdktf.booleanToTerraform(struct!.shouldLogInvalidRows),
    stage_path: cdktf.stringToTerraform(struct!.stagePath),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    system_fields: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.systemFields),
    type: cdktf.stringToTerraform(struct!.type),
    write_high_water_mark: cdktf.numberToTerraform(struct!.writeHighWaterMark),
  }
}


export function destinationOutputFilesystemToHclTerraform(struct?: DestinationOutputFilesystem | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    add_id_to_stage_path: {
      value: cdktf.booleanToHclTerraform(struct!.addIdToStagePath),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    automatic_schema: {
      value: cdktf.booleanToHclTerraform(struct!.automaticSchema),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    base_file_name: {
      value: cdktf.stringToHclTerraform(struct!.baseFileName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    compress: {
      value: cdktf.stringToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    compression_level: {
      value: cdktf.stringToHclTerraform(struct!.compressionLevel),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    deadletter_enabled: {
      value: cdktf.booleanToHclTerraform(struct!.deadletterEnabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    deadletter_path: {
      value: cdktf.stringToHclTerraform(struct!.deadletterPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    dest_path: {
      value: cdktf.stringToHclTerraform(struct!.destPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    empty_dir_cleanup_sec: {
      value: cdktf.numberToHclTerraform(struct!.emptyDirCleanupSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    enable_page_checksum: {
      value: cdktf.booleanToHclTerraform(struct!.enablePageChecksum),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    enable_statistics: {
      value: cdktf.booleanToHclTerraform(struct!.enableStatistics),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    enable_write_page_index: {
      value: cdktf.booleanToHclTerraform(struct!.enableWritePageIndex),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    file_name_suffix: {
      value: cdktf.stringToHclTerraform(struct!.fileNameSuffix),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    format: {
      value: cdktf.stringToHclTerraform(struct!.format),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    header_line: {
      value: cdktf.stringToHclTerraform(struct!.headerLine),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    key_value_metadata: {
      value: cdktf.listMapperHcl(destinationOutputFilesystemKeyValueMetadataToHclTerraform, false)(struct!.keyValueMetadata),
      isBlock: true,
      type: "list",
      storageClassType: "DestinationOutputFilesystemKeyValueMetadataList",
    },
    max_file_idle_time_sec: {
      value: cdktf.numberToHclTerraform(struct!.maxFileIdleTimeSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_file_open_time_sec: {
      value: cdktf.numberToHclTerraform(struct!.maxFileOpenTimeSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_file_size_mb: {
      value: cdktf.numberToHclTerraform(struct!.maxFileSizeMb),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_open_files: {
      value: cdktf.numberToHclTerraform(struct!.maxOpenFiles),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_retry_num: {
      value: cdktf.numberToHclTerraform(struct!.maxRetryNum),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.onBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    on_disk_full_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.onDiskFullBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    parquet_data_page_version: {
      value: cdktf.stringToHclTerraform(struct!.parquetDataPageVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    parquet_page_size: {
      value: cdktf.stringToHclTerraform(struct!.parquetPageSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    parquet_row_group_length: {
      value: cdktf.numberToHclTerraform(struct!.parquetRowGroupLength),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    parquet_version: {
      value: cdktf.stringToHclTerraform(struct!.parquetVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    partition_expr: {
      value: cdktf.stringToHclTerraform(struct!.partitionExpr),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    remove_empty_dirs: {
      value: cdktf.booleanToHclTerraform(struct!.removeEmptyDirs),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    should_log_invalid_rows: {
      value: cdktf.booleanToHclTerraform(struct!.shouldLogInvalidRows),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    stage_path: {
      value: cdktf.stringToHclTerraform(struct!.stagePath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    system_fields: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.systemFields),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    write_high_water_mark: {
      value: cdktf.numberToHclTerraform(struct!.writeHighWaterMark),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputFilesystemOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DestinationOutputFilesystem | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._addIdToStagePath !== undefined) {
      hasAnyValues = true;
      internalValueResult.addIdToStagePath = this._addIdToStagePath;
    }
    if (this._automaticSchema !== undefined) {
      hasAnyValues = true;
      internalValueResult.automaticSchema = this._automaticSchema;
    }
    if (this._baseFileName !== undefined) {
      hasAnyValues = true;
      internalValueResult.baseFileName = this._baseFileName;
    }
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._compressionLevel !== undefined) {
      hasAnyValues = true;
      internalValueResult.compressionLevel = this._compressionLevel;
    }
    if (this._deadletterEnabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.deadletterEnabled = this._deadletterEnabled;
    }
    if (this._deadletterPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.deadletterPath = this._deadletterPath;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._destPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.destPath = this._destPath;
    }
    if (this._emptyDirCleanupSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.emptyDirCleanupSec = this._emptyDirCleanupSec;
    }
    if (this._enablePageChecksum !== undefined) {
      hasAnyValues = true;
      internalValueResult.enablePageChecksum = this._enablePageChecksum;
    }
    if (this._enableStatistics !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableStatistics = this._enableStatistics;
    }
    if (this._enableWritePageIndex !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableWritePageIndex = this._enableWritePageIndex;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._fileNameSuffix !== undefined) {
      hasAnyValues = true;
      internalValueResult.fileNameSuffix = this._fileNameSuffix;
    }
    if (this._format !== undefined) {
      hasAnyValues = true;
      internalValueResult.format = this._format;
    }
    if (this._headerLine !== undefined) {
      hasAnyValues = true;
      internalValueResult.headerLine = this._headerLine;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._keyValueMetadata?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.keyValueMetadata = this._keyValueMetadata?.internalValue;
    }
    if (this._maxFileIdleTimeSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxFileIdleTimeSec = this._maxFileIdleTimeSec;
    }
    if (this._maxFileOpenTimeSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxFileOpenTimeSec = this._maxFileOpenTimeSec;
    }
    if (this._maxFileSizeMb !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxFileSizeMb = this._maxFileSizeMb;
    }
    if (this._maxOpenFiles !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxOpenFiles = this._maxOpenFiles;
    }
    if (this._maxRetryNum !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxRetryNum = this._maxRetryNum;
    }
    if (this._onBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.onBackpressure = this._onBackpressure;
    }
    if (this._onDiskFullBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.onDiskFullBackpressure = this._onDiskFullBackpressure;
    }
    if (this._parquetDataPageVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.parquetDataPageVersion = this._parquetDataPageVersion;
    }
    if (this._parquetPageSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.parquetPageSize = this._parquetPageSize;
    }
    if (this._parquetRowGroupLength !== undefined) {
      hasAnyValues = true;
      internalValueResult.parquetRowGroupLength = this._parquetRowGroupLength;
    }
    if (this._parquetVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.parquetVersion = this._parquetVersion;
    }
    if (this._partitionExpr !== undefined) {
      hasAnyValues = true;
      internalValueResult.partitionExpr = this._partitionExpr;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._removeEmptyDirs !== undefined) {
      hasAnyValues = true;
      internalValueResult.removeEmptyDirs = this._removeEmptyDirs;
    }
    if (this._shouldLogInvalidRows !== undefined) {
      hasAnyValues = true;
      internalValueResult.shouldLogInvalidRows = this._shouldLogInvalidRows;
    }
    if (this._stagePath !== undefined) {
      hasAnyValues = true;
      internalValueResult.stagePath = this._stagePath;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._systemFields !== undefined) {
      hasAnyValues = true;
      internalValueResult.systemFields = this._systemFields;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._writeHighWaterMark !== undefined) {
      hasAnyValues = true;
      internalValueResult.writeHighWaterMark = this._writeHighWaterMark;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputFilesystem | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._addIdToStagePath = undefined;
      this._automaticSchema = undefined;
      this._baseFileName = undefined;
      this._compress = undefined;
      this._compressionLevel = undefined;
      this._deadletterEnabled = undefined;
      this._deadletterPath = undefined;
      this._description = undefined;
      this._destPath = undefined;
      this._emptyDirCleanupSec = undefined;
      this._enablePageChecksum = undefined;
      this._enableStatistics = undefined;
      this._enableWritePageIndex = undefined;
      this._environment = undefined;
      this._fileNameSuffix = undefined;
      this._format = undefined;
      this._headerLine = undefined;
      this._id = undefined;
      this._keyValueMetadata.internalValue = undefined;
      this._maxFileIdleTimeSec = undefined;
      this._maxFileOpenTimeSec = undefined;
      this._maxFileSizeMb = undefined;
      this._maxOpenFiles = undefined;
      this._maxRetryNum = undefined;
      this._onBackpressure = undefined;
      this._onDiskFullBackpressure = undefined;
      this._parquetDataPageVersion = undefined;
      this._parquetPageSize = undefined;
      this._parquetRowGroupLength = undefined;
      this._parquetVersion = undefined;
      this._partitionExpr = undefined;
      this._pipeline = undefined;
      this._removeEmptyDirs = undefined;
      this._shouldLogInvalidRows = undefined;
      this._stagePath = undefined;
      this._streamtags = undefined;
      this._systemFields = undefined;
      this._type = undefined;
      this._writeHighWaterMark = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._addIdToStagePath = value.addIdToStagePath;
      this._automaticSchema = value.automaticSchema;
      this._baseFileName = value.baseFileName;
      this._compress = value.compress;
      this._compressionLevel = value.compressionLevel;
      this._deadletterEnabled = value.deadletterEnabled;
      this._deadletterPath = value.deadletterPath;
      this._description = value.description;
      this._destPath = value.destPath;
      this._emptyDirCleanupSec = value.emptyDirCleanupSec;
      this._enablePageChecksum = value.enablePageChecksum;
      this._enableStatistics = value.enableStatistics;
      this._enableWritePageIndex = value.enableWritePageIndex;
      this._environment = value.environment;
      this._fileNameSuffix = value.fileNameSuffix;
      this._format = value.format;
      this._headerLine = value.headerLine;
      this._id = value.id;
      this._keyValueMetadata.internalValue = value.keyValueMetadata;
      this._maxFileIdleTimeSec = value.maxFileIdleTimeSec;
      this._maxFileOpenTimeSec = value.maxFileOpenTimeSec;
      this._maxFileSizeMb = value.maxFileSizeMb;
      this._maxOpenFiles = value.maxOpenFiles;
      this._maxRetryNum = value.maxRetryNum;
      this._onBackpressure = value.onBackpressure;
      this._onDiskFullBackpressure = value.onDiskFullBackpressure;
      this._parquetDataPageVersion = value.parquetDataPageVersion;
      this._parquetPageSize = value.parquetPageSize;
      this._parquetRowGroupLength = value.parquetRowGroupLength;
      this._parquetVersion = value.parquetVersion;
      this._partitionExpr = value.partitionExpr;
      this._pipeline = value.pipeline;
      this._removeEmptyDirs = value.removeEmptyDirs;
      this._shouldLogInvalidRows = value.shouldLogInvalidRows;
      this._stagePath = value.stagePath;
      this._streamtags = value.streamtags;
      this._systemFields = value.systemFields;
      this._type = value.type;
      this._writeHighWaterMark = value.writeHighWaterMark;
    }
  }

  // add_id_to_stage_path - computed: true, optional: true, required: false
  private _addIdToStagePath?: boolean | cdktf.IResolvable; 
  public get addIdToStagePath() {
    return this.getBooleanAttribute('add_id_to_stage_path');
  }
  public set addIdToStagePath(value: boolean | cdktf.IResolvable) {
    this._addIdToStagePath = value;
  }
  public resetAddIdToStagePath() {
    this._addIdToStagePath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addIdToStagePathInput() {
    return this._addIdToStagePath;
  }

  // automatic_schema - computed: true, optional: true, required: false
  private _automaticSchema?: boolean | cdktf.IResolvable; 
  public get automaticSchema() {
    return this.getBooleanAttribute('automatic_schema');
  }
  public set automaticSchema(value: boolean | cdktf.IResolvable) {
    this._automaticSchema = value;
  }
  public resetAutomaticSchema() {
    this._automaticSchema = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get automaticSchemaInput() {
    return this._automaticSchema;
  }

  // base_file_name - computed: true, optional: true, required: false
  private _baseFileName?: string; 
  public get baseFileName() {
    return this.getStringAttribute('base_file_name');
  }
  public set baseFileName(value: string) {
    this._baseFileName = value;
  }
  public resetBaseFileName() {
    this._baseFileName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get baseFileNameInput() {
    return this._baseFileName;
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: string; 
  public get compress() {
    return this.getStringAttribute('compress');
  }
  public set compress(value: string) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // compression_level - computed: true, optional: true, required: false
  private _compressionLevel?: string; 
  public get compressionLevel() {
    return this.getStringAttribute('compression_level');
  }
  public set compressionLevel(value: string) {
    this._compressionLevel = value;
  }
  public resetCompressionLevel() {
    this._compressionLevel = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressionLevelInput() {
    return this._compressionLevel;
  }

  // deadletter_enabled - computed: true, optional: true, required: false
  private _deadletterEnabled?: boolean | cdktf.IResolvable; 
  public get deadletterEnabled() {
    return this.getBooleanAttribute('deadletter_enabled');
  }
  public set deadletterEnabled(value: boolean | cdktf.IResolvable) {
    this._deadletterEnabled = value;
  }
  public resetDeadletterEnabled() {
    this._deadletterEnabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get deadletterEnabledInput() {
    return this._deadletterEnabled;
  }

  // deadletter_path - computed: true, optional: true, required: false
  private _deadletterPath?: string; 
  public get deadletterPath() {
    return this.getStringAttribute('deadletter_path');
  }
  public set deadletterPath(value: string) {
    this._deadletterPath = value;
  }
  public resetDeadletterPath() {
    this._deadletterPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get deadletterPathInput() {
    return this._deadletterPath;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // dest_path - computed: false, optional: false, required: true
  private _destPath?: string; 
  public get destPath() {
    return this.getStringAttribute('dest_path');
  }
  public set destPath(value: string) {
    this._destPath = value;
  }
  // Temporarily expose input value. Use with caution.
  public get destPathInput() {
    return this._destPath;
  }

  // empty_dir_cleanup_sec - computed: true, optional: true, required: false
  private _emptyDirCleanupSec?: number; 
  public get emptyDirCleanupSec() {
    return this.getNumberAttribute('empty_dir_cleanup_sec');
  }
  public set emptyDirCleanupSec(value: number) {
    this._emptyDirCleanupSec = value;
  }
  public resetEmptyDirCleanupSec() {
    this._emptyDirCleanupSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get emptyDirCleanupSecInput() {
    return this._emptyDirCleanupSec;
  }

  // enable_page_checksum - computed: true, optional: true, required: false
  private _enablePageChecksum?: boolean | cdktf.IResolvable; 
  public get enablePageChecksum() {
    return this.getBooleanAttribute('enable_page_checksum');
  }
  public set enablePageChecksum(value: boolean | cdktf.IResolvable) {
    this._enablePageChecksum = value;
  }
  public resetEnablePageChecksum() {
    this._enablePageChecksum = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enablePageChecksumInput() {
    return this._enablePageChecksum;
  }

  // enable_statistics - computed: true, optional: true, required: false
  private _enableStatistics?: boolean | cdktf.IResolvable; 
  public get enableStatistics() {
    return this.getBooleanAttribute('enable_statistics');
  }
  public set enableStatistics(value: boolean | cdktf.IResolvable) {
    this._enableStatistics = value;
  }
  public resetEnableStatistics() {
    this._enableStatistics = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableStatisticsInput() {
    return this._enableStatistics;
  }

  // enable_write_page_index - computed: true, optional: true, required: false
  private _enableWritePageIndex?: boolean | cdktf.IResolvable; 
  public get enableWritePageIndex() {
    return this.getBooleanAttribute('enable_write_page_index');
  }
  public set enableWritePageIndex(value: boolean | cdktf.IResolvable) {
    this._enableWritePageIndex = value;
  }
  public resetEnableWritePageIndex() {
    this._enableWritePageIndex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableWritePageIndexInput() {
    return this._enableWritePageIndex;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // file_name_suffix - computed: true, optional: true, required: false
  private _fileNameSuffix?: string; 
  public get fileNameSuffix() {
    return this.getStringAttribute('file_name_suffix');
  }
  public set fileNameSuffix(value: string) {
    this._fileNameSuffix = value;
  }
  public resetFileNameSuffix() {
    this._fileNameSuffix = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fileNameSuffixInput() {
    return this._fileNameSuffix;
  }

  // format - computed: true, optional: true, required: false
  private _format?: string; 
  public get format() {
    return this.getStringAttribute('format');
  }
  public set format(value: string) {
    this._format = value;
  }
  public resetFormat() {
    this._format = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get formatInput() {
    return this._format;
  }

  // header_line - computed: true, optional: true, required: false
  private _headerLine?: string; 
  public get headerLine() {
    return this.getStringAttribute('header_line');
  }
  public set headerLine(value: string) {
    this._headerLine = value;
  }
  public resetHeaderLine() {
    this._headerLine = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get headerLineInput() {
    return this._headerLine;
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // key_value_metadata - computed: false, optional: true, required: false
  private _keyValueMetadata = new DestinationOutputFilesystemKeyValueMetadataList(this, "key_value_metadata", false);
  public get keyValueMetadata() {
    return this._keyValueMetadata;
  }
  public putKeyValueMetadata(value: DestinationOutputFilesystemKeyValueMetadata[] | cdktf.IResolvable) {
    this._keyValueMetadata.internalValue = value;
  }
  public resetKeyValueMetadata() {
    this._keyValueMetadata.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyValueMetadataInput() {
    return this._keyValueMetadata.internalValue;
  }

  // max_file_idle_time_sec - computed: true, optional: true, required: false
  private _maxFileIdleTimeSec?: number; 
  public get maxFileIdleTimeSec() {
    return this.getNumberAttribute('max_file_idle_time_sec');
  }
  public set maxFileIdleTimeSec(value: number) {
    this._maxFileIdleTimeSec = value;
  }
  public resetMaxFileIdleTimeSec() {
    this._maxFileIdleTimeSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxFileIdleTimeSecInput() {
    return this._maxFileIdleTimeSec;
  }

  // max_file_open_time_sec - computed: true, optional: true, required: false
  private _maxFileOpenTimeSec?: number; 
  public get maxFileOpenTimeSec() {
    return this.getNumberAttribute('max_file_open_time_sec');
  }
  public set maxFileOpenTimeSec(value: number) {
    this._maxFileOpenTimeSec = value;
  }
  public resetMaxFileOpenTimeSec() {
    this._maxFileOpenTimeSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxFileOpenTimeSecInput() {
    return this._maxFileOpenTimeSec;
  }

  // max_file_size_mb - computed: true, optional: true, required: false
  private _maxFileSizeMb?: number; 
  public get maxFileSizeMb() {
    return this.getNumberAttribute('max_file_size_mb');
  }
  public set maxFileSizeMb(value: number) {
    this._maxFileSizeMb = value;
  }
  public resetMaxFileSizeMb() {
    this._maxFileSizeMb = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxFileSizeMbInput() {
    return this._maxFileSizeMb;
  }

  // max_open_files - computed: true, optional: true, required: false
  private _maxOpenFiles?: number; 
  public get maxOpenFiles() {
    return this.getNumberAttribute('max_open_files');
  }
  public set maxOpenFiles(value: number) {
    this._maxOpenFiles = value;
  }
  public resetMaxOpenFiles() {
    this._maxOpenFiles = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxOpenFilesInput() {
    return this._maxOpenFiles;
  }

  // max_retry_num - computed: true, optional: true, required: false
  private _maxRetryNum?: number; 
  public get maxRetryNum() {
    return this.getNumberAttribute('max_retry_num');
  }
  public set maxRetryNum(value: number) {
    this._maxRetryNum = value;
  }
  public resetMaxRetryNum() {
    this._maxRetryNum = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxRetryNumInput() {
    return this._maxRetryNum;
  }

  // on_backpressure - computed: true, optional: true, required: false
  private _onBackpressure?: string; 
  public get onBackpressure() {
    return this.getStringAttribute('on_backpressure');
  }
  public set onBackpressure(value: string) {
    this._onBackpressure = value;
  }
  public resetOnBackpressure() {
    this._onBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get onBackpressureInput() {
    return this._onBackpressure;
  }

  // on_disk_full_backpressure - computed: true, optional: true, required: false
  private _onDiskFullBackpressure?: string; 
  public get onDiskFullBackpressure() {
    return this.getStringAttribute('on_disk_full_backpressure');
  }
  public set onDiskFullBackpressure(value: string) {
    this._onDiskFullBackpressure = value;
  }
  public resetOnDiskFullBackpressure() {
    this._onDiskFullBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get onDiskFullBackpressureInput() {
    return this._onDiskFullBackpressure;
  }

  // parquet_data_page_version - computed: true, optional: true, required: false
  private _parquetDataPageVersion?: string; 
  public get parquetDataPageVersion() {
    return this.getStringAttribute('parquet_data_page_version');
  }
  public set parquetDataPageVersion(value: string) {
    this._parquetDataPageVersion = value;
  }
  public resetParquetDataPageVersion() {
    this._parquetDataPageVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get parquetDataPageVersionInput() {
    return this._parquetDataPageVersion;
  }

  // parquet_page_size - computed: true, optional: true, required: false
  private _parquetPageSize?: string; 
  public get parquetPageSize() {
    return this.getStringAttribute('parquet_page_size');
  }
  public set parquetPageSize(value: string) {
    this._parquetPageSize = value;
  }
  public resetParquetPageSize() {
    this._parquetPageSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get parquetPageSizeInput() {
    return this._parquetPageSize;
  }

  // parquet_row_group_length - computed: true, optional: true, required: false
  private _parquetRowGroupLength?: number; 
  public get parquetRowGroupLength() {
    return this.getNumberAttribute('parquet_row_group_length');
  }
  public set parquetRowGroupLength(value: number) {
    this._parquetRowGroupLength = value;
  }
  public resetParquetRowGroupLength() {
    this._parquetRowGroupLength = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get parquetRowGroupLengthInput() {
    return this._parquetRowGroupLength;
  }

  // parquet_version - computed: true, optional: true, required: false
  private _parquetVersion?: string; 
  public get parquetVersion() {
    return this.getStringAttribute('parquet_version');
  }
  public set parquetVersion(value: string) {
    this._parquetVersion = value;
  }
  public resetParquetVersion() {
    this._parquetVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get parquetVersionInput() {
    return this._parquetVersion;
  }

  // partition_expr - computed: true, optional: true, required: false
  private _partitionExpr?: string; 
  public get partitionExpr() {
    return this.getStringAttribute('partition_expr');
  }
  public set partitionExpr(value: string) {
    this._partitionExpr = value;
  }
  public resetPartitionExpr() {
    this._partitionExpr = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get partitionExprInput() {
    return this._partitionExpr;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // remove_empty_dirs - computed: true, optional: true, required: false
  private _removeEmptyDirs?: boolean | cdktf.IResolvable; 
  public get removeEmptyDirs() {
    return this.getBooleanAttribute('remove_empty_dirs');
  }
  public set removeEmptyDirs(value: boolean | cdktf.IResolvable) {
    this._removeEmptyDirs = value;
  }
  public resetRemoveEmptyDirs() {
    this._removeEmptyDirs = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get removeEmptyDirsInput() {
    return this._removeEmptyDirs;
  }

  // should_log_invalid_rows - computed: false, optional: true, required: false
  private _shouldLogInvalidRows?: boolean | cdktf.IResolvable; 
  public get shouldLogInvalidRows() {
    return this.getBooleanAttribute('should_log_invalid_rows');
  }
  public set shouldLogInvalidRows(value: boolean | cdktf.IResolvable) {
    this._shouldLogInvalidRows = value;
  }
  public resetShouldLogInvalidRows() {
    this._shouldLogInvalidRows = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get shouldLogInvalidRowsInput() {
    return this._shouldLogInvalidRows;
  }

  // stage_path - computed: false, optional: true, required: false
  private _stagePath?: string; 
  public get stagePath() {
    return this.getStringAttribute('stage_path');
  }
  public set stagePath(value: string) {
    this._stagePath = value;
  }
  public resetStagePath() {
    this._stagePath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get stagePathInput() {
    return this._stagePath;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // system_fields - computed: true, optional: true, required: false
  private _systemFields?: string[]; 
  public get systemFields() {
    return this.getListAttribute('system_fields');
  }
  public set systemFields(value: string[]) {
    this._systemFields = value;
  }
  public resetSystemFields() {
    this._systemFields = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get systemFieldsInput() {
    return this._systemFields;
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // write_high_water_mark - computed: true, optional: true, required: false
  private _writeHighWaterMark?: number; 
  public get writeHighWaterMark() {
    return this.getNumberAttribute('write_high_water_mark');
  }
  public set writeHighWaterMark(value: number) {
    this._writeHighWaterMark = value;
  }
  public resetWriteHighWaterMark() {
    this._writeHighWaterMark = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get writeHighWaterMarkInput() {
    return this._writeHighWaterMark;
  }
}
export interface DestinationOutputGoogleChronicleCustomLabels {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#key Destination#key}
  */
  readonly key: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#value Destination#value}
  */
  readonly value: string;
}

export function destinationOutputGoogleChronicleCustomLabelsToTerraform(struct?: DestinationOutputGoogleChronicleCustomLabels | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function destinationOutputGoogleChronicleCustomLabelsToHclTerraform(struct?: DestinationOutputGoogleChronicleCustomLabels | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputGoogleChronicleCustomLabelsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DestinationOutputGoogleChronicleCustomLabels | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputGoogleChronicleCustomLabels | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._value = value.value;
    }
  }

  // key - computed: false, optional: false, required: true
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DestinationOutputGoogleChronicleCustomLabelsList extends cdktf.ComplexList {
  public internalValue? : DestinationOutputGoogleChronicleCustomLabels[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DestinationOutputGoogleChronicleCustomLabelsOutputReference {
    return new DestinationOutputGoogleChronicleCustomLabelsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DestinationOutputGoogleChronicleExtraHttpHeaders {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#name Destination#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#value Destination#value}
  */
  readonly value: string;
}

export function destinationOutputGoogleChronicleExtraHttpHeadersToTerraform(struct?: DestinationOutputGoogleChronicleExtraHttpHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function destinationOutputGoogleChronicleExtraHttpHeadersToHclTerraform(struct?: DestinationOutputGoogleChronicleExtraHttpHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputGoogleChronicleExtraHttpHeadersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DestinationOutputGoogleChronicleExtraHttpHeaders | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputGoogleChronicleExtraHttpHeaders | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DestinationOutputGoogleChronicleExtraHttpHeadersList extends cdktf.ComplexList {
  public internalValue? : DestinationOutputGoogleChronicleExtraHttpHeaders[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DestinationOutputGoogleChronicleExtraHttpHeadersOutputReference {
    return new DestinationOutputGoogleChronicleExtraHttpHeadersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DestinationOutputGoogleChronicleExtraLogTypes {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#description Destination#description}
  */
  readonly description?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#log_type Destination#log_type}
  */
  readonly logType: string;
}

export function destinationOutputGoogleChronicleExtraLogTypesToTerraform(struct?: DestinationOutputGoogleChronicleExtraLogTypes | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    description: cdktf.stringToTerraform(struct!.description),
    log_type: cdktf.stringToTerraform(struct!.logType),
  }
}


export function destinationOutputGoogleChronicleExtraLogTypesToHclTerraform(struct?: DestinationOutputGoogleChronicleExtraLogTypes | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    log_type: {
      value: cdktf.stringToHclTerraform(struct!.logType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputGoogleChronicleExtraLogTypesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DestinationOutputGoogleChronicleExtraLogTypes | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._logType !== undefined) {
      hasAnyValues = true;
      internalValueResult.logType = this._logType;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputGoogleChronicleExtraLogTypes | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._description = undefined;
      this._logType = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._description = value.description;
      this._logType = value.logType;
    }
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // log_type - computed: false, optional: false, required: true
  private _logType?: string; 
  public get logType() {
    return this.getStringAttribute('log_type');
  }
  public set logType(value: string) {
    this._logType = value;
  }
  // Temporarily expose input value. Use with caution.
  public get logTypeInput() {
    return this._logType;
  }
}

export class DestinationOutputGoogleChronicleExtraLogTypesList extends cdktf.ComplexList {
  public internalValue? : DestinationOutputGoogleChronicleExtraLogTypes[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DestinationOutputGoogleChronicleExtraLogTypesOutputReference {
    return new DestinationOutputGoogleChronicleExtraLogTypesOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DestinationOutputGoogleChroniclePqControls {
}

export function destinationOutputGoogleChroniclePqControlsToTerraform(struct?: DestinationOutputGoogleChroniclePqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function destinationOutputGoogleChroniclePqControlsToHclTerraform(struct?: DestinationOutputGoogleChroniclePqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class DestinationOutputGoogleChroniclePqControlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DestinationOutputGoogleChroniclePqControls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputGoogleChroniclePqControls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface DestinationOutputGoogleChronicleResponseRetrySettings {
  /**
  * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc. Default: 2
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#backoff_rate Destination#backoff_rate}
  */
  readonly backoffRate?: number;
  /**
  * The HTTP response status code that will trigger retries
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#http_status Destination#http_status}
  */
  readonly httpStatus: number;
  /**
  * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes). Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#initial_backoff Destination#initial_backoff}
  */
  readonly initialBackoff?: number;
  /**
  * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds). Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#max_backoff Destination#max_backoff}
  */
  readonly maxBackoff?: number;
}

export function destinationOutputGoogleChronicleResponseRetrySettingsToTerraform(struct?: DestinationOutputGoogleChronicleResponseRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    backoff_rate: cdktf.numberToTerraform(struct!.backoffRate),
    http_status: cdktf.numberToTerraform(struct!.httpStatus),
    initial_backoff: cdktf.numberToTerraform(struct!.initialBackoff),
    max_backoff: cdktf.numberToTerraform(struct!.maxBackoff),
  }
}


export function destinationOutputGoogleChronicleResponseRetrySettingsToHclTerraform(struct?: DestinationOutputGoogleChronicleResponseRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    backoff_rate: {
      value: cdktf.numberToHclTerraform(struct!.backoffRate),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    http_status: {
      value: cdktf.numberToHclTerraform(struct!.httpStatus),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    initial_backoff: {
      value: cdktf.numberToHclTerraform(struct!.initialBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_backoff: {
      value: cdktf.numberToHclTerraform(struct!.maxBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputGoogleChronicleResponseRetrySettingsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DestinationOutputGoogleChronicleResponseRetrySettings | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._backoffRate !== undefined) {
      hasAnyValues = true;
      internalValueResult.backoffRate = this._backoffRate;
    }
    if (this._httpStatus !== undefined) {
      hasAnyValues = true;
      internalValueResult.httpStatus = this._httpStatus;
    }
    if (this._initialBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.initialBackoff = this._initialBackoff;
    }
    if (this._maxBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBackoff = this._maxBackoff;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputGoogleChronicleResponseRetrySettings | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._backoffRate = undefined;
      this._httpStatus = undefined;
      this._initialBackoff = undefined;
      this._maxBackoff = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._backoffRate = value.backoffRate;
      this._httpStatus = value.httpStatus;
      this._initialBackoff = value.initialBackoff;
      this._maxBackoff = value.maxBackoff;
    }
  }

  // backoff_rate - computed: true, optional: true, required: false
  private _backoffRate?: number; 
  public get backoffRate() {
    return this.getNumberAttribute('backoff_rate');
  }
  public set backoffRate(value: number) {
    this._backoffRate = value;
  }
  public resetBackoffRate() {
    this._backoffRate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get backoffRateInput() {
    return this._backoffRate;
  }

  // http_status - computed: false, optional: false, required: true
  private _httpStatus?: number; 
  public get httpStatus() {
    return this.getNumberAttribute('http_status');
  }
  public set httpStatus(value: number) {
    this._httpStatus = value;
  }
  // Temporarily expose input value. Use with caution.
  public get httpStatusInput() {
    return this._httpStatus;
  }

  // initial_backoff - computed: true, optional: true, required: false
  private _initialBackoff?: number; 
  public get initialBackoff() {
    return this.getNumberAttribute('initial_backoff');
  }
  public set initialBackoff(value: number) {
    this._initialBackoff = value;
  }
  public resetInitialBackoff() {
    this._initialBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get initialBackoffInput() {
    return this._initialBackoff;
  }

  // max_backoff - computed: true, optional: true, required: false
  private _maxBackoff?: number; 
  public get maxBackoff() {
    return this.getNumberAttribute('max_backoff');
  }
  public set maxBackoff(value: number) {
    this._maxBackoff = value;
  }
  public resetMaxBackoff() {
    this._maxBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBackoffInput() {
    return this._maxBackoff;
  }
}

export class DestinationOutputGoogleChronicleResponseRetrySettingsList extends cdktf.ComplexList {
  public internalValue? : DestinationOutputGoogleChronicleResponseRetrySettings[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DestinationOutputGoogleChronicleResponseRetrySettingsOutputReference {
    return new DestinationOutputGoogleChronicleResponseRetrySettingsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DestinationOutputGoogleChronicleTimeoutRetrySettings {
  /**
  * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc. Default: 2
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#backoff_rate Destination#backoff_rate}
  */
  readonly backoffRate?: number;
  /**
  * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes). Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#initial_backoff Destination#initial_backoff}
  */
  readonly initialBackoff?: number;
  /**
  * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds). Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#max_backoff Destination#max_backoff}
  */
  readonly maxBackoff?: number;
  /**
  * Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#timeout_retry Destination#timeout_retry}
  */
  readonly timeoutRetry?: boolean | cdktf.IResolvable;
}

export function destinationOutputGoogleChronicleTimeoutRetrySettingsToTerraform(struct?: DestinationOutputGoogleChronicleTimeoutRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    backoff_rate: cdktf.numberToTerraform(struct!.backoffRate),
    initial_backoff: cdktf.numberToTerraform(struct!.initialBackoff),
    max_backoff: cdktf.numberToTerraform(struct!.maxBackoff),
    timeout_retry: cdktf.booleanToTerraform(struct!.timeoutRetry),
  }
}


export function destinationOutputGoogleChronicleTimeoutRetrySettingsToHclTerraform(struct?: DestinationOutputGoogleChronicleTimeoutRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    backoff_rate: {
      value: cdktf.numberToHclTerraform(struct!.backoffRate),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    initial_backoff: {
      value: cdktf.numberToHclTerraform(struct!.initialBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_backoff: {
      value: cdktf.numberToHclTerraform(struct!.maxBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    timeout_retry: {
      value: cdktf.booleanToHclTerraform(struct!.timeoutRetry),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputGoogleChronicleTimeoutRetrySettingsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DestinationOutputGoogleChronicleTimeoutRetrySettings | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._backoffRate !== undefined) {
      hasAnyValues = true;
      internalValueResult.backoffRate = this._backoffRate;
    }
    if (this._initialBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.initialBackoff = this._initialBackoff;
    }
    if (this._maxBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBackoff = this._maxBackoff;
    }
    if (this._timeoutRetry !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutRetry = this._timeoutRetry;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputGoogleChronicleTimeoutRetrySettings | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._backoffRate = undefined;
      this._initialBackoff = undefined;
      this._maxBackoff = undefined;
      this._timeoutRetry = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._backoffRate = value.backoffRate;
      this._initialBackoff = value.initialBackoff;
      this._maxBackoff = value.maxBackoff;
      this._timeoutRetry = value.timeoutRetry;
    }
  }

  // backoff_rate - computed: true, optional: true, required: false
  private _backoffRate?: number; 
  public get backoffRate() {
    return this.getNumberAttribute('backoff_rate');
  }
  public set backoffRate(value: number) {
    this._backoffRate = value;
  }
  public resetBackoffRate() {
    this._backoffRate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get backoffRateInput() {
    return this._backoffRate;
  }

  // initial_backoff - computed: true, optional: true, required: false
  private _initialBackoff?: number; 
  public get initialBackoff() {
    return this.getNumberAttribute('initial_backoff');
  }
  public set initialBackoff(value: number) {
    this._initialBackoff = value;
  }
  public resetInitialBackoff() {
    this._initialBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get initialBackoffInput() {
    return this._initialBackoff;
  }

  // max_backoff - computed: true, optional: true, required: false
  private _maxBackoff?: number; 
  public get maxBackoff() {
    return this.getNumberAttribute('max_backoff');
  }
  public set maxBackoff(value: number) {
    this._maxBackoff = value;
  }
  public resetMaxBackoff() {
    this._maxBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBackoffInput() {
    return this._maxBackoff;
  }

  // timeout_retry - computed: true, optional: true, required: false
  private _timeoutRetry?: boolean | cdktf.IResolvable; 
  public get timeoutRetry() {
    return this.getBooleanAttribute('timeout_retry');
  }
  public set timeoutRetry(value: boolean | cdktf.IResolvable) {
    this._timeoutRetry = value;
  }
  public resetTimeoutRetry() {
    this._timeoutRetry = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutRetryInput() {
    return this._timeoutRetry;
  }
}
export interface DestinationOutputGoogleChronicle {
  /**
  * Organization's API key in Google SecOps
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#api_key Destination#api_key}
  */
  readonly apiKey?: string;
  /**
  * Select or create a stored text secret
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#api_key_secret Destination#api_key_secret}
  */
  readonly apiKeySecret?: string;
  /**
  * Default: "v1"; must be one of ["v1", "v2"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#api_version Destination#api_version}
  */
  readonly apiVersion?: string;
  /**
  * Default: "serviceAccount"; must be one of ["manual", "secret", "serviceAccount", "serviceAccountSecret"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#authentication_method Destination#authentication_method}
  */
  readonly authenticationMethod?: string;
  /**
  * Compress the payload body before sending. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#compress Destination#compress}
  */
  readonly compress?: boolean | cdktf.IResolvable;
  /**
  * Maximum number of ongoing requests before blocking. Default: 5
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#concurrency Destination#concurrency}
  */
  readonly concurrency?: number;
  /**
  * Custom labels to be added to every batch
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#custom_labels Destination#custom_labels}
  */
  readonly customLabels?: DestinationOutputGoogleChronicleCustomLabels[] | cdktf.IResolvable;
  /**
  * Unique identifier (UUID) corresponding to a particular SecOps instance. Provided by your SecOps representative.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#customer_id Destination#customer_id}
  */
  readonly customerId?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#description Destination#description}
  */
  readonly description?: string;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#environment Destination#environment}
  */
  readonly environment?: string;
  /**
  * Headers to add to all events
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#extra_http_headers Destination#extra_http_headers}
  */
  readonly extraHttpHeaders?: DestinationOutputGoogleChronicleExtraHttpHeaders[] | cdktf.IResolvable;
  /**
  * Custom log types. If the value "Custom" is selected in the setting "Default log type" above, the first custom log type in this table will be automatically selected as default log type.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#extra_log_types Destination#extra_log_types}
  */
  readonly extraLogTypes?: DestinationOutputGoogleChronicleExtraLogTypes[] | cdktf.IResolvable;
  /**
  * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below. Default: "none"; must be one of ["payload", "payloadAndHeaders", "none"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#failed_request_logging_mode Destination#failed_request_logging_mode}
  */
  readonly failedRequestLoggingMode?: string;
  /**
  * Maximum time between requests. Small values could cause the payload size to be smaller than the configured Body size limit. Default: 1
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#flush_period_sec Destination#flush_period_sec}
  */
  readonly flushPeriodSec?: number;
  /**
  * Unique ID for this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#id Destination#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * Default: "unstructured"; must be one of ["unstructured", "udm"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#log_format_type Destination#log_format_type}
  */
  readonly logFormatType?: string;
  /**
  * Name of the event field that contains the log text to send. If not specified, Stream sends a JSON representation of the whole event.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#log_text_field Destination#log_text_field}
  */
  readonly logTextField?: string;
  /**
  * Default log type value to send to SecOps. Can be overwritten by event field __logType.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#log_type Destination#log_type}
  */
  readonly logType?: string;
  /**
  * Maximum number of events to include in the request body. Default is 0 (unlimited). Default: 0
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#max_payload_events Destination#max_payload_events}
  */
  readonly maxPayloadEvents?: number;
  /**
  * Maximum size, in KB, of the request body. Default: 1024
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#max_payload_size_kb Destination#max_payload_size_kb}
  */
  readonly maxPayloadSizeKb?: number;
  /**
  * User-configured environment namespace to identify the data domain the logs originated from. Use namespace as a tag to identify the appropriate data domain for indexing and enrichment functionality. Can be overwritten by event field __namespace.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#namespace Destination#namespace}
  */
  readonly namespace?: string;
  /**
  * How to handle events when all receivers are exerting backpressure. Default: "block"; must be one of ["block", "drop", "queue"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#on_backpressure Destination#on_backpressure}
  */
  readonly onBackpressure?: string;
  /**
  * Pipeline to process data before sending out to this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pipeline Destination#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pq_compress Destination#pq_compress}
  */
  readonly pqCompress?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pq_controls Destination#pq_controls}
  */
  readonly pqControls?: DestinationOutputGoogleChroniclePqControls;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.). Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pq_max_file_size Destination#pq_max_file_size}
  */
  readonly pqMaxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pq_max_size Destination#pq_max_size}
  */
  readonly pqMaxSize?: string;
  /**
  * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem. Default: "error"; must be one of ["error", "backpressure", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pq_mode Destination#pq_mode}
  */
  readonly pqMode?: string;
  /**
  * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged. Default: "block"; must be one of ["block", "drop"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pq_on_backpressure Destination#pq_on_backpressure}
  */
  readonly pqOnBackpressure?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pq_path Destination#pq_path}
  */
  readonly pqPath?: string;
  /**
  * Regional endpoint to send events to
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#region Destination#region}
  */
  readonly region?: string;
  /**
  * Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's). 
  *         Enabled by default. When this setting is also present in TLS Settings (Client Side), 
  *         that value will take precedence.
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#reject_unauthorized Destination#reject_unauthorized}
  */
  readonly rejectUnauthorized?: boolean | cdktf.IResolvable;
  /**
  * Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#response_honor_retry_after_header Destination#response_honor_retry_after_header}
  */
  readonly responseHonorRetryAfterHeader?: boolean | cdktf.IResolvable;
  /**
  * Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#response_retry_settings Destination#response_retry_settings}
  */
  readonly responseRetrySettings?: DestinationOutputGoogleChronicleResponseRetrySettings[] | cdktf.IResolvable;
  /**
  * List of headers that are safe to log in plain text. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#safe_headers Destination#safe_headers}
  */
  readonly safeHeaders?: string[];
  /**
  * Contents of service account credentials (JSON keys) file downloaded from Google Cloud. To upload a file, click the upload button at this field's upper right.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#service_account_credentials Destination#service_account_credentials}
  */
  readonly serviceAccountCredentials?: string;
  /**
  * Select or create a stored text secret
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#service_account_credentials_secret Destination#service_account_credentials_secret}
  */
  readonly serviceAccountCredentialsSecret?: string;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#streamtags Destination#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Fields to automatically add to events, such as cribl_pipe. Supports wildcards. Default: ["cribl_pipe"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#system_fields Destination#system_fields}
  */
  readonly systemFields?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#timeout_retry_settings Destination#timeout_retry_settings}
  */
  readonly timeoutRetrySettings?: DestinationOutputGoogleChronicleTimeoutRetrySettings;
  /**
  * Amount of time, in seconds, to wait for a request to complete before canceling it. Default: 90
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#timeout_sec Destination#timeout_sec}
  */
  readonly timeoutSec?: number;
  /**
  * Maximum total size of the batches waiting to be sent. If left blank, defaults to 5 times the max body size (if set). If 0, no limit is enforced.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#total_memory_limit_kb Destination#total_memory_limit_kb}
  */
  readonly totalMemoryLimitKb?: number;
  /**
  * must be "google_chronicle"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#type Destination#type}
  */
  readonly type: string;
  /**
  * Enable round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#use_round_robin_dns Destination#use_round_robin_dns}
  */
  readonly useRoundRobinDns?: boolean | cdktf.IResolvable;
}

export function destinationOutputGoogleChronicleToTerraform(struct?: DestinationOutputGoogleChronicle | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    api_key: cdktf.stringToTerraform(struct!.apiKey),
    api_key_secret: cdktf.stringToTerraform(struct!.apiKeySecret),
    api_version: cdktf.stringToTerraform(struct!.apiVersion),
    authentication_method: cdktf.stringToTerraform(struct!.authenticationMethod),
    compress: cdktf.booleanToTerraform(struct!.compress),
    concurrency: cdktf.numberToTerraform(struct!.concurrency),
    custom_labels: cdktf.listMapper(destinationOutputGoogleChronicleCustomLabelsToTerraform, false)(struct!.customLabels),
    customer_id: cdktf.stringToTerraform(struct!.customerId),
    description: cdktf.stringToTerraform(struct!.description),
    environment: cdktf.stringToTerraform(struct!.environment),
    extra_http_headers: cdktf.listMapper(destinationOutputGoogleChronicleExtraHttpHeadersToTerraform, false)(struct!.extraHttpHeaders),
    extra_log_types: cdktf.listMapper(destinationOutputGoogleChronicleExtraLogTypesToTerraform, false)(struct!.extraLogTypes),
    failed_request_logging_mode: cdktf.stringToTerraform(struct!.failedRequestLoggingMode),
    flush_period_sec: cdktf.numberToTerraform(struct!.flushPeriodSec),
    id: cdktf.stringToTerraform(struct!.id),
    log_format_type: cdktf.stringToTerraform(struct!.logFormatType),
    log_text_field: cdktf.stringToTerraform(struct!.logTextField),
    log_type: cdktf.stringToTerraform(struct!.logType),
    max_payload_events: cdktf.numberToTerraform(struct!.maxPayloadEvents),
    max_payload_size_kb: cdktf.numberToTerraform(struct!.maxPayloadSizeKb),
    namespace: cdktf.stringToTerraform(struct!.namespace),
    on_backpressure: cdktf.stringToTerraform(struct!.onBackpressure),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    pq_compress: cdktf.stringToTerraform(struct!.pqCompress),
    pq_controls: destinationOutputGoogleChroniclePqControlsToTerraform(struct!.pqControls),
    pq_max_file_size: cdktf.stringToTerraform(struct!.pqMaxFileSize),
    pq_max_size: cdktf.stringToTerraform(struct!.pqMaxSize),
    pq_mode: cdktf.stringToTerraform(struct!.pqMode),
    pq_on_backpressure: cdktf.stringToTerraform(struct!.pqOnBackpressure),
    pq_path: cdktf.stringToTerraform(struct!.pqPath),
    region: cdktf.stringToTerraform(struct!.region),
    reject_unauthorized: cdktf.booleanToTerraform(struct!.rejectUnauthorized),
    response_honor_retry_after_header: cdktf.booleanToTerraform(struct!.responseHonorRetryAfterHeader),
    response_retry_settings: cdktf.listMapper(destinationOutputGoogleChronicleResponseRetrySettingsToTerraform, false)(struct!.responseRetrySettings),
    safe_headers: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.safeHeaders),
    service_account_credentials: cdktf.stringToTerraform(struct!.serviceAccountCredentials),
    service_account_credentials_secret: cdktf.stringToTerraform(struct!.serviceAccountCredentialsSecret),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    system_fields: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.systemFields),
    timeout_retry_settings: destinationOutputGoogleChronicleTimeoutRetrySettingsToTerraform(struct!.timeoutRetrySettings),
    timeout_sec: cdktf.numberToTerraform(struct!.timeoutSec),
    total_memory_limit_kb: cdktf.numberToTerraform(struct!.totalMemoryLimitKb),
    type: cdktf.stringToTerraform(struct!.type),
    use_round_robin_dns: cdktf.booleanToTerraform(struct!.useRoundRobinDns),
  }
}


export function destinationOutputGoogleChronicleToHclTerraform(struct?: DestinationOutputGoogleChronicle | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    api_key: {
      value: cdktf.stringToHclTerraform(struct!.apiKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    api_key_secret: {
      value: cdktf.stringToHclTerraform(struct!.apiKeySecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    api_version: {
      value: cdktf.stringToHclTerraform(struct!.apiVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    authentication_method: {
      value: cdktf.stringToHclTerraform(struct!.authenticationMethod),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    compress: {
      value: cdktf.booleanToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    concurrency: {
      value: cdktf.numberToHclTerraform(struct!.concurrency),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    custom_labels: {
      value: cdktf.listMapperHcl(destinationOutputGoogleChronicleCustomLabelsToHclTerraform, false)(struct!.customLabels),
      isBlock: true,
      type: "list",
      storageClassType: "DestinationOutputGoogleChronicleCustomLabelsList",
    },
    customer_id: {
      value: cdktf.stringToHclTerraform(struct!.customerId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    extra_http_headers: {
      value: cdktf.listMapperHcl(destinationOutputGoogleChronicleExtraHttpHeadersToHclTerraform, false)(struct!.extraHttpHeaders),
      isBlock: true,
      type: "list",
      storageClassType: "DestinationOutputGoogleChronicleExtraHttpHeadersList",
    },
    extra_log_types: {
      value: cdktf.listMapperHcl(destinationOutputGoogleChronicleExtraLogTypesToHclTerraform, false)(struct!.extraLogTypes),
      isBlock: true,
      type: "list",
      storageClassType: "DestinationOutputGoogleChronicleExtraLogTypesList",
    },
    failed_request_logging_mode: {
      value: cdktf.stringToHclTerraform(struct!.failedRequestLoggingMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    flush_period_sec: {
      value: cdktf.numberToHclTerraform(struct!.flushPeriodSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    log_format_type: {
      value: cdktf.stringToHclTerraform(struct!.logFormatType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    log_text_field: {
      value: cdktf.stringToHclTerraform(struct!.logTextField),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    log_type: {
      value: cdktf.stringToHclTerraform(struct!.logType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_payload_events: {
      value: cdktf.numberToHclTerraform(struct!.maxPayloadEvents),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_payload_size_kb: {
      value: cdktf.numberToHclTerraform(struct!.maxPayloadSizeKb),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    namespace: {
      value: cdktf.stringToHclTerraform(struct!.namespace),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.onBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_compress: {
      value: cdktf.stringToHclTerraform(struct!.pqCompress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_controls: {
      value: destinationOutputGoogleChroniclePqControlsToHclTerraform(struct!.pqControls),
      isBlock: true,
      type: "struct",
      storageClassType: "DestinationOutputGoogleChroniclePqControls",
    },
    pq_max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_max_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_mode: {
      value: cdktf.stringToHclTerraform(struct!.pqMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.pqOnBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_path: {
      value: cdktf.stringToHclTerraform(struct!.pqPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    region: {
      value: cdktf.stringToHclTerraform(struct!.region),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reject_unauthorized: {
      value: cdktf.booleanToHclTerraform(struct!.rejectUnauthorized),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    response_honor_retry_after_header: {
      value: cdktf.booleanToHclTerraform(struct!.responseHonorRetryAfterHeader),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    response_retry_settings: {
      value: cdktf.listMapperHcl(destinationOutputGoogleChronicleResponseRetrySettingsToHclTerraform, false)(struct!.responseRetrySettings),
      isBlock: true,
      type: "list",
      storageClassType: "DestinationOutputGoogleChronicleResponseRetrySettingsList",
    },
    safe_headers: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.safeHeaders),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    service_account_credentials: {
      value: cdktf.stringToHclTerraform(struct!.serviceAccountCredentials),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    service_account_credentials_secret: {
      value: cdktf.stringToHclTerraform(struct!.serviceAccountCredentialsSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    system_fields: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.systemFields),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    timeout_retry_settings: {
      value: destinationOutputGoogleChronicleTimeoutRetrySettingsToHclTerraform(struct!.timeoutRetrySettings),
      isBlock: true,
      type: "struct",
      storageClassType: "DestinationOutputGoogleChronicleTimeoutRetrySettings",
    },
    timeout_sec: {
      value: cdktf.numberToHclTerraform(struct!.timeoutSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    total_memory_limit_kb: {
      value: cdktf.numberToHclTerraform(struct!.totalMemoryLimitKb),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    use_round_robin_dns: {
      value: cdktf.booleanToHclTerraform(struct!.useRoundRobinDns),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputGoogleChronicleOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DestinationOutputGoogleChronicle | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._apiKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.apiKey = this._apiKey;
    }
    if (this._apiKeySecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.apiKeySecret = this._apiKeySecret;
    }
    if (this._apiVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.apiVersion = this._apiVersion;
    }
    if (this._authenticationMethod !== undefined) {
      hasAnyValues = true;
      internalValueResult.authenticationMethod = this._authenticationMethod;
    }
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._concurrency !== undefined) {
      hasAnyValues = true;
      internalValueResult.concurrency = this._concurrency;
    }
    if (this._customLabels?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.customLabels = this._customLabels?.internalValue;
    }
    if (this._customerId !== undefined) {
      hasAnyValues = true;
      internalValueResult.customerId = this._customerId;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._extraHttpHeaders?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.extraHttpHeaders = this._extraHttpHeaders?.internalValue;
    }
    if (this._extraLogTypes?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.extraLogTypes = this._extraLogTypes?.internalValue;
    }
    if (this._failedRequestLoggingMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.failedRequestLoggingMode = this._failedRequestLoggingMode;
    }
    if (this._flushPeriodSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.flushPeriodSec = this._flushPeriodSec;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._logFormatType !== undefined) {
      hasAnyValues = true;
      internalValueResult.logFormatType = this._logFormatType;
    }
    if (this._logTextField !== undefined) {
      hasAnyValues = true;
      internalValueResult.logTextField = this._logTextField;
    }
    if (this._logType !== undefined) {
      hasAnyValues = true;
      internalValueResult.logType = this._logType;
    }
    if (this._maxPayloadEvents !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxPayloadEvents = this._maxPayloadEvents;
    }
    if (this._maxPayloadSizeKb !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxPayloadSizeKb = this._maxPayloadSizeKb;
    }
    if (this._namespace !== undefined) {
      hasAnyValues = true;
      internalValueResult.namespace = this._namespace;
    }
    if (this._onBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.onBackpressure = this._onBackpressure;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._pqCompress !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqCompress = this._pqCompress;
    }
    if (this._pqControls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqControls = this._pqControls?.internalValue;
    }
    if (this._pqMaxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxFileSize = this._pqMaxFileSize;
    }
    if (this._pqMaxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxSize = this._pqMaxSize;
    }
    if (this._pqMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMode = this._pqMode;
    }
    if (this._pqOnBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqOnBackpressure = this._pqOnBackpressure;
    }
    if (this._pqPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqPath = this._pqPath;
    }
    if (this._region !== undefined) {
      hasAnyValues = true;
      internalValueResult.region = this._region;
    }
    if (this._rejectUnauthorized !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectUnauthorized = this._rejectUnauthorized;
    }
    if (this._responseHonorRetryAfterHeader !== undefined) {
      hasAnyValues = true;
      internalValueResult.responseHonorRetryAfterHeader = this._responseHonorRetryAfterHeader;
    }
    if (this._responseRetrySettings?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.responseRetrySettings = this._responseRetrySettings?.internalValue;
    }
    if (this._safeHeaders !== undefined) {
      hasAnyValues = true;
      internalValueResult.safeHeaders = this._safeHeaders;
    }
    if (this._serviceAccountCredentials !== undefined) {
      hasAnyValues = true;
      internalValueResult.serviceAccountCredentials = this._serviceAccountCredentials;
    }
    if (this._serviceAccountCredentialsSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.serviceAccountCredentialsSecret = this._serviceAccountCredentialsSecret;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._systemFields !== undefined) {
      hasAnyValues = true;
      internalValueResult.systemFields = this._systemFields;
    }
    if (this._timeoutRetrySettings?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutRetrySettings = this._timeoutRetrySettings?.internalValue;
    }
    if (this._timeoutSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutSec = this._timeoutSec;
    }
    if (this._totalMemoryLimitKb !== undefined) {
      hasAnyValues = true;
      internalValueResult.totalMemoryLimitKb = this._totalMemoryLimitKb;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._useRoundRobinDns !== undefined) {
      hasAnyValues = true;
      internalValueResult.useRoundRobinDns = this._useRoundRobinDns;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputGoogleChronicle | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._apiKey = undefined;
      this._apiKeySecret = undefined;
      this._apiVersion = undefined;
      this._authenticationMethod = undefined;
      this._compress = undefined;
      this._concurrency = undefined;
      this._customLabels.internalValue = undefined;
      this._customerId = undefined;
      this._description = undefined;
      this._environment = undefined;
      this._extraHttpHeaders.internalValue = undefined;
      this._extraLogTypes.internalValue = undefined;
      this._failedRequestLoggingMode = undefined;
      this._flushPeriodSec = undefined;
      this._id = undefined;
      this._logFormatType = undefined;
      this._logTextField = undefined;
      this._logType = undefined;
      this._maxPayloadEvents = undefined;
      this._maxPayloadSizeKb = undefined;
      this._namespace = undefined;
      this._onBackpressure = undefined;
      this._pipeline = undefined;
      this._pqCompress = undefined;
      this._pqControls.internalValue = undefined;
      this._pqMaxFileSize = undefined;
      this._pqMaxSize = undefined;
      this._pqMode = undefined;
      this._pqOnBackpressure = undefined;
      this._pqPath = undefined;
      this._region = undefined;
      this._rejectUnauthorized = undefined;
      this._responseHonorRetryAfterHeader = undefined;
      this._responseRetrySettings.internalValue = undefined;
      this._safeHeaders = undefined;
      this._serviceAccountCredentials = undefined;
      this._serviceAccountCredentialsSecret = undefined;
      this._streamtags = undefined;
      this._systemFields = undefined;
      this._timeoutRetrySettings.internalValue = undefined;
      this._timeoutSec = undefined;
      this._totalMemoryLimitKb = undefined;
      this._type = undefined;
      this._useRoundRobinDns = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._apiKey = value.apiKey;
      this._apiKeySecret = value.apiKeySecret;
      this._apiVersion = value.apiVersion;
      this._authenticationMethod = value.authenticationMethod;
      this._compress = value.compress;
      this._concurrency = value.concurrency;
      this._customLabels.internalValue = value.customLabels;
      this._customerId = value.customerId;
      this._description = value.description;
      this._environment = value.environment;
      this._extraHttpHeaders.internalValue = value.extraHttpHeaders;
      this._extraLogTypes.internalValue = value.extraLogTypes;
      this._failedRequestLoggingMode = value.failedRequestLoggingMode;
      this._flushPeriodSec = value.flushPeriodSec;
      this._id = value.id;
      this._logFormatType = value.logFormatType;
      this._logTextField = value.logTextField;
      this._logType = value.logType;
      this._maxPayloadEvents = value.maxPayloadEvents;
      this._maxPayloadSizeKb = value.maxPayloadSizeKb;
      this._namespace = value.namespace;
      this._onBackpressure = value.onBackpressure;
      this._pipeline = value.pipeline;
      this._pqCompress = value.pqCompress;
      this._pqControls.internalValue = value.pqControls;
      this._pqMaxFileSize = value.pqMaxFileSize;
      this._pqMaxSize = value.pqMaxSize;
      this._pqMode = value.pqMode;
      this._pqOnBackpressure = value.pqOnBackpressure;
      this._pqPath = value.pqPath;
      this._region = value.region;
      this._rejectUnauthorized = value.rejectUnauthorized;
      this._responseHonorRetryAfterHeader = value.responseHonorRetryAfterHeader;
      this._responseRetrySettings.internalValue = value.responseRetrySettings;
      this._safeHeaders = value.safeHeaders;
      this._serviceAccountCredentials = value.serviceAccountCredentials;
      this._serviceAccountCredentialsSecret = value.serviceAccountCredentialsSecret;
      this._streamtags = value.streamtags;
      this._systemFields = value.systemFields;
      this._timeoutRetrySettings.internalValue = value.timeoutRetrySettings;
      this._timeoutSec = value.timeoutSec;
      this._totalMemoryLimitKb = value.totalMemoryLimitKb;
      this._type = value.type;
      this._useRoundRobinDns = value.useRoundRobinDns;
    }
  }

  // api_key - computed: false, optional: true, required: false
  private _apiKey?: string; 
  public get apiKey() {
    return this.getStringAttribute('api_key');
  }
  public set apiKey(value: string) {
    this._apiKey = value;
  }
  public resetApiKey() {
    this._apiKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get apiKeyInput() {
    return this._apiKey;
  }

  // api_key_secret - computed: false, optional: true, required: false
  private _apiKeySecret?: string; 
  public get apiKeySecret() {
    return this.getStringAttribute('api_key_secret');
  }
  public set apiKeySecret(value: string) {
    this._apiKeySecret = value;
  }
  public resetApiKeySecret() {
    this._apiKeySecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get apiKeySecretInput() {
    return this._apiKeySecret;
  }

  // api_version - computed: true, optional: true, required: false
  private _apiVersion?: string; 
  public get apiVersion() {
    return this.getStringAttribute('api_version');
  }
  public set apiVersion(value: string) {
    this._apiVersion = value;
  }
  public resetApiVersion() {
    this._apiVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get apiVersionInput() {
    return this._apiVersion;
  }

  // authentication_method - computed: true, optional: true, required: false
  private _authenticationMethod?: string; 
  public get authenticationMethod() {
    return this.getStringAttribute('authentication_method');
  }
  public set authenticationMethod(value: string) {
    this._authenticationMethod = value;
  }
  public resetAuthenticationMethod() {
    this._authenticationMethod = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authenticationMethodInput() {
    return this._authenticationMethod;
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: boolean | cdktf.IResolvable; 
  public get compress() {
    return this.getBooleanAttribute('compress');
  }
  public set compress(value: boolean | cdktf.IResolvable) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // concurrency - computed: true, optional: true, required: false
  private _concurrency?: number; 
  public get concurrency() {
    return this.getNumberAttribute('concurrency');
  }
  public set concurrency(value: number) {
    this._concurrency = value;
  }
  public resetConcurrency() {
    this._concurrency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get concurrencyInput() {
    return this._concurrency;
  }

  // custom_labels - computed: false, optional: true, required: false
  private _customLabels = new DestinationOutputGoogleChronicleCustomLabelsList(this, "custom_labels", false);
  public get customLabels() {
    return this._customLabels;
  }
  public putCustomLabels(value: DestinationOutputGoogleChronicleCustomLabels[] | cdktf.IResolvable) {
    this._customLabels.internalValue = value;
  }
  public resetCustomLabels() {
    this._customLabels.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get customLabelsInput() {
    return this._customLabels.internalValue;
  }

  // customer_id - computed: false, optional: true, required: false
  private _customerId?: string; 
  public get customerId() {
    return this.getStringAttribute('customer_id');
  }
  public set customerId(value: string) {
    this._customerId = value;
  }
  public resetCustomerId() {
    this._customerId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get customerIdInput() {
    return this._customerId;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // extra_http_headers - computed: false, optional: true, required: false
  private _extraHttpHeaders = new DestinationOutputGoogleChronicleExtraHttpHeadersList(this, "extra_http_headers", false);
  public get extraHttpHeaders() {
    return this._extraHttpHeaders;
  }
  public putExtraHttpHeaders(value: DestinationOutputGoogleChronicleExtraHttpHeaders[] | cdktf.IResolvable) {
    this._extraHttpHeaders.internalValue = value;
  }
  public resetExtraHttpHeaders() {
    this._extraHttpHeaders.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get extraHttpHeadersInput() {
    return this._extraHttpHeaders.internalValue;
  }

  // extra_log_types - computed: false, optional: true, required: false
  private _extraLogTypes = new DestinationOutputGoogleChronicleExtraLogTypesList(this, "extra_log_types", false);
  public get extraLogTypes() {
    return this._extraLogTypes;
  }
  public putExtraLogTypes(value: DestinationOutputGoogleChronicleExtraLogTypes[] | cdktf.IResolvable) {
    this._extraLogTypes.internalValue = value;
  }
  public resetExtraLogTypes() {
    this._extraLogTypes.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get extraLogTypesInput() {
    return this._extraLogTypes.internalValue;
  }

  // failed_request_logging_mode - computed: true, optional: true, required: false
  private _failedRequestLoggingMode?: string; 
  public get failedRequestLoggingMode() {
    return this.getStringAttribute('failed_request_logging_mode');
  }
  public set failedRequestLoggingMode(value: string) {
    this._failedRequestLoggingMode = value;
  }
  public resetFailedRequestLoggingMode() {
    this._failedRequestLoggingMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get failedRequestLoggingModeInput() {
    return this._failedRequestLoggingMode;
  }

  // flush_period_sec - computed: true, optional: true, required: false
  private _flushPeriodSec?: number; 
  public get flushPeriodSec() {
    return this.getNumberAttribute('flush_period_sec');
  }
  public set flushPeriodSec(value: number) {
    this._flushPeriodSec = value;
  }
  public resetFlushPeriodSec() {
    this._flushPeriodSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get flushPeriodSecInput() {
    return this._flushPeriodSec;
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // log_format_type - computed: true, optional: true, required: false
  private _logFormatType?: string; 
  public get logFormatType() {
    return this.getStringAttribute('log_format_type');
  }
  public set logFormatType(value: string) {
    this._logFormatType = value;
  }
  public resetLogFormatType() {
    this._logFormatType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get logFormatTypeInput() {
    return this._logFormatType;
  }

  // log_text_field - computed: false, optional: true, required: false
  private _logTextField?: string; 
  public get logTextField() {
    return this.getStringAttribute('log_text_field');
  }
  public set logTextField(value: string) {
    this._logTextField = value;
  }
  public resetLogTextField() {
    this._logTextField = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get logTextFieldInput() {
    return this._logTextField;
  }

  // log_type - computed: false, optional: true, required: false
  private _logType?: string; 
  public get logType() {
    return this.getStringAttribute('log_type');
  }
  public set logType(value: string) {
    this._logType = value;
  }
  public resetLogType() {
    this._logType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get logTypeInput() {
    return this._logType;
  }

  // max_payload_events - computed: true, optional: true, required: false
  private _maxPayloadEvents?: number; 
  public get maxPayloadEvents() {
    return this.getNumberAttribute('max_payload_events');
  }
  public set maxPayloadEvents(value: number) {
    this._maxPayloadEvents = value;
  }
  public resetMaxPayloadEvents() {
    this._maxPayloadEvents = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxPayloadEventsInput() {
    return this._maxPayloadEvents;
  }

  // max_payload_size_kb - computed: true, optional: true, required: false
  private _maxPayloadSizeKb?: number; 
  public get maxPayloadSizeKb() {
    return this.getNumberAttribute('max_payload_size_kb');
  }
  public set maxPayloadSizeKb(value: number) {
    this._maxPayloadSizeKb = value;
  }
  public resetMaxPayloadSizeKb() {
    this._maxPayloadSizeKb = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxPayloadSizeKbInput() {
    return this._maxPayloadSizeKb;
  }

  // namespace - computed: false, optional: true, required: false
  private _namespace?: string; 
  public get namespace() {
    return this.getStringAttribute('namespace');
  }
  public set namespace(value: string) {
    this._namespace = value;
  }
  public resetNamespace() {
    this._namespace = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get namespaceInput() {
    return this._namespace;
  }

  // on_backpressure - computed: true, optional: true, required: false
  private _onBackpressure?: string; 
  public get onBackpressure() {
    return this.getStringAttribute('on_backpressure');
  }
  public set onBackpressure(value: string) {
    this._onBackpressure = value;
  }
  public resetOnBackpressure() {
    this._onBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get onBackpressureInput() {
    return this._onBackpressure;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // pq_compress - computed: true, optional: true, required: false
  private _pqCompress?: string; 
  public get pqCompress() {
    return this.getStringAttribute('pq_compress');
  }
  public set pqCompress(value: string) {
    this._pqCompress = value;
  }
  public resetPqCompress() {
    this._pqCompress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqCompressInput() {
    return this._pqCompress;
  }

  // pq_controls - computed: false, optional: true, required: false
  private _pqControls = new DestinationOutputGoogleChroniclePqControlsOutputReference(this, "pq_controls");
  public get pqControls() {
    return this._pqControls;
  }
  public putPqControls(value: DestinationOutputGoogleChroniclePqControls) {
    this._pqControls.internalValue = value;
  }
  public resetPqControls() {
    this._pqControls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqControlsInput() {
    return this._pqControls.internalValue;
  }

  // pq_max_file_size - computed: true, optional: true, required: false
  private _pqMaxFileSize?: string; 
  public get pqMaxFileSize() {
    return this.getStringAttribute('pq_max_file_size');
  }
  public set pqMaxFileSize(value: string) {
    this._pqMaxFileSize = value;
  }
  public resetPqMaxFileSize() {
    this._pqMaxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxFileSizeInput() {
    return this._pqMaxFileSize;
  }

  // pq_max_size - computed: true, optional: true, required: false
  private _pqMaxSize?: string; 
  public get pqMaxSize() {
    return this.getStringAttribute('pq_max_size');
  }
  public set pqMaxSize(value: string) {
    this._pqMaxSize = value;
  }
  public resetPqMaxSize() {
    this._pqMaxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxSizeInput() {
    return this._pqMaxSize;
  }

  // pq_mode - computed: true, optional: true, required: false
  private _pqMode?: string; 
  public get pqMode() {
    return this.getStringAttribute('pq_mode');
  }
  public set pqMode(value: string) {
    this._pqMode = value;
  }
  public resetPqMode() {
    this._pqMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqModeInput() {
    return this._pqMode;
  }

  // pq_on_backpressure - computed: true, optional: true, required: false
  private _pqOnBackpressure?: string; 
  public get pqOnBackpressure() {
    return this.getStringAttribute('pq_on_backpressure');
  }
  public set pqOnBackpressure(value: string) {
    this._pqOnBackpressure = value;
  }
  public resetPqOnBackpressure() {
    this._pqOnBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqOnBackpressureInput() {
    return this._pqOnBackpressure;
  }

  // pq_path - computed: true, optional: true, required: false
  private _pqPath?: string; 
  public get pqPath() {
    return this.getStringAttribute('pq_path');
  }
  public set pqPath(value: string) {
    this._pqPath = value;
  }
  public resetPqPath() {
    this._pqPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqPathInput() {
    return this._pqPath;
  }

  // region - computed: false, optional: true, required: false
  private _region?: string; 
  public get region() {
    return this.getStringAttribute('region');
  }
  public set region(value: string) {
    this._region = value;
  }
  public resetRegion() {
    this._region = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get regionInput() {
    return this._region;
  }

  // reject_unauthorized - computed: true, optional: true, required: false
  private _rejectUnauthorized?: boolean | cdktf.IResolvable; 
  public get rejectUnauthorized() {
    return this.getBooleanAttribute('reject_unauthorized');
  }
  public set rejectUnauthorized(value: boolean | cdktf.IResolvable) {
    this._rejectUnauthorized = value;
  }
  public resetRejectUnauthorized() {
    this._rejectUnauthorized = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectUnauthorizedInput() {
    return this._rejectUnauthorized;
  }

  // response_honor_retry_after_header - computed: true, optional: true, required: false
  private _responseHonorRetryAfterHeader?: boolean | cdktf.IResolvable; 
  public get responseHonorRetryAfterHeader() {
    return this.getBooleanAttribute('response_honor_retry_after_header');
  }
  public set responseHonorRetryAfterHeader(value: boolean | cdktf.IResolvable) {
    this._responseHonorRetryAfterHeader = value;
  }
  public resetResponseHonorRetryAfterHeader() {
    this._responseHonorRetryAfterHeader = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get responseHonorRetryAfterHeaderInput() {
    return this._responseHonorRetryAfterHeader;
  }

  // response_retry_settings - computed: false, optional: true, required: false
  private _responseRetrySettings = new DestinationOutputGoogleChronicleResponseRetrySettingsList(this, "response_retry_settings", false);
  public get responseRetrySettings() {
    return this._responseRetrySettings;
  }
  public putResponseRetrySettings(value: DestinationOutputGoogleChronicleResponseRetrySettings[] | cdktf.IResolvable) {
    this._responseRetrySettings.internalValue = value;
  }
  public resetResponseRetrySettings() {
    this._responseRetrySettings.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get responseRetrySettingsInput() {
    return this._responseRetrySettings.internalValue;
  }

  // safe_headers - computed: true, optional: true, required: false
  private _safeHeaders?: string[]; 
  public get safeHeaders() {
    return this.getListAttribute('safe_headers');
  }
  public set safeHeaders(value: string[]) {
    this._safeHeaders = value;
  }
  public resetSafeHeaders() {
    this._safeHeaders = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get safeHeadersInput() {
    return this._safeHeaders;
  }

  // service_account_credentials - computed: false, optional: true, required: false
  private _serviceAccountCredentials?: string; 
  public get serviceAccountCredentials() {
    return this.getStringAttribute('service_account_credentials');
  }
  public set serviceAccountCredentials(value: string) {
    this._serviceAccountCredentials = value;
  }
  public resetServiceAccountCredentials() {
    this._serviceAccountCredentials = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serviceAccountCredentialsInput() {
    return this._serviceAccountCredentials;
  }

  // service_account_credentials_secret - computed: false, optional: true, required: false
  private _serviceAccountCredentialsSecret?: string; 
  public get serviceAccountCredentialsSecret() {
    return this.getStringAttribute('service_account_credentials_secret');
  }
  public set serviceAccountCredentialsSecret(value: string) {
    this._serviceAccountCredentialsSecret = value;
  }
  public resetServiceAccountCredentialsSecret() {
    this._serviceAccountCredentialsSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serviceAccountCredentialsSecretInput() {
    return this._serviceAccountCredentialsSecret;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // system_fields - computed: true, optional: true, required: false
  private _systemFields?: string[]; 
  public get systemFields() {
    return this.getListAttribute('system_fields');
  }
  public set systemFields(value: string[]) {
    this._systemFields = value;
  }
  public resetSystemFields() {
    this._systemFields = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get systemFieldsInput() {
    return this._systemFields;
  }

  // timeout_retry_settings - computed: false, optional: true, required: false
  private _timeoutRetrySettings = new DestinationOutputGoogleChronicleTimeoutRetrySettingsOutputReference(this, "timeout_retry_settings");
  public get timeoutRetrySettings() {
    return this._timeoutRetrySettings;
  }
  public putTimeoutRetrySettings(value: DestinationOutputGoogleChronicleTimeoutRetrySettings) {
    this._timeoutRetrySettings.internalValue = value;
  }
  public resetTimeoutRetrySettings() {
    this._timeoutRetrySettings.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutRetrySettingsInput() {
    return this._timeoutRetrySettings.internalValue;
  }

  // timeout_sec - computed: true, optional: true, required: false
  private _timeoutSec?: number; 
  public get timeoutSec() {
    return this.getNumberAttribute('timeout_sec');
  }
  public set timeoutSec(value: number) {
    this._timeoutSec = value;
  }
  public resetTimeoutSec() {
    this._timeoutSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutSecInput() {
    return this._timeoutSec;
  }

  // total_memory_limit_kb - computed: false, optional: true, required: false
  private _totalMemoryLimitKb?: number; 
  public get totalMemoryLimitKb() {
    return this.getNumberAttribute('total_memory_limit_kb');
  }
  public set totalMemoryLimitKb(value: number) {
    this._totalMemoryLimitKb = value;
  }
  public resetTotalMemoryLimitKb() {
    this._totalMemoryLimitKb = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get totalMemoryLimitKbInput() {
    return this._totalMemoryLimitKb;
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // use_round_robin_dns - computed: true, optional: true, required: false
  private _useRoundRobinDns?: boolean | cdktf.IResolvable; 
  public get useRoundRobinDns() {
    return this.getBooleanAttribute('use_round_robin_dns');
  }
  public set useRoundRobinDns(value: boolean | cdktf.IResolvable) {
    this._useRoundRobinDns = value;
  }
  public resetUseRoundRobinDns() {
    this._useRoundRobinDns = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get useRoundRobinDnsInput() {
    return this._useRoundRobinDns;
  }
}
export interface DestinationOutputGoogleCloudLoggingLogLabels {
  /**
  * Label name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#label Destination#label}
  */
  readonly label: string;
  /**
  * JavaScript expression to compute the label's value.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#value_expression Destination#value_expression}
  */
  readonly valueExpression: string;
}

export function destinationOutputGoogleCloudLoggingLogLabelsToTerraform(struct?: DestinationOutputGoogleCloudLoggingLogLabels | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    label: cdktf.stringToTerraform(struct!.label),
    value_expression: cdktf.stringToTerraform(struct!.valueExpression),
  }
}


export function destinationOutputGoogleCloudLoggingLogLabelsToHclTerraform(struct?: DestinationOutputGoogleCloudLoggingLogLabels | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    label: {
      value: cdktf.stringToHclTerraform(struct!.label),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value_expression: {
      value: cdktf.stringToHclTerraform(struct!.valueExpression),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputGoogleCloudLoggingLogLabelsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DestinationOutputGoogleCloudLoggingLogLabels | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._label !== undefined) {
      hasAnyValues = true;
      internalValueResult.label = this._label;
    }
    if (this._valueExpression !== undefined) {
      hasAnyValues = true;
      internalValueResult.valueExpression = this._valueExpression;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputGoogleCloudLoggingLogLabels | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._label = undefined;
      this._valueExpression = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._label = value.label;
      this._valueExpression = value.valueExpression;
    }
  }

  // label - computed: false, optional: false, required: true
  private _label?: string; 
  public get label() {
    return this.getStringAttribute('label');
  }
  public set label(value: string) {
    this._label = value;
  }
  // Temporarily expose input value. Use with caution.
  public get labelInput() {
    return this._label;
  }

  // value_expression - computed: false, optional: false, required: true
  private _valueExpression?: string; 
  public get valueExpression() {
    return this.getStringAttribute('value_expression');
  }
  public set valueExpression(value: string) {
    this._valueExpression = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueExpressionInput() {
    return this._valueExpression;
  }
}

export class DestinationOutputGoogleCloudLoggingLogLabelsList extends cdktf.ComplexList {
  public internalValue? : DestinationOutputGoogleCloudLoggingLogLabels[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DestinationOutputGoogleCloudLoggingLogLabelsOutputReference {
    return new DestinationOutputGoogleCloudLoggingLogLabelsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DestinationOutputGoogleCloudLoggingPqControls {
}

export function destinationOutputGoogleCloudLoggingPqControlsToTerraform(struct?: DestinationOutputGoogleCloudLoggingPqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function destinationOutputGoogleCloudLoggingPqControlsToHclTerraform(struct?: DestinationOutputGoogleCloudLoggingPqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class DestinationOutputGoogleCloudLoggingPqControlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DestinationOutputGoogleCloudLoggingPqControls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputGoogleCloudLoggingPqControls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface DestinationOutputGoogleCloudLoggingResourceTypeLabels {
  /**
  * Label name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#label Destination#label}
  */
  readonly label: string;
  /**
  * JavaScript expression to compute the label's value.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#value_expression Destination#value_expression}
  */
  readonly valueExpression: string;
}

export function destinationOutputGoogleCloudLoggingResourceTypeLabelsToTerraform(struct?: DestinationOutputGoogleCloudLoggingResourceTypeLabels | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    label: cdktf.stringToTerraform(struct!.label),
    value_expression: cdktf.stringToTerraform(struct!.valueExpression),
  }
}


export function destinationOutputGoogleCloudLoggingResourceTypeLabelsToHclTerraform(struct?: DestinationOutputGoogleCloudLoggingResourceTypeLabels | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    label: {
      value: cdktf.stringToHclTerraform(struct!.label),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value_expression: {
      value: cdktf.stringToHclTerraform(struct!.valueExpression),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputGoogleCloudLoggingResourceTypeLabelsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DestinationOutputGoogleCloudLoggingResourceTypeLabels | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._label !== undefined) {
      hasAnyValues = true;
      internalValueResult.label = this._label;
    }
    if (this._valueExpression !== undefined) {
      hasAnyValues = true;
      internalValueResult.valueExpression = this._valueExpression;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputGoogleCloudLoggingResourceTypeLabels | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._label = undefined;
      this._valueExpression = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._label = value.label;
      this._valueExpression = value.valueExpression;
    }
  }

  // label - computed: false, optional: false, required: true
  private _label?: string; 
  public get label() {
    return this.getStringAttribute('label');
  }
  public set label(value: string) {
    this._label = value;
  }
  // Temporarily expose input value. Use with caution.
  public get labelInput() {
    return this._label;
  }

  // value_expression - computed: false, optional: false, required: true
  private _valueExpression?: string; 
  public get valueExpression() {
    return this.getStringAttribute('value_expression');
  }
  public set valueExpression(value: string) {
    this._valueExpression = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueExpressionInput() {
    return this._valueExpression;
  }
}

export class DestinationOutputGoogleCloudLoggingResourceTypeLabelsList extends cdktf.ComplexList {
  public internalValue? : DestinationOutputGoogleCloudLoggingResourceTypeLabels[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DestinationOutputGoogleCloudLoggingResourceTypeLabelsOutputReference {
    return new DestinationOutputGoogleCloudLoggingResourceTypeLabelsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DestinationOutputGoogleCloudLogging {
  /**
  * A JavaScript expression that evaluates to the HTTP request cache fill bytes as a string, in int64 format. See the [documentation](https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry#httprequest) for details.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#cache_fill_bytes_expression Destination#cache_fill_bytes_expression}
  */
  readonly cacheFillBytesExpression?: string;
  /**
  * A JavaScript expression that evaluates to the HTTP request cache hit as a boolean. See the [documentation](https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry#httprequest) for details.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#cache_hit_expression Destination#cache_hit_expression}
  */
  readonly cacheHitExpression?: string;
  /**
  * A JavaScript expression that evaluates to the HTTP request cache lookup as a boolean. See the [documentation](https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry#httprequest) for details.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#cache_lookup_expression Destination#cache_lookup_expression}
  */
  readonly cacheLookupExpression?: string;
  /**
  * A JavaScript expression that evaluates to the HTTP request cache validated with origin server as a boolean. See the [documentation](https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry#httprequest) for details.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#cache_validated_expression Destination#cache_validated_expression}
  */
  readonly cacheValidatedExpression?: string;
  /**
  * Maximum number of ongoing requests before blocking. Default: 5
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#concurrency Destination#concurrency}
  */
  readonly concurrency?: number;
  /**
  * Amount of time (milliseconds) to wait for the connection to establish before retrying. Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#connection_timeout Destination#connection_timeout}
  */
  readonly connectionTimeout?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#description Destination#description}
  */
  readonly description?: string;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#environment Destination#environment}
  */
  readonly environment?: string;
  /**
  * A JavaScript expression that evaluates to the log entry source location file as a string. See the [documentation](https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry#logentrysourcelocation) for details.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#file_expression Destination#file_expression}
  */
  readonly fileExpression?: string;
  /**
  * A JavaScript expression that evaluates to the log entry operation first flag as a boolean. See the [documentation](https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry#logentryoperation) for details.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#first_expression Destination#first_expression}
  */
  readonly firstExpression?: string;
  /**
  * Maximum time between requests. Small values could cause the payload size to be smaller than the configured Max record size. Default: 1
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#flush_period_sec Destination#flush_period_sec}
  */
  readonly flushPeriodSec?: number;
  /**
  * A JavaScript expression that evaluates to the log entry source location function as a string. See the [documentation](https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry#logentrysourcelocation) for details.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#function_expression Destination#function_expression}
  */
  readonly functionExpression?: string;
  /**
  * Choose Auto to use Google Application Default Credentials (ADC), Manual to enter Google service account credentials directly, or Secret to select or create a stored secret that references Google service account credentials. Default: "manual"; must be one of ["auto", "manual", "secret"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#google_auth_method Destination#google_auth_method}
  */
  readonly googleAuthMethod?: string;
  /**
  * Unique ID for this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#id Destination#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * A JavaScript expression that evaluates to the log entry operation ID as a string. See the [documentation](https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry#logentryoperation) for details.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#id_expression Destination#id_expression}
  */
  readonly idExpression?: string;
  /**
  * A JavaScript expression that evaluates to the log entry log split index as a number. See the [documentation](https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry#logsplit) for details.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#index_expression Destination#index_expression}
  */
  readonly indexExpression?: string;
  /**
  * JavaScript expression to compute the value of the insert ID field.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#insert_id_expression Destination#insert_id_expression}
  */
  readonly insertIdExpression?: string;
  /**
  * A JavaScript expression that evaluates to the log entry operation last flag as a boolean. See the [documentation](https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry#logentryoperation) for details.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#last_expression Destination#last_expression}
  */
  readonly lastExpression?: string;
  /**
  * A JavaScript expression that evaluates to the HTTP request latency, formatted as <seconds>.<nanoseconds>s (for example, 1.23s). See the [documentation](https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry#httprequest) for details.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#latency_expression Destination#latency_expression}
  */
  readonly latencyExpression?: string;
  /**
  * A JavaScript expression that evaluates to the log entry source location line as a string, in int64 format. See the [documentation](https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry#logentrysourcelocation) for details.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#line_expression Destination#line_expression}
  */
  readonly lineExpression?: string;
  /**
  * Labels to apply to the log entry
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#log_labels Destination#log_labels}
  */
  readonly logLabels?: DestinationOutputGoogleCloudLoggingLogLabels[] | cdktf.IResolvable;
  /**
  * JavaScript expression to compute the value of the folder ID with which log entries should be associated.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#log_location_expression Destination#log_location_expression}
  */
  readonly logLocationExpression: string;
  /**
  * must be one of ["project", "organization", "billingAccount", "folder"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#log_location_type Destination#log_location_type}
  */
  readonly logLocationType: string;
  /**
  * JavaScript expression to compute the value of the log name.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#log_name_expression Destination#log_name_expression}
  */
  readonly logNameExpression: string;
  /**
  * Max number of events to include in the request body. Default is 0 (unlimited). Default: 0
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#max_payload_events Destination#max_payload_events}
  */
  readonly maxPayloadEvents?: number;
  /**
  * Maximum size, in KB, of the request body. Default: 4096
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#max_payload_size_kb Destination#max_payload_size_kb}
  */
  readonly maxPayloadSizeKb?: number;
  /**
  * How to handle events when all receivers are exerting backpressure. Default: "block"; must be one of ["block", "drop", "queue"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#on_backpressure Destination#on_backpressure}
  */
  readonly onBackpressure?: string;
  /**
  * JavaScript expression to compute the value of the payload. Must evaluate to a JavaScript object value. If an invalid value is encountered it will result in the default value instead. Defaults to the entire event.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#payload_expression Destination#payload_expression}
  */
  readonly payloadExpression?: string;
  /**
  * Format to use when sending payload. Defaults to Text. Default: "text"; must be one of ["text", "json"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#payload_format Destination#payload_format}
  */
  readonly payloadFormat?: string;
  /**
  * Pipeline to process data before sending out to this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pipeline Destination#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pq_compress Destination#pq_compress}
  */
  readonly pqCompress?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pq_controls Destination#pq_controls}
  */
  readonly pqControls?: DestinationOutputGoogleCloudLoggingPqControls;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.). Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pq_max_file_size Destination#pq_max_file_size}
  */
  readonly pqMaxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pq_max_size Destination#pq_max_size}
  */
  readonly pqMaxSize?: string;
  /**
  * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem. Default: "error"; must be one of ["error", "backpressure", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pq_mode Destination#pq_mode}
  */
  readonly pqMode?: string;
  /**
  * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged. Default: "block"; must be one of ["block", "drop"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pq_on_backpressure Destination#pq_on_backpressure}
  */
  readonly pqOnBackpressure?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pq_path Destination#pq_path}
  */
  readonly pqPath?: string;
  /**
  * A JavaScript expression that evaluates to the log entry operation producer as a string. See the [documentation](https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry#logentryoperation) for details.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#producer_expression Destination#producer_expression}
  */
  readonly producerExpression?: string;
  /**
  * A JavaScript expression that evaluates to the HTTP request protocol as a string. See the [documentation](https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry#httprequest) for details.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#protocol_expression Destination#protocol_expression}
  */
  readonly protocolExpression?: string;
  /**
  * A JavaScript expression that evaluates to the HTTP request referer as a string. See the [documentation](https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry#httprequest) for details.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#referer_expression Destination#referer_expression}
  */
  readonly refererExpression?: string;
  /**
  * A JavaScript expression that evaluates to the HTTP request remote IP as a string. See the [documentation](https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry#httprequest) for details.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#remote_ip_expression Destination#remote_ip_expression}
  */
  readonly remoteIpExpression?: string;
  /**
  * A JavaScript expression that evaluates to the HTTP request method as a string. See the [documentation](https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry#httprequest) for details.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#request_method_expression Destination#request_method_expression}
  */
  readonly requestMethodExpression?: string;
  /**
  * A JavaScript expression that evaluates to the HTTP request size as a string, in int64 format. See the [documentation](https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry#httprequest) for details.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#request_size_expression Destination#request_size_expression}
  */
  readonly requestSizeExpression?: string;
  /**
  * A JavaScript expression that evaluates to the HTTP request URL as a string. See the [documentation](https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry#httprequest) for details.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#request_url_expression Destination#request_url_expression}
  */
  readonly requestUrlExpression?: string;
  /**
  * JavaScript expression to compute the value of the managed resource type field. Must evaluate to one of the valid values [here](https://cloud.google.com/logging/docs/api/v2/resource-list#resource-types). Defaults to "global".
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#resource_type_expression Destination#resource_type_expression}
  */
  readonly resourceTypeExpression?: string;
  /**
  * Labels to apply to the managed resource. These must correspond to the valid labels for the specified resource type (see [here](https://cloud.google.com/logging/docs/api/v2/resource-list#resource-types)). Otherwise, they will be dropped by Google Cloud Logging.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#resource_type_labels Destination#resource_type_labels}
  */
  readonly resourceTypeLabels?: DestinationOutputGoogleCloudLoggingResourceTypeLabels[] | cdktf.IResolvable;
  /**
  * A JavaScript expression that evaluates to the HTTP response size as a string, in int64 format. See the [documentation](https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry#httprequest) for details.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#response_size_expression Destination#response_size_expression}
  */
  readonly responseSizeExpression?: string;
  /**
  * Select or create a stored text secret
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#secret Destination#secret}
  */
  readonly secret?: string;
  /**
  * A JavaScript expression that evaluates to the HTTP request server IP as a string. See the [documentation](https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry#httprequest) for details.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#server_ip_expression Destination#server_ip_expression}
  */
  readonly serverIpExpression?: string;
  /**
  * Contents of service account credentials (JSON keys) file downloaded from Google Cloud. To upload a file, click the upload button at this field's upper right.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#service_account_credentials Destination#service_account_credentials}
  */
  readonly serviceAccountCredentials?: string;
  /**
  * JavaScript expression to compute the value of the severity field. Must evaluate to one of the severity values supported by Google Cloud Logging [here](https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry#logseverity) (case insensitive). Defaults to "DEFAULT".
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#severity_expression Destination#severity_expression}
  */
  readonly severityExpression?: string;
  /**
  * A JavaScript expression that evaluates to the ID of the cloud trace span associated with the current operation in which the log is being written as a string. See the [documentation](https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry) for details.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#span_id_expression Destination#span_id_expression}
  */
  readonly spanIdExpression?: string;
  /**
  * A JavaScript expression that evaluates to the HTTP request method as a number. See the [documentation](https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry#httprequest) for details.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#status_expression Destination#status_expression}
  */
  readonly statusExpression?: string;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#streamtags Destination#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Fields to automatically add to events, such as cribl_pipe. Supports wildcards. Default: ["cribl_pipe"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#system_fields Destination#system_fields}
  */
  readonly systemFields?: string[];
  /**
  * Maximum number of requests to limit to per second.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#throttle_rate_req_per_sec Destination#throttle_rate_req_per_sec}
  */
  readonly throttleRateReqPerSec?: number;
  /**
  * Amount of time, in seconds, to wait for a request to complete before canceling it. Default: 30
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#timeout_sec Destination#timeout_sec}
  */
  readonly timeoutSec?: number;
  /**
  * Maximum total size of the batches waiting to be sent. If left blank, defaults to 5 times the max body size (if set). If 0, no limit is enforced.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#total_memory_limit_kb Destination#total_memory_limit_kb}
  */
  readonly totalMemoryLimitKb?: number;
  /**
  * A JavaScript expression that evaluates to the log entry log split total splits as a number. See the [documentation](https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry#logsplit) for details.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#total_splits_expression Destination#total_splits_expression}
  */
  readonly totalSplitsExpression?: string;
  /**
  * A JavaScript expression that evaluates to the REST resource name of the trace being written as a string. See the [documentation](https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry) for details.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#trace_expression Destination#trace_expression}
  */
  readonly traceExpression?: string;
  /**
  * A JavaScript expression that evaluates to the the sampling decision of the span associated with the log entry. See the [documentation](https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry) for details.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#trace_sampled_expression Destination#trace_sampled_expression}
  */
  readonly traceSampledExpression?: string;
  /**
  * must be "google_cloud_logging"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#type Destination#type}
  */
  readonly type?: string;
  /**
  * A JavaScript expression that evaluates to the log entry log split UID as a string. See the [documentation](https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry#logsplit) for details.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#uid_expression Destination#uid_expression}
  */
  readonly uidExpression?: string;
  /**
  * A JavaScript expression that evaluates to the HTTP request user agent as a string. See the [documentation](https://cloud.google.com/logging/docs/reference/v2/rest/v2/LogEntry#httprequest) for details.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#user_agent_expression Destination#user_agent_expression}
  */
  readonly userAgentExpression?: string;
}

export function destinationOutputGoogleCloudLoggingToTerraform(struct?: DestinationOutputGoogleCloudLogging | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    cache_fill_bytes_expression: cdktf.stringToTerraform(struct!.cacheFillBytesExpression),
    cache_hit_expression: cdktf.stringToTerraform(struct!.cacheHitExpression),
    cache_lookup_expression: cdktf.stringToTerraform(struct!.cacheLookupExpression),
    cache_validated_expression: cdktf.stringToTerraform(struct!.cacheValidatedExpression),
    concurrency: cdktf.numberToTerraform(struct!.concurrency),
    connection_timeout: cdktf.numberToTerraform(struct!.connectionTimeout),
    description: cdktf.stringToTerraform(struct!.description),
    environment: cdktf.stringToTerraform(struct!.environment),
    file_expression: cdktf.stringToTerraform(struct!.fileExpression),
    first_expression: cdktf.stringToTerraform(struct!.firstExpression),
    flush_period_sec: cdktf.numberToTerraform(struct!.flushPeriodSec),
    function_expression: cdktf.stringToTerraform(struct!.functionExpression),
    google_auth_method: cdktf.stringToTerraform(struct!.googleAuthMethod),
    id: cdktf.stringToTerraform(struct!.id),
    id_expression: cdktf.stringToTerraform(struct!.idExpression),
    index_expression: cdktf.stringToTerraform(struct!.indexExpression),
    insert_id_expression: cdktf.stringToTerraform(struct!.insertIdExpression),
    last_expression: cdktf.stringToTerraform(struct!.lastExpression),
    latency_expression: cdktf.stringToTerraform(struct!.latencyExpression),
    line_expression: cdktf.stringToTerraform(struct!.lineExpression),
    log_labels: cdktf.listMapper(destinationOutputGoogleCloudLoggingLogLabelsToTerraform, false)(struct!.logLabels),
    log_location_expression: cdktf.stringToTerraform(struct!.logLocationExpression),
    log_location_type: cdktf.stringToTerraform(struct!.logLocationType),
    log_name_expression: cdktf.stringToTerraform(struct!.logNameExpression),
    max_payload_events: cdktf.numberToTerraform(struct!.maxPayloadEvents),
    max_payload_size_kb: cdktf.numberToTerraform(struct!.maxPayloadSizeKb),
    on_backpressure: cdktf.stringToTerraform(struct!.onBackpressure),
    payload_expression: cdktf.stringToTerraform(struct!.payloadExpression),
    payload_format: cdktf.stringToTerraform(struct!.payloadFormat),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    pq_compress: cdktf.stringToTerraform(struct!.pqCompress),
    pq_controls: destinationOutputGoogleCloudLoggingPqControlsToTerraform(struct!.pqControls),
    pq_max_file_size: cdktf.stringToTerraform(struct!.pqMaxFileSize),
    pq_max_size: cdktf.stringToTerraform(struct!.pqMaxSize),
    pq_mode: cdktf.stringToTerraform(struct!.pqMode),
    pq_on_backpressure: cdktf.stringToTerraform(struct!.pqOnBackpressure),
    pq_path: cdktf.stringToTerraform(struct!.pqPath),
    producer_expression: cdktf.stringToTerraform(struct!.producerExpression),
    protocol_expression: cdktf.stringToTerraform(struct!.protocolExpression),
    referer_expression: cdktf.stringToTerraform(struct!.refererExpression),
    remote_ip_expression: cdktf.stringToTerraform(struct!.remoteIpExpression),
    request_method_expression: cdktf.stringToTerraform(struct!.requestMethodExpression),
    request_size_expression: cdktf.stringToTerraform(struct!.requestSizeExpression),
    request_url_expression: cdktf.stringToTerraform(struct!.requestUrlExpression),
    resource_type_expression: cdktf.stringToTerraform(struct!.resourceTypeExpression),
    resource_type_labels: cdktf.listMapper(destinationOutputGoogleCloudLoggingResourceTypeLabelsToTerraform, false)(struct!.resourceTypeLabels),
    response_size_expression: cdktf.stringToTerraform(struct!.responseSizeExpression),
    secret: cdktf.stringToTerraform(struct!.secret),
    server_ip_expression: cdktf.stringToTerraform(struct!.serverIpExpression),
    service_account_credentials: cdktf.stringToTerraform(struct!.serviceAccountCredentials),
    severity_expression: cdktf.stringToTerraform(struct!.severityExpression),
    span_id_expression: cdktf.stringToTerraform(struct!.spanIdExpression),
    status_expression: cdktf.stringToTerraform(struct!.statusExpression),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    system_fields: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.systemFields),
    throttle_rate_req_per_sec: cdktf.numberToTerraform(struct!.throttleRateReqPerSec),
    timeout_sec: cdktf.numberToTerraform(struct!.timeoutSec),
    total_memory_limit_kb: cdktf.numberToTerraform(struct!.totalMemoryLimitKb),
    total_splits_expression: cdktf.stringToTerraform(struct!.totalSplitsExpression),
    trace_expression: cdktf.stringToTerraform(struct!.traceExpression),
    trace_sampled_expression: cdktf.stringToTerraform(struct!.traceSampledExpression),
    type: cdktf.stringToTerraform(struct!.type),
    uid_expression: cdktf.stringToTerraform(struct!.uidExpression),
    user_agent_expression: cdktf.stringToTerraform(struct!.userAgentExpression),
  }
}


export function destinationOutputGoogleCloudLoggingToHclTerraform(struct?: DestinationOutputGoogleCloudLogging | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    cache_fill_bytes_expression: {
      value: cdktf.stringToHclTerraform(struct!.cacheFillBytesExpression),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    cache_hit_expression: {
      value: cdktf.stringToHclTerraform(struct!.cacheHitExpression),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    cache_lookup_expression: {
      value: cdktf.stringToHclTerraform(struct!.cacheLookupExpression),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    cache_validated_expression: {
      value: cdktf.stringToHclTerraform(struct!.cacheValidatedExpression),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    concurrency: {
      value: cdktf.numberToHclTerraform(struct!.concurrency),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    connection_timeout: {
      value: cdktf.numberToHclTerraform(struct!.connectionTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    file_expression: {
      value: cdktf.stringToHclTerraform(struct!.fileExpression),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    first_expression: {
      value: cdktf.stringToHclTerraform(struct!.firstExpression),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    flush_period_sec: {
      value: cdktf.numberToHclTerraform(struct!.flushPeriodSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    function_expression: {
      value: cdktf.stringToHclTerraform(struct!.functionExpression),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    google_auth_method: {
      value: cdktf.stringToHclTerraform(struct!.googleAuthMethod),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    id_expression: {
      value: cdktf.stringToHclTerraform(struct!.idExpression),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    index_expression: {
      value: cdktf.stringToHclTerraform(struct!.indexExpression),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    insert_id_expression: {
      value: cdktf.stringToHclTerraform(struct!.insertIdExpression),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    last_expression: {
      value: cdktf.stringToHclTerraform(struct!.lastExpression),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    latency_expression: {
      value: cdktf.stringToHclTerraform(struct!.latencyExpression),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    line_expression: {
      value: cdktf.stringToHclTerraform(struct!.lineExpression),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    log_labels: {
      value: cdktf.listMapperHcl(destinationOutputGoogleCloudLoggingLogLabelsToHclTerraform, false)(struct!.logLabels),
      isBlock: true,
      type: "list",
      storageClassType: "DestinationOutputGoogleCloudLoggingLogLabelsList",
    },
    log_location_expression: {
      value: cdktf.stringToHclTerraform(struct!.logLocationExpression),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    log_location_type: {
      value: cdktf.stringToHclTerraform(struct!.logLocationType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    log_name_expression: {
      value: cdktf.stringToHclTerraform(struct!.logNameExpression),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_payload_events: {
      value: cdktf.numberToHclTerraform(struct!.maxPayloadEvents),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_payload_size_kb: {
      value: cdktf.numberToHclTerraform(struct!.maxPayloadSizeKb),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.onBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    payload_expression: {
      value: cdktf.stringToHclTerraform(struct!.payloadExpression),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    payload_format: {
      value: cdktf.stringToHclTerraform(struct!.payloadFormat),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_compress: {
      value: cdktf.stringToHclTerraform(struct!.pqCompress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_controls: {
      value: destinationOutputGoogleCloudLoggingPqControlsToHclTerraform(struct!.pqControls),
      isBlock: true,
      type: "struct",
      storageClassType: "DestinationOutputGoogleCloudLoggingPqControls",
    },
    pq_max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_max_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_mode: {
      value: cdktf.stringToHclTerraform(struct!.pqMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.pqOnBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_path: {
      value: cdktf.stringToHclTerraform(struct!.pqPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    producer_expression: {
      value: cdktf.stringToHclTerraform(struct!.producerExpression),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    protocol_expression: {
      value: cdktf.stringToHclTerraform(struct!.protocolExpression),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    referer_expression: {
      value: cdktf.stringToHclTerraform(struct!.refererExpression),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    remote_ip_expression: {
      value: cdktf.stringToHclTerraform(struct!.remoteIpExpression),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    request_method_expression: {
      value: cdktf.stringToHclTerraform(struct!.requestMethodExpression),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    request_size_expression: {
      value: cdktf.stringToHclTerraform(struct!.requestSizeExpression),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    request_url_expression: {
      value: cdktf.stringToHclTerraform(struct!.requestUrlExpression),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    resource_type_expression: {
      value: cdktf.stringToHclTerraform(struct!.resourceTypeExpression),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    resource_type_labels: {
      value: cdktf.listMapperHcl(destinationOutputGoogleCloudLoggingResourceTypeLabelsToHclTerraform, false)(struct!.resourceTypeLabels),
      isBlock: true,
      type: "list",
      storageClassType: "DestinationOutputGoogleCloudLoggingResourceTypeLabelsList",
    },
    response_size_expression: {
      value: cdktf.stringToHclTerraform(struct!.responseSizeExpression),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret: {
      value: cdktf.stringToHclTerraform(struct!.secret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    server_ip_expression: {
      value: cdktf.stringToHclTerraform(struct!.serverIpExpression),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    service_account_credentials: {
      value: cdktf.stringToHclTerraform(struct!.serviceAccountCredentials),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    severity_expression: {
      value: cdktf.stringToHclTerraform(struct!.severityExpression),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    span_id_expression: {
      value: cdktf.stringToHclTerraform(struct!.spanIdExpression),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    status_expression: {
      value: cdktf.stringToHclTerraform(struct!.statusExpression),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    system_fields: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.systemFields),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    throttle_rate_req_per_sec: {
      value: cdktf.numberToHclTerraform(struct!.throttleRateReqPerSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    timeout_sec: {
      value: cdktf.numberToHclTerraform(struct!.timeoutSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    total_memory_limit_kb: {
      value: cdktf.numberToHclTerraform(struct!.totalMemoryLimitKb),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    total_splits_expression: {
      value: cdktf.stringToHclTerraform(struct!.totalSplitsExpression),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    trace_expression: {
      value: cdktf.stringToHclTerraform(struct!.traceExpression),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    trace_sampled_expression: {
      value: cdktf.stringToHclTerraform(struct!.traceSampledExpression),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    uid_expression: {
      value: cdktf.stringToHclTerraform(struct!.uidExpression),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    user_agent_expression: {
      value: cdktf.stringToHclTerraform(struct!.userAgentExpression),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputGoogleCloudLoggingOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DestinationOutputGoogleCloudLogging | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._cacheFillBytesExpression !== undefined) {
      hasAnyValues = true;
      internalValueResult.cacheFillBytesExpression = this._cacheFillBytesExpression;
    }
    if (this._cacheHitExpression !== undefined) {
      hasAnyValues = true;
      internalValueResult.cacheHitExpression = this._cacheHitExpression;
    }
    if (this._cacheLookupExpression !== undefined) {
      hasAnyValues = true;
      internalValueResult.cacheLookupExpression = this._cacheLookupExpression;
    }
    if (this._cacheValidatedExpression !== undefined) {
      hasAnyValues = true;
      internalValueResult.cacheValidatedExpression = this._cacheValidatedExpression;
    }
    if (this._concurrency !== undefined) {
      hasAnyValues = true;
      internalValueResult.concurrency = this._concurrency;
    }
    if (this._connectionTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.connectionTimeout = this._connectionTimeout;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._fileExpression !== undefined) {
      hasAnyValues = true;
      internalValueResult.fileExpression = this._fileExpression;
    }
    if (this._firstExpression !== undefined) {
      hasAnyValues = true;
      internalValueResult.firstExpression = this._firstExpression;
    }
    if (this._flushPeriodSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.flushPeriodSec = this._flushPeriodSec;
    }
    if (this._functionExpression !== undefined) {
      hasAnyValues = true;
      internalValueResult.functionExpression = this._functionExpression;
    }
    if (this._googleAuthMethod !== undefined) {
      hasAnyValues = true;
      internalValueResult.googleAuthMethod = this._googleAuthMethod;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._idExpression !== undefined) {
      hasAnyValues = true;
      internalValueResult.idExpression = this._idExpression;
    }
    if (this._indexExpression !== undefined) {
      hasAnyValues = true;
      internalValueResult.indexExpression = this._indexExpression;
    }
    if (this._insertIdExpression !== undefined) {
      hasAnyValues = true;
      internalValueResult.insertIdExpression = this._insertIdExpression;
    }
    if (this._lastExpression !== undefined) {
      hasAnyValues = true;
      internalValueResult.lastExpression = this._lastExpression;
    }
    if (this._latencyExpression !== undefined) {
      hasAnyValues = true;
      internalValueResult.latencyExpression = this._latencyExpression;
    }
    if (this._lineExpression !== undefined) {
      hasAnyValues = true;
      internalValueResult.lineExpression = this._lineExpression;
    }
    if (this._logLabels?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.logLabels = this._logLabels?.internalValue;
    }
    if (this._logLocationExpression !== undefined) {
      hasAnyValues = true;
      internalValueResult.logLocationExpression = this._logLocationExpression;
    }
    if (this._logLocationType !== undefined) {
      hasAnyValues = true;
      internalValueResult.logLocationType = this._logLocationType;
    }
    if (this._logNameExpression !== undefined) {
      hasAnyValues = true;
      internalValueResult.logNameExpression = this._logNameExpression;
    }
    if (this._maxPayloadEvents !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxPayloadEvents = this._maxPayloadEvents;
    }
    if (this._maxPayloadSizeKb !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxPayloadSizeKb = this._maxPayloadSizeKb;
    }
    if (this._onBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.onBackpressure = this._onBackpressure;
    }
    if (this._payloadExpression !== undefined) {
      hasAnyValues = true;
      internalValueResult.payloadExpression = this._payloadExpression;
    }
    if (this._payloadFormat !== undefined) {
      hasAnyValues = true;
      internalValueResult.payloadFormat = this._payloadFormat;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._pqCompress !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqCompress = this._pqCompress;
    }
    if (this._pqControls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqControls = this._pqControls?.internalValue;
    }
    if (this._pqMaxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxFileSize = this._pqMaxFileSize;
    }
    if (this._pqMaxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxSize = this._pqMaxSize;
    }
    if (this._pqMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMode = this._pqMode;
    }
    if (this._pqOnBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqOnBackpressure = this._pqOnBackpressure;
    }
    if (this._pqPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqPath = this._pqPath;
    }
    if (this._producerExpression !== undefined) {
      hasAnyValues = true;
      internalValueResult.producerExpression = this._producerExpression;
    }
    if (this._protocolExpression !== undefined) {
      hasAnyValues = true;
      internalValueResult.protocolExpression = this._protocolExpression;
    }
    if (this._refererExpression !== undefined) {
      hasAnyValues = true;
      internalValueResult.refererExpression = this._refererExpression;
    }
    if (this._remoteIpExpression !== undefined) {
      hasAnyValues = true;
      internalValueResult.remoteIpExpression = this._remoteIpExpression;
    }
    if (this._requestMethodExpression !== undefined) {
      hasAnyValues = true;
      internalValueResult.requestMethodExpression = this._requestMethodExpression;
    }
    if (this._requestSizeExpression !== undefined) {
      hasAnyValues = true;
      internalValueResult.requestSizeExpression = this._requestSizeExpression;
    }
    if (this._requestUrlExpression !== undefined) {
      hasAnyValues = true;
      internalValueResult.requestUrlExpression = this._requestUrlExpression;
    }
    if (this._resourceTypeExpression !== undefined) {
      hasAnyValues = true;
      internalValueResult.resourceTypeExpression = this._resourceTypeExpression;
    }
    if (this._resourceTypeLabels?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.resourceTypeLabels = this._resourceTypeLabels?.internalValue;
    }
    if (this._responseSizeExpression !== undefined) {
      hasAnyValues = true;
      internalValueResult.responseSizeExpression = this._responseSizeExpression;
    }
    if (this._secret !== undefined) {
      hasAnyValues = true;
      internalValueResult.secret = this._secret;
    }
    if (this._serverIpExpression !== undefined) {
      hasAnyValues = true;
      internalValueResult.serverIpExpression = this._serverIpExpression;
    }
    if (this._serviceAccountCredentials !== undefined) {
      hasAnyValues = true;
      internalValueResult.serviceAccountCredentials = this._serviceAccountCredentials;
    }
    if (this._severityExpression !== undefined) {
      hasAnyValues = true;
      internalValueResult.severityExpression = this._severityExpression;
    }
    if (this._spanIdExpression !== undefined) {
      hasAnyValues = true;
      internalValueResult.spanIdExpression = this._spanIdExpression;
    }
    if (this._statusExpression !== undefined) {
      hasAnyValues = true;
      internalValueResult.statusExpression = this._statusExpression;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._systemFields !== undefined) {
      hasAnyValues = true;
      internalValueResult.systemFields = this._systemFields;
    }
    if (this._throttleRateReqPerSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.throttleRateReqPerSec = this._throttleRateReqPerSec;
    }
    if (this._timeoutSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutSec = this._timeoutSec;
    }
    if (this._totalMemoryLimitKb !== undefined) {
      hasAnyValues = true;
      internalValueResult.totalMemoryLimitKb = this._totalMemoryLimitKb;
    }
    if (this._totalSplitsExpression !== undefined) {
      hasAnyValues = true;
      internalValueResult.totalSplitsExpression = this._totalSplitsExpression;
    }
    if (this._traceExpression !== undefined) {
      hasAnyValues = true;
      internalValueResult.traceExpression = this._traceExpression;
    }
    if (this._traceSampledExpression !== undefined) {
      hasAnyValues = true;
      internalValueResult.traceSampledExpression = this._traceSampledExpression;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._uidExpression !== undefined) {
      hasAnyValues = true;
      internalValueResult.uidExpression = this._uidExpression;
    }
    if (this._userAgentExpression !== undefined) {
      hasAnyValues = true;
      internalValueResult.userAgentExpression = this._userAgentExpression;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputGoogleCloudLogging | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._cacheFillBytesExpression = undefined;
      this._cacheHitExpression = undefined;
      this._cacheLookupExpression = undefined;
      this._cacheValidatedExpression = undefined;
      this._concurrency = undefined;
      this._connectionTimeout = undefined;
      this._description = undefined;
      this._environment = undefined;
      this._fileExpression = undefined;
      this._firstExpression = undefined;
      this._flushPeriodSec = undefined;
      this._functionExpression = undefined;
      this._googleAuthMethod = undefined;
      this._id = undefined;
      this._idExpression = undefined;
      this._indexExpression = undefined;
      this._insertIdExpression = undefined;
      this._lastExpression = undefined;
      this._latencyExpression = undefined;
      this._lineExpression = undefined;
      this._logLabels.internalValue = undefined;
      this._logLocationExpression = undefined;
      this._logLocationType = undefined;
      this._logNameExpression = undefined;
      this._maxPayloadEvents = undefined;
      this._maxPayloadSizeKb = undefined;
      this._onBackpressure = undefined;
      this._payloadExpression = undefined;
      this._payloadFormat = undefined;
      this._pipeline = undefined;
      this._pqCompress = undefined;
      this._pqControls.internalValue = undefined;
      this._pqMaxFileSize = undefined;
      this._pqMaxSize = undefined;
      this._pqMode = undefined;
      this._pqOnBackpressure = undefined;
      this._pqPath = undefined;
      this._producerExpression = undefined;
      this._protocolExpression = undefined;
      this._refererExpression = undefined;
      this._remoteIpExpression = undefined;
      this._requestMethodExpression = undefined;
      this._requestSizeExpression = undefined;
      this._requestUrlExpression = undefined;
      this._resourceTypeExpression = undefined;
      this._resourceTypeLabels.internalValue = undefined;
      this._responseSizeExpression = undefined;
      this._secret = undefined;
      this._serverIpExpression = undefined;
      this._serviceAccountCredentials = undefined;
      this._severityExpression = undefined;
      this._spanIdExpression = undefined;
      this._statusExpression = undefined;
      this._streamtags = undefined;
      this._systemFields = undefined;
      this._throttleRateReqPerSec = undefined;
      this._timeoutSec = undefined;
      this._totalMemoryLimitKb = undefined;
      this._totalSplitsExpression = undefined;
      this._traceExpression = undefined;
      this._traceSampledExpression = undefined;
      this._type = undefined;
      this._uidExpression = undefined;
      this._userAgentExpression = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._cacheFillBytesExpression = value.cacheFillBytesExpression;
      this._cacheHitExpression = value.cacheHitExpression;
      this._cacheLookupExpression = value.cacheLookupExpression;
      this._cacheValidatedExpression = value.cacheValidatedExpression;
      this._concurrency = value.concurrency;
      this._connectionTimeout = value.connectionTimeout;
      this._description = value.description;
      this._environment = value.environment;
      this._fileExpression = value.fileExpression;
      this._firstExpression = value.firstExpression;
      this._flushPeriodSec = value.flushPeriodSec;
      this._functionExpression = value.functionExpression;
      this._googleAuthMethod = value.googleAuthMethod;
      this._id = value.id;
      this._idExpression = value.idExpression;
      this._indexExpression = value.indexExpression;
      this._insertIdExpression = value.insertIdExpression;
      this._lastExpression = value.lastExpression;
      this._latencyExpression = value.latencyExpression;
      this._lineExpression = value.lineExpression;
      this._logLabels.internalValue = value.logLabels;
      this._logLocationExpression = value.logLocationExpression;
      this._logLocationType = value.logLocationType;
      this._logNameExpression = value.logNameExpression;
      this._maxPayloadEvents = value.maxPayloadEvents;
      this._maxPayloadSizeKb = value.maxPayloadSizeKb;
      this._onBackpressure = value.onBackpressure;
      this._payloadExpression = value.payloadExpression;
      this._payloadFormat = value.payloadFormat;
      this._pipeline = value.pipeline;
      this._pqCompress = value.pqCompress;
      this._pqControls.internalValue = value.pqControls;
      this._pqMaxFileSize = value.pqMaxFileSize;
      this._pqMaxSize = value.pqMaxSize;
      this._pqMode = value.pqMode;
      this._pqOnBackpressure = value.pqOnBackpressure;
      this._pqPath = value.pqPath;
      this._producerExpression = value.producerExpression;
      this._protocolExpression = value.protocolExpression;
      this._refererExpression = value.refererExpression;
      this._remoteIpExpression = value.remoteIpExpression;
      this._requestMethodExpression = value.requestMethodExpression;
      this._requestSizeExpression = value.requestSizeExpression;
      this._requestUrlExpression = value.requestUrlExpression;
      this._resourceTypeExpression = value.resourceTypeExpression;
      this._resourceTypeLabels.internalValue = value.resourceTypeLabels;
      this._responseSizeExpression = value.responseSizeExpression;
      this._secret = value.secret;
      this._serverIpExpression = value.serverIpExpression;
      this._serviceAccountCredentials = value.serviceAccountCredentials;
      this._severityExpression = value.severityExpression;
      this._spanIdExpression = value.spanIdExpression;
      this._statusExpression = value.statusExpression;
      this._streamtags = value.streamtags;
      this._systemFields = value.systemFields;
      this._throttleRateReqPerSec = value.throttleRateReqPerSec;
      this._timeoutSec = value.timeoutSec;
      this._totalMemoryLimitKb = value.totalMemoryLimitKb;
      this._totalSplitsExpression = value.totalSplitsExpression;
      this._traceExpression = value.traceExpression;
      this._traceSampledExpression = value.traceSampledExpression;
      this._type = value.type;
      this._uidExpression = value.uidExpression;
      this._userAgentExpression = value.userAgentExpression;
    }
  }

  // cache_fill_bytes_expression - computed: false, optional: true, required: false
  private _cacheFillBytesExpression?: string; 
  public get cacheFillBytesExpression() {
    return this.getStringAttribute('cache_fill_bytes_expression');
  }
  public set cacheFillBytesExpression(value: string) {
    this._cacheFillBytesExpression = value;
  }
  public resetCacheFillBytesExpression() {
    this._cacheFillBytesExpression = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cacheFillBytesExpressionInput() {
    return this._cacheFillBytesExpression;
  }

  // cache_hit_expression - computed: false, optional: true, required: false
  private _cacheHitExpression?: string; 
  public get cacheHitExpression() {
    return this.getStringAttribute('cache_hit_expression');
  }
  public set cacheHitExpression(value: string) {
    this._cacheHitExpression = value;
  }
  public resetCacheHitExpression() {
    this._cacheHitExpression = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cacheHitExpressionInput() {
    return this._cacheHitExpression;
  }

  // cache_lookup_expression - computed: false, optional: true, required: false
  private _cacheLookupExpression?: string; 
  public get cacheLookupExpression() {
    return this.getStringAttribute('cache_lookup_expression');
  }
  public set cacheLookupExpression(value: string) {
    this._cacheLookupExpression = value;
  }
  public resetCacheLookupExpression() {
    this._cacheLookupExpression = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cacheLookupExpressionInput() {
    return this._cacheLookupExpression;
  }

  // cache_validated_expression - computed: false, optional: true, required: false
  private _cacheValidatedExpression?: string; 
  public get cacheValidatedExpression() {
    return this.getStringAttribute('cache_validated_expression');
  }
  public set cacheValidatedExpression(value: string) {
    this._cacheValidatedExpression = value;
  }
  public resetCacheValidatedExpression() {
    this._cacheValidatedExpression = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cacheValidatedExpressionInput() {
    return this._cacheValidatedExpression;
  }

  // concurrency - computed: true, optional: true, required: false
  private _concurrency?: number; 
  public get concurrency() {
    return this.getNumberAttribute('concurrency');
  }
  public set concurrency(value: number) {
    this._concurrency = value;
  }
  public resetConcurrency() {
    this._concurrency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get concurrencyInput() {
    return this._concurrency;
  }

  // connection_timeout - computed: true, optional: true, required: false
  private _connectionTimeout?: number; 
  public get connectionTimeout() {
    return this.getNumberAttribute('connection_timeout');
  }
  public set connectionTimeout(value: number) {
    this._connectionTimeout = value;
  }
  public resetConnectionTimeout() {
    this._connectionTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectionTimeoutInput() {
    return this._connectionTimeout;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // file_expression - computed: false, optional: true, required: false
  private _fileExpression?: string; 
  public get fileExpression() {
    return this.getStringAttribute('file_expression');
  }
  public set fileExpression(value: string) {
    this._fileExpression = value;
  }
  public resetFileExpression() {
    this._fileExpression = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fileExpressionInput() {
    return this._fileExpression;
  }

  // first_expression - computed: false, optional: true, required: false
  private _firstExpression?: string; 
  public get firstExpression() {
    return this.getStringAttribute('first_expression');
  }
  public set firstExpression(value: string) {
    this._firstExpression = value;
  }
  public resetFirstExpression() {
    this._firstExpression = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get firstExpressionInput() {
    return this._firstExpression;
  }

  // flush_period_sec - computed: true, optional: true, required: false
  private _flushPeriodSec?: number; 
  public get flushPeriodSec() {
    return this.getNumberAttribute('flush_period_sec');
  }
  public set flushPeriodSec(value: number) {
    this._flushPeriodSec = value;
  }
  public resetFlushPeriodSec() {
    this._flushPeriodSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get flushPeriodSecInput() {
    return this._flushPeriodSec;
  }

  // function_expression - computed: false, optional: true, required: false
  private _functionExpression?: string; 
  public get functionExpression() {
    return this.getStringAttribute('function_expression');
  }
  public set functionExpression(value: string) {
    this._functionExpression = value;
  }
  public resetFunctionExpression() {
    this._functionExpression = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get functionExpressionInput() {
    return this._functionExpression;
  }

  // google_auth_method - computed: true, optional: true, required: false
  private _googleAuthMethod?: string; 
  public get googleAuthMethod() {
    return this.getStringAttribute('google_auth_method');
  }
  public set googleAuthMethod(value: string) {
    this._googleAuthMethod = value;
  }
  public resetGoogleAuthMethod() {
    this._googleAuthMethod = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get googleAuthMethodInput() {
    return this._googleAuthMethod;
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // id_expression - computed: false, optional: true, required: false
  private _idExpression?: string; 
  public get idExpression() {
    return this.getStringAttribute('id_expression');
  }
  public set idExpression(value: string) {
    this._idExpression = value;
  }
  public resetIdExpression() {
    this._idExpression = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idExpressionInput() {
    return this._idExpression;
  }

  // index_expression - computed: false, optional: true, required: false
  private _indexExpression?: string; 
  public get indexExpression() {
    return this.getStringAttribute('index_expression');
  }
  public set indexExpression(value: string) {
    this._indexExpression = value;
  }
  public resetIndexExpression() {
    this._indexExpression = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get indexExpressionInput() {
    return this._indexExpression;
  }

  // insert_id_expression - computed: false, optional: true, required: false
  private _insertIdExpression?: string; 
  public get insertIdExpression() {
    return this.getStringAttribute('insert_id_expression');
  }
  public set insertIdExpression(value: string) {
    this._insertIdExpression = value;
  }
  public resetInsertIdExpression() {
    this._insertIdExpression = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get insertIdExpressionInput() {
    return this._insertIdExpression;
  }

  // last_expression - computed: false, optional: true, required: false
  private _lastExpression?: string; 
  public get lastExpression() {
    return this.getStringAttribute('last_expression');
  }
  public set lastExpression(value: string) {
    this._lastExpression = value;
  }
  public resetLastExpression() {
    this._lastExpression = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get lastExpressionInput() {
    return this._lastExpression;
  }

  // latency_expression - computed: false, optional: true, required: false
  private _latencyExpression?: string; 
  public get latencyExpression() {
    return this.getStringAttribute('latency_expression');
  }
  public set latencyExpression(value: string) {
    this._latencyExpression = value;
  }
  public resetLatencyExpression() {
    this._latencyExpression = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get latencyExpressionInput() {
    return this._latencyExpression;
  }

  // line_expression - computed: false, optional: true, required: false
  private _lineExpression?: string; 
  public get lineExpression() {
    return this.getStringAttribute('line_expression');
  }
  public set lineExpression(value: string) {
    this._lineExpression = value;
  }
  public resetLineExpression() {
    this._lineExpression = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get lineExpressionInput() {
    return this._lineExpression;
  }

  // log_labels - computed: false, optional: true, required: false
  private _logLabels = new DestinationOutputGoogleCloudLoggingLogLabelsList(this, "log_labels", false);
  public get logLabels() {
    return this._logLabels;
  }
  public putLogLabels(value: DestinationOutputGoogleCloudLoggingLogLabels[] | cdktf.IResolvable) {
    this._logLabels.internalValue = value;
  }
  public resetLogLabels() {
    this._logLabels.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get logLabelsInput() {
    return this._logLabels.internalValue;
  }

  // log_location_expression - computed: false, optional: false, required: true
  private _logLocationExpression?: string; 
  public get logLocationExpression() {
    return this.getStringAttribute('log_location_expression');
  }
  public set logLocationExpression(value: string) {
    this._logLocationExpression = value;
  }
  // Temporarily expose input value. Use with caution.
  public get logLocationExpressionInput() {
    return this._logLocationExpression;
  }

  // log_location_type - computed: false, optional: false, required: true
  private _logLocationType?: string; 
  public get logLocationType() {
    return this.getStringAttribute('log_location_type');
  }
  public set logLocationType(value: string) {
    this._logLocationType = value;
  }
  // Temporarily expose input value. Use with caution.
  public get logLocationTypeInput() {
    return this._logLocationType;
  }

  // log_name_expression - computed: false, optional: false, required: true
  private _logNameExpression?: string; 
  public get logNameExpression() {
    return this.getStringAttribute('log_name_expression');
  }
  public set logNameExpression(value: string) {
    this._logNameExpression = value;
  }
  // Temporarily expose input value. Use with caution.
  public get logNameExpressionInput() {
    return this._logNameExpression;
  }

  // max_payload_events - computed: true, optional: true, required: false
  private _maxPayloadEvents?: number; 
  public get maxPayloadEvents() {
    return this.getNumberAttribute('max_payload_events');
  }
  public set maxPayloadEvents(value: number) {
    this._maxPayloadEvents = value;
  }
  public resetMaxPayloadEvents() {
    this._maxPayloadEvents = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxPayloadEventsInput() {
    return this._maxPayloadEvents;
  }

  // max_payload_size_kb - computed: true, optional: true, required: false
  private _maxPayloadSizeKb?: number; 
  public get maxPayloadSizeKb() {
    return this.getNumberAttribute('max_payload_size_kb');
  }
  public set maxPayloadSizeKb(value: number) {
    this._maxPayloadSizeKb = value;
  }
  public resetMaxPayloadSizeKb() {
    this._maxPayloadSizeKb = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxPayloadSizeKbInput() {
    return this._maxPayloadSizeKb;
  }

  // on_backpressure - computed: true, optional: true, required: false
  private _onBackpressure?: string; 
  public get onBackpressure() {
    return this.getStringAttribute('on_backpressure');
  }
  public set onBackpressure(value: string) {
    this._onBackpressure = value;
  }
  public resetOnBackpressure() {
    this._onBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get onBackpressureInput() {
    return this._onBackpressure;
  }

  // payload_expression - computed: false, optional: true, required: false
  private _payloadExpression?: string; 
  public get payloadExpression() {
    return this.getStringAttribute('payload_expression');
  }
  public set payloadExpression(value: string) {
    this._payloadExpression = value;
  }
  public resetPayloadExpression() {
    this._payloadExpression = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get payloadExpressionInput() {
    return this._payloadExpression;
  }

  // payload_format - computed: true, optional: true, required: false
  private _payloadFormat?: string; 
  public get payloadFormat() {
    return this.getStringAttribute('payload_format');
  }
  public set payloadFormat(value: string) {
    this._payloadFormat = value;
  }
  public resetPayloadFormat() {
    this._payloadFormat = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get payloadFormatInput() {
    return this._payloadFormat;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // pq_compress - computed: true, optional: true, required: false
  private _pqCompress?: string; 
  public get pqCompress() {
    return this.getStringAttribute('pq_compress');
  }
  public set pqCompress(value: string) {
    this._pqCompress = value;
  }
  public resetPqCompress() {
    this._pqCompress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqCompressInput() {
    return this._pqCompress;
  }

  // pq_controls - computed: false, optional: true, required: false
  private _pqControls = new DestinationOutputGoogleCloudLoggingPqControlsOutputReference(this, "pq_controls");
  public get pqControls() {
    return this._pqControls;
  }
  public putPqControls(value: DestinationOutputGoogleCloudLoggingPqControls) {
    this._pqControls.internalValue = value;
  }
  public resetPqControls() {
    this._pqControls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqControlsInput() {
    return this._pqControls.internalValue;
  }

  // pq_max_file_size - computed: true, optional: true, required: false
  private _pqMaxFileSize?: string; 
  public get pqMaxFileSize() {
    return this.getStringAttribute('pq_max_file_size');
  }
  public set pqMaxFileSize(value: string) {
    this._pqMaxFileSize = value;
  }
  public resetPqMaxFileSize() {
    this._pqMaxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxFileSizeInput() {
    return this._pqMaxFileSize;
  }

  // pq_max_size - computed: true, optional: true, required: false
  private _pqMaxSize?: string; 
  public get pqMaxSize() {
    return this.getStringAttribute('pq_max_size');
  }
  public set pqMaxSize(value: string) {
    this._pqMaxSize = value;
  }
  public resetPqMaxSize() {
    this._pqMaxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxSizeInput() {
    return this._pqMaxSize;
  }

  // pq_mode - computed: true, optional: true, required: false
  private _pqMode?: string; 
  public get pqMode() {
    return this.getStringAttribute('pq_mode');
  }
  public set pqMode(value: string) {
    this._pqMode = value;
  }
  public resetPqMode() {
    this._pqMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqModeInput() {
    return this._pqMode;
  }

  // pq_on_backpressure - computed: true, optional: true, required: false
  private _pqOnBackpressure?: string; 
  public get pqOnBackpressure() {
    return this.getStringAttribute('pq_on_backpressure');
  }
  public set pqOnBackpressure(value: string) {
    this._pqOnBackpressure = value;
  }
  public resetPqOnBackpressure() {
    this._pqOnBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqOnBackpressureInput() {
    return this._pqOnBackpressure;
  }

  // pq_path - computed: true, optional: true, required: false
  private _pqPath?: string; 
  public get pqPath() {
    return this.getStringAttribute('pq_path');
  }
  public set pqPath(value: string) {
    this._pqPath = value;
  }
  public resetPqPath() {
    this._pqPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqPathInput() {
    return this._pqPath;
  }

  // producer_expression - computed: false, optional: true, required: false
  private _producerExpression?: string; 
  public get producerExpression() {
    return this.getStringAttribute('producer_expression');
  }
  public set producerExpression(value: string) {
    this._producerExpression = value;
  }
  public resetProducerExpression() {
    this._producerExpression = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get producerExpressionInput() {
    return this._producerExpression;
  }

  // protocol_expression - computed: false, optional: true, required: false
  private _protocolExpression?: string; 
  public get protocolExpression() {
    return this.getStringAttribute('protocol_expression');
  }
  public set protocolExpression(value: string) {
    this._protocolExpression = value;
  }
  public resetProtocolExpression() {
    this._protocolExpression = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get protocolExpressionInput() {
    return this._protocolExpression;
  }

  // referer_expression - computed: false, optional: true, required: false
  private _refererExpression?: string; 
  public get refererExpression() {
    return this.getStringAttribute('referer_expression');
  }
  public set refererExpression(value: string) {
    this._refererExpression = value;
  }
  public resetRefererExpression() {
    this._refererExpression = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get refererExpressionInput() {
    return this._refererExpression;
  }

  // remote_ip_expression - computed: false, optional: true, required: false
  private _remoteIpExpression?: string; 
  public get remoteIpExpression() {
    return this.getStringAttribute('remote_ip_expression');
  }
  public set remoteIpExpression(value: string) {
    this._remoteIpExpression = value;
  }
  public resetRemoteIpExpression() {
    this._remoteIpExpression = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get remoteIpExpressionInput() {
    return this._remoteIpExpression;
  }

  // request_method_expression - computed: false, optional: true, required: false
  private _requestMethodExpression?: string; 
  public get requestMethodExpression() {
    return this.getStringAttribute('request_method_expression');
  }
  public set requestMethodExpression(value: string) {
    this._requestMethodExpression = value;
  }
  public resetRequestMethodExpression() {
    this._requestMethodExpression = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestMethodExpressionInput() {
    return this._requestMethodExpression;
  }

  // request_size_expression - computed: false, optional: true, required: false
  private _requestSizeExpression?: string; 
  public get requestSizeExpression() {
    return this.getStringAttribute('request_size_expression');
  }
  public set requestSizeExpression(value: string) {
    this._requestSizeExpression = value;
  }
  public resetRequestSizeExpression() {
    this._requestSizeExpression = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestSizeExpressionInput() {
    return this._requestSizeExpression;
  }

  // request_url_expression - computed: false, optional: true, required: false
  private _requestUrlExpression?: string; 
  public get requestUrlExpression() {
    return this.getStringAttribute('request_url_expression');
  }
  public set requestUrlExpression(value: string) {
    this._requestUrlExpression = value;
  }
  public resetRequestUrlExpression() {
    this._requestUrlExpression = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestUrlExpressionInput() {
    return this._requestUrlExpression;
  }

  // resource_type_expression - computed: false, optional: true, required: false
  private _resourceTypeExpression?: string; 
  public get resourceTypeExpression() {
    return this.getStringAttribute('resource_type_expression');
  }
  public set resourceTypeExpression(value: string) {
    this._resourceTypeExpression = value;
  }
  public resetResourceTypeExpression() {
    this._resourceTypeExpression = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get resourceTypeExpressionInput() {
    return this._resourceTypeExpression;
  }

  // resource_type_labels - computed: false, optional: true, required: false
  private _resourceTypeLabels = new DestinationOutputGoogleCloudLoggingResourceTypeLabelsList(this, "resource_type_labels", false);
  public get resourceTypeLabels() {
    return this._resourceTypeLabels;
  }
  public putResourceTypeLabels(value: DestinationOutputGoogleCloudLoggingResourceTypeLabels[] | cdktf.IResolvable) {
    this._resourceTypeLabels.internalValue = value;
  }
  public resetResourceTypeLabels() {
    this._resourceTypeLabels.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get resourceTypeLabelsInput() {
    return this._resourceTypeLabels.internalValue;
  }

  // response_size_expression - computed: false, optional: true, required: false
  private _responseSizeExpression?: string; 
  public get responseSizeExpression() {
    return this.getStringAttribute('response_size_expression');
  }
  public set responseSizeExpression(value: string) {
    this._responseSizeExpression = value;
  }
  public resetResponseSizeExpression() {
    this._responseSizeExpression = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get responseSizeExpressionInput() {
    return this._responseSizeExpression;
  }

  // secret - computed: false, optional: true, required: false
  private _secret?: string; 
  public get secret() {
    return this.getStringAttribute('secret');
  }
  public set secret(value: string) {
    this._secret = value;
  }
  public resetSecret() {
    this._secret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretInput() {
    return this._secret;
  }

  // server_ip_expression - computed: false, optional: true, required: false
  private _serverIpExpression?: string; 
  public get serverIpExpression() {
    return this.getStringAttribute('server_ip_expression');
  }
  public set serverIpExpression(value: string) {
    this._serverIpExpression = value;
  }
  public resetServerIpExpression() {
    this._serverIpExpression = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serverIpExpressionInput() {
    return this._serverIpExpression;
  }

  // service_account_credentials - computed: false, optional: true, required: false
  private _serviceAccountCredentials?: string; 
  public get serviceAccountCredentials() {
    return this.getStringAttribute('service_account_credentials');
  }
  public set serviceAccountCredentials(value: string) {
    this._serviceAccountCredentials = value;
  }
  public resetServiceAccountCredentials() {
    this._serviceAccountCredentials = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serviceAccountCredentialsInput() {
    return this._serviceAccountCredentials;
  }

  // severity_expression - computed: false, optional: true, required: false
  private _severityExpression?: string; 
  public get severityExpression() {
    return this.getStringAttribute('severity_expression');
  }
  public set severityExpression(value: string) {
    this._severityExpression = value;
  }
  public resetSeverityExpression() {
    this._severityExpression = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get severityExpressionInput() {
    return this._severityExpression;
  }

  // span_id_expression - computed: false, optional: true, required: false
  private _spanIdExpression?: string; 
  public get spanIdExpression() {
    return this.getStringAttribute('span_id_expression');
  }
  public set spanIdExpression(value: string) {
    this._spanIdExpression = value;
  }
  public resetSpanIdExpression() {
    this._spanIdExpression = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get spanIdExpressionInput() {
    return this._spanIdExpression;
  }

  // status_expression - computed: false, optional: true, required: false
  private _statusExpression?: string; 
  public get statusExpression() {
    return this.getStringAttribute('status_expression');
  }
  public set statusExpression(value: string) {
    this._statusExpression = value;
  }
  public resetStatusExpression() {
    this._statusExpression = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get statusExpressionInput() {
    return this._statusExpression;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // system_fields - computed: true, optional: true, required: false
  private _systemFields?: string[]; 
  public get systemFields() {
    return this.getListAttribute('system_fields');
  }
  public set systemFields(value: string[]) {
    this._systemFields = value;
  }
  public resetSystemFields() {
    this._systemFields = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get systemFieldsInput() {
    return this._systemFields;
  }

  // throttle_rate_req_per_sec - computed: false, optional: true, required: false
  private _throttleRateReqPerSec?: number; 
  public get throttleRateReqPerSec() {
    return this.getNumberAttribute('throttle_rate_req_per_sec');
  }
  public set throttleRateReqPerSec(value: number) {
    this._throttleRateReqPerSec = value;
  }
  public resetThrottleRateReqPerSec() {
    this._throttleRateReqPerSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get throttleRateReqPerSecInput() {
    return this._throttleRateReqPerSec;
  }

  // timeout_sec - computed: true, optional: true, required: false
  private _timeoutSec?: number; 
  public get timeoutSec() {
    return this.getNumberAttribute('timeout_sec');
  }
  public set timeoutSec(value: number) {
    this._timeoutSec = value;
  }
  public resetTimeoutSec() {
    this._timeoutSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutSecInput() {
    return this._timeoutSec;
  }

  // total_memory_limit_kb - computed: false, optional: true, required: false
  private _totalMemoryLimitKb?: number; 
  public get totalMemoryLimitKb() {
    return this.getNumberAttribute('total_memory_limit_kb');
  }
  public set totalMemoryLimitKb(value: number) {
    this._totalMemoryLimitKb = value;
  }
  public resetTotalMemoryLimitKb() {
    this._totalMemoryLimitKb = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get totalMemoryLimitKbInput() {
    return this._totalMemoryLimitKb;
  }

  // total_splits_expression - computed: false, optional: true, required: false
  private _totalSplitsExpression?: string; 
  public get totalSplitsExpression() {
    return this.getStringAttribute('total_splits_expression');
  }
  public set totalSplitsExpression(value: string) {
    this._totalSplitsExpression = value;
  }
  public resetTotalSplitsExpression() {
    this._totalSplitsExpression = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get totalSplitsExpressionInput() {
    return this._totalSplitsExpression;
  }

  // trace_expression - computed: false, optional: true, required: false
  private _traceExpression?: string; 
  public get traceExpression() {
    return this.getStringAttribute('trace_expression');
  }
  public set traceExpression(value: string) {
    this._traceExpression = value;
  }
  public resetTraceExpression() {
    this._traceExpression = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get traceExpressionInput() {
    return this._traceExpression;
  }

  // trace_sampled_expression - computed: false, optional: true, required: false
  private _traceSampledExpression?: string; 
  public get traceSampledExpression() {
    return this.getStringAttribute('trace_sampled_expression');
  }
  public set traceSampledExpression(value: string) {
    this._traceSampledExpression = value;
  }
  public resetTraceSampledExpression() {
    this._traceSampledExpression = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get traceSampledExpressionInput() {
    return this._traceSampledExpression;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // uid_expression - computed: false, optional: true, required: false
  private _uidExpression?: string; 
  public get uidExpression() {
    return this.getStringAttribute('uid_expression');
  }
  public set uidExpression(value: string) {
    this._uidExpression = value;
  }
  public resetUidExpression() {
    this._uidExpression = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get uidExpressionInput() {
    return this._uidExpression;
  }

  // user_agent_expression - computed: false, optional: true, required: false
  private _userAgentExpression?: string; 
  public get userAgentExpression() {
    return this.getStringAttribute('user_agent_expression');
  }
  public set userAgentExpression(value: string) {
    this._userAgentExpression = value;
  }
  public resetUserAgentExpression() {
    this._userAgentExpression = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get userAgentExpressionInput() {
    return this._userAgentExpression;
  }
}
export interface DestinationOutputGoogleCloudStorageKeyValueMetadata {
  /**
  * Default: ""
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#key Destination#key}
  */
  readonly key?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#value Destination#value}
  */
  readonly value: string;
}

export function destinationOutputGoogleCloudStorageKeyValueMetadataToTerraform(struct?: DestinationOutputGoogleCloudStorageKeyValueMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    key: cdktf.stringToTerraform(struct!.key),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function destinationOutputGoogleCloudStorageKeyValueMetadataToHclTerraform(struct?: DestinationOutputGoogleCloudStorageKeyValueMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    key: {
      value: cdktf.stringToHclTerraform(struct!.key),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputGoogleCloudStorageKeyValueMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DestinationOutputGoogleCloudStorageKeyValueMetadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._key !== undefined) {
      hasAnyValues = true;
      internalValueResult.key = this._key;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputGoogleCloudStorageKeyValueMetadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._key = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._key = value.key;
      this._value = value.value;
    }
  }

  // key - computed: true, optional: true, required: false
  private _key?: string; 
  public get key() {
    return this.getStringAttribute('key');
  }
  public set key(value: string) {
    this._key = value;
  }
  public resetKey() {
    this._key = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyInput() {
    return this._key;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DestinationOutputGoogleCloudStorageKeyValueMetadataList extends cdktf.ComplexList {
  public internalValue? : DestinationOutputGoogleCloudStorageKeyValueMetadata[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DestinationOutputGoogleCloudStorageKeyValueMetadataOutputReference {
    return new DestinationOutputGoogleCloudStorageKeyValueMetadataOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DestinationOutputGoogleCloudStorage {
  /**
  * Add the Output ID value to staging location. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#add_id_to_stage_path Destination#add_id_to_stage_path}
  */
  readonly addIdToStagePath?: boolean | cdktf.IResolvable;
  /**
  * Automatically calculate the schema based on the events of each Parquet file generated. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#automatic_schema Destination#automatic_schema}
  */
  readonly automaticSchema?: boolean | cdktf.IResolvable;
  /**
  * HMAC access key. This value can be a constant or a JavaScript expression, such as `${C.env.GCS_ACCESS_KEY}`.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#aws_api_key Destination#aws_api_key}
  */
  readonly awsApiKey?: string;
  /**
  * Default: "manual"; must be one of ["auto", "manual", "secret"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#aws_authentication_method Destination#aws_authentication_method}
  */
  readonly awsAuthenticationMethod?: string;
  /**
  * Select or create a stored secret that references your access key and secret key
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#aws_secret Destination#aws_secret}
  */
  readonly awsSecret?: string;
  /**
  * HMAC secret. This value can be a constant or a JavaScript expression, such as `${C.env.GCS_SECRET}`.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#aws_secret_key Destination#aws_secret_key}
  */
  readonly awsSecretKey?: string;
  /**
  * JavaScript expression to define the output filename prefix (can be constant). Default: "`CriblOut`"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#base_file_name Destination#base_file_name}
  */
  readonly baseFileName?: string;
  /**
  * Name of the destination bucket. This value can be a constant or a JavaScript expression that can only be evaluated at init time. Example of referencing a Global Variable: `myBucket-${C.vars.myVar}`.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#bucket Destination#bucket}
  */
  readonly bucket: string;
  /**
  * Data compression format to apply to HTTP content before it is delivered. Default: "gzip"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#compress Destination#compress}
  */
  readonly compress?: string;
  /**
  * Compression level to apply before moving files to final destination. Default: "best_speed"; must be one of ["best_speed", "normal", "best_compression"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#compression_level Destination#compression_level}
  */
  readonly compressionLevel?: string;
  /**
  * If a file fails to move to its final destination after the maximum number of retries, move it to a designated directory to prevent further errors. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#deadletter_enabled Destination#deadletter_enabled}
  */
  readonly deadletterEnabled?: boolean | cdktf.IResolvable;
  /**
  * Storage location for files that fail to reach their final destination after maximum retries are exceeded. Default: "$CRIBL_HOME/state/outputs/dead-letter"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#deadletter_path Destination#deadletter_path}
  */
  readonly deadletterPath?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#description Destination#description}
  */
  readonly description?: string;
  /**
  * Prefix to append to files before uploading. Must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can be evaluated only at init time. Example referencing a Global Variable: `myKeyPrefix-${C.vars.myVar}`. Default: ""
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#dest_path Destination#dest_path}
  */
  readonly destPath?: string;
  /**
  * How frequently, in seconds, to clean up empty directories. Default: 300
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#empty_dir_cleanup_sec Destination#empty_dir_cleanup_sec}
  */
  readonly emptyDirCleanupSec?: number;
  /**
  * Parquet tools can use the checksum of a Parquet page to verify data integrity. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#enable_page_checksum Destination#enable_page_checksum}
  */
  readonly enablePageChecksum?: boolean | cdktf.IResolvable;
  /**
  * Statistics profile an entire file in terms of minimum/maximum values within data, numbers of nulls, etc. You can use Parquet tools to view statistics. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#enable_statistics Destination#enable_statistics}
  */
  readonly enableStatistics?: boolean | cdktf.IResolvable;
  /**
  * One page index contains statistics for one data page. Parquet readers use statistics to enable page skipping. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#enable_write_page_index Destination#enable_write_page_index}
  */
  readonly enableWritePageIndex?: boolean | cdktf.IResolvable;
  /**
  * Google Cloud Storage service endpoint. Default: "https://storage.googleapis.com"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#endpoint Destination#endpoint}
  */
  readonly endpoint?: string;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#environment Destination#environment}
  */
  readonly environment?: string;
  /**
  * JavaScript expression to define the output filename suffix (can be constant).  The `__format` variable refers to the value of the `Data format` field (`json` or `raw`).  The `__compression` field refers to the kind of compression being used (`none` or `gzip`). Default: "`.${C.env[\"CRIBL_WORKER_ID\"]}.${__format}${__compression === \"gzip\" ? \".gz\" : \"\"}`"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#file_name_suffix Destination#file_name_suffix}
  */
  readonly fileNameSuffix?: string;
  /**
  * Format of the output data. Default: "json"; must be one of ["json", "raw", "parquet"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#format Destination#format}
  */
  readonly format?: string;
  /**
  * If set, this line will be written to the beginning of each output file. Default: ""
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#header_line Destination#header_line}
  */
  readonly headerLine?: string;
  /**
  * Unique ID for this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#id Destination#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * The metadata of files the Destination writes will include the properties you add here as key-value pairs. Useful for tagging. Examples: "key":"OCSF Event Class", "value":"9001"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#key_value_metadata Destination#key_value_metadata}
  */
  readonly keyValueMetadata?: DestinationOutputGoogleCloudStorageKeyValueMetadata[] | cdktf.IResolvable;
  /**
  * Maximum amount of time to keep inactive files open. Files open for longer than this will be closed and moved to final output location. Default: 30
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#max_file_idle_time_sec Destination#max_file_idle_time_sec}
  */
  readonly maxFileIdleTimeSec?: number;
  /**
  * Maximum amount of time to write to a file. Files open for longer than this will be closed and moved to final output location. Default: 300
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#max_file_open_time_sec Destination#max_file_open_time_sec}
  */
  readonly maxFileOpenTimeSec?: number;
  /**
  * Maximum uncompressed output file size. Files of this size will be closed and moved to final output location. Default: 32
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#max_file_size_mb Destination#max_file_size_mb}
  */
  readonly maxFileSizeMb?: number;
  /**
  * Maximum number of files to keep open concurrently. When exceeded, @{product} will close the oldest open files and move them to the final output location. Default: 100
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#max_open_files Destination#max_open_files}
  */
  readonly maxOpenFiles?: number;
  /**
  * The maximum number of times a file will attempt to move to its final destination before being dead-lettered. Default: 20
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#max_retry_num Destination#max_retry_num}
  */
  readonly maxRetryNum?: number;
  /**
  * Object ACL to assign to uploaded objects. Default: "private"; must be one of ["private", "bucket-owner-read", "bucket-owner-full-control", "project-private", "authenticated-read", "public-read"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#object_acl Destination#object_acl}
  */
  readonly objectAcl?: string;
  /**
  * How to handle events when all receivers are exerting backpressure. Default: "block"; must be one of ["block", "drop"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#on_backpressure Destination#on_backpressure}
  */
  readonly onBackpressure?: string;
  /**
  * How to handle events when disk space is below the global 'Min free disk space' limit. Default: "block"; must be one of ["block", "drop"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#on_disk_full_backpressure Destination#on_disk_full_backpressure}
  */
  readonly onDiskFullBackpressure?: string;
  /**
  * Serialization format of data pages. Note that some reader implementations use Data page V2's attributes to work more efficiently, while others ignore it. Default: "DATA_PAGE_V2"; must be one of ["DATA_PAGE_V1", "DATA_PAGE_V2"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#parquet_data_page_version Destination#parquet_data_page_version}
  */
  readonly parquetDataPageVersion?: string;
  /**
  * Target memory size for page segments, such as 1MB or 128MB. Generally, lower values improve reading speed, while higher values improve compression. Default: "1MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#parquet_page_size Destination#parquet_page_size}
  */
  readonly parquetPageSize?: string;
  /**
  * The number of rows that every group will contain. The final group can contain a smaller number of rows. Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#parquet_row_group_length Destination#parquet_row_group_length}
  */
  readonly parquetRowGroupLength?: number;
  /**
  * Determines which data types are supported and how they are represented. Default: "PARQUET_2_6"; must be one of ["PARQUET_1_0", "PARQUET_2_4", "PARQUET_2_6"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#parquet_version Destination#parquet_version}
  */
  readonly parquetVersion?: string;
  /**
  * JavaScript expression defining how files are partitioned and organized. Default is date-based. If blank, Stream will fall back to the event's __partition field value – if present – otherwise to each location's root directory. Default: "C.Time.strftime(_time ? _time : Date.now()/1000, '%Y/%m/%d')"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#partition_expr Destination#partition_expr}
  */
  readonly partitionExpr?: string;
  /**
  * Pipeline to process data before sending out to this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pipeline Destination#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Region where the bucket is located
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#region Destination#region}
  */
  readonly region: string;
  /**
  * Reject certificates that cannot be verified against a valid CA, such as self-signed certificates. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#reject_unauthorized Destination#reject_unauthorized}
  */
  readonly rejectUnauthorized?: boolean | cdktf.IResolvable;
  /**
  * Remove empty staging directories after moving files. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#remove_empty_dirs Destination#remove_empty_dirs}
  */
  readonly removeEmptyDirs?: boolean | cdktf.IResolvable;
  /**
  * Reuse connections between requests, which can improve performance. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#reuse_connections Destination#reuse_connections}
  */
  readonly reuseConnections?: boolean | cdktf.IResolvable;
  /**
  * Log up to 3 rows that @{product} skips due to data mismatch
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#should_log_invalid_rows Destination#should_log_invalid_rows}
  */
  readonly shouldLogInvalidRows?: boolean | cdktf.IResolvable;
  /**
  * Signature version to use for signing Google Cloud Storage requests. Default: "v4"; must be one of ["v2", "v4"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#signature_version Destination#signature_version}
  */
  readonly signatureVersion?: string;
  /**
  * Filesystem location in which to buffer files, before compressing and moving to final destination. Use performant and stable storage. Default: "$CRIBL_HOME/state/outputs/staging"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#stage_path Destination#stage_path}
  */
  readonly stagePath?: string;
  /**
  * Storage class to select for uploaded objects. must be one of ["STANDARD", "NEARLINE", "COLDLINE", "ARCHIVE"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#storage_class Destination#storage_class}
  */
  readonly storageClass?: string;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#streamtags Destination#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Fields to automatically add to events, such as cribl_pipe. Supports wildcards. Default: ["cribl_pipe"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#system_fields Destination#system_fields}
  */
  readonly systemFields?: string[];
  /**
  * must be "google_cloud_storage"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#type Destination#type}
  */
  readonly type?: string;
  /**
  * Disable if you can access files within the bucket but not the bucket itself. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#verify_permissions Destination#verify_permissions}
  */
  readonly verifyPermissions?: boolean | cdktf.IResolvable;
  /**
  * Buffer size used to write to a file. Default: 64
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#write_high_water_mark Destination#write_high_water_mark}
  */
  readonly writeHighWaterMark?: number;
}

export function destinationOutputGoogleCloudStorageToTerraform(struct?: DestinationOutputGoogleCloudStorage | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    add_id_to_stage_path: cdktf.booleanToTerraform(struct!.addIdToStagePath),
    automatic_schema: cdktf.booleanToTerraform(struct!.automaticSchema),
    aws_api_key: cdktf.stringToTerraform(struct!.awsApiKey),
    aws_authentication_method: cdktf.stringToTerraform(struct!.awsAuthenticationMethod),
    aws_secret: cdktf.stringToTerraform(struct!.awsSecret),
    aws_secret_key: cdktf.stringToTerraform(struct!.awsSecretKey),
    base_file_name: cdktf.stringToTerraform(struct!.baseFileName),
    bucket: cdktf.stringToTerraform(struct!.bucket),
    compress: cdktf.stringToTerraform(struct!.compress),
    compression_level: cdktf.stringToTerraform(struct!.compressionLevel),
    deadletter_enabled: cdktf.booleanToTerraform(struct!.deadletterEnabled),
    deadletter_path: cdktf.stringToTerraform(struct!.deadletterPath),
    description: cdktf.stringToTerraform(struct!.description),
    dest_path: cdktf.stringToTerraform(struct!.destPath),
    empty_dir_cleanup_sec: cdktf.numberToTerraform(struct!.emptyDirCleanupSec),
    enable_page_checksum: cdktf.booleanToTerraform(struct!.enablePageChecksum),
    enable_statistics: cdktf.booleanToTerraform(struct!.enableStatistics),
    enable_write_page_index: cdktf.booleanToTerraform(struct!.enableWritePageIndex),
    endpoint: cdktf.stringToTerraform(struct!.endpoint),
    environment: cdktf.stringToTerraform(struct!.environment),
    file_name_suffix: cdktf.stringToTerraform(struct!.fileNameSuffix),
    format: cdktf.stringToTerraform(struct!.format),
    header_line: cdktf.stringToTerraform(struct!.headerLine),
    id: cdktf.stringToTerraform(struct!.id),
    key_value_metadata: cdktf.listMapper(destinationOutputGoogleCloudStorageKeyValueMetadataToTerraform, false)(struct!.keyValueMetadata),
    max_file_idle_time_sec: cdktf.numberToTerraform(struct!.maxFileIdleTimeSec),
    max_file_open_time_sec: cdktf.numberToTerraform(struct!.maxFileOpenTimeSec),
    max_file_size_mb: cdktf.numberToTerraform(struct!.maxFileSizeMb),
    max_open_files: cdktf.numberToTerraform(struct!.maxOpenFiles),
    max_retry_num: cdktf.numberToTerraform(struct!.maxRetryNum),
    object_acl: cdktf.stringToTerraform(struct!.objectAcl),
    on_backpressure: cdktf.stringToTerraform(struct!.onBackpressure),
    on_disk_full_backpressure: cdktf.stringToTerraform(struct!.onDiskFullBackpressure),
    parquet_data_page_version: cdktf.stringToTerraform(struct!.parquetDataPageVersion),
    parquet_page_size: cdktf.stringToTerraform(struct!.parquetPageSize),
    parquet_row_group_length: cdktf.numberToTerraform(struct!.parquetRowGroupLength),
    parquet_version: cdktf.stringToTerraform(struct!.parquetVersion),
    partition_expr: cdktf.stringToTerraform(struct!.partitionExpr),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    region: cdktf.stringToTerraform(struct!.region),
    reject_unauthorized: cdktf.booleanToTerraform(struct!.rejectUnauthorized),
    remove_empty_dirs: cdktf.booleanToTerraform(struct!.removeEmptyDirs),
    reuse_connections: cdktf.booleanToTerraform(struct!.reuseConnections),
    should_log_invalid_rows: cdktf.booleanToTerraform(struct!.shouldLogInvalidRows),
    signature_version: cdktf.stringToTerraform(struct!.signatureVersion),
    stage_path: cdktf.stringToTerraform(struct!.stagePath),
    storage_class: cdktf.stringToTerraform(struct!.storageClass),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    system_fields: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.systemFields),
    type: cdktf.stringToTerraform(struct!.type),
    verify_permissions: cdktf.booleanToTerraform(struct!.verifyPermissions),
    write_high_water_mark: cdktf.numberToTerraform(struct!.writeHighWaterMark),
  }
}


export function destinationOutputGoogleCloudStorageToHclTerraform(struct?: DestinationOutputGoogleCloudStorage | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    add_id_to_stage_path: {
      value: cdktf.booleanToHclTerraform(struct!.addIdToStagePath),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    automatic_schema: {
      value: cdktf.booleanToHclTerraform(struct!.automaticSchema),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    aws_api_key: {
      value: cdktf.stringToHclTerraform(struct!.awsApiKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    aws_authentication_method: {
      value: cdktf.stringToHclTerraform(struct!.awsAuthenticationMethod),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    aws_secret: {
      value: cdktf.stringToHclTerraform(struct!.awsSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    aws_secret_key: {
      value: cdktf.stringToHclTerraform(struct!.awsSecretKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    base_file_name: {
      value: cdktf.stringToHclTerraform(struct!.baseFileName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    bucket: {
      value: cdktf.stringToHclTerraform(struct!.bucket),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    compress: {
      value: cdktf.stringToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    compression_level: {
      value: cdktf.stringToHclTerraform(struct!.compressionLevel),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    deadletter_enabled: {
      value: cdktf.booleanToHclTerraform(struct!.deadletterEnabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    deadletter_path: {
      value: cdktf.stringToHclTerraform(struct!.deadletterPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    dest_path: {
      value: cdktf.stringToHclTerraform(struct!.destPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    empty_dir_cleanup_sec: {
      value: cdktf.numberToHclTerraform(struct!.emptyDirCleanupSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    enable_page_checksum: {
      value: cdktf.booleanToHclTerraform(struct!.enablePageChecksum),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    enable_statistics: {
      value: cdktf.booleanToHclTerraform(struct!.enableStatistics),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    enable_write_page_index: {
      value: cdktf.booleanToHclTerraform(struct!.enableWritePageIndex),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    endpoint: {
      value: cdktf.stringToHclTerraform(struct!.endpoint),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    file_name_suffix: {
      value: cdktf.stringToHclTerraform(struct!.fileNameSuffix),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    format: {
      value: cdktf.stringToHclTerraform(struct!.format),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    header_line: {
      value: cdktf.stringToHclTerraform(struct!.headerLine),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    key_value_metadata: {
      value: cdktf.listMapperHcl(destinationOutputGoogleCloudStorageKeyValueMetadataToHclTerraform, false)(struct!.keyValueMetadata),
      isBlock: true,
      type: "list",
      storageClassType: "DestinationOutputGoogleCloudStorageKeyValueMetadataList",
    },
    max_file_idle_time_sec: {
      value: cdktf.numberToHclTerraform(struct!.maxFileIdleTimeSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_file_open_time_sec: {
      value: cdktf.numberToHclTerraform(struct!.maxFileOpenTimeSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_file_size_mb: {
      value: cdktf.numberToHclTerraform(struct!.maxFileSizeMb),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_open_files: {
      value: cdktf.numberToHclTerraform(struct!.maxOpenFiles),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_retry_num: {
      value: cdktf.numberToHclTerraform(struct!.maxRetryNum),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    object_acl: {
      value: cdktf.stringToHclTerraform(struct!.objectAcl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.onBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    on_disk_full_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.onDiskFullBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    parquet_data_page_version: {
      value: cdktf.stringToHclTerraform(struct!.parquetDataPageVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    parquet_page_size: {
      value: cdktf.stringToHclTerraform(struct!.parquetPageSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    parquet_row_group_length: {
      value: cdktf.numberToHclTerraform(struct!.parquetRowGroupLength),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    parquet_version: {
      value: cdktf.stringToHclTerraform(struct!.parquetVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    partition_expr: {
      value: cdktf.stringToHclTerraform(struct!.partitionExpr),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    region: {
      value: cdktf.stringToHclTerraform(struct!.region),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reject_unauthorized: {
      value: cdktf.booleanToHclTerraform(struct!.rejectUnauthorized),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    remove_empty_dirs: {
      value: cdktf.booleanToHclTerraform(struct!.removeEmptyDirs),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    reuse_connections: {
      value: cdktf.booleanToHclTerraform(struct!.reuseConnections),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    should_log_invalid_rows: {
      value: cdktf.booleanToHclTerraform(struct!.shouldLogInvalidRows),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    signature_version: {
      value: cdktf.stringToHclTerraform(struct!.signatureVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    stage_path: {
      value: cdktf.stringToHclTerraform(struct!.stagePath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    storage_class: {
      value: cdktf.stringToHclTerraform(struct!.storageClass),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    system_fields: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.systemFields),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    verify_permissions: {
      value: cdktf.booleanToHclTerraform(struct!.verifyPermissions),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    write_high_water_mark: {
      value: cdktf.numberToHclTerraform(struct!.writeHighWaterMark),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputGoogleCloudStorageOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DestinationOutputGoogleCloudStorage | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._addIdToStagePath !== undefined) {
      hasAnyValues = true;
      internalValueResult.addIdToStagePath = this._addIdToStagePath;
    }
    if (this._automaticSchema !== undefined) {
      hasAnyValues = true;
      internalValueResult.automaticSchema = this._automaticSchema;
    }
    if (this._awsApiKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.awsApiKey = this._awsApiKey;
    }
    if (this._awsAuthenticationMethod !== undefined) {
      hasAnyValues = true;
      internalValueResult.awsAuthenticationMethod = this._awsAuthenticationMethod;
    }
    if (this._awsSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.awsSecret = this._awsSecret;
    }
    if (this._awsSecretKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.awsSecretKey = this._awsSecretKey;
    }
    if (this._baseFileName !== undefined) {
      hasAnyValues = true;
      internalValueResult.baseFileName = this._baseFileName;
    }
    if (this._bucket !== undefined) {
      hasAnyValues = true;
      internalValueResult.bucket = this._bucket;
    }
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._compressionLevel !== undefined) {
      hasAnyValues = true;
      internalValueResult.compressionLevel = this._compressionLevel;
    }
    if (this._deadletterEnabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.deadletterEnabled = this._deadletterEnabled;
    }
    if (this._deadletterPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.deadletterPath = this._deadletterPath;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._destPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.destPath = this._destPath;
    }
    if (this._emptyDirCleanupSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.emptyDirCleanupSec = this._emptyDirCleanupSec;
    }
    if (this._enablePageChecksum !== undefined) {
      hasAnyValues = true;
      internalValueResult.enablePageChecksum = this._enablePageChecksum;
    }
    if (this._enableStatistics !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableStatistics = this._enableStatistics;
    }
    if (this._enableWritePageIndex !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableWritePageIndex = this._enableWritePageIndex;
    }
    if (this._endpoint !== undefined) {
      hasAnyValues = true;
      internalValueResult.endpoint = this._endpoint;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._fileNameSuffix !== undefined) {
      hasAnyValues = true;
      internalValueResult.fileNameSuffix = this._fileNameSuffix;
    }
    if (this._format !== undefined) {
      hasAnyValues = true;
      internalValueResult.format = this._format;
    }
    if (this._headerLine !== undefined) {
      hasAnyValues = true;
      internalValueResult.headerLine = this._headerLine;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._keyValueMetadata?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.keyValueMetadata = this._keyValueMetadata?.internalValue;
    }
    if (this._maxFileIdleTimeSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxFileIdleTimeSec = this._maxFileIdleTimeSec;
    }
    if (this._maxFileOpenTimeSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxFileOpenTimeSec = this._maxFileOpenTimeSec;
    }
    if (this._maxFileSizeMb !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxFileSizeMb = this._maxFileSizeMb;
    }
    if (this._maxOpenFiles !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxOpenFiles = this._maxOpenFiles;
    }
    if (this._maxRetryNum !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxRetryNum = this._maxRetryNum;
    }
    if (this._objectAcl !== undefined) {
      hasAnyValues = true;
      internalValueResult.objectAcl = this._objectAcl;
    }
    if (this._onBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.onBackpressure = this._onBackpressure;
    }
    if (this._onDiskFullBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.onDiskFullBackpressure = this._onDiskFullBackpressure;
    }
    if (this._parquetDataPageVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.parquetDataPageVersion = this._parquetDataPageVersion;
    }
    if (this._parquetPageSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.parquetPageSize = this._parquetPageSize;
    }
    if (this._parquetRowGroupLength !== undefined) {
      hasAnyValues = true;
      internalValueResult.parquetRowGroupLength = this._parquetRowGroupLength;
    }
    if (this._parquetVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.parquetVersion = this._parquetVersion;
    }
    if (this._partitionExpr !== undefined) {
      hasAnyValues = true;
      internalValueResult.partitionExpr = this._partitionExpr;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._region !== undefined) {
      hasAnyValues = true;
      internalValueResult.region = this._region;
    }
    if (this._rejectUnauthorized !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectUnauthorized = this._rejectUnauthorized;
    }
    if (this._removeEmptyDirs !== undefined) {
      hasAnyValues = true;
      internalValueResult.removeEmptyDirs = this._removeEmptyDirs;
    }
    if (this._reuseConnections !== undefined) {
      hasAnyValues = true;
      internalValueResult.reuseConnections = this._reuseConnections;
    }
    if (this._shouldLogInvalidRows !== undefined) {
      hasAnyValues = true;
      internalValueResult.shouldLogInvalidRows = this._shouldLogInvalidRows;
    }
    if (this._signatureVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.signatureVersion = this._signatureVersion;
    }
    if (this._stagePath !== undefined) {
      hasAnyValues = true;
      internalValueResult.stagePath = this._stagePath;
    }
    if (this._storageClass !== undefined) {
      hasAnyValues = true;
      internalValueResult.storageClass = this._storageClass;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._systemFields !== undefined) {
      hasAnyValues = true;
      internalValueResult.systemFields = this._systemFields;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._verifyPermissions !== undefined) {
      hasAnyValues = true;
      internalValueResult.verifyPermissions = this._verifyPermissions;
    }
    if (this._writeHighWaterMark !== undefined) {
      hasAnyValues = true;
      internalValueResult.writeHighWaterMark = this._writeHighWaterMark;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputGoogleCloudStorage | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._addIdToStagePath = undefined;
      this._automaticSchema = undefined;
      this._awsApiKey = undefined;
      this._awsAuthenticationMethod = undefined;
      this._awsSecret = undefined;
      this._awsSecretKey = undefined;
      this._baseFileName = undefined;
      this._bucket = undefined;
      this._compress = undefined;
      this._compressionLevel = undefined;
      this._deadletterEnabled = undefined;
      this._deadletterPath = undefined;
      this._description = undefined;
      this._destPath = undefined;
      this._emptyDirCleanupSec = undefined;
      this._enablePageChecksum = undefined;
      this._enableStatistics = undefined;
      this._enableWritePageIndex = undefined;
      this._endpoint = undefined;
      this._environment = undefined;
      this._fileNameSuffix = undefined;
      this._format = undefined;
      this._headerLine = undefined;
      this._id = undefined;
      this._keyValueMetadata.internalValue = undefined;
      this._maxFileIdleTimeSec = undefined;
      this._maxFileOpenTimeSec = undefined;
      this._maxFileSizeMb = undefined;
      this._maxOpenFiles = undefined;
      this._maxRetryNum = undefined;
      this._objectAcl = undefined;
      this._onBackpressure = undefined;
      this._onDiskFullBackpressure = undefined;
      this._parquetDataPageVersion = undefined;
      this._parquetPageSize = undefined;
      this._parquetRowGroupLength = undefined;
      this._parquetVersion = undefined;
      this._partitionExpr = undefined;
      this._pipeline = undefined;
      this._region = undefined;
      this._rejectUnauthorized = undefined;
      this._removeEmptyDirs = undefined;
      this._reuseConnections = undefined;
      this._shouldLogInvalidRows = undefined;
      this._signatureVersion = undefined;
      this._stagePath = undefined;
      this._storageClass = undefined;
      this._streamtags = undefined;
      this._systemFields = undefined;
      this._type = undefined;
      this._verifyPermissions = undefined;
      this._writeHighWaterMark = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._addIdToStagePath = value.addIdToStagePath;
      this._automaticSchema = value.automaticSchema;
      this._awsApiKey = value.awsApiKey;
      this._awsAuthenticationMethod = value.awsAuthenticationMethod;
      this._awsSecret = value.awsSecret;
      this._awsSecretKey = value.awsSecretKey;
      this._baseFileName = value.baseFileName;
      this._bucket = value.bucket;
      this._compress = value.compress;
      this._compressionLevel = value.compressionLevel;
      this._deadletterEnabled = value.deadletterEnabled;
      this._deadletterPath = value.deadletterPath;
      this._description = value.description;
      this._destPath = value.destPath;
      this._emptyDirCleanupSec = value.emptyDirCleanupSec;
      this._enablePageChecksum = value.enablePageChecksum;
      this._enableStatistics = value.enableStatistics;
      this._enableWritePageIndex = value.enableWritePageIndex;
      this._endpoint = value.endpoint;
      this._environment = value.environment;
      this._fileNameSuffix = value.fileNameSuffix;
      this._format = value.format;
      this._headerLine = value.headerLine;
      this._id = value.id;
      this._keyValueMetadata.internalValue = value.keyValueMetadata;
      this._maxFileIdleTimeSec = value.maxFileIdleTimeSec;
      this._maxFileOpenTimeSec = value.maxFileOpenTimeSec;
      this._maxFileSizeMb = value.maxFileSizeMb;
      this._maxOpenFiles = value.maxOpenFiles;
      this._maxRetryNum = value.maxRetryNum;
      this._objectAcl = value.objectAcl;
      this._onBackpressure = value.onBackpressure;
      this._onDiskFullBackpressure = value.onDiskFullBackpressure;
      this._parquetDataPageVersion = value.parquetDataPageVersion;
      this._parquetPageSize = value.parquetPageSize;
      this._parquetRowGroupLength = value.parquetRowGroupLength;
      this._parquetVersion = value.parquetVersion;
      this._partitionExpr = value.partitionExpr;
      this._pipeline = value.pipeline;
      this._region = value.region;
      this._rejectUnauthorized = value.rejectUnauthorized;
      this._removeEmptyDirs = value.removeEmptyDirs;
      this._reuseConnections = value.reuseConnections;
      this._shouldLogInvalidRows = value.shouldLogInvalidRows;
      this._signatureVersion = value.signatureVersion;
      this._stagePath = value.stagePath;
      this._storageClass = value.storageClass;
      this._streamtags = value.streamtags;
      this._systemFields = value.systemFields;
      this._type = value.type;
      this._verifyPermissions = value.verifyPermissions;
      this._writeHighWaterMark = value.writeHighWaterMark;
    }
  }

  // add_id_to_stage_path - computed: true, optional: true, required: false
  private _addIdToStagePath?: boolean | cdktf.IResolvable; 
  public get addIdToStagePath() {
    return this.getBooleanAttribute('add_id_to_stage_path');
  }
  public set addIdToStagePath(value: boolean | cdktf.IResolvable) {
    this._addIdToStagePath = value;
  }
  public resetAddIdToStagePath() {
    this._addIdToStagePath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get addIdToStagePathInput() {
    return this._addIdToStagePath;
  }

  // automatic_schema - computed: true, optional: true, required: false
  private _automaticSchema?: boolean | cdktf.IResolvable; 
  public get automaticSchema() {
    return this.getBooleanAttribute('automatic_schema');
  }
  public set automaticSchema(value: boolean | cdktf.IResolvable) {
    this._automaticSchema = value;
  }
  public resetAutomaticSchema() {
    this._automaticSchema = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get automaticSchemaInput() {
    return this._automaticSchema;
  }

  // aws_api_key - computed: false, optional: true, required: false
  private _awsApiKey?: string; 
  public get awsApiKey() {
    return this.getStringAttribute('aws_api_key');
  }
  public set awsApiKey(value: string) {
    this._awsApiKey = value;
  }
  public resetAwsApiKey() {
    this._awsApiKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsApiKeyInput() {
    return this._awsApiKey;
  }

  // aws_authentication_method - computed: true, optional: true, required: false
  private _awsAuthenticationMethod?: string; 
  public get awsAuthenticationMethod() {
    return this.getStringAttribute('aws_authentication_method');
  }
  public set awsAuthenticationMethod(value: string) {
    this._awsAuthenticationMethod = value;
  }
  public resetAwsAuthenticationMethod() {
    this._awsAuthenticationMethod = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsAuthenticationMethodInput() {
    return this._awsAuthenticationMethod;
  }

  // aws_secret - computed: false, optional: true, required: false
  private _awsSecret?: string; 
  public get awsSecret() {
    return this.getStringAttribute('aws_secret');
  }
  public set awsSecret(value: string) {
    this._awsSecret = value;
  }
  public resetAwsSecret() {
    this._awsSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsSecretInput() {
    return this._awsSecret;
  }

  // aws_secret_key - computed: false, optional: true, required: false
  private _awsSecretKey?: string; 
  public get awsSecretKey() {
    return this.getStringAttribute('aws_secret_key');
  }
  public set awsSecretKey(value: string) {
    this._awsSecretKey = value;
  }
  public resetAwsSecretKey() {
    this._awsSecretKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsSecretKeyInput() {
    return this._awsSecretKey;
  }

  // base_file_name - computed: true, optional: true, required: false
  private _baseFileName?: string; 
  public get baseFileName() {
    return this.getStringAttribute('base_file_name');
  }
  public set baseFileName(value: string) {
    this._baseFileName = value;
  }
  public resetBaseFileName() {
    this._baseFileName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get baseFileNameInput() {
    return this._baseFileName;
  }

  // bucket - computed: false, optional: false, required: true
  private _bucket?: string; 
  public get bucket() {
    return this.getStringAttribute('bucket');
  }
  public set bucket(value: string) {
    this._bucket = value;
  }
  // Temporarily expose input value. Use with caution.
  public get bucketInput() {
    return this._bucket;
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: string; 
  public get compress() {
    return this.getStringAttribute('compress');
  }
  public set compress(value: string) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // compression_level - computed: true, optional: true, required: false
  private _compressionLevel?: string; 
  public get compressionLevel() {
    return this.getStringAttribute('compression_level');
  }
  public set compressionLevel(value: string) {
    this._compressionLevel = value;
  }
  public resetCompressionLevel() {
    this._compressionLevel = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressionLevelInput() {
    return this._compressionLevel;
  }

  // deadletter_enabled - computed: true, optional: true, required: false
  private _deadletterEnabled?: boolean | cdktf.IResolvable; 
  public get deadletterEnabled() {
    return this.getBooleanAttribute('deadletter_enabled');
  }
  public set deadletterEnabled(value: boolean | cdktf.IResolvable) {
    this._deadletterEnabled = value;
  }
  public resetDeadletterEnabled() {
    this._deadletterEnabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get deadletterEnabledInput() {
    return this._deadletterEnabled;
  }

  // deadletter_path - computed: true, optional: true, required: false
  private _deadletterPath?: string; 
  public get deadletterPath() {
    return this.getStringAttribute('deadletter_path');
  }
  public set deadletterPath(value: string) {
    this._deadletterPath = value;
  }
  public resetDeadletterPath() {
    this._deadletterPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get deadletterPathInput() {
    return this._deadletterPath;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // dest_path - computed: true, optional: true, required: false
  private _destPath?: string; 
  public get destPath() {
    return this.getStringAttribute('dest_path');
  }
  public set destPath(value: string) {
    this._destPath = value;
  }
  public resetDestPath() {
    this._destPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get destPathInput() {
    return this._destPath;
  }

  // empty_dir_cleanup_sec - computed: true, optional: true, required: false
  private _emptyDirCleanupSec?: number; 
  public get emptyDirCleanupSec() {
    return this.getNumberAttribute('empty_dir_cleanup_sec');
  }
  public set emptyDirCleanupSec(value: number) {
    this._emptyDirCleanupSec = value;
  }
  public resetEmptyDirCleanupSec() {
    this._emptyDirCleanupSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get emptyDirCleanupSecInput() {
    return this._emptyDirCleanupSec;
  }

  // enable_page_checksum - computed: true, optional: true, required: false
  private _enablePageChecksum?: boolean | cdktf.IResolvable; 
  public get enablePageChecksum() {
    return this.getBooleanAttribute('enable_page_checksum');
  }
  public set enablePageChecksum(value: boolean | cdktf.IResolvable) {
    this._enablePageChecksum = value;
  }
  public resetEnablePageChecksum() {
    this._enablePageChecksum = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enablePageChecksumInput() {
    return this._enablePageChecksum;
  }

  // enable_statistics - computed: true, optional: true, required: false
  private _enableStatistics?: boolean | cdktf.IResolvable; 
  public get enableStatistics() {
    return this.getBooleanAttribute('enable_statistics');
  }
  public set enableStatistics(value: boolean | cdktf.IResolvable) {
    this._enableStatistics = value;
  }
  public resetEnableStatistics() {
    this._enableStatistics = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableStatisticsInput() {
    return this._enableStatistics;
  }

  // enable_write_page_index - computed: true, optional: true, required: false
  private _enableWritePageIndex?: boolean | cdktf.IResolvable; 
  public get enableWritePageIndex() {
    return this.getBooleanAttribute('enable_write_page_index');
  }
  public set enableWritePageIndex(value: boolean | cdktf.IResolvable) {
    this._enableWritePageIndex = value;
  }
  public resetEnableWritePageIndex() {
    this._enableWritePageIndex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableWritePageIndexInput() {
    return this._enableWritePageIndex;
  }

  // endpoint - computed: true, optional: true, required: false
  private _endpoint?: string; 
  public get endpoint() {
    return this.getStringAttribute('endpoint');
  }
  public set endpoint(value: string) {
    this._endpoint = value;
  }
  public resetEndpoint() {
    this._endpoint = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get endpointInput() {
    return this._endpoint;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // file_name_suffix - computed: true, optional: true, required: false
  private _fileNameSuffix?: string; 
  public get fileNameSuffix() {
    return this.getStringAttribute('file_name_suffix');
  }
  public set fileNameSuffix(value: string) {
    this._fileNameSuffix = value;
  }
  public resetFileNameSuffix() {
    this._fileNameSuffix = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fileNameSuffixInput() {
    return this._fileNameSuffix;
  }

  // format - computed: true, optional: true, required: false
  private _format?: string; 
  public get format() {
    return this.getStringAttribute('format');
  }
  public set format(value: string) {
    this._format = value;
  }
  public resetFormat() {
    this._format = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get formatInput() {
    return this._format;
  }

  // header_line - computed: true, optional: true, required: false
  private _headerLine?: string; 
  public get headerLine() {
    return this.getStringAttribute('header_line');
  }
  public set headerLine(value: string) {
    this._headerLine = value;
  }
  public resetHeaderLine() {
    this._headerLine = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get headerLineInput() {
    return this._headerLine;
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // key_value_metadata - computed: false, optional: true, required: false
  private _keyValueMetadata = new DestinationOutputGoogleCloudStorageKeyValueMetadataList(this, "key_value_metadata", false);
  public get keyValueMetadata() {
    return this._keyValueMetadata;
  }
  public putKeyValueMetadata(value: DestinationOutputGoogleCloudStorageKeyValueMetadata[] | cdktf.IResolvable) {
    this._keyValueMetadata.internalValue = value;
  }
  public resetKeyValueMetadata() {
    this._keyValueMetadata.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keyValueMetadataInput() {
    return this._keyValueMetadata.internalValue;
  }

  // max_file_idle_time_sec - computed: true, optional: true, required: false
  private _maxFileIdleTimeSec?: number; 
  public get maxFileIdleTimeSec() {
    return this.getNumberAttribute('max_file_idle_time_sec');
  }
  public set maxFileIdleTimeSec(value: number) {
    this._maxFileIdleTimeSec = value;
  }
  public resetMaxFileIdleTimeSec() {
    this._maxFileIdleTimeSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxFileIdleTimeSecInput() {
    return this._maxFileIdleTimeSec;
  }

  // max_file_open_time_sec - computed: true, optional: true, required: false
  private _maxFileOpenTimeSec?: number; 
  public get maxFileOpenTimeSec() {
    return this.getNumberAttribute('max_file_open_time_sec');
  }
  public set maxFileOpenTimeSec(value: number) {
    this._maxFileOpenTimeSec = value;
  }
  public resetMaxFileOpenTimeSec() {
    this._maxFileOpenTimeSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxFileOpenTimeSecInput() {
    return this._maxFileOpenTimeSec;
  }

  // max_file_size_mb - computed: true, optional: true, required: false
  private _maxFileSizeMb?: number; 
  public get maxFileSizeMb() {
    return this.getNumberAttribute('max_file_size_mb');
  }
  public set maxFileSizeMb(value: number) {
    this._maxFileSizeMb = value;
  }
  public resetMaxFileSizeMb() {
    this._maxFileSizeMb = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxFileSizeMbInput() {
    return this._maxFileSizeMb;
  }

  // max_open_files - computed: true, optional: true, required: false
  private _maxOpenFiles?: number; 
  public get maxOpenFiles() {
    return this.getNumberAttribute('max_open_files');
  }
  public set maxOpenFiles(value: number) {
    this._maxOpenFiles = value;
  }
  public resetMaxOpenFiles() {
    this._maxOpenFiles = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxOpenFilesInput() {
    return this._maxOpenFiles;
  }

  // max_retry_num - computed: true, optional: true, required: false
  private _maxRetryNum?: number; 
  public get maxRetryNum() {
    return this.getNumberAttribute('max_retry_num');
  }
  public set maxRetryNum(value: number) {
    this._maxRetryNum = value;
  }
  public resetMaxRetryNum() {
    this._maxRetryNum = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxRetryNumInput() {
    return this._maxRetryNum;
  }

  // object_acl - computed: true, optional: true, required: false
  private _objectAcl?: string; 
  public get objectAcl() {
    return this.getStringAttribute('object_acl');
  }
  public set objectAcl(value: string) {
    this._objectAcl = value;
  }
  public resetObjectAcl() {
    this._objectAcl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get objectAclInput() {
    return this._objectAcl;
  }

  // on_backpressure - computed: true, optional: true, required: false
  private _onBackpressure?: string; 
  public get onBackpressure() {
    return this.getStringAttribute('on_backpressure');
  }
  public set onBackpressure(value: string) {
    this._onBackpressure = value;
  }
  public resetOnBackpressure() {
    this._onBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get onBackpressureInput() {
    return this._onBackpressure;
  }

  // on_disk_full_backpressure - computed: true, optional: true, required: false
  private _onDiskFullBackpressure?: string; 
  public get onDiskFullBackpressure() {
    return this.getStringAttribute('on_disk_full_backpressure');
  }
  public set onDiskFullBackpressure(value: string) {
    this._onDiskFullBackpressure = value;
  }
  public resetOnDiskFullBackpressure() {
    this._onDiskFullBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get onDiskFullBackpressureInput() {
    return this._onDiskFullBackpressure;
  }

  // parquet_data_page_version - computed: true, optional: true, required: false
  private _parquetDataPageVersion?: string; 
  public get parquetDataPageVersion() {
    return this.getStringAttribute('parquet_data_page_version');
  }
  public set parquetDataPageVersion(value: string) {
    this._parquetDataPageVersion = value;
  }
  public resetParquetDataPageVersion() {
    this._parquetDataPageVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get parquetDataPageVersionInput() {
    return this._parquetDataPageVersion;
  }

  // parquet_page_size - computed: true, optional: true, required: false
  private _parquetPageSize?: string; 
  public get parquetPageSize() {
    return this.getStringAttribute('parquet_page_size');
  }
  public set parquetPageSize(value: string) {
    this._parquetPageSize = value;
  }
  public resetParquetPageSize() {
    this._parquetPageSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get parquetPageSizeInput() {
    return this._parquetPageSize;
  }

  // parquet_row_group_length - computed: true, optional: true, required: false
  private _parquetRowGroupLength?: number; 
  public get parquetRowGroupLength() {
    return this.getNumberAttribute('parquet_row_group_length');
  }
  public set parquetRowGroupLength(value: number) {
    this._parquetRowGroupLength = value;
  }
  public resetParquetRowGroupLength() {
    this._parquetRowGroupLength = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get parquetRowGroupLengthInput() {
    return this._parquetRowGroupLength;
  }

  // parquet_version - computed: true, optional: true, required: false
  private _parquetVersion?: string; 
  public get parquetVersion() {
    return this.getStringAttribute('parquet_version');
  }
  public set parquetVersion(value: string) {
    this._parquetVersion = value;
  }
  public resetParquetVersion() {
    this._parquetVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get parquetVersionInput() {
    return this._parquetVersion;
  }

  // partition_expr - computed: true, optional: true, required: false
  private _partitionExpr?: string; 
  public get partitionExpr() {
    return this.getStringAttribute('partition_expr');
  }
  public set partitionExpr(value: string) {
    this._partitionExpr = value;
  }
  public resetPartitionExpr() {
    this._partitionExpr = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get partitionExprInput() {
    return this._partitionExpr;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // region - computed: false, optional: false, required: true
  private _region?: string; 
  public get region() {
    return this.getStringAttribute('region');
  }
  public set region(value: string) {
    this._region = value;
  }
  // Temporarily expose input value. Use with caution.
  public get regionInput() {
    return this._region;
  }

  // reject_unauthorized - computed: true, optional: true, required: false
  private _rejectUnauthorized?: boolean | cdktf.IResolvable; 
  public get rejectUnauthorized() {
    return this.getBooleanAttribute('reject_unauthorized');
  }
  public set rejectUnauthorized(value: boolean | cdktf.IResolvable) {
    this._rejectUnauthorized = value;
  }
  public resetRejectUnauthorized() {
    this._rejectUnauthorized = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectUnauthorizedInput() {
    return this._rejectUnauthorized;
  }

  // remove_empty_dirs - computed: true, optional: true, required: false
  private _removeEmptyDirs?: boolean | cdktf.IResolvable; 
  public get removeEmptyDirs() {
    return this.getBooleanAttribute('remove_empty_dirs');
  }
  public set removeEmptyDirs(value: boolean | cdktf.IResolvable) {
    this._removeEmptyDirs = value;
  }
  public resetRemoveEmptyDirs() {
    this._removeEmptyDirs = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get removeEmptyDirsInput() {
    return this._removeEmptyDirs;
  }

  // reuse_connections - computed: true, optional: true, required: false
  private _reuseConnections?: boolean | cdktf.IResolvable; 
  public get reuseConnections() {
    return this.getBooleanAttribute('reuse_connections');
  }
  public set reuseConnections(value: boolean | cdktf.IResolvable) {
    this._reuseConnections = value;
  }
  public resetReuseConnections() {
    this._reuseConnections = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get reuseConnectionsInput() {
    return this._reuseConnections;
  }

  // should_log_invalid_rows - computed: false, optional: true, required: false
  private _shouldLogInvalidRows?: boolean | cdktf.IResolvable; 
  public get shouldLogInvalidRows() {
    return this.getBooleanAttribute('should_log_invalid_rows');
  }
  public set shouldLogInvalidRows(value: boolean | cdktf.IResolvable) {
    this._shouldLogInvalidRows = value;
  }
  public resetShouldLogInvalidRows() {
    this._shouldLogInvalidRows = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get shouldLogInvalidRowsInput() {
    return this._shouldLogInvalidRows;
  }

  // signature_version - computed: true, optional: true, required: false
  private _signatureVersion?: string; 
  public get signatureVersion() {
    return this.getStringAttribute('signature_version');
  }
  public set signatureVersion(value: string) {
    this._signatureVersion = value;
  }
  public resetSignatureVersion() {
    this._signatureVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get signatureVersionInput() {
    return this._signatureVersion;
  }

  // stage_path - computed: true, optional: true, required: false
  private _stagePath?: string; 
  public get stagePath() {
    return this.getStringAttribute('stage_path');
  }
  public set stagePath(value: string) {
    this._stagePath = value;
  }
  public resetStagePath() {
    this._stagePath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get stagePathInput() {
    return this._stagePath;
  }

  // storage_class - computed: false, optional: true, required: false
  private _storageClass?: string; 
  public get storageClass() {
    return this.getStringAttribute('storage_class');
  }
  public set storageClass(value: string) {
    this._storageClass = value;
  }
  public resetStorageClass() {
    this._storageClass = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get storageClassInput() {
    return this._storageClass;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // system_fields - computed: true, optional: true, required: false
  private _systemFields?: string[]; 
  public get systemFields() {
    return this.getListAttribute('system_fields');
  }
  public set systemFields(value: string[]) {
    this._systemFields = value;
  }
  public resetSystemFields() {
    this._systemFields = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get systemFieldsInput() {
    return this._systemFields;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // verify_permissions - computed: true, optional: true, required: false
  private _verifyPermissions?: boolean | cdktf.IResolvable; 
  public get verifyPermissions() {
    return this.getBooleanAttribute('verify_permissions');
  }
  public set verifyPermissions(value: boolean | cdktf.IResolvable) {
    this._verifyPermissions = value;
  }
  public resetVerifyPermissions() {
    this._verifyPermissions = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get verifyPermissionsInput() {
    return this._verifyPermissions;
  }

  // write_high_water_mark - computed: true, optional: true, required: false
  private _writeHighWaterMark?: number; 
  public get writeHighWaterMark() {
    return this.getNumberAttribute('write_high_water_mark');
  }
  public set writeHighWaterMark(value: number) {
    this._writeHighWaterMark = value;
  }
  public resetWriteHighWaterMark() {
    this._writeHighWaterMark = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get writeHighWaterMarkInput() {
    return this._writeHighWaterMark;
  }
}
export interface DestinationOutputGooglePubsubPqControls {
}

export function destinationOutputGooglePubsubPqControlsToTerraform(struct?: DestinationOutputGooglePubsubPqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function destinationOutputGooglePubsubPqControlsToHclTerraform(struct?: DestinationOutputGooglePubsubPqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class DestinationOutputGooglePubsubPqControlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DestinationOutputGooglePubsubPqControls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputGooglePubsubPqControls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface DestinationOutputGooglePubsub {
  /**
  * The maximum number of items the Google API should batch before it sends them to the topic. Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#batch_size Destination#batch_size}
  */
  readonly batchSize?: number;
  /**
  * The maximum amount of time, in milliseconds, that the Google API should wait to send a batch (if the Batch size is not reached). Default: 100
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#batch_timeout Destination#batch_timeout}
  */
  readonly batchTimeout?: number;
  /**
  * If enabled, create topic if it does not exist. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#create_topic Destination#create_topic}
  */
  readonly createTopic?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#description Destination#description}
  */
  readonly description?: string;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#environment Destination#environment}
  */
  readonly environment?: string;
  /**
  * Maximum time to wait before sending a batch (when batch size limit is not reached). Default: 1
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#flush_period_sec Destination#flush_period_sec}
  */
  readonly flushPeriodSec?: number;
  /**
  * Choose Auto to use Google Application Default Credentials (ADC), Manual to enter Google service account credentials directly, or Secret to select or create a stored secret that references Google service account credentials. Default: "manual"; must be one of ["auto", "manual", "secret"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#google_auth_method Destination#google_auth_method}
  */
  readonly googleAuthMethod?: string;
  /**
  * Unique ID for this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#id Destination#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * The maximum number of in-progress API requests before backpressure is applied. Default: 10
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#max_in_progress Destination#max_in_progress}
  */
  readonly maxInProgress?: number;
  /**
  * Maximum number of queued batches before blocking. Default: 100
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#max_queue_size Destination#max_queue_size}
  */
  readonly maxQueueSize?: number;
  /**
  * Maximum size (KB) of batches to send. Default: 256
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#max_record_size_kb Destination#max_record_size_kb}
  */
  readonly maxRecordSizeKb?: number;
  /**
  * How to handle events when all receivers are exerting backpressure. Default: "block"; must be one of ["block", "drop", "queue"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#on_backpressure Destination#on_backpressure}
  */
  readonly onBackpressure?: string;
  /**
  * If enabled, send events in the order they were added to the queue. For this to work correctly, the process receiving events must have ordering enabled. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#ordered_delivery Destination#ordered_delivery}
  */
  readonly orderedDelivery?: boolean | cdktf.IResolvable;
  /**
  * Pipeline to process data before sending out to this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pipeline Destination#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pq_compress Destination#pq_compress}
  */
  readonly pqCompress?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pq_controls Destination#pq_controls}
  */
  readonly pqControls?: DestinationOutputGooglePubsubPqControls;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.). Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pq_max_file_size Destination#pq_max_file_size}
  */
  readonly pqMaxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pq_max_size Destination#pq_max_size}
  */
  readonly pqMaxSize?: string;
  /**
  * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem. Default: "error"; must be one of ["error", "backpressure", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pq_mode Destination#pq_mode}
  */
  readonly pqMode?: string;
  /**
  * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged. Default: "block"; must be one of ["block", "drop"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pq_on_backpressure Destination#pq_on_backpressure}
  */
  readonly pqOnBackpressure?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pq_path Destination#pq_path}
  */
  readonly pqPath?: string;
  /**
  * Region to publish messages to. Select 'default' to allow Google to auto-select the nearest region. When using ordered delivery, the selected region must be allowed by message storage policy.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#region Destination#region}
  */
  readonly region?: string;
  /**
  * Select or create a stored text secret
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#secret Destination#secret}
  */
  readonly secret?: string;
  /**
  * Contents of service account credentials (JSON keys) file downloaded from Google Cloud. To upload a file, click the upload button at this field's upper right.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#service_account_credentials Destination#service_account_credentials}
  */
  readonly serviceAccountCredentials?: string;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#streamtags Destination#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Fields to automatically add to events, such as cribl_pipe. Supports wildcards. Default: ["cribl_pipe"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#system_fields Destination#system_fields}
  */
  readonly systemFields?: string[];
  /**
  * ID of the topic to send events to.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#topic_name Destination#topic_name}
  */
  readonly topicName: string;
  /**
  * must be "google_pubsub"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#type Destination#type}
  */
  readonly type: string;
}

export function destinationOutputGooglePubsubToTerraform(struct?: DestinationOutputGooglePubsub | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    batch_size: cdktf.numberToTerraform(struct!.batchSize),
    batch_timeout: cdktf.numberToTerraform(struct!.batchTimeout),
    create_topic: cdktf.booleanToTerraform(struct!.createTopic),
    description: cdktf.stringToTerraform(struct!.description),
    environment: cdktf.stringToTerraform(struct!.environment),
    flush_period_sec: cdktf.numberToTerraform(struct!.flushPeriodSec),
    google_auth_method: cdktf.stringToTerraform(struct!.googleAuthMethod),
    id: cdktf.stringToTerraform(struct!.id),
    max_in_progress: cdktf.numberToTerraform(struct!.maxInProgress),
    max_queue_size: cdktf.numberToTerraform(struct!.maxQueueSize),
    max_record_size_kb: cdktf.numberToTerraform(struct!.maxRecordSizeKb),
    on_backpressure: cdktf.stringToTerraform(struct!.onBackpressure),
    ordered_delivery: cdktf.booleanToTerraform(struct!.orderedDelivery),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    pq_compress: cdktf.stringToTerraform(struct!.pqCompress),
    pq_controls: destinationOutputGooglePubsubPqControlsToTerraform(struct!.pqControls),
    pq_max_file_size: cdktf.stringToTerraform(struct!.pqMaxFileSize),
    pq_max_size: cdktf.stringToTerraform(struct!.pqMaxSize),
    pq_mode: cdktf.stringToTerraform(struct!.pqMode),
    pq_on_backpressure: cdktf.stringToTerraform(struct!.pqOnBackpressure),
    pq_path: cdktf.stringToTerraform(struct!.pqPath),
    region: cdktf.stringToTerraform(struct!.region),
    secret: cdktf.stringToTerraform(struct!.secret),
    service_account_credentials: cdktf.stringToTerraform(struct!.serviceAccountCredentials),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    system_fields: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.systemFields),
    topic_name: cdktf.stringToTerraform(struct!.topicName),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function destinationOutputGooglePubsubToHclTerraform(struct?: DestinationOutputGooglePubsub | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    batch_size: {
      value: cdktf.numberToHclTerraform(struct!.batchSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    batch_timeout: {
      value: cdktf.numberToHclTerraform(struct!.batchTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    create_topic: {
      value: cdktf.booleanToHclTerraform(struct!.createTopic),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    flush_period_sec: {
      value: cdktf.numberToHclTerraform(struct!.flushPeriodSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    google_auth_method: {
      value: cdktf.stringToHclTerraform(struct!.googleAuthMethod),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_in_progress: {
      value: cdktf.numberToHclTerraform(struct!.maxInProgress),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_queue_size: {
      value: cdktf.numberToHclTerraform(struct!.maxQueueSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_record_size_kb: {
      value: cdktf.numberToHclTerraform(struct!.maxRecordSizeKb),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.onBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ordered_delivery: {
      value: cdktf.booleanToHclTerraform(struct!.orderedDelivery),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_compress: {
      value: cdktf.stringToHclTerraform(struct!.pqCompress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_controls: {
      value: destinationOutputGooglePubsubPqControlsToHclTerraform(struct!.pqControls),
      isBlock: true,
      type: "struct",
      storageClassType: "DestinationOutputGooglePubsubPqControls",
    },
    pq_max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_max_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_mode: {
      value: cdktf.stringToHclTerraform(struct!.pqMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.pqOnBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_path: {
      value: cdktf.stringToHclTerraform(struct!.pqPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    region: {
      value: cdktf.stringToHclTerraform(struct!.region),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret: {
      value: cdktf.stringToHclTerraform(struct!.secret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    service_account_credentials: {
      value: cdktf.stringToHclTerraform(struct!.serviceAccountCredentials),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    system_fields: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.systemFields),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    topic_name: {
      value: cdktf.stringToHclTerraform(struct!.topicName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputGooglePubsubOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DestinationOutputGooglePubsub | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._batchSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.batchSize = this._batchSize;
    }
    if (this._batchTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.batchTimeout = this._batchTimeout;
    }
    if (this._createTopic !== undefined) {
      hasAnyValues = true;
      internalValueResult.createTopic = this._createTopic;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._flushPeriodSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.flushPeriodSec = this._flushPeriodSec;
    }
    if (this._googleAuthMethod !== undefined) {
      hasAnyValues = true;
      internalValueResult.googleAuthMethod = this._googleAuthMethod;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._maxInProgress !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxInProgress = this._maxInProgress;
    }
    if (this._maxQueueSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxQueueSize = this._maxQueueSize;
    }
    if (this._maxRecordSizeKb !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxRecordSizeKb = this._maxRecordSizeKb;
    }
    if (this._onBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.onBackpressure = this._onBackpressure;
    }
    if (this._orderedDelivery !== undefined) {
      hasAnyValues = true;
      internalValueResult.orderedDelivery = this._orderedDelivery;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._pqCompress !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqCompress = this._pqCompress;
    }
    if (this._pqControls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqControls = this._pqControls?.internalValue;
    }
    if (this._pqMaxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxFileSize = this._pqMaxFileSize;
    }
    if (this._pqMaxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxSize = this._pqMaxSize;
    }
    if (this._pqMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMode = this._pqMode;
    }
    if (this._pqOnBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqOnBackpressure = this._pqOnBackpressure;
    }
    if (this._pqPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqPath = this._pqPath;
    }
    if (this._region !== undefined) {
      hasAnyValues = true;
      internalValueResult.region = this._region;
    }
    if (this._secret !== undefined) {
      hasAnyValues = true;
      internalValueResult.secret = this._secret;
    }
    if (this._serviceAccountCredentials !== undefined) {
      hasAnyValues = true;
      internalValueResult.serviceAccountCredentials = this._serviceAccountCredentials;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._systemFields !== undefined) {
      hasAnyValues = true;
      internalValueResult.systemFields = this._systemFields;
    }
    if (this._topicName !== undefined) {
      hasAnyValues = true;
      internalValueResult.topicName = this._topicName;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputGooglePubsub | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._batchSize = undefined;
      this._batchTimeout = undefined;
      this._createTopic = undefined;
      this._description = undefined;
      this._environment = undefined;
      this._flushPeriodSec = undefined;
      this._googleAuthMethod = undefined;
      this._id = undefined;
      this._maxInProgress = undefined;
      this._maxQueueSize = undefined;
      this._maxRecordSizeKb = undefined;
      this._onBackpressure = undefined;
      this._orderedDelivery = undefined;
      this._pipeline = undefined;
      this._pqCompress = undefined;
      this._pqControls.internalValue = undefined;
      this._pqMaxFileSize = undefined;
      this._pqMaxSize = undefined;
      this._pqMode = undefined;
      this._pqOnBackpressure = undefined;
      this._pqPath = undefined;
      this._region = undefined;
      this._secret = undefined;
      this._serviceAccountCredentials = undefined;
      this._streamtags = undefined;
      this._systemFields = undefined;
      this._topicName = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._batchSize = value.batchSize;
      this._batchTimeout = value.batchTimeout;
      this._createTopic = value.createTopic;
      this._description = value.description;
      this._environment = value.environment;
      this._flushPeriodSec = value.flushPeriodSec;
      this._googleAuthMethod = value.googleAuthMethod;
      this._id = value.id;
      this._maxInProgress = value.maxInProgress;
      this._maxQueueSize = value.maxQueueSize;
      this._maxRecordSizeKb = value.maxRecordSizeKb;
      this._onBackpressure = value.onBackpressure;
      this._orderedDelivery = value.orderedDelivery;
      this._pipeline = value.pipeline;
      this._pqCompress = value.pqCompress;
      this._pqControls.internalValue = value.pqControls;
      this._pqMaxFileSize = value.pqMaxFileSize;
      this._pqMaxSize = value.pqMaxSize;
      this._pqMode = value.pqMode;
      this._pqOnBackpressure = value.pqOnBackpressure;
      this._pqPath = value.pqPath;
      this._region = value.region;
      this._secret = value.secret;
      this._serviceAccountCredentials = value.serviceAccountCredentials;
      this._streamtags = value.streamtags;
      this._systemFields = value.systemFields;
      this._topicName = value.topicName;
      this._type = value.type;
    }
  }

  // batch_size - computed: true, optional: true, required: false
  private _batchSize?: number; 
  public get batchSize() {
    return this.getNumberAttribute('batch_size');
  }
  public set batchSize(value: number) {
    this._batchSize = value;
  }
  public resetBatchSize() {
    this._batchSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get batchSizeInput() {
    return this._batchSize;
  }

  // batch_timeout - computed: true, optional: true, required: false
  private _batchTimeout?: number; 
  public get batchTimeout() {
    return this.getNumberAttribute('batch_timeout');
  }
  public set batchTimeout(value: number) {
    this._batchTimeout = value;
  }
  public resetBatchTimeout() {
    this._batchTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get batchTimeoutInput() {
    return this._batchTimeout;
  }

  // create_topic - computed: true, optional: true, required: false
  private _createTopic?: boolean | cdktf.IResolvable; 
  public get createTopic() {
    return this.getBooleanAttribute('create_topic');
  }
  public set createTopic(value: boolean | cdktf.IResolvable) {
    this._createTopic = value;
  }
  public resetCreateTopic() {
    this._createTopic = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get createTopicInput() {
    return this._createTopic;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // flush_period_sec - computed: true, optional: true, required: false
  private _flushPeriodSec?: number; 
  public get flushPeriodSec() {
    return this.getNumberAttribute('flush_period_sec');
  }
  public set flushPeriodSec(value: number) {
    this._flushPeriodSec = value;
  }
  public resetFlushPeriodSec() {
    this._flushPeriodSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get flushPeriodSecInput() {
    return this._flushPeriodSec;
  }

  // google_auth_method - computed: true, optional: true, required: false
  private _googleAuthMethod?: string; 
  public get googleAuthMethod() {
    return this.getStringAttribute('google_auth_method');
  }
  public set googleAuthMethod(value: string) {
    this._googleAuthMethod = value;
  }
  public resetGoogleAuthMethod() {
    this._googleAuthMethod = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get googleAuthMethodInput() {
    return this._googleAuthMethod;
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // max_in_progress - computed: true, optional: true, required: false
  private _maxInProgress?: number; 
  public get maxInProgress() {
    return this.getNumberAttribute('max_in_progress');
  }
  public set maxInProgress(value: number) {
    this._maxInProgress = value;
  }
  public resetMaxInProgress() {
    this._maxInProgress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxInProgressInput() {
    return this._maxInProgress;
  }

  // max_queue_size - computed: true, optional: true, required: false
  private _maxQueueSize?: number; 
  public get maxQueueSize() {
    return this.getNumberAttribute('max_queue_size');
  }
  public set maxQueueSize(value: number) {
    this._maxQueueSize = value;
  }
  public resetMaxQueueSize() {
    this._maxQueueSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxQueueSizeInput() {
    return this._maxQueueSize;
  }

  // max_record_size_kb - computed: true, optional: true, required: false
  private _maxRecordSizeKb?: number; 
  public get maxRecordSizeKb() {
    return this.getNumberAttribute('max_record_size_kb');
  }
  public set maxRecordSizeKb(value: number) {
    this._maxRecordSizeKb = value;
  }
  public resetMaxRecordSizeKb() {
    this._maxRecordSizeKb = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxRecordSizeKbInput() {
    return this._maxRecordSizeKb;
  }

  // on_backpressure - computed: true, optional: true, required: false
  private _onBackpressure?: string; 
  public get onBackpressure() {
    return this.getStringAttribute('on_backpressure');
  }
  public set onBackpressure(value: string) {
    this._onBackpressure = value;
  }
  public resetOnBackpressure() {
    this._onBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get onBackpressureInput() {
    return this._onBackpressure;
  }

  // ordered_delivery - computed: true, optional: true, required: false
  private _orderedDelivery?: boolean | cdktf.IResolvable; 
  public get orderedDelivery() {
    return this.getBooleanAttribute('ordered_delivery');
  }
  public set orderedDelivery(value: boolean | cdktf.IResolvable) {
    this._orderedDelivery = value;
  }
  public resetOrderedDelivery() {
    this._orderedDelivery = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get orderedDeliveryInput() {
    return this._orderedDelivery;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // pq_compress - computed: true, optional: true, required: false
  private _pqCompress?: string; 
  public get pqCompress() {
    return this.getStringAttribute('pq_compress');
  }
  public set pqCompress(value: string) {
    this._pqCompress = value;
  }
  public resetPqCompress() {
    this._pqCompress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqCompressInput() {
    return this._pqCompress;
  }

  // pq_controls - computed: false, optional: true, required: false
  private _pqControls = new DestinationOutputGooglePubsubPqControlsOutputReference(this, "pq_controls");
  public get pqControls() {
    return this._pqControls;
  }
  public putPqControls(value: DestinationOutputGooglePubsubPqControls) {
    this._pqControls.internalValue = value;
  }
  public resetPqControls() {
    this._pqControls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqControlsInput() {
    return this._pqControls.internalValue;
  }

  // pq_max_file_size - computed: true, optional: true, required: false
  private _pqMaxFileSize?: string; 
  public get pqMaxFileSize() {
    return this.getStringAttribute('pq_max_file_size');
  }
  public set pqMaxFileSize(value: string) {
    this._pqMaxFileSize = value;
  }
  public resetPqMaxFileSize() {
    this._pqMaxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxFileSizeInput() {
    return this._pqMaxFileSize;
  }

  // pq_max_size - computed: true, optional: true, required: false
  private _pqMaxSize?: string; 
  public get pqMaxSize() {
    return this.getStringAttribute('pq_max_size');
  }
  public set pqMaxSize(value: string) {
    this._pqMaxSize = value;
  }
  public resetPqMaxSize() {
    this._pqMaxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxSizeInput() {
    return this._pqMaxSize;
  }

  // pq_mode - computed: true, optional: true, required: false
  private _pqMode?: string; 
  public get pqMode() {
    return this.getStringAttribute('pq_mode');
  }
  public set pqMode(value: string) {
    this._pqMode = value;
  }
  public resetPqMode() {
    this._pqMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqModeInput() {
    return this._pqMode;
  }

  // pq_on_backpressure - computed: true, optional: true, required: false
  private _pqOnBackpressure?: string; 
  public get pqOnBackpressure() {
    return this.getStringAttribute('pq_on_backpressure');
  }
  public set pqOnBackpressure(value: string) {
    this._pqOnBackpressure = value;
  }
  public resetPqOnBackpressure() {
    this._pqOnBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqOnBackpressureInput() {
    return this._pqOnBackpressure;
  }

  // pq_path - computed: true, optional: true, required: false
  private _pqPath?: string; 
  public get pqPath() {
    return this.getStringAttribute('pq_path');
  }
  public set pqPath(value: string) {
    this._pqPath = value;
  }
  public resetPqPath() {
    this._pqPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqPathInput() {
    return this._pqPath;
  }

  // region - computed: false, optional: true, required: false
  private _region?: string; 
  public get region() {
    return this.getStringAttribute('region');
  }
  public set region(value: string) {
    this._region = value;
  }
  public resetRegion() {
    this._region = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get regionInput() {
    return this._region;
  }

  // secret - computed: false, optional: true, required: false
  private _secret?: string; 
  public get secret() {
    return this.getStringAttribute('secret');
  }
  public set secret(value: string) {
    this._secret = value;
  }
  public resetSecret() {
    this._secret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretInput() {
    return this._secret;
  }

  // service_account_credentials - computed: false, optional: true, required: false
  private _serviceAccountCredentials?: string; 
  public get serviceAccountCredentials() {
    return this.getStringAttribute('service_account_credentials');
  }
  public set serviceAccountCredentials(value: string) {
    this._serviceAccountCredentials = value;
  }
  public resetServiceAccountCredentials() {
    this._serviceAccountCredentials = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get serviceAccountCredentialsInput() {
    return this._serviceAccountCredentials;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // system_fields - computed: true, optional: true, required: false
  private _systemFields?: string[]; 
  public get systemFields() {
    return this.getListAttribute('system_fields');
  }
  public set systemFields(value: string[]) {
    this._systemFields = value;
  }
  public resetSystemFields() {
    this._systemFields = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get systemFieldsInput() {
    return this._systemFields;
  }

  // topic_name - computed: false, optional: false, required: true
  private _topicName?: string; 
  public get topicName() {
    return this.getStringAttribute('topic_name');
  }
  public set topicName(value: string) {
    this._topicName = value;
  }
  // Temporarily expose input value. Use with caution.
  public get topicNameInput() {
    return this._topicName;
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1ExtraHttpHeaders {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#name Destination#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#value Destination#value}
  */
  readonly value: string;
}

export function destinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1ExtraHttpHeadersToTerraform(struct?: DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1ExtraHttpHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function destinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1ExtraHttpHeadersToHclTerraform(struct?: DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1ExtraHttpHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1ExtraHttpHeadersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1ExtraHttpHeaders | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1ExtraHttpHeaders | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1ExtraHttpHeadersList extends cdktf.ComplexList {
  public internalValue? : DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1ExtraHttpHeaders[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1ExtraHttpHeadersOutputReference {
    return new DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1ExtraHttpHeadersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1Labels {
  /**
  * Default: ""
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#name Destination#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#value Destination#value}
  */
  readonly value: string;
}

export function destinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1LabelsToTerraform(struct?: DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1Labels | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function destinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1LabelsToHclTerraform(struct?: DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1Labels | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1LabelsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1Labels | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1Labels | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: true, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1LabelsList extends cdktf.ComplexList {
  public internalValue? : DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1Labels[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1LabelsOutputReference {
    return new DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1LabelsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1LokiAuth {
  /**
  * Default: "basic"; must be one of ["none", "token", "textSecret", "basic", "credentialsSecret"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#auth_type Destination#auth_type}
  */
  readonly authType?: string;
  /**
  * Select or create a secret that references your credentials
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#credentials_secret Destination#credentials_secret}
  */
  readonly credentialsSecret?: string;
  /**
  * Password (API key in Grafana Cloud domain) for authentication
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#password Destination#password}
  */
  readonly password?: string;
  /**
  * Select or create a stored text secret
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#text_secret Destination#text_secret}
  */
  readonly textSecret?: string;
  /**
  * Bearer token to include in the authorization header. In Grafana Cloud, this is generally built by concatenating the username and the API key, separated by a colon. Example: <your-username>:<your-api-key>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#token Destination#token}
  */
  readonly token?: string;
  /**
  * Username for authentication
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#username Destination#username}
  */
  readonly username?: string;
}

export function destinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1LokiAuthToTerraform(struct?: DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1LokiAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    auth_type: cdktf.stringToTerraform(struct!.authType),
    credentials_secret: cdktf.stringToTerraform(struct!.credentialsSecret),
    password: cdktf.stringToTerraform(struct!.password),
    text_secret: cdktf.stringToTerraform(struct!.textSecret),
    token: cdktf.stringToTerraform(struct!.token),
    username: cdktf.stringToTerraform(struct!.username),
  }
}


export function destinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1LokiAuthToHclTerraform(struct?: DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1LokiAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    auth_type: {
      value: cdktf.stringToHclTerraform(struct!.authType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    credentials_secret: {
      value: cdktf.stringToHclTerraform(struct!.credentialsSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    password: {
      value: cdktf.stringToHclTerraform(struct!.password),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    text_secret: {
      value: cdktf.stringToHclTerraform(struct!.textSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    token: {
      value: cdktf.stringToHclTerraform(struct!.token),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    username: {
      value: cdktf.stringToHclTerraform(struct!.username),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1LokiAuthOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1LokiAuth | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._authType !== undefined) {
      hasAnyValues = true;
      internalValueResult.authType = this._authType;
    }
    if (this._credentialsSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.credentialsSecret = this._credentialsSecret;
    }
    if (this._password !== undefined) {
      hasAnyValues = true;
      internalValueResult.password = this._password;
    }
    if (this._textSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.textSecret = this._textSecret;
    }
    if (this._token !== undefined) {
      hasAnyValues = true;
      internalValueResult.token = this._token;
    }
    if (this._username !== undefined) {
      hasAnyValues = true;
      internalValueResult.username = this._username;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1LokiAuth | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._authType = undefined;
      this._credentialsSecret = undefined;
      this._password = undefined;
      this._textSecret = undefined;
      this._token = undefined;
      this._username = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._authType = value.authType;
      this._credentialsSecret = value.credentialsSecret;
      this._password = value.password;
      this._textSecret = value.textSecret;
      this._token = value.token;
      this._username = value.username;
    }
  }

  // auth_type - computed: true, optional: true, required: false
  private _authType?: string; 
  public get authType() {
    return this.getStringAttribute('auth_type');
  }
  public set authType(value: string) {
    this._authType = value;
  }
  public resetAuthType() {
    this._authType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authTypeInput() {
    return this._authType;
  }

  // credentials_secret - computed: false, optional: true, required: false
  private _credentialsSecret?: string; 
  public get credentialsSecret() {
    return this.getStringAttribute('credentials_secret');
  }
  public set credentialsSecret(value: string) {
    this._credentialsSecret = value;
  }
  public resetCredentialsSecret() {
    this._credentialsSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get credentialsSecretInput() {
    return this._credentialsSecret;
  }

  // password - computed: false, optional: true, required: false
  private _password?: string; 
  public get password() {
    return this.getStringAttribute('password');
  }
  public set password(value: string) {
    this._password = value;
  }
  public resetPassword() {
    this._password = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passwordInput() {
    return this._password;
  }

  // text_secret - computed: false, optional: true, required: false
  private _textSecret?: string; 
  public get textSecret() {
    return this.getStringAttribute('text_secret');
  }
  public set textSecret(value: string) {
    this._textSecret = value;
  }
  public resetTextSecret() {
    this._textSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get textSecretInput() {
    return this._textSecret;
  }

  // token - computed: false, optional: true, required: false
  private _token?: string; 
  public get token() {
    return this.getStringAttribute('token');
  }
  public set token(value: string) {
    this._token = value;
  }
  public resetToken() {
    this._token = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tokenInput() {
    return this._token;
  }

  // username - computed: false, optional: true, required: false
  private _username?: string; 
  public get username() {
    return this.getStringAttribute('username');
  }
  public set username(value: string) {
    this._username = value;
  }
  public resetUsername() {
    this._username = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usernameInput() {
    return this._username;
  }
}
export interface DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1PqControls {
}

export function destinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1PqControlsToTerraform(struct?: DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1PqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function destinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1PqControlsToHclTerraform(struct?: DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1PqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1PqControlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1PqControls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1PqControls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1PrometheusAuth {
  /**
  * Default: "basic"; must be one of ["none", "token", "textSecret", "basic", "credentialsSecret"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#auth_type Destination#auth_type}
  */
  readonly authType?: string;
  /**
  * Select or create a secret that references your credentials
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#credentials_secret Destination#credentials_secret}
  */
  readonly credentialsSecret?: string;
  /**
  * Password (API key in Grafana Cloud domain) for authentication
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#password Destination#password}
  */
  readonly password?: string;
  /**
  * Select or create a stored text secret
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#text_secret Destination#text_secret}
  */
  readonly textSecret?: string;
  /**
  * Bearer token to include in the authorization header. In Grafana Cloud, this is generally built by concatenating the username and the API key, separated by a colon. Example: <your-username>:<your-api-key>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#token Destination#token}
  */
  readonly token?: string;
  /**
  * Username for authentication
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#username Destination#username}
  */
  readonly username?: string;
}

export function destinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1PrometheusAuthToTerraform(struct?: DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1PrometheusAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    auth_type: cdktf.stringToTerraform(struct!.authType),
    credentials_secret: cdktf.stringToTerraform(struct!.credentialsSecret),
    password: cdktf.stringToTerraform(struct!.password),
    text_secret: cdktf.stringToTerraform(struct!.textSecret),
    token: cdktf.stringToTerraform(struct!.token),
    username: cdktf.stringToTerraform(struct!.username),
  }
}


export function destinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1PrometheusAuthToHclTerraform(struct?: DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1PrometheusAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    auth_type: {
      value: cdktf.stringToHclTerraform(struct!.authType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    credentials_secret: {
      value: cdktf.stringToHclTerraform(struct!.credentialsSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    password: {
      value: cdktf.stringToHclTerraform(struct!.password),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    text_secret: {
      value: cdktf.stringToHclTerraform(struct!.textSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    token: {
      value: cdktf.stringToHclTerraform(struct!.token),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    username: {
      value: cdktf.stringToHclTerraform(struct!.username),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1PrometheusAuthOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1PrometheusAuth | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._authType !== undefined) {
      hasAnyValues = true;
      internalValueResult.authType = this._authType;
    }
    if (this._credentialsSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.credentialsSecret = this._credentialsSecret;
    }
    if (this._password !== undefined) {
      hasAnyValues = true;
      internalValueResult.password = this._password;
    }
    if (this._textSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.textSecret = this._textSecret;
    }
    if (this._token !== undefined) {
      hasAnyValues = true;
      internalValueResult.token = this._token;
    }
    if (this._username !== undefined) {
      hasAnyValues = true;
      internalValueResult.username = this._username;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1PrometheusAuth | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._authType = undefined;
      this._credentialsSecret = undefined;
      this._password = undefined;
      this._textSecret = undefined;
      this._token = undefined;
      this._username = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._authType = value.authType;
      this._credentialsSecret = value.credentialsSecret;
      this._password = value.password;
      this._textSecret = value.textSecret;
      this._token = value.token;
      this._username = value.username;
    }
  }

  // auth_type - computed: true, optional: true, required: false
  private _authType?: string; 
  public get authType() {
    return this.getStringAttribute('auth_type');
  }
  public set authType(value: string) {
    this._authType = value;
  }
  public resetAuthType() {
    this._authType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authTypeInput() {
    return this._authType;
  }

  // credentials_secret - computed: false, optional: true, required: false
  private _credentialsSecret?: string; 
  public get credentialsSecret() {
    return this.getStringAttribute('credentials_secret');
  }
  public set credentialsSecret(value: string) {
    this._credentialsSecret = value;
  }
  public resetCredentialsSecret() {
    this._credentialsSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get credentialsSecretInput() {
    return this._credentialsSecret;
  }

  // password - computed: false, optional: true, required: false
  private _password?: string; 
  public get password() {
    return this.getStringAttribute('password');
  }
  public set password(value: string) {
    this._password = value;
  }
  public resetPassword() {
    this._password = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passwordInput() {
    return this._password;
  }

  // text_secret - computed: false, optional: true, required: false
  private _textSecret?: string; 
  public get textSecret() {
    return this.getStringAttribute('text_secret');
  }
  public set textSecret(value: string) {
    this._textSecret = value;
  }
  public resetTextSecret() {
    this._textSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get textSecretInput() {
    return this._textSecret;
  }

  // token - computed: false, optional: true, required: false
  private _token?: string; 
  public get token() {
    return this.getStringAttribute('token');
  }
  public set token(value: string) {
    this._token = value;
  }
  public resetToken() {
    this._token = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tokenInput() {
    return this._token;
  }

  // username - computed: false, optional: true, required: false
  private _username?: string; 
  public get username() {
    return this.getStringAttribute('username');
  }
  public set username(value: string) {
    this._username = value;
  }
  public resetUsername() {
    this._username = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usernameInput() {
    return this._username;
  }
}
export interface DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1ResponseRetrySettings {
  /**
  * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc. Default: 2
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#backoff_rate Destination#backoff_rate}
  */
  readonly backoffRate?: number;
  /**
  * The HTTP response status code that will trigger retries
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#http_status Destination#http_status}
  */
  readonly httpStatus: number;
  /**
  * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes). Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#initial_backoff Destination#initial_backoff}
  */
  readonly initialBackoff?: number;
  /**
  * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds). Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#max_backoff Destination#max_backoff}
  */
  readonly maxBackoff?: number;
}

export function destinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1ResponseRetrySettingsToTerraform(struct?: DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1ResponseRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    backoff_rate: cdktf.numberToTerraform(struct!.backoffRate),
    http_status: cdktf.numberToTerraform(struct!.httpStatus),
    initial_backoff: cdktf.numberToTerraform(struct!.initialBackoff),
    max_backoff: cdktf.numberToTerraform(struct!.maxBackoff),
  }
}


export function destinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1ResponseRetrySettingsToHclTerraform(struct?: DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1ResponseRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    backoff_rate: {
      value: cdktf.numberToHclTerraform(struct!.backoffRate),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    http_status: {
      value: cdktf.numberToHclTerraform(struct!.httpStatus),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    initial_backoff: {
      value: cdktf.numberToHclTerraform(struct!.initialBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_backoff: {
      value: cdktf.numberToHclTerraform(struct!.maxBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1ResponseRetrySettingsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1ResponseRetrySettings | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._backoffRate !== undefined) {
      hasAnyValues = true;
      internalValueResult.backoffRate = this._backoffRate;
    }
    if (this._httpStatus !== undefined) {
      hasAnyValues = true;
      internalValueResult.httpStatus = this._httpStatus;
    }
    if (this._initialBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.initialBackoff = this._initialBackoff;
    }
    if (this._maxBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBackoff = this._maxBackoff;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1ResponseRetrySettings | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._backoffRate = undefined;
      this._httpStatus = undefined;
      this._initialBackoff = undefined;
      this._maxBackoff = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._backoffRate = value.backoffRate;
      this._httpStatus = value.httpStatus;
      this._initialBackoff = value.initialBackoff;
      this._maxBackoff = value.maxBackoff;
    }
  }

  // backoff_rate - computed: true, optional: true, required: false
  private _backoffRate?: number; 
  public get backoffRate() {
    return this.getNumberAttribute('backoff_rate');
  }
  public set backoffRate(value: number) {
    this._backoffRate = value;
  }
  public resetBackoffRate() {
    this._backoffRate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get backoffRateInput() {
    return this._backoffRate;
  }

  // http_status - computed: false, optional: false, required: true
  private _httpStatus?: number; 
  public get httpStatus() {
    return this.getNumberAttribute('http_status');
  }
  public set httpStatus(value: number) {
    this._httpStatus = value;
  }
  // Temporarily expose input value. Use with caution.
  public get httpStatusInput() {
    return this._httpStatus;
  }

  // initial_backoff - computed: true, optional: true, required: false
  private _initialBackoff?: number; 
  public get initialBackoff() {
    return this.getNumberAttribute('initial_backoff');
  }
  public set initialBackoff(value: number) {
    this._initialBackoff = value;
  }
  public resetInitialBackoff() {
    this._initialBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get initialBackoffInput() {
    return this._initialBackoff;
  }

  // max_backoff - computed: true, optional: true, required: false
  private _maxBackoff?: number; 
  public get maxBackoff() {
    return this.getNumberAttribute('max_backoff');
  }
  public set maxBackoff(value: number) {
    this._maxBackoff = value;
  }
  public resetMaxBackoff() {
    this._maxBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBackoffInput() {
    return this._maxBackoff;
  }
}

export class DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1ResponseRetrySettingsList extends cdktf.ComplexList {
  public internalValue? : DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1ResponseRetrySettings[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1ResponseRetrySettingsOutputReference {
    return new DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1ResponseRetrySettingsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1TimeoutRetrySettings {
  /**
  * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc. Default: 2
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#backoff_rate Destination#backoff_rate}
  */
  readonly backoffRate?: number;
  /**
  * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes). Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#initial_backoff Destination#initial_backoff}
  */
  readonly initialBackoff?: number;
  /**
  * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds). Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#max_backoff Destination#max_backoff}
  */
  readonly maxBackoff?: number;
  /**
  * Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#timeout_retry Destination#timeout_retry}
  */
  readonly timeoutRetry?: boolean | cdktf.IResolvable;
}

export function destinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1TimeoutRetrySettingsToTerraform(struct?: DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1TimeoutRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    backoff_rate: cdktf.numberToTerraform(struct!.backoffRate),
    initial_backoff: cdktf.numberToTerraform(struct!.initialBackoff),
    max_backoff: cdktf.numberToTerraform(struct!.maxBackoff),
    timeout_retry: cdktf.booleanToTerraform(struct!.timeoutRetry),
  }
}


export function destinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1TimeoutRetrySettingsToHclTerraform(struct?: DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1TimeoutRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    backoff_rate: {
      value: cdktf.numberToHclTerraform(struct!.backoffRate),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    initial_backoff: {
      value: cdktf.numberToHclTerraform(struct!.initialBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_backoff: {
      value: cdktf.numberToHclTerraform(struct!.maxBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    timeout_retry: {
      value: cdktf.booleanToHclTerraform(struct!.timeoutRetry),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1TimeoutRetrySettingsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1TimeoutRetrySettings | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._backoffRate !== undefined) {
      hasAnyValues = true;
      internalValueResult.backoffRate = this._backoffRate;
    }
    if (this._initialBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.initialBackoff = this._initialBackoff;
    }
    if (this._maxBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBackoff = this._maxBackoff;
    }
    if (this._timeoutRetry !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutRetry = this._timeoutRetry;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1TimeoutRetrySettings | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._backoffRate = undefined;
      this._initialBackoff = undefined;
      this._maxBackoff = undefined;
      this._timeoutRetry = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._backoffRate = value.backoffRate;
      this._initialBackoff = value.initialBackoff;
      this._maxBackoff = value.maxBackoff;
      this._timeoutRetry = value.timeoutRetry;
    }
  }

  // backoff_rate - computed: true, optional: true, required: false
  private _backoffRate?: number; 
  public get backoffRate() {
    return this.getNumberAttribute('backoff_rate');
  }
  public set backoffRate(value: number) {
    this._backoffRate = value;
  }
  public resetBackoffRate() {
    this._backoffRate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get backoffRateInput() {
    return this._backoffRate;
  }

  // initial_backoff - computed: true, optional: true, required: false
  private _initialBackoff?: number; 
  public get initialBackoff() {
    return this.getNumberAttribute('initial_backoff');
  }
  public set initialBackoff(value: number) {
    this._initialBackoff = value;
  }
  public resetInitialBackoff() {
    this._initialBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get initialBackoffInput() {
    return this._initialBackoff;
  }

  // max_backoff - computed: true, optional: true, required: false
  private _maxBackoff?: number; 
  public get maxBackoff() {
    return this.getNumberAttribute('max_backoff');
  }
  public set maxBackoff(value: number) {
    this._maxBackoff = value;
  }
  public resetMaxBackoff() {
    this._maxBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBackoffInput() {
    return this._maxBackoff;
  }

  // timeout_retry - computed: true, optional: true, required: false
  private _timeoutRetry?: boolean | cdktf.IResolvable; 
  public get timeoutRetry() {
    return this.getBooleanAttribute('timeout_retry');
  }
  public set timeoutRetry(value: boolean | cdktf.IResolvable) {
    this._timeoutRetry = value;
  }
  public resetTimeoutRetry() {
    this._timeoutRetry = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutRetryInput() {
    return this._timeoutRetry;
  }
}
export interface DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1 {
  /**
  * Compress the payload body before sending. Applies only to JSON payloads; the Protobuf variant for both Prometheus and Loki are snappy-compressed by default. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#compress Destination#compress}
  */
  readonly compress?: boolean | cdktf.IResolvable;
  /**
  * Maximum number of ongoing requests before blocking. Warning: Setting this value > 1 can cause Loki and Prometheus to complain about entries being delivered out of order. Default: 1
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#concurrency Destination#concurrency}
  */
  readonly concurrency?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#description Destination#description}
  */
  readonly description?: string;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#environment Destination#environment}
  */
  readonly environment?: string;
  /**
  * Headers to add to all events
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#extra_http_headers Destination#extra_http_headers}
  */
  readonly extraHttpHeaders?: DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1ExtraHttpHeaders[] | cdktf.IResolvable;
  /**
  * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below. Default: "none"; must be one of ["payload", "payloadAndHeaders", "none"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#failed_request_logging_mode Destination#failed_request_logging_mode}
  */
  readonly failedRequestLoggingMode?: string;
  /**
  * Maximum time between requests. Small values could cause the payload size to be smaller than the configured Maximum time between requests. Small values can reduce the payload size below the configured 'Max record size' and 'Max events per request'. Warning: Setting this too low can increase the number of ongoing requests (depending on the value of 'Request concurrency'); this can cause Loki and Prometheus to complain about entries being delivered out of order. Default: 15
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#flush_period_sec Destination#flush_period_sec}
  */
  readonly flushPeriodSec?: number;
  /**
  * Unique ID for this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#id Destination#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id: string;
  /**
  * List of labels to send with logs. Labels define Loki streams, so use static labels to avoid proliferating label value combinations and streams. Can be merged and/or overridden by the events __labels field. Example: "__labels: {host: "cribl.io", level: "error"}"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#labels Destination#labels}
  */
  readonly labels?: DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1Labels[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#loki_auth Destination#loki_auth}
  */
  readonly lokiAuth?: DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1LokiAuth;
  /**
  * The endpoint to send logs to, such as https://logs-prod-us-central1.grafana.net
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#loki_url Destination#loki_url}
  */
  readonly lokiUrl: string;
  /**
  * Maximum number of events to include in the request body. Default is 0 (unlimited). Warning: Setting this too low can increase the number of ongoing requests (depending on the value of 'Request concurrency'); this can cause Loki and Prometheus to complain about entries being delivered out of order. Default: 0
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#max_payload_events Destination#max_payload_events}
  */
  readonly maxPayloadEvents?: number;
  /**
  * Maximum size, in KB, of the request body. Warning: Setting this too low can increase the number of ongoing requests (depending on the value of 'Request concurrency'); this can cause Loki and Prometheus to complain about entries being delivered out of order. Default: 4096
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#max_payload_size_kb Destination#max_payload_size_kb}
  */
  readonly maxPayloadSizeKb?: number;
  /**
  * Name of the event field that contains the message to send. If not specified, Stream sends a JSON representation of the whole event.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#message Destination#message}
  */
  readonly message?: string;
  /**
  * Format to use when sending logs to Loki (Protobuf or JSON). Default: "protobuf"; must be one of ["protobuf", "json"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#message_format Destination#message_format}
  */
  readonly messageFormat?: string;
  /**
  * JavaScript expression that can be used to rename metrics. For example, name.replace(/\./g, '_') will replace all '.' characters in a metric's name with the supported '_' character. Use the 'name' global variable to access the metric's name. You can access event fields' values via __e.<fieldName>. Default: "name.replace(/[^a-zA-Z0-9_]/g, '_')"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#metric_rename_expr Destination#metric_rename_expr}
  */
  readonly metricRenameExpr?: string;
  /**
  * How to handle events when all receivers are exerting backpressure. Default: "block"; must be one of ["block", "drop", "queue"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#on_backpressure Destination#on_backpressure}
  */
  readonly onBackpressure?: string;
  /**
  * Pipeline to process data before sending out to this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pipeline Destination#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pq_compress Destination#pq_compress}
  */
  readonly pqCompress?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pq_controls Destination#pq_controls}
  */
  readonly pqControls?: DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1PqControls;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.). Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pq_max_file_size Destination#pq_max_file_size}
  */
  readonly pqMaxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pq_max_size Destination#pq_max_size}
  */
  readonly pqMaxSize?: string;
  /**
  * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem. Default: "error"; must be one of ["error", "backpressure", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pq_mode Destination#pq_mode}
  */
  readonly pqMode?: string;
  /**
  * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged. Default: "block"; must be one of ["block", "drop"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pq_on_backpressure Destination#pq_on_backpressure}
  */
  readonly pqOnBackpressure?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pq_path Destination#pq_path}
  */
  readonly pqPath?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#prometheus_auth Destination#prometheus_auth}
  */
  readonly prometheusAuth?: DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1PrometheusAuth;
  /**
  * The remote_write endpoint to send Prometheus metrics to, such as https://prometheus-blocks-prod-us-central1.grafana.net/api/prom/push
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#prometheus_url Destination#prometheus_url}
  */
  readonly prometheusUrl?: string;
  /**
  * Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's). 
  *         Enabled by default. When this setting is also present in TLS Settings (Client Side), 
  *         that value will take precedence.
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#reject_unauthorized Destination#reject_unauthorized}
  */
  readonly rejectUnauthorized?: boolean | cdktf.IResolvable;
  /**
  * Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#response_honor_retry_after_header Destination#response_honor_retry_after_header}
  */
  readonly responseHonorRetryAfterHeader?: boolean | cdktf.IResolvable;
  /**
  * Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#response_retry_settings Destination#response_retry_settings}
  */
  readonly responseRetrySettings?: DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1ResponseRetrySettings[] | cdktf.IResolvable;
  /**
  * List of headers that are safe to log in plain text. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#safe_headers Destination#safe_headers}
  */
  readonly safeHeaders?: string[];
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#streamtags Destination#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Fields to automatically add to events, such as cribl_pipe. Supports wildcards. These fields are added as dimensions and labels to generated metrics and logs, respectively. Default: ["cribl_host","cribl_wp"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#system_fields Destination#system_fields}
  */
  readonly systemFields?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#timeout_retry_settings Destination#timeout_retry_settings}
  */
  readonly timeoutRetrySettings?: DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1TimeoutRetrySettings;
  /**
  * Amount of time, in seconds, to wait for a request to complete before canceling it. Default: 30
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#timeout_sec Destination#timeout_sec}
  */
  readonly timeoutSec?: number;
  /**
  * must be "grafana_cloud"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#type Destination#type}
  */
  readonly type: string;
  /**
  * Enable round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. For optimal performance, consider enabling this setting for non-load balanced destinations. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#use_round_robin_dns Destination#use_round_robin_dns}
  */
  readonly useRoundRobinDns?: boolean | cdktf.IResolvable;
}

export function destinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1ToTerraform(struct?: DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1 | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    compress: cdktf.booleanToTerraform(struct!.compress),
    concurrency: cdktf.numberToTerraform(struct!.concurrency),
    description: cdktf.stringToTerraform(struct!.description),
    environment: cdktf.stringToTerraform(struct!.environment),
    extra_http_headers: cdktf.listMapper(destinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1ExtraHttpHeadersToTerraform, false)(struct!.extraHttpHeaders),
    failed_request_logging_mode: cdktf.stringToTerraform(struct!.failedRequestLoggingMode),
    flush_period_sec: cdktf.numberToTerraform(struct!.flushPeriodSec),
    id: cdktf.stringToTerraform(struct!.id),
    labels: cdktf.listMapper(destinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1LabelsToTerraform, false)(struct!.labels),
    loki_auth: destinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1LokiAuthToTerraform(struct!.lokiAuth),
    loki_url: cdktf.stringToTerraform(struct!.lokiUrl),
    max_payload_events: cdktf.numberToTerraform(struct!.maxPayloadEvents),
    max_payload_size_kb: cdktf.numberToTerraform(struct!.maxPayloadSizeKb),
    message: cdktf.stringToTerraform(struct!.message),
    message_format: cdktf.stringToTerraform(struct!.messageFormat),
    metric_rename_expr: cdktf.stringToTerraform(struct!.metricRenameExpr),
    on_backpressure: cdktf.stringToTerraform(struct!.onBackpressure),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    pq_compress: cdktf.stringToTerraform(struct!.pqCompress),
    pq_controls: destinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1PqControlsToTerraform(struct!.pqControls),
    pq_max_file_size: cdktf.stringToTerraform(struct!.pqMaxFileSize),
    pq_max_size: cdktf.stringToTerraform(struct!.pqMaxSize),
    pq_mode: cdktf.stringToTerraform(struct!.pqMode),
    pq_on_backpressure: cdktf.stringToTerraform(struct!.pqOnBackpressure),
    pq_path: cdktf.stringToTerraform(struct!.pqPath),
    prometheus_auth: destinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1PrometheusAuthToTerraform(struct!.prometheusAuth),
    prometheus_url: cdktf.stringToTerraform(struct!.prometheusUrl),
    reject_unauthorized: cdktf.booleanToTerraform(struct!.rejectUnauthorized),
    response_honor_retry_after_header: cdktf.booleanToTerraform(struct!.responseHonorRetryAfterHeader),
    response_retry_settings: cdktf.listMapper(destinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1ResponseRetrySettingsToTerraform, false)(struct!.responseRetrySettings),
    safe_headers: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.safeHeaders),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    system_fields: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.systemFields),
    timeout_retry_settings: destinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1TimeoutRetrySettingsToTerraform(struct!.timeoutRetrySettings),
    timeout_sec: cdktf.numberToTerraform(struct!.timeoutSec),
    type: cdktf.stringToTerraform(struct!.type),
    use_round_robin_dns: cdktf.booleanToTerraform(struct!.useRoundRobinDns),
  }
}


export function destinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1ToHclTerraform(struct?: DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1 | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    compress: {
      value: cdktf.booleanToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    concurrency: {
      value: cdktf.numberToHclTerraform(struct!.concurrency),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    extra_http_headers: {
      value: cdktf.listMapperHcl(destinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1ExtraHttpHeadersToHclTerraform, false)(struct!.extraHttpHeaders),
      isBlock: true,
      type: "list",
      storageClassType: "DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1ExtraHttpHeadersList",
    },
    failed_request_logging_mode: {
      value: cdktf.stringToHclTerraform(struct!.failedRequestLoggingMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    flush_period_sec: {
      value: cdktf.numberToHclTerraform(struct!.flushPeriodSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    labels: {
      value: cdktf.listMapperHcl(destinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1LabelsToHclTerraform, false)(struct!.labels),
      isBlock: true,
      type: "list",
      storageClassType: "DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1LabelsList",
    },
    loki_auth: {
      value: destinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1LokiAuthToHclTerraform(struct!.lokiAuth),
      isBlock: true,
      type: "struct",
      storageClassType: "DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1LokiAuth",
    },
    loki_url: {
      value: cdktf.stringToHclTerraform(struct!.lokiUrl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_payload_events: {
      value: cdktf.numberToHclTerraform(struct!.maxPayloadEvents),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_payload_size_kb: {
      value: cdktf.numberToHclTerraform(struct!.maxPayloadSizeKb),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    message: {
      value: cdktf.stringToHclTerraform(struct!.message),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    message_format: {
      value: cdktf.stringToHclTerraform(struct!.messageFormat),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    metric_rename_expr: {
      value: cdktf.stringToHclTerraform(struct!.metricRenameExpr),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.onBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_compress: {
      value: cdktf.stringToHclTerraform(struct!.pqCompress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_controls: {
      value: destinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1PqControlsToHclTerraform(struct!.pqControls),
      isBlock: true,
      type: "struct",
      storageClassType: "DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1PqControls",
    },
    pq_max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_max_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_mode: {
      value: cdktf.stringToHclTerraform(struct!.pqMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.pqOnBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_path: {
      value: cdktf.stringToHclTerraform(struct!.pqPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    prometheus_auth: {
      value: destinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1PrometheusAuthToHclTerraform(struct!.prometheusAuth),
      isBlock: true,
      type: "struct",
      storageClassType: "DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1PrometheusAuth",
    },
    prometheus_url: {
      value: cdktf.stringToHclTerraform(struct!.prometheusUrl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reject_unauthorized: {
      value: cdktf.booleanToHclTerraform(struct!.rejectUnauthorized),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    response_honor_retry_after_header: {
      value: cdktf.booleanToHclTerraform(struct!.responseHonorRetryAfterHeader),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    response_retry_settings: {
      value: cdktf.listMapperHcl(destinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1ResponseRetrySettingsToHclTerraform, false)(struct!.responseRetrySettings),
      isBlock: true,
      type: "list",
      storageClassType: "DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1ResponseRetrySettingsList",
    },
    safe_headers: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.safeHeaders),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    system_fields: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.systemFields),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    timeout_retry_settings: {
      value: destinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1TimeoutRetrySettingsToHclTerraform(struct!.timeoutRetrySettings),
      isBlock: true,
      type: "struct",
      storageClassType: "DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1TimeoutRetrySettings",
    },
    timeout_sec: {
      value: cdktf.numberToHclTerraform(struct!.timeoutSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    use_round_robin_dns: {
      value: cdktf.booleanToHclTerraform(struct!.useRoundRobinDns),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1OutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1 | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._concurrency !== undefined) {
      hasAnyValues = true;
      internalValueResult.concurrency = this._concurrency;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._extraHttpHeaders?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.extraHttpHeaders = this._extraHttpHeaders?.internalValue;
    }
    if (this._failedRequestLoggingMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.failedRequestLoggingMode = this._failedRequestLoggingMode;
    }
    if (this._flushPeriodSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.flushPeriodSec = this._flushPeriodSec;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._labels?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.labels = this._labels?.internalValue;
    }
    if (this._lokiAuth?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.lokiAuth = this._lokiAuth?.internalValue;
    }
    if (this._lokiUrl !== undefined) {
      hasAnyValues = true;
      internalValueResult.lokiUrl = this._lokiUrl;
    }
    if (this._maxPayloadEvents !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxPayloadEvents = this._maxPayloadEvents;
    }
    if (this._maxPayloadSizeKb !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxPayloadSizeKb = this._maxPayloadSizeKb;
    }
    if (this._message !== undefined) {
      hasAnyValues = true;
      internalValueResult.message = this._message;
    }
    if (this._messageFormat !== undefined) {
      hasAnyValues = true;
      internalValueResult.messageFormat = this._messageFormat;
    }
    if (this._metricRenameExpr !== undefined) {
      hasAnyValues = true;
      internalValueResult.metricRenameExpr = this._metricRenameExpr;
    }
    if (this._onBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.onBackpressure = this._onBackpressure;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._pqCompress !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqCompress = this._pqCompress;
    }
    if (this._pqControls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqControls = this._pqControls?.internalValue;
    }
    if (this._pqMaxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxFileSize = this._pqMaxFileSize;
    }
    if (this._pqMaxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxSize = this._pqMaxSize;
    }
    if (this._pqMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMode = this._pqMode;
    }
    if (this._pqOnBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqOnBackpressure = this._pqOnBackpressure;
    }
    if (this._pqPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqPath = this._pqPath;
    }
    if (this._prometheusAuth?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.prometheusAuth = this._prometheusAuth?.internalValue;
    }
    if (this._prometheusUrl !== undefined) {
      hasAnyValues = true;
      internalValueResult.prometheusUrl = this._prometheusUrl;
    }
    if (this._rejectUnauthorized !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectUnauthorized = this._rejectUnauthorized;
    }
    if (this._responseHonorRetryAfterHeader !== undefined) {
      hasAnyValues = true;
      internalValueResult.responseHonorRetryAfterHeader = this._responseHonorRetryAfterHeader;
    }
    if (this._responseRetrySettings?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.responseRetrySettings = this._responseRetrySettings?.internalValue;
    }
    if (this._safeHeaders !== undefined) {
      hasAnyValues = true;
      internalValueResult.safeHeaders = this._safeHeaders;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._systemFields !== undefined) {
      hasAnyValues = true;
      internalValueResult.systemFields = this._systemFields;
    }
    if (this._timeoutRetrySettings?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutRetrySettings = this._timeoutRetrySettings?.internalValue;
    }
    if (this._timeoutSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutSec = this._timeoutSec;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._useRoundRobinDns !== undefined) {
      hasAnyValues = true;
      internalValueResult.useRoundRobinDns = this._useRoundRobinDns;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1 | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._compress = undefined;
      this._concurrency = undefined;
      this._description = undefined;
      this._environment = undefined;
      this._extraHttpHeaders.internalValue = undefined;
      this._failedRequestLoggingMode = undefined;
      this._flushPeriodSec = undefined;
      this._id = undefined;
      this._labels.internalValue = undefined;
      this._lokiAuth.internalValue = undefined;
      this._lokiUrl = undefined;
      this._maxPayloadEvents = undefined;
      this._maxPayloadSizeKb = undefined;
      this._message = undefined;
      this._messageFormat = undefined;
      this._metricRenameExpr = undefined;
      this._onBackpressure = undefined;
      this._pipeline = undefined;
      this._pqCompress = undefined;
      this._pqControls.internalValue = undefined;
      this._pqMaxFileSize = undefined;
      this._pqMaxSize = undefined;
      this._pqMode = undefined;
      this._pqOnBackpressure = undefined;
      this._pqPath = undefined;
      this._prometheusAuth.internalValue = undefined;
      this._prometheusUrl = undefined;
      this._rejectUnauthorized = undefined;
      this._responseHonorRetryAfterHeader = undefined;
      this._responseRetrySettings.internalValue = undefined;
      this._safeHeaders = undefined;
      this._streamtags = undefined;
      this._systemFields = undefined;
      this._timeoutRetrySettings.internalValue = undefined;
      this._timeoutSec = undefined;
      this._type = undefined;
      this._useRoundRobinDns = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._compress = value.compress;
      this._concurrency = value.concurrency;
      this._description = value.description;
      this._environment = value.environment;
      this._extraHttpHeaders.internalValue = value.extraHttpHeaders;
      this._failedRequestLoggingMode = value.failedRequestLoggingMode;
      this._flushPeriodSec = value.flushPeriodSec;
      this._id = value.id;
      this._labels.internalValue = value.labels;
      this._lokiAuth.internalValue = value.lokiAuth;
      this._lokiUrl = value.lokiUrl;
      this._maxPayloadEvents = value.maxPayloadEvents;
      this._maxPayloadSizeKb = value.maxPayloadSizeKb;
      this._message = value.message;
      this._messageFormat = value.messageFormat;
      this._metricRenameExpr = value.metricRenameExpr;
      this._onBackpressure = value.onBackpressure;
      this._pipeline = value.pipeline;
      this._pqCompress = value.pqCompress;
      this._pqControls.internalValue = value.pqControls;
      this._pqMaxFileSize = value.pqMaxFileSize;
      this._pqMaxSize = value.pqMaxSize;
      this._pqMode = value.pqMode;
      this._pqOnBackpressure = value.pqOnBackpressure;
      this._pqPath = value.pqPath;
      this._prometheusAuth.internalValue = value.prometheusAuth;
      this._prometheusUrl = value.prometheusUrl;
      this._rejectUnauthorized = value.rejectUnauthorized;
      this._responseHonorRetryAfterHeader = value.responseHonorRetryAfterHeader;
      this._responseRetrySettings.internalValue = value.responseRetrySettings;
      this._safeHeaders = value.safeHeaders;
      this._streamtags = value.streamtags;
      this._systemFields = value.systemFields;
      this._timeoutRetrySettings.internalValue = value.timeoutRetrySettings;
      this._timeoutSec = value.timeoutSec;
      this._type = value.type;
      this._useRoundRobinDns = value.useRoundRobinDns;
    }
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: boolean | cdktf.IResolvable; 
  public get compress() {
    return this.getBooleanAttribute('compress');
  }
  public set compress(value: boolean | cdktf.IResolvable) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // concurrency - computed: true, optional: true, required: false
  private _concurrency?: number; 
  public get concurrency() {
    return this.getNumberAttribute('concurrency');
  }
  public set concurrency(value: number) {
    this._concurrency = value;
  }
  public resetConcurrency() {
    this._concurrency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get concurrencyInput() {
    return this._concurrency;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // extra_http_headers - computed: false, optional: true, required: false
  private _extraHttpHeaders = new DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1ExtraHttpHeadersList(this, "extra_http_headers", false);
  public get extraHttpHeaders() {
    return this._extraHttpHeaders;
  }
  public putExtraHttpHeaders(value: DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1ExtraHttpHeaders[] | cdktf.IResolvable) {
    this._extraHttpHeaders.internalValue = value;
  }
  public resetExtraHttpHeaders() {
    this._extraHttpHeaders.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get extraHttpHeadersInput() {
    return this._extraHttpHeaders.internalValue;
  }

  // failed_request_logging_mode - computed: true, optional: true, required: false
  private _failedRequestLoggingMode?: string; 
  public get failedRequestLoggingMode() {
    return this.getStringAttribute('failed_request_logging_mode');
  }
  public set failedRequestLoggingMode(value: string) {
    this._failedRequestLoggingMode = value;
  }
  public resetFailedRequestLoggingMode() {
    this._failedRequestLoggingMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get failedRequestLoggingModeInput() {
    return this._failedRequestLoggingMode;
  }

  // flush_period_sec - computed: true, optional: true, required: false
  private _flushPeriodSec?: number; 
  public get flushPeriodSec() {
    return this.getNumberAttribute('flush_period_sec');
  }
  public set flushPeriodSec(value: number) {
    this._flushPeriodSec = value;
  }
  public resetFlushPeriodSec() {
    this._flushPeriodSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get flushPeriodSecInput() {
    return this._flushPeriodSec;
  }

  // id - computed: false, optional: false, required: true
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // labels - computed: false, optional: true, required: false
  private _labels = new DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1LabelsList(this, "labels", false);
  public get labels() {
    return this._labels;
  }
  public putLabels(value: DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1Labels[] | cdktf.IResolvable) {
    this._labels.internalValue = value;
  }
  public resetLabels() {
    this._labels.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelsInput() {
    return this._labels.internalValue;
  }

  // loki_auth - computed: false, optional: true, required: false
  private _lokiAuth = new DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1LokiAuthOutputReference(this, "loki_auth");
  public get lokiAuth() {
    return this._lokiAuth;
  }
  public putLokiAuth(value: DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1LokiAuth) {
    this._lokiAuth.internalValue = value;
  }
  public resetLokiAuth() {
    this._lokiAuth.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get lokiAuthInput() {
    return this._lokiAuth.internalValue;
  }

  // loki_url - computed: false, optional: false, required: true
  private _lokiUrl?: string; 
  public get lokiUrl() {
    return this.getStringAttribute('loki_url');
  }
  public set lokiUrl(value: string) {
    this._lokiUrl = value;
  }
  // Temporarily expose input value. Use with caution.
  public get lokiUrlInput() {
    return this._lokiUrl;
  }

  // max_payload_events - computed: true, optional: true, required: false
  private _maxPayloadEvents?: number; 
  public get maxPayloadEvents() {
    return this.getNumberAttribute('max_payload_events');
  }
  public set maxPayloadEvents(value: number) {
    this._maxPayloadEvents = value;
  }
  public resetMaxPayloadEvents() {
    this._maxPayloadEvents = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxPayloadEventsInput() {
    return this._maxPayloadEvents;
  }

  // max_payload_size_kb - computed: true, optional: true, required: false
  private _maxPayloadSizeKb?: number; 
  public get maxPayloadSizeKb() {
    return this.getNumberAttribute('max_payload_size_kb');
  }
  public set maxPayloadSizeKb(value: number) {
    this._maxPayloadSizeKb = value;
  }
  public resetMaxPayloadSizeKb() {
    this._maxPayloadSizeKb = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxPayloadSizeKbInput() {
    return this._maxPayloadSizeKb;
  }

  // message - computed: false, optional: true, required: false
  private _message?: string; 
  public get message() {
    return this.getStringAttribute('message');
  }
  public set message(value: string) {
    this._message = value;
  }
  public resetMessage() {
    this._message = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get messageInput() {
    return this._message;
  }

  // message_format - computed: true, optional: true, required: false
  private _messageFormat?: string; 
  public get messageFormat() {
    return this.getStringAttribute('message_format');
  }
  public set messageFormat(value: string) {
    this._messageFormat = value;
  }
  public resetMessageFormat() {
    this._messageFormat = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get messageFormatInput() {
    return this._messageFormat;
  }

  // metric_rename_expr - computed: true, optional: true, required: false
  private _metricRenameExpr?: string; 
  public get metricRenameExpr() {
    return this.getStringAttribute('metric_rename_expr');
  }
  public set metricRenameExpr(value: string) {
    this._metricRenameExpr = value;
  }
  public resetMetricRenameExpr() {
    this._metricRenameExpr = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metricRenameExprInput() {
    return this._metricRenameExpr;
  }

  // on_backpressure - computed: true, optional: true, required: false
  private _onBackpressure?: string; 
  public get onBackpressure() {
    return this.getStringAttribute('on_backpressure');
  }
  public set onBackpressure(value: string) {
    this._onBackpressure = value;
  }
  public resetOnBackpressure() {
    this._onBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get onBackpressureInput() {
    return this._onBackpressure;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // pq_compress - computed: true, optional: true, required: false
  private _pqCompress?: string; 
  public get pqCompress() {
    return this.getStringAttribute('pq_compress');
  }
  public set pqCompress(value: string) {
    this._pqCompress = value;
  }
  public resetPqCompress() {
    this._pqCompress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqCompressInput() {
    return this._pqCompress;
  }

  // pq_controls - computed: false, optional: true, required: false
  private _pqControls = new DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1PqControlsOutputReference(this, "pq_controls");
  public get pqControls() {
    return this._pqControls;
  }
  public putPqControls(value: DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1PqControls) {
    this._pqControls.internalValue = value;
  }
  public resetPqControls() {
    this._pqControls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqControlsInput() {
    return this._pqControls.internalValue;
  }

  // pq_max_file_size - computed: true, optional: true, required: false
  private _pqMaxFileSize?: string; 
  public get pqMaxFileSize() {
    return this.getStringAttribute('pq_max_file_size');
  }
  public set pqMaxFileSize(value: string) {
    this._pqMaxFileSize = value;
  }
  public resetPqMaxFileSize() {
    this._pqMaxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxFileSizeInput() {
    return this._pqMaxFileSize;
  }

  // pq_max_size - computed: true, optional: true, required: false
  private _pqMaxSize?: string; 
  public get pqMaxSize() {
    return this.getStringAttribute('pq_max_size');
  }
  public set pqMaxSize(value: string) {
    this._pqMaxSize = value;
  }
  public resetPqMaxSize() {
    this._pqMaxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxSizeInput() {
    return this._pqMaxSize;
  }

  // pq_mode - computed: true, optional: true, required: false
  private _pqMode?: string; 
  public get pqMode() {
    return this.getStringAttribute('pq_mode');
  }
  public set pqMode(value: string) {
    this._pqMode = value;
  }
  public resetPqMode() {
    this._pqMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqModeInput() {
    return this._pqMode;
  }

  // pq_on_backpressure - computed: true, optional: true, required: false
  private _pqOnBackpressure?: string; 
  public get pqOnBackpressure() {
    return this.getStringAttribute('pq_on_backpressure');
  }
  public set pqOnBackpressure(value: string) {
    this._pqOnBackpressure = value;
  }
  public resetPqOnBackpressure() {
    this._pqOnBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqOnBackpressureInput() {
    return this._pqOnBackpressure;
  }

  // pq_path - computed: true, optional: true, required: false
  private _pqPath?: string; 
  public get pqPath() {
    return this.getStringAttribute('pq_path');
  }
  public set pqPath(value: string) {
    this._pqPath = value;
  }
  public resetPqPath() {
    this._pqPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqPathInput() {
    return this._pqPath;
  }

  // prometheus_auth - computed: false, optional: true, required: false
  private _prometheusAuth = new DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1PrometheusAuthOutputReference(this, "prometheus_auth");
  public get prometheusAuth() {
    return this._prometheusAuth;
  }
  public putPrometheusAuth(value: DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1PrometheusAuth) {
    this._prometheusAuth.internalValue = value;
  }
  public resetPrometheusAuth() {
    this._prometheusAuth.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get prometheusAuthInput() {
    return this._prometheusAuth.internalValue;
  }

  // prometheus_url - computed: false, optional: true, required: false
  private _prometheusUrl?: string; 
  public get prometheusUrl() {
    return this.getStringAttribute('prometheus_url');
  }
  public set prometheusUrl(value: string) {
    this._prometheusUrl = value;
  }
  public resetPrometheusUrl() {
    this._prometheusUrl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get prometheusUrlInput() {
    return this._prometheusUrl;
  }

  // reject_unauthorized - computed: true, optional: true, required: false
  private _rejectUnauthorized?: boolean | cdktf.IResolvable; 
  public get rejectUnauthorized() {
    return this.getBooleanAttribute('reject_unauthorized');
  }
  public set rejectUnauthorized(value: boolean | cdktf.IResolvable) {
    this._rejectUnauthorized = value;
  }
  public resetRejectUnauthorized() {
    this._rejectUnauthorized = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectUnauthorizedInput() {
    return this._rejectUnauthorized;
  }

  // response_honor_retry_after_header - computed: true, optional: true, required: false
  private _responseHonorRetryAfterHeader?: boolean | cdktf.IResolvable; 
  public get responseHonorRetryAfterHeader() {
    return this.getBooleanAttribute('response_honor_retry_after_header');
  }
  public set responseHonorRetryAfterHeader(value: boolean | cdktf.IResolvable) {
    this._responseHonorRetryAfterHeader = value;
  }
  public resetResponseHonorRetryAfterHeader() {
    this._responseHonorRetryAfterHeader = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get responseHonorRetryAfterHeaderInput() {
    return this._responseHonorRetryAfterHeader;
  }

  // response_retry_settings - computed: false, optional: true, required: false
  private _responseRetrySettings = new DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1ResponseRetrySettingsList(this, "response_retry_settings", false);
  public get responseRetrySettings() {
    return this._responseRetrySettings;
  }
  public putResponseRetrySettings(value: DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1ResponseRetrySettings[] | cdktf.IResolvable) {
    this._responseRetrySettings.internalValue = value;
  }
  public resetResponseRetrySettings() {
    this._responseRetrySettings.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get responseRetrySettingsInput() {
    return this._responseRetrySettings.internalValue;
  }

  // safe_headers - computed: true, optional: true, required: false
  private _safeHeaders?: string[]; 
  public get safeHeaders() {
    return this.getListAttribute('safe_headers');
  }
  public set safeHeaders(value: string[]) {
    this._safeHeaders = value;
  }
  public resetSafeHeaders() {
    this._safeHeaders = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get safeHeadersInput() {
    return this._safeHeaders;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // system_fields - computed: true, optional: true, required: false
  private _systemFields?: string[]; 
  public get systemFields() {
    return this.getListAttribute('system_fields');
  }
  public set systemFields(value: string[]) {
    this._systemFields = value;
  }
  public resetSystemFields() {
    this._systemFields = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get systemFieldsInput() {
    return this._systemFields;
  }

  // timeout_retry_settings - computed: false, optional: true, required: false
  private _timeoutRetrySettings = new DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1TimeoutRetrySettingsOutputReference(this, "timeout_retry_settings");
  public get timeoutRetrySettings() {
    return this._timeoutRetrySettings;
  }
  public putTimeoutRetrySettings(value: DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1TimeoutRetrySettings) {
    this._timeoutRetrySettings.internalValue = value;
  }
  public resetTimeoutRetrySettings() {
    this._timeoutRetrySettings.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutRetrySettingsInput() {
    return this._timeoutRetrySettings.internalValue;
  }

  // timeout_sec - computed: true, optional: true, required: false
  private _timeoutSec?: number; 
  public get timeoutSec() {
    return this.getNumberAttribute('timeout_sec');
  }
  public set timeoutSec(value: number) {
    this._timeoutSec = value;
  }
  public resetTimeoutSec() {
    this._timeoutSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutSecInput() {
    return this._timeoutSec;
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // use_round_robin_dns - computed: true, optional: true, required: false
  private _useRoundRobinDns?: boolean | cdktf.IResolvable; 
  public get useRoundRobinDns() {
    return this.getBooleanAttribute('use_round_robin_dns');
  }
  public set useRoundRobinDns(value: boolean | cdktf.IResolvable) {
    this._useRoundRobinDns = value;
  }
  public resetUseRoundRobinDns() {
    this._useRoundRobinDns = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get useRoundRobinDnsInput() {
    return this._useRoundRobinDns;
  }
}
export interface DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2ExtraHttpHeaders {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#name Destination#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#value Destination#value}
  */
  readonly value: string;
}

export function destinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2ExtraHttpHeadersToTerraform(struct?: DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2ExtraHttpHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function destinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2ExtraHttpHeadersToHclTerraform(struct?: DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2ExtraHttpHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2ExtraHttpHeadersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2ExtraHttpHeaders | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2ExtraHttpHeaders | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2ExtraHttpHeadersList extends cdktf.ComplexList {
  public internalValue? : DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2ExtraHttpHeaders[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2ExtraHttpHeadersOutputReference {
    return new DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2ExtraHttpHeadersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2Labels {
  /**
  * Default: ""
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#name Destination#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#value Destination#value}
  */
  readonly value: string;
}

export function destinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2LabelsToTerraform(struct?: DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2Labels | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function destinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2LabelsToHclTerraform(struct?: DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2Labels | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2LabelsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2Labels | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2Labels | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: true, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2LabelsList extends cdktf.ComplexList {
  public internalValue? : DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2Labels[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2LabelsOutputReference {
    return new DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2LabelsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2LokiAuth {
  /**
  * Default: "basic"; must be one of ["none", "token", "textSecret", "basic", "credentialsSecret"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#auth_type Destination#auth_type}
  */
  readonly authType?: string;
  /**
  * Select or create a secret that references your credentials
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#credentials_secret Destination#credentials_secret}
  */
  readonly credentialsSecret?: string;
  /**
  * Password (API key in Grafana Cloud domain) for authentication
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#password Destination#password}
  */
  readonly password?: string;
  /**
  * Select or create a stored text secret
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#text_secret Destination#text_secret}
  */
  readonly textSecret?: string;
  /**
  * Bearer token to include in the authorization header. In Grafana Cloud, this is generally built by concatenating the username and the API key, separated by a colon. Example: <your-username>:<your-api-key>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#token Destination#token}
  */
  readonly token?: string;
  /**
  * Username for authentication
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#username Destination#username}
  */
  readonly username?: string;
}

export function destinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2LokiAuthToTerraform(struct?: DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2LokiAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    auth_type: cdktf.stringToTerraform(struct!.authType),
    credentials_secret: cdktf.stringToTerraform(struct!.credentialsSecret),
    password: cdktf.stringToTerraform(struct!.password),
    text_secret: cdktf.stringToTerraform(struct!.textSecret),
    token: cdktf.stringToTerraform(struct!.token),
    username: cdktf.stringToTerraform(struct!.username),
  }
}


export function destinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2LokiAuthToHclTerraform(struct?: DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2LokiAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    auth_type: {
      value: cdktf.stringToHclTerraform(struct!.authType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    credentials_secret: {
      value: cdktf.stringToHclTerraform(struct!.credentialsSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    password: {
      value: cdktf.stringToHclTerraform(struct!.password),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    text_secret: {
      value: cdktf.stringToHclTerraform(struct!.textSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    token: {
      value: cdktf.stringToHclTerraform(struct!.token),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    username: {
      value: cdktf.stringToHclTerraform(struct!.username),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2LokiAuthOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2LokiAuth | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._authType !== undefined) {
      hasAnyValues = true;
      internalValueResult.authType = this._authType;
    }
    if (this._credentialsSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.credentialsSecret = this._credentialsSecret;
    }
    if (this._password !== undefined) {
      hasAnyValues = true;
      internalValueResult.password = this._password;
    }
    if (this._textSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.textSecret = this._textSecret;
    }
    if (this._token !== undefined) {
      hasAnyValues = true;
      internalValueResult.token = this._token;
    }
    if (this._username !== undefined) {
      hasAnyValues = true;
      internalValueResult.username = this._username;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2LokiAuth | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._authType = undefined;
      this._credentialsSecret = undefined;
      this._password = undefined;
      this._textSecret = undefined;
      this._token = undefined;
      this._username = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._authType = value.authType;
      this._credentialsSecret = value.credentialsSecret;
      this._password = value.password;
      this._textSecret = value.textSecret;
      this._token = value.token;
      this._username = value.username;
    }
  }

  // auth_type - computed: true, optional: true, required: false
  private _authType?: string; 
  public get authType() {
    return this.getStringAttribute('auth_type');
  }
  public set authType(value: string) {
    this._authType = value;
  }
  public resetAuthType() {
    this._authType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authTypeInput() {
    return this._authType;
  }

  // credentials_secret - computed: false, optional: true, required: false
  private _credentialsSecret?: string; 
  public get credentialsSecret() {
    return this.getStringAttribute('credentials_secret');
  }
  public set credentialsSecret(value: string) {
    this._credentialsSecret = value;
  }
  public resetCredentialsSecret() {
    this._credentialsSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get credentialsSecretInput() {
    return this._credentialsSecret;
  }

  // password - computed: false, optional: true, required: false
  private _password?: string; 
  public get password() {
    return this.getStringAttribute('password');
  }
  public set password(value: string) {
    this._password = value;
  }
  public resetPassword() {
    this._password = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passwordInput() {
    return this._password;
  }

  // text_secret - computed: false, optional: true, required: false
  private _textSecret?: string; 
  public get textSecret() {
    return this.getStringAttribute('text_secret');
  }
  public set textSecret(value: string) {
    this._textSecret = value;
  }
  public resetTextSecret() {
    this._textSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get textSecretInput() {
    return this._textSecret;
  }

  // token - computed: false, optional: true, required: false
  private _token?: string; 
  public get token() {
    return this.getStringAttribute('token');
  }
  public set token(value: string) {
    this._token = value;
  }
  public resetToken() {
    this._token = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tokenInput() {
    return this._token;
  }

  // username - computed: false, optional: true, required: false
  private _username?: string; 
  public get username() {
    return this.getStringAttribute('username');
  }
  public set username(value: string) {
    this._username = value;
  }
  public resetUsername() {
    this._username = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usernameInput() {
    return this._username;
  }
}
export interface DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2PqControls {
}

export function destinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2PqControlsToTerraform(struct?: DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2PqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function destinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2PqControlsToHclTerraform(struct?: DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2PqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2PqControlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2PqControls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2PqControls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2PrometheusAuth {
  /**
  * Default: "basic"; must be one of ["none", "token", "textSecret", "basic", "credentialsSecret"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#auth_type Destination#auth_type}
  */
  readonly authType?: string;
  /**
  * Select or create a secret that references your credentials
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#credentials_secret Destination#credentials_secret}
  */
  readonly credentialsSecret?: string;
  /**
  * Password (API key in Grafana Cloud domain) for authentication
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#password Destination#password}
  */
  readonly password?: string;
  /**
  * Select or create a stored text secret
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#text_secret Destination#text_secret}
  */
  readonly textSecret?: string;
  /**
  * Bearer token to include in the authorization header. In Grafana Cloud, this is generally built by concatenating the username and the API key, separated by a colon. Example: <your-username>:<your-api-key>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#token Destination#token}
  */
  readonly token?: string;
  /**
  * Username for authentication
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#username Destination#username}
  */
  readonly username?: string;
}

export function destinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2PrometheusAuthToTerraform(struct?: DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2PrometheusAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    auth_type: cdktf.stringToTerraform(struct!.authType),
    credentials_secret: cdktf.stringToTerraform(struct!.credentialsSecret),
    password: cdktf.stringToTerraform(struct!.password),
    text_secret: cdktf.stringToTerraform(struct!.textSecret),
    token: cdktf.stringToTerraform(struct!.token),
    username: cdktf.stringToTerraform(struct!.username),
  }
}


export function destinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2PrometheusAuthToHclTerraform(struct?: DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2PrometheusAuth | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    auth_type: {
      value: cdktf.stringToHclTerraform(struct!.authType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    credentials_secret: {
      value: cdktf.stringToHclTerraform(struct!.credentialsSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    password: {
      value: cdktf.stringToHclTerraform(struct!.password),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    text_secret: {
      value: cdktf.stringToHclTerraform(struct!.textSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    token: {
      value: cdktf.stringToHclTerraform(struct!.token),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    username: {
      value: cdktf.stringToHclTerraform(struct!.username),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2PrometheusAuthOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2PrometheusAuth | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._authType !== undefined) {
      hasAnyValues = true;
      internalValueResult.authType = this._authType;
    }
    if (this._credentialsSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.credentialsSecret = this._credentialsSecret;
    }
    if (this._password !== undefined) {
      hasAnyValues = true;
      internalValueResult.password = this._password;
    }
    if (this._textSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.textSecret = this._textSecret;
    }
    if (this._token !== undefined) {
      hasAnyValues = true;
      internalValueResult.token = this._token;
    }
    if (this._username !== undefined) {
      hasAnyValues = true;
      internalValueResult.username = this._username;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2PrometheusAuth | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._authType = undefined;
      this._credentialsSecret = undefined;
      this._password = undefined;
      this._textSecret = undefined;
      this._token = undefined;
      this._username = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._authType = value.authType;
      this._credentialsSecret = value.credentialsSecret;
      this._password = value.password;
      this._textSecret = value.textSecret;
      this._token = value.token;
      this._username = value.username;
    }
  }

  // auth_type - computed: true, optional: true, required: false
  private _authType?: string; 
  public get authType() {
    return this.getStringAttribute('auth_type');
  }
  public set authType(value: string) {
    this._authType = value;
  }
  public resetAuthType() {
    this._authType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authTypeInput() {
    return this._authType;
  }

  // credentials_secret - computed: false, optional: true, required: false
  private _credentialsSecret?: string; 
  public get credentialsSecret() {
    return this.getStringAttribute('credentials_secret');
  }
  public set credentialsSecret(value: string) {
    this._credentialsSecret = value;
  }
  public resetCredentialsSecret() {
    this._credentialsSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get credentialsSecretInput() {
    return this._credentialsSecret;
  }

  // password - computed: false, optional: true, required: false
  private _password?: string; 
  public get password() {
    return this.getStringAttribute('password');
  }
  public set password(value: string) {
    this._password = value;
  }
  public resetPassword() {
    this._password = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passwordInput() {
    return this._password;
  }

  // text_secret - computed: false, optional: true, required: false
  private _textSecret?: string; 
  public get textSecret() {
    return this.getStringAttribute('text_secret');
  }
  public set textSecret(value: string) {
    this._textSecret = value;
  }
  public resetTextSecret() {
    this._textSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get textSecretInput() {
    return this._textSecret;
  }

  // token - computed: false, optional: true, required: false
  private _token?: string; 
  public get token() {
    return this.getStringAttribute('token');
  }
  public set token(value: string) {
    this._token = value;
  }
  public resetToken() {
    this._token = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tokenInput() {
    return this._token;
  }

  // username - computed: false, optional: true, required: false
  private _username?: string; 
  public get username() {
    return this.getStringAttribute('username');
  }
  public set username(value: string) {
    this._username = value;
  }
  public resetUsername() {
    this._username = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usernameInput() {
    return this._username;
  }
}
export interface DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2ResponseRetrySettings {
  /**
  * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc. Default: 2
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#backoff_rate Destination#backoff_rate}
  */
  readonly backoffRate?: number;
  /**
  * The HTTP response status code that will trigger retries
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#http_status Destination#http_status}
  */
  readonly httpStatus: number;
  /**
  * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes). Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#initial_backoff Destination#initial_backoff}
  */
  readonly initialBackoff?: number;
  /**
  * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds). Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#max_backoff Destination#max_backoff}
  */
  readonly maxBackoff?: number;
}

export function destinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2ResponseRetrySettingsToTerraform(struct?: DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2ResponseRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    backoff_rate: cdktf.numberToTerraform(struct!.backoffRate),
    http_status: cdktf.numberToTerraform(struct!.httpStatus),
    initial_backoff: cdktf.numberToTerraform(struct!.initialBackoff),
    max_backoff: cdktf.numberToTerraform(struct!.maxBackoff),
  }
}


export function destinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2ResponseRetrySettingsToHclTerraform(struct?: DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2ResponseRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    backoff_rate: {
      value: cdktf.numberToHclTerraform(struct!.backoffRate),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    http_status: {
      value: cdktf.numberToHclTerraform(struct!.httpStatus),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    initial_backoff: {
      value: cdktf.numberToHclTerraform(struct!.initialBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_backoff: {
      value: cdktf.numberToHclTerraform(struct!.maxBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2ResponseRetrySettingsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2ResponseRetrySettings | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._backoffRate !== undefined) {
      hasAnyValues = true;
      internalValueResult.backoffRate = this._backoffRate;
    }
    if (this._httpStatus !== undefined) {
      hasAnyValues = true;
      internalValueResult.httpStatus = this._httpStatus;
    }
    if (this._initialBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.initialBackoff = this._initialBackoff;
    }
    if (this._maxBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBackoff = this._maxBackoff;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2ResponseRetrySettings | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._backoffRate = undefined;
      this._httpStatus = undefined;
      this._initialBackoff = undefined;
      this._maxBackoff = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._backoffRate = value.backoffRate;
      this._httpStatus = value.httpStatus;
      this._initialBackoff = value.initialBackoff;
      this._maxBackoff = value.maxBackoff;
    }
  }

  // backoff_rate - computed: true, optional: true, required: false
  private _backoffRate?: number; 
  public get backoffRate() {
    return this.getNumberAttribute('backoff_rate');
  }
  public set backoffRate(value: number) {
    this._backoffRate = value;
  }
  public resetBackoffRate() {
    this._backoffRate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get backoffRateInput() {
    return this._backoffRate;
  }

  // http_status - computed: false, optional: false, required: true
  private _httpStatus?: number; 
  public get httpStatus() {
    return this.getNumberAttribute('http_status');
  }
  public set httpStatus(value: number) {
    this._httpStatus = value;
  }
  // Temporarily expose input value. Use with caution.
  public get httpStatusInput() {
    return this._httpStatus;
  }

  // initial_backoff - computed: true, optional: true, required: false
  private _initialBackoff?: number; 
  public get initialBackoff() {
    return this.getNumberAttribute('initial_backoff');
  }
  public set initialBackoff(value: number) {
    this._initialBackoff = value;
  }
  public resetInitialBackoff() {
    this._initialBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get initialBackoffInput() {
    return this._initialBackoff;
  }

  // max_backoff - computed: true, optional: true, required: false
  private _maxBackoff?: number; 
  public get maxBackoff() {
    return this.getNumberAttribute('max_backoff');
  }
  public set maxBackoff(value: number) {
    this._maxBackoff = value;
  }
  public resetMaxBackoff() {
    this._maxBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBackoffInput() {
    return this._maxBackoff;
  }
}

export class DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2ResponseRetrySettingsList extends cdktf.ComplexList {
  public internalValue? : DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2ResponseRetrySettings[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2ResponseRetrySettingsOutputReference {
    return new DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2ResponseRetrySettingsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2TimeoutRetrySettings {
  /**
  * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc. Default: 2
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#backoff_rate Destination#backoff_rate}
  */
  readonly backoffRate?: number;
  /**
  * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes). Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#initial_backoff Destination#initial_backoff}
  */
  readonly initialBackoff?: number;
  /**
  * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds). Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#max_backoff Destination#max_backoff}
  */
  readonly maxBackoff?: number;
  /**
  * Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#timeout_retry Destination#timeout_retry}
  */
  readonly timeoutRetry?: boolean | cdktf.IResolvable;
}

export function destinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2TimeoutRetrySettingsToTerraform(struct?: DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2TimeoutRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    backoff_rate: cdktf.numberToTerraform(struct!.backoffRate),
    initial_backoff: cdktf.numberToTerraform(struct!.initialBackoff),
    max_backoff: cdktf.numberToTerraform(struct!.maxBackoff),
    timeout_retry: cdktf.booleanToTerraform(struct!.timeoutRetry),
  }
}


export function destinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2TimeoutRetrySettingsToHclTerraform(struct?: DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2TimeoutRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    backoff_rate: {
      value: cdktf.numberToHclTerraform(struct!.backoffRate),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    initial_backoff: {
      value: cdktf.numberToHclTerraform(struct!.initialBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_backoff: {
      value: cdktf.numberToHclTerraform(struct!.maxBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    timeout_retry: {
      value: cdktf.booleanToHclTerraform(struct!.timeoutRetry),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2TimeoutRetrySettingsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2TimeoutRetrySettings | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._backoffRate !== undefined) {
      hasAnyValues = true;
      internalValueResult.backoffRate = this._backoffRate;
    }
    if (this._initialBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.initialBackoff = this._initialBackoff;
    }
    if (this._maxBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBackoff = this._maxBackoff;
    }
    if (this._timeoutRetry !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutRetry = this._timeoutRetry;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2TimeoutRetrySettings | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._backoffRate = undefined;
      this._initialBackoff = undefined;
      this._maxBackoff = undefined;
      this._timeoutRetry = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._backoffRate = value.backoffRate;
      this._initialBackoff = value.initialBackoff;
      this._maxBackoff = value.maxBackoff;
      this._timeoutRetry = value.timeoutRetry;
    }
  }

  // backoff_rate - computed: true, optional: true, required: false
  private _backoffRate?: number; 
  public get backoffRate() {
    return this.getNumberAttribute('backoff_rate');
  }
  public set backoffRate(value: number) {
    this._backoffRate = value;
  }
  public resetBackoffRate() {
    this._backoffRate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get backoffRateInput() {
    return this._backoffRate;
  }

  // initial_backoff - computed: true, optional: true, required: false
  private _initialBackoff?: number; 
  public get initialBackoff() {
    return this.getNumberAttribute('initial_backoff');
  }
  public set initialBackoff(value: number) {
    this._initialBackoff = value;
  }
  public resetInitialBackoff() {
    this._initialBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get initialBackoffInput() {
    return this._initialBackoff;
  }

  // max_backoff - computed: true, optional: true, required: false
  private _maxBackoff?: number; 
  public get maxBackoff() {
    return this.getNumberAttribute('max_backoff');
  }
  public set maxBackoff(value: number) {
    this._maxBackoff = value;
  }
  public resetMaxBackoff() {
    this._maxBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBackoffInput() {
    return this._maxBackoff;
  }

  // timeout_retry - computed: true, optional: true, required: false
  private _timeoutRetry?: boolean | cdktf.IResolvable; 
  public get timeoutRetry() {
    return this.getBooleanAttribute('timeout_retry');
  }
  public set timeoutRetry(value: boolean | cdktf.IResolvable) {
    this._timeoutRetry = value;
  }
  public resetTimeoutRetry() {
    this._timeoutRetry = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutRetryInput() {
    return this._timeoutRetry;
  }
}
export interface DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2 {
  /**
  * Compress the payload body before sending. Applies only to JSON payloads; the Protobuf variant for both Prometheus and Loki are snappy-compressed by default. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#compress Destination#compress}
  */
  readonly compress?: boolean | cdktf.IResolvable;
  /**
  * Maximum number of ongoing requests before blocking. Warning: Setting this value > 1 can cause Loki and Prometheus to complain about entries being delivered out of order. Default: 1
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#concurrency Destination#concurrency}
  */
  readonly concurrency?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#description Destination#description}
  */
  readonly description?: string;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#environment Destination#environment}
  */
  readonly environment?: string;
  /**
  * Headers to add to all events
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#extra_http_headers Destination#extra_http_headers}
  */
  readonly extraHttpHeaders?: DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2ExtraHttpHeaders[] | cdktf.IResolvable;
  /**
  * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below. Default: "none"; must be one of ["payload", "payloadAndHeaders", "none"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#failed_request_logging_mode Destination#failed_request_logging_mode}
  */
  readonly failedRequestLoggingMode?: string;
  /**
  * Maximum time between requests. Small values could cause the payload size to be smaller than the configured Maximum time between requests. Small values can reduce the payload size below the configured 'Max record size' and 'Max events per request'. Warning: Setting this too low can increase the number of ongoing requests (depending on the value of 'Request concurrency'); this can cause Loki and Prometheus to complain about entries being delivered out of order. Default: 15
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#flush_period_sec Destination#flush_period_sec}
  */
  readonly flushPeriodSec?: number;
  /**
  * Unique ID for this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#id Destination#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id: string;
  /**
  * List of labels to send with logs. Labels define Loki streams, so use static labels to avoid proliferating label value combinations and streams. Can be merged and/or overridden by the events __labels field. Example: "__labels: {host: "cribl.io", level: "error"}"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#labels Destination#labels}
  */
  readonly labels?: DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2Labels[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#loki_auth Destination#loki_auth}
  */
  readonly lokiAuth?: DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2LokiAuth;
  /**
  * The endpoint to send logs to, such as https://logs-prod-us-central1.grafana.net
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#loki_url Destination#loki_url}
  */
  readonly lokiUrl?: string;
  /**
  * Maximum number of events to include in the request body. Default is 0 (unlimited). Warning: Setting this too low can increase the number of ongoing requests (depending on the value of 'Request concurrency'); this can cause Loki and Prometheus to complain about entries being delivered out of order. Default: 0
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#max_payload_events Destination#max_payload_events}
  */
  readonly maxPayloadEvents?: number;
  /**
  * Maximum size, in KB, of the request body. Warning: Setting this too low can increase the number of ongoing requests (depending on the value of 'Request concurrency'); this can cause Loki and Prometheus to complain about entries being delivered out of order. Default: 4096
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#max_payload_size_kb Destination#max_payload_size_kb}
  */
  readonly maxPayloadSizeKb?: number;
  /**
  * Name of the event field that contains the message to send. If not specified, Stream sends a JSON representation of the whole event.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#message Destination#message}
  */
  readonly message?: string;
  /**
  * Format to use when sending logs to Loki (Protobuf or JSON). Default: "protobuf"; must be one of ["protobuf", "json"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#message_format Destination#message_format}
  */
  readonly messageFormat?: string;
  /**
  * JavaScript expression that can be used to rename metrics. For example, name.replace(/\./g, '_') will replace all '.' characters in a metric's name with the supported '_' character. Use the 'name' global variable to access the metric's name. You can access event fields' values via __e.<fieldName>. Default: "name.replace(/[^a-zA-Z0-9_]/g, '_')"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#metric_rename_expr Destination#metric_rename_expr}
  */
  readonly metricRenameExpr?: string;
  /**
  * How to handle events when all receivers are exerting backpressure. Default: "block"; must be one of ["block", "drop", "queue"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#on_backpressure Destination#on_backpressure}
  */
  readonly onBackpressure?: string;
  /**
  * Pipeline to process data before sending out to this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pipeline Destination#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pq_compress Destination#pq_compress}
  */
  readonly pqCompress?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pq_controls Destination#pq_controls}
  */
  readonly pqControls?: DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2PqControls;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.). Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pq_max_file_size Destination#pq_max_file_size}
  */
  readonly pqMaxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pq_max_size Destination#pq_max_size}
  */
  readonly pqMaxSize?: string;
  /**
  * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem. Default: "error"; must be one of ["error", "backpressure", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pq_mode Destination#pq_mode}
  */
  readonly pqMode?: string;
  /**
  * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged. Default: "block"; must be one of ["block", "drop"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pq_on_backpressure Destination#pq_on_backpressure}
  */
  readonly pqOnBackpressure?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pq_path Destination#pq_path}
  */
  readonly pqPath?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#prometheus_auth Destination#prometheus_auth}
  */
  readonly prometheusAuth?: DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2PrometheusAuth;
  /**
  * The remote_write endpoint to send Prometheus metrics to, such as https://prometheus-blocks-prod-us-central1.grafana.net/api/prom/push
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#prometheus_url Destination#prometheus_url}
  */
  readonly prometheusUrl: string;
  /**
  * Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's). 
  *         Enabled by default. When this setting is also present in TLS Settings (Client Side), 
  *         that value will take precedence.
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#reject_unauthorized Destination#reject_unauthorized}
  */
  readonly rejectUnauthorized?: boolean | cdktf.IResolvable;
  /**
  * Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#response_honor_retry_after_header Destination#response_honor_retry_after_header}
  */
  readonly responseHonorRetryAfterHeader?: boolean | cdktf.IResolvable;
  /**
  * Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#response_retry_settings Destination#response_retry_settings}
  */
  readonly responseRetrySettings?: DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2ResponseRetrySettings[] | cdktf.IResolvable;
  /**
  * List of headers that are safe to log in plain text. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#safe_headers Destination#safe_headers}
  */
  readonly safeHeaders?: string[];
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#streamtags Destination#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Fields to automatically add to events, such as cribl_pipe. Supports wildcards. These fields are added as dimensions and labels to generated metrics and logs, respectively. Default: ["cribl_host","cribl_wp"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#system_fields Destination#system_fields}
  */
  readonly systemFields?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#timeout_retry_settings Destination#timeout_retry_settings}
  */
  readonly timeoutRetrySettings?: DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2TimeoutRetrySettings;
  /**
  * Amount of time, in seconds, to wait for a request to complete before canceling it. Default: 30
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#timeout_sec Destination#timeout_sec}
  */
  readonly timeoutSec?: number;
  /**
  * must be "grafana_cloud"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#type Destination#type}
  */
  readonly type: string;
  /**
  * Enable round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. For optimal performance, consider enabling this setting for non-load balanced destinations. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#use_round_robin_dns Destination#use_round_robin_dns}
  */
  readonly useRoundRobinDns?: boolean | cdktf.IResolvable;
}

export function destinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2ToTerraform(struct?: DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2 | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    compress: cdktf.booleanToTerraform(struct!.compress),
    concurrency: cdktf.numberToTerraform(struct!.concurrency),
    description: cdktf.stringToTerraform(struct!.description),
    environment: cdktf.stringToTerraform(struct!.environment),
    extra_http_headers: cdktf.listMapper(destinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2ExtraHttpHeadersToTerraform, false)(struct!.extraHttpHeaders),
    failed_request_logging_mode: cdktf.stringToTerraform(struct!.failedRequestLoggingMode),
    flush_period_sec: cdktf.numberToTerraform(struct!.flushPeriodSec),
    id: cdktf.stringToTerraform(struct!.id),
    labels: cdktf.listMapper(destinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2LabelsToTerraform, false)(struct!.labels),
    loki_auth: destinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2LokiAuthToTerraform(struct!.lokiAuth),
    loki_url: cdktf.stringToTerraform(struct!.lokiUrl),
    max_payload_events: cdktf.numberToTerraform(struct!.maxPayloadEvents),
    max_payload_size_kb: cdktf.numberToTerraform(struct!.maxPayloadSizeKb),
    message: cdktf.stringToTerraform(struct!.message),
    message_format: cdktf.stringToTerraform(struct!.messageFormat),
    metric_rename_expr: cdktf.stringToTerraform(struct!.metricRenameExpr),
    on_backpressure: cdktf.stringToTerraform(struct!.onBackpressure),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    pq_compress: cdktf.stringToTerraform(struct!.pqCompress),
    pq_controls: destinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2PqControlsToTerraform(struct!.pqControls),
    pq_max_file_size: cdktf.stringToTerraform(struct!.pqMaxFileSize),
    pq_max_size: cdktf.stringToTerraform(struct!.pqMaxSize),
    pq_mode: cdktf.stringToTerraform(struct!.pqMode),
    pq_on_backpressure: cdktf.stringToTerraform(struct!.pqOnBackpressure),
    pq_path: cdktf.stringToTerraform(struct!.pqPath),
    prometheus_auth: destinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2PrometheusAuthToTerraform(struct!.prometheusAuth),
    prometheus_url: cdktf.stringToTerraform(struct!.prometheusUrl),
    reject_unauthorized: cdktf.booleanToTerraform(struct!.rejectUnauthorized),
    response_honor_retry_after_header: cdktf.booleanToTerraform(struct!.responseHonorRetryAfterHeader),
    response_retry_settings: cdktf.listMapper(destinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2ResponseRetrySettingsToTerraform, false)(struct!.responseRetrySettings),
    safe_headers: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.safeHeaders),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    system_fields: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.systemFields),
    timeout_retry_settings: destinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2TimeoutRetrySettingsToTerraform(struct!.timeoutRetrySettings),
    timeout_sec: cdktf.numberToTerraform(struct!.timeoutSec),
    type: cdktf.stringToTerraform(struct!.type),
    use_round_robin_dns: cdktf.booleanToTerraform(struct!.useRoundRobinDns),
  }
}


export function destinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2ToHclTerraform(struct?: DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2 | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    compress: {
      value: cdktf.booleanToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    concurrency: {
      value: cdktf.numberToHclTerraform(struct!.concurrency),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    extra_http_headers: {
      value: cdktf.listMapperHcl(destinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2ExtraHttpHeadersToHclTerraform, false)(struct!.extraHttpHeaders),
      isBlock: true,
      type: "list",
      storageClassType: "DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2ExtraHttpHeadersList",
    },
    failed_request_logging_mode: {
      value: cdktf.stringToHclTerraform(struct!.failedRequestLoggingMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    flush_period_sec: {
      value: cdktf.numberToHclTerraform(struct!.flushPeriodSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    labels: {
      value: cdktf.listMapperHcl(destinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2LabelsToHclTerraform, false)(struct!.labels),
      isBlock: true,
      type: "list",
      storageClassType: "DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2LabelsList",
    },
    loki_auth: {
      value: destinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2LokiAuthToHclTerraform(struct!.lokiAuth),
      isBlock: true,
      type: "struct",
      storageClassType: "DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2LokiAuth",
    },
    loki_url: {
      value: cdktf.stringToHclTerraform(struct!.lokiUrl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_payload_events: {
      value: cdktf.numberToHclTerraform(struct!.maxPayloadEvents),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_payload_size_kb: {
      value: cdktf.numberToHclTerraform(struct!.maxPayloadSizeKb),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    message: {
      value: cdktf.stringToHclTerraform(struct!.message),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    message_format: {
      value: cdktf.stringToHclTerraform(struct!.messageFormat),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    metric_rename_expr: {
      value: cdktf.stringToHclTerraform(struct!.metricRenameExpr),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.onBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_compress: {
      value: cdktf.stringToHclTerraform(struct!.pqCompress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_controls: {
      value: destinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2PqControlsToHclTerraform(struct!.pqControls),
      isBlock: true,
      type: "struct",
      storageClassType: "DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2PqControls",
    },
    pq_max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_max_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_mode: {
      value: cdktf.stringToHclTerraform(struct!.pqMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.pqOnBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_path: {
      value: cdktf.stringToHclTerraform(struct!.pqPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    prometheus_auth: {
      value: destinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2PrometheusAuthToHclTerraform(struct!.prometheusAuth),
      isBlock: true,
      type: "struct",
      storageClassType: "DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2PrometheusAuth",
    },
    prometheus_url: {
      value: cdktf.stringToHclTerraform(struct!.prometheusUrl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reject_unauthorized: {
      value: cdktf.booleanToHclTerraform(struct!.rejectUnauthorized),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    response_honor_retry_after_header: {
      value: cdktf.booleanToHclTerraform(struct!.responseHonorRetryAfterHeader),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    response_retry_settings: {
      value: cdktf.listMapperHcl(destinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2ResponseRetrySettingsToHclTerraform, false)(struct!.responseRetrySettings),
      isBlock: true,
      type: "list",
      storageClassType: "DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2ResponseRetrySettingsList",
    },
    safe_headers: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.safeHeaders),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    system_fields: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.systemFields),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    timeout_retry_settings: {
      value: destinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2TimeoutRetrySettingsToHclTerraform(struct!.timeoutRetrySettings),
      isBlock: true,
      type: "struct",
      storageClassType: "DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2TimeoutRetrySettings",
    },
    timeout_sec: {
      value: cdktf.numberToHclTerraform(struct!.timeoutSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    use_round_robin_dns: {
      value: cdktf.booleanToHclTerraform(struct!.useRoundRobinDns),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2OutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2 | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._concurrency !== undefined) {
      hasAnyValues = true;
      internalValueResult.concurrency = this._concurrency;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._extraHttpHeaders?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.extraHttpHeaders = this._extraHttpHeaders?.internalValue;
    }
    if (this._failedRequestLoggingMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.failedRequestLoggingMode = this._failedRequestLoggingMode;
    }
    if (this._flushPeriodSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.flushPeriodSec = this._flushPeriodSec;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._labels?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.labels = this._labels?.internalValue;
    }
    if (this._lokiAuth?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.lokiAuth = this._lokiAuth?.internalValue;
    }
    if (this._lokiUrl !== undefined) {
      hasAnyValues = true;
      internalValueResult.lokiUrl = this._lokiUrl;
    }
    if (this._maxPayloadEvents !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxPayloadEvents = this._maxPayloadEvents;
    }
    if (this._maxPayloadSizeKb !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxPayloadSizeKb = this._maxPayloadSizeKb;
    }
    if (this._message !== undefined) {
      hasAnyValues = true;
      internalValueResult.message = this._message;
    }
    if (this._messageFormat !== undefined) {
      hasAnyValues = true;
      internalValueResult.messageFormat = this._messageFormat;
    }
    if (this._metricRenameExpr !== undefined) {
      hasAnyValues = true;
      internalValueResult.metricRenameExpr = this._metricRenameExpr;
    }
    if (this._onBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.onBackpressure = this._onBackpressure;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._pqCompress !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqCompress = this._pqCompress;
    }
    if (this._pqControls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqControls = this._pqControls?.internalValue;
    }
    if (this._pqMaxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxFileSize = this._pqMaxFileSize;
    }
    if (this._pqMaxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxSize = this._pqMaxSize;
    }
    if (this._pqMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMode = this._pqMode;
    }
    if (this._pqOnBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqOnBackpressure = this._pqOnBackpressure;
    }
    if (this._pqPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqPath = this._pqPath;
    }
    if (this._prometheusAuth?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.prometheusAuth = this._prometheusAuth?.internalValue;
    }
    if (this._prometheusUrl !== undefined) {
      hasAnyValues = true;
      internalValueResult.prometheusUrl = this._prometheusUrl;
    }
    if (this._rejectUnauthorized !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectUnauthorized = this._rejectUnauthorized;
    }
    if (this._responseHonorRetryAfterHeader !== undefined) {
      hasAnyValues = true;
      internalValueResult.responseHonorRetryAfterHeader = this._responseHonorRetryAfterHeader;
    }
    if (this._responseRetrySettings?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.responseRetrySettings = this._responseRetrySettings?.internalValue;
    }
    if (this._safeHeaders !== undefined) {
      hasAnyValues = true;
      internalValueResult.safeHeaders = this._safeHeaders;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._systemFields !== undefined) {
      hasAnyValues = true;
      internalValueResult.systemFields = this._systemFields;
    }
    if (this._timeoutRetrySettings?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutRetrySettings = this._timeoutRetrySettings?.internalValue;
    }
    if (this._timeoutSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutSec = this._timeoutSec;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._useRoundRobinDns !== undefined) {
      hasAnyValues = true;
      internalValueResult.useRoundRobinDns = this._useRoundRobinDns;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2 | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._compress = undefined;
      this._concurrency = undefined;
      this._description = undefined;
      this._environment = undefined;
      this._extraHttpHeaders.internalValue = undefined;
      this._failedRequestLoggingMode = undefined;
      this._flushPeriodSec = undefined;
      this._id = undefined;
      this._labels.internalValue = undefined;
      this._lokiAuth.internalValue = undefined;
      this._lokiUrl = undefined;
      this._maxPayloadEvents = undefined;
      this._maxPayloadSizeKb = undefined;
      this._message = undefined;
      this._messageFormat = undefined;
      this._metricRenameExpr = undefined;
      this._onBackpressure = undefined;
      this._pipeline = undefined;
      this._pqCompress = undefined;
      this._pqControls.internalValue = undefined;
      this._pqMaxFileSize = undefined;
      this._pqMaxSize = undefined;
      this._pqMode = undefined;
      this._pqOnBackpressure = undefined;
      this._pqPath = undefined;
      this._prometheusAuth.internalValue = undefined;
      this._prometheusUrl = undefined;
      this._rejectUnauthorized = undefined;
      this._responseHonorRetryAfterHeader = undefined;
      this._responseRetrySettings.internalValue = undefined;
      this._safeHeaders = undefined;
      this._streamtags = undefined;
      this._systemFields = undefined;
      this._timeoutRetrySettings.internalValue = undefined;
      this._timeoutSec = undefined;
      this._type = undefined;
      this._useRoundRobinDns = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._compress = value.compress;
      this._concurrency = value.concurrency;
      this._description = value.description;
      this._environment = value.environment;
      this._extraHttpHeaders.internalValue = value.extraHttpHeaders;
      this._failedRequestLoggingMode = value.failedRequestLoggingMode;
      this._flushPeriodSec = value.flushPeriodSec;
      this._id = value.id;
      this._labels.internalValue = value.labels;
      this._lokiAuth.internalValue = value.lokiAuth;
      this._lokiUrl = value.lokiUrl;
      this._maxPayloadEvents = value.maxPayloadEvents;
      this._maxPayloadSizeKb = value.maxPayloadSizeKb;
      this._message = value.message;
      this._messageFormat = value.messageFormat;
      this._metricRenameExpr = value.metricRenameExpr;
      this._onBackpressure = value.onBackpressure;
      this._pipeline = value.pipeline;
      this._pqCompress = value.pqCompress;
      this._pqControls.internalValue = value.pqControls;
      this._pqMaxFileSize = value.pqMaxFileSize;
      this._pqMaxSize = value.pqMaxSize;
      this._pqMode = value.pqMode;
      this._pqOnBackpressure = value.pqOnBackpressure;
      this._pqPath = value.pqPath;
      this._prometheusAuth.internalValue = value.prometheusAuth;
      this._prometheusUrl = value.prometheusUrl;
      this._rejectUnauthorized = value.rejectUnauthorized;
      this._responseHonorRetryAfterHeader = value.responseHonorRetryAfterHeader;
      this._responseRetrySettings.internalValue = value.responseRetrySettings;
      this._safeHeaders = value.safeHeaders;
      this._streamtags = value.streamtags;
      this._systemFields = value.systemFields;
      this._timeoutRetrySettings.internalValue = value.timeoutRetrySettings;
      this._timeoutSec = value.timeoutSec;
      this._type = value.type;
      this._useRoundRobinDns = value.useRoundRobinDns;
    }
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: boolean | cdktf.IResolvable; 
  public get compress() {
    return this.getBooleanAttribute('compress');
  }
  public set compress(value: boolean | cdktf.IResolvable) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // concurrency - computed: true, optional: true, required: false
  private _concurrency?: number; 
  public get concurrency() {
    return this.getNumberAttribute('concurrency');
  }
  public set concurrency(value: number) {
    this._concurrency = value;
  }
  public resetConcurrency() {
    this._concurrency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get concurrencyInput() {
    return this._concurrency;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // extra_http_headers - computed: false, optional: true, required: false
  private _extraHttpHeaders = new DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2ExtraHttpHeadersList(this, "extra_http_headers", false);
  public get extraHttpHeaders() {
    return this._extraHttpHeaders;
  }
  public putExtraHttpHeaders(value: DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2ExtraHttpHeaders[] | cdktf.IResolvable) {
    this._extraHttpHeaders.internalValue = value;
  }
  public resetExtraHttpHeaders() {
    this._extraHttpHeaders.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get extraHttpHeadersInput() {
    return this._extraHttpHeaders.internalValue;
  }

  // failed_request_logging_mode - computed: true, optional: true, required: false
  private _failedRequestLoggingMode?: string; 
  public get failedRequestLoggingMode() {
    return this.getStringAttribute('failed_request_logging_mode');
  }
  public set failedRequestLoggingMode(value: string) {
    this._failedRequestLoggingMode = value;
  }
  public resetFailedRequestLoggingMode() {
    this._failedRequestLoggingMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get failedRequestLoggingModeInput() {
    return this._failedRequestLoggingMode;
  }

  // flush_period_sec - computed: true, optional: true, required: false
  private _flushPeriodSec?: number; 
  public get flushPeriodSec() {
    return this.getNumberAttribute('flush_period_sec');
  }
  public set flushPeriodSec(value: number) {
    this._flushPeriodSec = value;
  }
  public resetFlushPeriodSec() {
    this._flushPeriodSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get flushPeriodSecInput() {
    return this._flushPeriodSec;
  }

  // id - computed: false, optional: false, required: true
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // labels - computed: false, optional: true, required: false
  private _labels = new DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2LabelsList(this, "labels", false);
  public get labels() {
    return this._labels;
  }
  public putLabels(value: DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2Labels[] | cdktf.IResolvable) {
    this._labels.internalValue = value;
  }
  public resetLabels() {
    this._labels.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get labelsInput() {
    return this._labels.internalValue;
  }

  // loki_auth - computed: false, optional: true, required: false
  private _lokiAuth = new DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2LokiAuthOutputReference(this, "loki_auth");
  public get lokiAuth() {
    return this._lokiAuth;
  }
  public putLokiAuth(value: DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2LokiAuth) {
    this._lokiAuth.internalValue = value;
  }
  public resetLokiAuth() {
    this._lokiAuth.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get lokiAuthInput() {
    return this._lokiAuth.internalValue;
  }

  // loki_url - computed: false, optional: true, required: false
  private _lokiUrl?: string; 
  public get lokiUrl() {
    return this.getStringAttribute('loki_url');
  }
  public set lokiUrl(value: string) {
    this._lokiUrl = value;
  }
  public resetLokiUrl() {
    this._lokiUrl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get lokiUrlInput() {
    return this._lokiUrl;
  }

  // max_payload_events - computed: true, optional: true, required: false
  private _maxPayloadEvents?: number; 
  public get maxPayloadEvents() {
    return this.getNumberAttribute('max_payload_events');
  }
  public set maxPayloadEvents(value: number) {
    this._maxPayloadEvents = value;
  }
  public resetMaxPayloadEvents() {
    this._maxPayloadEvents = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxPayloadEventsInput() {
    return this._maxPayloadEvents;
  }

  // max_payload_size_kb - computed: true, optional: true, required: false
  private _maxPayloadSizeKb?: number; 
  public get maxPayloadSizeKb() {
    return this.getNumberAttribute('max_payload_size_kb');
  }
  public set maxPayloadSizeKb(value: number) {
    this._maxPayloadSizeKb = value;
  }
  public resetMaxPayloadSizeKb() {
    this._maxPayloadSizeKb = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxPayloadSizeKbInput() {
    return this._maxPayloadSizeKb;
  }

  // message - computed: false, optional: true, required: false
  private _message?: string; 
  public get message() {
    return this.getStringAttribute('message');
  }
  public set message(value: string) {
    this._message = value;
  }
  public resetMessage() {
    this._message = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get messageInput() {
    return this._message;
  }

  // message_format - computed: true, optional: true, required: false
  private _messageFormat?: string; 
  public get messageFormat() {
    return this.getStringAttribute('message_format');
  }
  public set messageFormat(value: string) {
    this._messageFormat = value;
  }
  public resetMessageFormat() {
    this._messageFormat = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get messageFormatInput() {
    return this._messageFormat;
  }

  // metric_rename_expr - computed: true, optional: true, required: false
  private _metricRenameExpr?: string; 
  public get metricRenameExpr() {
    return this.getStringAttribute('metric_rename_expr');
  }
  public set metricRenameExpr(value: string) {
    this._metricRenameExpr = value;
  }
  public resetMetricRenameExpr() {
    this._metricRenameExpr = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metricRenameExprInput() {
    return this._metricRenameExpr;
  }

  // on_backpressure - computed: true, optional: true, required: false
  private _onBackpressure?: string; 
  public get onBackpressure() {
    return this.getStringAttribute('on_backpressure');
  }
  public set onBackpressure(value: string) {
    this._onBackpressure = value;
  }
  public resetOnBackpressure() {
    this._onBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get onBackpressureInput() {
    return this._onBackpressure;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // pq_compress - computed: true, optional: true, required: false
  private _pqCompress?: string; 
  public get pqCompress() {
    return this.getStringAttribute('pq_compress');
  }
  public set pqCompress(value: string) {
    this._pqCompress = value;
  }
  public resetPqCompress() {
    this._pqCompress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqCompressInput() {
    return this._pqCompress;
  }

  // pq_controls - computed: false, optional: true, required: false
  private _pqControls = new DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2PqControlsOutputReference(this, "pq_controls");
  public get pqControls() {
    return this._pqControls;
  }
  public putPqControls(value: DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2PqControls) {
    this._pqControls.internalValue = value;
  }
  public resetPqControls() {
    this._pqControls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqControlsInput() {
    return this._pqControls.internalValue;
  }

  // pq_max_file_size - computed: true, optional: true, required: false
  private _pqMaxFileSize?: string; 
  public get pqMaxFileSize() {
    return this.getStringAttribute('pq_max_file_size');
  }
  public set pqMaxFileSize(value: string) {
    this._pqMaxFileSize = value;
  }
  public resetPqMaxFileSize() {
    this._pqMaxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxFileSizeInput() {
    return this._pqMaxFileSize;
  }

  // pq_max_size - computed: true, optional: true, required: false
  private _pqMaxSize?: string; 
  public get pqMaxSize() {
    return this.getStringAttribute('pq_max_size');
  }
  public set pqMaxSize(value: string) {
    this._pqMaxSize = value;
  }
  public resetPqMaxSize() {
    this._pqMaxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxSizeInput() {
    return this._pqMaxSize;
  }

  // pq_mode - computed: true, optional: true, required: false
  private _pqMode?: string; 
  public get pqMode() {
    return this.getStringAttribute('pq_mode');
  }
  public set pqMode(value: string) {
    this._pqMode = value;
  }
  public resetPqMode() {
    this._pqMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqModeInput() {
    return this._pqMode;
  }

  // pq_on_backpressure - computed: true, optional: true, required: false
  private _pqOnBackpressure?: string; 
  public get pqOnBackpressure() {
    return this.getStringAttribute('pq_on_backpressure');
  }
  public set pqOnBackpressure(value: string) {
    this._pqOnBackpressure = value;
  }
  public resetPqOnBackpressure() {
    this._pqOnBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqOnBackpressureInput() {
    return this._pqOnBackpressure;
  }

  // pq_path - computed: true, optional: true, required: false
  private _pqPath?: string; 
  public get pqPath() {
    return this.getStringAttribute('pq_path');
  }
  public set pqPath(value: string) {
    this._pqPath = value;
  }
  public resetPqPath() {
    this._pqPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqPathInput() {
    return this._pqPath;
  }

  // prometheus_auth - computed: false, optional: true, required: false
  private _prometheusAuth = new DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2PrometheusAuthOutputReference(this, "prometheus_auth");
  public get prometheusAuth() {
    return this._prometheusAuth;
  }
  public putPrometheusAuth(value: DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2PrometheusAuth) {
    this._prometheusAuth.internalValue = value;
  }
  public resetPrometheusAuth() {
    this._prometheusAuth.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get prometheusAuthInput() {
    return this._prometheusAuth.internalValue;
  }

  // prometheus_url - computed: false, optional: false, required: true
  private _prometheusUrl?: string; 
  public get prometheusUrl() {
    return this.getStringAttribute('prometheus_url');
  }
  public set prometheusUrl(value: string) {
    this._prometheusUrl = value;
  }
  // Temporarily expose input value. Use with caution.
  public get prometheusUrlInput() {
    return this._prometheusUrl;
  }

  // reject_unauthorized - computed: true, optional: true, required: false
  private _rejectUnauthorized?: boolean | cdktf.IResolvable; 
  public get rejectUnauthorized() {
    return this.getBooleanAttribute('reject_unauthorized');
  }
  public set rejectUnauthorized(value: boolean | cdktf.IResolvable) {
    this._rejectUnauthorized = value;
  }
  public resetRejectUnauthorized() {
    this._rejectUnauthorized = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectUnauthorizedInput() {
    return this._rejectUnauthorized;
  }

  // response_honor_retry_after_header - computed: true, optional: true, required: false
  private _responseHonorRetryAfterHeader?: boolean | cdktf.IResolvable; 
  public get responseHonorRetryAfterHeader() {
    return this.getBooleanAttribute('response_honor_retry_after_header');
  }
  public set responseHonorRetryAfterHeader(value: boolean | cdktf.IResolvable) {
    this._responseHonorRetryAfterHeader = value;
  }
  public resetResponseHonorRetryAfterHeader() {
    this._responseHonorRetryAfterHeader = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get responseHonorRetryAfterHeaderInput() {
    return this._responseHonorRetryAfterHeader;
  }

  // response_retry_settings - computed: false, optional: true, required: false
  private _responseRetrySettings = new DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2ResponseRetrySettingsList(this, "response_retry_settings", false);
  public get responseRetrySettings() {
    return this._responseRetrySettings;
  }
  public putResponseRetrySettings(value: DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2ResponseRetrySettings[] | cdktf.IResolvable) {
    this._responseRetrySettings.internalValue = value;
  }
  public resetResponseRetrySettings() {
    this._responseRetrySettings.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get responseRetrySettingsInput() {
    return this._responseRetrySettings.internalValue;
  }

  // safe_headers - computed: true, optional: true, required: false
  private _safeHeaders?: string[]; 
  public get safeHeaders() {
    return this.getListAttribute('safe_headers');
  }
  public set safeHeaders(value: string[]) {
    this._safeHeaders = value;
  }
  public resetSafeHeaders() {
    this._safeHeaders = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get safeHeadersInput() {
    return this._safeHeaders;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // system_fields - computed: true, optional: true, required: false
  private _systemFields?: string[]; 
  public get systemFields() {
    return this.getListAttribute('system_fields');
  }
  public set systemFields(value: string[]) {
    this._systemFields = value;
  }
  public resetSystemFields() {
    this._systemFields = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get systemFieldsInput() {
    return this._systemFields;
  }

  // timeout_retry_settings - computed: false, optional: true, required: false
  private _timeoutRetrySettings = new DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2TimeoutRetrySettingsOutputReference(this, "timeout_retry_settings");
  public get timeoutRetrySettings() {
    return this._timeoutRetrySettings;
  }
  public putTimeoutRetrySettings(value: DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2TimeoutRetrySettings) {
    this._timeoutRetrySettings.internalValue = value;
  }
  public resetTimeoutRetrySettings() {
    this._timeoutRetrySettings.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutRetrySettingsInput() {
    return this._timeoutRetrySettings.internalValue;
  }

  // timeout_sec - computed: true, optional: true, required: false
  private _timeoutSec?: number; 
  public get timeoutSec() {
    return this.getNumberAttribute('timeout_sec');
  }
  public set timeoutSec(value: number) {
    this._timeoutSec = value;
  }
  public resetTimeoutSec() {
    this._timeoutSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutSecInput() {
    return this._timeoutSec;
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // use_round_robin_dns - computed: true, optional: true, required: false
  private _useRoundRobinDns?: boolean | cdktf.IResolvable; 
  public get useRoundRobinDns() {
    return this.getBooleanAttribute('use_round_robin_dns');
  }
  public set useRoundRobinDns(value: boolean | cdktf.IResolvable) {
    this._useRoundRobinDns = value;
  }
  public resetUseRoundRobinDns() {
    this._useRoundRobinDns = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get useRoundRobinDnsInput() {
    return this._useRoundRobinDns;
  }
}
export interface DestinationOutputGrafanaCloud {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#output_grafana_cloud_grafana_cloud1 Destination#output_grafana_cloud_grafana_cloud1}
  */
  readonly outputGrafanaCloudGrafanaCloud1?: DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#output_grafana_cloud_grafana_cloud2 Destination#output_grafana_cloud_grafana_cloud2}
  */
  readonly outputGrafanaCloudGrafanaCloud2?: DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2;
}

export function destinationOutputGrafanaCloudToTerraform(struct?: DestinationOutputGrafanaCloud | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    output_grafana_cloud_grafana_cloud1: destinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1ToTerraform(struct!.outputGrafanaCloudGrafanaCloud1),
    output_grafana_cloud_grafana_cloud2: destinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2ToTerraform(struct!.outputGrafanaCloudGrafanaCloud2),
  }
}


export function destinationOutputGrafanaCloudToHclTerraform(struct?: DestinationOutputGrafanaCloud | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    output_grafana_cloud_grafana_cloud1: {
      value: destinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1ToHclTerraform(struct!.outputGrafanaCloudGrafanaCloud1),
      isBlock: true,
      type: "struct",
      storageClassType: "DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1",
    },
    output_grafana_cloud_grafana_cloud2: {
      value: destinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2ToHclTerraform(struct!.outputGrafanaCloudGrafanaCloud2),
      isBlock: true,
      type: "struct",
      storageClassType: "DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputGrafanaCloudOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DestinationOutputGrafanaCloud | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._outputGrafanaCloudGrafanaCloud1?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.outputGrafanaCloudGrafanaCloud1 = this._outputGrafanaCloudGrafanaCloud1?.internalValue;
    }
    if (this._outputGrafanaCloudGrafanaCloud2?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.outputGrafanaCloudGrafanaCloud2 = this._outputGrafanaCloudGrafanaCloud2?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputGrafanaCloud | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._outputGrafanaCloudGrafanaCloud1.internalValue = undefined;
      this._outputGrafanaCloudGrafanaCloud2.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._outputGrafanaCloudGrafanaCloud1.internalValue = value.outputGrafanaCloudGrafanaCloud1;
      this._outputGrafanaCloudGrafanaCloud2.internalValue = value.outputGrafanaCloudGrafanaCloud2;
    }
  }

  // output_grafana_cloud_grafana_cloud1 - computed: false, optional: true, required: false
  private _outputGrafanaCloudGrafanaCloud1 = new DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1OutputReference(this, "output_grafana_cloud_grafana_cloud1");
  public get outputGrafanaCloudGrafanaCloud1() {
    return this._outputGrafanaCloudGrafanaCloud1;
  }
  public putOutputGrafanaCloudGrafanaCloud1(value: DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud1) {
    this._outputGrafanaCloudGrafanaCloud1.internalValue = value;
  }
  public resetOutputGrafanaCloudGrafanaCloud1() {
    this._outputGrafanaCloudGrafanaCloud1.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get outputGrafanaCloudGrafanaCloud1Input() {
    return this._outputGrafanaCloudGrafanaCloud1.internalValue;
  }

  // output_grafana_cloud_grafana_cloud2 - computed: false, optional: true, required: false
  private _outputGrafanaCloudGrafanaCloud2 = new DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2OutputReference(this, "output_grafana_cloud_grafana_cloud2");
  public get outputGrafanaCloudGrafanaCloud2() {
    return this._outputGrafanaCloudGrafanaCloud2;
  }
  public putOutputGrafanaCloudGrafanaCloud2(value: DestinationOutputGrafanaCloudOutputGrafanaCloudGrafanaCloud2) {
    this._outputGrafanaCloudGrafanaCloud2.internalValue = value;
  }
  public resetOutputGrafanaCloudGrafanaCloud2() {
    this._outputGrafanaCloudGrafanaCloud2.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get outputGrafanaCloudGrafanaCloud2Input() {
    return this._outputGrafanaCloudGrafanaCloud2.internalValue;
  }
}
export interface DestinationOutputGraphitePqControls {
}

export function destinationOutputGraphitePqControlsToTerraform(struct?: DestinationOutputGraphitePqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function destinationOutputGraphitePqControlsToHclTerraform(struct?: DestinationOutputGraphitePqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class DestinationOutputGraphitePqControlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DestinationOutputGraphitePqControls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputGraphitePqControls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface DestinationOutputGraphite {
  /**
  * Amount of time (milliseconds) to wait for the connection to establish before retrying. Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#connection_timeout Destination#connection_timeout}
  */
  readonly connectionTimeout?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#description Destination#description}
  */
  readonly description?: string;
  /**
  * How often to resolve the destination hostname to an IP address. Ignored if the destination is an IP address. A value of 0 means every batch sent will incur a DNS lookup. Default: 0
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#dns_resolve_period_sec Destination#dns_resolve_period_sec}
  */
  readonly dnsResolvePeriodSec?: number;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#environment Destination#environment}
  */
  readonly environment?: string;
  /**
  * When protocol is TCP, specifies how often buffers should be flushed, resulting in records sent to the destination. Default: 1
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#flush_period_sec Destination#flush_period_sec}
  */
  readonly flushPeriodSec?: number;
  /**
  * The hostname of the destination.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#host Destination#host}
  */
  readonly host: string;
  /**
  * Unique ID for this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#id Destination#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * When protocol is UDP, specifies the maximum size of packets sent to the destination. Also known as the MTU for the network path to the destination system. Default: 512
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#mtu Destination#mtu}
  */
  readonly mtu?: number;
  /**
  * How to handle events when all receivers are exerting backpressure. Default: "block"; must be one of ["block", "drop", "queue"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#on_backpressure Destination#on_backpressure}
  */
  readonly onBackpressure?: string;
  /**
  * Pipeline to process data before sending out to this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pipeline Destination#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Destination port. Default: 8125
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#port Destination#port}
  */
  readonly port?: number;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pq_compress Destination#pq_compress}
  */
  readonly pqCompress?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pq_controls Destination#pq_controls}
  */
  readonly pqControls?: DestinationOutputGraphitePqControls;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.). Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pq_max_file_size Destination#pq_max_file_size}
  */
  readonly pqMaxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pq_max_size Destination#pq_max_size}
  */
  readonly pqMaxSize?: string;
  /**
  * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem. Default: "error"; must be one of ["error", "backpressure", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pq_mode Destination#pq_mode}
  */
  readonly pqMode?: string;
  /**
  * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged. Default: "block"; must be one of ["block", "drop"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pq_on_backpressure Destination#pq_on_backpressure}
  */
  readonly pqOnBackpressure?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pq_path Destination#pq_path}
  */
  readonly pqPath?: string;
  /**
  * Protocol to use when communicating with the destination. Default: "udp"; must be one of ["udp", "tcp"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#protocol Destination#protocol}
  */
  readonly protocol?: string;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#streamtags Destination#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Fields to automatically add to events, such as cribl_pipe. Supports wildcards. Default: ["cribl_pipe"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#system_fields Destination#system_fields}
  */
  readonly systemFields?: string[];
  /**
  * Rate (in bytes per second) to throttle while writing to an output. Accepts values with multiple-byte units, such as KB, MB, and GB. (Example: 42 MB) Default value of 0 specifies no throttling. Default: "0"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#throttle_rate_per_sec Destination#throttle_rate_per_sec}
  */
  readonly throttleRatePerSec?: string;
  /**
  * must be "graphite"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#type Destination#type}
  */
  readonly type?: string;
  /**
  * Amount of time (milliseconds) to wait for a write to complete before assuming connection is dead. Default: 60000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#write_timeout Destination#write_timeout}
  */
  readonly writeTimeout?: number;
}

export function destinationOutputGraphiteToTerraform(struct?: DestinationOutputGraphite | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    connection_timeout: cdktf.numberToTerraform(struct!.connectionTimeout),
    description: cdktf.stringToTerraform(struct!.description),
    dns_resolve_period_sec: cdktf.numberToTerraform(struct!.dnsResolvePeriodSec),
    environment: cdktf.stringToTerraform(struct!.environment),
    flush_period_sec: cdktf.numberToTerraform(struct!.flushPeriodSec),
    host: cdktf.stringToTerraform(struct!.host),
    id: cdktf.stringToTerraform(struct!.id),
    mtu: cdktf.numberToTerraform(struct!.mtu),
    on_backpressure: cdktf.stringToTerraform(struct!.onBackpressure),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    port: cdktf.numberToTerraform(struct!.port),
    pq_compress: cdktf.stringToTerraform(struct!.pqCompress),
    pq_controls: destinationOutputGraphitePqControlsToTerraform(struct!.pqControls),
    pq_max_file_size: cdktf.stringToTerraform(struct!.pqMaxFileSize),
    pq_max_size: cdktf.stringToTerraform(struct!.pqMaxSize),
    pq_mode: cdktf.stringToTerraform(struct!.pqMode),
    pq_on_backpressure: cdktf.stringToTerraform(struct!.pqOnBackpressure),
    pq_path: cdktf.stringToTerraform(struct!.pqPath),
    protocol: cdktf.stringToTerraform(struct!.protocol),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    system_fields: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.systemFields),
    throttle_rate_per_sec: cdktf.stringToTerraform(struct!.throttleRatePerSec),
    type: cdktf.stringToTerraform(struct!.type),
    write_timeout: cdktf.numberToTerraform(struct!.writeTimeout),
  }
}


export function destinationOutputGraphiteToHclTerraform(struct?: DestinationOutputGraphite | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    connection_timeout: {
      value: cdktf.numberToHclTerraform(struct!.connectionTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    dns_resolve_period_sec: {
      value: cdktf.numberToHclTerraform(struct!.dnsResolvePeriodSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    flush_period_sec: {
      value: cdktf.numberToHclTerraform(struct!.flushPeriodSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    host: {
      value: cdktf.stringToHclTerraform(struct!.host),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    mtu: {
      value: cdktf.numberToHclTerraform(struct!.mtu),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.onBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    pq_compress: {
      value: cdktf.stringToHclTerraform(struct!.pqCompress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_controls: {
      value: destinationOutputGraphitePqControlsToHclTerraform(struct!.pqControls),
      isBlock: true,
      type: "struct",
      storageClassType: "DestinationOutputGraphitePqControls",
    },
    pq_max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_max_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_mode: {
      value: cdktf.stringToHclTerraform(struct!.pqMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.pqOnBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_path: {
      value: cdktf.stringToHclTerraform(struct!.pqPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    protocol: {
      value: cdktf.stringToHclTerraform(struct!.protocol),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    system_fields: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.systemFields),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    throttle_rate_per_sec: {
      value: cdktf.stringToHclTerraform(struct!.throttleRatePerSec),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    write_timeout: {
      value: cdktf.numberToHclTerraform(struct!.writeTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputGraphiteOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DestinationOutputGraphite | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._connectionTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.connectionTimeout = this._connectionTimeout;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._dnsResolvePeriodSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.dnsResolvePeriodSec = this._dnsResolvePeriodSec;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._flushPeriodSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.flushPeriodSec = this._flushPeriodSec;
    }
    if (this._host !== undefined) {
      hasAnyValues = true;
      internalValueResult.host = this._host;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._mtu !== undefined) {
      hasAnyValues = true;
      internalValueResult.mtu = this._mtu;
    }
    if (this._onBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.onBackpressure = this._onBackpressure;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._pqCompress !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqCompress = this._pqCompress;
    }
    if (this._pqControls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqControls = this._pqControls?.internalValue;
    }
    if (this._pqMaxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxFileSize = this._pqMaxFileSize;
    }
    if (this._pqMaxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxSize = this._pqMaxSize;
    }
    if (this._pqMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMode = this._pqMode;
    }
    if (this._pqOnBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqOnBackpressure = this._pqOnBackpressure;
    }
    if (this._pqPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqPath = this._pqPath;
    }
    if (this._protocol !== undefined) {
      hasAnyValues = true;
      internalValueResult.protocol = this._protocol;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._systemFields !== undefined) {
      hasAnyValues = true;
      internalValueResult.systemFields = this._systemFields;
    }
    if (this._throttleRatePerSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.throttleRatePerSec = this._throttleRatePerSec;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._writeTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.writeTimeout = this._writeTimeout;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputGraphite | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._connectionTimeout = undefined;
      this._description = undefined;
      this._dnsResolvePeriodSec = undefined;
      this._environment = undefined;
      this._flushPeriodSec = undefined;
      this._host = undefined;
      this._id = undefined;
      this._mtu = undefined;
      this._onBackpressure = undefined;
      this._pipeline = undefined;
      this._port = undefined;
      this._pqCompress = undefined;
      this._pqControls.internalValue = undefined;
      this._pqMaxFileSize = undefined;
      this._pqMaxSize = undefined;
      this._pqMode = undefined;
      this._pqOnBackpressure = undefined;
      this._pqPath = undefined;
      this._protocol = undefined;
      this._streamtags = undefined;
      this._systemFields = undefined;
      this._throttleRatePerSec = undefined;
      this._type = undefined;
      this._writeTimeout = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._connectionTimeout = value.connectionTimeout;
      this._description = value.description;
      this._dnsResolvePeriodSec = value.dnsResolvePeriodSec;
      this._environment = value.environment;
      this._flushPeriodSec = value.flushPeriodSec;
      this._host = value.host;
      this._id = value.id;
      this._mtu = value.mtu;
      this._onBackpressure = value.onBackpressure;
      this._pipeline = value.pipeline;
      this._port = value.port;
      this._pqCompress = value.pqCompress;
      this._pqControls.internalValue = value.pqControls;
      this._pqMaxFileSize = value.pqMaxFileSize;
      this._pqMaxSize = value.pqMaxSize;
      this._pqMode = value.pqMode;
      this._pqOnBackpressure = value.pqOnBackpressure;
      this._pqPath = value.pqPath;
      this._protocol = value.protocol;
      this._streamtags = value.streamtags;
      this._systemFields = value.systemFields;
      this._throttleRatePerSec = value.throttleRatePerSec;
      this._type = value.type;
      this._writeTimeout = value.writeTimeout;
    }
  }

  // connection_timeout - computed: true, optional: true, required: false
  private _connectionTimeout?: number; 
  public get connectionTimeout() {
    return this.getNumberAttribute('connection_timeout');
  }
  public set connectionTimeout(value: number) {
    this._connectionTimeout = value;
  }
  public resetConnectionTimeout() {
    this._connectionTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectionTimeoutInput() {
    return this._connectionTimeout;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // dns_resolve_period_sec - computed: true, optional: true, required: false
  private _dnsResolvePeriodSec?: number; 
  public get dnsResolvePeriodSec() {
    return this.getNumberAttribute('dns_resolve_period_sec');
  }
  public set dnsResolvePeriodSec(value: number) {
    this._dnsResolvePeriodSec = value;
  }
  public resetDnsResolvePeriodSec() {
    this._dnsResolvePeriodSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dnsResolvePeriodSecInput() {
    return this._dnsResolvePeriodSec;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // flush_period_sec - computed: true, optional: true, required: false
  private _flushPeriodSec?: number; 
  public get flushPeriodSec() {
    return this.getNumberAttribute('flush_period_sec');
  }
  public set flushPeriodSec(value: number) {
    this._flushPeriodSec = value;
  }
  public resetFlushPeriodSec() {
    this._flushPeriodSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get flushPeriodSecInput() {
    return this._flushPeriodSec;
  }

  // host - computed: false, optional: false, required: true
  private _host?: string; 
  public get host() {
    return this.getStringAttribute('host');
  }
  public set host(value: string) {
    this._host = value;
  }
  // Temporarily expose input value. Use with caution.
  public get hostInput() {
    return this._host;
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // mtu - computed: true, optional: true, required: false
  private _mtu?: number; 
  public get mtu() {
    return this.getNumberAttribute('mtu');
  }
  public set mtu(value: number) {
    this._mtu = value;
  }
  public resetMtu() {
    this._mtu = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get mtuInput() {
    return this._mtu;
  }

  // on_backpressure - computed: true, optional: true, required: false
  private _onBackpressure?: string; 
  public get onBackpressure() {
    return this.getStringAttribute('on_backpressure');
  }
  public set onBackpressure(value: string) {
    this._onBackpressure = value;
  }
  public resetOnBackpressure() {
    this._onBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get onBackpressureInput() {
    return this._onBackpressure;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // port - computed: true, optional: true, required: false
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // pq_compress - computed: true, optional: true, required: false
  private _pqCompress?: string; 
  public get pqCompress() {
    return this.getStringAttribute('pq_compress');
  }
  public set pqCompress(value: string) {
    this._pqCompress = value;
  }
  public resetPqCompress() {
    this._pqCompress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqCompressInput() {
    return this._pqCompress;
  }

  // pq_controls - computed: false, optional: true, required: false
  private _pqControls = new DestinationOutputGraphitePqControlsOutputReference(this, "pq_controls");
  public get pqControls() {
    return this._pqControls;
  }
  public putPqControls(value: DestinationOutputGraphitePqControls) {
    this._pqControls.internalValue = value;
  }
  public resetPqControls() {
    this._pqControls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqControlsInput() {
    return this._pqControls.internalValue;
  }

  // pq_max_file_size - computed: true, optional: true, required: false
  private _pqMaxFileSize?: string; 
  public get pqMaxFileSize() {
    return this.getStringAttribute('pq_max_file_size');
  }
  public set pqMaxFileSize(value: string) {
    this._pqMaxFileSize = value;
  }
  public resetPqMaxFileSize() {
    this._pqMaxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxFileSizeInput() {
    return this._pqMaxFileSize;
  }

  // pq_max_size - computed: true, optional: true, required: false
  private _pqMaxSize?: string; 
  public get pqMaxSize() {
    return this.getStringAttribute('pq_max_size');
  }
  public set pqMaxSize(value: string) {
    this._pqMaxSize = value;
  }
  public resetPqMaxSize() {
    this._pqMaxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxSizeInput() {
    return this._pqMaxSize;
  }

  // pq_mode - computed: true, optional: true, required: false
  private _pqMode?: string; 
  public get pqMode() {
    return this.getStringAttribute('pq_mode');
  }
  public set pqMode(value: string) {
    this._pqMode = value;
  }
  public resetPqMode() {
    this._pqMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqModeInput() {
    return this._pqMode;
  }

  // pq_on_backpressure - computed: true, optional: true, required: false
  private _pqOnBackpressure?: string; 
  public get pqOnBackpressure() {
    return this.getStringAttribute('pq_on_backpressure');
  }
  public set pqOnBackpressure(value: string) {
    this._pqOnBackpressure = value;
  }
  public resetPqOnBackpressure() {
    this._pqOnBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqOnBackpressureInput() {
    return this._pqOnBackpressure;
  }

  // pq_path - computed: true, optional: true, required: false
  private _pqPath?: string; 
  public get pqPath() {
    return this.getStringAttribute('pq_path');
  }
  public set pqPath(value: string) {
    this._pqPath = value;
  }
  public resetPqPath() {
    this._pqPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqPathInput() {
    return this._pqPath;
  }

  // protocol - computed: true, optional: true, required: false
  private _protocol?: string; 
  public get protocol() {
    return this.getStringAttribute('protocol');
  }
  public set protocol(value: string) {
    this._protocol = value;
  }
  public resetProtocol() {
    this._protocol = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get protocolInput() {
    return this._protocol;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // system_fields - computed: true, optional: true, required: false
  private _systemFields?: string[]; 
  public get systemFields() {
    return this.getListAttribute('system_fields');
  }
  public set systemFields(value: string[]) {
    this._systemFields = value;
  }
  public resetSystemFields() {
    this._systemFields = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get systemFieldsInput() {
    return this._systemFields;
  }

  // throttle_rate_per_sec - computed: true, optional: true, required: false
  private _throttleRatePerSec?: string; 
  public get throttleRatePerSec() {
    return this.getStringAttribute('throttle_rate_per_sec');
  }
  public set throttleRatePerSec(value: string) {
    this._throttleRatePerSec = value;
  }
  public resetThrottleRatePerSec() {
    this._throttleRatePerSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get throttleRatePerSecInput() {
    return this._throttleRatePerSec;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // write_timeout - computed: true, optional: true, required: false
  private _writeTimeout?: number; 
  public get writeTimeout() {
    return this.getNumberAttribute('write_timeout');
  }
  public set writeTimeout(value: number) {
    this._writeTimeout = value;
  }
  public resetWriteTimeout() {
    this._writeTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get writeTimeoutInput() {
    return this._writeTimeout;
  }
}
export interface DestinationOutputHoneycombExtraHttpHeaders {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#name Destination#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#value Destination#value}
  */
  readonly value: string;
}

export function destinationOutputHoneycombExtraHttpHeadersToTerraform(struct?: DestinationOutputHoneycombExtraHttpHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function destinationOutputHoneycombExtraHttpHeadersToHclTerraform(struct?: DestinationOutputHoneycombExtraHttpHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputHoneycombExtraHttpHeadersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DestinationOutputHoneycombExtraHttpHeaders | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputHoneycombExtraHttpHeaders | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DestinationOutputHoneycombExtraHttpHeadersList extends cdktf.ComplexList {
  public internalValue? : DestinationOutputHoneycombExtraHttpHeaders[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DestinationOutputHoneycombExtraHttpHeadersOutputReference {
    return new DestinationOutputHoneycombExtraHttpHeadersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DestinationOutputHoneycombPqControls {
}

export function destinationOutputHoneycombPqControlsToTerraform(struct?: DestinationOutputHoneycombPqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function destinationOutputHoneycombPqControlsToHclTerraform(struct?: DestinationOutputHoneycombPqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class DestinationOutputHoneycombPqControlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DestinationOutputHoneycombPqControls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputHoneycombPqControls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface DestinationOutputHoneycombResponseRetrySettings {
  /**
  * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc. Default: 2
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#backoff_rate Destination#backoff_rate}
  */
  readonly backoffRate?: number;
  /**
  * The HTTP response status code that will trigger retries
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#http_status Destination#http_status}
  */
  readonly httpStatus: number;
  /**
  * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes). Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#initial_backoff Destination#initial_backoff}
  */
  readonly initialBackoff?: number;
  /**
  * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds). Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#max_backoff Destination#max_backoff}
  */
  readonly maxBackoff?: number;
}

export function destinationOutputHoneycombResponseRetrySettingsToTerraform(struct?: DestinationOutputHoneycombResponseRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    backoff_rate: cdktf.numberToTerraform(struct!.backoffRate),
    http_status: cdktf.numberToTerraform(struct!.httpStatus),
    initial_backoff: cdktf.numberToTerraform(struct!.initialBackoff),
    max_backoff: cdktf.numberToTerraform(struct!.maxBackoff),
  }
}


export function destinationOutputHoneycombResponseRetrySettingsToHclTerraform(struct?: DestinationOutputHoneycombResponseRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    backoff_rate: {
      value: cdktf.numberToHclTerraform(struct!.backoffRate),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    http_status: {
      value: cdktf.numberToHclTerraform(struct!.httpStatus),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    initial_backoff: {
      value: cdktf.numberToHclTerraform(struct!.initialBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_backoff: {
      value: cdktf.numberToHclTerraform(struct!.maxBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputHoneycombResponseRetrySettingsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DestinationOutputHoneycombResponseRetrySettings | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._backoffRate !== undefined) {
      hasAnyValues = true;
      internalValueResult.backoffRate = this._backoffRate;
    }
    if (this._httpStatus !== undefined) {
      hasAnyValues = true;
      internalValueResult.httpStatus = this._httpStatus;
    }
    if (this._initialBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.initialBackoff = this._initialBackoff;
    }
    if (this._maxBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBackoff = this._maxBackoff;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputHoneycombResponseRetrySettings | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._backoffRate = undefined;
      this._httpStatus = undefined;
      this._initialBackoff = undefined;
      this._maxBackoff = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._backoffRate = value.backoffRate;
      this._httpStatus = value.httpStatus;
      this._initialBackoff = value.initialBackoff;
      this._maxBackoff = value.maxBackoff;
    }
  }

  // backoff_rate - computed: true, optional: true, required: false
  private _backoffRate?: number; 
  public get backoffRate() {
    return this.getNumberAttribute('backoff_rate');
  }
  public set backoffRate(value: number) {
    this._backoffRate = value;
  }
  public resetBackoffRate() {
    this._backoffRate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get backoffRateInput() {
    return this._backoffRate;
  }

  // http_status - computed: false, optional: false, required: true
  private _httpStatus?: number; 
  public get httpStatus() {
    return this.getNumberAttribute('http_status');
  }
  public set httpStatus(value: number) {
    this._httpStatus = value;
  }
  // Temporarily expose input value. Use with caution.
  public get httpStatusInput() {
    return this._httpStatus;
  }

  // initial_backoff - computed: true, optional: true, required: false
  private _initialBackoff?: number; 
  public get initialBackoff() {
    return this.getNumberAttribute('initial_backoff');
  }
  public set initialBackoff(value: number) {
    this._initialBackoff = value;
  }
  public resetInitialBackoff() {
    this._initialBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get initialBackoffInput() {
    return this._initialBackoff;
  }

  // max_backoff - computed: true, optional: true, required: false
  private _maxBackoff?: number; 
  public get maxBackoff() {
    return this.getNumberAttribute('max_backoff');
  }
  public set maxBackoff(value: number) {
    this._maxBackoff = value;
  }
  public resetMaxBackoff() {
    this._maxBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBackoffInput() {
    return this._maxBackoff;
  }
}

export class DestinationOutputHoneycombResponseRetrySettingsList extends cdktf.ComplexList {
  public internalValue? : DestinationOutputHoneycombResponseRetrySettings[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DestinationOutputHoneycombResponseRetrySettingsOutputReference {
    return new DestinationOutputHoneycombResponseRetrySettingsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DestinationOutputHoneycombTimeoutRetrySettings {
  /**
  * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc. Default: 2
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#backoff_rate Destination#backoff_rate}
  */
  readonly backoffRate?: number;
  /**
  * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes). Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#initial_backoff Destination#initial_backoff}
  */
  readonly initialBackoff?: number;
  /**
  * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds). Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#max_backoff Destination#max_backoff}
  */
  readonly maxBackoff?: number;
  /**
  * Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#timeout_retry Destination#timeout_retry}
  */
  readonly timeoutRetry?: boolean | cdktf.IResolvable;
}

export function destinationOutputHoneycombTimeoutRetrySettingsToTerraform(struct?: DestinationOutputHoneycombTimeoutRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    backoff_rate: cdktf.numberToTerraform(struct!.backoffRate),
    initial_backoff: cdktf.numberToTerraform(struct!.initialBackoff),
    max_backoff: cdktf.numberToTerraform(struct!.maxBackoff),
    timeout_retry: cdktf.booleanToTerraform(struct!.timeoutRetry),
  }
}


export function destinationOutputHoneycombTimeoutRetrySettingsToHclTerraform(struct?: DestinationOutputHoneycombTimeoutRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    backoff_rate: {
      value: cdktf.numberToHclTerraform(struct!.backoffRate),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    initial_backoff: {
      value: cdktf.numberToHclTerraform(struct!.initialBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_backoff: {
      value: cdktf.numberToHclTerraform(struct!.maxBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    timeout_retry: {
      value: cdktf.booleanToHclTerraform(struct!.timeoutRetry),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputHoneycombTimeoutRetrySettingsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DestinationOutputHoneycombTimeoutRetrySettings | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._backoffRate !== undefined) {
      hasAnyValues = true;
      internalValueResult.backoffRate = this._backoffRate;
    }
    if (this._initialBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.initialBackoff = this._initialBackoff;
    }
    if (this._maxBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBackoff = this._maxBackoff;
    }
    if (this._timeoutRetry !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutRetry = this._timeoutRetry;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputHoneycombTimeoutRetrySettings | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._backoffRate = undefined;
      this._initialBackoff = undefined;
      this._maxBackoff = undefined;
      this._timeoutRetry = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._backoffRate = value.backoffRate;
      this._initialBackoff = value.initialBackoff;
      this._maxBackoff = value.maxBackoff;
      this._timeoutRetry = value.timeoutRetry;
    }
  }

  // backoff_rate - computed: true, optional: true, required: false
  private _backoffRate?: number; 
  public get backoffRate() {
    return this.getNumberAttribute('backoff_rate');
  }
  public set backoffRate(value: number) {
    this._backoffRate = value;
  }
  public resetBackoffRate() {
    this._backoffRate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get backoffRateInput() {
    return this._backoffRate;
  }

  // initial_backoff - computed: true, optional: true, required: false
  private _initialBackoff?: number; 
  public get initialBackoff() {
    return this.getNumberAttribute('initial_backoff');
  }
  public set initialBackoff(value: number) {
    this._initialBackoff = value;
  }
  public resetInitialBackoff() {
    this._initialBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get initialBackoffInput() {
    return this._initialBackoff;
  }

  // max_backoff - computed: true, optional: true, required: false
  private _maxBackoff?: number; 
  public get maxBackoff() {
    return this.getNumberAttribute('max_backoff');
  }
  public set maxBackoff(value: number) {
    this._maxBackoff = value;
  }
  public resetMaxBackoff() {
    this._maxBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBackoffInput() {
    return this._maxBackoff;
  }

  // timeout_retry - computed: true, optional: true, required: false
  private _timeoutRetry?: boolean | cdktf.IResolvable; 
  public get timeoutRetry() {
    return this.getBooleanAttribute('timeout_retry');
  }
  public set timeoutRetry(value: boolean | cdktf.IResolvable) {
    this._timeoutRetry = value;
  }
  public resetTimeoutRetry() {
    this._timeoutRetry = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutRetryInput() {
    return this._timeoutRetry;
  }
}
export interface DestinationOutputHoneycomb {
  /**
  * Enter API key directly, or select a stored secret. Default: "manual"; must be one of ["manual", "secret"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#auth_type Destination#auth_type}
  */
  readonly authType?: string;
  /**
  * Compress the payload body before sending. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#compress Destination#compress}
  */
  readonly compress?: boolean | cdktf.IResolvable;
  /**
  * Maximum number of ongoing requests before blocking. Default: 5
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#concurrency Destination#concurrency}
  */
  readonly concurrency?: number;
  /**
  * Name of the dataset to send events to – e.g., observability
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#dataset Destination#dataset}
  */
  readonly dataset: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#description Destination#description}
  */
  readonly description?: string;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#environment Destination#environment}
  */
  readonly environment?: string;
  /**
  * Headers to add to all events
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#extra_http_headers Destination#extra_http_headers}
  */
  readonly extraHttpHeaders?: DestinationOutputHoneycombExtraHttpHeaders[] | cdktf.IResolvable;
  /**
  * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below. Default: "none"; must be one of ["payload", "payloadAndHeaders", "none"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#failed_request_logging_mode Destination#failed_request_logging_mode}
  */
  readonly failedRequestLoggingMode?: string;
  /**
  * Maximum time between requests. Small values could cause the payload size to be smaller than the configured Body size limit. Default: 1
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#flush_period_sec Destination#flush_period_sec}
  */
  readonly flushPeriodSec?: number;
  /**
  * Unique ID for this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#id Destination#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * Maximum number of events to include in the request body. Default is 0 (unlimited). Default: 0
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#max_payload_events Destination#max_payload_events}
  */
  readonly maxPayloadEvents?: number;
  /**
  * Maximum size, in KB, of the request body. Default: 4096
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#max_payload_size_kb Destination#max_payload_size_kb}
  */
  readonly maxPayloadSizeKb?: number;
  /**
  * How to handle events when all receivers are exerting backpressure. Default: "block"; must be one of ["block", "drop", "queue"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#on_backpressure Destination#on_backpressure}
  */
  readonly onBackpressure?: string;
  /**
  * Pipeline to process data before sending out to this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pipeline Destination#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pq_compress Destination#pq_compress}
  */
  readonly pqCompress?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pq_controls Destination#pq_controls}
  */
  readonly pqControls?: DestinationOutputHoneycombPqControls;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.). Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pq_max_file_size Destination#pq_max_file_size}
  */
  readonly pqMaxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pq_max_size Destination#pq_max_size}
  */
  readonly pqMaxSize?: string;
  /**
  * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem. Default: "error"; must be one of ["error", "backpressure", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pq_mode Destination#pq_mode}
  */
  readonly pqMode?: string;
  /**
  * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged. Default: "block"; must be one of ["block", "drop"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pq_on_backpressure Destination#pq_on_backpressure}
  */
  readonly pqOnBackpressure?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pq_path Destination#pq_path}
  */
  readonly pqPath?: string;
  /**
  * Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's). 
  *         Enabled by default. When this setting is also present in TLS Settings (Client Side), 
  *         that value will take precedence.
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#reject_unauthorized Destination#reject_unauthorized}
  */
  readonly rejectUnauthorized?: boolean | cdktf.IResolvable;
  /**
  * Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#response_honor_retry_after_header Destination#response_honor_retry_after_header}
  */
  readonly responseHonorRetryAfterHeader?: boolean | cdktf.IResolvable;
  /**
  * Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#response_retry_settings Destination#response_retry_settings}
  */
  readonly responseRetrySettings?: DestinationOutputHoneycombResponseRetrySettings[] | cdktf.IResolvable;
  /**
  * List of headers that are safe to log in plain text. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#safe_headers Destination#safe_headers}
  */
  readonly safeHeaders?: string[];
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#streamtags Destination#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Fields to automatically add to events, such as cribl_pipe. Supports wildcards. Default: ["cribl_pipe"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#system_fields Destination#system_fields}
  */
  readonly systemFields?: string[];
  /**
  * Team API key where the dataset belongs
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#team Destination#team}
  */
  readonly team?: string;
  /**
  * Select or create a stored text secret
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#text_secret Destination#text_secret}
  */
  readonly textSecret?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#timeout_retry_settings Destination#timeout_retry_settings}
  */
  readonly timeoutRetrySettings?: DestinationOutputHoneycombTimeoutRetrySettings;
  /**
  * Amount of time, in seconds, to wait for a request to complete before canceling it. Default: 30
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#timeout_sec Destination#timeout_sec}
  */
  readonly timeoutSec?: number;
  /**
  * must be "honeycomb"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#type Destination#type}
  */
  readonly type: string;
  /**
  * Enable round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. For optimal performance, consider enabling this setting for non-load balanced destinations. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#use_round_robin_dns Destination#use_round_robin_dns}
  */
  readonly useRoundRobinDns?: boolean | cdktf.IResolvable;
}

export function destinationOutputHoneycombToTerraform(struct?: DestinationOutputHoneycomb | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    auth_type: cdktf.stringToTerraform(struct!.authType),
    compress: cdktf.booleanToTerraform(struct!.compress),
    concurrency: cdktf.numberToTerraform(struct!.concurrency),
    dataset: cdktf.stringToTerraform(struct!.dataset),
    description: cdktf.stringToTerraform(struct!.description),
    environment: cdktf.stringToTerraform(struct!.environment),
    extra_http_headers: cdktf.listMapper(destinationOutputHoneycombExtraHttpHeadersToTerraform, false)(struct!.extraHttpHeaders),
    failed_request_logging_mode: cdktf.stringToTerraform(struct!.failedRequestLoggingMode),
    flush_period_sec: cdktf.numberToTerraform(struct!.flushPeriodSec),
    id: cdktf.stringToTerraform(struct!.id),
    max_payload_events: cdktf.numberToTerraform(struct!.maxPayloadEvents),
    max_payload_size_kb: cdktf.numberToTerraform(struct!.maxPayloadSizeKb),
    on_backpressure: cdktf.stringToTerraform(struct!.onBackpressure),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    pq_compress: cdktf.stringToTerraform(struct!.pqCompress),
    pq_controls: destinationOutputHoneycombPqControlsToTerraform(struct!.pqControls),
    pq_max_file_size: cdktf.stringToTerraform(struct!.pqMaxFileSize),
    pq_max_size: cdktf.stringToTerraform(struct!.pqMaxSize),
    pq_mode: cdktf.stringToTerraform(struct!.pqMode),
    pq_on_backpressure: cdktf.stringToTerraform(struct!.pqOnBackpressure),
    pq_path: cdktf.stringToTerraform(struct!.pqPath),
    reject_unauthorized: cdktf.booleanToTerraform(struct!.rejectUnauthorized),
    response_honor_retry_after_header: cdktf.booleanToTerraform(struct!.responseHonorRetryAfterHeader),
    response_retry_settings: cdktf.listMapper(destinationOutputHoneycombResponseRetrySettingsToTerraform, false)(struct!.responseRetrySettings),
    safe_headers: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.safeHeaders),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    system_fields: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.systemFields),
    team: cdktf.stringToTerraform(struct!.team),
    text_secret: cdktf.stringToTerraform(struct!.textSecret),
    timeout_retry_settings: destinationOutputHoneycombTimeoutRetrySettingsToTerraform(struct!.timeoutRetrySettings),
    timeout_sec: cdktf.numberToTerraform(struct!.timeoutSec),
    type: cdktf.stringToTerraform(struct!.type),
    use_round_robin_dns: cdktf.booleanToTerraform(struct!.useRoundRobinDns),
  }
}


export function destinationOutputHoneycombToHclTerraform(struct?: DestinationOutputHoneycomb | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    auth_type: {
      value: cdktf.stringToHclTerraform(struct!.authType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    compress: {
      value: cdktf.booleanToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    concurrency: {
      value: cdktf.numberToHclTerraform(struct!.concurrency),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    dataset: {
      value: cdktf.stringToHclTerraform(struct!.dataset),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    extra_http_headers: {
      value: cdktf.listMapperHcl(destinationOutputHoneycombExtraHttpHeadersToHclTerraform, false)(struct!.extraHttpHeaders),
      isBlock: true,
      type: "list",
      storageClassType: "DestinationOutputHoneycombExtraHttpHeadersList",
    },
    failed_request_logging_mode: {
      value: cdktf.stringToHclTerraform(struct!.failedRequestLoggingMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    flush_period_sec: {
      value: cdktf.numberToHclTerraform(struct!.flushPeriodSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_payload_events: {
      value: cdktf.numberToHclTerraform(struct!.maxPayloadEvents),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_payload_size_kb: {
      value: cdktf.numberToHclTerraform(struct!.maxPayloadSizeKb),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.onBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_compress: {
      value: cdktf.stringToHclTerraform(struct!.pqCompress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_controls: {
      value: destinationOutputHoneycombPqControlsToHclTerraform(struct!.pqControls),
      isBlock: true,
      type: "struct",
      storageClassType: "DestinationOutputHoneycombPqControls",
    },
    pq_max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_max_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_mode: {
      value: cdktf.stringToHclTerraform(struct!.pqMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.pqOnBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_path: {
      value: cdktf.stringToHclTerraform(struct!.pqPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reject_unauthorized: {
      value: cdktf.booleanToHclTerraform(struct!.rejectUnauthorized),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    response_honor_retry_after_header: {
      value: cdktf.booleanToHclTerraform(struct!.responseHonorRetryAfterHeader),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    response_retry_settings: {
      value: cdktf.listMapperHcl(destinationOutputHoneycombResponseRetrySettingsToHclTerraform, false)(struct!.responseRetrySettings),
      isBlock: true,
      type: "list",
      storageClassType: "DestinationOutputHoneycombResponseRetrySettingsList",
    },
    safe_headers: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.safeHeaders),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    system_fields: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.systemFields),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    team: {
      value: cdktf.stringToHclTerraform(struct!.team),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    text_secret: {
      value: cdktf.stringToHclTerraform(struct!.textSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    timeout_retry_settings: {
      value: destinationOutputHoneycombTimeoutRetrySettingsToHclTerraform(struct!.timeoutRetrySettings),
      isBlock: true,
      type: "struct",
      storageClassType: "DestinationOutputHoneycombTimeoutRetrySettings",
    },
    timeout_sec: {
      value: cdktf.numberToHclTerraform(struct!.timeoutSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    use_round_robin_dns: {
      value: cdktf.booleanToHclTerraform(struct!.useRoundRobinDns),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputHoneycombOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DestinationOutputHoneycomb | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._authType !== undefined) {
      hasAnyValues = true;
      internalValueResult.authType = this._authType;
    }
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._concurrency !== undefined) {
      hasAnyValues = true;
      internalValueResult.concurrency = this._concurrency;
    }
    if (this._dataset !== undefined) {
      hasAnyValues = true;
      internalValueResult.dataset = this._dataset;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._extraHttpHeaders?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.extraHttpHeaders = this._extraHttpHeaders?.internalValue;
    }
    if (this._failedRequestLoggingMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.failedRequestLoggingMode = this._failedRequestLoggingMode;
    }
    if (this._flushPeriodSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.flushPeriodSec = this._flushPeriodSec;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._maxPayloadEvents !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxPayloadEvents = this._maxPayloadEvents;
    }
    if (this._maxPayloadSizeKb !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxPayloadSizeKb = this._maxPayloadSizeKb;
    }
    if (this._onBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.onBackpressure = this._onBackpressure;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._pqCompress !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqCompress = this._pqCompress;
    }
    if (this._pqControls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqControls = this._pqControls?.internalValue;
    }
    if (this._pqMaxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxFileSize = this._pqMaxFileSize;
    }
    if (this._pqMaxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxSize = this._pqMaxSize;
    }
    if (this._pqMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMode = this._pqMode;
    }
    if (this._pqOnBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqOnBackpressure = this._pqOnBackpressure;
    }
    if (this._pqPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqPath = this._pqPath;
    }
    if (this._rejectUnauthorized !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectUnauthorized = this._rejectUnauthorized;
    }
    if (this._responseHonorRetryAfterHeader !== undefined) {
      hasAnyValues = true;
      internalValueResult.responseHonorRetryAfterHeader = this._responseHonorRetryAfterHeader;
    }
    if (this._responseRetrySettings?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.responseRetrySettings = this._responseRetrySettings?.internalValue;
    }
    if (this._safeHeaders !== undefined) {
      hasAnyValues = true;
      internalValueResult.safeHeaders = this._safeHeaders;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._systemFields !== undefined) {
      hasAnyValues = true;
      internalValueResult.systemFields = this._systemFields;
    }
    if (this._team !== undefined) {
      hasAnyValues = true;
      internalValueResult.team = this._team;
    }
    if (this._textSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.textSecret = this._textSecret;
    }
    if (this._timeoutRetrySettings?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutRetrySettings = this._timeoutRetrySettings?.internalValue;
    }
    if (this._timeoutSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutSec = this._timeoutSec;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._useRoundRobinDns !== undefined) {
      hasAnyValues = true;
      internalValueResult.useRoundRobinDns = this._useRoundRobinDns;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputHoneycomb | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._authType = undefined;
      this._compress = undefined;
      this._concurrency = undefined;
      this._dataset = undefined;
      this._description = undefined;
      this._environment = undefined;
      this._extraHttpHeaders.internalValue = undefined;
      this._failedRequestLoggingMode = undefined;
      this._flushPeriodSec = undefined;
      this._id = undefined;
      this._maxPayloadEvents = undefined;
      this._maxPayloadSizeKb = undefined;
      this._onBackpressure = undefined;
      this._pipeline = undefined;
      this._pqCompress = undefined;
      this._pqControls.internalValue = undefined;
      this._pqMaxFileSize = undefined;
      this._pqMaxSize = undefined;
      this._pqMode = undefined;
      this._pqOnBackpressure = undefined;
      this._pqPath = undefined;
      this._rejectUnauthorized = undefined;
      this._responseHonorRetryAfterHeader = undefined;
      this._responseRetrySettings.internalValue = undefined;
      this._safeHeaders = undefined;
      this._streamtags = undefined;
      this._systemFields = undefined;
      this._team = undefined;
      this._textSecret = undefined;
      this._timeoutRetrySettings.internalValue = undefined;
      this._timeoutSec = undefined;
      this._type = undefined;
      this._useRoundRobinDns = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._authType = value.authType;
      this._compress = value.compress;
      this._concurrency = value.concurrency;
      this._dataset = value.dataset;
      this._description = value.description;
      this._environment = value.environment;
      this._extraHttpHeaders.internalValue = value.extraHttpHeaders;
      this._failedRequestLoggingMode = value.failedRequestLoggingMode;
      this._flushPeriodSec = value.flushPeriodSec;
      this._id = value.id;
      this._maxPayloadEvents = value.maxPayloadEvents;
      this._maxPayloadSizeKb = value.maxPayloadSizeKb;
      this._onBackpressure = value.onBackpressure;
      this._pipeline = value.pipeline;
      this._pqCompress = value.pqCompress;
      this._pqControls.internalValue = value.pqControls;
      this._pqMaxFileSize = value.pqMaxFileSize;
      this._pqMaxSize = value.pqMaxSize;
      this._pqMode = value.pqMode;
      this._pqOnBackpressure = value.pqOnBackpressure;
      this._pqPath = value.pqPath;
      this._rejectUnauthorized = value.rejectUnauthorized;
      this._responseHonorRetryAfterHeader = value.responseHonorRetryAfterHeader;
      this._responseRetrySettings.internalValue = value.responseRetrySettings;
      this._safeHeaders = value.safeHeaders;
      this._streamtags = value.streamtags;
      this._systemFields = value.systemFields;
      this._team = value.team;
      this._textSecret = value.textSecret;
      this._timeoutRetrySettings.internalValue = value.timeoutRetrySettings;
      this._timeoutSec = value.timeoutSec;
      this._type = value.type;
      this._useRoundRobinDns = value.useRoundRobinDns;
    }
  }

  // auth_type - computed: true, optional: true, required: false
  private _authType?: string; 
  public get authType() {
    return this.getStringAttribute('auth_type');
  }
  public set authType(value: string) {
    this._authType = value;
  }
  public resetAuthType() {
    this._authType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authTypeInput() {
    return this._authType;
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: boolean | cdktf.IResolvable; 
  public get compress() {
    return this.getBooleanAttribute('compress');
  }
  public set compress(value: boolean | cdktf.IResolvable) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // concurrency - computed: true, optional: true, required: false
  private _concurrency?: number; 
  public get concurrency() {
    return this.getNumberAttribute('concurrency');
  }
  public set concurrency(value: number) {
    this._concurrency = value;
  }
  public resetConcurrency() {
    this._concurrency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get concurrencyInput() {
    return this._concurrency;
  }

  // dataset - computed: false, optional: false, required: true
  private _dataset?: string; 
  public get dataset() {
    return this.getStringAttribute('dataset');
  }
  public set dataset(value: string) {
    this._dataset = value;
  }
  // Temporarily expose input value. Use with caution.
  public get datasetInput() {
    return this._dataset;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // extra_http_headers - computed: false, optional: true, required: false
  private _extraHttpHeaders = new DestinationOutputHoneycombExtraHttpHeadersList(this, "extra_http_headers", false);
  public get extraHttpHeaders() {
    return this._extraHttpHeaders;
  }
  public putExtraHttpHeaders(value: DestinationOutputHoneycombExtraHttpHeaders[] | cdktf.IResolvable) {
    this._extraHttpHeaders.internalValue = value;
  }
  public resetExtraHttpHeaders() {
    this._extraHttpHeaders.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get extraHttpHeadersInput() {
    return this._extraHttpHeaders.internalValue;
  }

  // failed_request_logging_mode - computed: true, optional: true, required: false
  private _failedRequestLoggingMode?: string; 
  public get failedRequestLoggingMode() {
    return this.getStringAttribute('failed_request_logging_mode');
  }
  public set failedRequestLoggingMode(value: string) {
    this._failedRequestLoggingMode = value;
  }
  public resetFailedRequestLoggingMode() {
    this._failedRequestLoggingMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get failedRequestLoggingModeInput() {
    return this._failedRequestLoggingMode;
  }

  // flush_period_sec - computed: true, optional: true, required: false
  private _flushPeriodSec?: number; 
  public get flushPeriodSec() {
    return this.getNumberAttribute('flush_period_sec');
  }
  public set flushPeriodSec(value: number) {
    this._flushPeriodSec = value;
  }
  public resetFlushPeriodSec() {
    this._flushPeriodSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get flushPeriodSecInput() {
    return this._flushPeriodSec;
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // max_payload_events - computed: true, optional: true, required: false
  private _maxPayloadEvents?: number; 
  public get maxPayloadEvents() {
    return this.getNumberAttribute('max_payload_events');
  }
  public set maxPayloadEvents(value: number) {
    this._maxPayloadEvents = value;
  }
  public resetMaxPayloadEvents() {
    this._maxPayloadEvents = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxPayloadEventsInput() {
    return this._maxPayloadEvents;
  }

  // max_payload_size_kb - computed: true, optional: true, required: false
  private _maxPayloadSizeKb?: number; 
  public get maxPayloadSizeKb() {
    return this.getNumberAttribute('max_payload_size_kb');
  }
  public set maxPayloadSizeKb(value: number) {
    this._maxPayloadSizeKb = value;
  }
  public resetMaxPayloadSizeKb() {
    this._maxPayloadSizeKb = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxPayloadSizeKbInput() {
    return this._maxPayloadSizeKb;
  }

  // on_backpressure - computed: true, optional: true, required: false
  private _onBackpressure?: string; 
  public get onBackpressure() {
    return this.getStringAttribute('on_backpressure');
  }
  public set onBackpressure(value: string) {
    this._onBackpressure = value;
  }
  public resetOnBackpressure() {
    this._onBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get onBackpressureInput() {
    return this._onBackpressure;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // pq_compress - computed: true, optional: true, required: false
  private _pqCompress?: string; 
  public get pqCompress() {
    return this.getStringAttribute('pq_compress');
  }
  public set pqCompress(value: string) {
    this._pqCompress = value;
  }
  public resetPqCompress() {
    this._pqCompress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqCompressInput() {
    return this._pqCompress;
  }

  // pq_controls - computed: false, optional: true, required: false
  private _pqControls = new DestinationOutputHoneycombPqControlsOutputReference(this, "pq_controls");
  public get pqControls() {
    return this._pqControls;
  }
  public putPqControls(value: DestinationOutputHoneycombPqControls) {
    this._pqControls.internalValue = value;
  }
  public resetPqControls() {
    this._pqControls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqControlsInput() {
    return this._pqControls.internalValue;
  }

  // pq_max_file_size - computed: true, optional: true, required: false
  private _pqMaxFileSize?: string; 
  public get pqMaxFileSize() {
    return this.getStringAttribute('pq_max_file_size');
  }
  public set pqMaxFileSize(value: string) {
    this._pqMaxFileSize = value;
  }
  public resetPqMaxFileSize() {
    this._pqMaxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxFileSizeInput() {
    return this._pqMaxFileSize;
  }

  // pq_max_size - computed: true, optional: true, required: false
  private _pqMaxSize?: string; 
  public get pqMaxSize() {
    return this.getStringAttribute('pq_max_size');
  }
  public set pqMaxSize(value: string) {
    this._pqMaxSize = value;
  }
  public resetPqMaxSize() {
    this._pqMaxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxSizeInput() {
    return this._pqMaxSize;
  }

  // pq_mode - computed: true, optional: true, required: false
  private _pqMode?: string; 
  public get pqMode() {
    return this.getStringAttribute('pq_mode');
  }
  public set pqMode(value: string) {
    this._pqMode = value;
  }
  public resetPqMode() {
    this._pqMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqModeInput() {
    return this._pqMode;
  }

  // pq_on_backpressure - computed: true, optional: true, required: false
  private _pqOnBackpressure?: string; 
  public get pqOnBackpressure() {
    return this.getStringAttribute('pq_on_backpressure');
  }
  public set pqOnBackpressure(value: string) {
    this._pqOnBackpressure = value;
  }
  public resetPqOnBackpressure() {
    this._pqOnBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqOnBackpressureInput() {
    return this._pqOnBackpressure;
  }

  // pq_path - computed: true, optional: true, required: false
  private _pqPath?: string; 
  public get pqPath() {
    return this.getStringAttribute('pq_path');
  }
  public set pqPath(value: string) {
    this._pqPath = value;
  }
  public resetPqPath() {
    this._pqPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqPathInput() {
    return this._pqPath;
  }

  // reject_unauthorized - computed: true, optional: true, required: false
  private _rejectUnauthorized?: boolean | cdktf.IResolvable; 
  public get rejectUnauthorized() {
    return this.getBooleanAttribute('reject_unauthorized');
  }
  public set rejectUnauthorized(value: boolean | cdktf.IResolvable) {
    this._rejectUnauthorized = value;
  }
  public resetRejectUnauthorized() {
    this._rejectUnauthorized = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectUnauthorizedInput() {
    return this._rejectUnauthorized;
  }

  // response_honor_retry_after_header - computed: true, optional: true, required: false
  private _responseHonorRetryAfterHeader?: boolean | cdktf.IResolvable; 
  public get responseHonorRetryAfterHeader() {
    return this.getBooleanAttribute('response_honor_retry_after_header');
  }
  public set responseHonorRetryAfterHeader(value: boolean | cdktf.IResolvable) {
    this._responseHonorRetryAfterHeader = value;
  }
  public resetResponseHonorRetryAfterHeader() {
    this._responseHonorRetryAfterHeader = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get responseHonorRetryAfterHeaderInput() {
    return this._responseHonorRetryAfterHeader;
  }

  // response_retry_settings - computed: false, optional: true, required: false
  private _responseRetrySettings = new DestinationOutputHoneycombResponseRetrySettingsList(this, "response_retry_settings", false);
  public get responseRetrySettings() {
    return this._responseRetrySettings;
  }
  public putResponseRetrySettings(value: DestinationOutputHoneycombResponseRetrySettings[] | cdktf.IResolvable) {
    this._responseRetrySettings.internalValue = value;
  }
  public resetResponseRetrySettings() {
    this._responseRetrySettings.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get responseRetrySettingsInput() {
    return this._responseRetrySettings.internalValue;
  }

  // safe_headers - computed: true, optional: true, required: false
  private _safeHeaders?: string[]; 
  public get safeHeaders() {
    return this.getListAttribute('safe_headers');
  }
  public set safeHeaders(value: string[]) {
    this._safeHeaders = value;
  }
  public resetSafeHeaders() {
    this._safeHeaders = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get safeHeadersInput() {
    return this._safeHeaders;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // system_fields - computed: true, optional: true, required: false
  private _systemFields?: string[]; 
  public get systemFields() {
    return this.getListAttribute('system_fields');
  }
  public set systemFields(value: string[]) {
    this._systemFields = value;
  }
  public resetSystemFields() {
    this._systemFields = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get systemFieldsInput() {
    return this._systemFields;
  }

  // team - computed: false, optional: true, required: false
  private _team?: string; 
  public get team() {
    return this.getStringAttribute('team');
  }
  public set team(value: string) {
    this._team = value;
  }
  public resetTeam() {
    this._team = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get teamInput() {
    return this._team;
  }

  // text_secret - computed: false, optional: true, required: false
  private _textSecret?: string; 
  public get textSecret() {
    return this.getStringAttribute('text_secret');
  }
  public set textSecret(value: string) {
    this._textSecret = value;
  }
  public resetTextSecret() {
    this._textSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get textSecretInput() {
    return this._textSecret;
  }

  // timeout_retry_settings - computed: false, optional: true, required: false
  private _timeoutRetrySettings = new DestinationOutputHoneycombTimeoutRetrySettingsOutputReference(this, "timeout_retry_settings");
  public get timeoutRetrySettings() {
    return this._timeoutRetrySettings;
  }
  public putTimeoutRetrySettings(value: DestinationOutputHoneycombTimeoutRetrySettings) {
    this._timeoutRetrySettings.internalValue = value;
  }
  public resetTimeoutRetrySettings() {
    this._timeoutRetrySettings.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutRetrySettingsInput() {
    return this._timeoutRetrySettings.internalValue;
  }

  // timeout_sec - computed: true, optional: true, required: false
  private _timeoutSec?: number; 
  public get timeoutSec() {
    return this.getNumberAttribute('timeout_sec');
  }
  public set timeoutSec(value: number) {
    this._timeoutSec = value;
  }
  public resetTimeoutSec() {
    this._timeoutSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutSecInput() {
    return this._timeoutSec;
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // use_round_robin_dns - computed: true, optional: true, required: false
  private _useRoundRobinDns?: boolean | cdktf.IResolvable; 
  public get useRoundRobinDns() {
    return this.getBooleanAttribute('use_round_robin_dns');
  }
  public set useRoundRobinDns(value: boolean | cdktf.IResolvable) {
    this._useRoundRobinDns = value;
  }
  public resetUseRoundRobinDns() {
    this._useRoundRobinDns = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get useRoundRobinDnsInput() {
    return this._useRoundRobinDns;
  }
}
export interface DestinationOutputHumioHecExtraHttpHeaders {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#name Destination#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#value Destination#value}
  */
  readonly value: string;
}

export function destinationOutputHumioHecExtraHttpHeadersToTerraform(struct?: DestinationOutputHumioHecExtraHttpHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function destinationOutputHumioHecExtraHttpHeadersToHclTerraform(struct?: DestinationOutputHumioHecExtraHttpHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputHumioHecExtraHttpHeadersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DestinationOutputHumioHecExtraHttpHeaders | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputHumioHecExtraHttpHeaders | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DestinationOutputHumioHecExtraHttpHeadersList extends cdktf.ComplexList {
  public internalValue? : DestinationOutputHumioHecExtraHttpHeaders[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DestinationOutputHumioHecExtraHttpHeadersOutputReference {
    return new DestinationOutputHumioHecExtraHttpHeadersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DestinationOutputHumioHecPqControls {
}

export function destinationOutputHumioHecPqControlsToTerraform(struct?: DestinationOutputHumioHecPqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
  }
}


export function destinationOutputHumioHecPqControlsToHclTerraform(struct?: DestinationOutputHumioHecPqControls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
  };
  return attrs;
}

export class DestinationOutputHumioHecPqControlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DestinationOutputHumioHecPqControls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputHumioHecPqControls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
    }
  }
}
export interface DestinationOutputHumioHecResponseRetrySettings {
  /**
  * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc. Default: 2
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#backoff_rate Destination#backoff_rate}
  */
  readonly backoffRate?: number;
  /**
  * The HTTP response status code that will trigger retries
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#http_status Destination#http_status}
  */
  readonly httpStatus: number;
  /**
  * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes). Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#initial_backoff Destination#initial_backoff}
  */
  readonly initialBackoff?: number;
  /**
  * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds). Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#max_backoff Destination#max_backoff}
  */
  readonly maxBackoff?: number;
}

export function destinationOutputHumioHecResponseRetrySettingsToTerraform(struct?: DestinationOutputHumioHecResponseRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    backoff_rate: cdktf.numberToTerraform(struct!.backoffRate),
    http_status: cdktf.numberToTerraform(struct!.httpStatus),
    initial_backoff: cdktf.numberToTerraform(struct!.initialBackoff),
    max_backoff: cdktf.numberToTerraform(struct!.maxBackoff),
  }
}


export function destinationOutputHumioHecResponseRetrySettingsToHclTerraform(struct?: DestinationOutputHumioHecResponseRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    backoff_rate: {
      value: cdktf.numberToHclTerraform(struct!.backoffRate),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    http_status: {
      value: cdktf.numberToHclTerraform(struct!.httpStatus),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    initial_backoff: {
      value: cdktf.numberToHclTerraform(struct!.initialBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_backoff: {
      value: cdktf.numberToHclTerraform(struct!.maxBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputHumioHecResponseRetrySettingsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DestinationOutputHumioHecResponseRetrySettings | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._backoffRate !== undefined) {
      hasAnyValues = true;
      internalValueResult.backoffRate = this._backoffRate;
    }
    if (this._httpStatus !== undefined) {
      hasAnyValues = true;
      internalValueResult.httpStatus = this._httpStatus;
    }
    if (this._initialBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.initialBackoff = this._initialBackoff;
    }
    if (this._maxBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBackoff = this._maxBackoff;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputHumioHecResponseRetrySettings | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._backoffRate = undefined;
      this._httpStatus = undefined;
      this._initialBackoff = undefined;
      this._maxBackoff = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._backoffRate = value.backoffRate;
      this._httpStatus = value.httpStatus;
      this._initialBackoff = value.initialBackoff;
      this._maxBackoff = value.maxBackoff;
    }
  }

  // backoff_rate - computed: true, optional: true, required: false
  private _backoffRate?: number; 
  public get backoffRate() {
    return this.getNumberAttribute('backoff_rate');
  }
  public set backoffRate(value: number) {
    this._backoffRate = value;
  }
  public resetBackoffRate() {
    this._backoffRate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get backoffRateInput() {
    return this._backoffRate;
  }

  // http_status - computed: false, optional: false, required: true
  private _httpStatus?: number; 
  public get httpStatus() {
    return this.getNumberAttribute('http_status');
  }
  public set httpStatus(value: number) {
    this._httpStatus = value;
  }
  // Temporarily expose input value. Use with caution.
  public get httpStatusInput() {
    return this._httpStatus;
  }

  // initial_backoff - computed: true, optional: true, required: false
  private _initialBackoff?: number; 
  public get initialBackoff() {
    return this.getNumberAttribute('initial_backoff');
  }
  public set initialBackoff(value: number) {
    this._initialBackoff = value;
  }
  public resetInitialBackoff() {
    this._initialBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get initialBackoffInput() {
    return this._initialBackoff;
  }

  // max_backoff - computed: true, optional: true, required: false
  private _maxBackoff?: number; 
  public get maxBackoff() {
    return this.getNumberAttribute('max_backoff');
  }
  public set maxBackoff(value: number) {
    this._maxBackoff = value;
  }
  public resetMaxBackoff() {
    this._maxBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBackoffInput() {
    return this._maxBackoff;
  }
}

export class DestinationOutputHumioHecResponseRetrySettingsList extends cdktf.ComplexList {
  public internalValue? : DestinationOutputHumioHecResponseRetrySettings[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DestinationOutputHumioHecResponseRetrySettingsOutputReference {
    return new DestinationOutputHumioHecResponseRetrySettingsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DestinationOutputHumioHecTimeoutRetrySettings {
  /**
  * Base for exponential backoff. A value of 2 (default) means Cribl Stream will retry after 2 seconds, then 4 seconds, then 8 seconds, etc. Default: 2
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#backoff_rate Destination#backoff_rate}
  */
  readonly backoffRate?: number;
  /**
  * How long, in milliseconds, Cribl Stream should wait before initiating backoff. Maximum interval is 600,000 ms (10 minutes). Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#initial_backoff Destination#initial_backoff}
  */
  readonly initialBackoff?: number;
  /**
  * The maximum backoff interval, in milliseconds, Cribl Stream should apply. Default (and minimum) is 10,000 ms (10 seconds); maximum is 180,000 ms (180 seconds). Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#max_backoff Destination#max_backoff}
  */
  readonly maxBackoff?: number;
  /**
  * Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#timeout_retry Destination#timeout_retry}
  */
  readonly timeoutRetry?: boolean | cdktf.IResolvable;
}

export function destinationOutputHumioHecTimeoutRetrySettingsToTerraform(struct?: DestinationOutputHumioHecTimeoutRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    backoff_rate: cdktf.numberToTerraform(struct!.backoffRate),
    initial_backoff: cdktf.numberToTerraform(struct!.initialBackoff),
    max_backoff: cdktf.numberToTerraform(struct!.maxBackoff),
    timeout_retry: cdktf.booleanToTerraform(struct!.timeoutRetry),
  }
}


export function destinationOutputHumioHecTimeoutRetrySettingsToHclTerraform(struct?: DestinationOutputHumioHecTimeoutRetrySettings | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    backoff_rate: {
      value: cdktf.numberToHclTerraform(struct!.backoffRate),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    initial_backoff: {
      value: cdktf.numberToHclTerraform(struct!.initialBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_backoff: {
      value: cdktf.numberToHclTerraform(struct!.maxBackoff),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    timeout_retry: {
      value: cdktf.booleanToHclTerraform(struct!.timeoutRetry),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputHumioHecTimeoutRetrySettingsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DestinationOutputHumioHecTimeoutRetrySettings | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._backoffRate !== undefined) {
      hasAnyValues = true;
      internalValueResult.backoffRate = this._backoffRate;
    }
    if (this._initialBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.initialBackoff = this._initialBackoff;
    }
    if (this._maxBackoff !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBackoff = this._maxBackoff;
    }
    if (this._timeoutRetry !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutRetry = this._timeoutRetry;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputHumioHecTimeoutRetrySettings | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._backoffRate = undefined;
      this._initialBackoff = undefined;
      this._maxBackoff = undefined;
      this._timeoutRetry = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._backoffRate = value.backoffRate;
      this._initialBackoff = value.initialBackoff;
      this._maxBackoff = value.maxBackoff;
      this._timeoutRetry = value.timeoutRetry;
    }
  }

  // backoff_rate - computed: true, optional: true, required: false
  private _backoffRate?: number; 
  public get backoffRate() {
    return this.getNumberAttribute('backoff_rate');
  }
  public set backoffRate(value: number) {
    this._backoffRate = value;
  }
  public resetBackoffRate() {
    this._backoffRate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get backoffRateInput() {
    return this._backoffRate;
  }

  // initial_backoff - computed: true, optional: true, required: false
  private _initialBackoff?: number; 
  public get initialBackoff() {
    return this.getNumberAttribute('initial_backoff');
  }
  public set initialBackoff(value: number) {
    this._initialBackoff = value;
  }
  public resetInitialBackoff() {
    this._initialBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get initialBackoffInput() {
    return this._initialBackoff;
  }

  // max_backoff - computed: true, optional: true, required: false
  private _maxBackoff?: number; 
  public get maxBackoff() {
    return this.getNumberAttribute('max_backoff');
  }
  public set maxBackoff(value: number) {
    this._maxBackoff = value;
  }
  public resetMaxBackoff() {
    this._maxBackoff = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBackoffInput() {
    return this._maxBackoff;
  }

  // timeout_retry - computed: true, optional: true, required: false
  private _timeoutRetry?: boolean | cdktf.IResolvable; 
  public get timeoutRetry() {
    return this.getBooleanAttribute('timeout_retry');
  }
  public set timeoutRetry(value: boolean | cdktf.IResolvable) {
    this._timeoutRetry = value;
  }
  public resetTimeoutRetry() {
    this._timeoutRetry = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutRetryInput() {
    return this._timeoutRetry;
  }
}
export interface DestinationOutputHumioHec {
  /**
  * Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate. Default: "manual"; must be one of ["manual", "secret"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#auth_type Destination#auth_type}
  */
  readonly authType?: string;
  /**
  * Compress the payload body before sending. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#compress Destination#compress}
  */
  readonly compress?: boolean | cdktf.IResolvable;
  /**
  * Maximum number of ongoing requests before blocking. Default: 5
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#concurrency Destination#concurrency}
  */
  readonly concurrency?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#description Destination#description}
  */
  readonly description?: string;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#environment Destination#environment}
  */
  readonly environment?: string;
  /**
  * Headers to add to all events
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#extra_http_headers Destination#extra_http_headers}
  */
  readonly extraHttpHeaders?: DestinationOutputHumioHecExtraHttpHeaders[] | cdktf.IResolvable;
  /**
  * Data to log when a request fails. All headers are redacted by default, unless listed as safe headers below. Default: "none"; must be one of ["payload", "payloadAndHeaders", "none"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#failed_request_logging_mode Destination#failed_request_logging_mode}
  */
  readonly failedRequestLoggingMode?: string;
  /**
  * Maximum time between requests. Small values could cause the payload size to be smaller than the configured Body size limit. Default: 1
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#flush_period_sec Destination#flush_period_sec}
  */
  readonly flushPeriodSec?: number;
  /**
  * When set to JSON, the event is automatically formatted with required fields before sending. When set to Raw, only the event's `_raw` value is sent. Default: "JSON"; must be one of ["JSON", "raw"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#format Destination#format}
  */
  readonly format?: string;
  /**
  * Unique ID for this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#id Destination#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * Maximum number of events to include in the request body. Default is 0 (unlimited). Default: 0
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#max_payload_events Destination#max_payload_events}
  */
  readonly maxPayloadEvents?: number;
  /**
  * Maximum size, in KB, of the request body. Default: 4096
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#max_payload_size_kb Destination#max_payload_size_kb}
  */
  readonly maxPayloadSizeKb?: number;
  /**
  * How to handle events when all receivers are exerting backpressure. Default: "block"; must be one of ["block", "drop", "queue"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#on_backpressure Destination#on_backpressure}
  */
  readonly onBackpressure?: string;
  /**
  * Pipeline to process data before sending out to this output
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pipeline Destination#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pq_compress Destination#pq_compress}
  */
  readonly pqCompress?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pq_controls Destination#pq_controls}
  */
  readonly pqControls?: DestinationOutputHumioHecPqControls;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing (KB, MB, etc.). Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pq_max_file_size Destination#pq_max_file_size}
  */
  readonly pqMaxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pq_max_size Destination#pq_max_size}
  */
  readonly pqMaxSize?: string;
  /**
  * In Error mode, PQ writes events to the filesystem if the Destination is unavailable. In Backpressure mode, PQ writes events to the filesystem when it detects backpressure from the Destination. In Always On mode, PQ always writes events to the filesystem. Default: "error"; must be one of ["error", "backpressure", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pq_mode Destination#pq_mode}
  */
  readonly pqMode?: string;
  /**
  * How to handle events when the queue is exerting backpressure (full capacity or low disk). 'Block' is the same behavior as non-PQ blocking. 'Drop new data' throws away incoming data, while leaving the contents of the PQ unchanged. Default: "block"; must be one of ["block", "drop"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pq_on_backpressure Destination#pq_on_backpressure}
  */
  readonly pqOnBackpressure?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/<output-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#pq_path Destination#pq_path}
  */
  readonly pqPath?: string;
  /**
  * Reject certificates not authorized by a CA in the CA certificate path or by another trusted CA (such as the system's). 
  *         Enabled by default. When this setting is also present in TLS Settings (Client Side), 
  *         that value will take precedence.
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#reject_unauthorized Destination#reject_unauthorized}
  */
  readonly rejectUnauthorized?: boolean | cdktf.IResolvable;
  /**
  * Honor any Retry-After header that specifies a delay (in seconds) no longer than 180 seconds after the retry request. @{product} limits the delay to 180 seconds, even if the Retry-After header specifies a longer delay. When enabled, takes precedence over user-configured retry options. When disabled, all Retry-After headers are ignored. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#response_honor_retry_after_header Destination#response_honor_retry_after_header}
  */
  readonly responseHonorRetryAfterHeader?: boolean | cdktf.IResolvable;
  /**
  * Automatically retry after unsuccessful response status codes, such as 429 (Too Many Requests) or 503 (Service Unavailable)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#response_retry_settings Destination#response_retry_settings}
  */
  readonly responseRetrySettings?: DestinationOutputHumioHecResponseRetrySettings[] | cdktf.IResolvable;
  /**
  * List of headers that are safe to log in plain text. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#safe_headers Destination#safe_headers}
  */
  readonly safeHeaders?: string[];
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#streamtags Destination#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Fields to automatically add to events, such as cribl_pipe. Supports wildcards. Default: ["cribl_pipe"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#system_fields Destination#system_fields}
  */
  readonly systemFields?: string[];
  /**
  * Select or create a stored text secret
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#text_secret Destination#text_secret}
  */
  readonly textSecret?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#timeout_retry_settings Destination#timeout_retry_settings}
  */
  readonly timeoutRetrySettings?: DestinationOutputHumioHecTimeoutRetrySettings;
  /**
  * Amount of time, in seconds, to wait for a request to complete before canceling it. Default: 30
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#timeout_sec Destination#timeout_sec}
  */
  readonly timeoutSec?: number;
  /**
  * CrowdStrike Falcon LogScale authentication token
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#token Destination#token}
  */
  readonly token?: string;
  /**
  * must be "humio_hec"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#type Destination#type}
  */
  readonly type?: string;
  /**
  * URL to a CrowdStrike Falcon LogScale endpoint to send events to. Examples: https://cloud.us.humio.com/api/v1/ingest/hec for JSON and https://cloud.us.humio.com/api/v1/ingest/hec/raw for raw. Default: "https://cloud.us.humio.com/api/v1/ingest/hec"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#url Destination#url}
  */
  readonly url?: string;
  /**
  * Enable round-robin DNS lookup. When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. For optimal performance, consider enabling this setting for non-load balanced destinations. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#use_round_robin_dns Destination#use_round_robin_dns}
  */
  readonly useRoundRobinDns?: boolean | cdktf.IResolvable;
}

export function destinationOutputHumioHecToTerraform(struct?: DestinationOutputHumioHec | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    auth_type: cdktf.stringToTerraform(struct!.authType),
    compress: cdktf.booleanToTerraform(struct!.compress),
    concurrency: cdktf.numberToTerraform(struct!.concurrency),
    description: cdktf.stringToTerraform(struct!.description),
    environment: cdktf.stringToTerraform(struct!.environment),
    extra_http_headers: cdktf.listMapper(destinationOutputHumioHecExtraHttpHeadersToTerraform, false)(struct!.extraHttpHeaders),
    failed_request_logging_mode: cdktf.stringToTerraform(struct!.failedRequestLoggingMode),
    flush_period_sec: cdktf.numberToTerraform(struct!.flushPeriodSec),
    format: cdktf.stringToTerraform(struct!.format),
    id: cdktf.stringToTerraform(struct!.id),
    max_payload_events: cdktf.numberToTerraform(struct!.maxPayloadEvents),
    max_payload_size_kb: cdktf.numberToTerraform(struct!.maxPayloadSizeKb),
    on_backpressure: cdktf.stringToTerraform(struct!.onBackpressure),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    pq_compress: cdktf.stringToTerraform(struct!.pqCompress),
    pq_controls: destinationOutputHumioHecPqControlsToTerraform(struct!.pqControls),
    pq_max_file_size: cdktf.stringToTerraform(struct!.pqMaxFileSize),
    pq_max_size: cdktf.stringToTerraform(struct!.pqMaxSize),
    pq_mode: cdktf.stringToTerraform(struct!.pqMode),
    pq_on_backpressure: cdktf.stringToTerraform(struct!.pqOnBackpressure),
    pq_path: cdktf.stringToTerraform(struct!.pqPath),
    reject_unauthorized: cdktf.booleanToTerraform(struct!.rejectUnauthorized),
    response_honor_retry_after_header: cdktf.booleanToTerraform(struct!.responseHonorRetryAfterHeader),
    response_retry_settings: cdktf.listMapper(destinationOutputHumioHecResponseRetrySettingsToTerraform, false)(struct!.responseRetrySettings),
    safe_headers: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.safeHeaders),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    system_fields: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.systemFields),
    text_secret: cdktf.stringToTerraform(struct!.textSecret),
    timeout_retry_settings: destinationOutputHumioHecTimeoutRetrySettingsToTerraform(struct!.timeoutRetrySettings),
    timeout_sec: cdktf.numberToTerraform(struct!.timeoutSec),
    token: cdktf.stringToTerraform(struct!.token),
    type: cdktf.stringToTerraform(struct!.type),
    url: cdktf.stringToTerraform(struct!.url),
    use_round_robin_dns: cdktf.booleanToTerraform(struct!.useRoundRobinDns),
  }
}


export function destinationOutputHumioHecToHclTerraform(struct?: DestinationOutputHumioHec | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    auth_type: {
      value: cdktf.stringToHclTerraform(struct!.authType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    compress: {
      value: cdktf.booleanToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    concurrency: {
      value: cdktf.numberToHclTerraform(struct!.concurrency),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    extra_http_headers: {
      value: cdktf.listMapperHcl(destinationOutputHumioHecExtraHttpHeadersToHclTerraform, false)(struct!.extraHttpHeaders),
      isBlock: true,
      type: "list",
      storageClassType: "DestinationOutputHumioHecExtraHttpHeadersList",
    },
    failed_request_logging_mode: {
      value: cdktf.stringToHclTerraform(struct!.failedRequestLoggingMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    flush_period_sec: {
      value: cdktf.numberToHclTerraform(struct!.flushPeriodSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    format: {
      value: cdktf.stringToHclTerraform(struct!.format),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_payload_events: {
      value: cdktf.numberToHclTerraform(struct!.maxPayloadEvents),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_payload_size_kb: {
      value: cdktf.numberToHclTerraform(struct!.maxPayloadSizeKb),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.onBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_compress: {
      value: cdktf.stringToHclTerraform(struct!.pqCompress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_controls: {
      value: destinationOutputHumioHecPqControlsToHclTerraform(struct!.pqControls),
      isBlock: true,
      type: "struct",
      storageClassType: "DestinationOutputHumioHecPqControls",
    },
    pq_max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_max_size: {
      value: cdktf.stringToHclTerraform(struct!.pqMaxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_mode: {
      value: cdktf.stringToHclTerraform(struct!.pqMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_on_backpressure: {
      value: cdktf.stringToHclTerraform(struct!.pqOnBackpressure),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq_path: {
      value: cdktf.stringToHclTerraform(struct!.pqPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reject_unauthorized: {
      value: cdktf.booleanToHclTerraform(struct!.rejectUnauthorized),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    response_honor_retry_after_header: {
      value: cdktf.booleanToHclTerraform(struct!.responseHonorRetryAfterHeader),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    response_retry_settings: {
      value: cdktf.listMapperHcl(destinationOutputHumioHecResponseRetrySettingsToHclTerraform, false)(struct!.responseRetrySettings),
      isBlock: true,
      type: "list",
      storageClassType: "DestinationOutputHumioHecResponseRetrySettingsList",
    },
    safe_headers: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.safeHeaders),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    system_fields: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.systemFields),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    text_secret: {
      value: cdktf.stringToHclTerraform(struct!.textSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    timeout_retry_settings: {
      value: destinationOutputHumioHecTimeoutRetrySettingsToHclTerraform(struct!.timeoutRetrySettings),
      isBlock: true,
      type: "struct",
      storageClassType: "DestinationOutputHumioHecTimeoutRetrySettings",
    },
    timeout_sec: {
      value: cdktf.numberToHclTerraform(struct!.timeoutSec),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    token: {
      value: cdktf.stringToHclTerraform(struct!.token),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    url: {
      value: cdktf.stringToHclTerraform(struct!.url),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    use_round_robin_dns: {
      value: cdktf.booleanToHclTerraform(struct!.useRoundRobinDns),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputHumioHecOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): DestinationOutputHumioHec | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._authType !== undefined) {
      hasAnyValues = true;
      internalValueResult.authType = this._authType;
    }
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._concurrency !== undefined) {
      hasAnyValues = true;
      internalValueResult.concurrency = this._concurrency;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._extraHttpHeaders?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.extraHttpHeaders = this._extraHttpHeaders?.internalValue;
    }
    if (this._failedRequestLoggingMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.failedRequestLoggingMode = this._failedRequestLoggingMode;
    }
    if (this._flushPeriodSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.flushPeriodSec = this._flushPeriodSec;
    }
    if (this._format !== undefined) {
      hasAnyValues = true;
      internalValueResult.format = this._format;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._maxPayloadEvents !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxPayloadEvents = this._maxPayloadEvents;
    }
    if (this._maxPayloadSizeKb !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxPayloadSizeKb = this._maxPayloadSizeKb;
    }
    if (this._onBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.onBackpressure = this._onBackpressure;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._pqCompress !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqCompress = this._pqCompress;
    }
    if (this._pqControls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqControls = this._pqControls?.internalValue;
    }
    if (this._pqMaxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxFileSize = this._pqMaxFileSize;
    }
    if (this._pqMaxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMaxSize = this._pqMaxSize;
    }
    if (this._pqMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqMode = this._pqMode;
    }
    if (this._pqOnBackpressure !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqOnBackpressure = this._pqOnBackpressure;
    }
    if (this._pqPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqPath = this._pqPath;
    }
    if (this._rejectUnauthorized !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectUnauthorized = this._rejectUnauthorized;
    }
    if (this._responseHonorRetryAfterHeader !== undefined) {
      hasAnyValues = true;
      internalValueResult.responseHonorRetryAfterHeader = this._responseHonorRetryAfterHeader;
    }
    if (this._responseRetrySettings?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.responseRetrySettings = this._responseRetrySettings?.internalValue;
    }
    if (this._safeHeaders !== undefined) {
      hasAnyValues = true;
      internalValueResult.safeHeaders = this._safeHeaders;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._systemFields !== undefined) {
      hasAnyValues = true;
      internalValueResult.systemFields = this._systemFields;
    }
    if (this._textSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.textSecret = this._textSecret;
    }
    if (this._timeoutRetrySettings?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutRetrySettings = this._timeoutRetrySettings?.internalValue;
    }
    if (this._timeoutSec !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeoutSec = this._timeoutSec;
    }
    if (this._token !== undefined) {
      hasAnyValues = true;
      internalValueResult.token = this._token;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._url !== undefined) {
      hasAnyValues = true;
      internalValueResult.url = this._url;
    }
    if (this._useRoundRobinDns !== undefined) {
      hasAnyValues = true;
      internalValueResult.useRoundRobinDns = this._useRoundRobinDns;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputHumioHec | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._authType = undefined;
      this._compress = undefined;
      this._concurrency = undefined;
      this._description = undefined;
      this._environment = undefined;
      this._extraHttpHeaders.internalValue = undefined;
      this._failedRequestLoggingMode = undefined;
      this._flushPeriodSec = undefined;
      this._format = undefined;
      this._id = undefined;
      this._maxPayloadEvents = undefined;
      this._maxPayloadSizeKb = undefined;
      this._onBackpressure = undefined;
      this._pipeline = undefined;
      this._pqCompress = undefined;
      this._pqControls.internalValue = undefined;
      this._pqMaxFileSize = undefined;
      this._pqMaxSize = undefined;
      this._pqMode = undefined;
      this._pqOnBackpressure = undefined;
      this._pqPath = undefined;
      this._rejectUnauthorized = undefined;
      this._responseHonorRetryAfterHeader = undefined;
      this._responseRetrySettings.internalValue = undefined;
      this._safeHeaders = undefined;
      this._streamtags = undefined;
      this._systemFields = undefined;
      this._textSecret = undefined;
      this._timeoutRetrySettings.internalValue = undefined;
      this._timeoutSec = undefined;
      this._token = undefined;
      this._type = undefined;
      this._url = undefined;
      this._useRoundRobinDns = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._authType = value.authType;
      this._compress = value.compress;
      this._concurrency = value.concurrency;
      this._description = value.description;
      this._environment = value.environment;
      this._extraHttpHeaders.internalValue = value.extraHttpHeaders;
      this._failedRequestLoggingMode = value.failedRequestLoggingMode;
      this._flushPeriodSec = value.flushPeriodSec;
      this._format = value.format;
      this._id = value.id;
      this._maxPayloadEvents = value.maxPayloadEvents;
      this._maxPayloadSizeKb = value.maxPayloadSizeKb;
      this._onBackpressure = value.onBackpressure;
      this._pipeline = value.pipeline;
      this._pqCompress = value.pqCompress;
      this._pqControls.internalValue = value.pqControls;
      this._pqMaxFileSize = value.pqMaxFileSize;
      this._pqMaxSize = value.pqMaxSize;
      this._pqMode = value.pqMode;
      this._pqOnBackpressure = value.pqOnBackpressure;
      this._pqPath = value.pqPath;
      this._rejectUnauthorized = value.rejectUnauthorized;
      this._responseHonorRetryAfterHeader = value.responseHonorRetryAfterHeader;
      this._responseRetrySettings.internalValue = value.responseRetrySettings;
      this._safeHeaders = value.safeHeaders;
      this._streamtags = value.streamtags;
      this._systemFields = value.systemFields;
      this._textSecret = value.textSecret;
      this._timeoutRetrySettings.internalValue = value.timeoutRetrySettings;
      this._timeoutSec = value.timeoutSec;
      this._token = value.token;
      this._type = value.type;
      this._url = value.url;
      this._useRoundRobinDns = value.useRoundRobinDns;
    }
  }

  // auth_type - computed: true, optional: true, required: false
  private _authType?: string; 
  public get authType() {
    return this.getStringAttribute('auth_type');
  }
  public set authType(value: string) {
    this._authType = value;
  }
  public resetAuthType() {
    this._authType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authTypeInput() {
    return this._authType;
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: boolean | cdktf.IResolvable; 
  public get compress() {
    return this.getBooleanAttribute('compress');
  }
  public set compress(value: boolean | cdktf.IResolvable) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // concurrency - computed: true, optional: true, required: false
  private _concurrency?: number; 
  public get concurrency() {
    return this.getNumberAttribute('concurrency');
  }
  public set concurrency(value: number) {
    this._concurrency = value;
  }
  public resetConcurrency() {
    this._concurrency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get concurrencyInput() {
    return this._concurrency;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // extra_http_headers - computed: false, optional: true, required: false
  private _extraHttpHeaders = new DestinationOutputHumioHecExtraHttpHeadersList(this, "extra_http_headers", false);
  public get extraHttpHeaders() {
    return this._extraHttpHeaders;
  }
  public putExtraHttpHeaders(value: DestinationOutputHumioHecExtraHttpHeaders[] | cdktf.IResolvable) {
    this._extraHttpHeaders.internalValue = value;
  }
  public resetExtraHttpHeaders() {
    this._extraHttpHeaders.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get extraHttpHeadersInput() {
    return this._extraHttpHeaders.internalValue;
  }

  // failed_request_logging_mode - computed: true, optional: true, required: false
  private _failedRequestLoggingMode?: string; 
  public get failedRequestLoggingMode() {
    return this.getStringAttribute('failed_request_logging_mode');
  }
  public set failedRequestLoggingMode(value: string) {
    this._failedRequestLoggingMode = value;
  }
  public resetFailedRequestLoggingMode() {
    this._failedRequestLoggingMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get failedRequestLoggingModeInput() {
    return this._failedRequestLoggingMode;
  }

  // flush_period_sec - computed: true, optional: true, required: false
  private _flushPeriodSec?: number; 
  public get flushPeriodSec() {
    return this.getNumberAttribute('flush_period_sec');
  }
  public set flushPeriodSec(value: number) {
    this._flushPeriodSec = value;
  }
  public resetFlushPeriodSec() {
    this._flushPeriodSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get flushPeriodSecInput() {
    return this._flushPeriodSec;
  }

  // format - computed: true, optional: true, required: false
  private _format?: string; 
  public get format() {
    return this.getStringAttribute('format');
  }
  public set format(value: string) {
    this._format = value;
  }
  public resetFormat() {
    this._format = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get formatInput() {
    return this._format;
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // max_payload_events - computed: true, optional: true, required: false
  private _maxPayloadEvents?: number; 
  public get maxPayloadEvents() {
    return this.getNumberAttribute('max_payload_events');
  }
  public set maxPayloadEvents(value: number) {
    this._maxPayloadEvents = value;
  }
  public resetMaxPayloadEvents() {
    this._maxPayloadEvents = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxPayloadEventsInput() {
    return this._maxPayloadEvents;
  }

  // max_payload_size_kb - computed: true, optional: true, required: false
  private _maxPayloadSizeKb?: number; 
  public get maxPayloadSizeKb() {
    return this.getNumberAttribute('max_payload_size_kb');
  }
  public set maxPayloadSizeKb(value: number) {
    this._maxPayloadSizeKb = value;
  }
  public resetMaxPayloadSizeKb() {
    this._maxPayloadSizeKb = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxPayloadSizeKbInput() {
    return this._maxPayloadSizeKb;
  }

  // on_backpressure - computed: true, optional: true, required: false
  private _onBackpressure?: string; 
  public get onBackpressure() {
    return this.getStringAttribute('on_backpressure');
  }
  public set onBackpressure(value: string) {
    this._onBackpressure = value;
  }
  public resetOnBackpressure() {
    this._onBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get onBackpressureInput() {
    return this._onBackpressure;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // pq_compress - computed: true, optional: true, required: false
  private _pqCompress?: string; 
  public get pqCompress() {
    return this.getStringAttribute('pq_compress');
  }
  public set pqCompress(value: string) {
    this._pqCompress = value;
  }
  public resetPqCompress() {
    this._pqCompress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqCompressInput() {
    return this._pqCompress;
  }

  // pq_controls - computed: false, optional: true, required: false
  private _pqControls = new DestinationOutputHumioHecPqControlsOutputReference(this, "pq_controls");
  public get pqControls() {
    return this._pqControls;
  }
  public putPqControls(value: DestinationOutputHumioHecPqControls) {
    this._pqControls.internalValue = value;
  }
  public resetPqControls() {
    this._pqControls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqControlsInput() {
    return this._pqControls.internalValue;
  }

  // pq_max_file_size - computed: true, optional: true, required: false
  private _pqMaxFileSize?: string; 
  public get pqMaxFileSize() {
    return this.getStringAttribute('pq_max_file_size');
  }
  public set pqMaxFileSize(value: string) {
    this._pqMaxFileSize = value;
  }
  public resetPqMaxFileSize() {
    this._pqMaxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxFileSizeInput() {
    return this._pqMaxFileSize;
  }

  // pq_max_size - computed: true, optional: true, required: false
  private _pqMaxSize?: string; 
  public get pqMaxSize() {
    return this.getStringAttribute('pq_max_size');
  }
  public set pqMaxSize(value: string) {
    this._pqMaxSize = value;
  }
  public resetPqMaxSize() {
    this._pqMaxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqMaxSizeInput() {
    return this._pqMaxSize;
  }

  // pq_mode - computed: true, optional: true, required: false
  private _pqMode?: string; 
  public get pqMode() {
    return this.getStringAttribute('pq_mode');
  }
  public set pqMode(value: string) {
    this._pqMode = value;
  }
  public resetPqMode() {
    this._pqMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqModeInput() {
    return this._pqMode;
  }

  // pq_on_backpressure - computed: true, optional: true, required: false
  private _pqOnBackpressure?: string; 
  public get pqOnBackpressure() {
    return this.getStringAttribute('pq_on_backpressure');
  }
  public set pqOnBackpressure(value: string) {
    this._pqOnBackpressure = value;
  }
  public resetPqOnBackpressure() {
    this._pqOnBackpressure = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqOnBackpressureInput() {
    return this._pqOnBackpressure;
  }

  // pq_path - computed: true, optional: true, required: false
  private _pqPath?: string; 
  public get pqPath() {
    return this.getStringAttribute('pq_path');
  }
  public set pqPath(value: string) {
    this._pqPath = value;
  }
  public resetPqPath() {
    this._pqPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqPathInput() {
    return this._pqPath;
  }

  // reject_unauthorized - computed: true, optional: true, required: false
  private _rejectUnauthorized?: boolean | cdktf.IResolvable; 
  public get rejectUnauthorized() {
    return this.getBooleanAttribute('reject_unauthorized');
  }
  public set rejectUnauthorized(value: boolean | cdktf.IResolvable) {
    this._rejectUnauthorized = value;
  }
  public resetRejectUnauthorized() {
    this._rejectUnauthorized = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectUnauthorizedInput() {
    return this._rejectUnauthorized;
  }

  // response_honor_retry_after_header - computed: true, optional: true, required: false
  private _responseHonorRetryAfterHeader?: boolean | cdktf.IResolvable; 
  public get responseHonorRetryAfterHeader() {
    return this.getBooleanAttribute('response_honor_retry_after_header');
  }
  public set responseHonorRetryAfterHeader(value: boolean | cdktf.IResolvable) {
    this._responseHonorRetryAfterHeader = value;
  }
  public resetResponseHonorRetryAfterHeader() {
    this._responseHonorRetryAfterHeader = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get responseHonorRetryAfterHeaderInput() {
    return this._responseHonorRetryAfterHeader;
  }

  // response_retry_settings - computed: false, optional: true, required: false
  private _responseRetrySettings = new DestinationOutputHumioHecResponseRetrySettingsList(this, "response_retry_settings", false);
  public get responseRetrySettings() {
    return this._responseRetrySettings;
  }
  public putResponseRetrySettings(value: DestinationOutputHumioHecResponseRetrySettings[] | cdktf.IResolvable) {
    this._responseRetrySettings.internalValue = value;
  }
  public resetResponseRetrySettings() {
    this._responseRetrySettings.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get responseRetrySettingsInput() {
    return this._responseRetrySettings.internalValue;
  }

  // safe_headers - computed: true, optional: true, required: false
  private _safeHeaders?: string[]; 
  public get safeHeaders() {
    return this.getListAttribute('safe_headers');
  }
  public set safeHeaders(value: string[]) {
    this._safeHeaders = value;
  }
  public resetSafeHeaders() {
    this._safeHeaders = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get safeHeadersInput() {
    return this._safeHeaders;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // system_fields - computed: true, optional: true, required: false
  private _systemFields?: string[]; 
  public get systemFields() {
    return this.getListAttribute('system_fields');
  }
  public set systemFields(value: string[]) {
    this._systemFields = value;
  }
  public resetSystemFields() {
    this._systemFields = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get systemFieldsInput() {
    return this._systemFields;
  }

  // text_secret - computed: false, optional: true, required: false
  private _textSecret?: string; 
  public get textSecret() {
    return this.getStringAttribute('text_secret');
  }
  public set textSecret(value: string) {
    this._textSecret = value;
  }
  public resetTextSecret() {
    this._textSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get textSecretInput() {
    return this._textSecret;
  }

  // timeout_retry_settings - computed: false, optional: true, required: false
  private _timeoutRetrySettings = new DestinationOutputHumioHecTimeoutRetrySettingsOutputReference(this, "timeout_retry_settings");
  public get timeoutRetrySettings() {
    return this._timeoutRetrySettings;
  }
  public putTimeoutRetrySettings(value: DestinationOutputHumioHecTimeoutRetrySettings) {
    this._timeoutRetrySettings.internalValue = value;
  }
  public resetTimeoutRetrySettings() {
    this._timeoutRetrySettings.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutRetrySettingsInput() {
    return this._timeoutRetrySettings.internalValue;
  }

  // timeout_sec - computed: true, optional: true, required: false
  private _timeoutSec?: number; 
  public get timeoutSec() {
    return this.getNumberAttribute('timeout_sec');
  }
  public set timeoutSec(value: number) {
    this._timeoutSec = value;
  }
  public resetTimeoutSec() {
    this._timeoutSec = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeoutSecInput() {
    return this._timeoutSec;
  }

  // token - computed: false, optional: true, required: false
  private _token?: string; 
  public get token() {
    return this.getStringAttribute('token');
  }
  public set token(value: string) {
    this._token = value;
  }
  public resetToken() {
    this._token = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tokenInput() {
    return this._token;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // url - computed: true, optional: true, required: false
  private _url?: string; 
  public get url() {
    return this.getStringAttribute('url');
  }
  public set url(value: string) {
    this._url = value;
  }
  public resetUrl() {
    this._url = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get urlInput() {
    return this._url;
  }

  // use_round_robin_dns - computed: true, optional: true, required: false
  private _useRoundRobinDns?: boolean | cdktf.IResolvable; 
  public get useRoundRobinDns() {
    return this.getBooleanAttribute('use_round_robin_dns');
  }
  public set useRoundRobinDns(value: boolean | cdktf.IResolvable) {
    this._useRoundRobinDns = value;
  }
  public resetUseRoundRobinDns() {
    this._useRoundRobinDns = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get useRoundRobinDnsInput() {
    return this._useRoundRobinDns;
  }
}
export interface DestinationOutputInfluxdbExtraHttpHeaders {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#name Destination#name}
  */
  readonly name?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#value Destination#value}
  */
  readonly value: string;
}

export function destinationOutputInfluxdbExtraHttpHeadersToTerraform(struct?: DestinationOutputInfluxdbExtraHttpHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function destinationOutputInfluxdbExtraHttpHeadersToHclTerraform(struct?: DestinationOutputInfluxdbExtraHttpHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputInfluxdbExtraHttpHeadersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DestinationOutputInfluxdbExtraHttpHeaders | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputInfluxdbExtraHttpHeaders | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: true, required: false
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  public resetName() {
    this._name = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DestinationOutputInfluxdbExtraHttpHeadersList extends cdktf.ComplexList {
  public internalValue? : DestinationOutputInfluxdbExtraHttpHeaders[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DestinationOutputInfluxdbExtraHttpHeadersOutputReference {
    return new DestinationOutputInfluxdbExtraHttpHeadersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface DestinationOutputInfluxdbOauthHeaders {
  /**
  * OAuth header name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#name Destination#name}
  */
  readonly name: string;
  /**
  * OAuth header value
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/destination#value Destination#value}
  */
  readonly value: string;
}

export function destinationOutputInfluxdbOauthHeadersToTerraform(struct?: DestinationOutputInfluxdbOauthHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function destinationOutputInfluxdbOauthHeadersToHclTerraform(struct?: DestinationOutputInfluxdbOauthHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class DestinationOutputInfluxdbOauthHeadersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): DestinationOutputInfluxdbOauthHeaders | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: DestinationOutputInfluxdbOauthHeaders | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class DestinationOutputInfluxdbOauthHeadersList extends cdktf.ComplexList {
  public internalValue? : DestinationOutputInfluxdbOauthHeaders[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): DestinationOutputInfluxdbOauthHeadersOutputReference {
    return new DestinationOutputInfluxdbOauthHeadersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
