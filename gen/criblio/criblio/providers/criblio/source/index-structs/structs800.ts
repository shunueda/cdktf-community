import * as cdktf from 'cdktf';
import { SourceInputSplunkAuthTokens,
sourceInputSplunkAuthTokensToTerraform,
sourceInputSplunkAuthTokensToHclTerraform,
SourceInputSplunkAuthTokensList,
SourceInputSplunkConnections,
sourceInputSplunkConnectionsToTerraform,
sourceInputSplunkConnectionsToHclTerraform,
SourceInputSplunkConnectionsList,
SourceInputSplunkMetadata,
sourceInputSplunkMetadataToTerraform,
sourceInputSplunkMetadataToHclTerraform,
SourceInputSplunkMetadataList } from './structs400'
export interface SourceInputSplunkPq {
  /**
  * The number of events to send downstream before committing that Stream has read them. Default: 42
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#commit_frequency Source#commit_frequency}
  */
  readonly commitFrequency?: number;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#compress Source#compress}
  */
  readonly compress?: string;
  /**
  * The maximum number of events to hold in memory before writing the events to disk. Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_buffer_size Source#max_buffer_size}
  */
  readonly maxBufferSize?: number;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc. Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_file_size Source#max_file_size}
  */
  readonly maxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_size Source#max_size}
  */
  readonly maxSize?: string;
  /**
  * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine. Default: "always"; must be one of ["smart", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#mode Source#mode}
  */
  readonly mode?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#path Source#path}
  */
  readonly path?: string;
}

export function sourceInputSplunkPqToTerraform(struct?: SourceInputSplunkPq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    commit_frequency: cdktf.numberToTerraform(struct!.commitFrequency),
    compress: cdktf.stringToTerraform(struct!.compress),
    max_buffer_size: cdktf.numberToTerraform(struct!.maxBufferSize),
    max_file_size: cdktf.stringToTerraform(struct!.maxFileSize),
    max_size: cdktf.stringToTerraform(struct!.maxSize),
    mode: cdktf.stringToTerraform(struct!.mode),
    path: cdktf.stringToTerraform(struct!.path),
  }
}


export function sourceInputSplunkPqToHclTerraform(struct?: SourceInputSplunkPq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    commit_frequency: {
      value: cdktf.numberToHclTerraform(struct!.commitFrequency),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    compress: {
      value: cdktf.stringToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_buffer_size: {
      value: cdktf.numberToHclTerraform(struct!.maxBufferSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.maxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_size: {
      value: cdktf.stringToHclTerraform(struct!.maxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputSplunkPqOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SourceInputSplunkPq | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._commitFrequency !== undefined) {
      hasAnyValues = true;
      internalValueResult.commitFrequency = this._commitFrequency;
    }
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._maxBufferSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBufferSize = this._maxBufferSize;
    }
    if (this._maxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxFileSize = this._maxFileSize;
    }
    if (this._maxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxSize = this._maxSize;
    }
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputSplunkPq | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._commitFrequency = undefined;
      this._compress = undefined;
      this._maxBufferSize = undefined;
      this._maxFileSize = undefined;
      this._maxSize = undefined;
      this._mode = undefined;
      this._path = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._commitFrequency = value.commitFrequency;
      this._compress = value.compress;
      this._maxBufferSize = value.maxBufferSize;
      this._maxFileSize = value.maxFileSize;
      this._maxSize = value.maxSize;
      this._mode = value.mode;
      this._path = value.path;
    }
  }

  // commit_frequency - computed: true, optional: true, required: false
  private _commitFrequency?: number; 
  public get commitFrequency() {
    return this.getNumberAttribute('commit_frequency');
  }
  public set commitFrequency(value: number) {
    this._commitFrequency = value;
  }
  public resetCommitFrequency() {
    this._commitFrequency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commitFrequencyInput() {
    return this._commitFrequency;
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: string; 
  public get compress() {
    return this.getStringAttribute('compress');
  }
  public set compress(value: string) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // max_buffer_size - computed: true, optional: true, required: false
  private _maxBufferSize?: number; 
  public get maxBufferSize() {
    return this.getNumberAttribute('max_buffer_size');
  }
  public set maxBufferSize(value: number) {
    this._maxBufferSize = value;
  }
  public resetMaxBufferSize() {
    this._maxBufferSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBufferSizeInput() {
    return this._maxBufferSize;
  }

  // max_file_size - computed: true, optional: true, required: false
  private _maxFileSize?: string; 
  public get maxFileSize() {
    return this.getStringAttribute('max_file_size');
  }
  public set maxFileSize(value: string) {
    this._maxFileSize = value;
  }
  public resetMaxFileSize() {
    this._maxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxFileSizeInput() {
    return this._maxFileSize;
  }

  // max_size - computed: true, optional: true, required: false
  private _maxSize?: string; 
  public get maxSize() {
    return this.getStringAttribute('max_size');
  }
  public set maxSize(value: string) {
    this._maxSize = value;
  }
  public resetMaxSize() {
    this._maxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxSizeInput() {
    return this._maxSize;
  }

  // mode - computed: true, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // path - computed: true, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }
}
export interface SourceInputSplunkTls {
  /**
  * Path on server containing CA certificates to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#ca_path Source#ca_path}
  */
  readonly caPath?: string;
  /**
  * Path on server containing certificates to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#cert_path Source#cert_path}
  */
  readonly certPath?: string;
  /**
  * The name of the predefined certificate
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#certificate_name Source#certificate_name}
  */
  readonly certificateName?: string;
  /**
  * Parsed as JSON.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#common_name_regex Source#common_name_regex}
  */
  readonly commonNameRegex?: string;
  /**
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#disabled Source#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_version Source#max_version}
  */
  readonly maxVersion?: string;
  /**
  * must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#min_version Source#min_version}
  */
  readonly minVersion?: string;
  /**
  * Passphrase to use to decrypt private key
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#passphrase Source#passphrase}
  */
  readonly passphrase?: string;
  /**
  * Path on server containing the private key to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#priv_key_path Source#priv_key_path}
  */
  readonly privKeyPath?: string;
  /**
  * Parsed as JSON.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#reject_unauthorized Source#reject_unauthorized}
  */
  readonly rejectUnauthorized?: string;
  /**
  * Require clients to present their certificates. Used to perform client authentication using SSL certs. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#request_cert Source#request_cert}
  */
  readonly requestCert?: boolean | cdktf.IResolvable;
}

export function sourceInputSplunkTlsToTerraform(struct?: SourceInputSplunkTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ca_path: cdktf.stringToTerraform(struct!.caPath),
    cert_path: cdktf.stringToTerraform(struct!.certPath),
    certificate_name: cdktf.stringToTerraform(struct!.certificateName),
    common_name_regex: cdktf.stringToTerraform(struct!.commonNameRegex),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    max_version: cdktf.stringToTerraform(struct!.maxVersion),
    min_version: cdktf.stringToTerraform(struct!.minVersion),
    passphrase: cdktf.stringToTerraform(struct!.passphrase),
    priv_key_path: cdktf.stringToTerraform(struct!.privKeyPath),
    reject_unauthorized: cdktf.stringToTerraform(struct!.rejectUnauthorized),
    request_cert: cdktf.booleanToTerraform(struct!.requestCert),
  }
}


export function sourceInputSplunkTlsToHclTerraform(struct?: SourceInputSplunkTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ca_path: {
      value: cdktf.stringToHclTerraform(struct!.caPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    cert_path: {
      value: cdktf.stringToHclTerraform(struct!.certPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    certificate_name: {
      value: cdktf.stringToHclTerraform(struct!.certificateName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    common_name_regex: {
      value: cdktf.stringToHclTerraform(struct!.commonNameRegex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    max_version: {
      value: cdktf.stringToHclTerraform(struct!.maxVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    min_version: {
      value: cdktf.stringToHclTerraform(struct!.minVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    passphrase: {
      value: cdktf.stringToHclTerraform(struct!.passphrase),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    priv_key_path: {
      value: cdktf.stringToHclTerraform(struct!.privKeyPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reject_unauthorized: {
      value: cdktf.stringToHclTerraform(struct!.rejectUnauthorized),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    request_cert: {
      value: cdktf.booleanToHclTerraform(struct!.requestCert),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputSplunkTlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SourceInputSplunkTls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._caPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.caPath = this._caPath;
    }
    if (this._certPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.certPath = this._certPath;
    }
    if (this._certificateName !== undefined) {
      hasAnyValues = true;
      internalValueResult.certificateName = this._certificateName;
    }
    if (this._commonNameRegex !== undefined) {
      hasAnyValues = true;
      internalValueResult.commonNameRegex = this._commonNameRegex;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._maxVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxVersion = this._maxVersion;
    }
    if (this._minVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.minVersion = this._minVersion;
    }
    if (this._passphrase !== undefined) {
      hasAnyValues = true;
      internalValueResult.passphrase = this._passphrase;
    }
    if (this._privKeyPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.privKeyPath = this._privKeyPath;
    }
    if (this._rejectUnauthorized !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectUnauthorized = this._rejectUnauthorized;
    }
    if (this._requestCert !== undefined) {
      hasAnyValues = true;
      internalValueResult.requestCert = this._requestCert;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputSplunkTls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._caPath = undefined;
      this._certPath = undefined;
      this._certificateName = undefined;
      this._commonNameRegex = undefined;
      this._disabled = undefined;
      this._maxVersion = undefined;
      this._minVersion = undefined;
      this._passphrase = undefined;
      this._privKeyPath = undefined;
      this._rejectUnauthorized = undefined;
      this._requestCert = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._caPath = value.caPath;
      this._certPath = value.certPath;
      this._certificateName = value.certificateName;
      this._commonNameRegex = value.commonNameRegex;
      this._disabled = value.disabled;
      this._maxVersion = value.maxVersion;
      this._minVersion = value.minVersion;
      this._passphrase = value.passphrase;
      this._privKeyPath = value.privKeyPath;
      this._rejectUnauthorized = value.rejectUnauthorized;
      this._requestCert = value.requestCert;
    }
  }

  // ca_path - computed: false, optional: true, required: false
  private _caPath?: string; 
  public get caPath() {
    return this.getStringAttribute('ca_path');
  }
  public set caPath(value: string) {
    this._caPath = value;
  }
  public resetCaPath() {
    this._caPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get caPathInput() {
    return this._caPath;
  }

  // cert_path - computed: false, optional: true, required: false
  private _certPath?: string; 
  public get certPath() {
    return this.getStringAttribute('cert_path');
  }
  public set certPath(value: string) {
    this._certPath = value;
  }
  public resetCertPath() {
    this._certPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certPathInput() {
    return this._certPath;
  }

  // certificate_name - computed: false, optional: true, required: false
  private _certificateName?: string; 
  public get certificateName() {
    return this.getStringAttribute('certificate_name');
  }
  public set certificateName(value: string) {
    this._certificateName = value;
  }
  public resetCertificateName() {
    this._certificateName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certificateNameInput() {
    return this._certificateName;
  }

  // common_name_regex - computed: false, optional: true, required: false
  private _commonNameRegex?: string; 
  public get commonNameRegex() {
    return this.getStringAttribute('common_name_regex');
  }
  public set commonNameRegex(value: string) {
    this._commonNameRegex = value;
  }
  public resetCommonNameRegex() {
    this._commonNameRegex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commonNameRegexInput() {
    return this._commonNameRegex;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // max_version - computed: false, optional: true, required: false
  private _maxVersion?: string; 
  public get maxVersion() {
    return this.getStringAttribute('max_version');
  }
  public set maxVersion(value: string) {
    this._maxVersion = value;
  }
  public resetMaxVersion() {
    this._maxVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxVersionInput() {
    return this._maxVersion;
  }

  // min_version - computed: false, optional: true, required: false
  private _minVersion?: string; 
  public get minVersion() {
    return this.getStringAttribute('min_version');
  }
  public set minVersion(value: string) {
    this._minVersion = value;
  }
  public resetMinVersion() {
    this._minVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get minVersionInput() {
    return this._minVersion;
  }

  // passphrase - computed: false, optional: true, required: false
  private _passphrase?: string; 
  public get passphrase() {
    return this.getStringAttribute('passphrase');
  }
  public set passphrase(value: string) {
    this._passphrase = value;
  }
  public resetPassphrase() {
    this._passphrase = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passphraseInput() {
    return this._passphrase;
  }

  // priv_key_path - computed: false, optional: true, required: false
  private _privKeyPath?: string; 
  public get privKeyPath() {
    return this.getStringAttribute('priv_key_path');
  }
  public set privKeyPath(value: string) {
    this._privKeyPath = value;
  }
  public resetPrivKeyPath() {
    this._privKeyPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get privKeyPathInput() {
    return this._privKeyPath;
  }

  // reject_unauthorized - computed: false, optional: true, required: false
  private _rejectUnauthorized?: string; 
  public get rejectUnauthorized() {
    return this.getStringAttribute('reject_unauthorized');
  }
  public set rejectUnauthorized(value: string) {
    this._rejectUnauthorized = value;
  }
  public resetRejectUnauthorized() {
    this._rejectUnauthorized = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectUnauthorizedInput() {
    return this._rejectUnauthorized;
  }

  // request_cert - computed: true, optional: true, required: false
  private _requestCert?: boolean | cdktf.IResolvable; 
  public get requestCert() {
    return this.getBooleanAttribute('request_cert');
  }
  public set requestCert(value: boolean | cdktf.IResolvable) {
    this._requestCert = value;
  }
  public resetRequestCert() {
    this._requestCert = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestCertInput() {
    return this._requestCert;
  }
}
export interface SourceInputSplunk {
  /**
  * Shared secrets to be provided by any Splunk forwarder. If empty, unauthorized access is permitted.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#auth_tokens Source#auth_tokens}
  */
  readonly authTokens?: SourceInputSplunkAuthTokens[] | cdktf.IResolvable;
  /**
  * A list of event-breaking rulesets that will be applied, in order, to the input data stream
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#breaker_rulesets Source#breaker_rulesets}
  */
  readonly breakerRulesets?: string[];
  /**
  * Controls whether to support reading compressed data from a forwarder. Select 'Automatic' to match the forwarder's configuration, or 'Disabled' to reject compressed connections. Default: "disabled"; must be one of ["disabled", "auto", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#compress Source#compress}
  */
  readonly compress?: string;
  /**
  * Direct connections to Destinations, and optionally via a Pipeline or a Pack
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#connections Source#connections}
  */
  readonly connections?: SourceInputSplunkConnections[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#description Source#description}
  */
  readonly description?: string;
  /**
  * Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#disabled Source#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * Drop Splunk control fields such as `crcSalt` and `_savedPort`. If disabled, control fields are stored in the internal field `__ctrlFields`. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#drop_control_fields Source#drop_control_fields}
  */
  readonly dropControlFields?: boolean | cdktf.IResolvable;
  /**
  * Enable if the connection is proxied by a device that supports proxy protocol v1 or v2. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#enable_proxy_header Source#enable_proxy_header}
  */
  readonly enableProxyHeader?: boolean | cdktf.IResolvable;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#environment Source#environment}
  */
  readonly environment?: string;
  /**
  * Extract and process Splunk-generated metrics as Cribl metrics. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#extract_metrics Source#extract_metrics}
  */
  readonly extractMetrics?: boolean | cdktf.IResolvable;
  /**
  * Address to bind on. Defaults to 0.0.0.0 (all addresses). Default: "0.0.0.0"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#host Source#host}
  */
  readonly host?: string;
  /**
  * Unique ID for this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#id Source#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * Regex matching IP addresses that are allowed to establish a connection. Default: "/.* /"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#ip_whitelist_regex Source#ip_whitelist_regex}
   *
  * Note: The above comment contained a comment block ending sequence (* followed by /). We have introduced a space between to prevent syntax errors. Please ignore the space.
  */
  readonly ipWhitelistRegex?: string;
  /**
  * Maximum number of active connections allowed per Worker Process. Use 0 for unlimited. Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_active_cxn Source#max_active_cxn}
  */
  readonly maxActiveCxn?: number;
  /**
  * The highest S2S protocol version to advertise during handshake. Default: "v3"; must be one of ["v3", "v4"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_s2_sversion Source#max_s2_sversion}
  */
  readonly maxS2Sversion?: string;
  /**
  * Fields to add to events from this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#metadata Source#metadata}
  */
  readonly metadata?: SourceInputSplunkMetadata[] | cdktf.IResolvable;
  /**
  * Pipeline to process data from this Source before sending it through the Routes
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#pipeline Source#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Port to listen on
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#port Source#port}
  */
  readonly port: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#pq Source#pq}
  */
  readonly pq?: SourceInputSplunkPq;
  /**
  * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers). Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#pq_enabled Source#pq_enabled}
  */
  readonly pqEnabled?: boolean | cdktf.IResolvable;
  /**
  * Select whether to send data to Routes, or directly to Destinations. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#send_to_routes Source#send_to_routes}
  */
  readonly sendToRoutes?: boolean | cdktf.IResolvable;
  /**
  * How long the server will wait after initiating a closure for a client to close its end of the connection. If the client doesn't close the connection within this time, the server will forcefully terminate the socket to prevent resource leaks and ensure efficient connection cleanup and system stability. Leave at 0 for no inactive socket monitoring. Default: 30
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#socket_ending_max_wait Source#socket_ending_max_wait}
  */
  readonly socketEndingMaxWait?: number;
  /**
  * How long @{product} should wait before assuming that an inactive socket has timed out. After this time, the connection will be closed. Leave at 0 for no inactive socket monitoring. Default: 0
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#socket_idle_timeout Source#socket_idle_timeout}
  */
  readonly socketIdleTimeout?: number;
  /**
  * The maximum duration a socket can remain open, even if active. This helps manage resources and mitigate issues caused by TCP pinning. Set to 0 to disable. Default: 0
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#socket_max_lifespan Source#socket_max_lifespan}
  */
  readonly socketMaxLifespan?: number;
  /**
  * How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines. Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#stale_channel_flush_ms Source#stale_channel_flush_ms}
  */
  readonly staleChannelFlushMs?: number;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#streamtags Source#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#tls Source#tls}
  */
  readonly tls?: SourceInputSplunkTls;
  /**
  * must be "splunk"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#type Source#type}
  */
  readonly type?: string;
  /**
  * Event Breakers will determine events' time zone from UF-provided metadata, when TZ can't be inferred from the raw event. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#use_fwd_timezone Source#use_fwd_timezone}
  */
  readonly useFwdTimezone?: boolean | cdktf.IResolvable;
}

export function sourceInputSplunkToTerraform(struct?: SourceInputSplunk | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    auth_tokens: cdktf.listMapper(sourceInputSplunkAuthTokensToTerraform, false)(struct!.authTokens),
    breaker_rulesets: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.breakerRulesets),
    compress: cdktf.stringToTerraform(struct!.compress),
    connections: cdktf.listMapper(sourceInputSplunkConnectionsToTerraform, false)(struct!.connections),
    description: cdktf.stringToTerraform(struct!.description),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    drop_control_fields: cdktf.booleanToTerraform(struct!.dropControlFields),
    enable_proxy_header: cdktf.booleanToTerraform(struct!.enableProxyHeader),
    environment: cdktf.stringToTerraform(struct!.environment),
    extract_metrics: cdktf.booleanToTerraform(struct!.extractMetrics),
    host: cdktf.stringToTerraform(struct!.host),
    id: cdktf.stringToTerraform(struct!.id),
    ip_whitelist_regex: cdktf.stringToTerraform(struct!.ipWhitelistRegex),
    max_active_cxn: cdktf.numberToTerraform(struct!.maxActiveCxn),
    max_s2_sversion: cdktf.stringToTerraform(struct!.maxS2Sversion),
    metadata: cdktf.listMapper(sourceInputSplunkMetadataToTerraform, false)(struct!.metadata),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    port: cdktf.numberToTerraform(struct!.port),
    pq: sourceInputSplunkPqToTerraform(struct!.pq),
    pq_enabled: cdktf.booleanToTerraform(struct!.pqEnabled),
    send_to_routes: cdktf.booleanToTerraform(struct!.sendToRoutes),
    socket_ending_max_wait: cdktf.numberToTerraform(struct!.socketEndingMaxWait),
    socket_idle_timeout: cdktf.numberToTerraform(struct!.socketIdleTimeout),
    socket_max_lifespan: cdktf.numberToTerraform(struct!.socketMaxLifespan),
    stale_channel_flush_ms: cdktf.numberToTerraform(struct!.staleChannelFlushMs),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    tls: sourceInputSplunkTlsToTerraform(struct!.tls),
    type: cdktf.stringToTerraform(struct!.type),
    use_fwd_timezone: cdktf.booleanToTerraform(struct!.useFwdTimezone),
  }
}


export function sourceInputSplunkToHclTerraform(struct?: SourceInputSplunk | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    auth_tokens: {
      value: cdktf.listMapperHcl(sourceInputSplunkAuthTokensToHclTerraform, false)(struct!.authTokens),
      isBlock: true,
      type: "list",
      storageClassType: "SourceInputSplunkAuthTokensList",
    },
    breaker_rulesets: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.breakerRulesets),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    compress: {
      value: cdktf.stringToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    connections: {
      value: cdktf.listMapperHcl(sourceInputSplunkConnectionsToHclTerraform, false)(struct!.connections),
      isBlock: true,
      type: "list",
      storageClassType: "SourceInputSplunkConnectionsList",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    drop_control_fields: {
      value: cdktf.booleanToHclTerraform(struct!.dropControlFields),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    enable_proxy_header: {
      value: cdktf.booleanToHclTerraform(struct!.enableProxyHeader),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    extract_metrics: {
      value: cdktf.booleanToHclTerraform(struct!.extractMetrics),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    host: {
      value: cdktf.stringToHclTerraform(struct!.host),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ip_whitelist_regex: {
      value: cdktf.stringToHclTerraform(struct!.ipWhitelistRegex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_active_cxn: {
      value: cdktf.numberToHclTerraform(struct!.maxActiveCxn),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_s2_sversion: {
      value: cdktf.stringToHclTerraform(struct!.maxS2Sversion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    metadata: {
      value: cdktf.listMapperHcl(sourceInputSplunkMetadataToHclTerraform, false)(struct!.metadata),
      isBlock: true,
      type: "list",
      storageClassType: "SourceInputSplunkMetadataList",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    pq: {
      value: sourceInputSplunkPqToHclTerraform(struct!.pq),
      isBlock: true,
      type: "struct",
      storageClassType: "SourceInputSplunkPq",
    },
    pq_enabled: {
      value: cdktf.booleanToHclTerraform(struct!.pqEnabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    send_to_routes: {
      value: cdktf.booleanToHclTerraform(struct!.sendToRoutes),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    socket_ending_max_wait: {
      value: cdktf.numberToHclTerraform(struct!.socketEndingMaxWait),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    socket_idle_timeout: {
      value: cdktf.numberToHclTerraform(struct!.socketIdleTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    socket_max_lifespan: {
      value: cdktf.numberToHclTerraform(struct!.socketMaxLifespan),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    stale_channel_flush_ms: {
      value: cdktf.numberToHclTerraform(struct!.staleChannelFlushMs),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    tls: {
      value: sourceInputSplunkTlsToHclTerraform(struct!.tls),
      isBlock: true,
      type: "struct",
      storageClassType: "SourceInputSplunkTls",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    use_fwd_timezone: {
      value: cdktf.booleanToHclTerraform(struct!.useFwdTimezone),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputSplunkOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SourceInputSplunk | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._authTokens?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.authTokens = this._authTokens?.internalValue;
    }
    if (this._breakerRulesets !== undefined) {
      hasAnyValues = true;
      internalValueResult.breakerRulesets = this._breakerRulesets;
    }
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._connections?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.connections = this._connections?.internalValue;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._dropControlFields !== undefined) {
      hasAnyValues = true;
      internalValueResult.dropControlFields = this._dropControlFields;
    }
    if (this._enableProxyHeader !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableProxyHeader = this._enableProxyHeader;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._extractMetrics !== undefined) {
      hasAnyValues = true;
      internalValueResult.extractMetrics = this._extractMetrics;
    }
    if (this._host !== undefined) {
      hasAnyValues = true;
      internalValueResult.host = this._host;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._ipWhitelistRegex !== undefined) {
      hasAnyValues = true;
      internalValueResult.ipWhitelistRegex = this._ipWhitelistRegex;
    }
    if (this._maxActiveCxn !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxActiveCxn = this._maxActiveCxn;
    }
    if (this._maxS2Sversion !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxS2Sversion = this._maxS2Sversion;
    }
    if (this._metadata?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadata = this._metadata?.internalValue;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._pq?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pq = this._pq?.internalValue;
    }
    if (this._pqEnabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqEnabled = this._pqEnabled;
    }
    if (this._sendToRoutes !== undefined) {
      hasAnyValues = true;
      internalValueResult.sendToRoutes = this._sendToRoutes;
    }
    if (this._socketEndingMaxWait !== undefined) {
      hasAnyValues = true;
      internalValueResult.socketEndingMaxWait = this._socketEndingMaxWait;
    }
    if (this._socketIdleTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.socketIdleTimeout = this._socketIdleTimeout;
    }
    if (this._socketMaxLifespan !== undefined) {
      hasAnyValues = true;
      internalValueResult.socketMaxLifespan = this._socketMaxLifespan;
    }
    if (this._staleChannelFlushMs !== undefined) {
      hasAnyValues = true;
      internalValueResult.staleChannelFlushMs = this._staleChannelFlushMs;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._tls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tls = this._tls?.internalValue;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._useFwdTimezone !== undefined) {
      hasAnyValues = true;
      internalValueResult.useFwdTimezone = this._useFwdTimezone;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputSplunk | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._authTokens.internalValue = undefined;
      this._breakerRulesets = undefined;
      this._compress = undefined;
      this._connections.internalValue = undefined;
      this._description = undefined;
      this._disabled = undefined;
      this._dropControlFields = undefined;
      this._enableProxyHeader = undefined;
      this._environment = undefined;
      this._extractMetrics = undefined;
      this._host = undefined;
      this._id = undefined;
      this._ipWhitelistRegex = undefined;
      this._maxActiveCxn = undefined;
      this._maxS2Sversion = undefined;
      this._metadata.internalValue = undefined;
      this._pipeline = undefined;
      this._port = undefined;
      this._pq.internalValue = undefined;
      this._pqEnabled = undefined;
      this._sendToRoutes = undefined;
      this._socketEndingMaxWait = undefined;
      this._socketIdleTimeout = undefined;
      this._socketMaxLifespan = undefined;
      this._staleChannelFlushMs = undefined;
      this._streamtags = undefined;
      this._tls.internalValue = undefined;
      this._type = undefined;
      this._useFwdTimezone = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._authTokens.internalValue = value.authTokens;
      this._breakerRulesets = value.breakerRulesets;
      this._compress = value.compress;
      this._connections.internalValue = value.connections;
      this._description = value.description;
      this._disabled = value.disabled;
      this._dropControlFields = value.dropControlFields;
      this._enableProxyHeader = value.enableProxyHeader;
      this._environment = value.environment;
      this._extractMetrics = value.extractMetrics;
      this._host = value.host;
      this._id = value.id;
      this._ipWhitelistRegex = value.ipWhitelistRegex;
      this._maxActiveCxn = value.maxActiveCxn;
      this._maxS2Sversion = value.maxS2Sversion;
      this._metadata.internalValue = value.metadata;
      this._pipeline = value.pipeline;
      this._port = value.port;
      this._pq.internalValue = value.pq;
      this._pqEnabled = value.pqEnabled;
      this._sendToRoutes = value.sendToRoutes;
      this._socketEndingMaxWait = value.socketEndingMaxWait;
      this._socketIdleTimeout = value.socketIdleTimeout;
      this._socketMaxLifespan = value.socketMaxLifespan;
      this._staleChannelFlushMs = value.staleChannelFlushMs;
      this._streamtags = value.streamtags;
      this._tls.internalValue = value.tls;
      this._type = value.type;
      this._useFwdTimezone = value.useFwdTimezone;
    }
  }

  // auth_tokens - computed: false, optional: true, required: false
  private _authTokens = new SourceInputSplunkAuthTokensList(this, "auth_tokens", false);
  public get authTokens() {
    return this._authTokens;
  }
  public putAuthTokens(value: SourceInputSplunkAuthTokens[] | cdktf.IResolvable) {
    this._authTokens.internalValue = value;
  }
  public resetAuthTokens() {
    this._authTokens.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authTokensInput() {
    return this._authTokens.internalValue;
  }

  // breaker_rulesets - computed: false, optional: true, required: false
  private _breakerRulesets?: string[]; 
  public get breakerRulesets() {
    return this.getListAttribute('breaker_rulesets');
  }
  public set breakerRulesets(value: string[]) {
    this._breakerRulesets = value;
  }
  public resetBreakerRulesets() {
    this._breakerRulesets = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get breakerRulesetsInput() {
    return this._breakerRulesets;
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: string; 
  public get compress() {
    return this.getStringAttribute('compress');
  }
  public set compress(value: string) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // connections - computed: false, optional: true, required: false
  private _connections = new SourceInputSplunkConnectionsList(this, "connections", false);
  public get connections() {
    return this._connections;
  }
  public putConnections(value: SourceInputSplunkConnections[] | cdktf.IResolvable) {
    this._connections.internalValue = value;
  }
  public resetConnections() {
    this._connections.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectionsInput() {
    return this._connections.internalValue;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // drop_control_fields - computed: true, optional: true, required: false
  private _dropControlFields?: boolean | cdktf.IResolvable; 
  public get dropControlFields() {
    return this.getBooleanAttribute('drop_control_fields');
  }
  public set dropControlFields(value: boolean | cdktf.IResolvable) {
    this._dropControlFields = value;
  }
  public resetDropControlFields() {
    this._dropControlFields = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dropControlFieldsInput() {
    return this._dropControlFields;
  }

  // enable_proxy_header - computed: true, optional: true, required: false
  private _enableProxyHeader?: boolean | cdktf.IResolvable; 
  public get enableProxyHeader() {
    return this.getBooleanAttribute('enable_proxy_header');
  }
  public set enableProxyHeader(value: boolean | cdktf.IResolvable) {
    this._enableProxyHeader = value;
  }
  public resetEnableProxyHeader() {
    this._enableProxyHeader = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableProxyHeaderInput() {
    return this._enableProxyHeader;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // extract_metrics - computed: true, optional: true, required: false
  private _extractMetrics?: boolean | cdktf.IResolvable; 
  public get extractMetrics() {
    return this.getBooleanAttribute('extract_metrics');
  }
  public set extractMetrics(value: boolean | cdktf.IResolvable) {
    this._extractMetrics = value;
  }
  public resetExtractMetrics() {
    this._extractMetrics = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get extractMetricsInput() {
    return this._extractMetrics;
  }

  // host - computed: true, optional: true, required: false
  private _host?: string; 
  public get host() {
    return this.getStringAttribute('host');
  }
  public set host(value: string) {
    this._host = value;
  }
  public resetHost() {
    this._host = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostInput() {
    return this._host;
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // ip_whitelist_regex - computed: true, optional: true, required: false
  private _ipWhitelistRegex?: string; 
  public get ipWhitelistRegex() {
    return this.getStringAttribute('ip_whitelist_regex');
  }
  public set ipWhitelistRegex(value: string) {
    this._ipWhitelistRegex = value;
  }
  public resetIpWhitelistRegex() {
    this._ipWhitelistRegex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ipWhitelistRegexInput() {
    return this._ipWhitelistRegex;
  }

  // max_active_cxn - computed: true, optional: true, required: false
  private _maxActiveCxn?: number; 
  public get maxActiveCxn() {
    return this.getNumberAttribute('max_active_cxn');
  }
  public set maxActiveCxn(value: number) {
    this._maxActiveCxn = value;
  }
  public resetMaxActiveCxn() {
    this._maxActiveCxn = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxActiveCxnInput() {
    return this._maxActiveCxn;
  }

  // max_s2_sversion - computed: true, optional: true, required: false
  private _maxS2Sversion?: string; 
  public get maxS2Sversion() {
    return this.getStringAttribute('max_s2_sversion');
  }
  public set maxS2Sversion(value: string) {
    this._maxS2Sversion = value;
  }
  public resetMaxS2Sversion() {
    this._maxS2Sversion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxS2SversionInput() {
    return this._maxS2Sversion;
  }

  // metadata - computed: false, optional: true, required: false
  private _metadata = new SourceInputSplunkMetadataList(this, "metadata", false);
  public get metadata() {
    return this._metadata;
  }
  public putMetadata(value: SourceInputSplunkMetadata[] | cdktf.IResolvable) {
    this._metadata.internalValue = value;
  }
  public resetMetadata() {
    this._metadata.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataInput() {
    return this._metadata.internalValue;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // port - computed: false, optional: false, required: true
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // pq - computed: false, optional: true, required: false
  private _pq = new SourceInputSplunkPqOutputReference(this, "pq");
  public get pq() {
    return this._pq;
  }
  public putPq(value: SourceInputSplunkPq) {
    this._pq.internalValue = value;
  }
  public resetPq() {
    this._pq.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqInput() {
    return this._pq.internalValue;
  }

  // pq_enabled - computed: true, optional: true, required: false
  private _pqEnabled?: boolean | cdktf.IResolvable; 
  public get pqEnabled() {
    return this.getBooleanAttribute('pq_enabled');
  }
  public set pqEnabled(value: boolean | cdktf.IResolvable) {
    this._pqEnabled = value;
  }
  public resetPqEnabled() {
    this._pqEnabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqEnabledInput() {
    return this._pqEnabled;
  }

  // send_to_routes - computed: true, optional: true, required: false
  private _sendToRoutes?: boolean | cdktf.IResolvable; 
  public get sendToRoutes() {
    return this.getBooleanAttribute('send_to_routes');
  }
  public set sendToRoutes(value: boolean | cdktf.IResolvable) {
    this._sendToRoutes = value;
  }
  public resetSendToRoutes() {
    this._sendToRoutes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sendToRoutesInput() {
    return this._sendToRoutes;
  }

  // socket_ending_max_wait - computed: true, optional: true, required: false
  private _socketEndingMaxWait?: number; 
  public get socketEndingMaxWait() {
    return this.getNumberAttribute('socket_ending_max_wait');
  }
  public set socketEndingMaxWait(value: number) {
    this._socketEndingMaxWait = value;
  }
  public resetSocketEndingMaxWait() {
    this._socketEndingMaxWait = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get socketEndingMaxWaitInput() {
    return this._socketEndingMaxWait;
  }

  // socket_idle_timeout - computed: true, optional: true, required: false
  private _socketIdleTimeout?: number; 
  public get socketIdleTimeout() {
    return this.getNumberAttribute('socket_idle_timeout');
  }
  public set socketIdleTimeout(value: number) {
    this._socketIdleTimeout = value;
  }
  public resetSocketIdleTimeout() {
    this._socketIdleTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get socketIdleTimeoutInput() {
    return this._socketIdleTimeout;
  }

  // socket_max_lifespan - computed: true, optional: true, required: false
  private _socketMaxLifespan?: number; 
  public get socketMaxLifespan() {
    return this.getNumberAttribute('socket_max_lifespan');
  }
  public set socketMaxLifespan(value: number) {
    this._socketMaxLifespan = value;
  }
  public resetSocketMaxLifespan() {
    this._socketMaxLifespan = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get socketMaxLifespanInput() {
    return this._socketMaxLifespan;
  }

  // stale_channel_flush_ms - computed: true, optional: true, required: false
  private _staleChannelFlushMs?: number; 
  public get staleChannelFlushMs() {
    return this.getNumberAttribute('stale_channel_flush_ms');
  }
  public set staleChannelFlushMs(value: number) {
    this._staleChannelFlushMs = value;
  }
  public resetStaleChannelFlushMs() {
    this._staleChannelFlushMs = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get staleChannelFlushMsInput() {
    return this._staleChannelFlushMs;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // tls - computed: false, optional: true, required: false
  private _tls = new SourceInputSplunkTlsOutputReference(this, "tls");
  public get tls() {
    return this._tls;
  }
  public putTls(value: SourceInputSplunkTls) {
    this._tls.internalValue = value;
  }
  public resetTls() {
    this._tls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsInput() {
    return this._tls.internalValue;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // use_fwd_timezone - computed: true, optional: true, required: false
  private _useFwdTimezone?: boolean | cdktf.IResolvable; 
  public get useFwdTimezone() {
    return this.getBooleanAttribute('use_fwd_timezone');
  }
  public set useFwdTimezone(value: boolean | cdktf.IResolvable) {
    this._useFwdTimezone = value;
  }
  public resetUseFwdTimezone() {
    this._useFwdTimezone = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get useFwdTimezoneInput() {
    return this._useFwdTimezone;
  }
}
export interface SourceInputSplunkHecAuthTokensMetadata {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#name Source#name}
  */
  readonly name: string;
  /**
  * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#value Source#value}
  */
  readonly value: string;
}

export function sourceInputSplunkHecAuthTokensMetadataToTerraform(struct?: SourceInputSplunkHecAuthTokensMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function sourceInputSplunkHecAuthTokensMetadataToHclTerraform(struct?: SourceInputSplunkHecAuthTokensMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputSplunkHecAuthTokensMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): SourceInputSplunkHecAuthTokensMetadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputSplunkHecAuthTokensMetadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class SourceInputSplunkHecAuthTokensMetadataList extends cdktf.ComplexList {
  public internalValue? : SourceInputSplunkHecAuthTokensMetadata[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): SourceInputSplunkHecAuthTokensMetadataOutputReference {
    return new SourceInputSplunkHecAuthTokensMetadataOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface SourceInputSplunkHecAuthTokens {
  /**
  * Enter the values you want to allow in the HEC event index field at the token level. Supports wildcards. To skip validation, leave blank.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#allowed_indexes_at_token Source#allowed_indexes_at_token}
  */
  readonly allowedIndexesAtToken?: string[];
  /**
  * Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate. Default: "manual"; must be one of ["manual", "secret"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#auth_type Source#auth_type}
  */
  readonly authType?: string;
  /**
  * Optional token description
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#description Source#description}
  */
  readonly description?: string;
  /**
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#enabled Source#enabled}
  */
  readonly enabled?: boolean | cdktf.IResolvable;
  /**
  * Fields to add to events referencing this token
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#metadata Source#metadata}
  */
  readonly metadata?: SourceInputSplunkHecAuthTokensMetadata[] | cdktf.IResolvable;
  /**
  * Parsed as JSON.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#token Source#token}
  */
  readonly token: string;
  /**
  * Parsed as JSON.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#token_secret Source#token_secret}
  */
  readonly tokenSecret?: string;
}

export function sourceInputSplunkHecAuthTokensToTerraform(struct?: SourceInputSplunkHecAuthTokens | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    allowed_indexes_at_token: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.allowedIndexesAtToken),
    auth_type: cdktf.stringToTerraform(struct!.authType),
    description: cdktf.stringToTerraform(struct!.description),
    enabled: cdktf.booleanToTerraform(struct!.enabled),
    metadata: cdktf.listMapper(sourceInputSplunkHecAuthTokensMetadataToTerraform, false)(struct!.metadata),
    token: cdktf.stringToTerraform(struct!.token),
    token_secret: cdktf.stringToTerraform(struct!.tokenSecret),
  }
}


export function sourceInputSplunkHecAuthTokensToHclTerraform(struct?: SourceInputSplunkHecAuthTokens | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    allowed_indexes_at_token: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.allowedIndexesAtToken),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    auth_type: {
      value: cdktf.stringToHclTerraform(struct!.authType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    enabled: {
      value: cdktf.booleanToHclTerraform(struct!.enabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    metadata: {
      value: cdktf.listMapperHcl(sourceInputSplunkHecAuthTokensMetadataToHclTerraform, false)(struct!.metadata),
      isBlock: true,
      type: "list",
      storageClassType: "SourceInputSplunkHecAuthTokensMetadataList",
    },
    token: {
      value: cdktf.stringToHclTerraform(struct!.token),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    token_secret: {
      value: cdktf.stringToHclTerraform(struct!.tokenSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputSplunkHecAuthTokensOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): SourceInputSplunkHecAuthTokens | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._allowedIndexesAtToken !== undefined) {
      hasAnyValues = true;
      internalValueResult.allowedIndexesAtToken = this._allowedIndexesAtToken;
    }
    if (this._authType !== undefined) {
      hasAnyValues = true;
      internalValueResult.authType = this._authType;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._enabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.enabled = this._enabled;
    }
    if (this._metadata?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadata = this._metadata?.internalValue;
    }
    if (this._token !== undefined) {
      hasAnyValues = true;
      internalValueResult.token = this._token;
    }
    if (this._tokenSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.tokenSecret = this._tokenSecret;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputSplunkHecAuthTokens | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._allowedIndexesAtToken = undefined;
      this._authType = undefined;
      this._description = undefined;
      this._enabled = undefined;
      this._metadata.internalValue = undefined;
      this._token = undefined;
      this._tokenSecret = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._allowedIndexesAtToken = value.allowedIndexesAtToken;
      this._authType = value.authType;
      this._description = value.description;
      this._enabled = value.enabled;
      this._metadata.internalValue = value.metadata;
      this._token = value.token;
      this._tokenSecret = value.tokenSecret;
    }
  }

  // allowed_indexes_at_token - computed: false, optional: true, required: false
  private _allowedIndexesAtToken?: string[]; 
  public get allowedIndexesAtToken() {
    return this.getListAttribute('allowed_indexes_at_token');
  }
  public set allowedIndexesAtToken(value: string[]) {
    this._allowedIndexesAtToken = value;
  }
  public resetAllowedIndexesAtToken() {
    this._allowedIndexesAtToken = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get allowedIndexesAtTokenInput() {
    return this._allowedIndexesAtToken;
  }

  // auth_type - computed: true, optional: true, required: false
  private _authType?: string; 
  public get authType() {
    return this.getStringAttribute('auth_type');
  }
  public set authType(value: string) {
    this._authType = value;
  }
  public resetAuthType() {
    this._authType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authTypeInput() {
    return this._authType;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // enabled - computed: true, optional: true, required: false
  private _enabled?: boolean | cdktf.IResolvable; 
  public get enabled() {
    return this.getBooleanAttribute('enabled');
  }
  public set enabled(value: boolean | cdktf.IResolvable) {
    this._enabled = value;
  }
  public resetEnabled() {
    this._enabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enabledInput() {
    return this._enabled;
  }

  // metadata - computed: false, optional: true, required: false
  private _metadata = new SourceInputSplunkHecAuthTokensMetadataList(this, "metadata", false);
  public get metadata() {
    return this._metadata;
  }
  public putMetadata(value: SourceInputSplunkHecAuthTokensMetadata[] | cdktf.IResolvable) {
    this._metadata.internalValue = value;
  }
  public resetMetadata() {
    this._metadata.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataInput() {
    return this._metadata.internalValue;
  }

  // token - computed: false, optional: false, required: true
  private _token?: string; 
  public get token() {
    return this.getStringAttribute('token');
  }
  public set token(value: string) {
    this._token = value;
  }
  // Temporarily expose input value. Use with caution.
  public get tokenInput() {
    return this._token;
  }

  // token_secret - computed: false, optional: true, required: false
  private _tokenSecret?: string; 
  public get tokenSecret() {
    return this.getStringAttribute('token_secret');
  }
  public set tokenSecret(value: string) {
    this._tokenSecret = value;
  }
  public resetTokenSecret() {
    this._tokenSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tokenSecretInput() {
    return this._tokenSecret;
  }
}

export class SourceInputSplunkHecAuthTokensList extends cdktf.ComplexList {
  public internalValue? : SourceInputSplunkHecAuthTokens[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): SourceInputSplunkHecAuthTokensOutputReference {
    return new SourceInputSplunkHecAuthTokensOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface SourceInputSplunkHecConnections {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#output Source#output}
  */
  readonly output: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#pipeline Source#pipeline}
  */
  readonly pipeline?: string;
}

export function sourceInputSplunkHecConnectionsToTerraform(struct?: SourceInputSplunkHecConnections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    output: cdktf.stringToTerraform(struct!.output),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
  }
}


export function sourceInputSplunkHecConnectionsToHclTerraform(struct?: SourceInputSplunkHecConnections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    output: {
      value: cdktf.stringToHclTerraform(struct!.output),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputSplunkHecConnectionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): SourceInputSplunkHecConnections | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._output !== undefined) {
      hasAnyValues = true;
      internalValueResult.output = this._output;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputSplunkHecConnections | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._output = undefined;
      this._pipeline = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._output = value.output;
      this._pipeline = value.pipeline;
    }
  }

  // output - computed: false, optional: false, required: true
  private _output?: string; 
  public get output() {
    return this.getStringAttribute('output');
  }
  public set output(value: string) {
    this._output = value;
  }
  // Temporarily expose input value. Use with caution.
  public get outputInput() {
    return this._output;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }
}

export class SourceInputSplunkHecConnectionsList extends cdktf.ComplexList {
  public internalValue? : SourceInputSplunkHecConnections[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): SourceInputSplunkHecConnectionsOutputReference {
    return new SourceInputSplunkHecConnectionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface SourceInputSplunkHecMetadata {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#name Source#name}
  */
  readonly name: string;
  /**
  * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#value Source#value}
  */
  readonly value: string;
}

export function sourceInputSplunkHecMetadataToTerraform(struct?: SourceInputSplunkHecMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function sourceInputSplunkHecMetadataToHclTerraform(struct?: SourceInputSplunkHecMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputSplunkHecMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): SourceInputSplunkHecMetadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputSplunkHecMetadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class SourceInputSplunkHecMetadataList extends cdktf.ComplexList {
  public internalValue? : SourceInputSplunkHecMetadata[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): SourceInputSplunkHecMetadataOutputReference {
    return new SourceInputSplunkHecMetadataOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface SourceInputSplunkHecPq {
  /**
  * The number of events to send downstream before committing that Stream has read them. Default: 42
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#commit_frequency Source#commit_frequency}
  */
  readonly commitFrequency?: number;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#compress Source#compress}
  */
  readonly compress?: string;
  /**
  * The maximum number of events to hold in memory before writing the events to disk. Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_buffer_size Source#max_buffer_size}
  */
  readonly maxBufferSize?: number;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc. Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_file_size Source#max_file_size}
  */
  readonly maxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_size Source#max_size}
  */
  readonly maxSize?: string;
  /**
  * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine. Default: "always"; must be one of ["smart", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#mode Source#mode}
  */
  readonly mode?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#path Source#path}
  */
  readonly path?: string;
}

export function sourceInputSplunkHecPqToTerraform(struct?: SourceInputSplunkHecPq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    commit_frequency: cdktf.numberToTerraform(struct!.commitFrequency),
    compress: cdktf.stringToTerraform(struct!.compress),
    max_buffer_size: cdktf.numberToTerraform(struct!.maxBufferSize),
    max_file_size: cdktf.stringToTerraform(struct!.maxFileSize),
    max_size: cdktf.stringToTerraform(struct!.maxSize),
    mode: cdktf.stringToTerraform(struct!.mode),
    path: cdktf.stringToTerraform(struct!.path),
  }
}


export function sourceInputSplunkHecPqToHclTerraform(struct?: SourceInputSplunkHecPq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    commit_frequency: {
      value: cdktf.numberToHclTerraform(struct!.commitFrequency),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    compress: {
      value: cdktf.stringToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_buffer_size: {
      value: cdktf.numberToHclTerraform(struct!.maxBufferSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.maxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_size: {
      value: cdktf.stringToHclTerraform(struct!.maxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputSplunkHecPqOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SourceInputSplunkHecPq | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._commitFrequency !== undefined) {
      hasAnyValues = true;
      internalValueResult.commitFrequency = this._commitFrequency;
    }
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._maxBufferSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBufferSize = this._maxBufferSize;
    }
    if (this._maxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxFileSize = this._maxFileSize;
    }
    if (this._maxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxSize = this._maxSize;
    }
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputSplunkHecPq | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._commitFrequency = undefined;
      this._compress = undefined;
      this._maxBufferSize = undefined;
      this._maxFileSize = undefined;
      this._maxSize = undefined;
      this._mode = undefined;
      this._path = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._commitFrequency = value.commitFrequency;
      this._compress = value.compress;
      this._maxBufferSize = value.maxBufferSize;
      this._maxFileSize = value.maxFileSize;
      this._maxSize = value.maxSize;
      this._mode = value.mode;
      this._path = value.path;
    }
  }

  // commit_frequency - computed: true, optional: true, required: false
  private _commitFrequency?: number; 
  public get commitFrequency() {
    return this.getNumberAttribute('commit_frequency');
  }
  public set commitFrequency(value: number) {
    this._commitFrequency = value;
  }
  public resetCommitFrequency() {
    this._commitFrequency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commitFrequencyInput() {
    return this._commitFrequency;
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: string; 
  public get compress() {
    return this.getStringAttribute('compress');
  }
  public set compress(value: string) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // max_buffer_size - computed: true, optional: true, required: false
  private _maxBufferSize?: number; 
  public get maxBufferSize() {
    return this.getNumberAttribute('max_buffer_size');
  }
  public set maxBufferSize(value: number) {
    this._maxBufferSize = value;
  }
  public resetMaxBufferSize() {
    this._maxBufferSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBufferSizeInput() {
    return this._maxBufferSize;
  }

  // max_file_size - computed: true, optional: true, required: false
  private _maxFileSize?: string; 
  public get maxFileSize() {
    return this.getStringAttribute('max_file_size');
  }
  public set maxFileSize(value: string) {
    this._maxFileSize = value;
  }
  public resetMaxFileSize() {
    this._maxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxFileSizeInput() {
    return this._maxFileSize;
  }

  // max_size - computed: true, optional: true, required: false
  private _maxSize?: string; 
  public get maxSize() {
    return this.getStringAttribute('max_size');
  }
  public set maxSize(value: string) {
    this._maxSize = value;
  }
  public resetMaxSize() {
    this._maxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxSizeInput() {
    return this._maxSize;
  }

  // mode - computed: true, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // path - computed: true, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }
}
export interface SourceInputSplunkHecTls {
  /**
  * Path on server containing CA certificates to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#ca_path Source#ca_path}
  */
  readonly caPath?: string;
  /**
  * Path on server containing certificates to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#cert_path Source#cert_path}
  */
  readonly certPath?: string;
  /**
  * The name of the predefined certificate
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#certificate_name Source#certificate_name}
  */
  readonly certificateName?: string;
  /**
  * Parsed as JSON.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#common_name_regex Source#common_name_regex}
  */
  readonly commonNameRegex?: string;
  /**
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#disabled Source#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_version Source#max_version}
  */
  readonly maxVersion?: string;
  /**
  * must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#min_version Source#min_version}
  */
  readonly minVersion?: string;
  /**
  * Passphrase to use to decrypt private key
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#passphrase Source#passphrase}
  */
  readonly passphrase?: string;
  /**
  * Path on server containing the private key to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#priv_key_path Source#priv_key_path}
  */
  readonly privKeyPath?: string;
  /**
  * Parsed as JSON.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#reject_unauthorized Source#reject_unauthorized}
  */
  readonly rejectUnauthorized?: string;
  /**
  * Require clients to present their certificates. Used to perform client authentication using SSL certs. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#request_cert Source#request_cert}
  */
  readonly requestCert?: boolean | cdktf.IResolvable;
}

export function sourceInputSplunkHecTlsToTerraform(struct?: SourceInputSplunkHecTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ca_path: cdktf.stringToTerraform(struct!.caPath),
    cert_path: cdktf.stringToTerraform(struct!.certPath),
    certificate_name: cdktf.stringToTerraform(struct!.certificateName),
    common_name_regex: cdktf.stringToTerraform(struct!.commonNameRegex),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    max_version: cdktf.stringToTerraform(struct!.maxVersion),
    min_version: cdktf.stringToTerraform(struct!.minVersion),
    passphrase: cdktf.stringToTerraform(struct!.passphrase),
    priv_key_path: cdktf.stringToTerraform(struct!.privKeyPath),
    reject_unauthorized: cdktf.stringToTerraform(struct!.rejectUnauthorized),
    request_cert: cdktf.booleanToTerraform(struct!.requestCert),
  }
}


export function sourceInputSplunkHecTlsToHclTerraform(struct?: SourceInputSplunkHecTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ca_path: {
      value: cdktf.stringToHclTerraform(struct!.caPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    cert_path: {
      value: cdktf.stringToHclTerraform(struct!.certPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    certificate_name: {
      value: cdktf.stringToHclTerraform(struct!.certificateName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    common_name_regex: {
      value: cdktf.stringToHclTerraform(struct!.commonNameRegex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    max_version: {
      value: cdktf.stringToHclTerraform(struct!.maxVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    min_version: {
      value: cdktf.stringToHclTerraform(struct!.minVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    passphrase: {
      value: cdktf.stringToHclTerraform(struct!.passphrase),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    priv_key_path: {
      value: cdktf.stringToHclTerraform(struct!.privKeyPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reject_unauthorized: {
      value: cdktf.stringToHclTerraform(struct!.rejectUnauthorized),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    request_cert: {
      value: cdktf.booleanToHclTerraform(struct!.requestCert),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputSplunkHecTlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SourceInputSplunkHecTls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._caPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.caPath = this._caPath;
    }
    if (this._certPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.certPath = this._certPath;
    }
    if (this._certificateName !== undefined) {
      hasAnyValues = true;
      internalValueResult.certificateName = this._certificateName;
    }
    if (this._commonNameRegex !== undefined) {
      hasAnyValues = true;
      internalValueResult.commonNameRegex = this._commonNameRegex;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._maxVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxVersion = this._maxVersion;
    }
    if (this._minVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.minVersion = this._minVersion;
    }
    if (this._passphrase !== undefined) {
      hasAnyValues = true;
      internalValueResult.passphrase = this._passphrase;
    }
    if (this._privKeyPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.privKeyPath = this._privKeyPath;
    }
    if (this._rejectUnauthorized !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectUnauthorized = this._rejectUnauthorized;
    }
    if (this._requestCert !== undefined) {
      hasAnyValues = true;
      internalValueResult.requestCert = this._requestCert;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputSplunkHecTls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._caPath = undefined;
      this._certPath = undefined;
      this._certificateName = undefined;
      this._commonNameRegex = undefined;
      this._disabled = undefined;
      this._maxVersion = undefined;
      this._minVersion = undefined;
      this._passphrase = undefined;
      this._privKeyPath = undefined;
      this._rejectUnauthorized = undefined;
      this._requestCert = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._caPath = value.caPath;
      this._certPath = value.certPath;
      this._certificateName = value.certificateName;
      this._commonNameRegex = value.commonNameRegex;
      this._disabled = value.disabled;
      this._maxVersion = value.maxVersion;
      this._minVersion = value.minVersion;
      this._passphrase = value.passphrase;
      this._privKeyPath = value.privKeyPath;
      this._rejectUnauthorized = value.rejectUnauthorized;
      this._requestCert = value.requestCert;
    }
  }

  // ca_path - computed: false, optional: true, required: false
  private _caPath?: string; 
  public get caPath() {
    return this.getStringAttribute('ca_path');
  }
  public set caPath(value: string) {
    this._caPath = value;
  }
  public resetCaPath() {
    this._caPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get caPathInput() {
    return this._caPath;
  }

  // cert_path - computed: false, optional: true, required: false
  private _certPath?: string; 
  public get certPath() {
    return this.getStringAttribute('cert_path');
  }
  public set certPath(value: string) {
    this._certPath = value;
  }
  public resetCertPath() {
    this._certPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certPathInput() {
    return this._certPath;
  }

  // certificate_name - computed: false, optional: true, required: false
  private _certificateName?: string; 
  public get certificateName() {
    return this.getStringAttribute('certificate_name');
  }
  public set certificateName(value: string) {
    this._certificateName = value;
  }
  public resetCertificateName() {
    this._certificateName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certificateNameInput() {
    return this._certificateName;
  }

  // common_name_regex - computed: false, optional: true, required: false
  private _commonNameRegex?: string; 
  public get commonNameRegex() {
    return this.getStringAttribute('common_name_regex');
  }
  public set commonNameRegex(value: string) {
    this._commonNameRegex = value;
  }
  public resetCommonNameRegex() {
    this._commonNameRegex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commonNameRegexInput() {
    return this._commonNameRegex;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // max_version - computed: false, optional: true, required: false
  private _maxVersion?: string; 
  public get maxVersion() {
    return this.getStringAttribute('max_version');
  }
  public set maxVersion(value: string) {
    this._maxVersion = value;
  }
  public resetMaxVersion() {
    this._maxVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxVersionInput() {
    return this._maxVersion;
  }

  // min_version - computed: false, optional: true, required: false
  private _minVersion?: string; 
  public get minVersion() {
    return this.getStringAttribute('min_version');
  }
  public set minVersion(value: string) {
    this._minVersion = value;
  }
  public resetMinVersion() {
    this._minVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get minVersionInput() {
    return this._minVersion;
  }

  // passphrase - computed: false, optional: true, required: false
  private _passphrase?: string; 
  public get passphrase() {
    return this.getStringAttribute('passphrase');
  }
  public set passphrase(value: string) {
    this._passphrase = value;
  }
  public resetPassphrase() {
    this._passphrase = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passphraseInput() {
    return this._passphrase;
  }

  // priv_key_path - computed: false, optional: true, required: false
  private _privKeyPath?: string; 
  public get privKeyPath() {
    return this.getStringAttribute('priv_key_path');
  }
  public set privKeyPath(value: string) {
    this._privKeyPath = value;
  }
  public resetPrivKeyPath() {
    this._privKeyPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get privKeyPathInput() {
    return this._privKeyPath;
  }

  // reject_unauthorized - computed: false, optional: true, required: false
  private _rejectUnauthorized?: string; 
  public get rejectUnauthorized() {
    return this.getStringAttribute('reject_unauthorized');
  }
  public set rejectUnauthorized(value: string) {
    this._rejectUnauthorized = value;
  }
  public resetRejectUnauthorized() {
    this._rejectUnauthorized = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectUnauthorizedInput() {
    return this._rejectUnauthorized;
  }

  // request_cert - computed: true, optional: true, required: false
  private _requestCert?: boolean | cdktf.IResolvable; 
  public get requestCert() {
    return this.getBooleanAttribute('request_cert');
  }
  public set requestCert(value: boolean | cdktf.IResolvable) {
    this._requestCert = value;
  }
  public resetRequestCert() {
    this._requestCert = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestCertInput() {
    return this._requestCert;
  }
}
export interface SourceInputSplunkHec {
  /**
  * Optionally, list HTTP headers that @{product} will send to allowed origins as "Access-Control-Allow-Headers" in a CORS preflight response. Use "*" to allow all headers.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#access_control_allow_headers Source#access_control_allow_headers}
  */
  readonly accessControlAllowHeaders?: string[];
  /**
  * Optionally, list HTTP origins to which @{product} should send CORS (cross-origin resource sharing) Access-Control-Allow-* headers. Supports wildcards.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#access_control_allow_origin Source#access_control_allow_origin}
  */
  readonly accessControlAllowOrigin?: string[];
  /**
  * How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc. Default: 100
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#activity_log_sample_rate Source#activity_log_sample_rate}
  */
  readonly activityLogSampleRate?: number;
  /**
  * List values allowed in HEC event index field. Leave blank to skip validation. Supports wildcards. The values here can expand index validation at the token level.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#allowed_indexes Source#allowed_indexes}
  */
  readonly allowedIndexes?: string[];
  /**
  * Shared secrets to be provided by any client (Authorization: <token>). If empty, unauthorized access is permitted.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#auth_tokens Source#auth_tokens}
  */
  readonly authTokens?: SourceInputSplunkHecAuthTokens[] | cdktf.IResolvable;
  /**
  * A list of event-breaking rulesets that will be applied, in order, to the input data stream
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#breaker_rulesets Source#breaker_rulesets}
  */
  readonly breakerRulesets?: string[];
  /**
  * Add request headers to events, in the __headers field. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#capture_headers Source#capture_headers}
  */
  readonly captureHeaders?: boolean | cdktf.IResolvable;
  /**
  * Direct connections to Destinations, and optionally via a Pipeline or a Pack
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#connections Source#connections}
  */
  readonly connections?: SourceInputSplunkHecConnections[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#description Source#description}
  */
  readonly description?: string;
  /**
  * Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#disabled Source#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * Drop Splunk control fields such as `crcSalt` and `_savedPort`. If disabled, control fields are stored in the internal field `__ctrlFields`. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#drop_control_fields Source#drop_control_fields}
  */
  readonly dropControlFields?: boolean | cdktf.IResolvable;
  /**
  * Emit per-token (<prefix>.http.perToken) and summary (<prefix>.http.summary) request metrics. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#emit_token_metrics Source#emit_token_metrics}
  */
  readonly emitTokenMetrics?: boolean | cdktf.IResolvable;
  /**
  * Parsed as JSON.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#enable_health_check Source#enable_health_check}
  */
  readonly enableHealthCheck?: string;
  /**
  * Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#enable_proxy_header Source#enable_proxy_header}
  */
  readonly enableProxyHeader?: boolean | cdktf.IResolvable;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#environment Source#environment}
  */
  readonly environment?: string;
  /**
  * Extract and process Splunk-generated metrics as Cribl metrics. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#extract_metrics Source#extract_metrics}
  */
  readonly extractMetrics?: boolean | cdktf.IResolvable;
  /**
  * Address to bind on. Defaults to 0.0.0.0 (all addresses). Default: "0.0.0.0"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#host Source#host}
  */
  readonly host?: string;
  /**
  * Unique ID for this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#id Source#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * Messages from matched IP addresses will be processed, unless also matched by the denylist. Default: "/.* /"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#ip_allowlist_regex Source#ip_allowlist_regex}
   *
  * Note: The above comment contained a comment block ending sequence (* followed by /). We have introduced a space between to prevent syntax errors. Please ignore the space.
  */
  readonly ipAllowlistRegex?: string;
  /**
  * Messages from matched IP addresses will be ignored. This takes precedence over the allowlist. Default: "/^$/"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#ip_denylist_regex Source#ip_denylist_regex}
  */
  readonly ipDenylistRegex?: string;
  /**
  * After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes). Default: 5
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#keep_alive_timeout Source#keep_alive_timeout}
  */
  readonly keepAliveTimeout?: number;
  /**
  * Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput. Default: 256
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_active_req Source#max_active_req}
  */
  readonly maxActiveReq?: number;
  /**
  * Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited). Default: 0
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_requests_per_socket Source#max_requests_per_socket}
  */
  readonly maxRequestsPerSocket?: number;
  /**
  * Fields to add to every event. Overrides fields added at the token or request level. See [the Source documentation](https://docs.cribl.io/stream/sources-splunk-hec/#fields) for more info.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#metadata Source#metadata}
  */
  readonly metadata?: SourceInputSplunkHecMetadata[] | cdktf.IResolvable;
  /**
  * Pipeline to process data from this Source before sending it through the Routes
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#pipeline Source#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Port to listen on
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#port Source#port}
  */
  readonly port: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#pq Source#pq}
  */
  readonly pq?: SourceInputSplunkHecPq;
  /**
  * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers). Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#pq_enabled Source#pq_enabled}
  */
  readonly pqEnabled?: boolean | cdktf.IResolvable;
  /**
  * How long to wait for an incoming request to complete before aborting it. Use 0 to disable. Default: 0
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#request_timeout Source#request_timeout}
  */
  readonly requestTimeout?: number;
  /**
  * Select whether to send data to Routes, or directly to Destinations. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#send_to_routes Source#send_to_routes}
  */
  readonly sendToRoutes?: boolean | cdktf.IResolvable;
  /**
  * How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0. Default: 0
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#socket_timeout Source#socket_timeout}
  */
  readonly socketTimeout?: number;
  /**
  * Enable Splunk HEC acknowledgements. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#splunk_hec_acks Source#splunk_hec_acks}
  */
  readonly splunkHecAcks?: boolean | cdktf.IResolvable;
  /**
  * Absolute path on which to listen for the Splunk HTTP Event Collector API requests. This input supports the /event, /raw and /s2s endpoints. Default: "/services/collector"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#splunk_hec_api Source#splunk_hec_api}
  */
  readonly splunkHecApi?: string;
  /**
  * How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines. Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#stale_channel_flush_ms Source#stale_channel_flush_ms}
  */
  readonly staleChannelFlushMs?: number;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#streamtags Source#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#tls Source#tls}
  */
  readonly tls?: SourceInputSplunkHecTls;
  /**
  * must be "splunk_hec"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#type Source#type}
  */
  readonly type?: string;
  /**
  * Event Breakers will determine events' time zone from UF-provided metadata, when TZ can't be inferred from the raw event. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#use_fwd_timezone Source#use_fwd_timezone}
  */
  readonly useFwdTimezone?: boolean | cdktf.IResolvable;
}

export function sourceInputSplunkHecToTerraform(struct?: SourceInputSplunkHec | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    access_control_allow_headers: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.accessControlAllowHeaders),
    access_control_allow_origin: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.accessControlAllowOrigin),
    activity_log_sample_rate: cdktf.numberToTerraform(struct!.activityLogSampleRate),
    allowed_indexes: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.allowedIndexes),
    auth_tokens: cdktf.listMapper(sourceInputSplunkHecAuthTokensToTerraform, false)(struct!.authTokens),
    breaker_rulesets: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.breakerRulesets),
    capture_headers: cdktf.booleanToTerraform(struct!.captureHeaders),
    connections: cdktf.listMapper(sourceInputSplunkHecConnectionsToTerraform, false)(struct!.connections),
    description: cdktf.stringToTerraform(struct!.description),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    drop_control_fields: cdktf.booleanToTerraform(struct!.dropControlFields),
    emit_token_metrics: cdktf.booleanToTerraform(struct!.emitTokenMetrics),
    enable_health_check: cdktf.stringToTerraform(struct!.enableHealthCheck),
    enable_proxy_header: cdktf.booleanToTerraform(struct!.enableProxyHeader),
    environment: cdktf.stringToTerraform(struct!.environment),
    extract_metrics: cdktf.booleanToTerraform(struct!.extractMetrics),
    host: cdktf.stringToTerraform(struct!.host),
    id: cdktf.stringToTerraform(struct!.id),
    ip_allowlist_regex: cdktf.stringToTerraform(struct!.ipAllowlistRegex),
    ip_denylist_regex: cdktf.stringToTerraform(struct!.ipDenylistRegex),
    keep_alive_timeout: cdktf.numberToTerraform(struct!.keepAliveTimeout),
    max_active_req: cdktf.numberToTerraform(struct!.maxActiveReq),
    max_requests_per_socket: cdktf.numberToTerraform(struct!.maxRequestsPerSocket),
    metadata: cdktf.listMapper(sourceInputSplunkHecMetadataToTerraform, false)(struct!.metadata),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    port: cdktf.numberToTerraform(struct!.port),
    pq: sourceInputSplunkHecPqToTerraform(struct!.pq),
    pq_enabled: cdktf.booleanToTerraform(struct!.pqEnabled),
    request_timeout: cdktf.numberToTerraform(struct!.requestTimeout),
    send_to_routes: cdktf.booleanToTerraform(struct!.sendToRoutes),
    socket_timeout: cdktf.numberToTerraform(struct!.socketTimeout),
    splunk_hec_acks: cdktf.booleanToTerraform(struct!.splunkHecAcks),
    splunk_hec_api: cdktf.stringToTerraform(struct!.splunkHecApi),
    stale_channel_flush_ms: cdktf.numberToTerraform(struct!.staleChannelFlushMs),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    tls: sourceInputSplunkHecTlsToTerraform(struct!.tls),
    type: cdktf.stringToTerraform(struct!.type),
    use_fwd_timezone: cdktf.booleanToTerraform(struct!.useFwdTimezone),
  }
}


export function sourceInputSplunkHecToHclTerraform(struct?: SourceInputSplunkHec | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    access_control_allow_headers: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.accessControlAllowHeaders),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    access_control_allow_origin: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.accessControlAllowOrigin),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    activity_log_sample_rate: {
      value: cdktf.numberToHclTerraform(struct!.activityLogSampleRate),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    allowed_indexes: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.allowedIndexes),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    auth_tokens: {
      value: cdktf.listMapperHcl(sourceInputSplunkHecAuthTokensToHclTerraform, false)(struct!.authTokens),
      isBlock: true,
      type: "list",
      storageClassType: "SourceInputSplunkHecAuthTokensList",
    },
    breaker_rulesets: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.breakerRulesets),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    capture_headers: {
      value: cdktf.booleanToHclTerraform(struct!.captureHeaders),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    connections: {
      value: cdktf.listMapperHcl(sourceInputSplunkHecConnectionsToHclTerraform, false)(struct!.connections),
      isBlock: true,
      type: "list",
      storageClassType: "SourceInputSplunkHecConnectionsList",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    drop_control_fields: {
      value: cdktf.booleanToHclTerraform(struct!.dropControlFields),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    emit_token_metrics: {
      value: cdktf.booleanToHclTerraform(struct!.emitTokenMetrics),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    enable_health_check: {
      value: cdktf.stringToHclTerraform(struct!.enableHealthCheck),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    enable_proxy_header: {
      value: cdktf.booleanToHclTerraform(struct!.enableProxyHeader),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    extract_metrics: {
      value: cdktf.booleanToHclTerraform(struct!.extractMetrics),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    host: {
      value: cdktf.stringToHclTerraform(struct!.host),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ip_allowlist_regex: {
      value: cdktf.stringToHclTerraform(struct!.ipAllowlistRegex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ip_denylist_regex: {
      value: cdktf.stringToHclTerraform(struct!.ipDenylistRegex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    keep_alive_timeout: {
      value: cdktf.numberToHclTerraform(struct!.keepAliveTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_active_req: {
      value: cdktf.numberToHclTerraform(struct!.maxActiveReq),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_requests_per_socket: {
      value: cdktf.numberToHclTerraform(struct!.maxRequestsPerSocket),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    metadata: {
      value: cdktf.listMapperHcl(sourceInputSplunkHecMetadataToHclTerraform, false)(struct!.metadata),
      isBlock: true,
      type: "list",
      storageClassType: "SourceInputSplunkHecMetadataList",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    pq: {
      value: sourceInputSplunkHecPqToHclTerraform(struct!.pq),
      isBlock: true,
      type: "struct",
      storageClassType: "SourceInputSplunkHecPq",
    },
    pq_enabled: {
      value: cdktf.booleanToHclTerraform(struct!.pqEnabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    request_timeout: {
      value: cdktf.numberToHclTerraform(struct!.requestTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    send_to_routes: {
      value: cdktf.booleanToHclTerraform(struct!.sendToRoutes),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    socket_timeout: {
      value: cdktf.numberToHclTerraform(struct!.socketTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    splunk_hec_acks: {
      value: cdktf.booleanToHclTerraform(struct!.splunkHecAcks),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    splunk_hec_api: {
      value: cdktf.stringToHclTerraform(struct!.splunkHecApi),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    stale_channel_flush_ms: {
      value: cdktf.numberToHclTerraform(struct!.staleChannelFlushMs),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    tls: {
      value: sourceInputSplunkHecTlsToHclTerraform(struct!.tls),
      isBlock: true,
      type: "struct",
      storageClassType: "SourceInputSplunkHecTls",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    use_fwd_timezone: {
      value: cdktf.booleanToHclTerraform(struct!.useFwdTimezone),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputSplunkHecOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SourceInputSplunkHec | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._accessControlAllowHeaders !== undefined) {
      hasAnyValues = true;
      internalValueResult.accessControlAllowHeaders = this._accessControlAllowHeaders;
    }
    if (this._accessControlAllowOrigin !== undefined) {
      hasAnyValues = true;
      internalValueResult.accessControlAllowOrigin = this._accessControlAllowOrigin;
    }
    if (this._activityLogSampleRate !== undefined) {
      hasAnyValues = true;
      internalValueResult.activityLogSampleRate = this._activityLogSampleRate;
    }
    if (this._allowedIndexes !== undefined) {
      hasAnyValues = true;
      internalValueResult.allowedIndexes = this._allowedIndexes;
    }
    if (this._authTokens?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.authTokens = this._authTokens?.internalValue;
    }
    if (this._breakerRulesets !== undefined) {
      hasAnyValues = true;
      internalValueResult.breakerRulesets = this._breakerRulesets;
    }
    if (this._captureHeaders !== undefined) {
      hasAnyValues = true;
      internalValueResult.captureHeaders = this._captureHeaders;
    }
    if (this._connections?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.connections = this._connections?.internalValue;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._dropControlFields !== undefined) {
      hasAnyValues = true;
      internalValueResult.dropControlFields = this._dropControlFields;
    }
    if (this._emitTokenMetrics !== undefined) {
      hasAnyValues = true;
      internalValueResult.emitTokenMetrics = this._emitTokenMetrics;
    }
    if (this._enableHealthCheck !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableHealthCheck = this._enableHealthCheck;
    }
    if (this._enableProxyHeader !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableProxyHeader = this._enableProxyHeader;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._extractMetrics !== undefined) {
      hasAnyValues = true;
      internalValueResult.extractMetrics = this._extractMetrics;
    }
    if (this._host !== undefined) {
      hasAnyValues = true;
      internalValueResult.host = this._host;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._ipAllowlistRegex !== undefined) {
      hasAnyValues = true;
      internalValueResult.ipAllowlistRegex = this._ipAllowlistRegex;
    }
    if (this._ipDenylistRegex !== undefined) {
      hasAnyValues = true;
      internalValueResult.ipDenylistRegex = this._ipDenylistRegex;
    }
    if (this._keepAliveTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.keepAliveTimeout = this._keepAliveTimeout;
    }
    if (this._maxActiveReq !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxActiveReq = this._maxActiveReq;
    }
    if (this._maxRequestsPerSocket !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxRequestsPerSocket = this._maxRequestsPerSocket;
    }
    if (this._metadata?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadata = this._metadata?.internalValue;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._pq?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pq = this._pq?.internalValue;
    }
    if (this._pqEnabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqEnabled = this._pqEnabled;
    }
    if (this._requestTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.requestTimeout = this._requestTimeout;
    }
    if (this._sendToRoutes !== undefined) {
      hasAnyValues = true;
      internalValueResult.sendToRoutes = this._sendToRoutes;
    }
    if (this._socketTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.socketTimeout = this._socketTimeout;
    }
    if (this._splunkHecAcks !== undefined) {
      hasAnyValues = true;
      internalValueResult.splunkHecAcks = this._splunkHecAcks;
    }
    if (this._splunkHecApi !== undefined) {
      hasAnyValues = true;
      internalValueResult.splunkHecApi = this._splunkHecApi;
    }
    if (this._staleChannelFlushMs !== undefined) {
      hasAnyValues = true;
      internalValueResult.staleChannelFlushMs = this._staleChannelFlushMs;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._tls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tls = this._tls?.internalValue;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._useFwdTimezone !== undefined) {
      hasAnyValues = true;
      internalValueResult.useFwdTimezone = this._useFwdTimezone;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputSplunkHec | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._accessControlAllowHeaders = undefined;
      this._accessControlAllowOrigin = undefined;
      this._activityLogSampleRate = undefined;
      this._allowedIndexes = undefined;
      this._authTokens.internalValue = undefined;
      this._breakerRulesets = undefined;
      this._captureHeaders = undefined;
      this._connections.internalValue = undefined;
      this._description = undefined;
      this._disabled = undefined;
      this._dropControlFields = undefined;
      this._emitTokenMetrics = undefined;
      this._enableHealthCheck = undefined;
      this._enableProxyHeader = undefined;
      this._environment = undefined;
      this._extractMetrics = undefined;
      this._host = undefined;
      this._id = undefined;
      this._ipAllowlistRegex = undefined;
      this._ipDenylistRegex = undefined;
      this._keepAliveTimeout = undefined;
      this._maxActiveReq = undefined;
      this._maxRequestsPerSocket = undefined;
      this._metadata.internalValue = undefined;
      this._pipeline = undefined;
      this._port = undefined;
      this._pq.internalValue = undefined;
      this._pqEnabled = undefined;
      this._requestTimeout = undefined;
      this._sendToRoutes = undefined;
      this._socketTimeout = undefined;
      this._splunkHecAcks = undefined;
      this._splunkHecApi = undefined;
      this._staleChannelFlushMs = undefined;
      this._streamtags = undefined;
      this._tls.internalValue = undefined;
      this._type = undefined;
      this._useFwdTimezone = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._accessControlAllowHeaders = value.accessControlAllowHeaders;
      this._accessControlAllowOrigin = value.accessControlAllowOrigin;
      this._activityLogSampleRate = value.activityLogSampleRate;
      this._allowedIndexes = value.allowedIndexes;
      this._authTokens.internalValue = value.authTokens;
      this._breakerRulesets = value.breakerRulesets;
      this._captureHeaders = value.captureHeaders;
      this._connections.internalValue = value.connections;
      this._description = value.description;
      this._disabled = value.disabled;
      this._dropControlFields = value.dropControlFields;
      this._emitTokenMetrics = value.emitTokenMetrics;
      this._enableHealthCheck = value.enableHealthCheck;
      this._enableProxyHeader = value.enableProxyHeader;
      this._environment = value.environment;
      this._extractMetrics = value.extractMetrics;
      this._host = value.host;
      this._id = value.id;
      this._ipAllowlistRegex = value.ipAllowlistRegex;
      this._ipDenylistRegex = value.ipDenylistRegex;
      this._keepAliveTimeout = value.keepAliveTimeout;
      this._maxActiveReq = value.maxActiveReq;
      this._maxRequestsPerSocket = value.maxRequestsPerSocket;
      this._metadata.internalValue = value.metadata;
      this._pipeline = value.pipeline;
      this._port = value.port;
      this._pq.internalValue = value.pq;
      this._pqEnabled = value.pqEnabled;
      this._requestTimeout = value.requestTimeout;
      this._sendToRoutes = value.sendToRoutes;
      this._socketTimeout = value.socketTimeout;
      this._splunkHecAcks = value.splunkHecAcks;
      this._splunkHecApi = value.splunkHecApi;
      this._staleChannelFlushMs = value.staleChannelFlushMs;
      this._streamtags = value.streamtags;
      this._tls.internalValue = value.tls;
      this._type = value.type;
      this._useFwdTimezone = value.useFwdTimezone;
    }
  }

  // access_control_allow_headers - computed: false, optional: true, required: false
  private _accessControlAllowHeaders?: string[]; 
  public get accessControlAllowHeaders() {
    return this.getListAttribute('access_control_allow_headers');
  }
  public set accessControlAllowHeaders(value: string[]) {
    this._accessControlAllowHeaders = value;
  }
  public resetAccessControlAllowHeaders() {
    this._accessControlAllowHeaders = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get accessControlAllowHeadersInput() {
    return this._accessControlAllowHeaders;
  }

  // access_control_allow_origin - computed: false, optional: true, required: false
  private _accessControlAllowOrigin?: string[]; 
  public get accessControlAllowOrigin() {
    return this.getListAttribute('access_control_allow_origin');
  }
  public set accessControlAllowOrigin(value: string[]) {
    this._accessControlAllowOrigin = value;
  }
  public resetAccessControlAllowOrigin() {
    this._accessControlAllowOrigin = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get accessControlAllowOriginInput() {
    return this._accessControlAllowOrigin;
  }

  // activity_log_sample_rate - computed: true, optional: true, required: false
  private _activityLogSampleRate?: number; 
  public get activityLogSampleRate() {
    return this.getNumberAttribute('activity_log_sample_rate');
  }
  public set activityLogSampleRate(value: number) {
    this._activityLogSampleRate = value;
  }
  public resetActivityLogSampleRate() {
    this._activityLogSampleRate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get activityLogSampleRateInput() {
    return this._activityLogSampleRate;
  }

  // allowed_indexes - computed: false, optional: true, required: false
  private _allowedIndexes?: string[]; 
  public get allowedIndexes() {
    return this.getListAttribute('allowed_indexes');
  }
  public set allowedIndexes(value: string[]) {
    this._allowedIndexes = value;
  }
  public resetAllowedIndexes() {
    this._allowedIndexes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get allowedIndexesInput() {
    return this._allowedIndexes;
  }

  // auth_tokens - computed: false, optional: true, required: false
  private _authTokens = new SourceInputSplunkHecAuthTokensList(this, "auth_tokens", false);
  public get authTokens() {
    return this._authTokens;
  }
  public putAuthTokens(value: SourceInputSplunkHecAuthTokens[] | cdktf.IResolvable) {
    this._authTokens.internalValue = value;
  }
  public resetAuthTokens() {
    this._authTokens.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authTokensInput() {
    return this._authTokens.internalValue;
  }

  // breaker_rulesets - computed: false, optional: true, required: false
  private _breakerRulesets?: string[]; 
  public get breakerRulesets() {
    return this.getListAttribute('breaker_rulesets');
  }
  public set breakerRulesets(value: string[]) {
    this._breakerRulesets = value;
  }
  public resetBreakerRulesets() {
    this._breakerRulesets = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get breakerRulesetsInput() {
    return this._breakerRulesets;
  }

  // capture_headers - computed: true, optional: true, required: false
  private _captureHeaders?: boolean | cdktf.IResolvable; 
  public get captureHeaders() {
    return this.getBooleanAttribute('capture_headers');
  }
  public set captureHeaders(value: boolean | cdktf.IResolvable) {
    this._captureHeaders = value;
  }
  public resetCaptureHeaders() {
    this._captureHeaders = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get captureHeadersInput() {
    return this._captureHeaders;
  }

  // connections - computed: false, optional: true, required: false
  private _connections = new SourceInputSplunkHecConnectionsList(this, "connections", false);
  public get connections() {
    return this._connections;
  }
  public putConnections(value: SourceInputSplunkHecConnections[] | cdktf.IResolvable) {
    this._connections.internalValue = value;
  }
  public resetConnections() {
    this._connections.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectionsInput() {
    return this._connections.internalValue;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // drop_control_fields - computed: true, optional: true, required: false
  private _dropControlFields?: boolean | cdktf.IResolvable; 
  public get dropControlFields() {
    return this.getBooleanAttribute('drop_control_fields');
  }
  public set dropControlFields(value: boolean | cdktf.IResolvable) {
    this._dropControlFields = value;
  }
  public resetDropControlFields() {
    this._dropControlFields = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dropControlFieldsInput() {
    return this._dropControlFields;
  }

  // emit_token_metrics - computed: true, optional: true, required: false
  private _emitTokenMetrics?: boolean | cdktf.IResolvable; 
  public get emitTokenMetrics() {
    return this.getBooleanAttribute('emit_token_metrics');
  }
  public set emitTokenMetrics(value: boolean | cdktf.IResolvable) {
    this._emitTokenMetrics = value;
  }
  public resetEmitTokenMetrics() {
    this._emitTokenMetrics = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get emitTokenMetricsInput() {
    return this._emitTokenMetrics;
  }

  // enable_health_check - computed: false, optional: true, required: false
  private _enableHealthCheck?: string; 
  public get enableHealthCheck() {
    return this.getStringAttribute('enable_health_check');
  }
  public set enableHealthCheck(value: string) {
    this._enableHealthCheck = value;
  }
  public resetEnableHealthCheck() {
    this._enableHealthCheck = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableHealthCheckInput() {
    return this._enableHealthCheck;
  }

  // enable_proxy_header - computed: true, optional: true, required: false
  private _enableProxyHeader?: boolean | cdktf.IResolvable; 
  public get enableProxyHeader() {
    return this.getBooleanAttribute('enable_proxy_header');
  }
  public set enableProxyHeader(value: boolean | cdktf.IResolvable) {
    this._enableProxyHeader = value;
  }
  public resetEnableProxyHeader() {
    this._enableProxyHeader = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableProxyHeaderInput() {
    return this._enableProxyHeader;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // extract_metrics - computed: true, optional: true, required: false
  private _extractMetrics?: boolean | cdktf.IResolvable; 
  public get extractMetrics() {
    return this.getBooleanAttribute('extract_metrics');
  }
  public set extractMetrics(value: boolean | cdktf.IResolvable) {
    this._extractMetrics = value;
  }
  public resetExtractMetrics() {
    this._extractMetrics = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get extractMetricsInput() {
    return this._extractMetrics;
  }

  // host - computed: true, optional: true, required: false
  private _host?: string; 
  public get host() {
    return this.getStringAttribute('host');
  }
  public set host(value: string) {
    this._host = value;
  }
  public resetHost() {
    this._host = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostInput() {
    return this._host;
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // ip_allowlist_regex - computed: true, optional: true, required: false
  private _ipAllowlistRegex?: string; 
  public get ipAllowlistRegex() {
    return this.getStringAttribute('ip_allowlist_regex');
  }
  public set ipAllowlistRegex(value: string) {
    this._ipAllowlistRegex = value;
  }
  public resetIpAllowlistRegex() {
    this._ipAllowlistRegex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ipAllowlistRegexInput() {
    return this._ipAllowlistRegex;
  }

  // ip_denylist_regex - computed: true, optional: true, required: false
  private _ipDenylistRegex?: string; 
  public get ipDenylistRegex() {
    return this.getStringAttribute('ip_denylist_regex');
  }
  public set ipDenylistRegex(value: string) {
    this._ipDenylistRegex = value;
  }
  public resetIpDenylistRegex() {
    this._ipDenylistRegex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ipDenylistRegexInput() {
    return this._ipDenylistRegex;
  }

  // keep_alive_timeout - computed: true, optional: true, required: false
  private _keepAliveTimeout?: number; 
  public get keepAliveTimeout() {
    return this.getNumberAttribute('keep_alive_timeout');
  }
  public set keepAliveTimeout(value: number) {
    this._keepAliveTimeout = value;
  }
  public resetKeepAliveTimeout() {
    this._keepAliveTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keepAliveTimeoutInput() {
    return this._keepAliveTimeout;
  }

  // max_active_req - computed: true, optional: true, required: false
  private _maxActiveReq?: number; 
  public get maxActiveReq() {
    return this.getNumberAttribute('max_active_req');
  }
  public set maxActiveReq(value: number) {
    this._maxActiveReq = value;
  }
  public resetMaxActiveReq() {
    this._maxActiveReq = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxActiveReqInput() {
    return this._maxActiveReq;
  }

  // max_requests_per_socket - computed: true, optional: true, required: false
  private _maxRequestsPerSocket?: number; 
  public get maxRequestsPerSocket() {
    return this.getNumberAttribute('max_requests_per_socket');
  }
  public set maxRequestsPerSocket(value: number) {
    this._maxRequestsPerSocket = value;
  }
  public resetMaxRequestsPerSocket() {
    this._maxRequestsPerSocket = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxRequestsPerSocketInput() {
    return this._maxRequestsPerSocket;
  }

  // metadata - computed: false, optional: true, required: false
  private _metadata = new SourceInputSplunkHecMetadataList(this, "metadata", false);
  public get metadata() {
    return this._metadata;
  }
  public putMetadata(value: SourceInputSplunkHecMetadata[] | cdktf.IResolvable) {
    this._metadata.internalValue = value;
  }
  public resetMetadata() {
    this._metadata.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataInput() {
    return this._metadata.internalValue;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // port - computed: false, optional: false, required: true
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // pq - computed: false, optional: true, required: false
  private _pq = new SourceInputSplunkHecPqOutputReference(this, "pq");
  public get pq() {
    return this._pq;
  }
  public putPq(value: SourceInputSplunkHecPq) {
    this._pq.internalValue = value;
  }
  public resetPq() {
    this._pq.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqInput() {
    return this._pq.internalValue;
  }

  // pq_enabled - computed: true, optional: true, required: false
  private _pqEnabled?: boolean | cdktf.IResolvable; 
  public get pqEnabled() {
    return this.getBooleanAttribute('pq_enabled');
  }
  public set pqEnabled(value: boolean | cdktf.IResolvable) {
    this._pqEnabled = value;
  }
  public resetPqEnabled() {
    this._pqEnabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqEnabledInput() {
    return this._pqEnabled;
  }

  // request_timeout - computed: true, optional: true, required: false
  private _requestTimeout?: number; 
  public get requestTimeout() {
    return this.getNumberAttribute('request_timeout');
  }
  public set requestTimeout(value: number) {
    this._requestTimeout = value;
  }
  public resetRequestTimeout() {
    this._requestTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestTimeoutInput() {
    return this._requestTimeout;
  }

  // send_to_routes - computed: true, optional: true, required: false
  private _sendToRoutes?: boolean | cdktf.IResolvable; 
  public get sendToRoutes() {
    return this.getBooleanAttribute('send_to_routes');
  }
  public set sendToRoutes(value: boolean | cdktf.IResolvable) {
    this._sendToRoutes = value;
  }
  public resetSendToRoutes() {
    this._sendToRoutes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sendToRoutesInput() {
    return this._sendToRoutes;
  }

  // socket_timeout - computed: true, optional: true, required: false
  private _socketTimeout?: number; 
  public get socketTimeout() {
    return this.getNumberAttribute('socket_timeout');
  }
  public set socketTimeout(value: number) {
    this._socketTimeout = value;
  }
  public resetSocketTimeout() {
    this._socketTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get socketTimeoutInput() {
    return this._socketTimeout;
  }

  // splunk_hec_acks - computed: true, optional: true, required: false
  private _splunkHecAcks?: boolean | cdktf.IResolvable; 
  public get splunkHecAcks() {
    return this.getBooleanAttribute('splunk_hec_acks');
  }
  public set splunkHecAcks(value: boolean | cdktf.IResolvable) {
    this._splunkHecAcks = value;
  }
  public resetSplunkHecAcks() {
    this._splunkHecAcks = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get splunkHecAcksInput() {
    return this._splunkHecAcks;
  }

  // splunk_hec_api - computed: true, optional: true, required: false
  private _splunkHecApi?: string; 
  public get splunkHecApi() {
    return this.getStringAttribute('splunk_hec_api');
  }
  public set splunkHecApi(value: string) {
    this._splunkHecApi = value;
  }
  public resetSplunkHecApi() {
    this._splunkHecApi = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get splunkHecApiInput() {
    return this._splunkHecApi;
  }

  // stale_channel_flush_ms - computed: true, optional: true, required: false
  private _staleChannelFlushMs?: number; 
  public get staleChannelFlushMs() {
    return this.getNumberAttribute('stale_channel_flush_ms');
  }
  public set staleChannelFlushMs(value: number) {
    this._staleChannelFlushMs = value;
  }
  public resetStaleChannelFlushMs() {
    this._staleChannelFlushMs = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get staleChannelFlushMsInput() {
    return this._staleChannelFlushMs;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // tls - computed: false, optional: true, required: false
  private _tls = new SourceInputSplunkHecTlsOutputReference(this, "tls");
  public get tls() {
    return this._tls;
  }
  public putTls(value: SourceInputSplunkHecTls) {
    this._tls.internalValue = value;
  }
  public resetTls() {
    this._tls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsInput() {
    return this._tls.internalValue;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // use_fwd_timezone - computed: true, optional: true, required: false
  private _useFwdTimezone?: boolean | cdktf.IResolvable; 
  public get useFwdTimezone() {
    return this.getBooleanAttribute('use_fwd_timezone');
  }
  public set useFwdTimezone(value: boolean | cdktf.IResolvable) {
    this._useFwdTimezone = value;
  }
  public resetUseFwdTimezone() {
    this._useFwdTimezone = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get useFwdTimezoneInput() {
    return this._useFwdTimezone;
  }
}
export interface SourceInputSplunkSearchConnections {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#output Source#output}
  */
  readonly output: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#pipeline Source#pipeline}
  */
  readonly pipeline?: string;
}

export function sourceInputSplunkSearchConnectionsToTerraform(struct?: SourceInputSplunkSearchConnections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    output: cdktf.stringToTerraform(struct!.output),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
  }
}


export function sourceInputSplunkSearchConnectionsToHclTerraform(struct?: SourceInputSplunkSearchConnections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    output: {
      value: cdktf.stringToHclTerraform(struct!.output),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputSplunkSearchConnectionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): SourceInputSplunkSearchConnections | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._output !== undefined) {
      hasAnyValues = true;
      internalValueResult.output = this._output;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputSplunkSearchConnections | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._output = undefined;
      this._pipeline = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._output = value.output;
      this._pipeline = value.pipeline;
    }
  }

  // output - computed: false, optional: false, required: true
  private _output?: string; 
  public get output() {
    return this.getStringAttribute('output');
  }
  public set output(value: string) {
    this._output = value;
  }
  // Temporarily expose input value. Use with caution.
  public get outputInput() {
    return this._output;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }
}

export class SourceInputSplunkSearchConnectionsList extends cdktf.ComplexList {
  public internalValue? : SourceInputSplunkSearchConnections[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): SourceInputSplunkSearchConnectionsOutputReference {
    return new SourceInputSplunkSearchConnectionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface SourceInputSplunkSearchEndpointHeaders {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#name Source#name}
  */
  readonly name: string;
  /**
  * JavaScript expression to compute the header's value, normally enclosed in backticks (e.g., `${earliest}`). If a constant, use single quotes (e.g., 'earliest'). Values without delimiters (e.g., earliest) are evaluated as strings.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#value Source#value}
  */
  readonly value: string;
}

export function sourceInputSplunkSearchEndpointHeadersToTerraform(struct?: SourceInputSplunkSearchEndpointHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function sourceInputSplunkSearchEndpointHeadersToHclTerraform(struct?: SourceInputSplunkSearchEndpointHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputSplunkSearchEndpointHeadersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): SourceInputSplunkSearchEndpointHeaders | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputSplunkSearchEndpointHeaders | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class SourceInputSplunkSearchEndpointHeadersList extends cdktf.ComplexList {
  public internalValue? : SourceInputSplunkSearchEndpointHeaders[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): SourceInputSplunkSearchEndpointHeadersOutputReference {
    return new SourceInputSplunkSearchEndpointHeadersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface SourceInputSplunkSearchEndpointParams {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#name Source#name}
  */
  readonly name: string;
  /**
  * JavaScript expression to compute the parameter's value, normally enclosed in backticks (e.g., `${earliest}`). If a constant, use single quotes (e.g., 'earliest'). Values without delimiters (e.g., earliest) are evaluated as strings.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#value Source#value}
  */
  readonly value: string;
}

export function sourceInputSplunkSearchEndpointParamsToTerraform(struct?: SourceInputSplunkSearchEndpointParams | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function sourceInputSplunkSearchEndpointParamsToHclTerraform(struct?: SourceInputSplunkSearchEndpointParams | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputSplunkSearchEndpointParamsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): SourceInputSplunkSearchEndpointParams | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputSplunkSearchEndpointParams | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class SourceInputSplunkSearchEndpointParamsList extends cdktf.ComplexList {
  public internalValue? : SourceInputSplunkSearchEndpointParams[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): SourceInputSplunkSearchEndpointParamsOutputReference {
    return new SourceInputSplunkSearchEndpointParamsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface SourceInputSplunkSearchMetadata {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#name Source#name}
  */
  readonly name: string;
  /**
  * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#value Source#value}
  */
  readonly value: string;
}

export function sourceInputSplunkSearchMetadataToTerraform(struct?: SourceInputSplunkSearchMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function sourceInputSplunkSearchMetadataToHclTerraform(struct?: SourceInputSplunkSearchMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputSplunkSearchMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): SourceInputSplunkSearchMetadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputSplunkSearchMetadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class SourceInputSplunkSearchMetadataList extends cdktf.ComplexList {
  public internalValue? : SourceInputSplunkSearchMetadata[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): SourceInputSplunkSearchMetadataOutputReference {
    return new SourceInputSplunkSearchMetadataOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface SourceInputSplunkSearchOauthHeaders {
  /**
  * OAuth header name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#name Source#name}
  */
  readonly name: string;
  /**
  * OAuth header value
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#value Source#value}
  */
  readonly value: string;
}

export function sourceInputSplunkSearchOauthHeadersToTerraform(struct?: SourceInputSplunkSearchOauthHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function sourceInputSplunkSearchOauthHeadersToHclTerraform(struct?: SourceInputSplunkSearchOauthHeaders | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputSplunkSearchOauthHeadersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): SourceInputSplunkSearchOauthHeaders | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputSplunkSearchOauthHeaders | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class SourceInputSplunkSearchOauthHeadersList extends cdktf.ComplexList {
  public internalValue? : SourceInputSplunkSearchOauthHeaders[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): SourceInputSplunkSearchOauthHeadersOutputReference {
    return new SourceInputSplunkSearchOauthHeadersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface SourceInputSplunkSearchOauthParams {
  /**
  * OAuth parameter name
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#name Source#name}
  */
  readonly name: string;
  /**
  * OAuth parameter value
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#value Source#value}
  */
  readonly value: string;
}

export function sourceInputSplunkSearchOauthParamsToTerraform(struct?: SourceInputSplunkSearchOauthParams | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function sourceInputSplunkSearchOauthParamsToHclTerraform(struct?: SourceInputSplunkSearchOauthParams | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputSplunkSearchOauthParamsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): SourceInputSplunkSearchOauthParams | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputSplunkSearchOauthParams | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class SourceInputSplunkSearchOauthParamsList extends cdktf.ComplexList {
  public internalValue? : SourceInputSplunkSearchOauthParams[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): SourceInputSplunkSearchOauthParamsOutputReference {
    return new SourceInputSplunkSearchOauthParamsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface SourceInputSplunkSearchPq {
  /**
  * The number of events to send downstream before committing that Stream has read them. Default: 42
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#commit_frequency Source#commit_frequency}
  */
  readonly commitFrequency?: number;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#compress Source#compress}
  */
  readonly compress?: string;
  /**
  * The maximum number of events to hold in memory before writing the events to disk. Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_buffer_size Source#max_buffer_size}
  */
  readonly maxBufferSize?: number;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc. Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_file_size Source#max_file_size}
  */
  readonly maxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_size Source#max_size}
  */
  readonly maxSize?: string;
  /**
  * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine. Default: "always"; must be one of ["smart", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#mode Source#mode}
  */
  readonly mode?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#path Source#path}
  */
  readonly path?: string;
}

export function sourceInputSplunkSearchPqToTerraform(struct?: SourceInputSplunkSearchPq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    commit_frequency: cdktf.numberToTerraform(struct!.commitFrequency),
    compress: cdktf.stringToTerraform(struct!.compress),
    max_buffer_size: cdktf.numberToTerraform(struct!.maxBufferSize),
    max_file_size: cdktf.stringToTerraform(struct!.maxFileSize),
    max_size: cdktf.stringToTerraform(struct!.maxSize),
    mode: cdktf.stringToTerraform(struct!.mode),
    path: cdktf.stringToTerraform(struct!.path),
  }
}


export function sourceInputSplunkSearchPqToHclTerraform(struct?: SourceInputSplunkSearchPq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    commit_frequency: {
      value: cdktf.numberToHclTerraform(struct!.commitFrequency),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    compress: {
      value: cdktf.stringToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_buffer_size: {
      value: cdktf.numberToHclTerraform(struct!.maxBufferSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.maxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_size: {
      value: cdktf.stringToHclTerraform(struct!.maxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputSplunkSearchPqOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SourceInputSplunkSearchPq | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._commitFrequency !== undefined) {
      hasAnyValues = true;
      internalValueResult.commitFrequency = this._commitFrequency;
    }
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._maxBufferSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBufferSize = this._maxBufferSize;
    }
    if (this._maxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxFileSize = this._maxFileSize;
    }
    if (this._maxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxSize = this._maxSize;
    }
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputSplunkSearchPq | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._commitFrequency = undefined;
      this._compress = undefined;
      this._maxBufferSize = undefined;
      this._maxFileSize = undefined;
      this._maxSize = undefined;
      this._mode = undefined;
      this._path = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._commitFrequency = value.commitFrequency;
      this._compress = value.compress;
      this._maxBufferSize = value.maxBufferSize;
      this._maxFileSize = value.maxFileSize;
      this._maxSize = value.maxSize;
      this._mode = value.mode;
      this._path = value.path;
    }
  }

  // commit_frequency - computed: true, optional: true, required: false
  private _commitFrequency?: number; 
  public get commitFrequency() {
    return this.getNumberAttribute('commit_frequency');
  }
  public set commitFrequency(value: number) {
    this._commitFrequency = value;
  }
  public resetCommitFrequency() {
    this._commitFrequency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commitFrequencyInput() {
    return this._commitFrequency;
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: string; 
  public get compress() {
    return this.getStringAttribute('compress');
  }
  public set compress(value: string) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // max_buffer_size - computed: true, optional: true, required: false
  private _maxBufferSize?: number; 
  public get maxBufferSize() {
    return this.getNumberAttribute('max_buffer_size');
  }
  public set maxBufferSize(value: number) {
    this._maxBufferSize = value;
  }
  public resetMaxBufferSize() {
    this._maxBufferSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBufferSizeInput() {
    return this._maxBufferSize;
  }

  // max_file_size - computed: true, optional: true, required: false
  private _maxFileSize?: string; 
  public get maxFileSize() {
    return this.getStringAttribute('max_file_size');
  }
  public set maxFileSize(value: string) {
    this._maxFileSize = value;
  }
  public resetMaxFileSize() {
    this._maxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxFileSizeInput() {
    return this._maxFileSize;
  }

  // max_size - computed: true, optional: true, required: false
  private _maxSize?: string; 
  public get maxSize() {
    return this.getStringAttribute('max_size');
  }
  public set maxSize(value: string) {
    this._maxSize = value;
  }
  public resetMaxSize() {
    this._maxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxSizeInput() {
    return this._maxSize;
  }

  // mode - computed: true, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // path - computed: true, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }
}
export interface SourceInputSplunkSearchRetryRules {
  /**
  * List of HTTP codes that trigger a retry. Leave empty to use the default list of 429 and 503. Default: [429,503]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#codes Source#codes}
  */
  readonly codes?: number[];
  /**
  * Honor any Retry-After header that specifies a delay (in seconds) or a timestamp after which to retry the request. The delay is limited to 20 seconds, even if the Retry-After header specifies a longer delay. When disabled, all Retry-After headers are ignored. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#enable_header Source#enable_header}
  */
  readonly enableHeader?: boolean | cdktf.IResolvable;
  /**
  * Time interval between failed request and first retry (kickoff). Maximum allowed value is 20,000 ms (1/3 minute). Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#interval Source#interval}
  */
  readonly interval?: number;
  /**
  * The maximum number of times to retry a failed HTTP request. Default: 5
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#limit Source#limit}
  */
  readonly limit?: number;
  /**
  * Base for exponential backoff, e.g., base 2 means that retries will occur after 2, then 4, then 8 seconds, and so on. Default: 2
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#multiplier Source#multiplier}
  */
  readonly multiplier?: number;
  /**
  * Retry request when a connection reset (ECONNRESET) error occurs. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#retry_connect_reset Source#retry_connect_reset}
  */
  readonly retryConnectReset?: boolean | cdktf.IResolvable;
  /**
  * Make a single retry attempt when a connection timeout (ETIMEDOUT) error occurs. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#retry_connect_timeout Source#retry_connect_timeout}
  */
  readonly retryConnectTimeout?: boolean | cdktf.IResolvable;
  /**
  * The algorithm to use when performing HTTP retries. Default: "backoff"; must be one of ["none", "backoff", "static"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#type Source#type}
  */
  readonly type?: string;
}

export function sourceInputSplunkSearchRetryRulesToTerraform(struct?: SourceInputSplunkSearchRetryRules | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    codes: cdktf.listMapper(cdktf.numberToTerraform, false)(struct!.codes),
    enable_header: cdktf.booleanToTerraform(struct!.enableHeader),
    interval: cdktf.numberToTerraform(struct!.interval),
    limit: cdktf.numberToTerraform(struct!.limit),
    multiplier: cdktf.numberToTerraform(struct!.multiplier),
    retry_connect_reset: cdktf.booleanToTerraform(struct!.retryConnectReset),
    retry_connect_timeout: cdktf.booleanToTerraform(struct!.retryConnectTimeout),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function sourceInputSplunkSearchRetryRulesToHclTerraform(struct?: SourceInputSplunkSearchRetryRules | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    codes: {
      value: cdktf.listMapperHcl(cdktf.numberToHclTerraform, false)(struct!.codes),
      isBlock: false,
      type: "list",
      storageClassType: "numberList",
    },
    enable_header: {
      value: cdktf.booleanToHclTerraform(struct!.enableHeader),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    interval: {
      value: cdktf.numberToHclTerraform(struct!.interval),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    limit: {
      value: cdktf.numberToHclTerraform(struct!.limit),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    multiplier: {
      value: cdktf.numberToHclTerraform(struct!.multiplier),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    retry_connect_reset: {
      value: cdktf.booleanToHclTerraform(struct!.retryConnectReset),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    retry_connect_timeout: {
      value: cdktf.booleanToHclTerraform(struct!.retryConnectTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputSplunkSearchRetryRulesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SourceInputSplunkSearchRetryRules | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._codes !== undefined) {
      hasAnyValues = true;
      internalValueResult.codes = this._codes;
    }
    if (this._enableHeader !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableHeader = this._enableHeader;
    }
    if (this._interval !== undefined) {
      hasAnyValues = true;
      internalValueResult.interval = this._interval;
    }
    if (this._limit !== undefined) {
      hasAnyValues = true;
      internalValueResult.limit = this._limit;
    }
    if (this._multiplier !== undefined) {
      hasAnyValues = true;
      internalValueResult.multiplier = this._multiplier;
    }
    if (this._retryConnectReset !== undefined) {
      hasAnyValues = true;
      internalValueResult.retryConnectReset = this._retryConnectReset;
    }
    if (this._retryConnectTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.retryConnectTimeout = this._retryConnectTimeout;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputSplunkSearchRetryRules | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._codes = undefined;
      this._enableHeader = undefined;
      this._interval = undefined;
      this._limit = undefined;
      this._multiplier = undefined;
      this._retryConnectReset = undefined;
      this._retryConnectTimeout = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._codes = value.codes;
      this._enableHeader = value.enableHeader;
      this._interval = value.interval;
      this._limit = value.limit;
      this._multiplier = value.multiplier;
      this._retryConnectReset = value.retryConnectReset;
      this._retryConnectTimeout = value.retryConnectTimeout;
      this._type = value.type;
    }
  }

  // codes - computed: true, optional: true, required: false
  private _codes?: number[]; 
  public get codes() {
    return this.getNumberListAttribute('codes');
  }
  public set codes(value: number[]) {
    this._codes = value;
  }
  public resetCodes() {
    this._codes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get codesInput() {
    return this._codes;
  }

  // enable_header - computed: true, optional: true, required: false
  private _enableHeader?: boolean | cdktf.IResolvable; 
  public get enableHeader() {
    return this.getBooleanAttribute('enable_header');
  }
  public set enableHeader(value: boolean | cdktf.IResolvable) {
    this._enableHeader = value;
  }
  public resetEnableHeader() {
    this._enableHeader = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableHeaderInput() {
    return this._enableHeader;
  }

  // interval - computed: true, optional: true, required: false
  private _interval?: number; 
  public get interval() {
    return this.getNumberAttribute('interval');
  }
  public set interval(value: number) {
    this._interval = value;
  }
  public resetInterval() {
    this._interval = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get intervalInput() {
    return this._interval;
  }

  // limit - computed: true, optional: true, required: false
  private _limit?: number; 
  public get limit() {
    return this.getNumberAttribute('limit');
  }
  public set limit(value: number) {
    this._limit = value;
  }
  public resetLimit() {
    this._limit = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get limitInput() {
    return this._limit;
  }

  // multiplier - computed: true, optional: true, required: false
  private _multiplier?: number; 
  public get multiplier() {
    return this.getNumberAttribute('multiplier');
  }
  public set multiplier(value: number) {
    this._multiplier = value;
  }
  public resetMultiplier() {
    this._multiplier = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get multiplierInput() {
    return this._multiplier;
  }

  // retry_connect_reset - computed: true, optional: true, required: false
  private _retryConnectReset?: boolean | cdktf.IResolvable; 
  public get retryConnectReset() {
    return this.getBooleanAttribute('retry_connect_reset');
  }
  public set retryConnectReset(value: boolean | cdktf.IResolvable) {
    this._retryConnectReset = value;
  }
  public resetRetryConnectReset() {
    this._retryConnectReset = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get retryConnectResetInput() {
    return this._retryConnectReset;
  }

  // retry_connect_timeout - computed: true, optional: true, required: false
  private _retryConnectTimeout?: boolean | cdktf.IResolvable; 
  public get retryConnectTimeout() {
    return this.getBooleanAttribute('retry_connect_timeout');
  }
  public set retryConnectTimeout(value: boolean | cdktf.IResolvable) {
    this._retryConnectTimeout = value;
  }
  public resetRetryConnectTimeout() {
    this._retryConnectTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get retryConnectTimeoutInput() {
    return this._retryConnectTimeout;
  }

  // type - computed: true, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface SourceInputSplunkSearch {
  /**
  * JavaScript expression to compute the Authorization header value to pass in requests. The value `${token}` is used to reference the token obtained from authentication, e.g.: `Bearer ${token}`. Default: "`Bearer ${token}`"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#auth_header_expr Source#auth_header_expr}
  */
  readonly authHeaderExpr?: string;
  /**
  * Splunk Search authentication type. Default: "basic"; must be one of ["none", "basic", "credentialsSecret", "token", "textSecret", "oauth"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#auth_type Source#auth_type}
  */
  readonly authType?: string;
  /**
  * A list of event-breaking rulesets that will be applied, in order, to the input data stream. Default: ["Splunk Search Ruleset"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#breaker_rulesets Source#breaker_rulesets}
  */
  readonly breakerRulesets?: string[];
  /**
  * Direct connections to Destinations, and optionally via a Pipeline or a Pack
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#connections Source#connections}
  */
  readonly connections?: SourceInputSplunkSearchConnections[] | cdktf.IResolvable;
  /**
  * Select or create a secret that references your credentials
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#credentials_secret Source#credentials_secret}
  */
  readonly credentialsSecret?: string;
  /**
  * A cron schedule on which to run this job. Default: "* /15 * * * *"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#cron_schedule Source#cron_schedule}
   *
  * Note: The above comment contained a comment block ending sequence (* followed by /). We have introduced a space between to prevent syntax errors. Please ignore the space.
  */
  readonly cronSchedule?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#description Source#description}
  */
  readonly description?: string;
  /**
  * Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#disabled Source#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * The earliest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-16m@m'. Default: "-16m@m"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#earliest Source#earliest}
  */
  readonly earliest?: string;
  /**
  * Character encoding to use when parsing ingested data. When not set, @{product} will default to UTF-8 but may incorrectly interpret multi-byte characters.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#encoding Source#encoding}
  */
  readonly encoding?: string;
  /**
  * REST API used to create a search. Default: "/services/search/v2/jobs/export"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#endpoint Source#endpoint}
  */
  readonly endpoint?: string;
  /**
  * Optional request headers to send to the endpoint
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#endpoint_headers Source#endpoint_headers}
  */
  readonly endpointHeaders?: SourceInputSplunkSearchEndpointHeaders[] | cdktf.IResolvable;
  /**
  * Optional request parameters to send to the endpoint
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#endpoint_params Source#endpoint_params}
  */
  readonly endpointParams?: SourceInputSplunkSearchEndpointParams[] | cdktf.IResolvable;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#environment Source#environment}
  */
  readonly environment?: string;
  /**
  * Unique ID for this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#id Source#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * When enabled, this job's artifacts are not counted toward the Worker Group's finished job artifacts limit. Artifacts will be removed only after the Collector's configured time to live. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#ignore_group_jobs_limit Source#ignore_group_jobs_limit}
  */
  readonly ignoreGroupJobsLimit?: boolean | cdktf.IResolvable;
  /**
  * Maximum time the job is allowed to run (e.g., 30, 45s or 15m). Units are seconds, if not specified. Enter 0 for unlimited time. Default: "0"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#job_timeout Source#job_timeout}
  */
  readonly jobTimeout?: string;
  /**
  * How often workers should check in with the scheduler to keep job subscription alive. Default: 30
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#keep_alive_time Source#keep_alive_time}
  */
  readonly keepAliveTime?: number;
  /**
  * The latest time boundary for the search. Can be an exact or relative time. Examples: '2022-01-14T12:00:00Z' or '-1m@m'. Default: "-1m@m"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#latest Source#latest}
  */
  readonly latest?: string;
  /**
  * Collector runtime log level (verbosity). must be one of ["error", "warn", "info", "debug"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#log_level Source#log_level}
  */
  readonly logLevel?: string;
  /**
  * URL for OAuth
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#login_url Source#login_url}
  */
  readonly loginUrl?: string;
  /**
  * The number of Keep Alive Time periods before an inactive worker will have its job subscription revoked. Default: 3
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_missed_keep_alives Source#max_missed_keep_alives}
  */
  readonly maxMissedKeepAlives?: number;
  /**
  * Fields to add to events from this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#metadata Source#metadata}
  */
  readonly metadata?: SourceInputSplunkSearchMetadata[] | cdktf.IResolvable;
  /**
  * Additional headers to send in the OAuth login request. @{product} will automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#oauth_headers Source#oauth_headers}
  */
  readonly oauthHeaders?: SourceInputSplunkSearchOauthHeaders[] | cdktf.IResolvable;
  /**
  * Additional parameters to send in the OAuth login request. @{product} will combine the secret with these parameters, and will send the URL-encoded result in a POST request to the endpoint specified in the 'Login URL'. We'll automatically add the content-type header 'application/x-www-form-urlencoded' when sending this request.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#oauth_params Source#oauth_params}
  */
  readonly oauthParams?: SourceInputSplunkSearchOauthParams[] | cdktf.IResolvable;
  /**
  * Format of the returned output. Default: "json"; must be one of ["csv", "json"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#output_mode Source#output_mode}
  */
  readonly outputMode?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#password Source#password}
  */
  readonly password?: string;
  /**
  * Pipeline to process data from this Source before sending it through the Routes
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#pipeline Source#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#pq Source#pq}
  */
  readonly pq?: SourceInputSplunkSearchPq;
  /**
  * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers). Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#pq_enabled Source#pq_enabled}
  */
  readonly pqEnabled?: boolean | cdktf.IResolvable;
  /**
  * Reject certificates that cannot be verified against a valid CA (such as self-signed certificates). Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#reject_unauthorized Source#reject_unauthorized}
  */
  readonly rejectUnauthorized?: boolean | cdktf.IResolvable;
  /**
  * HTTP request inactivity timeout. Use 0 for no timeout. Default: 0
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#request_timeout Source#request_timeout}
  */
  readonly requestTimeout?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#retry_rules Source#retry_rules}
  */
  readonly retryRules?: SourceInputSplunkSearchRetryRules;
  /**
  * Enter Splunk search here. Examples: 'index=myAppLogs level=error channel=myApp' OR '| mstats avg(myStat) as myStat WHERE index=myStatsIndex.'
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#search Source#search}
  */
  readonly search: string;
  /**
  * Search head base URL. Can be an expression. Default is https://localhost:8089. Default: "https://localhost:8089"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#search_head Source#search_head}
  */
  readonly searchHead?: string;
  /**
  * Secret parameter value to pass in request body
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#secret Source#secret}
  */
  readonly secret?: string;
  /**
  * Secret parameter name to pass in request body
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#secret_param_name Source#secret_param_name}
  */
  readonly secretParamName?: string;
  /**
  * Select whether to send data to Routes, or directly to Destinations. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#send_to_routes Source#send_to_routes}
  */
  readonly sendToRoutes?: boolean | cdktf.IResolvable;
  /**
  * How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines. Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#stale_channel_flush_ms Source#stale_channel_flush_ms}
  */
  readonly staleChannelFlushMs?: number;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#streamtags Source#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Select or create a stored text secret
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#text_secret Source#text_secret}
  */
  readonly textSecret?: string;
  /**
  * Bearer token to include in the authorization header
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#token Source#token}
  */
  readonly token?: string;
  /**
  * Name of the auth token attribute in the OAuth response. Can be top-level (e.g., 'token'); or nested, using a period (e.g., 'data.token').
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#token_attribute_name Source#token_attribute_name}
  */
  readonly tokenAttributeName?: string;
  /**
  * How often the OAuth token should be refreshed. Default: 3600
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#token_timeout_secs Source#token_timeout_secs}
  */
  readonly tokenTimeoutSecs?: number;
  /**
  * Time to keep the job's artifacts on disk after job completion. This also affects how long a job is listed in the Job Inspector. Default: "4h"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#ttl Source#ttl}
  */
  readonly ttl?: string;
  /**
  * must be "splunk_search"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#type Source#type}
  */
  readonly type?: string;
  /**
  * When a DNS server returns multiple addresses, @{product} will cycle through them in the order returned. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#use_round_robin_dns Source#use_round_robin_dns}
  */
  readonly useRoundRobinDns?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#username Source#username}
  */
  readonly username?: string;
}

export function sourceInputSplunkSearchToTerraform(struct?: SourceInputSplunkSearch | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    auth_header_expr: cdktf.stringToTerraform(struct!.authHeaderExpr),
    auth_type: cdktf.stringToTerraform(struct!.authType),
    breaker_rulesets: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.breakerRulesets),
    connections: cdktf.listMapper(sourceInputSplunkSearchConnectionsToTerraform, false)(struct!.connections),
    credentials_secret: cdktf.stringToTerraform(struct!.credentialsSecret),
    cron_schedule: cdktf.stringToTerraform(struct!.cronSchedule),
    description: cdktf.stringToTerraform(struct!.description),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    earliest: cdktf.stringToTerraform(struct!.earliest),
    encoding: cdktf.stringToTerraform(struct!.encoding),
    endpoint: cdktf.stringToTerraform(struct!.endpoint),
    endpoint_headers: cdktf.listMapper(sourceInputSplunkSearchEndpointHeadersToTerraform, false)(struct!.endpointHeaders),
    endpoint_params: cdktf.listMapper(sourceInputSplunkSearchEndpointParamsToTerraform, false)(struct!.endpointParams),
    environment: cdktf.stringToTerraform(struct!.environment),
    id: cdktf.stringToTerraform(struct!.id),
    ignore_group_jobs_limit: cdktf.booleanToTerraform(struct!.ignoreGroupJobsLimit),
    job_timeout: cdktf.stringToTerraform(struct!.jobTimeout),
    keep_alive_time: cdktf.numberToTerraform(struct!.keepAliveTime),
    latest: cdktf.stringToTerraform(struct!.latest),
    log_level: cdktf.stringToTerraform(struct!.logLevel),
    login_url: cdktf.stringToTerraform(struct!.loginUrl),
    max_missed_keep_alives: cdktf.numberToTerraform(struct!.maxMissedKeepAlives),
    metadata: cdktf.listMapper(sourceInputSplunkSearchMetadataToTerraform, false)(struct!.metadata),
    oauth_headers: cdktf.listMapper(sourceInputSplunkSearchOauthHeadersToTerraform, false)(struct!.oauthHeaders),
    oauth_params: cdktf.listMapper(sourceInputSplunkSearchOauthParamsToTerraform, false)(struct!.oauthParams),
    output_mode: cdktf.stringToTerraform(struct!.outputMode),
    password: cdktf.stringToTerraform(struct!.password),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    pq: sourceInputSplunkSearchPqToTerraform(struct!.pq),
    pq_enabled: cdktf.booleanToTerraform(struct!.pqEnabled),
    reject_unauthorized: cdktf.booleanToTerraform(struct!.rejectUnauthorized),
    request_timeout: cdktf.numberToTerraform(struct!.requestTimeout),
    retry_rules: sourceInputSplunkSearchRetryRulesToTerraform(struct!.retryRules),
    search: cdktf.stringToTerraform(struct!.search),
    search_head: cdktf.stringToTerraform(struct!.searchHead),
    secret: cdktf.stringToTerraform(struct!.secret),
    secret_param_name: cdktf.stringToTerraform(struct!.secretParamName),
    send_to_routes: cdktf.booleanToTerraform(struct!.sendToRoutes),
    stale_channel_flush_ms: cdktf.numberToTerraform(struct!.staleChannelFlushMs),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    text_secret: cdktf.stringToTerraform(struct!.textSecret),
    token: cdktf.stringToTerraform(struct!.token),
    token_attribute_name: cdktf.stringToTerraform(struct!.tokenAttributeName),
    token_timeout_secs: cdktf.numberToTerraform(struct!.tokenTimeoutSecs),
    ttl: cdktf.stringToTerraform(struct!.ttl),
    type: cdktf.stringToTerraform(struct!.type),
    use_round_robin_dns: cdktf.booleanToTerraform(struct!.useRoundRobinDns),
    username: cdktf.stringToTerraform(struct!.username),
  }
}


export function sourceInputSplunkSearchToHclTerraform(struct?: SourceInputSplunkSearch | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    auth_header_expr: {
      value: cdktf.stringToHclTerraform(struct!.authHeaderExpr),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    auth_type: {
      value: cdktf.stringToHclTerraform(struct!.authType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    breaker_rulesets: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.breakerRulesets),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    connections: {
      value: cdktf.listMapperHcl(sourceInputSplunkSearchConnectionsToHclTerraform, false)(struct!.connections),
      isBlock: true,
      type: "list",
      storageClassType: "SourceInputSplunkSearchConnectionsList",
    },
    credentials_secret: {
      value: cdktf.stringToHclTerraform(struct!.credentialsSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    cron_schedule: {
      value: cdktf.stringToHclTerraform(struct!.cronSchedule),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    earliest: {
      value: cdktf.stringToHclTerraform(struct!.earliest),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    encoding: {
      value: cdktf.stringToHclTerraform(struct!.encoding),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    endpoint: {
      value: cdktf.stringToHclTerraform(struct!.endpoint),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    endpoint_headers: {
      value: cdktf.listMapperHcl(sourceInputSplunkSearchEndpointHeadersToHclTerraform, false)(struct!.endpointHeaders),
      isBlock: true,
      type: "list",
      storageClassType: "SourceInputSplunkSearchEndpointHeadersList",
    },
    endpoint_params: {
      value: cdktf.listMapperHcl(sourceInputSplunkSearchEndpointParamsToHclTerraform, false)(struct!.endpointParams),
      isBlock: true,
      type: "list",
      storageClassType: "SourceInputSplunkSearchEndpointParamsList",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ignore_group_jobs_limit: {
      value: cdktf.booleanToHclTerraform(struct!.ignoreGroupJobsLimit),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    job_timeout: {
      value: cdktf.stringToHclTerraform(struct!.jobTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    keep_alive_time: {
      value: cdktf.numberToHclTerraform(struct!.keepAliveTime),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    latest: {
      value: cdktf.stringToHclTerraform(struct!.latest),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    log_level: {
      value: cdktf.stringToHclTerraform(struct!.logLevel),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    login_url: {
      value: cdktf.stringToHclTerraform(struct!.loginUrl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_missed_keep_alives: {
      value: cdktf.numberToHclTerraform(struct!.maxMissedKeepAlives),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    metadata: {
      value: cdktf.listMapperHcl(sourceInputSplunkSearchMetadataToHclTerraform, false)(struct!.metadata),
      isBlock: true,
      type: "list",
      storageClassType: "SourceInputSplunkSearchMetadataList",
    },
    oauth_headers: {
      value: cdktf.listMapperHcl(sourceInputSplunkSearchOauthHeadersToHclTerraform, false)(struct!.oauthHeaders),
      isBlock: true,
      type: "list",
      storageClassType: "SourceInputSplunkSearchOauthHeadersList",
    },
    oauth_params: {
      value: cdktf.listMapperHcl(sourceInputSplunkSearchOauthParamsToHclTerraform, false)(struct!.oauthParams),
      isBlock: true,
      type: "list",
      storageClassType: "SourceInputSplunkSearchOauthParamsList",
    },
    output_mode: {
      value: cdktf.stringToHclTerraform(struct!.outputMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    password: {
      value: cdktf.stringToHclTerraform(struct!.password),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq: {
      value: sourceInputSplunkSearchPqToHclTerraform(struct!.pq),
      isBlock: true,
      type: "struct",
      storageClassType: "SourceInputSplunkSearchPq",
    },
    pq_enabled: {
      value: cdktf.booleanToHclTerraform(struct!.pqEnabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    reject_unauthorized: {
      value: cdktf.booleanToHclTerraform(struct!.rejectUnauthorized),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    request_timeout: {
      value: cdktf.numberToHclTerraform(struct!.requestTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    retry_rules: {
      value: sourceInputSplunkSearchRetryRulesToHclTerraform(struct!.retryRules),
      isBlock: true,
      type: "struct",
      storageClassType: "SourceInputSplunkSearchRetryRules",
    },
    search: {
      value: cdktf.stringToHclTerraform(struct!.search),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    search_head: {
      value: cdktf.stringToHclTerraform(struct!.searchHead),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret: {
      value: cdktf.stringToHclTerraform(struct!.secret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    secret_param_name: {
      value: cdktf.stringToHclTerraform(struct!.secretParamName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    send_to_routes: {
      value: cdktf.booleanToHclTerraform(struct!.sendToRoutes),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    stale_channel_flush_ms: {
      value: cdktf.numberToHclTerraform(struct!.staleChannelFlushMs),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    text_secret: {
      value: cdktf.stringToHclTerraform(struct!.textSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    token: {
      value: cdktf.stringToHclTerraform(struct!.token),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    token_attribute_name: {
      value: cdktf.stringToHclTerraform(struct!.tokenAttributeName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    token_timeout_secs: {
      value: cdktf.numberToHclTerraform(struct!.tokenTimeoutSecs),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    ttl: {
      value: cdktf.stringToHclTerraform(struct!.ttl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    use_round_robin_dns: {
      value: cdktf.booleanToHclTerraform(struct!.useRoundRobinDns),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    username: {
      value: cdktf.stringToHclTerraform(struct!.username),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputSplunkSearchOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SourceInputSplunkSearch | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._authHeaderExpr !== undefined) {
      hasAnyValues = true;
      internalValueResult.authHeaderExpr = this._authHeaderExpr;
    }
    if (this._authType !== undefined) {
      hasAnyValues = true;
      internalValueResult.authType = this._authType;
    }
    if (this._breakerRulesets !== undefined) {
      hasAnyValues = true;
      internalValueResult.breakerRulesets = this._breakerRulesets;
    }
    if (this._connections?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.connections = this._connections?.internalValue;
    }
    if (this._credentialsSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.credentialsSecret = this._credentialsSecret;
    }
    if (this._cronSchedule !== undefined) {
      hasAnyValues = true;
      internalValueResult.cronSchedule = this._cronSchedule;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._earliest !== undefined) {
      hasAnyValues = true;
      internalValueResult.earliest = this._earliest;
    }
    if (this._encoding !== undefined) {
      hasAnyValues = true;
      internalValueResult.encoding = this._encoding;
    }
    if (this._endpoint !== undefined) {
      hasAnyValues = true;
      internalValueResult.endpoint = this._endpoint;
    }
    if (this._endpointHeaders?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.endpointHeaders = this._endpointHeaders?.internalValue;
    }
    if (this._endpointParams?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.endpointParams = this._endpointParams?.internalValue;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._ignoreGroupJobsLimit !== undefined) {
      hasAnyValues = true;
      internalValueResult.ignoreGroupJobsLimit = this._ignoreGroupJobsLimit;
    }
    if (this._jobTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.jobTimeout = this._jobTimeout;
    }
    if (this._keepAliveTime !== undefined) {
      hasAnyValues = true;
      internalValueResult.keepAliveTime = this._keepAliveTime;
    }
    if (this._latest !== undefined) {
      hasAnyValues = true;
      internalValueResult.latest = this._latest;
    }
    if (this._logLevel !== undefined) {
      hasAnyValues = true;
      internalValueResult.logLevel = this._logLevel;
    }
    if (this._loginUrl !== undefined) {
      hasAnyValues = true;
      internalValueResult.loginUrl = this._loginUrl;
    }
    if (this._maxMissedKeepAlives !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxMissedKeepAlives = this._maxMissedKeepAlives;
    }
    if (this._metadata?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadata = this._metadata?.internalValue;
    }
    if (this._oauthHeaders?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.oauthHeaders = this._oauthHeaders?.internalValue;
    }
    if (this._oauthParams?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.oauthParams = this._oauthParams?.internalValue;
    }
    if (this._outputMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.outputMode = this._outputMode;
    }
    if (this._password !== undefined) {
      hasAnyValues = true;
      internalValueResult.password = this._password;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._pq?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pq = this._pq?.internalValue;
    }
    if (this._pqEnabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqEnabled = this._pqEnabled;
    }
    if (this._rejectUnauthorized !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectUnauthorized = this._rejectUnauthorized;
    }
    if (this._requestTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.requestTimeout = this._requestTimeout;
    }
    if (this._retryRules?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.retryRules = this._retryRules?.internalValue;
    }
    if (this._search !== undefined) {
      hasAnyValues = true;
      internalValueResult.search = this._search;
    }
    if (this._searchHead !== undefined) {
      hasAnyValues = true;
      internalValueResult.searchHead = this._searchHead;
    }
    if (this._secret !== undefined) {
      hasAnyValues = true;
      internalValueResult.secret = this._secret;
    }
    if (this._secretParamName !== undefined) {
      hasAnyValues = true;
      internalValueResult.secretParamName = this._secretParamName;
    }
    if (this._sendToRoutes !== undefined) {
      hasAnyValues = true;
      internalValueResult.sendToRoutes = this._sendToRoutes;
    }
    if (this._staleChannelFlushMs !== undefined) {
      hasAnyValues = true;
      internalValueResult.staleChannelFlushMs = this._staleChannelFlushMs;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._textSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.textSecret = this._textSecret;
    }
    if (this._token !== undefined) {
      hasAnyValues = true;
      internalValueResult.token = this._token;
    }
    if (this._tokenAttributeName !== undefined) {
      hasAnyValues = true;
      internalValueResult.tokenAttributeName = this._tokenAttributeName;
    }
    if (this._tokenTimeoutSecs !== undefined) {
      hasAnyValues = true;
      internalValueResult.tokenTimeoutSecs = this._tokenTimeoutSecs;
    }
    if (this._ttl !== undefined) {
      hasAnyValues = true;
      internalValueResult.ttl = this._ttl;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._useRoundRobinDns !== undefined) {
      hasAnyValues = true;
      internalValueResult.useRoundRobinDns = this._useRoundRobinDns;
    }
    if (this._username !== undefined) {
      hasAnyValues = true;
      internalValueResult.username = this._username;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputSplunkSearch | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._authHeaderExpr = undefined;
      this._authType = undefined;
      this._breakerRulesets = undefined;
      this._connections.internalValue = undefined;
      this._credentialsSecret = undefined;
      this._cronSchedule = undefined;
      this._description = undefined;
      this._disabled = undefined;
      this._earliest = undefined;
      this._encoding = undefined;
      this._endpoint = undefined;
      this._endpointHeaders.internalValue = undefined;
      this._endpointParams.internalValue = undefined;
      this._environment = undefined;
      this._id = undefined;
      this._ignoreGroupJobsLimit = undefined;
      this._jobTimeout = undefined;
      this._keepAliveTime = undefined;
      this._latest = undefined;
      this._logLevel = undefined;
      this._loginUrl = undefined;
      this._maxMissedKeepAlives = undefined;
      this._metadata.internalValue = undefined;
      this._oauthHeaders.internalValue = undefined;
      this._oauthParams.internalValue = undefined;
      this._outputMode = undefined;
      this._password = undefined;
      this._pipeline = undefined;
      this._pq.internalValue = undefined;
      this._pqEnabled = undefined;
      this._rejectUnauthorized = undefined;
      this._requestTimeout = undefined;
      this._retryRules.internalValue = undefined;
      this._search = undefined;
      this._searchHead = undefined;
      this._secret = undefined;
      this._secretParamName = undefined;
      this._sendToRoutes = undefined;
      this._staleChannelFlushMs = undefined;
      this._streamtags = undefined;
      this._textSecret = undefined;
      this._token = undefined;
      this._tokenAttributeName = undefined;
      this._tokenTimeoutSecs = undefined;
      this._ttl = undefined;
      this._type = undefined;
      this._useRoundRobinDns = undefined;
      this._username = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._authHeaderExpr = value.authHeaderExpr;
      this._authType = value.authType;
      this._breakerRulesets = value.breakerRulesets;
      this._connections.internalValue = value.connections;
      this._credentialsSecret = value.credentialsSecret;
      this._cronSchedule = value.cronSchedule;
      this._description = value.description;
      this._disabled = value.disabled;
      this._earliest = value.earliest;
      this._encoding = value.encoding;
      this._endpoint = value.endpoint;
      this._endpointHeaders.internalValue = value.endpointHeaders;
      this._endpointParams.internalValue = value.endpointParams;
      this._environment = value.environment;
      this._id = value.id;
      this._ignoreGroupJobsLimit = value.ignoreGroupJobsLimit;
      this._jobTimeout = value.jobTimeout;
      this._keepAliveTime = value.keepAliveTime;
      this._latest = value.latest;
      this._logLevel = value.logLevel;
      this._loginUrl = value.loginUrl;
      this._maxMissedKeepAlives = value.maxMissedKeepAlives;
      this._metadata.internalValue = value.metadata;
      this._oauthHeaders.internalValue = value.oauthHeaders;
      this._oauthParams.internalValue = value.oauthParams;
      this._outputMode = value.outputMode;
      this._password = value.password;
      this._pipeline = value.pipeline;
      this._pq.internalValue = value.pq;
      this._pqEnabled = value.pqEnabled;
      this._rejectUnauthorized = value.rejectUnauthorized;
      this._requestTimeout = value.requestTimeout;
      this._retryRules.internalValue = value.retryRules;
      this._search = value.search;
      this._searchHead = value.searchHead;
      this._secret = value.secret;
      this._secretParamName = value.secretParamName;
      this._sendToRoutes = value.sendToRoutes;
      this._staleChannelFlushMs = value.staleChannelFlushMs;
      this._streamtags = value.streamtags;
      this._textSecret = value.textSecret;
      this._token = value.token;
      this._tokenAttributeName = value.tokenAttributeName;
      this._tokenTimeoutSecs = value.tokenTimeoutSecs;
      this._ttl = value.ttl;
      this._type = value.type;
      this._useRoundRobinDns = value.useRoundRobinDns;
      this._username = value.username;
    }
  }

  // auth_header_expr - computed: true, optional: true, required: false
  private _authHeaderExpr?: string; 
  public get authHeaderExpr() {
    return this.getStringAttribute('auth_header_expr');
  }
  public set authHeaderExpr(value: string) {
    this._authHeaderExpr = value;
  }
  public resetAuthHeaderExpr() {
    this._authHeaderExpr = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authHeaderExprInput() {
    return this._authHeaderExpr;
  }

  // auth_type - computed: true, optional: true, required: false
  private _authType?: string; 
  public get authType() {
    return this.getStringAttribute('auth_type');
  }
  public set authType(value: string) {
    this._authType = value;
  }
  public resetAuthType() {
    this._authType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authTypeInput() {
    return this._authType;
  }

  // breaker_rulesets - computed: true, optional: true, required: false
  private _breakerRulesets?: string[]; 
  public get breakerRulesets() {
    return this.getListAttribute('breaker_rulesets');
  }
  public set breakerRulesets(value: string[]) {
    this._breakerRulesets = value;
  }
  public resetBreakerRulesets() {
    this._breakerRulesets = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get breakerRulesetsInput() {
    return this._breakerRulesets;
  }

  // connections - computed: false, optional: true, required: false
  private _connections = new SourceInputSplunkSearchConnectionsList(this, "connections", false);
  public get connections() {
    return this._connections;
  }
  public putConnections(value: SourceInputSplunkSearchConnections[] | cdktf.IResolvable) {
    this._connections.internalValue = value;
  }
  public resetConnections() {
    this._connections.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectionsInput() {
    return this._connections.internalValue;
  }

  // credentials_secret - computed: false, optional: true, required: false
  private _credentialsSecret?: string; 
  public get credentialsSecret() {
    return this.getStringAttribute('credentials_secret');
  }
  public set credentialsSecret(value: string) {
    this._credentialsSecret = value;
  }
  public resetCredentialsSecret() {
    this._credentialsSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get credentialsSecretInput() {
    return this._credentialsSecret;
  }

  // cron_schedule - computed: true, optional: true, required: false
  private _cronSchedule?: string; 
  public get cronSchedule() {
    return this.getStringAttribute('cron_schedule');
  }
  public set cronSchedule(value: string) {
    this._cronSchedule = value;
  }
  public resetCronSchedule() {
    this._cronSchedule = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cronScheduleInput() {
    return this._cronSchedule;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // earliest - computed: true, optional: true, required: false
  private _earliest?: string; 
  public get earliest() {
    return this.getStringAttribute('earliest');
  }
  public set earliest(value: string) {
    this._earliest = value;
  }
  public resetEarliest() {
    this._earliest = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get earliestInput() {
    return this._earliest;
  }

  // encoding - computed: false, optional: true, required: false
  private _encoding?: string; 
  public get encoding() {
    return this.getStringAttribute('encoding');
  }
  public set encoding(value: string) {
    this._encoding = value;
  }
  public resetEncoding() {
    this._encoding = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get encodingInput() {
    return this._encoding;
  }

  // endpoint - computed: true, optional: true, required: false
  private _endpoint?: string; 
  public get endpoint() {
    return this.getStringAttribute('endpoint');
  }
  public set endpoint(value: string) {
    this._endpoint = value;
  }
  public resetEndpoint() {
    this._endpoint = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get endpointInput() {
    return this._endpoint;
  }

  // endpoint_headers - computed: false, optional: true, required: false
  private _endpointHeaders = new SourceInputSplunkSearchEndpointHeadersList(this, "endpoint_headers", false);
  public get endpointHeaders() {
    return this._endpointHeaders;
  }
  public putEndpointHeaders(value: SourceInputSplunkSearchEndpointHeaders[] | cdktf.IResolvable) {
    this._endpointHeaders.internalValue = value;
  }
  public resetEndpointHeaders() {
    this._endpointHeaders.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get endpointHeadersInput() {
    return this._endpointHeaders.internalValue;
  }

  // endpoint_params - computed: false, optional: true, required: false
  private _endpointParams = new SourceInputSplunkSearchEndpointParamsList(this, "endpoint_params", false);
  public get endpointParams() {
    return this._endpointParams;
  }
  public putEndpointParams(value: SourceInputSplunkSearchEndpointParams[] | cdktf.IResolvable) {
    this._endpointParams.internalValue = value;
  }
  public resetEndpointParams() {
    this._endpointParams.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get endpointParamsInput() {
    return this._endpointParams.internalValue;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // ignore_group_jobs_limit - computed: true, optional: true, required: false
  private _ignoreGroupJobsLimit?: boolean | cdktf.IResolvable; 
  public get ignoreGroupJobsLimit() {
    return this.getBooleanAttribute('ignore_group_jobs_limit');
  }
  public set ignoreGroupJobsLimit(value: boolean | cdktf.IResolvable) {
    this._ignoreGroupJobsLimit = value;
  }
  public resetIgnoreGroupJobsLimit() {
    this._ignoreGroupJobsLimit = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ignoreGroupJobsLimitInput() {
    return this._ignoreGroupJobsLimit;
  }

  // job_timeout - computed: true, optional: true, required: false
  private _jobTimeout?: string; 
  public get jobTimeout() {
    return this.getStringAttribute('job_timeout');
  }
  public set jobTimeout(value: string) {
    this._jobTimeout = value;
  }
  public resetJobTimeout() {
    this._jobTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get jobTimeoutInput() {
    return this._jobTimeout;
  }

  // keep_alive_time - computed: true, optional: true, required: false
  private _keepAliveTime?: number; 
  public get keepAliveTime() {
    return this.getNumberAttribute('keep_alive_time');
  }
  public set keepAliveTime(value: number) {
    this._keepAliveTime = value;
  }
  public resetKeepAliveTime() {
    this._keepAliveTime = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keepAliveTimeInput() {
    return this._keepAliveTime;
  }

  // latest - computed: true, optional: true, required: false
  private _latest?: string; 
  public get latest() {
    return this.getStringAttribute('latest');
  }
  public set latest(value: string) {
    this._latest = value;
  }
  public resetLatest() {
    this._latest = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get latestInput() {
    return this._latest;
  }

  // log_level - computed: false, optional: true, required: false
  private _logLevel?: string; 
  public get logLevel() {
    return this.getStringAttribute('log_level');
  }
  public set logLevel(value: string) {
    this._logLevel = value;
  }
  public resetLogLevel() {
    this._logLevel = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get logLevelInput() {
    return this._logLevel;
  }

  // login_url - computed: false, optional: true, required: false
  private _loginUrl?: string; 
  public get loginUrl() {
    return this.getStringAttribute('login_url');
  }
  public set loginUrl(value: string) {
    this._loginUrl = value;
  }
  public resetLoginUrl() {
    this._loginUrl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get loginUrlInput() {
    return this._loginUrl;
  }

  // max_missed_keep_alives - computed: true, optional: true, required: false
  private _maxMissedKeepAlives?: number; 
  public get maxMissedKeepAlives() {
    return this.getNumberAttribute('max_missed_keep_alives');
  }
  public set maxMissedKeepAlives(value: number) {
    this._maxMissedKeepAlives = value;
  }
  public resetMaxMissedKeepAlives() {
    this._maxMissedKeepAlives = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxMissedKeepAlivesInput() {
    return this._maxMissedKeepAlives;
  }

  // metadata - computed: false, optional: true, required: false
  private _metadata = new SourceInputSplunkSearchMetadataList(this, "metadata", false);
  public get metadata() {
    return this._metadata;
  }
  public putMetadata(value: SourceInputSplunkSearchMetadata[] | cdktf.IResolvable) {
    this._metadata.internalValue = value;
  }
  public resetMetadata() {
    this._metadata.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataInput() {
    return this._metadata.internalValue;
  }

  // oauth_headers - computed: false, optional: true, required: false
  private _oauthHeaders = new SourceInputSplunkSearchOauthHeadersList(this, "oauth_headers", false);
  public get oauthHeaders() {
    return this._oauthHeaders;
  }
  public putOauthHeaders(value: SourceInputSplunkSearchOauthHeaders[] | cdktf.IResolvable) {
    this._oauthHeaders.internalValue = value;
  }
  public resetOauthHeaders() {
    this._oauthHeaders.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get oauthHeadersInput() {
    return this._oauthHeaders.internalValue;
  }

  // oauth_params - computed: false, optional: true, required: false
  private _oauthParams = new SourceInputSplunkSearchOauthParamsList(this, "oauth_params", false);
  public get oauthParams() {
    return this._oauthParams;
  }
  public putOauthParams(value: SourceInputSplunkSearchOauthParams[] | cdktf.IResolvable) {
    this._oauthParams.internalValue = value;
  }
  public resetOauthParams() {
    this._oauthParams.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get oauthParamsInput() {
    return this._oauthParams.internalValue;
  }

  // output_mode - computed: true, optional: true, required: false
  private _outputMode?: string; 
  public get outputMode() {
    return this.getStringAttribute('output_mode');
  }
  public set outputMode(value: string) {
    this._outputMode = value;
  }
  public resetOutputMode() {
    this._outputMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get outputModeInput() {
    return this._outputMode;
  }

  // password - computed: false, optional: true, required: false
  private _password?: string; 
  public get password() {
    return this.getStringAttribute('password');
  }
  public set password(value: string) {
    this._password = value;
  }
  public resetPassword() {
    this._password = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passwordInput() {
    return this._password;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // pq - computed: false, optional: true, required: false
  private _pq = new SourceInputSplunkSearchPqOutputReference(this, "pq");
  public get pq() {
    return this._pq;
  }
  public putPq(value: SourceInputSplunkSearchPq) {
    this._pq.internalValue = value;
  }
  public resetPq() {
    this._pq.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqInput() {
    return this._pq.internalValue;
  }

  // pq_enabled - computed: true, optional: true, required: false
  private _pqEnabled?: boolean | cdktf.IResolvable; 
  public get pqEnabled() {
    return this.getBooleanAttribute('pq_enabled');
  }
  public set pqEnabled(value: boolean | cdktf.IResolvable) {
    this._pqEnabled = value;
  }
  public resetPqEnabled() {
    this._pqEnabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqEnabledInput() {
    return this._pqEnabled;
  }

  // reject_unauthorized - computed: true, optional: true, required: false
  private _rejectUnauthorized?: boolean | cdktf.IResolvable; 
  public get rejectUnauthorized() {
    return this.getBooleanAttribute('reject_unauthorized');
  }
  public set rejectUnauthorized(value: boolean | cdktf.IResolvable) {
    this._rejectUnauthorized = value;
  }
  public resetRejectUnauthorized() {
    this._rejectUnauthorized = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectUnauthorizedInput() {
    return this._rejectUnauthorized;
  }

  // request_timeout - computed: true, optional: true, required: false
  private _requestTimeout?: number; 
  public get requestTimeout() {
    return this.getNumberAttribute('request_timeout');
  }
  public set requestTimeout(value: number) {
    this._requestTimeout = value;
  }
  public resetRequestTimeout() {
    this._requestTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestTimeoutInput() {
    return this._requestTimeout;
  }

  // retry_rules - computed: false, optional: true, required: false
  private _retryRules = new SourceInputSplunkSearchRetryRulesOutputReference(this, "retry_rules");
  public get retryRules() {
    return this._retryRules;
  }
  public putRetryRules(value: SourceInputSplunkSearchRetryRules) {
    this._retryRules.internalValue = value;
  }
  public resetRetryRules() {
    this._retryRules.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get retryRulesInput() {
    return this._retryRules.internalValue;
  }

  // search - computed: false, optional: false, required: true
  private _search?: string; 
  public get search() {
    return this.getStringAttribute('search');
  }
  public set search(value: string) {
    this._search = value;
  }
  // Temporarily expose input value. Use with caution.
  public get searchInput() {
    return this._search;
  }

  // search_head - computed: true, optional: true, required: false
  private _searchHead?: string; 
  public get searchHead() {
    return this.getStringAttribute('search_head');
  }
  public set searchHead(value: string) {
    this._searchHead = value;
  }
  public resetSearchHead() {
    this._searchHead = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get searchHeadInput() {
    return this._searchHead;
  }

  // secret - computed: false, optional: true, required: false
  private _secret?: string; 
  public get secret() {
    return this.getStringAttribute('secret');
  }
  public set secret(value: string) {
    this._secret = value;
  }
  public resetSecret() {
    this._secret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretInput() {
    return this._secret;
  }

  // secret_param_name - computed: false, optional: true, required: false
  private _secretParamName?: string; 
  public get secretParamName() {
    return this.getStringAttribute('secret_param_name');
  }
  public set secretParamName(value: string) {
    this._secretParamName = value;
  }
  public resetSecretParamName() {
    this._secretParamName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get secretParamNameInput() {
    return this._secretParamName;
  }

  // send_to_routes - computed: true, optional: true, required: false
  private _sendToRoutes?: boolean | cdktf.IResolvable; 
  public get sendToRoutes() {
    return this.getBooleanAttribute('send_to_routes');
  }
  public set sendToRoutes(value: boolean | cdktf.IResolvable) {
    this._sendToRoutes = value;
  }
  public resetSendToRoutes() {
    this._sendToRoutes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sendToRoutesInput() {
    return this._sendToRoutes;
  }

  // stale_channel_flush_ms - computed: true, optional: true, required: false
  private _staleChannelFlushMs?: number; 
  public get staleChannelFlushMs() {
    return this.getNumberAttribute('stale_channel_flush_ms');
  }
  public set staleChannelFlushMs(value: number) {
    this._staleChannelFlushMs = value;
  }
  public resetStaleChannelFlushMs() {
    this._staleChannelFlushMs = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get staleChannelFlushMsInput() {
    return this._staleChannelFlushMs;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // text_secret - computed: false, optional: true, required: false
  private _textSecret?: string; 
  public get textSecret() {
    return this.getStringAttribute('text_secret');
  }
  public set textSecret(value: string) {
    this._textSecret = value;
  }
  public resetTextSecret() {
    this._textSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get textSecretInput() {
    return this._textSecret;
  }

  // token - computed: false, optional: true, required: false
  private _token?: string; 
  public get token() {
    return this.getStringAttribute('token');
  }
  public set token(value: string) {
    this._token = value;
  }
  public resetToken() {
    this._token = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tokenInput() {
    return this._token;
  }

  // token_attribute_name - computed: false, optional: true, required: false
  private _tokenAttributeName?: string; 
  public get tokenAttributeName() {
    return this.getStringAttribute('token_attribute_name');
  }
  public set tokenAttributeName(value: string) {
    this._tokenAttributeName = value;
  }
  public resetTokenAttributeName() {
    this._tokenAttributeName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tokenAttributeNameInput() {
    return this._tokenAttributeName;
  }

  // token_timeout_secs - computed: true, optional: true, required: false
  private _tokenTimeoutSecs?: number; 
  public get tokenTimeoutSecs() {
    return this.getNumberAttribute('token_timeout_secs');
  }
  public set tokenTimeoutSecs(value: number) {
    this._tokenTimeoutSecs = value;
  }
  public resetTokenTimeoutSecs() {
    this._tokenTimeoutSecs = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tokenTimeoutSecsInput() {
    return this._tokenTimeoutSecs;
  }

  // ttl - computed: true, optional: true, required: false
  private _ttl?: string; 
  public get ttl() {
    return this.getStringAttribute('ttl');
  }
  public set ttl(value: string) {
    this._ttl = value;
  }
  public resetTtl() {
    this._ttl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ttlInput() {
    return this._ttl;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // use_round_robin_dns - computed: true, optional: true, required: false
  private _useRoundRobinDns?: boolean | cdktf.IResolvable; 
  public get useRoundRobinDns() {
    return this.getBooleanAttribute('use_round_robin_dns');
  }
  public set useRoundRobinDns(value: boolean | cdktf.IResolvable) {
    this._useRoundRobinDns = value;
  }
  public resetUseRoundRobinDns() {
    this._useRoundRobinDns = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get useRoundRobinDnsInput() {
    return this._useRoundRobinDns;
  }

  // username - computed: false, optional: true, required: false
  private _username?: string; 
  public get username() {
    return this.getStringAttribute('username');
  }
  public set username(value: string) {
    this._username = value;
  }
  public resetUsername() {
    this._username = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get usernameInput() {
    return this._username;
  }
}
export interface SourceInputSqsConnections {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#output Source#output}
  */
  readonly output: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#pipeline Source#pipeline}
  */
  readonly pipeline?: string;
}

export function sourceInputSqsConnectionsToTerraform(struct?: SourceInputSqsConnections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    output: cdktf.stringToTerraform(struct!.output),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
  }
}


export function sourceInputSqsConnectionsToHclTerraform(struct?: SourceInputSqsConnections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    output: {
      value: cdktf.stringToHclTerraform(struct!.output),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputSqsConnectionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): SourceInputSqsConnections | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._output !== undefined) {
      hasAnyValues = true;
      internalValueResult.output = this._output;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputSqsConnections | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._output = undefined;
      this._pipeline = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._output = value.output;
      this._pipeline = value.pipeline;
    }
  }

  // output - computed: false, optional: false, required: true
  private _output?: string; 
  public get output() {
    return this.getStringAttribute('output');
  }
  public set output(value: string) {
    this._output = value;
  }
  // Temporarily expose input value. Use with caution.
  public get outputInput() {
    return this._output;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }
}

export class SourceInputSqsConnectionsList extends cdktf.ComplexList {
  public internalValue? : SourceInputSqsConnections[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): SourceInputSqsConnectionsOutputReference {
    return new SourceInputSqsConnectionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface SourceInputSqsMetadata {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#name Source#name}
  */
  readonly name: string;
  /**
  * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#value Source#value}
  */
  readonly value: string;
}

export function sourceInputSqsMetadataToTerraform(struct?: SourceInputSqsMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function sourceInputSqsMetadataToHclTerraform(struct?: SourceInputSqsMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputSqsMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): SourceInputSqsMetadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputSqsMetadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class SourceInputSqsMetadataList extends cdktf.ComplexList {
  public internalValue? : SourceInputSqsMetadata[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): SourceInputSqsMetadataOutputReference {
    return new SourceInputSqsMetadataOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface SourceInputSqsPq {
  /**
  * The number of events to send downstream before committing that Stream has read them. Default: 42
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#commit_frequency Source#commit_frequency}
  */
  readonly commitFrequency?: number;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#compress Source#compress}
  */
  readonly compress?: string;
  /**
  * The maximum number of events to hold in memory before writing the events to disk. Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_buffer_size Source#max_buffer_size}
  */
  readonly maxBufferSize?: number;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc. Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_file_size Source#max_file_size}
  */
  readonly maxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_size Source#max_size}
  */
  readonly maxSize?: string;
  /**
  * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine. Default: "always"; must be one of ["smart", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#mode Source#mode}
  */
  readonly mode?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#path Source#path}
  */
  readonly path?: string;
}

export function sourceInputSqsPqToTerraform(struct?: SourceInputSqsPq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    commit_frequency: cdktf.numberToTerraform(struct!.commitFrequency),
    compress: cdktf.stringToTerraform(struct!.compress),
    max_buffer_size: cdktf.numberToTerraform(struct!.maxBufferSize),
    max_file_size: cdktf.stringToTerraform(struct!.maxFileSize),
    max_size: cdktf.stringToTerraform(struct!.maxSize),
    mode: cdktf.stringToTerraform(struct!.mode),
    path: cdktf.stringToTerraform(struct!.path),
  }
}


export function sourceInputSqsPqToHclTerraform(struct?: SourceInputSqsPq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    commit_frequency: {
      value: cdktf.numberToHclTerraform(struct!.commitFrequency),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    compress: {
      value: cdktf.stringToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_buffer_size: {
      value: cdktf.numberToHclTerraform(struct!.maxBufferSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.maxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_size: {
      value: cdktf.stringToHclTerraform(struct!.maxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputSqsPqOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SourceInputSqsPq | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._commitFrequency !== undefined) {
      hasAnyValues = true;
      internalValueResult.commitFrequency = this._commitFrequency;
    }
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._maxBufferSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBufferSize = this._maxBufferSize;
    }
    if (this._maxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxFileSize = this._maxFileSize;
    }
    if (this._maxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxSize = this._maxSize;
    }
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputSqsPq | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._commitFrequency = undefined;
      this._compress = undefined;
      this._maxBufferSize = undefined;
      this._maxFileSize = undefined;
      this._maxSize = undefined;
      this._mode = undefined;
      this._path = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._commitFrequency = value.commitFrequency;
      this._compress = value.compress;
      this._maxBufferSize = value.maxBufferSize;
      this._maxFileSize = value.maxFileSize;
      this._maxSize = value.maxSize;
      this._mode = value.mode;
      this._path = value.path;
    }
  }

  // commit_frequency - computed: true, optional: true, required: false
  private _commitFrequency?: number; 
  public get commitFrequency() {
    return this.getNumberAttribute('commit_frequency');
  }
  public set commitFrequency(value: number) {
    this._commitFrequency = value;
  }
  public resetCommitFrequency() {
    this._commitFrequency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commitFrequencyInput() {
    return this._commitFrequency;
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: string; 
  public get compress() {
    return this.getStringAttribute('compress');
  }
  public set compress(value: string) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // max_buffer_size - computed: true, optional: true, required: false
  private _maxBufferSize?: number; 
  public get maxBufferSize() {
    return this.getNumberAttribute('max_buffer_size');
  }
  public set maxBufferSize(value: number) {
    this._maxBufferSize = value;
  }
  public resetMaxBufferSize() {
    this._maxBufferSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBufferSizeInput() {
    return this._maxBufferSize;
  }

  // max_file_size - computed: true, optional: true, required: false
  private _maxFileSize?: string; 
  public get maxFileSize() {
    return this.getStringAttribute('max_file_size');
  }
  public set maxFileSize(value: string) {
    this._maxFileSize = value;
  }
  public resetMaxFileSize() {
    this._maxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxFileSizeInput() {
    return this._maxFileSize;
  }

  // max_size - computed: true, optional: true, required: false
  private _maxSize?: string; 
  public get maxSize() {
    return this.getStringAttribute('max_size');
  }
  public set maxSize(value: string) {
    this._maxSize = value;
  }
  public resetMaxSize() {
    this._maxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxSizeInput() {
    return this._maxSize;
  }

  // mode - computed: true, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // path - computed: true, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }
}
export interface SourceInputSqs {
  /**
  * Amazon Resource Name (ARN) of the role to assume
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#assume_role_arn Source#assume_role_arn}
  */
  readonly assumeRoleArn?: string;
  /**
  * External ID to use when assuming role
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#assume_role_external_id Source#assume_role_external_id}
  */
  readonly assumeRoleExternalId?: string;
  /**
  * SQS queue owner's AWS account ID. Leave empty if SQS queue is in same AWS account.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#aws_account_id Source#aws_account_id}
  */
  readonly awsAccountId?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#aws_api_key Source#aws_api_key}
  */
  readonly awsApiKey?: string;
  /**
  * AWS authentication method. Choose Auto to use IAM roles. Default: "auto"; must be one of ["auto", "manual", "secret"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#aws_authentication_method Source#aws_authentication_method}
  */
  readonly awsAuthenticationMethod?: string;
  /**
  * Select or create a stored secret that references your access key and secret key
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#aws_secret Source#aws_secret}
  */
  readonly awsSecret?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#aws_secret_key Source#aws_secret_key}
  */
  readonly awsSecretKey?: string;
  /**
  * Direct connections to Destinations, and optionally via a Pipeline or a Pack
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#connections Source#connections}
  */
  readonly connections?: SourceInputSqsConnections[] | cdktf.IResolvable;
  /**
  * Create queue if it does not exist. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#create_queue Source#create_queue}
  */
  readonly createQueue?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#description Source#description}
  */
  readonly description?: string;
  /**
  * Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#disabled Source#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * Duration of the assumed role's session, in seconds. Minimum is 900 (15 minutes), default is 3600 (1 hour), and maximum is 43200 (12 hours). Default: 3600
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#duration_seconds Source#duration_seconds}
  */
  readonly durationSeconds?: number;
  /**
  * Use Assume Role credentials to access SQS. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#enable_assume_role Source#enable_assume_role}
  */
  readonly enableAssumeRole?: boolean | cdktf.IResolvable;
  /**
  * SQS service endpoint. If empty, defaults to the AWS Region-specific endpoint. Otherwise, it must point to SQS-compatible endpoint.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#endpoint Source#endpoint}
  */
  readonly endpoint?: string;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#environment Source#environment}
  */
  readonly environment?: string;
  /**
  * Unique ID for this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#id Source#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * The maximum number of messages SQS should return in a poll request. Amazon SQS never returns more messages than this value (however, fewer messages might be returned). Valid values: 1 to 10. Default: 10
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_messages Source#max_messages}
  */
  readonly maxMessages?: number;
  /**
  * Fields to add to events from this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#metadata Source#metadata}
  */
  readonly metadata?: SourceInputSqsMetadata[] | cdktf.IResolvable;
  /**
  * How many receiver processes to run. The higher the number, the better the throughput - at the expense of CPU overhead. Default: 3
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#num_receivers Source#num_receivers}
  */
  readonly numReceivers?: number;
  /**
  * Pipeline to process data from this Source before sending it through the Routes
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#pipeline Source#pipeline}
  */
  readonly pipeline?: string;
  /**
  * How long to wait for events before trying polling again. The lower the number the higher the AWS bill. The higher the number the longer it will take for the source to react to configuration changes and system restarts. Default: 10
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#poll_timeout Source#poll_timeout}
  */
  readonly pollTimeout?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#pq Source#pq}
  */
  readonly pq?: SourceInputSqsPq;
  /**
  * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers). Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#pq_enabled Source#pq_enabled}
  */
  readonly pqEnabled?: boolean | cdktf.IResolvable;
  /**
  * The name, URL, or ARN of the SQS queue to read events from. When a non-AWS URL is specified, format must be: '{url}/myQueueName'. Example: 'https://host:port/myQueueName'. Value must be a JavaScript expression (which can evaluate to a constant value), enclosed in quotes or backticks. Can only be evaluated at init time. Example referencing a Global Variable: `https://host:port/myQueue-${C.vars.myVar}`.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#queue_name Source#queue_name}
  */
  readonly queueName: string;
  /**
  * The queue type used (or created). Default: "standard"; must be one of ["standard", "fifo"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#queue_type Source#queue_type}
  */
  readonly queueType?: string;
  /**
  * AWS Region where the SQS queue is located. Required, unless the Queue entry is a URL or ARN that includes a Region.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#region Source#region}
  */
  readonly region?: string;
  /**
  * Reject certificates that cannot be verified against a valid CA, such as self-signed certificates. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#reject_unauthorized Source#reject_unauthorized}
  */
  readonly rejectUnauthorized?: boolean | cdktf.IResolvable;
  /**
  * Reuse connections between requests, which can improve performance. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#reuse_connections Source#reuse_connections}
  */
  readonly reuseConnections?: boolean | cdktf.IResolvable;
  /**
  * Select whether to send data to Routes, or directly to Destinations. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#send_to_routes Source#send_to_routes}
  */
  readonly sendToRoutes?: boolean | cdktf.IResolvable;
  /**
  * Signature version to use for signing SQS requests. Default: "v4"; must be one of ["v2", "v4"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#signature_version Source#signature_version}
  */
  readonly signatureVersion?: string;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#streamtags Source#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * must be "sqs"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#type Source#type}
  */
  readonly type?: string;
  /**
  * After messages are retrieved by a ReceiveMessage request, @{product} will hide them from subsequent retrieve requests for at least this duration. You can set this as high as 43200 sec. (12 hours). Default: 600
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#visibility_timeout Source#visibility_timeout}
  */
  readonly visibilityTimeout?: number;
}

export function sourceInputSqsToTerraform(struct?: SourceInputSqs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    assume_role_arn: cdktf.stringToTerraform(struct!.assumeRoleArn),
    assume_role_external_id: cdktf.stringToTerraform(struct!.assumeRoleExternalId),
    aws_account_id: cdktf.stringToTerraform(struct!.awsAccountId),
    aws_api_key: cdktf.stringToTerraform(struct!.awsApiKey),
    aws_authentication_method: cdktf.stringToTerraform(struct!.awsAuthenticationMethod),
    aws_secret: cdktf.stringToTerraform(struct!.awsSecret),
    aws_secret_key: cdktf.stringToTerraform(struct!.awsSecretKey),
    connections: cdktf.listMapper(sourceInputSqsConnectionsToTerraform, false)(struct!.connections),
    create_queue: cdktf.booleanToTerraform(struct!.createQueue),
    description: cdktf.stringToTerraform(struct!.description),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    duration_seconds: cdktf.numberToTerraform(struct!.durationSeconds),
    enable_assume_role: cdktf.booleanToTerraform(struct!.enableAssumeRole),
    endpoint: cdktf.stringToTerraform(struct!.endpoint),
    environment: cdktf.stringToTerraform(struct!.environment),
    id: cdktf.stringToTerraform(struct!.id),
    max_messages: cdktf.numberToTerraform(struct!.maxMessages),
    metadata: cdktf.listMapper(sourceInputSqsMetadataToTerraform, false)(struct!.metadata),
    num_receivers: cdktf.numberToTerraform(struct!.numReceivers),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    poll_timeout: cdktf.numberToTerraform(struct!.pollTimeout),
    pq: sourceInputSqsPqToTerraform(struct!.pq),
    pq_enabled: cdktf.booleanToTerraform(struct!.pqEnabled),
    queue_name: cdktf.stringToTerraform(struct!.queueName),
    queue_type: cdktf.stringToTerraform(struct!.queueType),
    region: cdktf.stringToTerraform(struct!.region),
    reject_unauthorized: cdktf.booleanToTerraform(struct!.rejectUnauthorized),
    reuse_connections: cdktf.booleanToTerraform(struct!.reuseConnections),
    send_to_routes: cdktf.booleanToTerraform(struct!.sendToRoutes),
    signature_version: cdktf.stringToTerraform(struct!.signatureVersion),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    type: cdktf.stringToTerraform(struct!.type),
    visibility_timeout: cdktf.numberToTerraform(struct!.visibilityTimeout),
  }
}


export function sourceInputSqsToHclTerraform(struct?: SourceInputSqs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    assume_role_arn: {
      value: cdktf.stringToHclTerraform(struct!.assumeRoleArn),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    assume_role_external_id: {
      value: cdktf.stringToHclTerraform(struct!.assumeRoleExternalId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    aws_account_id: {
      value: cdktf.stringToHclTerraform(struct!.awsAccountId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    aws_api_key: {
      value: cdktf.stringToHclTerraform(struct!.awsApiKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    aws_authentication_method: {
      value: cdktf.stringToHclTerraform(struct!.awsAuthenticationMethod),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    aws_secret: {
      value: cdktf.stringToHclTerraform(struct!.awsSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    aws_secret_key: {
      value: cdktf.stringToHclTerraform(struct!.awsSecretKey),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    connections: {
      value: cdktf.listMapperHcl(sourceInputSqsConnectionsToHclTerraform, false)(struct!.connections),
      isBlock: true,
      type: "list",
      storageClassType: "SourceInputSqsConnectionsList",
    },
    create_queue: {
      value: cdktf.booleanToHclTerraform(struct!.createQueue),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    duration_seconds: {
      value: cdktf.numberToHclTerraform(struct!.durationSeconds),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    enable_assume_role: {
      value: cdktf.booleanToHclTerraform(struct!.enableAssumeRole),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    endpoint: {
      value: cdktf.stringToHclTerraform(struct!.endpoint),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_messages: {
      value: cdktf.numberToHclTerraform(struct!.maxMessages),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    metadata: {
      value: cdktf.listMapperHcl(sourceInputSqsMetadataToHclTerraform, false)(struct!.metadata),
      isBlock: true,
      type: "list",
      storageClassType: "SourceInputSqsMetadataList",
    },
    num_receivers: {
      value: cdktf.numberToHclTerraform(struct!.numReceivers),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    poll_timeout: {
      value: cdktf.numberToHclTerraform(struct!.pollTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    pq: {
      value: sourceInputSqsPqToHclTerraform(struct!.pq),
      isBlock: true,
      type: "struct",
      storageClassType: "SourceInputSqsPq",
    },
    pq_enabled: {
      value: cdktf.booleanToHclTerraform(struct!.pqEnabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    queue_name: {
      value: cdktf.stringToHclTerraform(struct!.queueName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    queue_type: {
      value: cdktf.stringToHclTerraform(struct!.queueType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    region: {
      value: cdktf.stringToHclTerraform(struct!.region),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reject_unauthorized: {
      value: cdktf.booleanToHclTerraform(struct!.rejectUnauthorized),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    reuse_connections: {
      value: cdktf.booleanToHclTerraform(struct!.reuseConnections),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    send_to_routes: {
      value: cdktf.booleanToHclTerraform(struct!.sendToRoutes),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    signature_version: {
      value: cdktf.stringToHclTerraform(struct!.signatureVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    visibility_timeout: {
      value: cdktf.numberToHclTerraform(struct!.visibilityTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputSqsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SourceInputSqs | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._assumeRoleArn !== undefined) {
      hasAnyValues = true;
      internalValueResult.assumeRoleArn = this._assumeRoleArn;
    }
    if (this._assumeRoleExternalId !== undefined) {
      hasAnyValues = true;
      internalValueResult.assumeRoleExternalId = this._assumeRoleExternalId;
    }
    if (this._awsAccountId !== undefined) {
      hasAnyValues = true;
      internalValueResult.awsAccountId = this._awsAccountId;
    }
    if (this._awsApiKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.awsApiKey = this._awsApiKey;
    }
    if (this._awsAuthenticationMethod !== undefined) {
      hasAnyValues = true;
      internalValueResult.awsAuthenticationMethod = this._awsAuthenticationMethod;
    }
    if (this._awsSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.awsSecret = this._awsSecret;
    }
    if (this._awsSecretKey !== undefined) {
      hasAnyValues = true;
      internalValueResult.awsSecretKey = this._awsSecretKey;
    }
    if (this._connections?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.connections = this._connections?.internalValue;
    }
    if (this._createQueue !== undefined) {
      hasAnyValues = true;
      internalValueResult.createQueue = this._createQueue;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._durationSeconds !== undefined) {
      hasAnyValues = true;
      internalValueResult.durationSeconds = this._durationSeconds;
    }
    if (this._enableAssumeRole !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableAssumeRole = this._enableAssumeRole;
    }
    if (this._endpoint !== undefined) {
      hasAnyValues = true;
      internalValueResult.endpoint = this._endpoint;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._maxMessages !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxMessages = this._maxMessages;
    }
    if (this._metadata?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadata = this._metadata?.internalValue;
    }
    if (this._numReceivers !== undefined) {
      hasAnyValues = true;
      internalValueResult.numReceivers = this._numReceivers;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._pollTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.pollTimeout = this._pollTimeout;
    }
    if (this._pq?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pq = this._pq?.internalValue;
    }
    if (this._pqEnabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqEnabled = this._pqEnabled;
    }
    if (this._queueName !== undefined) {
      hasAnyValues = true;
      internalValueResult.queueName = this._queueName;
    }
    if (this._queueType !== undefined) {
      hasAnyValues = true;
      internalValueResult.queueType = this._queueType;
    }
    if (this._region !== undefined) {
      hasAnyValues = true;
      internalValueResult.region = this._region;
    }
    if (this._rejectUnauthorized !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectUnauthorized = this._rejectUnauthorized;
    }
    if (this._reuseConnections !== undefined) {
      hasAnyValues = true;
      internalValueResult.reuseConnections = this._reuseConnections;
    }
    if (this._sendToRoutes !== undefined) {
      hasAnyValues = true;
      internalValueResult.sendToRoutes = this._sendToRoutes;
    }
    if (this._signatureVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.signatureVersion = this._signatureVersion;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._visibilityTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.visibilityTimeout = this._visibilityTimeout;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputSqs | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._assumeRoleArn = undefined;
      this._assumeRoleExternalId = undefined;
      this._awsAccountId = undefined;
      this._awsApiKey = undefined;
      this._awsAuthenticationMethod = undefined;
      this._awsSecret = undefined;
      this._awsSecretKey = undefined;
      this._connections.internalValue = undefined;
      this._createQueue = undefined;
      this._description = undefined;
      this._disabled = undefined;
      this._durationSeconds = undefined;
      this._enableAssumeRole = undefined;
      this._endpoint = undefined;
      this._environment = undefined;
      this._id = undefined;
      this._maxMessages = undefined;
      this._metadata.internalValue = undefined;
      this._numReceivers = undefined;
      this._pipeline = undefined;
      this._pollTimeout = undefined;
      this._pq.internalValue = undefined;
      this._pqEnabled = undefined;
      this._queueName = undefined;
      this._queueType = undefined;
      this._region = undefined;
      this._rejectUnauthorized = undefined;
      this._reuseConnections = undefined;
      this._sendToRoutes = undefined;
      this._signatureVersion = undefined;
      this._streamtags = undefined;
      this._type = undefined;
      this._visibilityTimeout = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._assumeRoleArn = value.assumeRoleArn;
      this._assumeRoleExternalId = value.assumeRoleExternalId;
      this._awsAccountId = value.awsAccountId;
      this._awsApiKey = value.awsApiKey;
      this._awsAuthenticationMethod = value.awsAuthenticationMethod;
      this._awsSecret = value.awsSecret;
      this._awsSecretKey = value.awsSecretKey;
      this._connections.internalValue = value.connections;
      this._createQueue = value.createQueue;
      this._description = value.description;
      this._disabled = value.disabled;
      this._durationSeconds = value.durationSeconds;
      this._enableAssumeRole = value.enableAssumeRole;
      this._endpoint = value.endpoint;
      this._environment = value.environment;
      this._id = value.id;
      this._maxMessages = value.maxMessages;
      this._metadata.internalValue = value.metadata;
      this._numReceivers = value.numReceivers;
      this._pipeline = value.pipeline;
      this._pollTimeout = value.pollTimeout;
      this._pq.internalValue = value.pq;
      this._pqEnabled = value.pqEnabled;
      this._queueName = value.queueName;
      this._queueType = value.queueType;
      this._region = value.region;
      this._rejectUnauthorized = value.rejectUnauthorized;
      this._reuseConnections = value.reuseConnections;
      this._sendToRoutes = value.sendToRoutes;
      this._signatureVersion = value.signatureVersion;
      this._streamtags = value.streamtags;
      this._type = value.type;
      this._visibilityTimeout = value.visibilityTimeout;
    }
  }

  // assume_role_arn - computed: false, optional: true, required: false
  private _assumeRoleArn?: string; 
  public get assumeRoleArn() {
    return this.getStringAttribute('assume_role_arn');
  }
  public set assumeRoleArn(value: string) {
    this._assumeRoleArn = value;
  }
  public resetAssumeRoleArn() {
    this._assumeRoleArn = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get assumeRoleArnInput() {
    return this._assumeRoleArn;
  }

  // assume_role_external_id - computed: false, optional: true, required: false
  private _assumeRoleExternalId?: string; 
  public get assumeRoleExternalId() {
    return this.getStringAttribute('assume_role_external_id');
  }
  public set assumeRoleExternalId(value: string) {
    this._assumeRoleExternalId = value;
  }
  public resetAssumeRoleExternalId() {
    this._assumeRoleExternalId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get assumeRoleExternalIdInput() {
    return this._assumeRoleExternalId;
  }

  // aws_account_id - computed: false, optional: true, required: false
  private _awsAccountId?: string; 
  public get awsAccountId() {
    return this.getStringAttribute('aws_account_id');
  }
  public set awsAccountId(value: string) {
    this._awsAccountId = value;
  }
  public resetAwsAccountId() {
    this._awsAccountId = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsAccountIdInput() {
    return this._awsAccountId;
  }

  // aws_api_key - computed: false, optional: true, required: false
  private _awsApiKey?: string; 
  public get awsApiKey() {
    return this.getStringAttribute('aws_api_key');
  }
  public set awsApiKey(value: string) {
    this._awsApiKey = value;
  }
  public resetAwsApiKey() {
    this._awsApiKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsApiKeyInput() {
    return this._awsApiKey;
  }

  // aws_authentication_method - computed: true, optional: true, required: false
  private _awsAuthenticationMethod?: string; 
  public get awsAuthenticationMethod() {
    return this.getStringAttribute('aws_authentication_method');
  }
  public set awsAuthenticationMethod(value: string) {
    this._awsAuthenticationMethod = value;
  }
  public resetAwsAuthenticationMethod() {
    this._awsAuthenticationMethod = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsAuthenticationMethodInput() {
    return this._awsAuthenticationMethod;
  }

  // aws_secret - computed: false, optional: true, required: false
  private _awsSecret?: string; 
  public get awsSecret() {
    return this.getStringAttribute('aws_secret');
  }
  public set awsSecret(value: string) {
    this._awsSecret = value;
  }
  public resetAwsSecret() {
    this._awsSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsSecretInput() {
    return this._awsSecret;
  }

  // aws_secret_key - computed: false, optional: true, required: false
  private _awsSecretKey?: string; 
  public get awsSecretKey() {
    return this.getStringAttribute('aws_secret_key');
  }
  public set awsSecretKey(value: string) {
    this._awsSecretKey = value;
  }
  public resetAwsSecretKey() {
    this._awsSecretKey = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get awsSecretKeyInput() {
    return this._awsSecretKey;
  }

  // connections - computed: false, optional: true, required: false
  private _connections = new SourceInputSqsConnectionsList(this, "connections", false);
  public get connections() {
    return this._connections;
  }
  public putConnections(value: SourceInputSqsConnections[] | cdktf.IResolvable) {
    this._connections.internalValue = value;
  }
  public resetConnections() {
    this._connections.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectionsInput() {
    return this._connections.internalValue;
  }

  // create_queue - computed: true, optional: true, required: false
  private _createQueue?: boolean | cdktf.IResolvable; 
  public get createQueue() {
    return this.getBooleanAttribute('create_queue');
  }
  public set createQueue(value: boolean | cdktf.IResolvable) {
    this._createQueue = value;
  }
  public resetCreateQueue() {
    this._createQueue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get createQueueInput() {
    return this._createQueue;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // duration_seconds - computed: true, optional: true, required: false
  private _durationSeconds?: number; 
  public get durationSeconds() {
    return this.getNumberAttribute('duration_seconds');
  }
  public set durationSeconds(value: number) {
    this._durationSeconds = value;
  }
  public resetDurationSeconds() {
    this._durationSeconds = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get durationSecondsInput() {
    return this._durationSeconds;
  }

  // enable_assume_role - computed: true, optional: true, required: false
  private _enableAssumeRole?: boolean | cdktf.IResolvable; 
  public get enableAssumeRole() {
    return this.getBooleanAttribute('enable_assume_role');
  }
  public set enableAssumeRole(value: boolean | cdktf.IResolvable) {
    this._enableAssumeRole = value;
  }
  public resetEnableAssumeRole() {
    this._enableAssumeRole = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableAssumeRoleInput() {
    return this._enableAssumeRole;
  }

  // endpoint - computed: false, optional: true, required: false
  private _endpoint?: string; 
  public get endpoint() {
    return this.getStringAttribute('endpoint');
  }
  public set endpoint(value: string) {
    this._endpoint = value;
  }
  public resetEndpoint() {
    this._endpoint = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get endpointInput() {
    return this._endpoint;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // max_messages - computed: true, optional: true, required: false
  private _maxMessages?: number; 
  public get maxMessages() {
    return this.getNumberAttribute('max_messages');
  }
  public set maxMessages(value: number) {
    this._maxMessages = value;
  }
  public resetMaxMessages() {
    this._maxMessages = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxMessagesInput() {
    return this._maxMessages;
  }

  // metadata - computed: false, optional: true, required: false
  private _metadata = new SourceInputSqsMetadataList(this, "metadata", false);
  public get metadata() {
    return this._metadata;
  }
  public putMetadata(value: SourceInputSqsMetadata[] | cdktf.IResolvable) {
    this._metadata.internalValue = value;
  }
  public resetMetadata() {
    this._metadata.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataInput() {
    return this._metadata.internalValue;
  }

  // num_receivers - computed: true, optional: true, required: false
  private _numReceivers?: number; 
  public get numReceivers() {
    return this.getNumberAttribute('num_receivers');
  }
  public set numReceivers(value: number) {
    this._numReceivers = value;
  }
  public resetNumReceivers() {
    this._numReceivers = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get numReceiversInput() {
    return this._numReceivers;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // poll_timeout - computed: true, optional: true, required: false
  private _pollTimeout?: number; 
  public get pollTimeout() {
    return this.getNumberAttribute('poll_timeout');
  }
  public set pollTimeout(value: number) {
    this._pollTimeout = value;
  }
  public resetPollTimeout() {
    this._pollTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pollTimeoutInput() {
    return this._pollTimeout;
  }

  // pq - computed: false, optional: true, required: false
  private _pq = new SourceInputSqsPqOutputReference(this, "pq");
  public get pq() {
    return this._pq;
  }
  public putPq(value: SourceInputSqsPq) {
    this._pq.internalValue = value;
  }
  public resetPq() {
    this._pq.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqInput() {
    return this._pq.internalValue;
  }

  // pq_enabled - computed: true, optional: true, required: false
  private _pqEnabled?: boolean | cdktf.IResolvable; 
  public get pqEnabled() {
    return this.getBooleanAttribute('pq_enabled');
  }
  public set pqEnabled(value: boolean | cdktf.IResolvable) {
    this._pqEnabled = value;
  }
  public resetPqEnabled() {
    this._pqEnabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqEnabledInput() {
    return this._pqEnabled;
  }

  // queue_name - computed: false, optional: false, required: true
  private _queueName?: string; 
  public get queueName() {
    return this.getStringAttribute('queue_name');
  }
  public set queueName(value: string) {
    this._queueName = value;
  }
  // Temporarily expose input value. Use with caution.
  public get queueNameInput() {
    return this._queueName;
  }

  // queue_type - computed: true, optional: true, required: false
  private _queueType?: string; 
  public get queueType() {
    return this.getStringAttribute('queue_type');
  }
  public set queueType(value: string) {
    this._queueType = value;
  }
  public resetQueueType() {
    this._queueType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get queueTypeInput() {
    return this._queueType;
  }

  // region - computed: false, optional: true, required: false
  private _region?: string; 
  public get region() {
    return this.getStringAttribute('region');
  }
  public set region(value: string) {
    this._region = value;
  }
  public resetRegion() {
    this._region = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get regionInput() {
    return this._region;
  }

  // reject_unauthorized - computed: true, optional: true, required: false
  private _rejectUnauthorized?: boolean | cdktf.IResolvable; 
  public get rejectUnauthorized() {
    return this.getBooleanAttribute('reject_unauthorized');
  }
  public set rejectUnauthorized(value: boolean | cdktf.IResolvable) {
    this._rejectUnauthorized = value;
  }
  public resetRejectUnauthorized() {
    this._rejectUnauthorized = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectUnauthorizedInput() {
    return this._rejectUnauthorized;
  }

  // reuse_connections - computed: true, optional: true, required: false
  private _reuseConnections?: boolean | cdktf.IResolvable; 
  public get reuseConnections() {
    return this.getBooleanAttribute('reuse_connections');
  }
  public set reuseConnections(value: boolean | cdktf.IResolvable) {
    this._reuseConnections = value;
  }
  public resetReuseConnections() {
    this._reuseConnections = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get reuseConnectionsInput() {
    return this._reuseConnections;
  }

  // send_to_routes - computed: true, optional: true, required: false
  private _sendToRoutes?: boolean | cdktf.IResolvable; 
  public get sendToRoutes() {
    return this.getBooleanAttribute('send_to_routes');
  }
  public set sendToRoutes(value: boolean | cdktf.IResolvable) {
    this._sendToRoutes = value;
  }
  public resetSendToRoutes() {
    this._sendToRoutes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sendToRoutesInput() {
    return this._sendToRoutes;
  }

  // signature_version - computed: true, optional: true, required: false
  private _signatureVersion?: string; 
  public get signatureVersion() {
    return this.getStringAttribute('signature_version');
  }
  public set signatureVersion(value: string) {
    this._signatureVersion = value;
  }
  public resetSignatureVersion() {
    this._signatureVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get signatureVersionInput() {
    return this._signatureVersion;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // visibility_timeout - computed: true, optional: true, required: false
  private _visibilityTimeout?: number; 
  public get visibilityTimeout() {
    return this.getNumberAttribute('visibility_timeout');
  }
  public set visibilityTimeout(value: number) {
    this._visibilityTimeout = value;
  }
  public resetVisibilityTimeout() {
    this._visibilityTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get visibilityTimeoutInput() {
    return this._visibilityTimeout;
  }
}
export interface SourceInputSyslogInputSyslogSyslog1Connections {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#output Source#output}
  */
  readonly output: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#pipeline Source#pipeline}
  */
  readonly pipeline?: string;
}

export function sourceInputSyslogInputSyslogSyslog1ConnectionsToTerraform(struct?: SourceInputSyslogInputSyslogSyslog1Connections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    output: cdktf.stringToTerraform(struct!.output),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
  }
}


export function sourceInputSyslogInputSyslogSyslog1ConnectionsToHclTerraform(struct?: SourceInputSyslogInputSyslogSyslog1Connections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    output: {
      value: cdktf.stringToHclTerraform(struct!.output),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputSyslogInputSyslogSyslog1ConnectionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): SourceInputSyslogInputSyslogSyslog1Connections | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._output !== undefined) {
      hasAnyValues = true;
      internalValueResult.output = this._output;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputSyslogInputSyslogSyslog1Connections | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._output = undefined;
      this._pipeline = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._output = value.output;
      this._pipeline = value.pipeline;
    }
  }

  // output - computed: false, optional: false, required: true
  private _output?: string; 
  public get output() {
    return this.getStringAttribute('output');
  }
  public set output(value: string) {
    this._output = value;
  }
  // Temporarily expose input value. Use with caution.
  public get outputInput() {
    return this._output;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }
}

export class SourceInputSyslogInputSyslogSyslog1ConnectionsList extends cdktf.ComplexList {
  public internalValue? : SourceInputSyslogInputSyslogSyslog1Connections[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): SourceInputSyslogInputSyslogSyslog1ConnectionsOutputReference {
    return new SourceInputSyslogInputSyslogSyslog1ConnectionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface SourceInputSyslogInputSyslogSyslog1Metadata {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#name Source#name}
  */
  readonly name: string;
  /**
  * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#value Source#value}
  */
  readonly value: string;
}

export function sourceInputSyslogInputSyslogSyslog1MetadataToTerraform(struct?: SourceInputSyslogInputSyslogSyslog1Metadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function sourceInputSyslogInputSyslogSyslog1MetadataToHclTerraform(struct?: SourceInputSyslogInputSyslogSyslog1Metadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputSyslogInputSyslogSyslog1MetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): SourceInputSyslogInputSyslogSyslog1Metadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputSyslogInputSyslogSyslog1Metadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class SourceInputSyslogInputSyslogSyslog1MetadataList extends cdktf.ComplexList {
  public internalValue? : SourceInputSyslogInputSyslogSyslog1Metadata[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): SourceInputSyslogInputSyslogSyslog1MetadataOutputReference {
    return new SourceInputSyslogInputSyslogSyslog1MetadataOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface SourceInputSyslogInputSyslogSyslog1Pq {
  /**
  * The number of events to send downstream before committing that Stream has read them. Default: 42
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#commit_frequency Source#commit_frequency}
  */
  readonly commitFrequency?: number;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#compress Source#compress}
  */
  readonly compress?: string;
  /**
  * The maximum number of events to hold in memory before writing the events to disk. Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_buffer_size Source#max_buffer_size}
  */
  readonly maxBufferSize?: number;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc. Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_file_size Source#max_file_size}
  */
  readonly maxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_size Source#max_size}
  */
  readonly maxSize?: string;
  /**
  * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine. Default: "always"; must be one of ["smart", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#mode Source#mode}
  */
  readonly mode?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#path Source#path}
  */
  readonly path?: string;
}

export function sourceInputSyslogInputSyslogSyslog1PqToTerraform(struct?: SourceInputSyslogInputSyslogSyslog1Pq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    commit_frequency: cdktf.numberToTerraform(struct!.commitFrequency),
    compress: cdktf.stringToTerraform(struct!.compress),
    max_buffer_size: cdktf.numberToTerraform(struct!.maxBufferSize),
    max_file_size: cdktf.stringToTerraform(struct!.maxFileSize),
    max_size: cdktf.stringToTerraform(struct!.maxSize),
    mode: cdktf.stringToTerraform(struct!.mode),
    path: cdktf.stringToTerraform(struct!.path),
  }
}


export function sourceInputSyslogInputSyslogSyslog1PqToHclTerraform(struct?: SourceInputSyslogInputSyslogSyslog1Pq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    commit_frequency: {
      value: cdktf.numberToHclTerraform(struct!.commitFrequency),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    compress: {
      value: cdktf.stringToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_buffer_size: {
      value: cdktf.numberToHclTerraform(struct!.maxBufferSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.maxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_size: {
      value: cdktf.stringToHclTerraform(struct!.maxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputSyslogInputSyslogSyslog1PqOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SourceInputSyslogInputSyslogSyslog1Pq | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._commitFrequency !== undefined) {
      hasAnyValues = true;
      internalValueResult.commitFrequency = this._commitFrequency;
    }
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._maxBufferSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBufferSize = this._maxBufferSize;
    }
    if (this._maxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxFileSize = this._maxFileSize;
    }
    if (this._maxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxSize = this._maxSize;
    }
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputSyslogInputSyslogSyslog1Pq | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._commitFrequency = undefined;
      this._compress = undefined;
      this._maxBufferSize = undefined;
      this._maxFileSize = undefined;
      this._maxSize = undefined;
      this._mode = undefined;
      this._path = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._commitFrequency = value.commitFrequency;
      this._compress = value.compress;
      this._maxBufferSize = value.maxBufferSize;
      this._maxFileSize = value.maxFileSize;
      this._maxSize = value.maxSize;
      this._mode = value.mode;
      this._path = value.path;
    }
  }

  // commit_frequency - computed: true, optional: true, required: false
  private _commitFrequency?: number; 
  public get commitFrequency() {
    return this.getNumberAttribute('commit_frequency');
  }
  public set commitFrequency(value: number) {
    this._commitFrequency = value;
  }
  public resetCommitFrequency() {
    this._commitFrequency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commitFrequencyInput() {
    return this._commitFrequency;
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: string; 
  public get compress() {
    return this.getStringAttribute('compress');
  }
  public set compress(value: string) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // max_buffer_size - computed: true, optional: true, required: false
  private _maxBufferSize?: number; 
  public get maxBufferSize() {
    return this.getNumberAttribute('max_buffer_size');
  }
  public set maxBufferSize(value: number) {
    this._maxBufferSize = value;
  }
  public resetMaxBufferSize() {
    this._maxBufferSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBufferSizeInput() {
    return this._maxBufferSize;
  }

  // max_file_size - computed: true, optional: true, required: false
  private _maxFileSize?: string; 
  public get maxFileSize() {
    return this.getStringAttribute('max_file_size');
  }
  public set maxFileSize(value: string) {
    this._maxFileSize = value;
  }
  public resetMaxFileSize() {
    this._maxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxFileSizeInput() {
    return this._maxFileSize;
  }

  // max_size - computed: true, optional: true, required: false
  private _maxSize?: string; 
  public get maxSize() {
    return this.getStringAttribute('max_size');
  }
  public set maxSize(value: string) {
    this._maxSize = value;
  }
  public resetMaxSize() {
    this._maxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxSizeInput() {
    return this._maxSize;
  }

  // mode - computed: true, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // path - computed: true, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }
}
export interface SourceInputSyslogInputSyslogSyslog1Tls {
  /**
  * Path on server containing CA certificates to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#ca_path Source#ca_path}
  */
  readonly caPath?: string;
  /**
  * Path on server containing certificates to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#cert_path Source#cert_path}
  */
  readonly certPath?: string;
  /**
  * The name of the predefined certificate
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#certificate_name Source#certificate_name}
  */
  readonly certificateName?: string;
  /**
  * Parsed as JSON.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#common_name_regex Source#common_name_regex}
  */
  readonly commonNameRegex?: string;
  /**
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#disabled Source#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_version Source#max_version}
  */
  readonly maxVersion?: string;
  /**
  * must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#min_version Source#min_version}
  */
  readonly minVersion?: string;
  /**
  * Passphrase to use to decrypt private key
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#passphrase Source#passphrase}
  */
  readonly passphrase?: string;
  /**
  * Path on server containing the private key to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#priv_key_path Source#priv_key_path}
  */
  readonly privKeyPath?: string;
  /**
  * Parsed as JSON.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#reject_unauthorized Source#reject_unauthorized}
  */
  readonly rejectUnauthorized?: string;
  /**
  * Require clients to present their certificates. Used to perform client authentication using SSL certs. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#request_cert Source#request_cert}
  */
  readonly requestCert?: boolean | cdktf.IResolvable;
}

export function sourceInputSyslogInputSyslogSyslog1TlsToTerraform(struct?: SourceInputSyslogInputSyslogSyslog1Tls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ca_path: cdktf.stringToTerraform(struct!.caPath),
    cert_path: cdktf.stringToTerraform(struct!.certPath),
    certificate_name: cdktf.stringToTerraform(struct!.certificateName),
    common_name_regex: cdktf.stringToTerraform(struct!.commonNameRegex),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    max_version: cdktf.stringToTerraform(struct!.maxVersion),
    min_version: cdktf.stringToTerraform(struct!.minVersion),
    passphrase: cdktf.stringToTerraform(struct!.passphrase),
    priv_key_path: cdktf.stringToTerraform(struct!.privKeyPath),
    reject_unauthorized: cdktf.stringToTerraform(struct!.rejectUnauthorized),
    request_cert: cdktf.booleanToTerraform(struct!.requestCert),
  }
}


export function sourceInputSyslogInputSyslogSyslog1TlsToHclTerraform(struct?: SourceInputSyslogInputSyslogSyslog1Tls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ca_path: {
      value: cdktf.stringToHclTerraform(struct!.caPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    cert_path: {
      value: cdktf.stringToHclTerraform(struct!.certPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    certificate_name: {
      value: cdktf.stringToHclTerraform(struct!.certificateName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    common_name_regex: {
      value: cdktf.stringToHclTerraform(struct!.commonNameRegex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    max_version: {
      value: cdktf.stringToHclTerraform(struct!.maxVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    min_version: {
      value: cdktf.stringToHclTerraform(struct!.minVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    passphrase: {
      value: cdktf.stringToHclTerraform(struct!.passphrase),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    priv_key_path: {
      value: cdktf.stringToHclTerraform(struct!.privKeyPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reject_unauthorized: {
      value: cdktf.stringToHclTerraform(struct!.rejectUnauthorized),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    request_cert: {
      value: cdktf.booleanToHclTerraform(struct!.requestCert),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputSyslogInputSyslogSyslog1TlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SourceInputSyslogInputSyslogSyslog1Tls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._caPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.caPath = this._caPath;
    }
    if (this._certPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.certPath = this._certPath;
    }
    if (this._certificateName !== undefined) {
      hasAnyValues = true;
      internalValueResult.certificateName = this._certificateName;
    }
    if (this._commonNameRegex !== undefined) {
      hasAnyValues = true;
      internalValueResult.commonNameRegex = this._commonNameRegex;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._maxVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxVersion = this._maxVersion;
    }
    if (this._minVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.minVersion = this._minVersion;
    }
    if (this._passphrase !== undefined) {
      hasAnyValues = true;
      internalValueResult.passphrase = this._passphrase;
    }
    if (this._privKeyPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.privKeyPath = this._privKeyPath;
    }
    if (this._rejectUnauthorized !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectUnauthorized = this._rejectUnauthorized;
    }
    if (this._requestCert !== undefined) {
      hasAnyValues = true;
      internalValueResult.requestCert = this._requestCert;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputSyslogInputSyslogSyslog1Tls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._caPath = undefined;
      this._certPath = undefined;
      this._certificateName = undefined;
      this._commonNameRegex = undefined;
      this._disabled = undefined;
      this._maxVersion = undefined;
      this._minVersion = undefined;
      this._passphrase = undefined;
      this._privKeyPath = undefined;
      this._rejectUnauthorized = undefined;
      this._requestCert = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._caPath = value.caPath;
      this._certPath = value.certPath;
      this._certificateName = value.certificateName;
      this._commonNameRegex = value.commonNameRegex;
      this._disabled = value.disabled;
      this._maxVersion = value.maxVersion;
      this._minVersion = value.minVersion;
      this._passphrase = value.passphrase;
      this._privKeyPath = value.privKeyPath;
      this._rejectUnauthorized = value.rejectUnauthorized;
      this._requestCert = value.requestCert;
    }
  }

  // ca_path - computed: false, optional: true, required: false
  private _caPath?: string; 
  public get caPath() {
    return this.getStringAttribute('ca_path');
  }
  public set caPath(value: string) {
    this._caPath = value;
  }
  public resetCaPath() {
    this._caPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get caPathInput() {
    return this._caPath;
  }

  // cert_path - computed: false, optional: true, required: false
  private _certPath?: string; 
  public get certPath() {
    return this.getStringAttribute('cert_path');
  }
  public set certPath(value: string) {
    this._certPath = value;
  }
  public resetCertPath() {
    this._certPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certPathInput() {
    return this._certPath;
  }

  // certificate_name - computed: false, optional: true, required: false
  private _certificateName?: string; 
  public get certificateName() {
    return this.getStringAttribute('certificate_name');
  }
  public set certificateName(value: string) {
    this._certificateName = value;
  }
  public resetCertificateName() {
    this._certificateName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certificateNameInput() {
    return this._certificateName;
  }

  // common_name_regex - computed: false, optional: true, required: false
  private _commonNameRegex?: string; 
  public get commonNameRegex() {
    return this.getStringAttribute('common_name_regex');
  }
  public set commonNameRegex(value: string) {
    this._commonNameRegex = value;
  }
  public resetCommonNameRegex() {
    this._commonNameRegex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commonNameRegexInput() {
    return this._commonNameRegex;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // max_version - computed: false, optional: true, required: false
  private _maxVersion?: string; 
  public get maxVersion() {
    return this.getStringAttribute('max_version');
  }
  public set maxVersion(value: string) {
    this._maxVersion = value;
  }
  public resetMaxVersion() {
    this._maxVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxVersionInput() {
    return this._maxVersion;
  }

  // min_version - computed: false, optional: true, required: false
  private _minVersion?: string; 
  public get minVersion() {
    return this.getStringAttribute('min_version');
  }
  public set minVersion(value: string) {
    this._minVersion = value;
  }
  public resetMinVersion() {
    this._minVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get minVersionInput() {
    return this._minVersion;
  }

  // passphrase - computed: false, optional: true, required: false
  private _passphrase?: string; 
  public get passphrase() {
    return this.getStringAttribute('passphrase');
  }
  public set passphrase(value: string) {
    this._passphrase = value;
  }
  public resetPassphrase() {
    this._passphrase = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passphraseInput() {
    return this._passphrase;
  }

  // priv_key_path - computed: false, optional: true, required: false
  private _privKeyPath?: string; 
  public get privKeyPath() {
    return this.getStringAttribute('priv_key_path');
  }
  public set privKeyPath(value: string) {
    this._privKeyPath = value;
  }
  public resetPrivKeyPath() {
    this._privKeyPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get privKeyPathInput() {
    return this._privKeyPath;
  }

  // reject_unauthorized - computed: false, optional: true, required: false
  private _rejectUnauthorized?: string; 
  public get rejectUnauthorized() {
    return this.getStringAttribute('reject_unauthorized');
  }
  public set rejectUnauthorized(value: string) {
    this._rejectUnauthorized = value;
  }
  public resetRejectUnauthorized() {
    this._rejectUnauthorized = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectUnauthorizedInput() {
    return this._rejectUnauthorized;
  }

  // request_cert - computed: true, optional: true, required: false
  private _requestCert?: boolean | cdktf.IResolvable; 
  public get requestCert() {
    return this.getBooleanAttribute('request_cert');
  }
  public set requestCert(value: boolean | cdktf.IResolvable) {
    this._requestCert = value;
  }
  public resetRequestCert() {
    this._requestCert = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestCertInput() {
    return this._requestCert;
  }
}
export interface SourceInputSyslogInputSyslogSyslog1 {
  /**
  * Enable if RFC 3164-formatted messages have hyphens in the app name portion of the TAG section. If disabled, only alphanumeric characters and underscores are allowed. Ignored for RFC 5424-formatted messages. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#allow_non_standard_app_name Source#allow_non_standard_app_name}
  */
  readonly allowNonStandardAppName?: boolean | cdktf.IResolvable;
  /**
  * Direct connections to Destinations, and optionally via a Pipeline or a Pack
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#connections Source#connections}
  */
  readonly connections?: SourceInputSyslogInputSyslogSyslog1Connections[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#description Source#description}
  */
  readonly description?: string;
  /**
  * Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#disabled Source#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * When enabled, parses PROXY protocol headers during the TLS handshake. Disable if compatibility issues arise.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#enable_enhanced_proxy_header_parsing Source#enable_enhanced_proxy_header_parsing}
  */
  readonly enableEnhancedProxyHeaderParsing?: boolean | cdktf.IResolvable;
  /**
  * Load balance traffic across all Worker Processes. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#enable_load_balancing Source#enable_load_balancing}
  */
  readonly enableLoadBalancing?: boolean | cdktf.IResolvable;
  /**
  * Enable if the connection is proxied by a device that supports Proxy Protocol V1 or V2. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#enable_proxy_header Source#enable_proxy_header}
  */
  readonly enableProxyHeader?: boolean | cdktf.IResolvable;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#environment Source#environment}
  */
  readonly environment?: string;
  /**
  * Address to bind on. For IPv4 (all addresses), use the default '0.0.0.0'. For IPv6, enter '::' (all addresses) or specify an IP address. Default: "0.0.0.0"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#host Source#host}
  */
  readonly host?: string;
  /**
  * Unique ID for this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#id Source#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * Enable if we should infer the syslog framing of the incoming messages. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#infer_framing Source#infer_framing}
  */
  readonly inferFraming?: boolean | cdktf.IResolvable;
  /**
  * Regex matching IP addresses that are allowed to send data. Default: "/.* /"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#ip_whitelist_regex Source#ip_whitelist_regex}
   *
  * Note: The above comment contained a comment block ending sequence (* followed by /). We have introduced a space between to prevent syntax errors. Please ignore the space.
  */
  readonly ipWhitelistRegex?: string;
  /**
  * Wildcard list of fields to keep from source data; * = ALL (default). Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#keep_fields_list Source#keep_fields_list}
  */
  readonly keepFieldsList?: string[];
  /**
  * Maximum number of active connections allowed per Worker Process for TCP connections. Use 0 for unlimited. Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_active_cxn Source#max_active_cxn}
  */
  readonly maxActiveCxn?: number;
  /**
  * Maximum number of events to buffer when downstream is blocking. Only applies to UDP. Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_buffer_size Source#max_buffer_size}
  */
  readonly maxBufferSize?: number;
  /**
  * Fields to add to events from this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#metadata Source#metadata}
  */
  readonly metadata?: SourceInputSyslogInputSyslogSyslog1Metadata[] | cdktf.IResolvable;
  /**
  * Enable if incoming messages use octet counting per RFC 6587. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#octet_counting Source#octet_counting}
  */
  readonly octetCounting?: boolean | cdktf.IResolvable;
  /**
  * Pipeline to process data from this Source before sending it through the Routes
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#pipeline Source#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#pq Source#pq}
  */
  readonly pq?: SourceInputSyslogInputSyslogSyslog1Pq;
  /**
  * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers). Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#pq_enabled Source#pq_enabled}
  */
  readonly pqEnabled?: boolean | cdktf.IResolvable;
  /**
  * Select whether to send data to Routes, or directly to Destinations. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#send_to_routes Source#send_to_routes}
  */
  readonly sendToRoutes?: boolean | cdktf.IResolvable;
  /**
  * Treat UDP packet data received as full syslog message. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#single_msg_udp_packets Source#single_msg_udp_packets}
  */
  readonly singleMsgUdpPackets?: boolean | cdktf.IResolvable;
  /**
  * How long the server will wait after initiating a closure for a client to close its end of the connection. If the client doesn't close the connection within this time, the server will forcefully terminate the socket to prevent resource leaks and ensure efficient connection cleanup and system stability. Leave at 0 for no inactive socket monitoring. Default: 30
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#socket_ending_max_wait Source#socket_ending_max_wait}
  */
  readonly socketEndingMaxWait?: number;
  /**
  * How long @{product} should wait before assuming that an inactive socket has timed out. After this time, the connection will be closed. Leave at 0 for no inactive socket monitoring. Default: 0
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#socket_idle_timeout Source#socket_idle_timeout}
  */
  readonly socketIdleTimeout?: number;
  /**
  * The maximum duration a socket can remain open, even if active. This helps manage resources and mitigate issues caused by TCP pinning. Set to 0 to disable. Default: 0
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#socket_max_lifespan Source#socket_max_lifespan}
  */
  readonly socketMaxLifespan?: number;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#streamtags Source#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Enable if we should infer octet counting only if the messages comply with RFC 5424. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#strictly_infer_octet_counting Source#strictly_infer_octet_counting}
  */
  readonly strictlyInferOctetCounting?: boolean | cdktf.IResolvable;
  /**
  * Enter TCP port number to listen on. Not required if listening on UDP.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#tcp_port Source#tcp_port}
  */
  readonly tcpPort?: number;
  /**
  * Timezone to assign to timestamps without timezone info. Default: "local"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#timestamp_timezone Source#timestamp_timezone}
  */
  readonly timestampTimezone?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#tls Source#tls}
  */
  readonly tls?: SourceInputSyslogInputSyslogSyslog1Tls;
  /**
  * must be "syslog"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#type Source#type}
  */
  readonly type: string;
  /**
  * Enter UDP port number to listen on. Not required if listening on TCP.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#udp_port Source#udp_port}
  */
  readonly udpPort: number;
  /**
  * Optionally, set the SO_RCVBUF socket option for the UDP socket. This value tells the operating system how many bytes can be buffered in the kernel before events are dropped. Leave blank to use the OS default. Caution: Increasing this value will affect OS memory utilization.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#udp_socket_rx_buf_size Source#udp_socket_rx_buf_size}
  */
  readonly udpSocketRxBufSize?: number;
}

export function sourceInputSyslogInputSyslogSyslog1ToTerraform(struct?: SourceInputSyslogInputSyslogSyslog1 | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    allow_non_standard_app_name: cdktf.booleanToTerraform(struct!.allowNonStandardAppName),
    connections: cdktf.listMapper(sourceInputSyslogInputSyslogSyslog1ConnectionsToTerraform, false)(struct!.connections),
    description: cdktf.stringToTerraform(struct!.description),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    enable_enhanced_proxy_header_parsing: cdktf.booleanToTerraform(struct!.enableEnhancedProxyHeaderParsing),
    enable_load_balancing: cdktf.booleanToTerraform(struct!.enableLoadBalancing),
    enable_proxy_header: cdktf.booleanToTerraform(struct!.enableProxyHeader),
    environment: cdktf.stringToTerraform(struct!.environment),
    host: cdktf.stringToTerraform(struct!.host),
    id: cdktf.stringToTerraform(struct!.id),
    infer_framing: cdktf.booleanToTerraform(struct!.inferFraming),
    ip_whitelist_regex: cdktf.stringToTerraform(struct!.ipWhitelistRegex),
    keep_fields_list: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.keepFieldsList),
    max_active_cxn: cdktf.numberToTerraform(struct!.maxActiveCxn),
    max_buffer_size: cdktf.numberToTerraform(struct!.maxBufferSize),
    metadata: cdktf.listMapper(sourceInputSyslogInputSyslogSyslog1MetadataToTerraform, false)(struct!.metadata),
    octet_counting: cdktf.booleanToTerraform(struct!.octetCounting),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    pq: sourceInputSyslogInputSyslogSyslog1PqToTerraform(struct!.pq),
    pq_enabled: cdktf.booleanToTerraform(struct!.pqEnabled),
    send_to_routes: cdktf.booleanToTerraform(struct!.sendToRoutes),
    single_msg_udp_packets: cdktf.booleanToTerraform(struct!.singleMsgUdpPackets),
    socket_ending_max_wait: cdktf.numberToTerraform(struct!.socketEndingMaxWait),
    socket_idle_timeout: cdktf.numberToTerraform(struct!.socketIdleTimeout),
    socket_max_lifespan: cdktf.numberToTerraform(struct!.socketMaxLifespan),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    strictly_infer_octet_counting: cdktf.booleanToTerraform(struct!.strictlyInferOctetCounting),
    tcp_port: cdktf.numberToTerraform(struct!.tcpPort),
    timestamp_timezone: cdktf.stringToTerraform(struct!.timestampTimezone),
    tls: sourceInputSyslogInputSyslogSyslog1TlsToTerraform(struct!.tls),
    type: cdktf.stringToTerraform(struct!.type),
    udp_port: cdktf.numberToTerraform(struct!.udpPort),
    udp_socket_rx_buf_size: cdktf.numberToTerraform(struct!.udpSocketRxBufSize),
  }
}


export function sourceInputSyslogInputSyslogSyslog1ToHclTerraform(struct?: SourceInputSyslogInputSyslogSyslog1 | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    allow_non_standard_app_name: {
      value: cdktf.booleanToHclTerraform(struct!.allowNonStandardAppName),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    connections: {
      value: cdktf.listMapperHcl(sourceInputSyslogInputSyslogSyslog1ConnectionsToHclTerraform, false)(struct!.connections),
      isBlock: true,
      type: "list",
      storageClassType: "SourceInputSyslogInputSyslogSyslog1ConnectionsList",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    enable_enhanced_proxy_header_parsing: {
      value: cdktf.booleanToHclTerraform(struct!.enableEnhancedProxyHeaderParsing),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    enable_load_balancing: {
      value: cdktf.booleanToHclTerraform(struct!.enableLoadBalancing),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    enable_proxy_header: {
      value: cdktf.booleanToHclTerraform(struct!.enableProxyHeader),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    host: {
      value: cdktf.stringToHclTerraform(struct!.host),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    infer_framing: {
      value: cdktf.booleanToHclTerraform(struct!.inferFraming),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    ip_whitelist_regex: {
      value: cdktf.stringToHclTerraform(struct!.ipWhitelistRegex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    keep_fields_list: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.keepFieldsList),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    max_active_cxn: {
      value: cdktf.numberToHclTerraform(struct!.maxActiveCxn),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_buffer_size: {
      value: cdktf.numberToHclTerraform(struct!.maxBufferSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    metadata: {
      value: cdktf.listMapperHcl(sourceInputSyslogInputSyslogSyslog1MetadataToHclTerraform, false)(struct!.metadata),
      isBlock: true,
      type: "list",
      storageClassType: "SourceInputSyslogInputSyslogSyslog1MetadataList",
    },
    octet_counting: {
      value: cdktf.booleanToHclTerraform(struct!.octetCounting),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq: {
      value: sourceInputSyslogInputSyslogSyslog1PqToHclTerraform(struct!.pq),
      isBlock: true,
      type: "struct",
      storageClassType: "SourceInputSyslogInputSyslogSyslog1Pq",
    },
    pq_enabled: {
      value: cdktf.booleanToHclTerraform(struct!.pqEnabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    send_to_routes: {
      value: cdktf.booleanToHclTerraform(struct!.sendToRoutes),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    single_msg_udp_packets: {
      value: cdktf.booleanToHclTerraform(struct!.singleMsgUdpPackets),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    socket_ending_max_wait: {
      value: cdktf.numberToHclTerraform(struct!.socketEndingMaxWait),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    socket_idle_timeout: {
      value: cdktf.numberToHclTerraform(struct!.socketIdleTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    socket_max_lifespan: {
      value: cdktf.numberToHclTerraform(struct!.socketMaxLifespan),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    strictly_infer_octet_counting: {
      value: cdktf.booleanToHclTerraform(struct!.strictlyInferOctetCounting),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    tcp_port: {
      value: cdktf.numberToHclTerraform(struct!.tcpPort),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    timestamp_timezone: {
      value: cdktf.stringToHclTerraform(struct!.timestampTimezone),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tls: {
      value: sourceInputSyslogInputSyslogSyslog1TlsToHclTerraform(struct!.tls),
      isBlock: true,
      type: "struct",
      storageClassType: "SourceInputSyslogInputSyslogSyslog1Tls",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    udp_port: {
      value: cdktf.numberToHclTerraform(struct!.udpPort),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    udp_socket_rx_buf_size: {
      value: cdktf.numberToHclTerraform(struct!.udpSocketRxBufSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputSyslogInputSyslogSyslog1OutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SourceInputSyslogInputSyslogSyslog1 | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._allowNonStandardAppName !== undefined) {
      hasAnyValues = true;
      internalValueResult.allowNonStandardAppName = this._allowNonStandardAppName;
    }
    if (this._connections?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.connections = this._connections?.internalValue;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._enableEnhancedProxyHeaderParsing !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableEnhancedProxyHeaderParsing = this._enableEnhancedProxyHeaderParsing;
    }
    if (this._enableLoadBalancing !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableLoadBalancing = this._enableLoadBalancing;
    }
    if (this._enableProxyHeader !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableProxyHeader = this._enableProxyHeader;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._host !== undefined) {
      hasAnyValues = true;
      internalValueResult.host = this._host;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._inferFraming !== undefined) {
      hasAnyValues = true;
      internalValueResult.inferFraming = this._inferFraming;
    }
    if (this._ipWhitelistRegex !== undefined) {
      hasAnyValues = true;
      internalValueResult.ipWhitelistRegex = this._ipWhitelistRegex;
    }
    if (this._keepFieldsList !== undefined) {
      hasAnyValues = true;
      internalValueResult.keepFieldsList = this._keepFieldsList;
    }
    if (this._maxActiveCxn !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxActiveCxn = this._maxActiveCxn;
    }
    if (this._maxBufferSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBufferSize = this._maxBufferSize;
    }
    if (this._metadata?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadata = this._metadata?.internalValue;
    }
    if (this._octetCounting !== undefined) {
      hasAnyValues = true;
      internalValueResult.octetCounting = this._octetCounting;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._pq?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pq = this._pq?.internalValue;
    }
    if (this._pqEnabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqEnabled = this._pqEnabled;
    }
    if (this._sendToRoutes !== undefined) {
      hasAnyValues = true;
      internalValueResult.sendToRoutes = this._sendToRoutes;
    }
    if (this._singleMsgUdpPackets !== undefined) {
      hasAnyValues = true;
      internalValueResult.singleMsgUdpPackets = this._singleMsgUdpPackets;
    }
    if (this._socketEndingMaxWait !== undefined) {
      hasAnyValues = true;
      internalValueResult.socketEndingMaxWait = this._socketEndingMaxWait;
    }
    if (this._socketIdleTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.socketIdleTimeout = this._socketIdleTimeout;
    }
    if (this._socketMaxLifespan !== undefined) {
      hasAnyValues = true;
      internalValueResult.socketMaxLifespan = this._socketMaxLifespan;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._strictlyInferOctetCounting !== undefined) {
      hasAnyValues = true;
      internalValueResult.strictlyInferOctetCounting = this._strictlyInferOctetCounting;
    }
    if (this._tcpPort !== undefined) {
      hasAnyValues = true;
      internalValueResult.tcpPort = this._tcpPort;
    }
    if (this._timestampTimezone !== undefined) {
      hasAnyValues = true;
      internalValueResult.timestampTimezone = this._timestampTimezone;
    }
    if (this._tls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tls = this._tls?.internalValue;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._udpPort !== undefined) {
      hasAnyValues = true;
      internalValueResult.udpPort = this._udpPort;
    }
    if (this._udpSocketRxBufSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.udpSocketRxBufSize = this._udpSocketRxBufSize;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputSyslogInputSyslogSyslog1 | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._allowNonStandardAppName = undefined;
      this._connections.internalValue = undefined;
      this._description = undefined;
      this._disabled = undefined;
      this._enableEnhancedProxyHeaderParsing = undefined;
      this._enableLoadBalancing = undefined;
      this._enableProxyHeader = undefined;
      this._environment = undefined;
      this._host = undefined;
      this._id = undefined;
      this._inferFraming = undefined;
      this._ipWhitelistRegex = undefined;
      this._keepFieldsList = undefined;
      this._maxActiveCxn = undefined;
      this._maxBufferSize = undefined;
      this._metadata.internalValue = undefined;
      this._octetCounting = undefined;
      this._pipeline = undefined;
      this._pq.internalValue = undefined;
      this._pqEnabled = undefined;
      this._sendToRoutes = undefined;
      this._singleMsgUdpPackets = undefined;
      this._socketEndingMaxWait = undefined;
      this._socketIdleTimeout = undefined;
      this._socketMaxLifespan = undefined;
      this._streamtags = undefined;
      this._strictlyInferOctetCounting = undefined;
      this._tcpPort = undefined;
      this._timestampTimezone = undefined;
      this._tls.internalValue = undefined;
      this._type = undefined;
      this._udpPort = undefined;
      this._udpSocketRxBufSize = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._allowNonStandardAppName = value.allowNonStandardAppName;
      this._connections.internalValue = value.connections;
      this._description = value.description;
      this._disabled = value.disabled;
      this._enableEnhancedProxyHeaderParsing = value.enableEnhancedProxyHeaderParsing;
      this._enableLoadBalancing = value.enableLoadBalancing;
      this._enableProxyHeader = value.enableProxyHeader;
      this._environment = value.environment;
      this._host = value.host;
      this._id = value.id;
      this._inferFraming = value.inferFraming;
      this._ipWhitelistRegex = value.ipWhitelistRegex;
      this._keepFieldsList = value.keepFieldsList;
      this._maxActiveCxn = value.maxActiveCxn;
      this._maxBufferSize = value.maxBufferSize;
      this._metadata.internalValue = value.metadata;
      this._octetCounting = value.octetCounting;
      this._pipeline = value.pipeline;
      this._pq.internalValue = value.pq;
      this._pqEnabled = value.pqEnabled;
      this._sendToRoutes = value.sendToRoutes;
      this._singleMsgUdpPackets = value.singleMsgUdpPackets;
      this._socketEndingMaxWait = value.socketEndingMaxWait;
      this._socketIdleTimeout = value.socketIdleTimeout;
      this._socketMaxLifespan = value.socketMaxLifespan;
      this._streamtags = value.streamtags;
      this._strictlyInferOctetCounting = value.strictlyInferOctetCounting;
      this._tcpPort = value.tcpPort;
      this._timestampTimezone = value.timestampTimezone;
      this._tls.internalValue = value.tls;
      this._type = value.type;
      this._udpPort = value.udpPort;
      this._udpSocketRxBufSize = value.udpSocketRxBufSize;
    }
  }

  // allow_non_standard_app_name - computed: true, optional: true, required: false
  private _allowNonStandardAppName?: boolean | cdktf.IResolvable; 
  public get allowNonStandardAppName() {
    return this.getBooleanAttribute('allow_non_standard_app_name');
  }
  public set allowNonStandardAppName(value: boolean | cdktf.IResolvable) {
    this._allowNonStandardAppName = value;
  }
  public resetAllowNonStandardAppName() {
    this._allowNonStandardAppName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get allowNonStandardAppNameInput() {
    return this._allowNonStandardAppName;
  }

  // connections - computed: false, optional: true, required: false
  private _connections = new SourceInputSyslogInputSyslogSyslog1ConnectionsList(this, "connections", false);
  public get connections() {
    return this._connections;
  }
  public putConnections(value: SourceInputSyslogInputSyslogSyslog1Connections[] | cdktf.IResolvable) {
    this._connections.internalValue = value;
  }
  public resetConnections() {
    this._connections.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectionsInput() {
    return this._connections.internalValue;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // enable_enhanced_proxy_header_parsing - computed: false, optional: true, required: false
  private _enableEnhancedProxyHeaderParsing?: boolean | cdktf.IResolvable; 
  public get enableEnhancedProxyHeaderParsing() {
    return this.getBooleanAttribute('enable_enhanced_proxy_header_parsing');
  }
  public set enableEnhancedProxyHeaderParsing(value: boolean | cdktf.IResolvable) {
    this._enableEnhancedProxyHeaderParsing = value;
  }
  public resetEnableEnhancedProxyHeaderParsing() {
    this._enableEnhancedProxyHeaderParsing = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableEnhancedProxyHeaderParsingInput() {
    return this._enableEnhancedProxyHeaderParsing;
  }

  // enable_load_balancing - computed: true, optional: true, required: false
  private _enableLoadBalancing?: boolean | cdktf.IResolvable; 
  public get enableLoadBalancing() {
    return this.getBooleanAttribute('enable_load_balancing');
  }
  public set enableLoadBalancing(value: boolean | cdktf.IResolvable) {
    this._enableLoadBalancing = value;
  }
  public resetEnableLoadBalancing() {
    this._enableLoadBalancing = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableLoadBalancingInput() {
    return this._enableLoadBalancing;
  }

  // enable_proxy_header - computed: true, optional: true, required: false
  private _enableProxyHeader?: boolean | cdktf.IResolvable; 
  public get enableProxyHeader() {
    return this.getBooleanAttribute('enable_proxy_header');
  }
  public set enableProxyHeader(value: boolean | cdktf.IResolvable) {
    this._enableProxyHeader = value;
  }
  public resetEnableProxyHeader() {
    this._enableProxyHeader = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableProxyHeaderInput() {
    return this._enableProxyHeader;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // host - computed: true, optional: true, required: false
  private _host?: string; 
  public get host() {
    return this.getStringAttribute('host');
  }
  public set host(value: string) {
    this._host = value;
  }
  public resetHost() {
    this._host = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostInput() {
    return this._host;
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // infer_framing - computed: true, optional: true, required: false
  private _inferFraming?: boolean | cdktf.IResolvable; 
  public get inferFraming() {
    return this.getBooleanAttribute('infer_framing');
  }
  public set inferFraming(value: boolean | cdktf.IResolvable) {
    this._inferFraming = value;
  }
  public resetInferFraming() {
    this._inferFraming = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get inferFramingInput() {
    return this._inferFraming;
  }

  // ip_whitelist_regex - computed: true, optional: true, required: false
  private _ipWhitelistRegex?: string; 
  public get ipWhitelistRegex() {
    return this.getStringAttribute('ip_whitelist_regex');
  }
  public set ipWhitelistRegex(value: string) {
    this._ipWhitelistRegex = value;
  }
  public resetIpWhitelistRegex() {
    this._ipWhitelistRegex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ipWhitelistRegexInput() {
    return this._ipWhitelistRegex;
  }

  // keep_fields_list - computed: true, optional: true, required: false
  private _keepFieldsList?: string[]; 
  public get keepFieldsList() {
    return this.getListAttribute('keep_fields_list');
  }
  public set keepFieldsList(value: string[]) {
    this._keepFieldsList = value;
  }
  public resetKeepFieldsList() {
    this._keepFieldsList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keepFieldsListInput() {
    return this._keepFieldsList;
  }

  // max_active_cxn - computed: true, optional: true, required: false
  private _maxActiveCxn?: number; 
  public get maxActiveCxn() {
    return this.getNumberAttribute('max_active_cxn');
  }
  public set maxActiveCxn(value: number) {
    this._maxActiveCxn = value;
  }
  public resetMaxActiveCxn() {
    this._maxActiveCxn = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxActiveCxnInput() {
    return this._maxActiveCxn;
  }

  // max_buffer_size - computed: true, optional: true, required: false
  private _maxBufferSize?: number; 
  public get maxBufferSize() {
    return this.getNumberAttribute('max_buffer_size');
  }
  public set maxBufferSize(value: number) {
    this._maxBufferSize = value;
  }
  public resetMaxBufferSize() {
    this._maxBufferSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBufferSizeInput() {
    return this._maxBufferSize;
  }

  // metadata - computed: false, optional: true, required: false
  private _metadata = new SourceInputSyslogInputSyslogSyslog1MetadataList(this, "metadata", false);
  public get metadata() {
    return this._metadata;
  }
  public putMetadata(value: SourceInputSyslogInputSyslogSyslog1Metadata[] | cdktf.IResolvable) {
    this._metadata.internalValue = value;
  }
  public resetMetadata() {
    this._metadata.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataInput() {
    return this._metadata.internalValue;
  }

  // octet_counting - computed: true, optional: true, required: false
  private _octetCounting?: boolean | cdktf.IResolvable; 
  public get octetCounting() {
    return this.getBooleanAttribute('octet_counting');
  }
  public set octetCounting(value: boolean | cdktf.IResolvable) {
    this._octetCounting = value;
  }
  public resetOctetCounting() {
    this._octetCounting = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get octetCountingInput() {
    return this._octetCounting;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // pq - computed: false, optional: true, required: false
  private _pq = new SourceInputSyslogInputSyslogSyslog1PqOutputReference(this, "pq");
  public get pq() {
    return this._pq;
  }
  public putPq(value: SourceInputSyslogInputSyslogSyslog1Pq) {
    this._pq.internalValue = value;
  }
  public resetPq() {
    this._pq.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqInput() {
    return this._pq.internalValue;
  }

  // pq_enabled - computed: true, optional: true, required: false
  private _pqEnabled?: boolean | cdktf.IResolvable; 
  public get pqEnabled() {
    return this.getBooleanAttribute('pq_enabled');
  }
  public set pqEnabled(value: boolean | cdktf.IResolvable) {
    this._pqEnabled = value;
  }
  public resetPqEnabled() {
    this._pqEnabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqEnabledInput() {
    return this._pqEnabled;
  }

  // send_to_routes - computed: true, optional: true, required: false
  private _sendToRoutes?: boolean | cdktf.IResolvable; 
  public get sendToRoutes() {
    return this.getBooleanAttribute('send_to_routes');
  }
  public set sendToRoutes(value: boolean | cdktf.IResolvable) {
    this._sendToRoutes = value;
  }
  public resetSendToRoutes() {
    this._sendToRoutes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sendToRoutesInput() {
    return this._sendToRoutes;
  }

  // single_msg_udp_packets - computed: true, optional: true, required: false
  private _singleMsgUdpPackets?: boolean | cdktf.IResolvable; 
  public get singleMsgUdpPackets() {
    return this.getBooleanAttribute('single_msg_udp_packets');
  }
  public set singleMsgUdpPackets(value: boolean | cdktf.IResolvable) {
    this._singleMsgUdpPackets = value;
  }
  public resetSingleMsgUdpPackets() {
    this._singleMsgUdpPackets = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get singleMsgUdpPacketsInput() {
    return this._singleMsgUdpPackets;
  }

  // socket_ending_max_wait - computed: true, optional: true, required: false
  private _socketEndingMaxWait?: number; 
  public get socketEndingMaxWait() {
    return this.getNumberAttribute('socket_ending_max_wait');
  }
  public set socketEndingMaxWait(value: number) {
    this._socketEndingMaxWait = value;
  }
  public resetSocketEndingMaxWait() {
    this._socketEndingMaxWait = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get socketEndingMaxWaitInput() {
    return this._socketEndingMaxWait;
  }

  // socket_idle_timeout - computed: true, optional: true, required: false
  private _socketIdleTimeout?: number; 
  public get socketIdleTimeout() {
    return this.getNumberAttribute('socket_idle_timeout');
  }
  public set socketIdleTimeout(value: number) {
    this._socketIdleTimeout = value;
  }
  public resetSocketIdleTimeout() {
    this._socketIdleTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get socketIdleTimeoutInput() {
    return this._socketIdleTimeout;
  }

  // socket_max_lifespan - computed: true, optional: true, required: false
  private _socketMaxLifespan?: number; 
  public get socketMaxLifespan() {
    return this.getNumberAttribute('socket_max_lifespan');
  }
  public set socketMaxLifespan(value: number) {
    this._socketMaxLifespan = value;
  }
  public resetSocketMaxLifespan() {
    this._socketMaxLifespan = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get socketMaxLifespanInput() {
    return this._socketMaxLifespan;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // strictly_infer_octet_counting - computed: true, optional: true, required: false
  private _strictlyInferOctetCounting?: boolean | cdktf.IResolvable; 
  public get strictlyInferOctetCounting() {
    return this.getBooleanAttribute('strictly_infer_octet_counting');
  }
  public set strictlyInferOctetCounting(value: boolean | cdktf.IResolvable) {
    this._strictlyInferOctetCounting = value;
  }
  public resetStrictlyInferOctetCounting() {
    this._strictlyInferOctetCounting = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get strictlyInferOctetCountingInput() {
    return this._strictlyInferOctetCounting;
  }

  // tcp_port - computed: false, optional: true, required: false
  private _tcpPort?: number; 
  public get tcpPort() {
    return this.getNumberAttribute('tcp_port');
  }
  public set tcpPort(value: number) {
    this._tcpPort = value;
  }
  public resetTcpPort() {
    this._tcpPort = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tcpPortInput() {
    return this._tcpPort;
  }

  // timestamp_timezone - computed: true, optional: true, required: false
  private _timestampTimezone?: string; 
  public get timestampTimezone() {
    return this.getStringAttribute('timestamp_timezone');
  }
  public set timestampTimezone(value: string) {
    this._timestampTimezone = value;
  }
  public resetTimestampTimezone() {
    this._timestampTimezone = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timestampTimezoneInput() {
    return this._timestampTimezone;
  }

  // tls - computed: false, optional: true, required: false
  private _tls = new SourceInputSyslogInputSyslogSyslog1TlsOutputReference(this, "tls");
  public get tls() {
    return this._tls;
  }
  public putTls(value: SourceInputSyslogInputSyslogSyslog1Tls) {
    this._tls.internalValue = value;
  }
  public resetTls() {
    this._tls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsInput() {
    return this._tls.internalValue;
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // udp_port - computed: false, optional: false, required: true
  private _udpPort?: number; 
  public get udpPort() {
    return this.getNumberAttribute('udp_port');
  }
  public set udpPort(value: number) {
    this._udpPort = value;
  }
  // Temporarily expose input value. Use with caution.
  public get udpPortInput() {
    return this._udpPort;
  }

  // udp_socket_rx_buf_size - computed: false, optional: true, required: false
  private _udpSocketRxBufSize?: number; 
  public get udpSocketRxBufSize() {
    return this.getNumberAttribute('udp_socket_rx_buf_size');
  }
  public set udpSocketRxBufSize(value: number) {
    this._udpSocketRxBufSize = value;
  }
  public resetUdpSocketRxBufSize() {
    this._udpSocketRxBufSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get udpSocketRxBufSizeInput() {
    return this._udpSocketRxBufSize;
  }
}
export interface SourceInputSyslogInputSyslogSyslog2Connections {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#output Source#output}
  */
  readonly output: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#pipeline Source#pipeline}
  */
  readonly pipeline?: string;
}

export function sourceInputSyslogInputSyslogSyslog2ConnectionsToTerraform(struct?: SourceInputSyslogInputSyslogSyslog2Connections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    output: cdktf.stringToTerraform(struct!.output),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
  }
}


export function sourceInputSyslogInputSyslogSyslog2ConnectionsToHclTerraform(struct?: SourceInputSyslogInputSyslogSyslog2Connections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    output: {
      value: cdktf.stringToHclTerraform(struct!.output),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputSyslogInputSyslogSyslog2ConnectionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): SourceInputSyslogInputSyslogSyslog2Connections | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._output !== undefined) {
      hasAnyValues = true;
      internalValueResult.output = this._output;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputSyslogInputSyslogSyslog2Connections | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._output = undefined;
      this._pipeline = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._output = value.output;
      this._pipeline = value.pipeline;
    }
  }

  // output - computed: false, optional: false, required: true
  private _output?: string; 
  public get output() {
    return this.getStringAttribute('output');
  }
  public set output(value: string) {
    this._output = value;
  }
  // Temporarily expose input value. Use with caution.
  public get outputInput() {
    return this._output;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }
}

export class SourceInputSyslogInputSyslogSyslog2ConnectionsList extends cdktf.ComplexList {
  public internalValue? : SourceInputSyslogInputSyslogSyslog2Connections[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): SourceInputSyslogInputSyslogSyslog2ConnectionsOutputReference {
    return new SourceInputSyslogInputSyslogSyslog2ConnectionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface SourceInputSyslogInputSyslogSyslog2Metadata {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#name Source#name}
  */
  readonly name: string;
  /**
  * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#value Source#value}
  */
  readonly value: string;
}

export function sourceInputSyslogInputSyslogSyslog2MetadataToTerraform(struct?: SourceInputSyslogInputSyslogSyslog2Metadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function sourceInputSyslogInputSyslogSyslog2MetadataToHclTerraform(struct?: SourceInputSyslogInputSyslogSyslog2Metadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputSyslogInputSyslogSyslog2MetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): SourceInputSyslogInputSyslogSyslog2Metadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputSyslogInputSyslogSyslog2Metadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class SourceInputSyslogInputSyslogSyslog2MetadataList extends cdktf.ComplexList {
  public internalValue? : SourceInputSyslogInputSyslogSyslog2Metadata[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): SourceInputSyslogInputSyslogSyslog2MetadataOutputReference {
    return new SourceInputSyslogInputSyslogSyslog2MetadataOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface SourceInputSyslogInputSyslogSyslog2Pq {
  /**
  * The number of events to send downstream before committing that Stream has read them. Default: 42
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#commit_frequency Source#commit_frequency}
  */
  readonly commitFrequency?: number;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#compress Source#compress}
  */
  readonly compress?: string;
  /**
  * The maximum number of events to hold in memory before writing the events to disk. Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_buffer_size Source#max_buffer_size}
  */
  readonly maxBufferSize?: number;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc. Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_file_size Source#max_file_size}
  */
  readonly maxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_size Source#max_size}
  */
  readonly maxSize?: string;
  /**
  * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine. Default: "always"; must be one of ["smart", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#mode Source#mode}
  */
  readonly mode?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#path Source#path}
  */
  readonly path?: string;
}

export function sourceInputSyslogInputSyslogSyslog2PqToTerraform(struct?: SourceInputSyslogInputSyslogSyslog2Pq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    commit_frequency: cdktf.numberToTerraform(struct!.commitFrequency),
    compress: cdktf.stringToTerraform(struct!.compress),
    max_buffer_size: cdktf.numberToTerraform(struct!.maxBufferSize),
    max_file_size: cdktf.stringToTerraform(struct!.maxFileSize),
    max_size: cdktf.stringToTerraform(struct!.maxSize),
    mode: cdktf.stringToTerraform(struct!.mode),
    path: cdktf.stringToTerraform(struct!.path),
  }
}


export function sourceInputSyslogInputSyslogSyslog2PqToHclTerraform(struct?: SourceInputSyslogInputSyslogSyslog2Pq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    commit_frequency: {
      value: cdktf.numberToHclTerraform(struct!.commitFrequency),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    compress: {
      value: cdktf.stringToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_buffer_size: {
      value: cdktf.numberToHclTerraform(struct!.maxBufferSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.maxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_size: {
      value: cdktf.stringToHclTerraform(struct!.maxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputSyslogInputSyslogSyslog2PqOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SourceInputSyslogInputSyslogSyslog2Pq | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._commitFrequency !== undefined) {
      hasAnyValues = true;
      internalValueResult.commitFrequency = this._commitFrequency;
    }
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._maxBufferSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBufferSize = this._maxBufferSize;
    }
    if (this._maxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxFileSize = this._maxFileSize;
    }
    if (this._maxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxSize = this._maxSize;
    }
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputSyslogInputSyslogSyslog2Pq | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._commitFrequency = undefined;
      this._compress = undefined;
      this._maxBufferSize = undefined;
      this._maxFileSize = undefined;
      this._maxSize = undefined;
      this._mode = undefined;
      this._path = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._commitFrequency = value.commitFrequency;
      this._compress = value.compress;
      this._maxBufferSize = value.maxBufferSize;
      this._maxFileSize = value.maxFileSize;
      this._maxSize = value.maxSize;
      this._mode = value.mode;
      this._path = value.path;
    }
  }

  // commit_frequency - computed: true, optional: true, required: false
  private _commitFrequency?: number; 
  public get commitFrequency() {
    return this.getNumberAttribute('commit_frequency');
  }
  public set commitFrequency(value: number) {
    this._commitFrequency = value;
  }
  public resetCommitFrequency() {
    this._commitFrequency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commitFrequencyInput() {
    return this._commitFrequency;
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: string; 
  public get compress() {
    return this.getStringAttribute('compress');
  }
  public set compress(value: string) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // max_buffer_size - computed: true, optional: true, required: false
  private _maxBufferSize?: number; 
  public get maxBufferSize() {
    return this.getNumberAttribute('max_buffer_size');
  }
  public set maxBufferSize(value: number) {
    this._maxBufferSize = value;
  }
  public resetMaxBufferSize() {
    this._maxBufferSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBufferSizeInput() {
    return this._maxBufferSize;
  }

  // max_file_size - computed: true, optional: true, required: false
  private _maxFileSize?: string; 
  public get maxFileSize() {
    return this.getStringAttribute('max_file_size');
  }
  public set maxFileSize(value: string) {
    this._maxFileSize = value;
  }
  public resetMaxFileSize() {
    this._maxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxFileSizeInput() {
    return this._maxFileSize;
  }

  // max_size - computed: true, optional: true, required: false
  private _maxSize?: string; 
  public get maxSize() {
    return this.getStringAttribute('max_size');
  }
  public set maxSize(value: string) {
    this._maxSize = value;
  }
  public resetMaxSize() {
    this._maxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxSizeInput() {
    return this._maxSize;
  }

  // mode - computed: true, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // path - computed: true, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }
}
export interface SourceInputSyslogInputSyslogSyslog2Tls {
  /**
  * Path on server containing CA certificates to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#ca_path Source#ca_path}
  */
  readonly caPath?: string;
  /**
  * Path on server containing certificates to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#cert_path Source#cert_path}
  */
  readonly certPath?: string;
  /**
  * The name of the predefined certificate
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#certificate_name Source#certificate_name}
  */
  readonly certificateName?: string;
  /**
  * Parsed as JSON.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#common_name_regex Source#common_name_regex}
  */
  readonly commonNameRegex?: string;
  /**
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#disabled Source#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_version Source#max_version}
  */
  readonly maxVersion?: string;
  /**
  * must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#min_version Source#min_version}
  */
  readonly minVersion?: string;
  /**
  * Passphrase to use to decrypt private key
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#passphrase Source#passphrase}
  */
  readonly passphrase?: string;
  /**
  * Path on server containing the private key to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#priv_key_path Source#priv_key_path}
  */
  readonly privKeyPath?: string;
  /**
  * Parsed as JSON.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#reject_unauthorized Source#reject_unauthorized}
  */
  readonly rejectUnauthorized?: string;
  /**
  * Require clients to present their certificates. Used to perform client authentication using SSL certs. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#request_cert Source#request_cert}
  */
  readonly requestCert?: boolean | cdktf.IResolvable;
}

export function sourceInputSyslogInputSyslogSyslog2TlsToTerraform(struct?: SourceInputSyslogInputSyslogSyslog2Tls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ca_path: cdktf.stringToTerraform(struct!.caPath),
    cert_path: cdktf.stringToTerraform(struct!.certPath),
    certificate_name: cdktf.stringToTerraform(struct!.certificateName),
    common_name_regex: cdktf.stringToTerraform(struct!.commonNameRegex),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    max_version: cdktf.stringToTerraform(struct!.maxVersion),
    min_version: cdktf.stringToTerraform(struct!.minVersion),
    passphrase: cdktf.stringToTerraform(struct!.passphrase),
    priv_key_path: cdktf.stringToTerraform(struct!.privKeyPath),
    reject_unauthorized: cdktf.stringToTerraform(struct!.rejectUnauthorized),
    request_cert: cdktf.booleanToTerraform(struct!.requestCert),
  }
}


export function sourceInputSyslogInputSyslogSyslog2TlsToHclTerraform(struct?: SourceInputSyslogInputSyslogSyslog2Tls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ca_path: {
      value: cdktf.stringToHclTerraform(struct!.caPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    cert_path: {
      value: cdktf.stringToHclTerraform(struct!.certPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    certificate_name: {
      value: cdktf.stringToHclTerraform(struct!.certificateName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    common_name_regex: {
      value: cdktf.stringToHclTerraform(struct!.commonNameRegex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    max_version: {
      value: cdktf.stringToHclTerraform(struct!.maxVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    min_version: {
      value: cdktf.stringToHclTerraform(struct!.minVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    passphrase: {
      value: cdktf.stringToHclTerraform(struct!.passphrase),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    priv_key_path: {
      value: cdktf.stringToHclTerraform(struct!.privKeyPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reject_unauthorized: {
      value: cdktf.stringToHclTerraform(struct!.rejectUnauthorized),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    request_cert: {
      value: cdktf.booleanToHclTerraform(struct!.requestCert),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputSyslogInputSyslogSyslog2TlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SourceInputSyslogInputSyslogSyslog2Tls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._caPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.caPath = this._caPath;
    }
    if (this._certPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.certPath = this._certPath;
    }
    if (this._certificateName !== undefined) {
      hasAnyValues = true;
      internalValueResult.certificateName = this._certificateName;
    }
    if (this._commonNameRegex !== undefined) {
      hasAnyValues = true;
      internalValueResult.commonNameRegex = this._commonNameRegex;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._maxVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxVersion = this._maxVersion;
    }
    if (this._minVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.minVersion = this._minVersion;
    }
    if (this._passphrase !== undefined) {
      hasAnyValues = true;
      internalValueResult.passphrase = this._passphrase;
    }
    if (this._privKeyPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.privKeyPath = this._privKeyPath;
    }
    if (this._rejectUnauthorized !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectUnauthorized = this._rejectUnauthorized;
    }
    if (this._requestCert !== undefined) {
      hasAnyValues = true;
      internalValueResult.requestCert = this._requestCert;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputSyslogInputSyslogSyslog2Tls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._caPath = undefined;
      this._certPath = undefined;
      this._certificateName = undefined;
      this._commonNameRegex = undefined;
      this._disabled = undefined;
      this._maxVersion = undefined;
      this._minVersion = undefined;
      this._passphrase = undefined;
      this._privKeyPath = undefined;
      this._rejectUnauthorized = undefined;
      this._requestCert = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._caPath = value.caPath;
      this._certPath = value.certPath;
      this._certificateName = value.certificateName;
      this._commonNameRegex = value.commonNameRegex;
      this._disabled = value.disabled;
      this._maxVersion = value.maxVersion;
      this._minVersion = value.minVersion;
      this._passphrase = value.passphrase;
      this._privKeyPath = value.privKeyPath;
      this._rejectUnauthorized = value.rejectUnauthorized;
      this._requestCert = value.requestCert;
    }
  }

  // ca_path - computed: false, optional: true, required: false
  private _caPath?: string; 
  public get caPath() {
    return this.getStringAttribute('ca_path');
  }
  public set caPath(value: string) {
    this._caPath = value;
  }
  public resetCaPath() {
    this._caPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get caPathInput() {
    return this._caPath;
  }

  // cert_path - computed: false, optional: true, required: false
  private _certPath?: string; 
  public get certPath() {
    return this.getStringAttribute('cert_path');
  }
  public set certPath(value: string) {
    this._certPath = value;
  }
  public resetCertPath() {
    this._certPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certPathInput() {
    return this._certPath;
  }

  // certificate_name - computed: false, optional: true, required: false
  private _certificateName?: string; 
  public get certificateName() {
    return this.getStringAttribute('certificate_name');
  }
  public set certificateName(value: string) {
    this._certificateName = value;
  }
  public resetCertificateName() {
    this._certificateName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certificateNameInput() {
    return this._certificateName;
  }

  // common_name_regex - computed: false, optional: true, required: false
  private _commonNameRegex?: string; 
  public get commonNameRegex() {
    return this.getStringAttribute('common_name_regex');
  }
  public set commonNameRegex(value: string) {
    this._commonNameRegex = value;
  }
  public resetCommonNameRegex() {
    this._commonNameRegex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commonNameRegexInput() {
    return this._commonNameRegex;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // max_version - computed: false, optional: true, required: false
  private _maxVersion?: string; 
  public get maxVersion() {
    return this.getStringAttribute('max_version');
  }
  public set maxVersion(value: string) {
    this._maxVersion = value;
  }
  public resetMaxVersion() {
    this._maxVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxVersionInput() {
    return this._maxVersion;
  }

  // min_version - computed: false, optional: true, required: false
  private _minVersion?: string; 
  public get minVersion() {
    return this.getStringAttribute('min_version');
  }
  public set minVersion(value: string) {
    this._minVersion = value;
  }
  public resetMinVersion() {
    this._minVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get minVersionInput() {
    return this._minVersion;
  }

  // passphrase - computed: false, optional: true, required: false
  private _passphrase?: string; 
  public get passphrase() {
    return this.getStringAttribute('passphrase');
  }
  public set passphrase(value: string) {
    this._passphrase = value;
  }
  public resetPassphrase() {
    this._passphrase = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passphraseInput() {
    return this._passphrase;
  }

  // priv_key_path - computed: false, optional: true, required: false
  private _privKeyPath?: string; 
  public get privKeyPath() {
    return this.getStringAttribute('priv_key_path');
  }
  public set privKeyPath(value: string) {
    this._privKeyPath = value;
  }
  public resetPrivKeyPath() {
    this._privKeyPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get privKeyPathInput() {
    return this._privKeyPath;
  }

  // reject_unauthorized - computed: false, optional: true, required: false
  private _rejectUnauthorized?: string; 
  public get rejectUnauthorized() {
    return this.getStringAttribute('reject_unauthorized');
  }
  public set rejectUnauthorized(value: string) {
    this._rejectUnauthorized = value;
  }
  public resetRejectUnauthorized() {
    this._rejectUnauthorized = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectUnauthorizedInput() {
    return this._rejectUnauthorized;
  }

  // request_cert - computed: true, optional: true, required: false
  private _requestCert?: boolean | cdktf.IResolvable; 
  public get requestCert() {
    return this.getBooleanAttribute('request_cert');
  }
  public set requestCert(value: boolean | cdktf.IResolvable) {
    this._requestCert = value;
  }
  public resetRequestCert() {
    this._requestCert = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestCertInput() {
    return this._requestCert;
  }
}
export interface SourceInputSyslogInputSyslogSyslog2 {
  /**
  * Enable if RFC 3164-formatted messages have hyphens in the app name portion of the TAG section. If disabled, only alphanumeric characters and underscores are allowed. Ignored for RFC 5424-formatted messages. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#allow_non_standard_app_name Source#allow_non_standard_app_name}
  */
  readonly allowNonStandardAppName?: boolean | cdktf.IResolvable;
  /**
  * Direct connections to Destinations, and optionally via a Pipeline or a Pack
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#connections Source#connections}
  */
  readonly connections?: SourceInputSyslogInputSyslogSyslog2Connections[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#description Source#description}
  */
  readonly description?: string;
  /**
  * Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#disabled Source#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * When enabled, parses PROXY protocol headers during the TLS handshake. Disable if compatibility issues arise.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#enable_enhanced_proxy_header_parsing Source#enable_enhanced_proxy_header_parsing}
  */
  readonly enableEnhancedProxyHeaderParsing?: boolean | cdktf.IResolvable;
  /**
  * Load balance traffic across all Worker Processes. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#enable_load_balancing Source#enable_load_balancing}
  */
  readonly enableLoadBalancing?: boolean | cdktf.IResolvable;
  /**
  * Enable if the connection is proxied by a device that supports Proxy Protocol V1 or V2. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#enable_proxy_header Source#enable_proxy_header}
  */
  readonly enableProxyHeader?: boolean | cdktf.IResolvable;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#environment Source#environment}
  */
  readonly environment?: string;
  /**
  * Address to bind on. For IPv4 (all addresses), use the default '0.0.0.0'. For IPv6, enter '::' (all addresses) or specify an IP address. Default: "0.0.0.0"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#host Source#host}
  */
  readonly host?: string;
  /**
  * Unique ID for this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#id Source#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * Enable if we should infer the syslog framing of the incoming messages. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#infer_framing Source#infer_framing}
  */
  readonly inferFraming?: boolean | cdktf.IResolvable;
  /**
  * Regex matching IP addresses that are allowed to send data. Default: "/.* /"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#ip_whitelist_regex Source#ip_whitelist_regex}
   *
  * Note: The above comment contained a comment block ending sequence (* followed by /). We have introduced a space between to prevent syntax errors. Please ignore the space.
  */
  readonly ipWhitelistRegex?: string;
  /**
  * Wildcard list of fields to keep from source data; * = ALL (default). Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#keep_fields_list Source#keep_fields_list}
  */
  readonly keepFieldsList?: string[];
  /**
  * Maximum number of active connections allowed per Worker Process for TCP connections. Use 0 for unlimited. Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_active_cxn Source#max_active_cxn}
  */
  readonly maxActiveCxn?: number;
  /**
  * Maximum number of events to buffer when downstream is blocking. Only applies to UDP. Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_buffer_size Source#max_buffer_size}
  */
  readonly maxBufferSize?: number;
  /**
  * Fields to add to events from this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#metadata Source#metadata}
  */
  readonly metadata?: SourceInputSyslogInputSyslogSyslog2Metadata[] | cdktf.IResolvable;
  /**
  * Enable if incoming messages use octet counting per RFC 6587. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#octet_counting Source#octet_counting}
  */
  readonly octetCounting?: boolean | cdktf.IResolvable;
  /**
  * Pipeline to process data from this Source before sending it through the Routes
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#pipeline Source#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#pq Source#pq}
  */
  readonly pq?: SourceInputSyslogInputSyslogSyslog2Pq;
  /**
  * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers). Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#pq_enabled Source#pq_enabled}
  */
  readonly pqEnabled?: boolean | cdktf.IResolvable;
  /**
  * Select whether to send data to Routes, or directly to Destinations. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#send_to_routes Source#send_to_routes}
  */
  readonly sendToRoutes?: boolean | cdktf.IResolvable;
  /**
  * Treat UDP packet data received as full syslog message. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#single_msg_udp_packets Source#single_msg_udp_packets}
  */
  readonly singleMsgUdpPackets?: boolean | cdktf.IResolvable;
  /**
  * How long the server will wait after initiating a closure for a client to close its end of the connection. If the client doesn't close the connection within this time, the server will forcefully terminate the socket to prevent resource leaks and ensure efficient connection cleanup and system stability. Leave at 0 for no inactive socket monitoring. Default: 30
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#socket_ending_max_wait Source#socket_ending_max_wait}
  */
  readonly socketEndingMaxWait?: number;
  /**
  * How long @{product} should wait before assuming that an inactive socket has timed out. After this time, the connection will be closed. Leave at 0 for no inactive socket monitoring. Default: 0
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#socket_idle_timeout Source#socket_idle_timeout}
  */
  readonly socketIdleTimeout?: number;
  /**
  * The maximum duration a socket can remain open, even if active. This helps manage resources and mitigate issues caused by TCP pinning. Set to 0 to disable. Default: 0
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#socket_max_lifespan Source#socket_max_lifespan}
  */
  readonly socketMaxLifespan?: number;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#streamtags Source#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Enable if we should infer octet counting only if the messages comply with RFC 5424. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#strictly_infer_octet_counting Source#strictly_infer_octet_counting}
  */
  readonly strictlyInferOctetCounting?: boolean | cdktf.IResolvable;
  /**
  * Enter TCP port number to listen on. Not required if listening on UDP.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#tcp_port Source#tcp_port}
  */
  readonly tcpPort: number;
  /**
  * Timezone to assign to timestamps without timezone info. Default: "local"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#timestamp_timezone Source#timestamp_timezone}
  */
  readonly timestampTimezone?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#tls Source#tls}
  */
  readonly tls?: SourceInputSyslogInputSyslogSyslog2Tls;
  /**
  * must be "syslog"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#type Source#type}
  */
  readonly type: string;
  /**
  * Enter UDP port number to listen on. Not required if listening on TCP.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#udp_port Source#udp_port}
  */
  readonly udpPort?: number;
  /**
  * Optionally, set the SO_RCVBUF socket option for the UDP socket. This value tells the operating system how many bytes can be buffered in the kernel before events are dropped. Leave blank to use the OS default. Caution: Increasing this value will affect OS memory utilization.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#udp_socket_rx_buf_size Source#udp_socket_rx_buf_size}
  */
  readonly udpSocketRxBufSize?: number;
}

export function sourceInputSyslogInputSyslogSyslog2ToTerraform(struct?: SourceInputSyslogInputSyslogSyslog2 | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    allow_non_standard_app_name: cdktf.booleanToTerraform(struct!.allowNonStandardAppName),
    connections: cdktf.listMapper(sourceInputSyslogInputSyslogSyslog2ConnectionsToTerraform, false)(struct!.connections),
    description: cdktf.stringToTerraform(struct!.description),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    enable_enhanced_proxy_header_parsing: cdktf.booleanToTerraform(struct!.enableEnhancedProxyHeaderParsing),
    enable_load_balancing: cdktf.booleanToTerraform(struct!.enableLoadBalancing),
    enable_proxy_header: cdktf.booleanToTerraform(struct!.enableProxyHeader),
    environment: cdktf.stringToTerraform(struct!.environment),
    host: cdktf.stringToTerraform(struct!.host),
    id: cdktf.stringToTerraform(struct!.id),
    infer_framing: cdktf.booleanToTerraform(struct!.inferFraming),
    ip_whitelist_regex: cdktf.stringToTerraform(struct!.ipWhitelistRegex),
    keep_fields_list: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.keepFieldsList),
    max_active_cxn: cdktf.numberToTerraform(struct!.maxActiveCxn),
    max_buffer_size: cdktf.numberToTerraform(struct!.maxBufferSize),
    metadata: cdktf.listMapper(sourceInputSyslogInputSyslogSyslog2MetadataToTerraform, false)(struct!.metadata),
    octet_counting: cdktf.booleanToTerraform(struct!.octetCounting),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    pq: sourceInputSyslogInputSyslogSyslog2PqToTerraform(struct!.pq),
    pq_enabled: cdktf.booleanToTerraform(struct!.pqEnabled),
    send_to_routes: cdktf.booleanToTerraform(struct!.sendToRoutes),
    single_msg_udp_packets: cdktf.booleanToTerraform(struct!.singleMsgUdpPackets),
    socket_ending_max_wait: cdktf.numberToTerraform(struct!.socketEndingMaxWait),
    socket_idle_timeout: cdktf.numberToTerraform(struct!.socketIdleTimeout),
    socket_max_lifespan: cdktf.numberToTerraform(struct!.socketMaxLifespan),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    strictly_infer_octet_counting: cdktf.booleanToTerraform(struct!.strictlyInferOctetCounting),
    tcp_port: cdktf.numberToTerraform(struct!.tcpPort),
    timestamp_timezone: cdktf.stringToTerraform(struct!.timestampTimezone),
    tls: sourceInputSyslogInputSyslogSyslog2TlsToTerraform(struct!.tls),
    type: cdktf.stringToTerraform(struct!.type),
    udp_port: cdktf.numberToTerraform(struct!.udpPort),
    udp_socket_rx_buf_size: cdktf.numberToTerraform(struct!.udpSocketRxBufSize),
  }
}


export function sourceInputSyslogInputSyslogSyslog2ToHclTerraform(struct?: SourceInputSyslogInputSyslogSyslog2 | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    allow_non_standard_app_name: {
      value: cdktf.booleanToHclTerraform(struct!.allowNonStandardAppName),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    connections: {
      value: cdktf.listMapperHcl(sourceInputSyslogInputSyslogSyslog2ConnectionsToHclTerraform, false)(struct!.connections),
      isBlock: true,
      type: "list",
      storageClassType: "SourceInputSyslogInputSyslogSyslog2ConnectionsList",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    enable_enhanced_proxy_header_parsing: {
      value: cdktf.booleanToHclTerraform(struct!.enableEnhancedProxyHeaderParsing),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    enable_load_balancing: {
      value: cdktf.booleanToHclTerraform(struct!.enableLoadBalancing),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    enable_proxy_header: {
      value: cdktf.booleanToHclTerraform(struct!.enableProxyHeader),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    host: {
      value: cdktf.stringToHclTerraform(struct!.host),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    infer_framing: {
      value: cdktf.booleanToHclTerraform(struct!.inferFraming),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    ip_whitelist_regex: {
      value: cdktf.stringToHclTerraform(struct!.ipWhitelistRegex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    keep_fields_list: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.keepFieldsList),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    max_active_cxn: {
      value: cdktf.numberToHclTerraform(struct!.maxActiveCxn),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_buffer_size: {
      value: cdktf.numberToHclTerraform(struct!.maxBufferSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    metadata: {
      value: cdktf.listMapperHcl(sourceInputSyslogInputSyslogSyslog2MetadataToHclTerraform, false)(struct!.metadata),
      isBlock: true,
      type: "list",
      storageClassType: "SourceInputSyslogInputSyslogSyslog2MetadataList",
    },
    octet_counting: {
      value: cdktf.booleanToHclTerraform(struct!.octetCounting),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq: {
      value: sourceInputSyslogInputSyslogSyslog2PqToHclTerraform(struct!.pq),
      isBlock: true,
      type: "struct",
      storageClassType: "SourceInputSyslogInputSyslogSyslog2Pq",
    },
    pq_enabled: {
      value: cdktf.booleanToHclTerraform(struct!.pqEnabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    send_to_routes: {
      value: cdktf.booleanToHclTerraform(struct!.sendToRoutes),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    single_msg_udp_packets: {
      value: cdktf.booleanToHclTerraform(struct!.singleMsgUdpPackets),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    socket_ending_max_wait: {
      value: cdktf.numberToHclTerraform(struct!.socketEndingMaxWait),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    socket_idle_timeout: {
      value: cdktf.numberToHclTerraform(struct!.socketIdleTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    socket_max_lifespan: {
      value: cdktf.numberToHclTerraform(struct!.socketMaxLifespan),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    strictly_infer_octet_counting: {
      value: cdktf.booleanToHclTerraform(struct!.strictlyInferOctetCounting),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    tcp_port: {
      value: cdktf.numberToHclTerraform(struct!.tcpPort),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    timestamp_timezone: {
      value: cdktf.stringToHclTerraform(struct!.timestampTimezone),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tls: {
      value: sourceInputSyslogInputSyslogSyslog2TlsToHclTerraform(struct!.tls),
      isBlock: true,
      type: "struct",
      storageClassType: "SourceInputSyslogInputSyslogSyslog2Tls",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    udp_port: {
      value: cdktf.numberToHclTerraform(struct!.udpPort),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    udp_socket_rx_buf_size: {
      value: cdktf.numberToHclTerraform(struct!.udpSocketRxBufSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputSyslogInputSyslogSyslog2OutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SourceInputSyslogInputSyslogSyslog2 | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._allowNonStandardAppName !== undefined) {
      hasAnyValues = true;
      internalValueResult.allowNonStandardAppName = this._allowNonStandardAppName;
    }
    if (this._connections?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.connections = this._connections?.internalValue;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._enableEnhancedProxyHeaderParsing !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableEnhancedProxyHeaderParsing = this._enableEnhancedProxyHeaderParsing;
    }
    if (this._enableLoadBalancing !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableLoadBalancing = this._enableLoadBalancing;
    }
    if (this._enableProxyHeader !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableProxyHeader = this._enableProxyHeader;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._host !== undefined) {
      hasAnyValues = true;
      internalValueResult.host = this._host;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._inferFraming !== undefined) {
      hasAnyValues = true;
      internalValueResult.inferFraming = this._inferFraming;
    }
    if (this._ipWhitelistRegex !== undefined) {
      hasAnyValues = true;
      internalValueResult.ipWhitelistRegex = this._ipWhitelistRegex;
    }
    if (this._keepFieldsList !== undefined) {
      hasAnyValues = true;
      internalValueResult.keepFieldsList = this._keepFieldsList;
    }
    if (this._maxActiveCxn !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxActiveCxn = this._maxActiveCxn;
    }
    if (this._maxBufferSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBufferSize = this._maxBufferSize;
    }
    if (this._metadata?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadata = this._metadata?.internalValue;
    }
    if (this._octetCounting !== undefined) {
      hasAnyValues = true;
      internalValueResult.octetCounting = this._octetCounting;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._pq?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pq = this._pq?.internalValue;
    }
    if (this._pqEnabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqEnabled = this._pqEnabled;
    }
    if (this._sendToRoutes !== undefined) {
      hasAnyValues = true;
      internalValueResult.sendToRoutes = this._sendToRoutes;
    }
    if (this._singleMsgUdpPackets !== undefined) {
      hasAnyValues = true;
      internalValueResult.singleMsgUdpPackets = this._singleMsgUdpPackets;
    }
    if (this._socketEndingMaxWait !== undefined) {
      hasAnyValues = true;
      internalValueResult.socketEndingMaxWait = this._socketEndingMaxWait;
    }
    if (this._socketIdleTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.socketIdleTimeout = this._socketIdleTimeout;
    }
    if (this._socketMaxLifespan !== undefined) {
      hasAnyValues = true;
      internalValueResult.socketMaxLifespan = this._socketMaxLifespan;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._strictlyInferOctetCounting !== undefined) {
      hasAnyValues = true;
      internalValueResult.strictlyInferOctetCounting = this._strictlyInferOctetCounting;
    }
    if (this._tcpPort !== undefined) {
      hasAnyValues = true;
      internalValueResult.tcpPort = this._tcpPort;
    }
    if (this._timestampTimezone !== undefined) {
      hasAnyValues = true;
      internalValueResult.timestampTimezone = this._timestampTimezone;
    }
    if (this._tls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tls = this._tls?.internalValue;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    if (this._udpPort !== undefined) {
      hasAnyValues = true;
      internalValueResult.udpPort = this._udpPort;
    }
    if (this._udpSocketRxBufSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.udpSocketRxBufSize = this._udpSocketRxBufSize;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputSyslogInputSyslogSyslog2 | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._allowNonStandardAppName = undefined;
      this._connections.internalValue = undefined;
      this._description = undefined;
      this._disabled = undefined;
      this._enableEnhancedProxyHeaderParsing = undefined;
      this._enableLoadBalancing = undefined;
      this._enableProxyHeader = undefined;
      this._environment = undefined;
      this._host = undefined;
      this._id = undefined;
      this._inferFraming = undefined;
      this._ipWhitelistRegex = undefined;
      this._keepFieldsList = undefined;
      this._maxActiveCxn = undefined;
      this._maxBufferSize = undefined;
      this._metadata.internalValue = undefined;
      this._octetCounting = undefined;
      this._pipeline = undefined;
      this._pq.internalValue = undefined;
      this._pqEnabled = undefined;
      this._sendToRoutes = undefined;
      this._singleMsgUdpPackets = undefined;
      this._socketEndingMaxWait = undefined;
      this._socketIdleTimeout = undefined;
      this._socketMaxLifespan = undefined;
      this._streamtags = undefined;
      this._strictlyInferOctetCounting = undefined;
      this._tcpPort = undefined;
      this._timestampTimezone = undefined;
      this._tls.internalValue = undefined;
      this._type = undefined;
      this._udpPort = undefined;
      this._udpSocketRxBufSize = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._allowNonStandardAppName = value.allowNonStandardAppName;
      this._connections.internalValue = value.connections;
      this._description = value.description;
      this._disabled = value.disabled;
      this._enableEnhancedProxyHeaderParsing = value.enableEnhancedProxyHeaderParsing;
      this._enableLoadBalancing = value.enableLoadBalancing;
      this._enableProxyHeader = value.enableProxyHeader;
      this._environment = value.environment;
      this._host = value.host;
      this._id = value.id;
      this._inferFraming = value.inferFraming;
      this._ipWhitelistRegex = value.ipWhitelistRegex;
      this._keepFieldsList = value.keepFieldsList;
      this._maxActiveCxn = value.maxActiveCxn;
      this._maxBufferSize = value.maxBufferSize;
      this._metadata.internalValue = value.metadata;
      this._octetCounting = value.octetCounting;
      this._pipeline = value.pipeline;
      this._pq.internalValue = value.pq;
      this._pqEnabled = value.pqEnabled;
      this._sendToRoutes = value.sendToRoutes;
      this._singleMsgUdpPackets = value.singleMsgUdpPackets;
      this._socketEndingMaxWait = value.socketEndingMaxWait;
      this._socketIdleTimeout = value.socketIdleTimeout;
      this._socketMaxLifespan = value.socketMaxLifespan;
      this._streamtags = value.streamtags;
      this._strictlyInferOctetCounting = value.strictlyInferOctetCounting;
      this._tcpPort = value.tcpPort;
      this._timestampTimezone = value.timestampTimezone;
      this._tls.internalValue = value.tls;
      this._type = value.type;
      this._udpPort = value.udpPort;
      this._udpSocketRxBufSize = value.udpSocketRxBufSize;
    }
  }

  // allow_non_standard_app_name - computed: true, optional: true, required: false
  private _allowNonStandardAppName?: boolean | cdktf.IResolvable; 
  public get allowNonStandardAppName() {
    return this.getBooleanAttribute('allow_non_standard_app_name');
  }
  public set allowNonStandardAppName(value: boolean | cdktf.IResolvable) {
    this._allowNonStandardAppName = value;
  }
  public resetAllowNonStandardAppName() {
    this._allowNonStandardAppName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get allowNonStandardAppNameInput() {
    return this._allowNonStandardAppName;
  }

  // connections - computed: false, optional: true, required: false
  private _connections = new SourceInputSyslogInputSyslogSyslog2ConnectionsList(this, "connections", false);
  public get connections() {
    return this._connections;
  }
  public putConnections(value: SourceInputSyslogInputSyslogSyslog2Connections[] | cdktf.IResolvable) {
    this._connections.internalValue = value;
  }
  public resetConnections() {
    this._connections.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectionsInput() {
    return this._connections.internalValue;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // enable_enhanced_proxy_header_parsing - computed: false, optional: true, required: false
  private _enableEnhancedProxyHeaderParsing?: boolean | cdktf.IResolvable; 
  public get enableEnhancedProxyHeaderParsing() {
    return this.getBooleanAttribute('enable_enhanced_proxy_header_parsing');
  }
  public set enableEnhancedProxyHeaderParsing(value: boolean | cdktf.IResolvable) {
    this._enableEnhancedProxyHeaderParsing = value;
  }
  public resetEnableEnhancedProxyHeaderParsing() {
    this._enableEnhancedProxyHeaderParsing = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableEnhancedProxyHeaderParsingInput() {
    return this._enableEnhancedProxyHeaderParsing;
  }

  // enable_load_balancing - computed: true, optional: true, required: false
  private _enableLoadBalancing?: boolean | cdktf.IResolvable; 
  public get enableLoadBalancing() {
    return this.getBooleanAttribute('enable_load_balancing');
  }
  public set enableLoadBalancing(value: boolean | cdktf.IResolvable) {
    this._enableLoadBalancing = value;
  }
  public resetEnableLoadBalancing() {
    this._enableLoadBalancing = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableLoadBalancingInput() {
    return this._enableLoadBalancing;
  }

  // enable_proxy_header - computed: true, optional: true, required: false
  private _enableProxyHeader?: boolean | cdktf.IResolvable; 
  public get enableProxyHeader() {
    return this.getBooleanAttribute('enable_proxy_header');
  }
  public set enableProxyHeader(value: boolean | cdktf.IResolvable) {
    this._enableProxyHeader = value;
  }
  public resetEnableProxyHeader() {
    this._enableProxyHeader = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableProxyHeaderInput() {
    return this._enableProxyHeader;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // host - computed: true, optional: true, required: false
  private _host?: string; 
  public get host() {
    return this.getStringAttribute('host');
  }
  public set host(value: string) {
    this._host = value;
  }
  public resetHost() {
    this._host = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostInput() {
    return this._host;
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // infer_framing - computed: true, optional: true, required: false
  private _inferFraming?: boolean | cdktf.IResolvable; 
  public get inferFraming() {
    return this.getBooleanAttribute('infer_framing');
  }
  public set inferFraming(value: boolean | cdktf.IResolvable) {
    this._inferFraming = value;
  }
  public resetInferFraming() {
    this._inferFraming = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get inferFramingInput() {
    return this._inferFraming;
  }

  // ip_whitelist_regex - computed: true, optional: true, required: false
  private _ipWhitelistRegex?: string; 
  public get ipWhitelistRegex() {
    return this.getStringAttribute('ip_whitelist_regex');
  }
  public set ipWhitelistRegex(value: string) {
    this._ipWhitelistRegex = value;
  }
  public resetIpWhitelistRegex() {
    this._ipWhitelistRegex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ipWhitelistRegexInput() {
    return this._ipWhitelistRegex;
  }

  // keep_fields_list - computed: true, optional: true, required: false
  private _keepFieldsList?: string[]; 
  public get keepFieldsList() {
    return this.getListAttribute('keep_fields_list');
  }
  public set keepFieldsList(value: string[]) {
    this._keepFieldsList = value;
  }
  public resetKeepFieldsList() {
    this._keepFieldsList = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keepFieldsListInput() {
    return this._keepFieldsList;
  }

  // max_active_cxn - computed: true, optional: true, required: false
  private _maxActiveCxn?: number; 
  public get maxActiveCxn() {
    return this.getNumberAttribute('max_active_cxn');
  }
  public set maxActiveCxn(value: number) {
    this._maxActiveCxn = value;
  }
  public resetMaxActiveCxn() {
    this._maxActiveCxn = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxActiveCxnInput() {
    return this._maxActiveCxn;
  }

  // max_buffer_size - computed: true, optional: true, required: false
  private _maxBufferSize?: number; 
  public get maxBufferSize() {
    return this.getNumberAttribute('max_buffer_size');
  }
  public set maxBufferSize(value: number) {
    this._maxBufferSize = value;
  }
  public resetMaxBufferSize() {
    this._maxBufferSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBufferSizeInput() {
    return this._maxBufferSize;
  }

  // metadata - computed: false, optional: true, required: false
  private _metadata = new SourceInputSyslogInputSyslogSyslog2MetadataList(this, "metadata", false);
  public get metadata() {
    return this._metadata;
  }
  public putMetadata(value: SourceInputSyslogInputSyslogSyslog2Metadata[] | cdktf.IResolvable) {
    this._metadata.internalValue = value;
  }
  public resetMetadata() {
    this._metadata.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataInput() {
    return this._metadata.internalValue;
  }

  // octet_counting - computed: true, optional: true, required: false
  private _octetCounting?: boolean | cdktf.IResolvable; 
  public get octetCounting() {
    return this.getBooleanAttribute('octet_counting');
  }
  public set octetCounting(value: boolean | cdktf.IResolvable) {
    this._octetCounting = value;
  }
  public resetOctetCounting() {
    this._octetCounting = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get octetCountingInput() {
    return this._octetCounting;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // pq - computed: false, optional: true, required: false
  private _pq = new SourceInputSyslogInputSyslogSyslog2PqOutputReference(this, "pq");
  public get pq() {
    return this._pq;
  }
  public putPq(value: SourceInputSyslogInputSyslogSyslog2Pq) {
    this._pq.internalValue = value;
  }
  public resetPq() {
    this._pq.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqInput() {
    return this._pq.internalValue;
  }

  // pq_enabled - computed: true, optional: true, required: false
  private _pqEnabled?: boolean | cdktf.IResolvable; 
  public get pqEnabled() {
    return this.getBooleanAttribute('pq_enabled');
  }
  public set pqEnabled(value: boolean | cdktf.IResolvable) {
    this._pqEnabled = value;
  }
  public resetPqEnabled() {
    this._pqEnabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqEnabledInput() {
    return this._pqEnabled;
  }

  // send_to_routes - computed: true, optional: true, required: false
  private _sendToRoutes?: boolean | cdktf.IResolvable; 
  public get sendToRoutes() {
    return this.getBooleanAttribute('send_to_routes');
  }
  public set sendToRoutes(value: boolean | cdktf.IResolvable) {
    this._sendToRoutes = value;
  }
  public resetSendToRoutes() {
    this._sendToRoutes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sendToRoutesInput() {
    return this._sendToRoutes;
  }

  // single_msg_udp_packets - computed: true, optional: true, required: false
  private _singleMsgUdpPackets?: boolean | cdktf.IResolvable; 
  public get singleMsgUdpPackets() {
    return this.getBooleanAttribute('single_msg_udp_packets');
  }
  public set singleMsgUdpPackets(value: boolean | cdktf.IResolvable) {
    this._singleMsgUdpPackets = value;
  }
  public resetSingleMsgUdpPackets() {
    this._singleMsgUdpPackets = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get singleMsgUdpPacketsInput() {
    return this._singleMsgUdpPackets;
  }

  // socket_ending_max_wait - computed: true, optional: true, required: false
  private _socketEndingMaxWait?: number; 
  public get socketEndingMaxWait() {
    return this.getNumberAttribute('socket_ending_max_wait');
  }
  public set socketEndingMaxWait(value: number) {
    this._socketEndingMaxWait = value;
  }
  public resetSocketEndingMaxWait() {
    this._socketEndingMaxWait = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get socketEndingMaxWaitInput() {
    return this._socketEndingMaxWait;
  }

  // socket_idle_timeout - computed: true, optional: true, required: false
  private _socketIdleTimeout?: number; 
  public get socketIdleTimeout() {
    return this.getNumberAttribute('socket_idle_timeout');
  }
  public set socketIdleTimeout(value: number) {
    this._socketIdleTimeout = value;
  }
  public resetSocketIdleTimeout() {
    this._socketIdleTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get socketIdleTimeoutInput() {
    return this._socketIdleTimeout;
  }

  // socket_max_lifespan - computed: true, optional: true, required: false
  private _socketMaxLifespan?: number; 
  public get socketMaxLifespan() {
    return this.getNumberAttribute('socket_max_lifespan');
  }
  public set socketMaxLifespan(value: number) {
    this._socketMaxLifespan = value;
  }
  public resetSocketMaxLifespan() {
    this._socketMaxLifespan = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get socketMaxLifespanInput() {
    return this._socketMaxLifespan;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // strictly_infer_octet_counting - computed: true, optional: true, required: false
  private _strictlyInferOctetCounting?: boolean | cdktf.IResolvable; 
  public get strictlyInferOctetCounting() {
    return this.getBooleanAttribute('strictly_infer_octet_counting');
  }
  public set strictlyInferOctetCounting(value: boolean | cdktf.IResolvable) {
    this._strictlyInferOctetCounting = value;
  }
  public resetStrictlyInferOctetCounting() {
    this._strictlyInferOctetCounting = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get strictlyInferOctetCountingInput() {
    return this._strictlyInferOctetCounting;
  }

  // tcp_port - computed: false, optional: false, required: true
  private _tcpPort?: number; 
  public get tcpPort() {
    return this.getNumberAttribute('tcp_port');
  }
  public set tcpPort(value: number) {
    this._tcpPort = value;
  }
  // Temporarily expose input value. Use with caution.
  public get tcpPortInput() {
    return this._tcpPort;
  }

  // timestamp_timezone - computed: true, optional: true, required: false
  private _timestampTimezone?: string; 
  public get timestampTimezone() {
    return this.getStringAttribute('timestamp_timezone');
  }
  public set timestampTimezone(value: string) {
    this._timestampTimezone = value;
  }
  public resetTimestampTimezone() {
    this._timestampTimezone = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timestampTimezoneInput() {
    return this._timestampTimezone;
  }

  // tls - computed: false, optional: true, required: false
  private _tls = new SourceInputSyslogInputSyslogSyslog2TlsOutputReference(this, "tls");
  public get tls() {
    return this._tls;
  }
  public putTls(value: SourceInputSyslogInputSyslogSyslog2Tls) {
    this._tls.internalValue = value;
  }
  public resetTls() {
    this._tls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsInput() {
    return this._tls.internalValue;
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }

  // udp_port - computed: false, optional: true, required: false
  private _udpPort?: number; 
  public get udpPort() {
    return this.getNumberAttribute('udp_port');
  }
  public set udpPort(value: number) {
    this._udpPort = value;
  }
  public resetUdpPort() {
    this._udpPort = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get udpPortInput() {
    return this._udpPort;
  }

  // udp_socket_rx_buf_size - computed: false, optional: true, required: false
  private _udpSocketRxBufSize?: number; 
  public get udpSocketRxBufSize() {
    return this.getNumberAttribute('udp_socket_rx_buf_size');
  }
  public set udpSocketRxBufSize(value: number) {
    this._udpSocketRxBufSize = value;
  }
  public resetUdpSocketRxBufSize() {
    this._udpSocketRxBufSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get udpSocketRxBufSizeInput() {
    return this._udpSocketRxBufSize;
  }
}
export interface SourceInputSyslog {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#input_syslog_syslog1 Source#input_syslog_syslog1}
  */
  readonly inputSyslogSyslog1?: SourceInputSyslogInputSyslogSyslog1;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#input_syslog_syslog2 Source#input_syslog_syslog2}
  */
  readonly inputSyslogSyslog2?: SourceInputSyslogInputSyslogSyslog2;
}

export function sourceInputSyslogToTerraform(struct?: SourceInputSyslog | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    input_syslog_syslog1: sourceInputSyslogInputSyslogSyslog1ToTerraform(struct!.inputSyslogSyslog1),
    input_syslog_syslog2: sourceInputSyslogInputSyslogSyslog2ToTerraform(struct!.inputSyslogSyslog2),
  }
}


export function sourceInputSyslogToHclTerraform(struct?: SourceInputSyslog | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    input_syslog_syslog1: {
      value: sourceInputSyslogInputSyslogSyslog1ToHclTerraform(struct!.inputSyslogSyslog1),
      isBlock: true,
      type: "struct",
      storageClassType: "SourceInputSyslogInputSyslogSyslog1",
    },
    input_syslog_syslog2: {
      value: sourceInputSyslogInputSyslogSyslog2ToHclTerraform(struct!.inputSyslogSyslog2),
      isBlock: true,
      type: "struct",
      storageClassType: "SourceInputSyslogInputSyslogSyslog2",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputSyslogOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SourceInputSyslog | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._inputSyslogSyslog1?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.inputSyslogSyslog1 = this._inputSyslogSyslog1?.internalValue;
    }
    if (this._inputSyslogSyslog2?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.inputSyslogSyslog2 = this._inputSyslogSyslog2?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputSyslog | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._inputSyslogSyslog1.internalValue = undefined;
      this._inputSyslogSyslog2.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._inputSyslogSyslog1.internalValue = value.inputSyslogSyslog1;
      this._inputSyslogSyslog2.internalValue = value.inputSyslogSyslog2;
    }
  }

  // input_syslog_syslog1 - computed: false, optional: true, required: false
  private _inputSyslogSyslog1 = new SourceInputSyslogInputSyslogSyslog1OutputReference(this, "input_syslog_syslog1");
  public get inputSyslogSyslog1() {
    return this._inputSyslogSyslog1;
  }
  public putInputSyslogSyslog1(value: SourceInputSyslogInputSyslogSyslog1) {
    this._inputSyslogSyslog1.internalValue = value;
  }
  public resetInputSyslogSyslog1() {
    this._inputSyslogSyslog1.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get inputSyslogSyslog1Input() {
    return this._inputSyslogSyslog1.internalValue;
  }

  // input_syslog_syslog2 - computed: false, optional: true, required: false
  private _inputSyslogSyslog2 = new SourceInputSyslogInputSyslogSyslog2OutputReference(this, "input_syslog_syslog2");
  public get inputSyslogSyslog2() {
    return this._inputSyslogSyslog2;
  }
  public putInputSyslogSyslog2(value: SourceInputSyslogInputSyslogSyslog2) {
    this._inputSyslogSyslog2.internalValue = value;
  }
  public resetInputSyslogSyslog2() {
    this._inputSyslogSyslog2.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get inputSyslogSyslog2Input() {
    return this._inputSyslogSyslog2.internalValue;
  }
}
export interface SourceInputSystemMetricsConnections {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#output Source#output}
  */
  readonly output: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#pipeline Source#pipeline}
  */
  readonly pipeline?: string;
}

export function sourceInputSystemMetricsConnectionsToTerraform(struct?: SourceInputSystemMetricsConnections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    output: cdktf.stringToTerraform(struct!.output),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
  }
}


export function sourceInputSystemMetricsConnectionsToHclTerraform(struct?: SourceInputSystemMetricsConnections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    output: {
      value: cdktf.stringToHclTerraform(struct!.output),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputSystemMetricsConnectionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): SourceInputSystemMetricsConnections | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._output !== undefined) {
      hasAnyValues = true;
      internalValueResult.output = this._output;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputSystemMetricsConnections | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._output = undefined;
      this._pipeline = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._output = value.output;
      this._pipeline = value.pipeline;
    }
  }

  // output - computed: false, optional: false, required: true
  private _output?: string; 
  public get output() {
    return this.getStringAttribute('output');
  }
  public set output(value: string) {
    this._output = value;
  }
  // Temporarily expose input value. Use with caution.
  public get outputInput() {
    return this._output;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }
}

export class SourceInputSystemMetricsConnectionsList extends cdktf.ComplexList {
  public internalValue? : SourceInputSystemMetricsConnections[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): SourceInputSystemMetricsConnectionsOutputReference {
    return new SourceInputSystemMetricsConnectionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface SourceInputSystemMetricsContainerFilters {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#expr Source#expr}
  */
  readonly expr: string;
}

export function sourceInputSystemMetricsContainerFiltersToTerraform(struct?: SourceInputSystemMetricsContainerFilters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    expr: cdktf.stringToTerraform(struct!.expr),
  }
}


export function sourceInputSystemMetricsContainerFiltersToHclTerraform(struct?: SourceInputSystemMetricsContainerFilters | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    expr: {
      value: cdktf.stringToHclTerraform(struct!.expr),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputSystemMetricsContainerFiltersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): SourceInputSystemMetricsContainerFilters | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._expr !== undefined) {
      hasAnyValues = true;
      internalValueResult.expr = this._expr;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputSystemMetricsContainerFilters | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._expr = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._expr = value.expr;
    }
  }

  // expr - computed: false, optional: false, required: true
  private _expr?: string; 
  public get expr() {
    return this.getStringAttribute('expr');
  }
  public set expr(value: string) {
    this._expr = value;
  }
  // Temporarily expose input value. Use with caution.
  public get exprInput() {
    return this._expr;
  }
}

export class SourceInputSystemMetricsContainerFiltersList extends cdktf.ComplexList {
  public internalValue? : SourceInputSystemMetricsContainerFilters[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): SourceInputSystemMetricsContainerFiltersOutputReference {
    return new SourceInputSystemMetricsContainerFiltersOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface SourceInputSystemMetricsContainer {
  /**
  * Include stopped and paused containers. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#all_containers Source#all_containers}
  */
  readonly allContainers?: boolean | cdktf.IResolvable;
  /**
  * Generate full container metrics. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#detail Source#detail}
  */
  readonly detail?: boolean | cdktf.IResolvable;
  /**
  * Full paths for Docker's UNIX-domain socket. Default: ["/var/run/docker.sock","/run/docker.sock"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#docker_socket Source#docker_socket}
  */
  readonly dockerSocket?: string[];
  /**
  * Timeout, in seconds, for the Docker API. Default: 5
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#docker_timeout Source#docker_timeout}
  */
  readonly dockerTimeout?: number;
  /**
  * Containers matching any of these will be included. All are included if no filters are added.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#filters Source#filters}
  */
  readonly filters?: SourceInputSystemMetricsContainerFilters[] | cdktf.IResolvable;
  /**
  * Select the level of detail for container metrics. Default: "basic"; must be one of ["basic", "all", "custom", "disabled"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#mode Source#mode}
  */
  readonly mode?: string;
  /**
  * Generate separate metrics for each device. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#per_device Source#per_device}
  */
  readonly perDevice?: boolean | cdktf.IResolvable;
}

export function sourceInputSystemMetricsContainerToTerraform(struct?: SourceInputSystemMetricsContainer | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    all_containers: cdktf.booleanToTerraform(struct!.allContainers),
    detail: cdktf.booleanToTerraform(struct!.detail),
    docker_socket: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.dockerSocket),
    docker_timeout: cdktf.numberToTerraform(struct!.dockerTimeout),
    filters: cdktf.listMapper(sourceInputSystemMetricsContainerFiltersToTerraform, false)(struct!.filters),
    mode: cdktf.stringToTerraform(struct!.mode),
    per_device: cdktf.booleanToTerraform(struct!.perDevice),
  }
}


export function sourceInputSystemMetricsContainerToHclTerraform(struct?: SourceInputSystemMetricsContainer | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    all_containers: {
      value: cdktf.booleanToHclTerraform(struct!.allContainers),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    detail: {
      value: cdktf.booleanToHclTerraform(struct!.detail),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    docker_socket: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.dockerSocket),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    docker_timeout: {
      value: cdktf.numberToHclTerraform(struct!.dockerTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    filters: {
      value: cdktf.listMapperHcl(sourceInputSystemMetricsContainerFiltersToHclTerraform, false)(struct!.filters),
      isBlock: true,
      type: "list",
      storageClassType: "SourceInputSystemMetricsContainerFiltersList",
    },
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    per_device: {
      value: cdktf.booleanToHclTerraform(struct!.perDevice),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputSystemMetricsContainerOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SourceInputSystemMetricsContainer | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._allContainers !== undefined) {
      hasAnyValues = true;
      internalValueResult.allContainers = this._allContainers;
    }
    if (this._detail !== undefined) {
      hasAnyValues = true;
      internalValueResult.detail = this._detail;
    }
    if (this._dockerSocket !== undefined) {
      hasAnyValues = true;
      internalValueResult.dockerSocket = this._dockerSocket;
    }
    if (this._dockerTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.dockerTimeout = this._dockerTimeout;
    }
    if (this._filters?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.filters = this._filters?.internalValue;
    }
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._perDevice !== undefined) {
      hasAnyValues = true;
      internalValueResult.perDevice = this._perDevice;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputSystemMetricsContainer | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._allContainers = undefined;
      this._detail = undefined;
      this._dockerSocket = undefined;
      this._dockerTimeout = undefined;
      this._filters.internalValue = undefined;
      this._mode = undefined;
      this._perDevice = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._allContainers = value.allContainers;
      this._detail = value.detail;
      this._dockerSocket = value.dockerSocket;
      this._dockerTimeout = value.dockerTimeout;
      this._filters.internalValue = value.filters;
      this._mode = value.mode;
      this._perDevice = value.perDevice;
    }
  }

  // all_containers - computed: true, optional: true, required: false
  private _allContainers?: boolean | cdktf.IResolvable; 
  public get allContainers() {
    return this.getBooleanAttribute('all_containers');
  }
  public set allContainers(value: boolean | cdktf.IResolvable) {
    this._allContainers = value;
  }
  public resetAllContainers() {
    this._allContainers = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get allContainersInput() {
    return this._allContainers;
  }

  // detail - computed: true, optional: true, required: false
  private _detail?: boolean | cdktf.IResolvable; 
  public get detail() {
    return this.getBooleanAttribute('detail');
  }
  public set detail(value: boolean | cdktf.IResolvable) {
    this._detail = value;
  }
  public resetDetail() {
    this._detail = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get detailInput() {
    return this._detail;
  }

  // docker_socket - computed: true, optional: true, required: false
  private _dockerSocket?: string[]; 
  public get dockerSocket() {
    return this.getListAttribute('docker_socket');
  }
  public set dockerSocket(value: string[]) {
    this._dockerSocket = value;
  }
  public resetDockerSocket() {
    this._dockerSocket = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dockerSocketInput() {
    return this._dockerSocket;
  }

  // docker_timeout - computed: true, optional: true, required: false
  private _dockerTimeout?: number; 
  public get dockerTimeout() {
    return this.getNumberAttribute('docker_timeout');
  }
  public set dockerTimeout(value: number) {
    this._dockerTimeout = value;
  }
  public resetDockerTimeout() {
    this._dockerTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dockerTimeoutInput() {
    return this._dockerTimeout;
  }

  // filters - computed: false, optional: true, required: false
  private _filters = new SourceInputSystemMetricsContainerFiltersList(this, "filters", false);
  public get filters() {
    return this._filters;
  }
  public putFilters(value: SourceInputSystemMetricsContainerFilters[] | cdktf.IResolvable) {
    this._filters.internalValue = value;
  }
  public resetFilters() {
    this._filters.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get filtersInput() {
    return this._filters.internalValue;
  }

  // mode - computed: true, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // per_device - computed: true, optional: true, required: false
  private _perDevice?: boolean | cdktf.IResolvable; 
  public get perDevice() {
    return this.getBooleanAttribute('per_device');
  }
  public set perDevice(value: boolean | cdktf.IResolvable) {
    this._perDevice = value;
  }
  public resetPerDevice() {
    this._perDevice = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get perDeviceInput() {
    return this._perDevice;
  }
}
export interface SourceInputSystemMetricsHostCustomCpu {
  /**
  * Generate metrics for all CPU states. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#detail Source#detail}
  */
  readonly detail?: boolean | cdktf.IResolvable;
  /**
  * Select the level of detail for CPU metrics. Default: "basic"; must be one of ["basic", "all", "custom", "disabled"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#mode Source#mode}
  */
  readonly mode?: string;
  /**
  * Generate metrics for each CPU. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#per_cpu Source#per_cpu}
  */
  readonly perCpu?: boolean | cdktf.IResolvable;
  /**
  * Generate raw, monotonic CPU time counters. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#time Source#time}
  */
  readonly time?: boolean | cdktf.IResolvable;
}

export function sourceInputSystemMetricsHostCustomCpuToTerraform(struct?: SourceInputSystemMetricsHostCustomCpu | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    detail: cdktf.booleanToTerraform(struct!.detail),
    mode: cdktf.stringToTerraform(struct!.mode),
    per_cpu: cdktf.booleanToTerraform(struct!.perCpu),
    time: cdktf.booleanToTerraform(struct!.time),
  }
}


export function sourceInputSystemMetricsHostCustomCpuToHclTerraform(struct?: SourceInputSystemMetricsHostCustomCpu | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    detail: {
      value: cdktf.booleanToHclTerraform(struct!.detail),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    per_cpu: {
      value: cdktf.booleanToHclTerraform(struct!.perCpu),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    time: {
      value: cdktf.booleanToHclTerraform(struct!.time),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputSystemMetricsHostCustomCpuOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SourceInputSystemMetricsHostCustomCpu | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._detail !== undefined) {
      hasAnyValues = true;
      internalValueResult.detail = this._detail;
    }
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._perCpu !== undefined) {
      hasAnyValues = true;
      internalValueResult.perCpu = this._perCpu;
    }
    if (this._time !== undefined) {
      hasAnyValues = true;
      internalValueResult.time = this._time;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputSystemMetricsHostCustomCpu | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._detail = undefined;
      this._mode = undefined;
      this._perCpu = undefined;
      this._time = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._detail = value.detail;
      this._mode = value.mode;
      this._perCpu = value.perCpu;
      this._time = value.time;
    }
  }

  // detail - computed: true, optional: true, required: false
  private _detail?: boolean | cdktf.IResolvable; 
  public get detail() {
    return this.getBooleanAttribute('detail');
  }
  public set detail(value: boolean | cdktf.IResolvable) {
    this._detail = value;
  }
  public resetDetail() {
    this._detail = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get detailInput() {
    return this._detail;
  }

  // mode - computed: true, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // per_cpu - computed: true, optional: true, required: false
  private _perCpu?: boolean | cdktf.IResolvable; 
  public get perCpu() {
    return this.getBooleanAttribute('per_cpu');
  }
  public set perCpu(value: boolean | cdktf.IResolvable) {
    this._perCpu = value;
  }
  public resetPerCpu() {
    this._perCpu = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get perCpuInput() {
    return this._perCpu;
  }

  // time - computed: true, optional: true, required: false
  private _time?: boolean | cdktf.IResolvable; 
  public get time() {
    return this.getBooleanAttribute('time');
  }
  public set time(value: boolean | cdktf.IResolvable) {
    this._time = value;
  }
  public resetTime() {
    this._time = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeInput() {
    return this._time;
  }
}
export interface SourceInputSystemMetricsHostCustomDisk {
  /**
  * Generate full disk metrics. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#detail Source#detail}
  */
  readonly detail?: boolean | cdktf.IResolvable;
  /**
  * Block devices to include/exclude. Examples: sda*, !loop*. Wildcards and ! (not) operators are supported. All devices are included if this list is empty. Default: ["!loop*","*"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#devices Source#devices}
  */
  readonly devices?: string[];
  /**
  * Filesystem types to include/exclude. Examples: ext4, !*tmpfs, !squashfs. Wildcards and ! (not) operators are supported. All types are included if this list is empty. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#fstypes Source#fstypes}
  */
  readonly fstypes?: string[];
  /**
  * Select the level of detail for disk metrics. Default: "basic"; must be one of ["basic", "all", "custom", "disabled"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#mode Source#mode}
  */
  readonly mode?: string;
  /**
  * Filesystem mountpoints to include/exclude. Examples: /, /home, !/proc*, !/tmp. Wildcards and ! (not) operators are supported. All mountpoints are included if this list is empty. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#mountpoints Source#mountpoints}
  */
  readonly mountpoints?: string[];
  /**
  * Generate separate metrics for each device. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#per_device Source#per_device}
  */
  readonly perDevice?: boolean | cdktf.IResolvable;
}

export function sourceInputSystemMetricsHostCustomDiskToTerraform(struct?: SourceInputSystemMetricsHostCustomDisk | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    detail: cdktf.booleanToTerraform(struct!.detail),
    devices: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.devices),
    fstypes: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.fstypes),
    mode: cdktf.stringToTerraform(struct!.mode),
    mountpoints: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.mountpoints),
    per_device: cdktf.booleanToTerraform(struct!.perDevice),
  }
}


export function sourceInputSystemMetricsHostCustomDiskToHclTerraform(struct?: SourceInputSystemMetricsHostCustomDisk | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    detail: {
      value: cdktf.booleanToHclTerraform(struct!.detail),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    devices: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.devices),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    fstypes: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.fstypes),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    mountpoints: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.mountpoints),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    per_device: {
      value: cdktf.booleanToHclTerraform(struct!.perDevice),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputSystemMetricsHostCustomDiskOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SourceInputSystemMetricsHostCustomDisk | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._detail !== undefined) {
      hasAnyValues = true;
      internalValueResult.detail = this._detail;
    }
    if (this._devices !== undefined) {
      hasAnyValues = true;
      internalValueResult.devices = this._devices;
    }
    if (this._fstypes !== undefined) {
      hasAnyValues = true;
      internalValueResult.fstypes = this._fstypes;
    }
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._mountpoints !== undefined) {
      hasAnyValues = true;
      internalValueResult.mountpoints = this._mountpoints;
    }
    if (this._perDevice !== undefined) {
      hasAnyValues = true;
      internalValueResult.perDevice = this._perDevice;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputSystemMetricsHostCustomDisk | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._detail = undefined;
      this._devices = undefined;
      this._fstypes = undefined;
      this._mode = undefined;
      this._mountpoints = undefined;
      this._perDevice = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._detail = value.detail;
      this._devices = value.devices;
      this._fstypes = value.fstypes;
      this._mode = value.mode;
      this._mountpoints = value.mountpoints;
      this._perDevice = value.perDevice;
    }
  }

  // detail - computed: true, optional: true, required: false
  private _detail?: boolean | cdktf.IResolvable; 
  public get detail() {
    return this.getBooleanAttribute('detail');
  }
  public set detail(value: boolean | cdktf.IResolvable) {
    this._detail = value;
  }
  public resetDetail() {
    this._detail = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get detailInput() {
    return this._detail;
  }

  // devices - computed: true, optional: true, required: false
  private _devices?: string[]; 
  public get devices() {
    return this.getListAttribute('devices');
  }
  public set devices(value: string[]) {
    this._devices = value;
  }
  public resetDevices() {
    this._devices = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get devicesInput() {
    return this._devices;
  }

  // fstypes - computed: true, optional: true, required: false
  private _fstypes?: string[]; 
  public get fstypes() {
    return this.getListAttribute('fstypes');
  }
  public set fstypes(value: string[]) {
    this._fstypes = value;
  }
  public resetFstypes() {
    this._fstypes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get fstypesInput() {
    return this._fstypes;
  }

  // mode - computed: true, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // mountpoints - computed: true, optional: true, required: false
  private _mountpoints?: string[]; 
  public get mountpoints() {
    return this.getListAttribute('mountpoints');
  }
  public set mountpoints(value: string[]) {
    this._mountpoints = value;
  }
  public resetMountpoints() {
    this._mountpoints = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get mountpointsInput() {
    return this._mountpoints;
  }

  // per_device - computed: true, optional: true, required: false
  private _perDevice?: boolean | cdktf.IResolvable; 
  public get perDevice() {
    return this.getBooleanAttribute('per_device');
  }
  public set perDevice(value: boolean | cdktf.IResolvable) {
    this._perDevice = value;
  }
  public resetPerDevice() {
    this._perDevice = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get perDeviceInput() {
    return this._perDevice;
  }
}
export interface SourceInputSystemMetricsHostCustomMemory {
  /**
  * Generate metrics for all memory states. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#detail Source#detail}
  */
  readonly detail?: boolean | cdktf.IResolvable;
  /**
  * Select the level of detail for memory metrics. Default: "basic"; must be one of ["basic", "all", "custom", "disabled"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#mode Source#mode}
  */
  readonly mode?: string;
}

export function sourceInputSystemMetricsHostCustomMemoryToTerraform(struct?: SourceInputSystemMetricsHostCustomMemory | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    detail: cdktf.booleanToTerraform(struct!.detail),
    mode: cdktf.stringToTerraform(struct!.mode),
  }
}


export function sourceInputSystemMetricsHostCustomMemoryToHclTerraform(struct?: SourceInputSystemMetricsHostCustomMemory | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    detail: {
      value: cdktf.booleanToHclTerraform(struct!.detail),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputSystemMetricsHostCustomMemoryOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SourceInputSystemMetricsHostCustomMemory | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._detail !== undefined) {
      hasAnyValues = true;
      internalValueResult.detail = this._detail;
    }
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputSystemMetricsHostCustomMemory | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._detail = undefined;
      this._mode = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._detail = value.detail;
      this._mode = value.mode;
    }
  }

  // detail - computed: true, optional: true, required: false
  private _detail?: boolean | cdktf.IResolvable; 
  public get detail() {
    return this.getBooleanAttribute('detail');
  }
  public set detail(value: boolean | cdktf.IResolvable) {
    this._detail = value;
  }
  public resetDetail() {
    this._detail = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get detailInput() {
    return this._detail;
  }

  // mode - computed: true, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }
}
export interface SourceInputSystemMetricsHostCustomNetwork {
  /**
  * Generate full network metrics. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#detail Source#detail}
  */
  readonly detail?: boolean | cdktf.IResolvable;
  /**
  * Network interfaces to include/exclude. Examples: eth0, !lo. All interfaces are included if this list is empty. Default: ["!lo","*"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#devices Source#devices}
  */
  readonly devices?: string[];
  /**
  * Select the level of detail for network metrics. Default: "basic"; must be one of ["basic", "all", "custom", "disabled"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#mode Source#mode}
  */
  readonly mode?: string;
  /**
  * Generate separate metrics for each interface. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#per_interface Source#per_interface}
  */
  readonly perInterface?: boolean | cdktf.IResolvable;
}

export function sourceInputSystemMetricsHostCustomNetworkToTerraform(struct?: SourceInputSystemMetricsHostCustomNetwork | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    detail: cdktf.booleanToTerraform(struct!.detail),
    devices: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.devices),
    mode: cdktf.stringToTerraform(struct!.mode),
    per_interface: cdktf.booleanToTerraform(struct!.perInterface),
  }
}


export function sourceInputSystemMetricsHostCustomNetworkToHclTerraform(struct?: SourceInputSystemMetricsHostCustomNetwork | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    detail: {
      value: cdktf.booleanToHclTerraform(struct!.detail),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    devices: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.devices),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    per_interface: {
      value: cdktf.booleanToHclTerraform(struct!.perInterface),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputSystemMetricsHostCustomNetworkOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SourceInputSystemMetricsHostCustomNetwork | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._detail !== undefined) {
      hasAnyValues = true;
      internalValueResult.detail = this._detail;
    }
    if (this._devices !== undefined) {
      hasAnyValues = true;
      internalValueResult.devices = this._devices;
    }
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._perInterface !== undefined) {
      hasAnyValues = true;
      internalValueResult.perInterface = this._perInterface;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputSystemMetricsHostCustomNetwork | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._detail = undefined;
      this._devices = undefined;
      this._mode = undefined;
      this._perInterface = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._detail = value.detail;
      this._devices = value.devices;
      this._mode = value.mode;
      this._perInterface = value.perInterface;
    }
  }

  // detail - computed: true, optional: true, required: false
  private _detail?: boolean | cdktf.IResolvable; 
  public get detail() {
    return this.getBooleanAttribute('detail');
  }
  public set detail(value: boolean | cdktf.IResolvable) {
    this._detail = value;
  }
  public resetDetail() {
    this._detail = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get detailInput() {
    return this._detail;
  }

  // devices - computed: true, optional: true, required: false
  private _devices?: string[]; 
  public get devices() {
    return this.getListAttribute('devices');
  }
  public set devices(value: string[]) {
    this._devices = value;
  }
  public resetDevices() {
    this._devices = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get devicesInput() {
    return this._devices;
  }

  // mode - computed: true, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // per_interface - computed: true, optional: true, required: false
  private _perInterface?: boolean | cdktf.IResolvable; 
  public get perInterface() {
    return this.getBooleanAttribute('per_interface');
  }
  public set perInterface(value: boolean | cdktf.IResolvable) {
    this._perInterface = value;
  }
  public resetPerInterface() {
    this._perInterface = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get perInterfaceInput() {
    return this._perInterface;
  }
}
export interface SourceInputSystemMetricsHostCustomSystem {
  /**
  * Select the level of detail for system metrics. Default: "basic"; must be one of ["basic", "all", "custom", "disabled"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#mode Source#mode}
  */
  readonly mode?: string;
  /**
  * Generate metrics for the numbers of processes in various states. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#processes Source#processes}
  */
  readonly processes?: boolean | cdktf.IResolvable;
}

export function sourceInputSystemMetricsHostCustomSystemToTerraform(struct?: SourceInputSystemMetricsHostCustomSystem | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    mode: cdktf.stringToTerraform(struct!.mode),
    processes: cdktf.booleanToTerraform(struct!.processes),
  }
}


export function sourceInputSystemMetricsHostCustomSystemToHclTerraform(struct?: SourceInputSystemMetricsHostCustomSystem | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    processes: {
      value: cdktf.booleanToHclTerraform(struct!.processes),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputSystemMetricsHostCustomSystemOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SourceInputSystemMetricsHostCustomSystem | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._processes !== undefined) {
      hasAnyValues = true;
      internalValueResult.processes = this._processes;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputSystemMetricsHostCustomSystem | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._mode = undefined;
      this._processes = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._mode = value.mode;
      this._processes = value.processes;
    }
  }

  // mode - computed: true, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // processes - computed: true, optional: true, required: false
  private _processes?: boolean | cdktf.IResolvable; 
  public get processes() {
    return this.getBooleanAttribute('processes');
  }
  public set processes(value: boolean | cdktf.IResolvable) {
    this._processes = value;
  }
  public resetProcesses() {
    this._processes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get processesInput() {
    return this._processes;
  }
}
export interface SourceInputSystemMetricsHostCustom {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#cpu Source#cpu}
  */
  readonly cpu?: SourceInputSystemMetricsHostCustomCpu;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#disk Source#disk}
  */
  readonly disk?: SourceInputSystemMetricsHostCustomDisk;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#memory Source#memory}
  */
  readonly memory?: SourceInputSystemMetricsHostCustomMemory;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#network Source#network}
  */
  readonly network?: SourceInputSystemMetricsHostCustomNetwork;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#system Source#system}
  */
  readonly systemAttribute?: SourceInputSystemMetricsHostCustomSystem;
}

export function sourceInputSystemMetricsHostCustomToTerraform(struct?: SourceInputSystemMetricsHostCustom | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    cpu: sourceInputSystemMetricsHostCustomCpuToTerraform(struct!.cpu),
    disk: sourceInputSystemMetricsHostCustomDiskToTerraform(struct!.disk),
    memory: sourceInputSystemMetricsHostCustomMemoryToTerraform(struct!.memory),
    network: sourceInputSystemMetricsHostCustomNetworkToTerraform(struct!.network),
    system: sourceInputSystemMetricsHostCustomSystemToTerraform(struct!.systemAttribute),
  }
}


export function sourceInputSystemMetricsHostCustomToHclTerraform(struct?: SourceInputSystemMetricsHostCustom | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    cpu: {
      value: sourceInputSystemMetricsHostCustomCpuToHclTerraform(struct!.cpu),
      isBlock: true,
      type: "struct",
      storageClassType: "SourceInputSystemMetricsHostCustomCpu",
    },
    disk: {
      value: sourceInputSystemMetricsHostCustomDiskToHclTerraform(struct!.disk),
      isBlock: true,
      type: "struct",
      storageClassType: "SourceInputSystemMetricsHostCustomDisk",
    },
    memory: {
      value: sourceInputSystemMetricsHostCustomMemoryToHclTerraform(struct!.memory),
      isBlock: true,
      type: "struct",
      storageClassType: "SourceInputSystemMetricsHostCustomMemory",
    },
    network: {
      value: sourceInputSystemMetricsHostCustomNetworkToHclTerraform(struct!.network),
      isBlock: true,
      type: "struct",
      storageClassType: "SourceInputSystemMetricsHostCustomNetwork",
    },
    system: {
      value: sourceInputSystemMetricsHostCustomSystemToHclTerraform(struct!.systemAttribute),
      isBlock: true,
      type: "struct",
      storageClassType: "SourceInputSystemMetricsHostCustomSystem",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputSystemMetricsHostCustomOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SourceInputSystemMetricsHostCustom | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._cpu?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.cpu = this._cpu?.internalValue;
    }
    if (this._disk?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.disk = this._disk?.internalValue;
    }
    if (this._memory?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.memory = this._memory?.internalValue;
    }
    if (this._network?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.network = this._network?.internalValue;
    }
    if (this._system?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.systemAttribute = this._system?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputSystemMetricsHostCustom | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._cpu.internalValue = undefined;
      this._disk.internalValue = undefined;
      this._memory.internalValue = undefined;
      this._network.internalValue = undefined;
      this._system.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._cpu.internalValue = value.cpu;
      this._disk.internalValue = value.disk;
      this._memory.internalValue = value.memory;
      this._network.internalValue = value.network;
      this._system.internalValue = value.systemAttribute;
    }
  }

  // cpu - computed: false, optional: true, required: false
  private _cpu = new SourceInputSystemMetricsHostCustomCpuOutputReference(this, "cpu");
  public get cpu() {
    return this._cpu;
  }
  public putCpu(value: SourceInputSystemMetricsHostCustomCpu) {
    this._cpu.internalValue = value;
  }
  public resetCpu() {
    this._cpu.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cpuInput() {
    return this._cpu.internalValue;
  }

  // disk - computed: false, optional: true, required: false
  private _disk = new SourceInputSystemMetricsHostCustomDiskOutputReference(this, "disk");
  public get disk() {
    return this._disk;
  }
  public putDisk(value: SourceInputSystemMetricsHostCustomDisk) {
    this._disk.internalValue = value;
  }
  public resetDisk() {
    this._disk.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get diskInput() {
    return this._disk.internalValue;
  }

  // memory - computed: false, optional: true, required: false
  private _memory = new SourceInputSystemMetricsHostCustomMemoryOutputReference(this, "memory");
  public get memory() {
    return this._memory;
  }
  public putMemory(value: SourceInputSystemMetricsHostCustomMemory) {
    this._memory.internalValue = value;
  }
  public resetMemory() {
    this._memory.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get memoryInput() {
    return this._memory.internalValue;
  }

  // network - computed: false, optional: true, required: false
  private _network = new SourceInputSystemMetricsHostCustomNetworkOutputReference(this, "network");
  public get network() {
    return this._network;
  }
  public putNetwork(value: SourceInputSystemMetricsHostCustomNetwork) {
    this._network.internalValue = value;
  }
  public resetNetwork() {
    this._network.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get networkInput() {
    return this._network.internalValue;
  }

  // system - computed: false, optional: true, required: false
  private _system = new SourceInputSystemMetricsHostCustomSystemOutputReference(this, "system");
  public get systemAttribute() {
    return this._system;
  }
  public putSystemAttribute(value: SourceInputSystemMetricsHostCustomSystem) {
    this._system.internalValue = value;
  }
  public resetSystemAttribute() {
    this._system.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get systemAttributeInput() {
    return this._system.internalValue;
  }
}
export interface SourceInputSystemMetricsHost {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#custom Source#custom}
  */
  readonly custom?: SourceInputSystemMetricsHostCustom;
  /**
  * Select level of detail for host metrics. Default: "basic"; must be one of ["basic", "all", "custom", "disabled"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#mode Source#mode}
  */
  readonly mode?: string;
}

export function sourceInputSystemMetricsHostToTerraform(struct?: SourceInputSystemMetricsHost | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    custom: sourceInputSystemMetricsHostCustomToTerraform(struct!.custom),
    mode: cdktf.stringToTerraform(struct!.mode),
  }
}


export function sourceInputSystemMetricsHostToHclTerraform(struct?: SourceInputSystemMetricsHost | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    custom: {
      value: sourceInputSystemMetricsHostCustomToHclTerraform(struct!.custom),
      isBlock: true,
      type: "struct",
      storageClassType: "SourceInputSystemMetricsHostCustom",
    },
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputSystemMetricsHostOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SourceInputSystemMetricsHost | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._custom?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.custom = this._custom?.internalValue;
    }
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputSystemMetricsHost | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._custom.internalValue = undefined;
      this._mode = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._custom.internalValue = value.custom;
      this._mode = value.mode;
    }
  }

  // custom - computed: false, optional: true, required: false
  private _custom = new SourceInputSystemMetricsHostCustomOutputReference(this, "custom");
  public get custom() {
    return this._custom;
  }
  public putCustom(value: SourceInputSystemMetricsHostCustom) {
    this._custom.internalValue = value;
  }
  public resetCustom() {
    this._custom.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get customInput() {
    return this._custom.internalValue;
  }

  // mode - computed: true, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }
}
export interface SourceInputSystemMetricsMetadata {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#name Source#name}
  */
  readonly name: string;
  /**
  * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#value Source#value}
  */
  readonly value: string;
}

export function sourceInputSystemMetricsMetadataToTerraform(struct?: SourceInputSystemMetricsMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function sourceInputSystemMetricsMetadataToHclTerraform(struct?: SourceInputSystemMetricsMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputSystemMetricsMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): SourceInputSystemMetricsMetadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputSystemMetricsMetadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class SourceInputSystemMetricsMetadataList extends cdktf.ComplexList {
  public internalValue? : SourceInputSystemMetricsMetadata[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): SourceInputSystemMetricsMetadataOutputReference {
    return new SourceInputSystemMetricsMetadataOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface SourceInputSystemMetricsPersistence {
  /**
  * Default: "gzip"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#compress Source#compress}
  */
  readonly compress?: string;
  /**
  * Path to use to write metrics. Defaults to $CRIBL_HOME/state/system_metrics. Default: "$CRIBL_HOME/state/system_metrics"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#dest_path Source#dest_path}
  */
  readonly destPath?: string;
  /**
  * Spool metrics to disk for Cribl Edge and Search. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#enable Source#enable}
  */
  readonly enable?: boolean | cdktf.IResolvable;
  /**
  * Maximum disk space allowed to be consumed (examples: 420MB, 4GB). When limit is reached, older data will be deleted. Default: "1GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_data_size Source#max_data_size}
  */
  readonly maxDataSize?: string;
  /**
  * Maximum amount of time to retain data (examples: 2h, 4d). When limit is reached, older data will be deleted. Default: "24h"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_data_time Source#max_data_time}
  */
  readonly maxDataTime?: string;
  /**
  * Time span for each file bucket. Default: "10m"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#time_window Source#time_window}
  */
  readonly timeWindow?: string;
}

export function sourceInputSystemMetricsPersistenceToTerraform(struct?: SourceInputSystemMetricsPersistence | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    compress: cdktf.stringToTerraform(struct!.compress),
    dest_path: cdktf.stringToTerraform(struct!.destPath),
    enable: cdktf.booleanToTerraform(struct!.enable),
    max_data_size: cdktf.stringToTerraform(struct!.maxDataSize),
    max_data_time: cdktf.stringToTerraform(struct!.maxDataTime),
    time_window: cdktf.stringToTerraform(struct!.timeWindow),
  }
}


export function sourceInputSystemMetricsPersistenceToHclTerraform(struct?: SourceInputSystemMetricsPersistence | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    compress: {
      value: cdktf.stringToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    dest_path: {
      value: cdktf.stringToHclTerraform(struct!.destPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    enable: {
      value: cdktf.booleanToHclTerraform(struct!.enable),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    max_data_size: {
      value: cdktf.stringToHclTerraform(struct!.maxDataSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_data_time: {
      value: cdktf.stringToHclTerraform(struct!.maxDataTime),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    time_window: {
      value: cdktf.stringToHclTerraform(struct!.timeWindow),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputSystemMetricsPersistenceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SourceInputSystemMetricsPersistence | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._destPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.destPath = this._destPath;
    }
    if (this._enable !== undefined) {
      hasAnyValues = true;
      internalValueResult.enable = this._enable;
    }
    if (this._maxDataSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxDataSize = this._maxDataSize;
    }
    if (this._maxDataTime !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxDataTime = this._maxDataTime;
    }
    if (this._timeWindow !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeWindow = this._timeWindow;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputSystemMetricsPersistence | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._compress = undefined;
      this._destPath = undefined;
      this._enable = undefined;
      this._maxDataSize = undefined;
      this._maxDataTime = undefined;
      this._timeWindow = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._compress = value.compress;
      this._destPath = value.destPath;
      this._enable = value.enable;
      this._maxDataSize = value.maxDataSize;
      this._maxDataTime = value.maxDataTime;
      this._timeWindow = value.timeWindow;
    }
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: string; 
  public get compress() {
    return this.getStringAttribute('compress');
  }
  public set compress(value: string) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // dest_path - computed: true, optional: true, required: false
  private _destPath?: string; 
  public get destPath() {
    return this.getStringAttribute('dest_path');
  }
  public set destPath(value: string) {
    this._destPath = value;
  }
  public resetDestPath() {
    this._destPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get destPathInput() {
    return this._destPath;
  }

  // enable - computed: true, optional: true, required: false
  private _enable?: boolean | cdktf.IResolvable; 
  public get enable() {
    return this.getBooleanAttribute('enable');
  }
  public set enable(value: boolean | cdktf.IResolvable) {
    this._enable = value;
  }
  public resetEnable() {
    this._enable = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableInput() {
    return this._enable;
  }

  // max_data_size - computed: true, optional: true, required: false
  private _maxDataSize?: string; 
  public get maxDataSize() {
    return this.getStringAttribute('max_data_size');
  }
  public set maxDataSize(value: string) {
    this._maxDataSize = value;
  }
  public resetMaxDataSize() {
    this._maxDataSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxDataSizeInput() {
    return this._maxDataSize;
  }

  // max_data_time - computed: true, optional: true, required: false
  private _maxDataTime?: string; 
  public get maxDataTime() {
    return this.getStringAttribute('max_data_time');
  }
  public set maxDataTime(value: string) {
    this._maxDataTime = value;
  }
  public resetMaxDataTime() {
    this._maxDataTime = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxDataTimeInput() {
    return this._maxDataTime;
  }

  // time_window - computed: true, optional: true, required: false
  private _timeWindow?: string; 
  public get timeWindow() {
    return this.getStringAttribute('time_window');
  }
  public set timeWindow(value: string) {
    this._timeWindow = value;
  }
  public resetTimeWindow() {
    this._timeWindow = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeWindowInput() {
    return this._timeWindow;
  }
}
export interface SourceInputSystemMetricsPq {
  /**
  * The number of events to send downstream before committing that Stream has read them. Default: 42
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#commit_frequency Source#commit_frequency}
  */
  readonly commitFrequency?: number;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#compress Source#compress}
  */
  readonly compress?: string;
  /**
  * The maximum number of events to hold in memory before writing the events to disk. Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_buffer_size Source#max_buffer_size}
  */
  readonly maxBufferSize?: number;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc. Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_file_size Source#max_file_size}
  */
  readonly maxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_size Source#max_size}
  */
  readonly maxSize?: string;
  /**
  * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine. Default: "always"; must be one of ["smart", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#mode Source#mode}
  */
  readonly mode?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#path Source#path}
  */
  readonly path?: string;
}

export function sourceInputSystemMetricsPqToTerraform(struct?: SourceInputSystemMetricsPq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    commit_frequency: cdktf.numberToTerraform(struct!.commitFrequency),
    compress: cdktf.stringToTerraform(struct!.compress),
    max_buffer_size: cdktf.numberToTerraform(struct!.maxBufferSize),
    max_file_size: cdktf.stringToTerraform(struct!.maxFileSize),
    max_size: cdktf.stringToTerraform(struct!.maxSize),
    mode: cdktf.stringToTerraform(struct!.mode),
    path: cdktf.stringToTerraform(struct!.path),
  }
}


export function sourceInputSystemMetricsPqToHclTerraform(struct?: SourceInputSystemMetricsPq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    commit_frequency: {
      value: cdktf.numberToHclTerraform(struct!.commitFrequency),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    compress: {
      value: cdktf.stringToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_buffer_size: {
      value: cdktf.numberToHclTerraform(struct!.maxBufferSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.maxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_size: {
      value: cdktf.stringToHclTerraform(struct!.maxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputSystemMetricsPqOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SourceInputSystemMetricsPq | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._commitFrequency !== undefined) {
      hasAnyValues = true;
      internalValueResult.commitFrequency = this._commitFrequency;
    }
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._maxBufferSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBufferSize = this._maxBufferSize;
    }
    if (this._maxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxFileSize = this._maxFileSize;
    }
    if (this._maxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxSize = this._maxSize;
    }
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputSystemMetricsPq | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._commitFrequency = undefined;
      this._compress = undefined;
      this._maxBufferSize = undefined;
      this._maxFileSize = undefined;
      this._maxSize = undefined;
      this._mode = undefined;
      this._path = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._commitFrequency = value.commitFrequency;
      this._compress = value.compress;
      this._maxBufferSize = value.maxBufferSize;
      this._maxFileSize = value.maxFileSize;
      this._maxSize = value.maxSize;
      this._mode = value.mode;
      this._path = value.path;
    }
  }

  // commit_frequency - computed: true, optional: true, required: false
  private _commitFrequency?: number; 
  public get commitFrequency() {
    return this.getNumberAttribute('commit_frequency');
  }
  public set commitFrequency(value: number) {
    this._commitFrequency = value;
  }
  public resetCommitFrequency() {
    this._commitFrequency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commitFrequencyInput() {
    return this._commitFrequency;
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: string; 
  public get compress() {
    return this.getStringAttribute('compress');
  }
  public set compress(value: string) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // max_buffer_size - computed: true, optional: true, required: false
  private _maxBufferSize?: number; 
  public get maxBufferSize() {
    return this.getNumberAttribute('max_buffer_size');
  }
  public set maxBufferSize(value: number) {
    this._maxBufferSize = value;
  }
  public resetMaxBufferSize() {
    this._maxBufferSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBufferSizeInput() {
    return this._maxBufferSize;
  }

  // max_file_size - computed: true, optional: true, required: false
  private _maxFileSize?: string; 
  public get maxFileSize() {
    return this.getStringAttribute('max_file_size');
  }
  public set maxFileSize(value: string) {
    this._maxFileSize = value;
  }
  public resetMaxFileSize() {
    this._maxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxFileSizeInput() {
    return this._maxFileSize;
  }

  // max_size - computed: true, optional: true, required: false
  private _maxSize?: string; 
  public get maxSize() {
    return this.getStringAttribute('max_size');
  }
  public set maxSize(value: string) {
    this._maxSize = value;
  }
  public resetMaxSize() {
    this._maxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxSizeInput() {
    return this._maxSize;
  }

  // mode - computed: true, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // path - computed: true, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }
}
export interface SourceInputSystemMetricsProcessSets {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#filter Source#filter}
  */
  readonly filter: string;
  /**
  * Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#include_children Source#include_children}
  */
  readonly includeChildren?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#name Source#name}
  */
  readonly name: string;
}

export function sourceInputSystemMetricsProcessSetsToTerraform(struct?: SourceInputSystemMetricsProcessSets | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    filter: cdktf.stringToTerraform(struct!.filter),
    include_children: cdktf.booleanToTerraform(struct!.includeChildren),
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function sourceInputSystemMetricsProcessSetsToHclTerraform(struct?: SourceInputSystemMetricsProcessSets | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    filter: {
      value: cdktf.stringToHclTerraform(struct!.filter),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    include_children: {
      value: cdktf.booleanToHclTerraform(struct!.includeChildren),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputSystemMetricsProcessSetsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): SourceInputSystemMetricsProcessSets | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._filter !== undefined) {
      hasAnyValues = true;
      internalValueResult.filter = this._filter;
    }
    if (this._includeChildren !== undefined) {
      hasAnyValues = true;
      internalValueResult.includeChildren = this._includeChildren;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputSystemMetricsProcessSets | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._filter = undefined;
      this._includeChildren = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._filter = value.filter;
      this._includeChildren = value.includeChildren;
      this._name = value.name;
    }
  }

  // filter - computed: false, optional: false, required: true
  private _filter?: string; 
  public get filter() {
    return this.getStringAttribute('filter');
  }
  public set filter(value: string) {
    this._filter = value;
  }
  // Temporarily expose input value. Use with caution.
  public get filterInput() {
    return this._filter;
  }

  // include_children - computed: true, optional: true, required: false
  private _includeChildren?: boolean | cdktf.IResolvable; 
  public get includeChildren() {
    return this.getBooleanAttribute('include_children');
  }
  public set includeChildren(value: boolean | cdktf.IResolvable) {
    this._includeChildren = value;
  }
  public resetIncludeChildren() {
    this._includeChildren = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get includeChildrenInput() {
    return this._includeChildren;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}

export class SourceInputSystemMetricsProcessSetsList extends cdktf.ComplexList {
  public internalValue? : SourceInputSystemMetricsProcessSets[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): SourceInputSystemMetricsProcessSetsOutputReference {
    return new SourceInputSystemMetricsProcessSetsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface SourceInputSystemMetricsProcess {
  /**
  * Configure sets to collect process metrics
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#sets Source#sets}
  */
  readonly sets?: SourceInputSystemMetricsProcessSets[] | cdktf.IResolvable;
}

export function sourceInputSystemMetricsProcessToTerraform(struct?: SourceInputSystemMetricsProcess | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    sets: cdktf.listMapper(sourceInputSystemMetricsProcessSetsToTerraform, false)(struct!.sets),
  }
}


export function sourceInputSystemMetricsProcessToHclTerraform(struct?: SourceInputSystemMetricsProcess | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    sets: {
      value: cdktf.listMapperHcl(sourceInputSystemMetricsProcessSetsToHclTerraform, false)(struct!.sets),
      isBlock: true,
      type: "list",
      storageClassType: "SourceInputSystemMetricsProcessSetsList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputSystemMetricsProcessOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SourceInputSystemMetricsProcess | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._sets?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.sets = this._sets?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputSystemMetricsProcess | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._sets.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._sets.internalValue = value.sets;
    }
  }

  // sets - computed: false, optional: true, required: false
  private _sets = new SourceInputSystemMetricsProcessSetsList(this, "sets", false);
  public get sets() {
    return this._sets;
  }
  public putSets(value: SourceInputSystemMetricsProcessSets[] | cdktf.IResolvable) {
    this._sets.internalValue = value;
  }
  public resetSets() {
    this._sets.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get setsInput() {
    return this._sets.internalValue;
  }
}
export interface SourceInputSystemMetrics {
  /**
  * Direct connections to Destinations, and optionally via a Pipeline or a Pack
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#connections Source#connections}
  */
  readonly connections?: SourceInputSystemMetricsConnections[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#container Source#container}
  */
  readonly container?: SourceInputSystemMetricsContainer;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#description Source#description}
  */
  readonly description?: string;
  /**
  * Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#disabled Source#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#environment Source#environment}
  */
  readonly environment?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#host Source#host}
  */
  readonly host?: SourceInputSystemMetricsHost;
  /**
  * Unique ID for this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#id Source#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id: string;
  /**
  * Time, in seconds, between consecutive metric collections. Default is 10 seconds. Default: 10
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#interval Source#interval}
  */
  readonly interval?: number;
  /**
  * Fields to add to events from this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#metadata Source#metadata}
  */
  readonly metadata?: SourceInputSystemMetricsMetadata[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#persistence Source#persistence}
  */
  readonly persistence?: SourceInputSystemMetricsPersistence;
  /**
  * Pipeline to process data from this Source before sending it through the Routes
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#pipeline Source#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#pq Source#pq}
  */
  readonly pq?: SourceInputSystemMetricsPq;
  /**
  * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers). Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#pq_enabled Source#pq_enabled}
  */
  readonly pqEnabled?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#process Source#process}
  */
  readonly process?: SourceInputSystemMetricsProcess;
  /**
  * Select whether to send data to Routes, or directly to Destinations. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#send_to_routes Source#send_to_routes}
  */
  readonly sendToRoutes?: boolean | cdktf.IResolvable;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#streamtags Source#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * must be "system_metrics"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#type Source#type}
  */
  readonly type: string;
}

export function sourceInputSystemMetricsToTerraform(struct?: SourceInputSystemMetrics | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    connections: cdktf.listMapper(sourceInputSystemMetricsConnectionsToTerraform, false)(struct!.connections),
    container: sourceInputSystemMetricsContainerToTerraform(struct!.container),
    description: cdktf.stringToTerraform(struct!.description),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    environment: cdktf.stringToTerraform(struct!.environment),
    host: sourceInputSystemMetricsHostToTerraform(struct!.host),
    id: cdktf.stringToTerraform(struct!.id),
    interval: cdktf.numberToTerraform(struct!.interval),
    metadata: cdktf.listMapper(sourceInputSystemMetricsMetadataToTerraform, false)(struct!.metadata),
    persistence: sourceInputSystemMetricsPersistenceToTerraform(struct!.persistence),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    pq: sourceInputSystemMetricsPqToTerraform(struct!.pq),
    pq_enabled: cdktf.booleanToTerraform(struct!.pqEnabled),
    process: sourceInputSystemMetricsProcessToTerraform(struct!.process),
    send_to_routes: cdktf.booleanToTerraform(struct!.sendToRoutes),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function sourceInputSystemMetricsToHclTerraform(struct?: SourceInputSystemMetrics | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    connections: {
      value: cdktf.listMapperHcl(sourceInputSystemMetricsConnectionsToHclTerraform, false)(struct!.connections),
      isBlock: true,
      type: "list",
      storageClassType: "SourceInputSystemMetricsConnectionsList",
    },
    container: {
      value: sourceInputSystemMetricsContainerToHclTerraform(struct!.container),
      isBlock: true,
      type: "struct",
      storageClassType: "SourceInputSystemMetricsContainer",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    host: {
      value: sourceInputSystemMetricsHostToHclTerraform(struct!.host),
      isBlock: true,
      type: "struct",
      storageClassType: "SourceInputSystemMetricsHost",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    interval: {
      value: cdktf.numberToHclTerraform(struct!.interval),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    metadata: {
      value: cdktf.listMapperHcl(sourceInputSystemMetricsMetadataToHclTerraform, false)(struct!.metadata),
      isBlock: true,
      type: "list",
      storageClassType: "SourceInputSystemMetricsMetadataList",
    },
    persistence: {
      value: sourceInputSystemMetricsPersistenceToHclTerraform(struct!.persistence),
      isBlock: true,
      type: "struct",
      storageClassType: "SourceInputSystemMetricsPersistence",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq: {
      value: sourceInputSystemMetricsPqToHclTerraform(struct!.pq),
      isBlock: true,
      type: "struct",
      storageClassType: "SourceInputSystemMetricsPq",
    },
    pq_enabled: {
      value: cdktf.booleanToHclTerraform(struct!.pqEnabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    process: {
      value: sourceInputSystemMetricsProcessToHclTerraform(struct!.process),
      isBlock: true,
      type: "struct",
      storageClassType: "SourceInputSystemMetricsProcess",
    },
    send_to_routes: {
      value: cdktf.booleanToHclTerraform(struct!.sendToRoutes),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputSystemMetricsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SourceInputSystemMetrics | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._connections?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.connections = this._connections?.internalValue;
    }
    if (this._container?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.container = this._container?.internalValue;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._host?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.host = this._host?.internalValue;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._interval !== undefined) {
      hasAnyValues = true;
      internalValueResult.interval = this._interval;
    }
    if (this._metadata?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadata = this._metadata?.internalValue;
    }
    if (this._persistence?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.persistence = this._persistence?.internalValue;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._pq?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pq = this._pq?.internalValue;
    }
    if (this._pqEnabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqEnabled = this._pqEnabled;
    }
    if (this._process?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.process = this._process?.internalValue;
    }
    if (this._sendToRoutes !== undefined) {
      hasAnyValues = true;
      internalValueResult.sendToRoutes = this._sendToRoutes;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputSystemMetrics | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._connections.internalValue = undefined;
      this._container.internalValue = undefined;
      this._description = undefined;
      this._disabled = undefined;
      this._environment = undefined;
      this._host.internalValue = undefined;
      this._id = undefined;
      this._interval = undefined;
      this._metadata.internalValue = undefined;
      this._persistence.internalValue = undefined;
      this._pipeline = undefined;
      this._pq.internalValue = undefined;
      this._pqEnabled = undefined;
      this._process.internalValue = undefined;
      this._sendToRoutes = undefined;
      this._streamtags = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._connections.internalValue = value.connections;
      this._container.internalValue = value.container;
      this._description = value.description;
      this._disabled = value.disabled;
      this._environment = value.environment;
      this._host.internalValue = value.host;
      this._id = value.id;
      this._interval = value.interval;
      this._metadata.internalValue = value.metadata;
      this._persistence.internalValue = value.persistence;
      this._pipeline = value.pipeline;
      this._pq.internalValue = value.pq;
      this._pqEnabled = value.pqEnabled;
      this._process.internalValue = value.process;
      this._sendToRoutes = value.sendToRoutes;
      this._streamtags = value.streamtags;
      this._type = value.type;
    }
  }

  // connections - computed: false, optional: true, required: false
  private _connections = new SourceInputSystemMetricsConnectionsList(this, "connections", false);
  public get connections() {
    return this._connections;
  }
  public putConnections(value: SourceInputSystemMetricsConnections[] | cdktf.IResolvable) {
    this._connections.internalValue = value;
  }
  public resetConnections() {
    this._connections.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectionsInput() {
    return this._connections.internalValue;
  }

  // container - computed: false, optional: true, required: false
  private _container = new SourceInputSystemMetricsContainerOutputReference(this, "container");
  public get container() {
    return this._container;
  }
  public putContainer(value: SourceInputSystemMetricsContainer) {
    this._container.internalValue = value;
  }
  public resetContainer() {
    this._container.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get containerInput() {
    return this._container.internalValue;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // host - computed: false, optional: true, required: false
  private _host = new SourceInputSystemMetricsHostOutputReference(this, "host");
  public get host() {
    return this._host;
  }
  public putHost(value: SourceInputSystemMetricsHost) {
    this._host.internalValue = value;
  }
  public resetHost() {
    this._host.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostInput() {
    return this._host.internalValue;
  }

  // id - computed: false, optional: false, required: true
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // interval - computed: true, optional: true, required: false
  private _interval?: number; 
  public get interval() {
    return this.getNumberAttribute('interval');
  }
  public set interval(value: number) {
    this._interval = value;
  }
  public resetInterval() {
    this._interval = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get intervalInput() {
    return this._interval;
  }

  // metadata - computed: false, optional: true, required: false
  private _metadata = new SourceInputSystemMetricsMetadataList(this, "metadata", false);
  public get metadata() {
    return this._metadata;
  }
  public putMetadata(value: SourceInputSystemMetricsMetadata[] | cdktf.IResolvable) {
    this._metadata.internalValue = value;
  }
  public resetMetadata() {
    this._metadata.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataInput() {
    return this._metadata.internalValue;
  }

  // persistence - computed: false, optional: true, required: false
  private _persistence = new SourceInputSystemMetricsPersistenceOutputReference(this, "persistence");
  public get persistence() {
    return this._persistence;
  }
  public putPersistence(value: SourceInputSystemMetricsPersistence) {
    this._persistence.internalValue = value;
  }
  public resetPersistence() {
    this._persistence.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get persistenceInput() {
    return this._persistence.internalValue;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // pq - computed: false, optional: true, required: false
  private _pq = new SourceInputSystemMetricsPqOutputReference(this, "pq");
  public get pq() {
    return this._pq;
  }
  public putPq(value: SourceInputSystemMetricsPq) {
    this._pq.internalValue = value;
  }
  public resetPq() {
    this._pq.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqInput() {
    return this._pq.internalValue;
  }

  // pq_enabled - computed: true, optional: true, required: false
  private _pqEnabled?: boolean | cdktf.IResolvable; 
  public get pqEnabled() {
    return this.getBooleanAttribute('pq_enabled');
  }
  public set pqEnabled(value: boolean | cdktf.IResolvable) {
    this._pqEnabled = value;
  }
  public resetPqEnabled() {
    this._pqEnabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqEnabledInput() {
    return this._pqEnabled;
  }

  // process - computed: false, optional: true, required: false
  private _process = new SourceInputSystemMetricsProcessOutputReference(this, "process");
  public get process() {
    return this._process;
  }
  public putProcess(value: SourceInputSystemMetricsProcess) {
    this._process.internalValue = value;
  }
  public resetProcess() {
    this._process.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get processInput() {
    return this._process.internalValue;
  }

  // send_to_routes - computed: true, optional: true, required: false
  private _sendToRoutes?: boolean | cdktf.IResolvable; 
  public get sendToRoutes() {
    return this.getBooleanAttribute('send_to_routes');
  }
  public set sendToRoutes(value: boolean | cdktf.IResolvable) {
    this._sendToRoutes = value;
  }
  public resetSendToRoutes() {
    this._sendToRoutes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sendToRoutesInput() {
    return this._sendToRoutes;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface SourceInputSystemStateCollectorsDisk {
  /**
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#enable Source#enable}
  */
  readonly enable?: boolean | cdktf.IResolvable;
}

export function sourceInputSystemStateCollectorsDiskToTerraform(struct?: SourceInputSystemStateCollectorsDisk | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    enable: cdktf.booleanToTerraform(struct!.enable),
  }
}


export function sourceInputSystemStateCollectorsDiskToHclTerraform(struct?: SourceInputSystemStateCollectorsDisk | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    enable: {
      value: cdktf.booleanToHclTerraform(struct!.enable),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputSystemStateCollectorsDiskOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SourceInputSystemStateCollectorsDisk | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._enable !== undefined) {
      hasAnyValues = true;
      internalValueResult.enable = this._enable;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputSystemStateCollectorsDisk | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._enable = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._enable = value.enable;
    }
  }

  // enable - computed: true, optional: true, required: false
  private _enable?: boolean | cdktf.IResolvable; 
  public get enable() {
    return this.getBooleanAttribute('enable');
  }
  public set enable(value: boolean | cdktf.IResolvable) {
    this._enable = value;
  }
  public resetEnable() {
    this._enable = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableInput() {
    return this._enable;
  }
}
export interface SourceInputSystemStateCollectorsDns {
  /**
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#enable Source#enable}
  */
  readonly enable?: boolean | cdktf.IResolvable;
}

export function sourceInputSystemStateCollectorsDnsToTerraform(struct?: SourceInputSystemStateCollectorsDns | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    enable: cdktf.booleanToTerraform(struct!.enable),
  }
}


export function sourceInputSystemStateCollectorsDnsToHclTerraform(struct?: SourceInputSystemStateCollectorsDns | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    enable: {
      value: cdktf.booleanToHclTerraform(struct!.enable),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputSystemStateCollectorsDnsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SourceInputSystemStateCollectorsDns | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._enable !== undefined) {
      hasAnyValues = true;
      internalValueResult.enable = this._enable;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputSystemStateCollectorsDns | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._enable = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._enable = value.enable;
    }
  }

  // enable - computed: true, optional: true, required: false
  private _enable?: boolean | cdktf.IResolvable; 
  public get enable() {
    return this.getBooleanAttribute('enable');
  }
  public set enable(value: boolean | cdktf.IResolvable) {
    this._enable = value;
  }
  public resetEnable() {
    this._enable = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableInput() {
    return this._enable;
  }
}
export interface SourceInputSystemStateCollectorsFirewall {
  /**
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#enable Source#enable}
  */
  readonly enable?: boolean | cdktf.IResolvable;
}

export function sourceInputSystemStateCollectorsFirewallToTerraform(struct?: SourceInputSystemStateCollectorsFirewall | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    enable: cdktf.booleanToTerraform(struct!.enable),
  }
}


export function sourceInputSystemStateCollectorsFirewallToHclTerraform(struct?: SourceInputSystemStateCollectorsFirewall | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    enable: {
      value: cdktf.booleanToHclTerraform(struct!.enable),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputSystemStateCollectorsFirewallOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SourceInputSystemStateCollectorsFirewall | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._enable !== undefined) {
      hasAnyValues = true;
      internalValueResult.enable = this._enable;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputSystemStateCollectorsFirewall | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._enable = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._enable = value.enable;
    }
  }

  // enable - computed: true, optional: true, required: false
  private _enable?: boolean | cdktf.IResolvable; 
  public get enable() {
    return this.getBooleanAttribute('enable');
  }
  public set enable(value: boolean | cdktf.IResolvable) {
    this._enable = value;
  }
  public resetEnable() {
    this._enable = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableInput() {
    return this._enable;
  }
}
export interface SourceInputSystemStateCollectorsHostsfile {
  /**
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#enable Source#enable}
  */
  readonly enable?: boolean | cdktf.IResolvable;
}

export function sourceInputSystemStateCollectorsHostsfileToTerraform(struct?: SourceInputSystemStateCollectorsHostsfile | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    enable: cdktf.booleanToTerraform(struct!.enable),
  }
}


export function sourceInputSystemStateCollectorsHostsfileToHclTerraform(struct?: SourceInputSystemStateCollectorsHostsfile | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    enable: {
      value: cdktf.booleanToHclTerraform(struct!.enable),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputSystemStateCollectorsHostsfileOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SourceInputSystemStateCollectorsHostsfile | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._enable !== undefined) {
      hasAnyValues = true;
      internalValueResult.enable = this._enable;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputSystemStateCollectorsHostsfile | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._enable = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._enable = value.enable;
    }
  }

  // enable - computed: true, optional: true, required: false
  private _enable?: boolean | cdktf.IResolvable; 
  public get enable() {
    return this.getBooleanAttribute('enable');
  }
  public set enable(value: boolean | cdktf.IResolvable) {
    this._enable = value;
  }
  public resetEnable() {
    this._enable = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableInput() {
    return this._enable;
  }
}
export interface SourceInputSystemStateCollectorsInterfaces {
  /**
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#enable Source#enable}
  */
  readonly enable?: boolean | cdktf.IResolvable;
}

export function sourceInputSystemStateCollectorsInterfacesToTerraform(struct?: SourceInputSystemStateCollectorsInterfaces | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    enable: cdktf.booleanToTerraform(struct!.enable),
  }
}


export function sourceInputSystemStateCollectorsInterfacesToHclTerraform(struct?: SourceInputSystemStateCollectorsInterfaces | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    enable: {
      value: cdktf.booleanToHclTerraform(struct!.enable),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputSystemStateCollectorsInterfacesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SourceInputSystemStateCollectorsInterfaces | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._enable !== undefined) {
      hasAnyValues = true;
      internalValueResult.enable = this._enable;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputSystemStateCollectorsInterfaces | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._enable = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._enable = value.enable;
    }
  }

  // enable - computed: true, optional: true, required: false
  private _enable?: boolean | cdktf.IResolvable; 
  public get enable() {
    return this.getBooleanAttribute('enable');
  }
  public set enable(value: boolean | cdktf.IResolvable) {
    this._enable = value;
  }
  public resetEnable() {
    this._enable = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableInput() {
    return this._enable;
  }
}
export interface SourceInputSystemStateCollectorsLoginUsers {
  /**
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#enable Source#enable}
  */
  readonly enable?: boolean | cdktf.IResolvable;
}

export function sourceInputSystemStateCollectorsLoginUsersToTerraform(struct?: SourceInputSystemStateCollectorsLoginUsers | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    enable: cdktf.booleanToTerraform(struct!.enable),
  }
}


export function sourceInputSystemStateCollectorsLoginUsersToHclTerraform(struct?: SourceInputSystemStateCollectorsLoginUsers | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    enable: {
      value: cdktf.booleanToHclTerraform(struct!.enable),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputSystemStateCollectorsLoginUsersOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SourceInputSystemStateCollectorsLoginUsers | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._enable !== undefined) {
      hasAnyValues = true;
      internalValueResult.enable = this._enable;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputSystemStateCollectorsLoginUsers | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._enable = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._enable = value.enable;
    }
  }

  // enable - computed: true, optional: true, required: false
  private _enable?: boolean | cdktf.IResolvable; 
  public get enable() {
    return this.getBooleanAttribute('enable');
  }
  public set enable(value: boolean | cdktf.IResolvable) {
    this._enable = value;
  }
  public resetEnable() {
    this._enable = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableInput() {
    return this._enable;
  }
}
export interface SourceInputSystemStateCollectorsMetadata {
  /**
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#enable Source#enable}
  */
  readonly enable?: boolean | cdktf.IResolvable;
}

export function sourceInputSystemStateCollectorsMetadataToTerraform(struct?: SourceInputSystemStateCollectorsMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    enable: cdktf.booleanToTerraform(struct!.enable),
  }
}


export function sourceInputSystemStateCollectorsMetadataToHclTerraform(struct?: SourceInputSystemStateCollectorsMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    enable: {
      value: cdktf.booleanToHclTerraform(struct!.enable),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputSystemStateCollectorsMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SourceInputSystemStateCollectorsMetadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._enable !== undefined) {
      hasAnyValues = true;
      internalValueResult.enable = this._enable;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputSystemStateCollectorsMetadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._enable = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._enable = value.enable;
    }
  }

  // enable - computed: true, optional: true, required: false
  private _enable?: boolean | cdktf.IResolvable; 
  public get enable() {
    return this.getBooleanAttribute('enable');
  }
  public set enable(value: boolean | cdktf.IResolvable) {
    this._enable = value;
  }
  public resetEnable() {
    this._enable = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableInput() {
    return this._enable;
  }
}
export interface SourceInputSystemStateCollectorsPorts {
  /**
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#enable Source#enable}
  */
  readonly enable?: boolean | cdktf.IResolvable;
}

export function sourceInputSystemStateCollectorsPortsToTerraform(struct?: SourceInputSystemStateCollectorsPorts | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    enable: cdktf.booleanToTerraform(struct!.enable),
  }
}


export function sourceInputSystemStateCollectorsPortsToHclTerraform(struct?: SourceInputSystemStateCollectorsPorts | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    enable: {
      value: cdktf.booleanToHclTerraform(struct!.enable),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputSystemStateCollectorsPortsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SourceInputSystemStateCollectorsPorts | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._enable !== undefined) {
      hasAnyValues = true;
      internalValueResult.enable = this._enable;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputSystemStateCollectorsPorts | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._enable = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._enable = value.enable;
    }
  }

  // enable - computed: true, optional: true, required: false
  private _enable?: boolean | cdktf.IResolvable; 
  public get enable() {
    return this.getBooleanAttribute('enable');
  }
  public set enable(value: boolean | cdktf.IResolvable) {
    this._enable = value;
  }
  public resetEnable() {
    this._enable = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableInput() {
    return this._enable;
  }
}
export interface SourceInputSystemStateCollectorsRoutes {
  /**
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#enable Source#enable}
  */
  readonly enable?: boolean | cdktf.IResolvable;
}

export function sourceInputSystemStateCollectorsRoutesToTerraform(struct?: SourceInputSystemStateCollectorsRoutes | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    enable: cdktf.booleanToTerraform(struct!.enable),
  }
}


export function sourceInputSystemStateCollectorsRoutesToHclTerraform(struct?: SourceInputSystemStateCollectorsRoutes | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    enable: {
      value: cdktf.booleanToHclTerraform(struct!.enable),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputSystemStateCollectorsRoutesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SourceInputSystemStateCollectorsRoutes | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._enable !== undefined) {
      hasAnyValues = true;
      internalValueResult.enable = this._enable;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputSystemStateCollectorsRoutes | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._enable = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._enable = value.enable;
    }
  }

  // enable - computed: true, optional: true, required: false
  private _enable?: boolean | cdktf.IResolvable; 
  public get enable() {
    return this.getBooleanAttribute('enable');
  }
  public set enable(value: boolean | cdktf.IResolvable) {
    this._enable = value;
  }
  public resetEnable() {
    this._enable = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableInput() {
    return this._enable;
  }
}
export interface SourceInputSystemStateCollectorsServices {
  /**
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#enable Source#enable}
  */
  readonly enable?: boolean | cdktf.IResolvable;
}

export function sourceInputSystemStateCollectorsServicesToTerraform(struct?: SourceInputSystemStateCollectorsServices | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    enable: cdktf.booleanToTerraform(struct!.enable),
  }
}


export function sourceInputSystemStateCollectorsServicesToHclTerraform(struct?: SourceInputSystemStateCollectorsServices | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    enable: {
      value: cdktf.booleanToHclTerraform(struct!.enable),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputSystemStateCollectorsServicesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SourceInputSystemStateCollectorsServices | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._enable !== undefined) {
      hasAnyValues = true;
      internalValueResult.enable = this._enable;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputSystemStateCollectorsServices | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._enable = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._enable = value.enable;
    }
  }

  // enable - computed: true, optional: true, required: false
  private _enable?: boolean | cdktf.IResolvable; 
  public get enable() {
    return this.getBooleanAttribute('enable');
  }
  public set enable(value: boolean | cdktf.IResolvable) {
    this._enable = value;
  }
  public resetEnable() {
    this._enable = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableInput() {
    return this._enable;
  }
}
export interface SourceInputSystemStateCollectorsUser {
  /**
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#enable Source#enable}
  */
  readonly enable?: boolean | cdktf.IResolvable;
}

export function sourceInputSystemStateCollectorsUserToTerraform(struct?: SourceInputSystemStateCollectorsUser | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    enable: cdktf.booleanToTerraform(struct!.enable),
  }
}


export function sourceInputSystemStateCollectorsUserToHclTerraform(struct?: SourceInputSystemStateCollectorsUser | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    enable: {
      value: cdktf.booleanToHclTerraform(struct!.enable),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputSystemStateCollectorsUserOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SourceInputSystemStateCollectorsUser | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._enable !== undefined) {
      hasAnyValues = true;
      internalValueResult.enable = this._enable;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputSystemStateCollectorsUser | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._enable = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._enable = value.enable;
    }
  }

  // enable - computed: true, optional: true, required: false
  private _enable?: boolean | cdktf.IResolvable; 
  public get enable() {
    return this.getBooleanAttribute('enable');
  }
  public set enable(value: boolean | cdktf.IResolvable) {
    this._enable = value;
  }
  public resetEnable() {
    this._enable = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableInput() {
    return this._enable;
  }
}
export interface SourceInputSystemStateCollectors {
  /**
  * Creates events for physical disks, partitions, and file systems
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#disk Source#disk}
  */
  readonly disk?: SourceInputSystemStateCollectorsDisk;
  /**
  * Creates events for DNS resolvers and search entries
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#dns Source#dns}
  */
  readonly dns?: SourceInputSystemStateCollectorsDns;
  /**
  * Creates events for Firewall rules entries
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#firewall Source#firewall}
  */
  readonly firewall?: SourceInputSystemStateCollectorsFirewall;
  /**
  * Creates events based on entries collected from the hosts file
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#hostsfile Source#hostsfile}
  */
  readonly hostsfile?: SourceInputSystemStateCollectorsHostsfile;
  /**
  * Creates events for each of the host’s network interfaces
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#interfaces Source#interfaces}
  */
  readonly interfaces?: SourceInputSystemStateCollectorsInterfaces;
  /**
  * Creates events for logged-in users
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#login_users Source#login_users}
  */
  readonly loginUsers?: SourceInputSystemStateCollectorsLoginUsers;
  /**
  * Creates events based on the host system’s current state
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#metadata Source#metadata}
  */
  readonly metadata?: SourceInputSystemStateCollectorsMetadata;
  /**
  * Creates events from list of listening ports
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#ports Source#ports}
  */
  readonly ports?: SourceInputSystemStateCollectorsPorts;
  /**
  * Creates events based on entries collected from the host’s network routes
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#routes Source#routes}
  */
  readonly routes?: SourceInputSystemStateCollectorsRoutes;
  /**
  * Creates events from the list of services
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#services Source#services}
  */
  readonly services?: SourceInputSystemStateCollectorsServices;
  /**
  * Creates events for local users and groups
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#user Source#user}
  */
  readonly user?: SourceInputSystemStateCollectorsUser;
}

export function sourceInputSystemStateCollectorsToTerraform(struct?: SourceInputSystemStateCollectors | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    disk: sourceInputSystemStateCollectorsDiskToTerraform(struct!.disk),
    dns: sourceInputSystemStateCollectorsDnsToTerraform(struct!.dns),
    firewall: sourceInputSystemStateCollectorsFirewallToTerraform(struct!.firewall),
    hostsfile: sourceInputSystemStateCollectorsHostsfileToTerraform(struct!.hostsfile),
    interfaces: sourceInputSystemStateCollectorsInterfacesToTerraform(struct!.interfaces),
    login_users: sourceInputSystemStateCollectorsLoginUsersToTerraform(struct!.loginUsers),
    metadata: sourceInputSystemStateCollectorsMetadataToTerraform(struct!.metadata),
    ports: sourceInputSystemStateCollectorsPortsToTerraform(struct!.ports),
    routes: sourceInputSystemStateCollectorsRoutesToTerraform(struct!.routes),
    services: sourceInputSystemStateCollectorsServicesToTerraform(struct!.services),
    user: sourceInputSystemStateCollectorsUserToTerraform(struct!.user),
  }
}


export function sourceInputSystemStateCollectorsToHclTerraform(struct?: SourceInputSystemStateCollectors | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    disk: {
      value: sourceInputSystemStateCollectorsDiskToHclTerraform(struct!.disk),
      isBlock: true,
      type: "struct",
      storageClassType: "SourceInputSystemStateCollectorsDisk",
    },
    dns: {
      value: sourceInputSystemStateCollectorsDnsToHclTerraform(struct!.dns),
      isBlock: true,
      type: "struct",
      storageClassType: "SourceInputSystemStateCollectorsDns",
    },
    firewall: {
      value: sourceInputSystemStateCollectorsFirewallToHclTerraform(struct!.firewall),
      isBlock: true,
      type: "struct",
      storageClassType: "SourceInputSystemStateCollectorsFirewall",
    },
    hostsfile: {
      value: sourceInputSystemStateCollectorsHostsfileToHclTerraform(struct!.hostsfile),
      isBlock: true,
      type: "struct",
      storageClassType: "SourceInputSystemStateCollectorsHostsfile",
    },
    interfaces: {
      value: sourceInputSystemStateCollectorsInterfacesToHclTerraform(struct!.interfaces),
      isBlock: true,
      type: "struct",
      storageClassType: "SourceInputSystemStateCollectorsInterfaces",
    },
    login_users: {
      value: sourceInputSystemStateCollectorsLoginUsersToHclTerraform(struct!.loginUsers),
      isBlock: true,
      type: "struct",
      storageClassType: "SourceInputSystemStateCollectorsLoginUsers",
    },
    metadata: {
      value: sourceInputSystemStateCollectorsMetadataToHclTerraform(struct!.metadata),
      isBlock: true,
      type: "struct",
      storageClassType: "SourceInputSystemStateCollectorsMetadata",
    },
    ports: {
      value: sourceInputSystemStateCollectorsPortsToHclTerraform(struct!.ports),
      isBlock: true,
      type: "struct",
      storageClassType: "SourceInputSystemStateCollectorsPorts",
    },
    routes: {
      value: sourceInputSystemStateCollectorsRoutesToHclTerraform(struct!.routes),
      isBlock: true,
      type: "struct",
      storageClassType: "SourceInputSystemStateCollectorsRoutes",
    },
    services: {
      value: sourceInputSystemStateCollectorsServicesToHclTerraform(struct!.services),
      isBlock: true,
      type: "struct",
      storageClassType: "SourceInputSystemStateCollectorsServices",
    },
    user: {
      value: sourceInputSystemStateCollectorsUserToHclTerraform(struct!.user),
      isBlock: true,
      type: "struct",
      storageClassType: "SourceInputSystemStateCollectorsUser",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputSystemStateCollectorsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SourceInputSystemStateCollectors | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._disk?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.disk = this._disk?.internalValue;
    }
    if (this._dns?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.dns = this._dns?.internalValue;
    }
    if (this._firewall?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.firewall = this._firewall?.internalValue;
    }
    if (this._hostsfile?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.hostsfile = this._hostsfile?.internalValue;
    }
    if (this._interfaces?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.interfaces = this._interfaces?.internalValue;
    }
    if (this._loginUsers?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.loginUsers = this._loginUsers?.internalValue;
    }
    if (this._metadata?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadata = this._metadata?.internalValue;
    }
    if (this._ports?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.ports = this._ports?.internalValue;
    }
    if (this._routes?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.routes = this._routes?.internalValue;
    }
    if (this._services?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.services = this._services?.internalValue;
    }
    if (this._user?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.user = this._user?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputSystemStateCollectors | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._disk.internalValue = undefined;
      this._dns.internalValue = undefined;
      this._firewall.internalValue = undefined;
      this._hostsfile.internalValue = undefined;
      this._interfaces.internalValue = undefined;
      this._loginUsers.internalValue = undefined;
      this._metadata.internalValue = undefined;
      this._ports.internalValue = undefined;
      this._routes.internalValue = undefined;
      this._services.internalValue = undefined;
      this._user.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._disk.internalValue = value.disk;
      this._dns.internalValue = value.dns;
      this._firewall.internalValue = value.firewall;
      this._hostsfile.internalValue = value.hostsfile;
      this._interfaces.internalValue = value.interfaces;
      this._loginUsers.internalValue = value.loginUsers;
      this._metadata.internalValue = value.metadata;
      this._ports.internalValue = value.ports;
      this._routes.internalValue = value.routes;
      this._services.internalValue = value.services;
      this._user.internalValue = value.user;
    }
  }

  // disk - computed: false, optional: true, required: false
  private _disk = new SourceInputSystemStateCollectorsDiskOutputReference(this, "disk");
  public get disk() {
    return this._disk;
  }
  public putDisk(value: SourceInputSystemStateCollectorsDisk) {
    this._disk.internalValue = value;
  }
  public resetDisk() {
    this._disk.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get diskInput() {
    return this._disk.internalValue;
  }

  // dns - computed: false, optional: true, required: false
  private _dns = new SourceInputSystemStateCollectorsDnsOutputReference(this, "dns");
  public get dns() {
    return this._dns;
  }
  public putDns(value: SourceInputSystemStateCollectorsDns) {
    this._dns.internalValue = value;
  }
  public resetDns() {
    this._dns.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get dnsInput() {
    return this._dns.internalValue;
  }

  // firewall - computed: false, optional: true, required: false
  private _firewall = new SourceInputSystemStateCollectorsFirewallOutputReference(this, "firewall");
  public get firewall() {
    return this._firewall;
  }
  public putFirewall(value: SourceInputSystemStateCollectorsFirewall) {
    this._firewall.internalValue = value;
  }
  public resetFirewall() {
    this._firewall.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get firewallInput() {
    return this._firewall.internalValue;
  }

  // hostsfile - computed: false, optional: true, required: false
  private _hostsfile = new SourceInputSystemStateCollectorsHostsfileOutputReference(this, "hostsfile");
  public get hostsfile() {
    return this._hostsfile;
  }
  public putHostsfile(value: SourceInputSystemStateCollectorsHostsfile) {
    this._hostsfile.internalValue = value;
  }
  public resetHostsfile() {
    this._hostsfile.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostsfileInput() {
    return this._hostsfile.internalValue;
  }

  // interfaces - computed: false, optional: true, required: false
  private _interfaces = new SourceInputSystemStateCollectorsInterfacesOutputReference(this, "interfaces");
  public get interfaces() {
    return this._interfaces;
  }
  public putInterfaces(value: SourceInputSystemStateCollectorsInterfaces) {
    this._interfaces.internalValue = value;
  }
  public resetInterfaces() {
    this._interfaces.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get interfacesInput() {
    return this._interfaces.internalValue;
  }

  // login_users - computed: false, optional: true, required: false
  private _loginUsers = new SourceInputSystemStateCollectorsLoginUsersOutputReference(this, "login_users");
  public get loginUsers() {
    return this._loginUsers;
  }
  public putLoginUsers(value: SourceInputSystemStateCollectorsLoginUsers) {
    this._loginUsers.internalValue = value;
  }
  public resetLoginUsers() {
    this._loginUsers.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get loginUsersInput() {
    return this._loginUsers.internalValue;
  }

  // metadata - computed: false, optional: true, required: false
  private _metadata = new SourceInputSystemStateCollectorsMetadataOutputReference(this, "metadata");
  public get metadata() {
    return this._metadata;
  }
  public putMetadata(value: SourceInputSystemStateCollectorsMetadata) {
    this._metadata.internalValue = value;
  }
  public resetMetadata() {
    this._metadata.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataInput() {
    return this._metadata.internalValue;
  }

  // ports - computed: false, optional: true, required: false
  private _ports = new SourceInputSystemStateCollectorsPortsOutputReference(this, "ports");
  public get ports() {
    return this._ports;
  }
  public putPorts(value: SourceInputSystemStateCollectorsPorts) {
    this._ports.internalValue = value;
  }
  public resetPorts() {
    this._ports.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portsInput() {
    return this._ports.internalValue;
  }

  // routes - computed: false, optional: true, required: false
  private _routes = new SourceInputSystemStateCollectorsRoutesOutputReference(this, "routes");
  public get routes() {
    return this._routes;
  }
  public putRoutes(value: SourceInputSystemStateCollectorsRoutes) {
    this._routes.internalValue = value;
  }
  public resetRoutes() {
    this._routes.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get routesInput() {
    return this._routes.internalValue;
  }

  // services - computed: false, optional: true, required: false
  private _services = new SourceInputSystemStateCollectorsServicesOutputReference(this, "services");
  public get services() {
    return this._services;
  }
  public putServices(value: SourceInputSystemStateCollectorsServices) {
    this._services.internalValue = value;
  }
  public resetServices() {
    this._services.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get servicesInput() {
    return this._services.internalValue;
  }

  // user - computed: false, optional: true, required: false
  private _user = new SourceInputSystemStateCollectorsUserOutputReference(this, "user");
  public get user() {
    return this._user;
  }
  public putUser(value: SourceInputSystemStateCollectorsUser) {
    this._user.internalValue = value;
  }
  public resetUser() {
    this._user.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get userInput() {
    return this._user.internalValue;
  }
}
export interface SourceInputSystemStateConnections {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#output Source#output}
  */
  readonly output: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#pipeline Source#pipeline}
  */
  readonly pipeline?: string;
}

export function sourceInputSystemStateConnectionsToTerraform(struct?: SourceInputSystemStateConnections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    output: cdktf.stringToTerraform(struct!.output),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
  }
}


export function sourceInputSystemStateConnectionsToHclTerraform(struct?: SourceInputSystemStateConnections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    output: {
      value: cdktf.stringToHclTerraform(struct!.output),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputSystemStateConnectionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): SourceInputSystemStateConnections | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._output !== undefined) {
      hasAnyValues = true;
      internalValueResult.output = this._output;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputSystemStateConnections | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._output = undefined;
      this._pipeline = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._output = value.output;
      this._pipeline = value.pipeline;
    }
  }

  // output - computed: false, optional: false, required: true
  private _output?: string; 
  public get output() {
    return this.getStringAttribute('output');
  }
  public set output(value: string) {
    this._output = value;
  }
  // Temporarily expose input value. Use with caution.
  public get outputInput() {
    return this._output;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }
}

export class SourceInputSystemStateConnectionsList extends cdktf.ComplexList {
  public internalValue? : SourceInputSystemStateConnections[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): SourceInputSystemStateConnectionsOutputReference {
    return new SourceInputSystemStateConnectionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface SourceInputSystemStateMetadata {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#name Source#name}
  */
  readonly name: string;
  /**
  * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#value Source#value}
  */
  readonly value: string;
}

export function sourceInputSystemStateMetadataToTerraform(struct?: SourceInputSystemStateMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function sourceInputSystemStateMetadataToHclTerraform(struct?: SourceInputSystemStateMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputSystemStateMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): SourceInputSystemStateMetadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputSystemStateMetadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class SourceInputSystemStateMetadataList extends cdktf.ComplexList {
  public internalValue? : SourceInputSystemStateMetadata[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): SourceInputSystemStateMetadataOutputReference {
    return new SourceInputSystemStateMetadataOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface SourceInputSystemStatePersistence {
  /**
  * Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#compress Source#compress}
  */
  readonly compress?: string;
  /**
  * Path to use to write metrics. Defaults to $CRIBL_HOME/state/system_state. Default: "$CRIBL_HOME/state/system_state"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#dest_path Source#dest_path}
  */
  readonly destPath?: string;
  /**
  * Spool metrics to disk for Cribl Edge and Search. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#enable Source#enable}
  */
  readonly enable?: boolean | cdktf.IResolvable;
  /**
  * Maximum disk space allowed to be consumed (examples: 420MB, 4GB). When limit is reached, older data will be deleted. Default: "1GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_data_size Source#max_data_size}
  */
  readonly maxDataSize?: string;
  /**
  * Maximum amount of time to retain data (examples: 2h, 4d). When limit is reached, older data will be deleted. Default: "24h"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_data_time Source#max_data_time}
  */
  readonly maxDataTime?: string;
  /**
  * Time span for each file bucket. Default: "10m"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#time_window Source#time_window}
  */
  readonly timeWindow?: string;
}

export function sourceInputSystemStatePersistenceToTerraform(struct?: SourceInputSystemStatePersistence | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    compress: cdktf.stringToTerraform(struct!.compress),
    dest_path: cdktf.stringToTerraform(struct!.destPath),
    enable: cdktf.booleanToTerraform(struct!.enable),
    max_data_size: cdktf.stringToTerraform(struct!.maxDataSize),
    max_data_time: cdktf.stringToTerraform(struct!.maxDataTime),
    time_window: cdktf.stringToTerraform(struct!.timeWindow),
  }
}


export function sourceInputSystemStatePersistenceToHclTerraform(struct?: SourceInputSystemStatePersistence | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    compress: {
      value: cdktf.stringToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    dest_path: {
      value: cdktf.stringToHclTerraform(struct!.destPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    enable: {
      value: cdktf.booleanToHclTerraform(struct!.enable),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    max_data_size: {
      value: cdktf.stringToHclTerraform(struct!.maxDataSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_data_time: {
      value: cdktf.stringToHclTerraform(struct!.maxDataTime),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    time_window: {
      value: cdktf.stringToHclTerraform(struct!.timeWindow),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputSystemStatePersistenceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SourceInputSystemStatePersistence | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._destPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.destPath = this._destPath;
    }
    if (this._enable !== undefined) {
      hasAnyValues = true;
      internalValueResult.enable = this._enable;
    }
    if (this._maxDataSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxDataSize = this._maxDataSize;
    }
    if (this._maxDataTime !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxDataTime = this._maxDataTime;
    }
    if (this._timeWindow !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeWindow = this._timeWindow;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputSystemStatePersistence | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._compress = undefined;
      this._destPath = undefined;
      this._enable = undefined;
      this._maxDataSize = undefined;
      this._maxDataTime = undefined;
      this._timeWindow = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._compress = value.compress;
      this._destPath = value.destPath;
      this._enable = value.enable;
      this._maxDataSize = value.maxDataSize;
      this._maxDataTime = value.maxDataTime;
      this._timeWindow = value.timeWindow;
    }
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: string; 
  public get compress() {
    return this.getStringAttribute('compress');
  }
  public set compress(value: string) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // dest_path - computed: true, optional: true, required: false
  private _destPath?: string; 
  public get destPath() {
    return this.getStringAttribute('dest_path');
  }
  public set destPath(value: string) {
    this._destPath = value;
  }
  public resetDestPath() {
    this._destPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get destPathInput() {
    return this._destPath;
  }

  // enable - computed: true, optional: true, required: false
  private _enable?: boolean | cdktf.IResolvable; 
  public get enable() {
    return this.getBooleanAttribute('enable');
  }
  public set enable(value: boolean | cdktf.IResolvable) {
    this._enable = value;
  }
  public resetEnable() {
    this._enable = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableInput() {
    return this._enable;
  }

  // max_data_size - computed: true, optional: true, required: false
  private _maxDataSize?: string; 
  public get maxDataSize() {
    return this.getStringAttribute('max_data_size');
  }
  public set maxDataSize(value: string) {
    this._maxDataSize = value;
  }
  public resetMaxDataSize() {
    this._maxDataSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxDataSizeInput() {
    return this._maxDataSize;
  }

  // max_data_time - computed: true, optional: true, required: false
  private _maxDataTime?: string; 
  public get maxDataTime() {
    return this.getStringAttribute('max_data_time');
  }
  public set maxDataTime(value: string) {
    this._maxDataTime = value;
  }
  public resetMaxDataTime() {
    this._maxDataTime = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxDataTimeInput() {
    return this._maxDataTime;
  }

  // time_window - computed: true, optional: true, required: false
  private _timeWindow?: string; 
  public get timeWindow() {
    return this.getStringAttribute('time_window');
  }
  public set timeWindow(value: string) {
    this._timeWindow = value;
  }
  public resetTimeWindow() {
    this._timeWindow = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeWindowInput() {
    return this._timeWindow;
  }
}
export interface SourceInputSystemStatePq {
  /**
  * The number of events to send downstream before committing that Stream has read them. Default: 42
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#commit_frequency Source#commit_frequency}
  */
  readonly commitFrequency?: number;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#compress Source#compress}
  */
  readonly compress?: string;
  /**
  * The maximum number of events to hold in memory before writing the events to disk. Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_buffer_size Source#max_buffer_size}
  */
  readonly maxBufferSize?: number;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc. Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_file_size Source#max_file_size}
  */
  readonly maxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_size Source#max_size}
  */
  readonly maxSize?: string;
  /**
  * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine. Default: "always"; must be one of ["smart", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#mode Source#mode}
  */
  readonly mode?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#path Source#path}
  */
  readonly path?: string;
}

export function sourceInputSystemStatePqToTerraform(struct?: SourceInputSystemStatePq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    commit_frequency: cdktf.numberToTerraform(struct!.commitFrequency),
    compress: cdktf.stringToTerraform(struct!.compress),
    max_buffer_size: cdktf.numberToTerraform(struct!.maxBufferSize),
    max_file_size: cdktf.stringToTerraform(struct!.maxFileSize),
    max_size: cdktf.stringToTerraform(struct!.maxSize),
    mode: cdktf.stringToTerraform(struct!.mode),
    path: cdktf.stringToTerraform(struct!.path),
  }
}


export function sourceInputSystemStatePqToHclTerraform(struct?: SourceInputSystemStatePq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    commit_frequency: {
      value: cdktf.numberToHclTerraform(struct!.commitFrequency),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    compress: {
      value: cdktf.stringToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_buffer_size: {
      value: cdktf.numberToHclTerraform(struct!.maxBufferSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.maxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_size: {
      value: cdktf.stringToHclTerraform(struct!.maxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputSystemStatePqOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SourceInputSystemStatePq | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._commitFrequency !== undefined) {
      hasAnyValues = true;
      internalValueResult.commitFrequency = this._commitFrequency;
    }
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._maxBufferSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBufferSize = this._maxBufferSize;
    }
    if (this._maxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxFileSize = this._maxFileSize;
    }
    if (this._maxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxSize = this._maxSize;
    }
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputSystemStatePq | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._commitFrequency = undefined;
      this._compress = undefined;
      this._maxBufferSize = undefined;
      this._maxFileSize = undefined;
      this._maxSize = undefined;
      this._mode = undefined;
      this._path = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._commitFrequency = value.commitFrequency;
      this._compress = value.compress;
      this._maxBufferSize = value.maxBufferSize;
      this._maxFileSize = value.maxFileSize;
      this._maxSize = value.maxSize;
      this._mode = value.mode;
      this._path = value.path;
    }
  }

  // commit_frequency - computed: true, optional: true, required: false
  private _commitFrequency?: number; 
  public get commitFrequency() {
    return this.getNumberAttribute('commit_frequency');
  }
  public set commitFrequency(value: number) {
    this._commitFrequency = value;
  }
  public resetCommitFrequency() {
    this._commitFrequency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commitFrequencyInput() {
    return this._commitFrequency;
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: string; 
  public get compress() {
    return this.getStringAttribute('compress');
  }
  public set compress(value: string) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // max_buffer_size - computed: true, optional: true, required: false
  private _maxBufferSize?: number; 
  public get maxBufferSize() {
    return this.getNumberAttribute('max_buffer_size');
  }
  public set maxBufferSize(value: number) {
    this._maxBufferSize = value;
  }
  public resetMaxBufferSize() {
    this._maxBufferSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBufferSizeInput() {
    return this._maxBufferSize;
  }

  // max_file_size - computed: true, optional: true, required: false
  private _maxFileSize?: string; 
  public get maxFileSize() {
    return this.getStringAttribute('max_file_size');
  }
  public set maxFileSize(value: string) {
    this._maxFileSize = value;
  }
  public resetMaxFileSize() {
    this._maxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxFileSizeInput() {
    return this._maxFileSize;
  }

  // max_size - computed: true, optional: true, required: false
  private _maxSize?: string; 
  public get maxSize() {
    return this.getStringAttribute('max_size');
  }
  public set maxSize(value: string) {
    this._maxSize = value;
  }
  public resetMaxSize() {
    this._maxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxSizeInput() {
    return this._maxSize;
  }

  // mode - computed: true, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // path - computed: true, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }
}
export interface SourceInputSystemState {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#collectors Source#collectors}
  */
  readonly collectors?: SourceInputSystemStateCollectors;
  /**
  * Direct connections to Destinations, and optionally via a Pipeline or a Pack
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#connections Source#connections}
  */
  readonly connections?: SourceInputSystemStateConnections[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#description Source#description}
  */
  readonly description?: string;
  /**
  * Enable to use built-in tools (PowerShell) to collect events instead of native API (default) [Learn more](https://docs.cribl.io/edge/sources-system-state/#advanced-tab). Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#disable_native_module Source#disable_native_module}
  */
  readonly disableNativeModule?: boolean | cdktf.IResolvable;
  /**
  * Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#disabled Source#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#environment Source#environment}
  */
  readonly environment?: string;
  /**
  * Unique ID for this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#id Source#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id: string;
  /**
  * Time, in seconds, between consecutive state collections. Default is 300 seconds (5 minutes). Default: 300
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#interval Source#interval}
  */
  readonly interval?: number;
  /**
  * Fields to add to events from this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#metadata Source#metadata}
  */
  readonly metadata?: SourceInputSystemStateMetadata[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#persistence Source#persistence}
  */
  readonly persistence?: SourceInputSystemStatePersistence;
  /**
  * Pipeline to process data from this Source before sending it through the Routes
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#pipeline Source#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#pq Source#pq}
  */
  readonly pq?: SourceInputSystemStatePq;
  /**
  * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers). Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#pq_enabled Source#pq_enabled}
  */
  readonly pqEnabled?: boolean | cdktf.IResolvable;
  /**
  * Select whether to send data to Routes, or directly to Destinations. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#send_to_routes Source#send_to_routes}
  */
  readonly sendToRoutes?: boolean | cdktf.IResolvable;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#streamtags Source#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * must be "system_state"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#type Source#type}
  */
  readonly type: string;
}

export function sourceInputSystemStateToTerraform(struct?: SourceInputSystemState | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    collectors: sourceInputSystemStateCollectorsToTerraform(struct!.collectors),
    connections: cdktf.listMapper(sourceInputSystemStateConnectionsToTerraform, false)(struct!.connections),
    description: cdktf.stringToTerraform(struct!.description),
    disable_native_module: cdktf.booleanToTerraform(struct!.disableNativeModule),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    environment: cdktf.stringToTerraform(struct!.environment),
    id: cdktf.stringToTerraform(struct!.id),
    interval: cdktf.numberToTerraform(struct!.interval),
    metadata: cdktf.listMapper(sourceInputSystemStateMetadataToTerraform, false)(struct!.metadata),
    persistence: sourceInputSystemStatePersistenceToTerraform(struct!.persistence),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    pq: sourceInputSystemStatePqToTerraform(struct!.pq),
    pq_enabled: cdktf.booleanToTerraform(struct!.pqEnabled),
    send_to_routes: cdktf.booleanToTerraform(struct!.sendToRoutes),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function sourceInputSystemStateToHclTerraform(struct?: SourceInputSystemState | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    collectors: {
      value: sourceInputSystemStateCollectorsToHclTerraform(struct!.collectors),
      isBlock: true,
      type: "struct",
      storageClassType: "SourceInputSystemStateCollectors",
    },
    connections: {
      value: cdktf.listMapperHcl(sourceInputSystemStateConnectionsToHclTerraform, false)(struct!.connections),
      isBlock: true,
      type: "list",
      storageClassType: "SourceInputSystemStateConnectionsList",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disable_native_module: {
      value: cdktf.booleanToHclTerraform(struct!.disableNativeModule),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    interval: {
      value: cdktf.numberToHclTerraform(struct!.interval),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    metadata: {
      value: cdktf.listMapperHcl(sourceInputSystemStateMetadataToHclTerraform, false)(struct!.metadata),
      isBlock: true,
      type: "list",
      storageClassType: "SourceInputSystemStateMetadataList",
    },
    persistence: {
      value: sourceInputSystemStatePersistenceToHclTerraform(struct!.persistence),
      isBlock: true,
      type: "struct",
      storageClassType: "SourceInputSystemStatePersistence",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq: {
      value: sourceInputSystemStatePqToHclTerraform(struct!.pq),
      isBlock: true,
      type: "struct",
      storageClassType: "SourceInputSystemStatePq",
    },
    pq_enabled: {
      value: cdktf.booleanToHclTerraform(struct!.pqEnabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    send_to_routes: {
      value: cdktf.booleanToHclTerraform(struct!.sendToRoutes),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputSystemStateOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SourceInputSystemState | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._collectors?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.collectors = this._collectors?.internalValue;
    }
    if (this._connections?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.connections = this._connections?.internalValue;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._disableNativeModule !== undefined) {
      hasAnyValues = true;
      internalValueResult.disableNativeModule = this._disableNativeModule;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._interval !== undefined) {
      hasAnyValues = true;
      internalValueResult.interval = this._interval;
    }
    if (this._metadata?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadata = this._metadata?.internalValue;
    }
    if (this._persistence?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.persistence = this._persistence?.internalValue;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._pq?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pq = this._pq?.internalValue;
    }
    if (this._pqEnabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqEnabled = this._pqEnabled;
    }
    if (this._sendToRoutes !== undefined) {
      hasAnyValues = true;
      internalValueResult.sendToRoutes = this._sendToRoutes;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputSystemState | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._collectors.internalValue = undefined;
      this._connections.internalValue = undefined;
      this._description = undefined;
      this._disableNativeModule = undefined;
      this._disabled = undefined;
      this._environment = undefined;
      this._id = undefined;
      this._interval = undefined;
      this._metadata.internalValue = undefined;
      this._persistence.internalValue = undefined;
      this._pipeline = undefined;
      this._pq.internalValue = undefined;
      this._pqEnabled = undefined;
      this._sendToRoutes = undefined;
      this._streamtags = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._collectors.internalValue = value.collectors;
      this._connections.internalValue = value.connections;
      this._description = value.description;
      this._disableNativeModule = value.disableNativeModule;
      this._disabled = value.disabled;
      this._environment = value.environment;
      this._id = value.id;
      this._interval = value.interval;
      this._metadata.internalValue = value.metadata;
      this._persistence.internalValue = value.persistence;
      this._pipeline = value.pipeline;
      this._pq.internalValue = value.pq;
      this._pqEnabled = value.pqEnabled;
      this._sendToRoutes = value.sendToRoutes;
      this._streamtags = value.streamtags;
      this._type = value.type;
    }
  }

  // collectors - computed: false, optional: true, required: false
  private _collectors = new SourceInputSystemStateCollectorsOutputReference(this, "collectors");
  public get collectors() {
    return this._collectors;
  }
  public putCollectors(value: SourceInputSystemStateCollectors) {
    this._collectors.internalValue = value;
  }
  public resetCollectors() {
    this._collectors.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get collectorsInput() {
    return this._collectors.internalValue;
  }

  // connections - computed: false, optional: true, required: false
  private _connections = new SourceInputSystemStateConnectionsList(this, "connections", false);
  public get connections() {
    return this._connections;
  }
  public putConnections(value: SourceInputSystemStateConnections[] | cdktf.IResolvable) {
    this._connections.internalValue = value;
  }
  public resetConnections() {
    this._connections.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectionsInput() {
    return this._connections.internalValue;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // disable_native_module - computed: true, optional: true, required: false
  private _disableNativeModule?: boolean | cdktf.IResolvable; 
  public get disableNativeModule() {
    return this.getBooleanAttribute('disable_native_module');
  }
  public set disableNativeModule(value: boolean | cdktf.IResolvable) {
    this._disableNativeModule = value;
  }
  public resetDisableNativeModule() {
    this._disableNativeModule = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disableNativeModuleInput() {
    return this._disableNativeModule;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // id - computed: false, optional: false, required: true
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // interval - computed: true, optional: true, required: false
  private _interval?: number; 
  public get interval() {
    return this.getNumberAttribute('interval');
  }
  public set interval(value: number) {
    this._interval = value;
  }
  public resetInterval() {
    this._interval = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get intervalInput() {
    return this._interval;
  }

  // metadata - computed: false, optional: true, required: false
  private _metadata = new SourceInputSystemStateMetadataList(this, "metadata", false);
  public get metadata() {
    return this._metadata;
  }
  public putMetadata(value: SourceInputSystemStateMetadata[] | cdktf.IResolvable) {
    this._metadata.internalValue = value;
  }
  public resetMetadata() {
    this._metadata.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataInput() {
    return this._metadata.internalValue;
  }

  // persistence - computed: false, optional: true, required: false
  private _persistence = new SourceInputSystemStatePersistenceOutputReference(this, "persistence");
  public get persistence() {
    return this._persistence;
  }
  public putPersistence(value: SourceInputSystemStatePersistence) {
    this._persistence.internalValue = value;
  }
  public resetPersistence() {
    this._persistence.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get persistenceInput() {
    return this._persistence.internalValue;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // pq - computed: false, optional: true, required: false
  private _pq = new SourceInputSystemStatePqOutputReference(this, "pq");
  public get pq() {
    return this._pq;
  }
  public putPq(value: SourceInputSystemStatePq) {
    this._pq.internalValue = value;
  }
  public resetPq() {
    this._pq.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqInput() {
    return this._pq.internalValue;
  }

  // pq_enabled - computed: true, optional: true, required: false
  private _pqEnabled?: boolean | cdktf.IResolvable; 
  public get pqEnabled() {
    return this.getBooleanAttribute('pq_enabled');
  }
  public set pqEnabled(value: boolean | cdktf.IResolvable) {
    this._pqEnabled = value;
  }
  public resetPqEnabled() {
    this._pqEnabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqEnabledInput() {
    return this._pqEnabled;
  }

  // send_to_routes - computed: true, optional: true, required: false
  private _sendToRoutes?: boolean | cdktf.IResolvable; 
  public get sendToRoutes() {
    return this.getBooleanAttribute('send_to_routes');
  }
  public set sendToRoutes(value: boolean | cdktf.IResolvable) {
    this._sendToRoutes = value;
  }
  public resetSendToRoutes() {
    this._sendToRoutes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sendToRoutesInput() {
    return this._sendToRoutes;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface SourceInputTcpConnections {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#output Source#output}
  */
  readonly output: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#pipeline Source#pipeline}
  */
  readonly pipeline?: string;
}

export function sourceInputTcpConnectionsToTerraform(struct?: SourceInputTcpConnections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    output: cdktf.stringToTerraform(struct!.output),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
  }
}


export function sourceInputTcpConnectionsToHclTerraform(struct?: SourceInputTcpConnections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    output: {
      value: cdktf.stringToHclTerraform(struct!.output),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputTcpConnectionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): SourceInputTcpConnections | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._output !== undefined) {
      hasAnyValues = true;
      internalValueResult.output = this._output;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputTcpConnections | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._output = undefined;
      this._pipeline = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._output = value.output;
      this._pipeline = value.pipeline;
    }
  }

  // output - computed: false, optional: false, required: true
  private _output?: string; 
  public get output() {
    return this.getStringAttribute('output');
  }
  public set output(value: string) {
    this._output = value;
  }
  // Temporarily expose input value. Use with caution.
  public get outputInput() {
    return this._output;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }
}

export class SourceInputTcpConnectionsList extends cdktf.ComplexList {
  public internalValue? : SourceInputTcpConnections[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): SourceInputTcpConnectionsOutputReference {
    return new SourceInputTcpConnectionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface SourceInputTcpMetadata {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#name Source#name}
  */
  readonly name: string;
  /**
  * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#value Source#value}
  */
  readonly value: string;
}

export function sourceInputTcpMetadataToTerraform(struct?: SourceInputTcpMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function sourceInputTcpMetadataToHclTerraform(struct?: SourceInputTcpMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputTcpMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): SourceInputTcpMetadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputTcpMetadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class SourceInputTcpMetadataList extends cdktf.ComplexList {
  public internalValue? : SourceInputTcpMetadata[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): SourceInputTcpMetadataOutputReference {
    return new SourceInputTcpMetadataOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface SourceInputTcpPq {
  /**
  * The number of events to send downstream before committing that Stream has read them. Default: 42
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#commit_frequency Source#commit_frequency}
  */
  readonly commitFrequency?: number;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#compress Source#compress}
  */
  readonly compress?: string;
  /**
  * The maximum number of events to hold in memory before writing the events to disk. Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_buffer_size Source#max_buffer_size}
  */
  readonly maxBufferSize?: number;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc. Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_file_size Source#max_file_size}
  */
  readonly maxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_size Source#max_size}
  */
  readonly maxSize?: string;
  /**
  * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine. Default: "always"; must be one of ["smart", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#mode Source#mode}
  */
  readonly mode?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#path Source#path}
  */
  readonly path?: string;
}

export function sourceInputTcpPqToTerraform(struct?: SourceInputTcpPq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    commit_frequency: cdktf.numberToTerraform(struct!.commitFrequency),
    compress: cdktf.stringToTerraform(struct!.compress),
    max_buffer_size: cdktf.numberToTerraform(struct!.maxBufferSize),
    max_file_size: cdktf.stringToTerraform(struct!.maxFileSize),
    max_size: cdktf.stringToTerraform(struct!.maxSize),
    mode: cdktf.stringToTerraform(struct!.mode),
    path: cdktf.stringToTerraform(struct!.path),
  }
}


export function sourceInputTcpPqToHclTerraform(struct?: SourceInputTcpPq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    commit_frequency: {
      value: cdktf.numberToHclTerraform(struct!.commitFrequency),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    compress: {
      value: cdktf.stringToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_buffer_size: {
      value: cdktf.numberToHclTerraform(struct!.maxBufferSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.maxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_size: {
      value: cdktf.stringToHclTerraform(struct!.maxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputTcpPqOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SourceInputTcpPq | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._commitFrequency !== undefined) {
      hasAnyValues = true;
      internalValueResult.commitFrequency = this._commitFrequency;
    }
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._maxBufferSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBufferSize = this._maxBufferSize;
    }
    if (this._maxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxFileSize = this._maxFileSize;
    }
    if (this._maxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxSize = this._maxSize;
    }
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputTcpPq | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._commitFrequency = undefined;
      this._compress = undefined;
      this._maxBufferSize = undefined;
      this._maxFileSize = undefined;
      this._maxSize = undefined;
      this._mode = undefined;
      this._path = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._commitFrequency = value.commitFrequency;
      this._compress = value.compress;
      this._maxBufferSize = value.maxBufferSize;
      this._maxFileSize = value.maxFileSize;
      this._maxSize = value.maxSize;
      this._mode = value.mode;
      this._path = value.path;
    }
  }

  // commit_frequency - computed: true, optional: true, required: false
  private _commitFrequency?: number; 
  public get commitFrequency() {
    return this.getNumberAttribute('commit_frequency');
  }
  public set commitFrequency(value: number) {
    this._commitFrequency = value;
  }
  public resetCommitFrequency() {
    this._commitFrequency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commitFrequencyInput() {
    return this._commitFrequency;
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: string; 
  public get compress() {
    return this.getStringAttribute('compress');
  }
  public set compress(value: string) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // max_buffer_size - computed: true, optional: true, required: false
  private _maxBufferSize?: number; 
  public get maxBufferSize() {
    return this.getNumberAttribute('max_buffer_size');
  }
  public set maxBufferSize(value: number) {
    this._maxBufferSize = value;
  }
  public resetMaxBufferSize() {
    this._maxBufferSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBufferSizeInput() {
    return this._maxBufferSize;
  }

  // max_file_size - computed: true, optional: true, required: false
  private _maxFileSize?: string; 
  public get maxFileSize() {
    return this.getStringAttribute('max_file_size');
  }
  public set maxFileSize(value: string) {
    this._maxFileSize = value;
  }
  public resetMaxFileSize() {
    this._maxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxFileSizeInput() {
    return this._maxFileSize;
  }

  // max_size - computed: true, optional: true, required: false
  private _maxSize?: string; 
  public get maxSize() {
    return this.getStringAttribute('max_size');
  }
  public set maxSize(value: string) {
    this._maxSize = value;
  }
  public resetMaxSize() {
    this._maxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxSizeInput() {
    return this._maxSize;
  }

  // mode - computed: true, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // path - computed: true, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }
}
export interface SourceInputTcpPreprocess {
  /**
  * Arguments to be added to the custom command
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#args Source#args}
  */
  readonly args?: string[];
  /**
  * Command to feed the data through (via stdin) and process its output (stdout)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#command Source#command}
  */
  readonly command?: string;
  /**
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#disabled Source#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
}

export function sourceInputTcpPreprocessToTerraform(struct?: SourceInputTcpPreprocess | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    args: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.args),
    command: cdktf.stringToTerraform(struct!.command),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
  }
}


export function sourceInputTcpPreprocessToHclTerraform(struct?: SourceInputTcpPreprocess | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    args: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.args),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    command: {
      value: cdktf.stringToHclTerraform(struct!.command),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputTcpPreprocessOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SourceInputTcpPreprocess | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._args !== undefined) {
      hasAnyValues = true;
      internalValueResult.args = this._args;
    }
    if (this._command !== undefined) {
      hasAnyValues = true;
      internalValueResult.command = this._command;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputTcpPreprocess | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._args = undefined;
      this._command = undefined;
      this._disabled = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._args = value.args;
      this._command = value.command;
      this._disabled = value.disabled;
    }
  }

  // args - computed: false, optional: true, required: false
  private _args?: string[]; 
  public get args() {
    return this.getListAttribute('args');
  }
  public set args(value: string[]) {
    this._args = value;
  }
  public resetArgs() {
    this._args = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get argsInput() {
    return this._args;
  }

  // command - computed: false, optional: true, required: false
  private _command?: string; 
  public get command() {
    return this.getStringAttribute('command');
  }
  public set command(value: string) {
    this._command = value;
  }
  public resetCommand() {
    this._command = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commandInput() {
    return this._command;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }
}
export interface SourceInputTcpTls {
  /**
  * Path on server containing CA certificates to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#ca_path Source#ca_path}
  */
  readonly caPath?: string;
  /**
  * Path on server containing certificates to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#cert_path Source#cert_path}
  */
  readonly certPath?: string;
  /**
  * The name of the predefined certificate
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#certificate_name Source#certificate_name}
  */
  readonly certificateName?: string;
  /**
  * Parsed as JSON.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#common_name_regex Source#common_name_regex}
  */
  readonly commonNameRegex?: string;
  /**
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#disabled Source#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_version Source#max_version}
  */
  readonly maxVersion?: string;
  /**
  * must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#min_version Source#min_version}
  */
  readonly minVersion?: string;
  /**
  * Passphrase to use to decrypt private key
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#passphrase Source#passphrase}
  */
  readonly passphrase?: string;
  /**
  * Path on server containing the private key to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#priv_key_path Source#priv_key_path}
  */
  readonly privKeyPath?: string;
  /**
  * Parsed as JSON.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#reject_unauthorized Source#reject_unauthorized}
  */
  readonly rejectUnauthorized?: string;
  /**
  * Require clients to present their certificates. Used to perform client authentication using SSL certs. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#request_cert Source#request_cert}
  */
  readonly requestCert?: boolean | cdktf.IResolvable;
}

export function sourceInputTcpTlsToTerraform(struct?: SourceInputTcpTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ca_path: cdktf.stringToTerraform(struct!.caPath),
    cert_path: cdktf.stringToTerraform(struct!.certPath),
    certificate_name: cdktf.stringToTerraform(struct!.certificateName),
    common_name_regex: cdktf.stringToTerraform(struct!.commonNameRegex),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    max_version: cdktf.stringToTerraform(struct!.maxVersion),
    min_version: cdktf.stringToTerraform(struct!.minVersion),
    passphrase: cdktf.stringToTerraform(struct!.passphrase),
    priv_key_path: cdktf.stringToTerraform(struct!.privKeyPath),
    reject_unauthorized: cdktf.stringToTerraform(struct!.rejectUnauthorized),
    request_cert: cdktf.booleanToTerraform(struct!.requestCert),
  }
}


export function sourceInputTcpTlsToHclTerraform(struct?: SourceInputTcpTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ca_path: {
      value: cdktf.stringToHclTerraform(struct!.caPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    cert_path: {
      value: cdktf.stringToHclTerraform(struct!.certPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    certificate_name: {
      value: cdktf.stringToHclTerraform(struct!.certificateName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    common_name_regex: {
      value: cdktf.stringToHclTerraform(struct!.commonNameRegex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    max_version: {
      value: cdktf.stringToHclTerraform(struct!.maxVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    min_version: {
      value: cdktf.stringToHclTerraform(struct!.minVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    passphrase: {
      value: cdktf.stringToHclTerraform(struct!.passphrase),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    priv_key_path: {
      value: cdktf.stringToHclTerraform(struct!.privKeyPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reject_unauthorized: {
      value: cdktf.stringToHclTerraform(struct!.rejectUnauthorized),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    request_cert: {
      value: cdktf.booleanToHclTerraform(struct!.requestCert),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputTcpTlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SourceInputTcpTls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._caPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.caPath = this._caPath;
    }
    if (this._certPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.certPath = this._certPath;
    }
    if (this._certificateName !== undefined) {
      hasAnyValues = true;
      internalValueResult.certificateName = this._certificateName;
    }
    if (this._commonNameRegex !== undefined) {
      hasAnyValues = true;
      internalValueResult.commonNameRegex = this._commonNameRegex;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._maxVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxVersion = this._maxVersion;
    }
    if (this._minVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.minVersion = this._minVersion;
    }
    if (this._passphrase !== undefined) {
      hasAnyValues = true;
      internalValueResult.passphrase = this._passphrase;
    }
    if (this._privKeyPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.privKeyPath = this._privKeyPath;
    }
    if (this._rejectUnauthorized !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectUnauthorized = this._rejectUnauthorized;
    }
    if (this._requestCert !== undefined) {
      hasAnyValues = true;
      internalValueResult.requestCert = this._requestCert;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputTcpTls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._caPath = undefined;
      this._certPath = undefined;
      this._certificateName = undefined;
      this._commonNameRegex = undefined;
      this._disabled = undefined;
      this._maxVersion = undefined;
      this._minVersion = undefined;
      this._passphrase = undefined;
      this._privKeyPath = undefined;
      this._rejectUnauthorized = undefined;
      this._requestCert = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._caPath = value.caPath;
      this._certPath = value.certPath;
      this._certificateName = value.certificateName;
      this._commonNameRegex = value.commonNameRegex;
      this._disabled = value.disabled;
      this._maxVersion = value.maxVersion;
      this._minVersion = value.minVersion;
      this._passphrase = value.passphrase;
      this._privKeyPath = value.privKeyPath;
      this._rejectUnauthorized = value.rejectUnauthorized;
      this._requestCert = value.requestCert;
    }
  }

  // ca_path - computed: false, optional: true, required: false
  private _caPath?: string; 
  public get caPath() {
    return this.getStringAttribute('ca_path');
  }
  public set caPath(value: string) {
    this._caPath = value;
  }
  public resetCaPath() {
    this._caPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get caPathInput() {
    return this._caPath;
  }

  // cert_path - computed: false, optional: true, required: false
  private _certPath?: string; 
  public get certPath() {
    return this.getStringAttribute('cert_path');
  }
  public set certPath(value: string) {
    this._certPath = value;
  }
  public resetCertPath() {
    this._certPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certPathInput() {
    return this._certPath;
  }

  // certificate_name - computed: false, optional: true, required: false
  private _certificateName?: string; 
  public get certificateName() {
    return this.getStringAttribute('certificate_name');
  }
  public set certificateName(value: string) {
    this._certificateName = value;
  }
  public resetCertificateName() {
    this._certificateName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certificateNameInput() {
    return this._certificateName;
  }

  // common_name_regex - computed: false, optional: true, required: false
  private _commonNameRegex?: string; 
  public get commonNameRegex() {
    return this.getStringAttribute('common_name_regex');
  }
  public set commonNameRegex(value: string) {
    this._commonNameRegex = value;
  }
  public resetCommonNameRegex() {
    this._commonNameRegex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commonNameRegexInput() {
    return this._commonNameRegex;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // max_version - computed: false, optional: true, required: false
  private _maxVersion?: string; 
  public get maxVersion() {
    return this.getStringAttribute('max_version');
  }
  public set maxVersion(value: string) {
    this._maxVersion = value;
  }
  public resetMaxVersion() {
    this._maxVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxVersionInput() {
    return this._maxVersion;
  }

  // min_version - computed: false, optional: true, required: false
  private _minVersion?: string; 
  public get minVersion() {
    return this.getStringAttribute('min_version');
  }
  public set minVersion(value: string) {
    this._minVersion = value;
  }
  public resetMinVersion() {
    this._minVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get minVersionInput() {
    return this._minVersion;
  }

  // passphrase - computed: false, optional: true, required: false
  private _passphrase?: string; 
  public get passphrase() {
    return this.getStringAttribute('passphrase');
  }
  public set passphrase(value: string) {
    this._passphrase = value;
  }
  public resetPassphrase() {
    this._passphrase = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passphraseInput() {
    return this._passphrase;
  }

  // priv_key_path - computed: false, optional: true, required: false
  private _privKeyPath?: string; 
  public get privKeyPath() {
    return this.getStringAttribute('priv_key_path');
  }
  public set privKeyPath(value: string) {
    this._privKeyPath = value;
  }
  public resetPrivKeyPath() {
    this._privKeyPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get privKeyPathInput() {
    return this._privKeyPath;
  }

  // reject_unauthorized - computed: false, optional: true, required: false
  private _rejectUnauthorized?: string; 
  public get rejectUnauthorized() {
    return this.getStringAttribute('reject_unauthorized');
  }
  public set rejectUnauthorized(value: string) {
    this._rejectUnauthorized = value;
  }
  public resetRejectUnauthorized() {
    this._rejectUnauthorized = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectUnauthorizedInput() {
    return this._rejectUnauthorized;
  }

  // request_cert - computed: true, optional: true, required: false
  private _requestCert?: boolean | cdktf.IResolvable; 
  public get requestCert() {
    return this.getBooleanAttribute('request_cert');
  }
  public set requestCert(value: boolean | cdktf.IResolvable) {
    this._requestCert = value;
  }
  public resetRequestCert() {
    this._requestCert = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestCertInput() {
    return this._requestCert;
  }
}
export interface SourceInputTcp {
  /**
  * Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate. Default: "manual"; must be one of ["manual", "secret"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#auth_type Source#auth_type}
  */
  readonly authType?: string;
  /**
  * A list of event-breaking rulesets that will be applied, in order, to the input data stream
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#breaker_rulesets Source#breaker_rulesets}
  */
  readonly breakerRulesets?: string[];
  /**
  * Direct connections to Destinations, and optionally via a Pipeline or a Pack
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#connections Source#connections}
  */
  readonly connections?: SourceInputTcpConnections[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#description Source#description}
  */
  readonly description?: string;
  /**
  * Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#disabled Source#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * Client will pass the header record with every new connection. The header can contain an authToken, and an object with a list of fields and values to add to every event. These fields can be used to simplify Event Breaker selection, routing, etc. Header has this format, and must be followed by a newline: { "authToken" : "myToken", "fields": { "field1": "value1", "field2": "value2" } }. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#enable_header Source#enable_header}
  */
  readonly enableHeader?: boolean | cdktf.IResolvable;
  /**
  * Enable if the connection is proxied by a device that supports Proxy Protocol V1 or V2. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#enable_proxy_header Source#enable_proxy_header}
  */
  readonly enableProxyHeader?: boolean | cdktf.IResolvable;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#environment Source#environment}
  */
  readonly environment?: string;
  /**
  * Address to bind on. Defaults to 0.0.0.0 (all addresses). Default: "0.0.0.0"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#host Source#host}
  */
  readonly host?: string;
  /**
  * Unique ID for this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#id Source#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * Regex matching IP addresses that are allowed to establish a connection. Default: "/.* /"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#ip_whitelist_regex Source#ip_whitelist_regex}
   *
  * Note: The above comment contained a comment block ending sequence (* followed by /). We have introduced a space between to prevent syntax errors. Please ignore the space.
  */
  readonly ipWhitelistRegex?: string;
  /**
  * Maximum number of active connections allowed per Worker Process. Use 0 for unlimited. Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_active_cxn Source#max_active_cxn}
  */
  readonly maxActiveCxn?: number;
  /**
  * Fields to add to events from this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#metadata Source#metadata}
  */
  readonly metadata?: SourceInputTcpMetadata[] | cdktf.IResolvable;
  /**
  * Pipeline to process data from this Source before sending it through the Routes
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#pipeline Source#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Port to listen on
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#port Source#port}
  */
  readonly port: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#pq Source#pq}
  */
  readonly pq?: SourceInputTcpPq;
  /**
  * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers). Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#pq_enabled Source#pq_enabled}
  */
  readonly pqEnabled?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#preprocess Source#preprocess}
  */
  readonly preprocess?: SourceInputTcpPreprocess;
  /**
  * Select whether to send data to Routes, or directly to Destinations. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#send_to_routes Source#send_to_routes}
  */
  readonly sendToRoutes?: boolean | cdktf.IResolvable;
  /**
  * How long the server will wait after initiating a closure for a client to close its end of the connection. If the client doesn't close the connection within this time, the server will forcefully terminate the socket to prevent resource leaks and ensure efficient connection cleanup and system stability. Leave at 0 for no inactive socket monitoring. Default: 30
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#socket_ending_max_wait Source#socket_ending_max_wait}
  */
  readonly socketEndingMaxWait?: number;
  /**
  * How long @{product} should wait before assuming that an inactive socket has timed out. After this time, the connection will be closed. Leave at 0 for no inactive socket monitoring. Default: 0
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#socket_idle_timeout Source#socket_idle_timeout}
  */
  readonly socketIdleTimeout?: number;
  /**
  * The maximum duration a socket can remain open, even if active. This helps manage resources and mitigate issues caused by TCP pinning. Set to 0 to disable. Default: 0
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#socket_max_lifespan Source#socket_max_lifespan}
  */
  readonly socketMaxLifespan?: number;
  /**
  * How long (in milliseconds) the Event Breaker will wait for new data to be sent to a specific channel before flushing the data stream out, as is, to the Pipelines. Default: 10000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#stale_channel_flush_ms Source#stale_channel_flush_ms}
  */
  readonly staleChannelFlushMs?: number;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#streamtags Source#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#tls Source#tls}
  */
  readonly tls?: SourceInputTcpTls;
  /**
  * must be "tcp"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#type Source#type}
  */
  readonly type?: string;
}

export function sourceInputTcpToTerraform(struct?: SourceInputTcp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    auth_type: cdktf.stringToTerraform(struct!.authType),
    breaker_rulesets: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.breakerRulesets),
    connections: cdktf.listMapper(sourceInputTcpConnectionsToTerraform, false)(struct!.connections),
    description: cdktf.stringToTerraform(struct!.description),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    enable_header: cdktf.booleanToTerraform(struct!.enableHeader),
    enable_proxy_header: cdktf.booleanToTerraform(struct!.enableProxyHeader),
    environment: cdktf.stringToTerraform(struct!.environment),
    host: cdktf.stringToTerraform(struct!.host),
    id: cdktf.stringToTerraform(struct!.id),
    ip_whitelist_regex: cdktf.stringToTerraform(struct!.ipWhitelistRegex),
    max_active_cxn: cdktf.numberToTerraform(struct!.maxActiveCxn),
    metadata: cdktf.listMapper(sourceInputTcpMetadataToTerraform, false)(struct!.metadata),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    port: cdktf.numberToTerraform(struct!.port),
    pq: sourceInputTcpPqToTerraform(struct!.pq),
    pq_enabled: cdktf.booleanToTerraform(struct!.pqEnabled),
    preprocess: sourceInputTcpPreprocessToTerraform(struct!.preprocess),
    send_to_routes: cdktf.booleanToTerraform(struct!.sendToRoutes),
    socket_ending_max_wait: cdktf.numberToTerraform(struct!.socketEndingMaxWait),
    socket_idle_timeout: cdktf.numberToTerraform(struct!.socketIdleTimeout),
    socket_max_lifespan: cdktf.numberToTerraform(struct!.socketMaxLifespan),
    stale_channel_flush_ms: cdktf.numberToTerraform(struct!.staleChannelFlushMs),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    tls: sourceInputTcpTlsToTerraform(struct!.tls),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function sourceInputTcpToHclTerraform(struct?: SourceInputTcp | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    auth_type: {
      value: cdktf.stringToHclTerraform(struct!.authType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    breaker_rulesets: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.breakerRulesets),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    connections: {
      value: cdktf.listMapperHcl(sourceInputTcpConnectionsToHclTerraform, false)(struct!.connections),
      isBlock: true,
      type: "list",
      storageClassType: "SourceInputTcpConnectionsList",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    enable_header: {
      value: cdktf.booleanToHclTerraform(struct!.enableHeader),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    enable_proxy_header: {
      value: cdktf.booleanToHclTerraform(struct!.enableProxyHeader),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    host: {
      value: cdktf.stringToHclTerraform(struct!.host),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ip_whitelist_regex: {
      value: cdktf.stringToHclTerraform(struct!.ipWhitelistRegex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_active_cxn: {
      value: cdktf.numberToHclTerraform(struct!.maxActiveCxn),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    metadata: {
      value: cdktf.listMapperHcl(sourceInputTcpMetadataToHclTerraform, false)(struct!.metadata),
      isBlock: true,
      type: "list",
      storageClassType: "SourceInputTcpMetadataList",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    pq: {
      value: sourceInputTcpPqToHclTerraform(struct!.pq),
      isBlock: true,
      type: "struct",
      storageClassType: "SourceInputTcpPq",
    },
    pq_enabled: {
      value: cdktf.booleanToHclTerraform(struct!.pqEnabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    preprocess: {
      value: sourceInputTcpPreprocessToHclTerraform(struct!.preprocess),
      isBlock: true,
      type: "struct",
      storageClassType: "SourceInputTcpPreprocess",
    },
    send_to_routes: {
      value: cdktf.booleanToHclTerraform(struct!.sendToRoutes),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    socket_ending_max_wait: {
      value: cdktf.numberToHclTerraform(struct!.socketEndingMaxWait),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    socket_idle_timeout: {
      value: cdktf.numberToHclTerraform(struct!.socketIdleTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    socket_max_lifespan: {
      value: cdktf.numberToHclTerraform(struct!.socketMaxLifespan),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    stale_channel_flush_ms: {
      value: cdktf.numberToHclTerraform(struct!.staleChannelFlushMs),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    tls: {
      value: sourceInputTcpTlsToHclTerraform(struct!.tls),
      isBlock: true,
      type: "struct",
      storageClassType: "SourceInputTcpTls",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputTcpOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SourceInputTcp | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._authType !== undefined) {
      hasAnyValues = true;
      internalValueResult.authType = this._authType;
    }
    if (this._breakerRulesets !== undefined) {
      hasAnyValues = true;
      internalValueResult.breakerRulesets = this._breakerRulesets;
    }
    if (this._connections?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.connections = this._connections?.internalValue;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._enableHeader !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableHeader = this._enableHeader;
    }
    if (this._enableProxyHeader !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableProxyHeader = this._enableProxyHeader;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._host !== undefined) {
      hasAnyValues = true;
      internalValueResult.host = this._host;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._ipWhitelistRegex !== undefined) {
      hasAnyValues = true;
      internalValueResult.ipWhitelistRegex = this._ipWhitelistRegex;
    }
    if (this._maxActiveCxn !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxActiveCxn = this._maxActiveCxn;
    }
    if (this._metadata?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadata = this._metadata?.internalValue;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._pq?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pq = this._pq?.internalValue;
    }
    if (this._pqEnabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqEnabled = this._pqEnabled;
    }
    if (this._preprocess?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.preprocess = this._preprocess?.internalValue;
    }
    if (this._sendToRoutes !== undefined) {
      hasAnyValues = true;
      internalValueResult.sendToRoutes = this._sendToRoutes;
    }
    if (this._socketEndingMaxWait !== undefined) {
      hasAnyValues = true;
      internalValueResult.socketEndingMaxWait = this._socketEndingMaxWait;
    }
    if (this._socketIdleTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.socketIdleTimeout = this._socketIdleTimeout;
    }
    if (this._socketMaxLifespan !== undefined) {
      hasAnyValues = true;
      internalValueResult.socketMaxLifespan = this._socketMaxLifespan;
    }
    if (this._staleChannelFlushMs !== undefined) {
      hasAnyValues = true;
      internalValueResult.staleChannelFlushMs = this._staleChannelFlushMs;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._tls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tls = this._tls?.internalValue;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputTcp | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._authType = undefined;
      this._breakerRulesets = undefined;
      this._connections.internalValue = undefined;
      this._description = undefined;
      this._disabled = undefined;
      this._enableHeader = undefined;
      this._enableProxyHeader = undefined;
      this._environment = undefined;
      this._host = undefined;
      this._id = undefined;
      this._ipWhitelistRegex = undefined;
      this._maxActiveCxn = undefined;
      this._metadata.internalValue = undefined;
      this._pipeline = undefined;
      this._port = undefined;
      this._pq.internalValue = undefined;
      this._pqEnabled = undefined;
      this._preprocess.internalValue = undefined;
      this._sendToRoutes = undefined;
      this._socketEndingMaxWait = undefined;
      this._socketIdleTimeout = undefined;
      this._socketMaxLifespan = undefined;
      this._staleChannelFlushMs = undefined;
      this._streamtags = undefined;
      this._tls.internalValue = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._authType = value.authType;
      this._breakerRulesets = value.breakerRulesets;
      this._connections.internalValue = value.connections;
      this._description = value.description;
      this._disabled = value.disabled;
      this._enableHeader = value.enableHeader;
      this._enableProxyHeader = value.enableProxyHeader;
      this._environment = value.environment;
      this._host = value.host;
      this._id = value.id;
      this._ipWhitelistRegex = value.ipWhitelistRegex;
      this._maxActiveCxn = value.maxActiveCxn;
      this._metadata.internalValue = value.metadata;
      this._pipeline = value.pipeline;
      this._port = value.port;
      this._pq.internalValue = value.pq;
      this._pqEnabled = value.pqEnabled;
      this._preprocess.internalValue = value.preprocess;
      this._sendToRoutes = value.sendToRoutes;
      this._socketEndingMaxWait = value.socketEndingMaxWait;
      this._socketIdleTimeout = value.socketIdleTimeout;
      this._socketMaxLifespan = value.socketMaxLifespan;
      this._staleChannelFlushMs = value.staleChannelFlushMs;
      this._streamtags = value.streamtags;
      this._tls.internalValue = value.tls;
      this._type = value.type;
    }
  }

  // auth_type - computed: true, optional: true, required: false
  private _authType?: string; 
  public get authType() {
    return this.getStringAttribute('auth_type');
  }
  public set authType(value: string) {
    this._authType = value;
  }
  public resetAuthType() {
    this._authType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authTypeInput() {
    return this._authType;
  }

  // breaker_rulesets - computed: false, optional: true, required: false
  private _breakerRulesets?: string[]; 
  public get breakerRulesets() {
    return this.getListAttribute('breaker_rulesets');
  }
  public set breakerRulesets(value: string[]) {
    this._breakerRulesets = value;
  }
  public resetBreakerRulesets() {
    this._breakerRulesets = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get breakerRulesetsInput() {
    return this._breakerRulesets;
  }

  // connections - computed: false, optional: true, required: false
  private _connections = new SourceInputTcpConnectionsList(this, "connections", false);
  public get connections() {
    return this._connections;
  }
  public putConnections(value: SourceInputTcpConnections[] | cdktf.IResolvable) {
    this._connections.internalValue = value;
  }
  public resetConnections() {
    this._connections.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectionsInput() {
    return this._connections.internalValue;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // enable_header - computed: true, optional: true, required: false
  private _enableHeader?: boolean | cdktf.IResolvable; 
  public get enableHeader() {
    return this.getBooleanAttribute('enable_header');
  }
  public set enableHeader(value: boolean | cdktf.IResolvable) {
    this._enableHeader = value;
  }
  public resetEnableHeader() {
    this._enableHeader = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableHeaderInput() {
    return this._enableHeader;
  }

  // enable_proxy_header - computed: true, optional: true, required: false
  private _enableProxyHeader?: boolean | cdktf.IResolvable; 
  public get enableProxyHeader() {
    return this.getBooleanAttribute('enable_proxy_header');
  }
  public set enableProxyHeader(value: boolean | cdktf.IResolvable) {
    this._enableProxyHeader = value;
  }
  public resetEnableProxyHeader() {
    this._enableProxyHeader = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableProxyHeaderInput() {
    return this._enableProxyHeader;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // host - computed: true, optional: true, required: false
  private _host?: string; 
  public get host() {
    return this.getStringAttribute('host');
  }
  public set host(value: string) {
    this._host = value;
  }
  public resetHost() {
    this._host = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostInput() {
    return this._host;
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // ip_whitelist_regex - computed: true, optional: true, required: false
  private _ipWhitelistRegex?: string; 
  public get ipWhitelistRegex() {
    return this.getStringAttribute('ip_whitelist_regex');
  }
  public set ipWhitelistRegex(value: string) {
    this._ipWhitelistRegex = value;
  }
  public resetIpWhitelistRegex() {
    this._ipWhitelistRegex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ipWhitelistRegexInput() {
    return this._ipWhitelistRegex;
  }

  // max_active_cxn - computed: true, optional: true, required: false
  private _maxActiveCxn?: number; 
  public get maxActiveCxn() {
    return this.getNumberAttribute('max_active_cxn');
  }
  public set maxActiveCxn(value: number) {
    this._maxActiveCxn = value;
  }
  public resetMaxActiveCxn() {
    this._maxActiveCxn = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxActiveCxnInput() {
    return this._maxActiveCxn;
  }

  // metadata - computed: false, optional: true, required: false
  private _metadata = new SourceInputTcpMetadataList(this, "metadata", false);
  public get metadata() {
    return this._metadata;
  }
  public putMetadata(value: SourceInputTcpMetadata[] | cdktf.IResolvable) {
    this._metadata.internalValue = value;
  }
  public resetMetadata() {
    this._metadata.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataInput() {
    return this._metadata.internalValue;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // port - computed: false, optional: false, required: true
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // pq - computed: false, optional: true, required: false
  private _pq = new SourceInputTcpPqOutputReference(this, "pq");
  public get pq() {
    return this._pq;
  }
  public putPq(value: SourceInputTcpPq) {
    this._pq.internalValue = value;
  }
  public resetPq() {
    this._pq.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqInput() {
    return this._pq.internalValue;
  }

  // pq_enabled - computed: true, optional: true, required: false
  private _pqEnabled?: boolean | cdktf.IResolvable; 
  public get pqEnabled() {
    return this.getBooleanAttribute('pq_enabled');
  }
  public set pqEnabled(value: boolean | cdktf.IResolvable) {
    this._pqEnabled = value;
  }
  public resetPqEnabled() {
    this._pqEnabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqEnabledInput() {
    return this._pqEnabled;
  }

  // preprocess - computed: false, optional: true, required: false
  private _preprocess = new SourceInputTcpPreprocessOutputReference(this, "preprocess");
  public get preprocess() {
    return this._preprocess;
  }
  public putPreprocess(value: SourceInputTcpPreprocess) {
    this._preprocess.internalValue = value;
  }
  public resetPreprocess() {
    this._preprocess.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get preprocessInput() {
    return this._preprocess.internalValue;
  }

  // send_to_routes - computed: true, optional: true, required: false
  private _sendToRoutes?: boolean | cdktf.IResolvable; 
  public get sendToRoutes() {
    return this.getBooleanAttribute('send_to_routes');
  }
  public set sendToRoutes(value: boolean | cdktf.IResolvable) {
    this._sendToRoutes = value;
  }
  public resetSendToRoutes() {
    this._sendToRoutes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sendToRoutesInput() {
    return this._sendToRoutes;
  }

  // socket_ending_max_wait - computed: true, optional: true, required: false
  private _socketEndingMaxWait?: number; 
  public get socketEndingMaxWait() {
    return this.getNumberAttribute('socket_ending_max_wait');
  }
  public set socketEndingMaxWait(value: number) {
    this._socketEndingMaxWait = value;
  }
  public resetSocketEndingMaxWait() {
    this._socketEndingMaxWait = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get socketEndingMaxWaitInput() {
    return this._socketEndingMaxWait;
  }

  // socket_idle_timeout - computed: true, optional: true, required: false
  private _socketIdleTimeout?: number; 
  public get socketIdleTimeout() {
    return this.getNumberAttribute('socket_idle_timeout');
  }
  public set socketIdleTimeout(value: number) {
    this._socketIdleTimeout = value;
  }
  public resetSocketIdleTimeout() {
    this._socketIdleTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get socketIdleTimeoutInput() {
    return this._socketIdleTimeout;
  }

  // socket_max_lifespan - computed: true, optional: true, required: false
  private _socketMaxLifespan?: number; 
  public get socketMaxLifespan() {
    return this.getNumberAttribute('socket_max_lifespan');
  }
  public set socketMaxLifespan(value: number) {
    this._socketMaxLifespan = value;
  }
  public resetSocketMaxLifespan() {
    this._socketMaxLifespan = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get socketMaxLifespanInput() {
    return this._socketMaxLifespan;
  }

  // stale_channel_flush_ms - computed: true, optional: true, required: false
  private _staleChannelFlushMs?: number; 
  public get staleChannelFlushMs() {
    return this.getNumberAttribute('stale_channel_flush_ms');
  }
  public set staleChannelFlushMs(value: number) {
    this._staleChannelFlushMs = value;
  }
  public resetStaleChannelFlushMs() {
    this._staleChannelFlushMs = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get staleChannelFlushMsInput() {
    return this._staleChannelFlushMs;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // tls - computed: false, optional: true, required: false
  private _tls = new SourceInputTcpTlsOutputReference(this, "tls");
  public get tls() {
    return this._tls;
  }
  public putTls(value: SourceInputTcpTls) {
    this._tls.internalValue = value;
  }
  public resetTls() {
    this._tls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsInput() {
    return this._tls.internalValue;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface SourceInputTcpjsonConnections {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#output Source#output}
  */
  readonly output: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#pipeline Source#pipeline}
  */
  readonly pipeline?: string;
}

export function sourceInputTcpjsonConnectionsToTerraform(struct?: SourceInputTcpjsonConnections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    output: cdktf.stringToTerraform(struct!.output),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
  }
}


export function sourceInputTcpjsonConnectionsToHclTerraform(struct?: SourceInputTcpjsonConnections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    output: {
      value: cdktf.stringToHclTerraform(struct!.output),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputTcpjsonConnectionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): SourceInputTcpjsonConnections | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._output !== undefined) {
      hasAnyValues = true;
      internalValueResult.output = this._output;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputTcpjsonConnections | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._output = undefined;
      this._pipeline = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._output = value.output;
      this._pipeline = value.pipeline;
    }
  }

  // output - computed: false, optional: false, required: true
  private _output?: string; 
  public get output() {
    return this.getStringAttribute('output');
  }
  public set output(value: string) {
    this._output = value;
  }
  // Temporarily expose input value. Use with caution.
  public get outputInput() {
    return this._output;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }
}

export class SourceInputTcpjsonConnectionsList extends cdktf.ComplexList {
  public internalValue? : SourceInputTcpjsonConnections[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): SourceInputTcpjsonConnectionsOutputReference {
    return new SourceInputTcpjsonConnectionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface SourceInputTcpjsonMetadata {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#name Source#name}
  */
  readonly name: string;
  /**
  * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#value Source#value}
  */
  readonly value: string;
}

export function sourceInputTcpjsonMetadataToTerraform(struct?: SourceInputTcpjsonMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function sourceInputTcpjsonMetadataToHclTerraform(struct?: SourceInputTcpjsonMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputTcpjsonMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): SourceInputTcpjsonMetadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputTcpjsonMetadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class SourceInputTcpjsonMetadataList extends cdktf.ComplexList {
  public internalValue? : SourceInputTcpjsonMetadata[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): SourceInputTcpjsonMetadataOutputReference {
    return new SourceInputTcpjsonMetadataOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface SourceInputTcpjsonPq {
  /**
  * The number of events to send downstream before committing that Stream has read them. Default: 42
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#commit_frequency Source#commit_frequency}
  */
  readonly commitFrequency?: number;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#compress Source#compress}
  */
  readonly compress?: string;
  /**
  * The maximum number of events to hold in memory before writing the events to disk. Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_buffer_size Source#max_buffer_size}
  */
  readonly maxBufferSize?: number;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc. Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_file_size Source#max_file_size}
  */
  readonly maxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_size Source#max_size}
  */
  readonly maxSize?: string;
  /**
  * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine. Default: "always"; must be one of ["smart", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#mode Source#mode}
  */
  readonly mode?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#path Source#path}
  */
  readonly path?: string;
}

export function sourceInputTcpjsonPqToTerraform(struct?: SourceInputTcpjsonPq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    commit_frequency: cdktf.numberToTerraform(struct!.commitFrequency),
    compress: cdktf.stringToTerraform(struct!.compress),
    max_buffer_size: cdktf.numberToTerraform(struct!.maxBufferSize),
    max_file_size: cdktf.stringToTerraform(struct!.maxFileSize),
    max_size: cdktf.stringToTerraform(struct!.maxSize),
    mode: cdktf.stringToTerraform(struct!.mode),
    path: cdktf.stringToTerraform(struct!.path),
  }
}


export function sourceInputTcpjsonPqToHclTerraform(struct?: SourceInputTcpjsonPq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    commit_frequency: {
      value: cdktf.numberToHclTerraform(struct!.commitFrequency),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    compress: {
      value: cdktf.stringToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_buffer_size: {
      value: cdktf.numberToHclTerraform(struct!.maxBufferSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.maxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_size: {
      value: cdktf.stringToHclTerraform(struct!.maxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputTcpjsonPqOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SourceInputTcpjsonPq | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._commitFrequency !== undefined) {
      hasAnyValues = true;
      internalValueResult.commitFrequency = this._commitFrequency;
    }
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._maxBufferSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBufferSize = this._maxBufferSize;
    }
    if (this._maxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxFileSize = this._maxFileSize;
    }
    if (this._maxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxSize = this._maxSize;
    }
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputTcpjsonPq | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._commitFrequency = undefined;
      this._compress = undefined;
      this._maxBufferSize = undefined;
      this._maxFileSize = undefined;
      this._maxSize = undefined;
      this._mode = undefined;
      this._path = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._commitFrequency = value.commitFrequency;
      this._compress = value.compress;
      this._maxBufferSize = value.maxBufferSize;
      this._maxFileSize = value.maxFileSize;
      this._maxSize = value.maxSize;
      this._mode = value.mode;
      this._path = value.path;
    }
  }

  // commit_frequency - computed: true, optional: true, required: false
  private _commitFrequency?: number; 
  public get commitFrequency() {
    return this.getNumberAttribute('commit_frequency');
  }
  public set commitFrequency(value: number) {
    this._commitFrequency = value;
  }
  public resetCommitFrequency() {
    this._commitFrequency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commitFrequencyInput() {
    return this._commitFrequency;
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: string; 
  public get compress() {
    return this.getStringAttribute('compress');
  }
  public set compress(value: string) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // max_buffer_size - computed: true, optional: true, required: false
  private _maxBufferSize?: number; 
  public get maxBufferSize() {
    return this.getNumberAttribute('max_buffer_size');
  }
  public set maxBufferSize(value: number) {
    this._maxBufferSize = value;
  }
  public resetMaxBufferSize() {
    this._maxBufferSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBufferSizeInput() {
    return this._maxBufferSize;
  }

  // max_file_size - computed: true, optional: true, required: false
  private _maxFileSize?: string; 
  public get maxFileSize() {
    return this.getStringAttribute('max_file_size');
  }
  public set maxFileSize(value: string) {
    this._maxFileSize = value;
  }
  public resetMaxFileSize() {
    this._maxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxFileSizeInput() {
    return this._maxFileSize;
  }

  // max_size - computed: true, optional: true, required: false
  private _maxSize?: string; 
  public get maxSize() {
    return this.getStringAttribute('max_size');
  }
  public set maxSize(value: string) {
    this._maxSize = value;
  }
  public resetMaxSize() {
    this._maxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxSizeInput() {
    return this._maxSize;
  }

  // mode - computed: true, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // path - computed: true, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }
}
export interface SourceInputTcpjsonTls {
  /**
  * Path on server containing CA certificates to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#ca_path Source#ca_path}
  */
  readonly caPath?: string;
  /**
  * Path on server containing certificates to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#cert_path Source#cert_path}
  */
  readonly certPath?: string;
  /**
  * The name of the predefined certificate
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#certificate_name Source#certificate_name}
  */
  readonly certificateName?: string;
  /**
  * Parsed as JSON.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#common_name_regex Source#common_name_regex}
  */
  readonly commonNameRegex?: string;
  /**
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#disabled Source#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_version Source#max_version}
  */
  readonly maxVersion?: string;
  /**
  * must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#min_version Source#min_version}
  */
  readonly minVersion?: string;
  /**
  * Passphrase to use to decrypt private key
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#passphrase Source#passphrase}
  */
  readonly passphrase?: string;
  /**
  * Path on server containing the private key to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#priv_key_path Source#priv_key_path}
  */
  readonly privKeyPath?: string;
  /**
  * Parsed as JSON.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#reject_unauthorized Source#reject_unauthorized}
  */
  readonly rejectUnauthorized?: string;
  /**
  * Require clients to present their certificates. Used to perform client authentication using SSL certs. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#request_cert Source#request_cert}
  */
  readonly requestCert?: boolean | cdktf.IResolvable;
}

export function sourceInputTcpjsonTlsToTerraform(struct?: SourceInputTcpjsonTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ca_path: cdktf.stringToTerraform(struct!.caPath),
    cert_path: cdktf.stringToTerraform(struct!.certPath),
    certificate_name: cdktf.stringToTerraform(struct!.certificateName),
    common_name_regex: cdktf.stringToTerraform(struct!.commonNameRegex),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    max_version: cdktf.stringToTerraform(struct!.maxVersion),
    min_version: cdktf.stringToTerraform(struct!.minVersion),
    passphrase: cdktf.stringToTerraform(struct!.passphrase),
    priv_key_path: cdktf.stringToTerraform(struct!.privKeyPath),
    reject_unauthorized: cdktf.stringToTerraform(struct!.rejectUnauthorized),
    request_cert: cdktf.booleanToTerraform(struct!.requestCert),
  }
}


export function sourceInputTcpjsonTlsToHclTerraform(struct?: SourceInputTcpjsonTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ca_path: {
      value: cdktf.stringToHclTerraform(struct!.caPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    cert_path: {
      value: cdktf.stringToHclTerraform(struct!.certPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    certificate_name: {
      value: cdktf.stringToHclTerraform(struct!.certificateName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    common_name_regex: {
      value: cdktf.stringToHclTerraform(struct!.commonNameRegex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    max_version: {
      value: cdktf.stringToHclTerraform(struct!.maxVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    min_version: {
      value: cdktf.stringToHclTerraform(struct!.minVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    passphrase: {
      value: cdktf.stringToHclTerraform(struct!.passphrase),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    priv_key_path: {
      value: cdktf.stringToHclTerraform(struct!.privKeyPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reject_unauthorized: {
      value: cdktf.stringToHclTerraform(struct!.rejectUnauthorized),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    request_cert: {
      value: cdktf.booleanToHclTerraform(struct!.requestCert),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputTcpjsonTlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SourceInputTcpjsonTls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._caPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.caPath = this._caPath;
    }
    if (this._certPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.certPath = this._certPath;
    }
    if (this._certificateName !== undefined) {
      hasAnyValues = true;
      internalValueResult.certificateName = this._certificateName;
    }
    if (this._commonNameRegex !== undefined) {
      hasAnyValues = true;
      internalValueResult.commonNameRegex = this._commonNameRegex;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._maxVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxVersion = this._maxVersion;
    }
    if (this._minVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.minVersion = this._minVersion;
    }
    if (this._passphrase !== undefined) {
      hasAnyValues = true;
      internalValueResult.passphrase = this._passphrase;
    }
    if (this._privKeyPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.privKeyPath = this._privKeyPath;
    }
    if (this._rejectUnauthorized !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectUnauthorized = this._rejectUnauthorized;
    }
    if (this._requestCert !== undefined) {
      hasAnyValues = true;
      internalValueResult.requestCert = this._requestCert;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputTcpjsonTls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._caPath = undefined;
      this._certPath = undefined;
      this._certificateName = undefined;
      this._commonNameRegex = undefined;
      this._disabled = undefined;
      this._maxVersion = undefined;
      this._minVersion = undefined;
      this._passphrase = undefined;
      this._privKeyPath = undefined;
      this._rejectUnauthorized = undefined;
      this._requestCert = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._caPath = value.caPath;
      this._certPath = value.certPath;
      this._certificateName = value.certificateName;
      this._commonNameRegex = value.commonNameRegex;
      this._disabled = value.disabled;
      this._maxVersion = value.maxVersion;
      this._minVersion = value.minVersion;
      this._passphrase = value.passphrase;
      this._privKeyPath = value.privKeyPath;
      this._rejectUnauthorized = value.rejectUnauthorized;
      this._requestCert = value.requestCert;
    }
  }

  // ca_path - computed: false, optional: true, required: false
  private _caPath?: string; 
  public get caPath() {
    return this.getStringAttribute('ca_path');
  }
  public set caPath(value: string) {
    this._caPath = value;
  }
  public resetCaPath() {
    this._caPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get caPathInput() {
    return this._caPath;
  }

  // cert_path - computed: false, optional: true, required: false
  private _certPath?: string; 
  public get certPath() {
    return this.getStringAttribute('cert_path');
  }
  public set certPath(value: string) {
    this._certPath = value;
  }
  public resetCertPath() {
    this._certPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certPathInput() {
    return this._certPath;
  }

  // certificate_name - computed: false, optional: true, required: false
  private _certificateName?: string; 
  public get certificateName() {
    return this.getStringAttribute('certificate_name');
  }
  public set certificateName(value: string) {
    this._certificateName = value;
  }
  public resetCertificateName() {
    this._certificateName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certificateNameInput() {
    return this._certificateName;
  }

  // common_name_regex - computed: false, optional: true, required: false
  private _commonNameRegex?: string; 
  public get commonNameRegex() {
    return this.getStringAttribute('common_name_regex');
  }
  public set commonNameRegex(value: string) {
    this._commonNameRegex = value;
  }
  public resetCommonNameRegex() {
    this._commonNameRegex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commonNameRegexInput() {
    return this._commonNameRegex;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // max_version - computed: false, optional: true, required: false
  private _maxVersion?: string; 
  public get maxVersion() {
    return this.getStringAttribute('max_version');
  }
  public set maxVersion(value: string) {
    this._maxVersion = value;
  }
  public resetMaxVersion() {
    this._maxVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxVersionInput() {
    return this._maxVersion;
  }

  // min_version - computed: false, optional: true, required: false
  private _minVersion?: string; 
  public get minVersion() {
    return this.getStringAttribute('min_version');
  }
  public set minVersion(value: string) {
    this._minVersion = value;
  }
  public resetMinVersion() {
    this._minVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get minVersionInput() {
    return this._minVersion;
  }

  // passphrase - computed: false, optional: true, required: false
  private _passphrase?: string; 
  public get passphrase() {
    return this.getStringAttribute('passphrase');
  }
  public set passphrase(value: string) {
    this._passphrase = value;
  }
  public resetPassphrase() {
    this._passphrase = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passphraseInput() {
    return this._passphrase;
  }

  // priv_key_path - computed: false, optional: true, required: false
  private _privKeyPath?: string; 
  public get privKeyPath() {
    return this.getStringAttribute('priv_key_path');
  }
  public set privKeyPath(value: string) {
    this._privKeyPath = value;
  }
  public resetPrivKeyPath() {
    this._privKeyPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get privKeyPathInput() {
    return this._privKeyPath;
  }

  // reject_unauthorized - computed: false, optional: true, required: false
  private _rejectUnauthorized?: string; 
  public get rejectUnauthorized() {
    return this.getStringAttribute('reject_unauthorized');
  }
  public set rejectUnauthorized(value: string) {
    this._rejectUnauthorized = value;
  }
  public resetRejectUnauthorized() {
    this._rejectUnauthorized = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectUnauthorizedInput() {
    return this._rejectUnauthorized;
  }

  // request_cert - computed: true, optional: true, required: false
  private _requestCert?: boolean | cdktf.IResolvable; 
  public get requestCert() {
    return this.getBooleanAttribute('request_cert');
  }
  public set requestCert(value: boolean | cdktf.IResolvable) {
    this._requestCert = value;
  }
  public resetRequestCert() {
    this._requestCert = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestCertInput() {
    return this._requestCert;
  }
}
export interface SourceInputTcpjson {
  /**
  * Shared secret to be provided by any client (in authToken header field). If empty, unauthorized access is permitted. Default: ""
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#auth_token Source#auth_token}
  */
  readonly authToken?: string;
  /**
  * Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate. Default: "manual"; must be one of ["manual", "secret"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#auth_type Source#auth_type}
  */
  readonly authType?: string;
  /**
  * Direct connections to Destinations, and optionally via a Pipeline or a Pack
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#connections Source#connections}
  */
  readonly connections?: SourceInputTcpjsonConnections[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#description Source#description}
  */
  readonly description?: string;
  /**
  * Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#disabled Source#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * Load balance traffic across all Worker Processes. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#enable_load_balancing Source#enable_load_balancing}
  */
  readonly enableLoadBalancing?: boolean | cdktf.IResolvable;
  /**
  * Enable if the connection is proxied by a device that supports proxy protocol v1 or v2. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#enable_proxy_header Source#enable_proxy_header}
  */
  readonly enableProxyHeader?: boolean | cdktf.IResolvable;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#environment Source#environment}
  */
  readonly environment?: string;
  /**
  * Address to bind on. Defaults to 0.0.0.0 (all addresses). Default: "0.0.0.0"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#host Source#host}
  */
  readonly host?: string;
  /**
  * Unique ID for this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#id Source#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * Regex matching IP addresses that are allowed to establish a connection. Default: "/.* /"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#ip_whitelist_regex Source#ip_whitelist_regex}
   *
  * Note: The above comment contained a comment block ending sequence (* followed by /). We have introduced a space between to prevent syntax errors. Please ignore the space.
  */
  readonly ipWhitelistRegex?: string;
  /**
  * Maximum number of active connections allowed per Worker Process. Use 0 for unlimited. Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_active_cxn Source#max_active_cxn}
  */
  readonly maxActiveCxn?: number;
  /**
  * Fields to add to events from this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#metadata Source#metadata}
  */
  readonly metadata?: SourceInputTcpjsonMetadata[] | cdktf.IResolvable;
  /**
  * Pipeline to process data from this Source before sending it through the Routes
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#pipeline Source#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Port to listen on
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#port Source#port}
  */
  readonly port: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#pq Source#pq}
  */
  readonly pq?: SourceInputTcpjsonPq;
  /**
  * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers). Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#pq_enabled Source#pq_enabled}
  */
  readonly pqEnabled?: boolean | cdktf.IResolvable;
  /**
  * Select whether to send data to Routes, or directly to Destinations. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#send_to_routes Source#send_to_routes}
  */
  readonly sendToRoutes?: boolean | cdktf.IResolvable;
  /**
  * How long the server will wait after initiating a closure for a client to close its end of the connection. If the client doesn't close the connection within this time, the server will forcefully terminate the socket to prevent resource leaks and ensure efficient connection cleanup and system stability. Leave at 0 for no inactive socket monitoring. Default: 30
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#socket_ending_max_wait Source#socket_ending_max_wait}
  */
  readonly socketEndingMaxWait?: number;
  /**
  * How long @{product} should wait before assuming that an inactive socket has timed out. After this time, the connection will be closed. Leave at 0 for no inactive socket monitoring. Default: 0
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#socket_idle_timeout Source#socket_idle_timeout}
  */
  readonly socketIdleTimeout?: number;
  /**
  * The maximum duration a socket can remain open, even if active. This helps manage resources and mitigate issues caused by TCP pinning. Set to 0 to disable. Default: 0
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#socket_max_lifespan Source#socket_max_lifespan}
  */
  readonly socketMaxLifespan?: number;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#streamtags Source#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Select or create a stored text secret
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#text_secret Source#text_secret}
  */
  readonly textSecret?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#tls Source#tls}
  */
  readonly tls?: SourceInputTcpjsonTls;
  /**
  * must be "tcpjson"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#type Source#type}
  */
  readonly type?: string;
}

export function sourceInputTcpjsonToTerraform(struct?: SourceInputTcpjson | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    auth_token: cdktf.stringToTerraform(struct!.authToken),
    auth_type: cdktf.stringToTerraform(struct!.authType),
    connections: cdktf.listMapper(sourceInputTcpjsonConnectionsToTerraform, false)(struct!.connections),
    description: cdktf.stringToTerraform(struct!.description),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    enable_load_balancing: cdktf.booleanToTerraform(struct!.enableLoadBalancing),
    enable_proxy_header: cdktf.booleanToTerraform(struct!.enableProxyHeader),
    environment: cdktf.stringToTerraform(struct!.environment),
    host: cdktf.stringToTerraform(struct!.host),
    id: cdktf.stringToTerraform(struct!.id),
    ip_whitelist_regex: cdktf.stringToTerraform(struct!.ipWhitelistRegex),
    max_active_cxn: cdktf.numberToTerraform(struct!.maxActiveCxn),
    metadata: cdktf.listMapper(sourceInputTcpjsonMetadataToTerraform, false)(struct!.metadata),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    port: cdktf.numberToTerraform(struct!.port),
    pq: sourceInputTcpjsonPqToTerraform(struct!.pq),
    pq_enabled: cdktf.booleanToTerraform(struct!.pqEnabled),
    send_to_routes: cdktf.booleanToTerraform(struct!.sendToRoutes),
    socket_ending_max_wait: cdktf.numberToTerraform(struct!.socketEndingMaxWait),
    socket_idle_timeout: cdktf.numberToTerraform(struct!.socketIdleTimeout),
    socket_max_lifespan: cdktf.numberToTerraform(struct!.socketMaxLifespan),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    text_secret: cdktf.stringToTerraform(struct!.textSecret),
    tls: sourceInputTcpjsonTlsToTerraform(struct!.tls),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function sourceInputTcpjsonToHclTerraform(struct?: SourceInputTcpjson | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    auth_token: {
      value: cdktf.stringToHclTerraform(struct!.authToken),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    auth_type: {
      value: cdktf.stringToHclTerraform(struct!.authType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    connections: {
      value: cdktf.listMapperHcl(sourceInputTcpjsonConnectionsToHclTerraform, false)(struct!.connections),
      isBlock: true,
      type: "list",
      storageClassType: "SourceInputTcpjsonConnectionsList",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    enable_load_balancing: {
      value: cdktf.booleanToHclTerraform(struct!.enableLoadBalancing),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    enable_proxy_header: {
      value: cdktf.booleanToHclTerraform(struct!.enableProxyHeader),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    host: {
      value: cdktf.stringToHclTerraform(struct!.host),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ip_whitelist_regex: {
      value: cdktf.stringToHclTerraform(struct!.ipWhitelistRegex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_active_cxn: {
      value: cdktf.numberToHclTerraform(struct!.maxActiveCxn),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    metadata: {
      value: cdktf.listMapperHcl(sourceInputTcpjsonMetadataToHclTerraform, false)(struct!.metadata),
      isBlock: true,
      type: "list",
      storageClassType: "SourceInputTcpjsonMetadataList",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    pq: {
      value: sourceInputTcpjsonPqToHclTerraform(struct!.pq),
      isBlock: true,
      type: "struct",
      storageClassType: "SourceInputTcpjsonPq",
    },
    pq_enabled: {
      value: cdktf.booleanToHclTerraform(struct!.pqEnabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    send_to_routes: {
      value: cdktf.booleanToHclTerraform(struct!.sendToRoutes),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    socket_ending_max_wait: {
      value: cdktf.numberToHclTerraform(struct!.socketEndingMaxWait),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    socket_idle_timeout: {
      value: cdktf.numberToHclTerraform(struct!.socketIdleTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    socket_max_lifespan: {
      value: cdktf.numberToHclTerraform(struct!.socketMaxLifespan),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    text_secret: {
      value: cdktf.stringToHclTerraform(struct!.textSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    tls: {
      value: sourceInputTcpjsonTlsToHclTerraform(struct!.tls),
      isBlock: true,
      type: "struct",
      storageClassType: "SourceInputTcpjsonTls",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputTcpjsonOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SourceInputTcpjson | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._authToken !== undefined) {
      hasAnyValues = true;
      internalValueResult.authToken = this._authToken;
    }
    if (this._authType !== undefined) {
      hasAnyValues = true;
      internalValueResult.authType = this._authType;
    }
    if (this._connections?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.connections = this._connections?.internalValue;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._enableLoadBalancing !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableLoadBalancing = this._enableLoadBalancing;
    }
    if (this._enableProxyHeader !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableProxyHeader = this._enableProxyHeader;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._host !== undefined) {
      hasAnyValues = true;
      internalValueResult.host = this._host;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._ipWhitelistRegex !== undefined) {
      hasAnyValues = true;
      internalValueResult.ipWhitelistRegex = this._ipWhitelistRegex;
    }
    if (this._maxActiveCxn !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxActiveCxn = this._maxActiveCxn;
    }
    if (this._metadata?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadata = this._metadata?.internalValue;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._pq?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pq = this._pq?.internalValue;
    }
    if (this._pqEnabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqEnabled = this._pqEnabled;
    }
    if (this._sendToRoutes !== undefined) {
      hasAnyValues = true;
      internalValueResult.sendToRoutes = this._sendToRoutes;
    }
    if (this._socketEndingMaxWait !== undefined) {
      hasAnyValues = true;
      internalValueResult.socketEndingMaxWait = this._socketEndingMaxWait;
    }
    if (this._socketIdleTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.socketIdleTimeout = this._socketIdleTimeout;
    }
    if (this._socketMaxLifespan !== undefined) {
      hasAnyValues = true;
      internalValueResult.socketMaxLifespan = this._socketMaxLifespan;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._textSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.textSecret = this._textSecret;
    }
    if (this._tls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tls = this._tls?.internalValue;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputTcpjson | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._authToken = undefined;
      this._authType = undefined;
      this._connections.internalValue = undefined;
      this._description = undefined;
      this._disabled = undefined;
      this._enableLoadBalancing = undefined;
      this._enableProxyHeader = undefined;
      this._environment = undefined;
      this._host = undefined;
      this._id = undefined;
      this._ipWhitelistRegex = undefined;
      this._maxActiveCxn = undefined;
      this._metadata.internalValue = undefined;
      this._pipeline = undefined;
      this._port = undefined;
      this._pq.internalValue = undefined;
      this._pqEnabled = undefined;
      this._sendToRoutes = undefined;
      this._socketEndingMaxWait = undefined;
      this._socketIdleTimeout = undefined;
      this._socketMaxLifespan = undefined;
      this._streamtags = undefined;
      this._textSecret = undefined;
      this._tls.internalValue = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._authToken = value.authToken;
      this._authType = value.authType;
      this._connections.internalValue = value.connections;
      this._description = value.description;
      this._disabled = value.disabled;
      this._enableLoadBalancing = value.enableLoadBalancing;
      this._enableProxyHeader = value.enableProxyHeader;
      this._environment = value.environment;
      this._host = value.host;
      this._id = value.id;
      this._ipWhitelistRegex = value.ipWhitelistRegex;
      this._maxActiveCxn = value.maxActiveCxn;
      this._metadata.internalValue = value.metadata;
      this._pipeline = value.pipeline;
      this._port = value.port;
      this._pq.internalValue = value.pq;
      this._pqEnabled = value.pqEnabled;
      this._sendToRoutes = value.sendToRoutes;
      this._socketEndingMaxWait = value.socketEndingMaxWait;
      this._socketIdleTimeout = value.socketIdleTimeout;
      this._socketMaxLifespan = value.socketMaxLifespan;
      this._streamtags = value.streamtags;
      this._textSecret = value.textSecret;
      this._tls.internalValue = value.tls;
      this._type = value.type;
    }
  }

  // auth_token - computed: true, optional: true, required: false
  private _authToken?: string; 
  public get authToken() {
    return this.getStringAttribute('auth_token');
  }
  public set authToken(value: string) {
    this._authToken = value;
  }
  public resetAuthToken() {
    this._authToken = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authTokenInput() {
    return this._authToken;
  }

  // auth_type - computed: true, optional: true, required: false
  private _authType?: string; 
  public get authType() {
    return this.getStringAttribute('auth_type');
  }
  public set authType(value: string) {
    this._authType = value;
  }
  public resetAuthType() {
    this._authType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authTypeInput() {
    return this._authType;
  }

  // connections - computed: false, optional: true, required: false
  private _connections = new SourceInputTcpjsonConnectionsList(this, "connections", false);
  public get connections() {
    return this._connections;
  }
  public putConnections(value: SourceInputTcpjsonConnections[] | cdktf.IResolvable) {
    this._connections.internalValue = value;
  }
  public resetConnections() {
    this._connections.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectionsInput() {
    return this._connections.internalValue;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // enable_load_balancing - computed: true, optional: true, required: false
  private _enableLoadBalancing?: boolean | cdktf.IResolvable; 
  public get enableLoadBalancing() {
    return this.getBooleanAttribute('enable_load_balancing');
  }
  public set enableLoadBalancing(value: boolean | cdktf.IResolvable) {
    this._enableLoadBalancing = value;
  }
  public resetEnableLoadBalancing() {
    this._enableLoadBalancing = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableLoadBalancingInput() {
    return this._enableLoadBalancing;
  }

  // enable_proxy_header - computed: true, optional: true, required: false
  private _enableProxyHeader?: boolean | cdktf.IResolvable; 
  public get enableProxyHeader() {
    return this.getBooleanAttribute('enable_proxy_header');
  }
  public set enableProxyHeader(value: boolean | cdktf.IResolvable) {
    this._enableProxyHeader = value;
  }
  public resetEnableProxyHeader() {
    this._enableProxyHeader = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableProxyHeaderInput() {
    return this._enableProxyHeader;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // host - computed: true, optional: true, required: false
  private _host?: string; 
  public get host() {
    return this.getStringAttribute('host');
  }
  public set host(value: string) {
    this._host = value;
  }
  public resetHost() {
    this._host = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostInput() {
    return this._host;
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // ip_whitelist_regex - computed: true, optional: true, required: false
  private _ipWhitelistRegex?: string; 
  public get ipWhitelistRegex() {
    return this.getStringAttribute('ip_whitelist_regex');
  }
  public set ipWhitelistRegex(value: string) {
    this._ipWhitelistRegex = value;
  }
  public resetIpWhitelistRegex() {
    this._ipWhitelistRegex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ipWhitelistRegexInput() {
    return this._ipWhitelistRegex;
  }

  // max_active_cxn - computed: true, optional: true, required: false
  private _maxActiveCxn?: number; 
  public get maxActiveCxn() {
    return this.getNumberAttribute('max_active_cxn');
  }
  public set maxActiveCxn(value: number) {
    this._maxActiveCxn = value;
  }
  public resetMaxActiveCxn() {
    this._maxActiveCxn = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxActiveCxnInput() {
    return this._maxActiveCxn;
  }

  // metadata - computed: false, optional: true, required: false
  private _metadata = new SourceInputTcpjsonMetadataList(this, "metadata", false);
  public get metadata() {
    return this._metadata;
  }
  public putMetadata(value: SourceInputTcpjsonMetadata[] | cdktf.IResolvable) {
    this._metadata.internalValue = value;
  }
  public resetMetadata() {
    this._metadata.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataInput() {
    return this._metadata.internalValue;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // port - computed: false, optional: false, required: true
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // pq - computed: false, optional: true, required: false
  private _pq = new SourceInputTcpjsonPqOutputReference(this, "pq");
  public get pq() {
    return this._pq;
  }
  public putPq(value: SourceInputTcpjsonPq) {
    this._pq.internalValue = value;
  }
  public resetPq() {
    this._pq.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqInput() {
    return this._pq.internalValue;
  }

  // pq_enabled - computed: true, optional: true, required: false
  private _pqEnabled?: boolean | cdktf.IResolvable; 
  public get pqEnabled() {
    return this.getBooleanAttribute('pq_enabled');
  }
  public set pqEnabled(value: boolean | cdktf.IResolvable) {
    this._pqEnabled = value;
  }
  public resetPqEnabled() {
    this._pqEnabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqEnabledInput() {
    return this._pqEnabled;
  }

  // send_to_routes - computed: true, optional: true, required: false
  private _sendToRoutes?: boolean | cdktf.IResolvable; 
  public get sendToRoutes() {
    return this.getBooleanAttribute('send_to_routes');
  }
  public set sendToRoutes(value: boolean | cdktf.IResolvable) {
    this._sendToRoutes = value;
  }
  public resetSendToRoutes() {
    this._sendToRoutes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sendToRoutesInput() {
    return this._sendToRoutes;
  }

  // socket_ending_max_wait - computed: true, optional: true, required: false
  private _socketEndingMaxWait?: number; 
  public get socketEndingMaxWait() {
    return this.getNumberAttribute('socket_ending_max_wait');
  }
  public set socketEndingMaxWait(value: number) {
    this._socketEndingMaxWait = value;
  }
  public resetSocketEndingMaxWait() {
    this._socketEndingMaxWait = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get socketEndingMaxWaitInput() {
    return this._socketEndingMaxWait;
  }

  // socket_idle_timeout - computed: true, optional: true, required: false
  private _socketIdleTimeout?: number; 
  public get socketIdleTimeout() {
    return this.getNumberAttribute('socket_idle_timeout');
  }
  public set socketIdleTimeout(value: number) {
    this._socketIdleTimeout = value;
  }
  public resetSocketIdleTimeout() {
    this._socketIdleTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get socketIdleTimeoutInput() {
    return this._socketIdleTimeout;
  }

  // socket_max_lifespan - computed: true, optional: true, required: false
  private _socketMaxLifespan?: number; 
  public get socketMaxLifespan() {
    return this.getNumberAttribute('socket_max_lifespan');
  }
  public set socketMaxLifespan(value: number) {
    this._socketMaxLifespan = value;
  }
  public resetSocketMaxLifespan() {
    this._socketMaxLifespan = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get socketMaxLifespanInput() {
    return this._socketMaxLifespan;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // text_secret - computed: false, optional: true, required: false
  private _textSecret?: string; 
  public get textSecret() {
    return this.getStringAttribute('text_secret');
  }
  public set textSecret(value: string) {
    this._textSecret = value;
  }
  public resetTextSecret() {
    this._textSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get textSecretInput() {
    return this._textSecret;
  }

  // tls - computed: false, optional: true, required: false
  private _tls = new SourceInputTcpjsonTlsOutputReference(this, "tls");
  public get tls() {
    return this._tls;
  }
  public putTls(value: SourceInputTcpjsonTls) {
    this._tls.internalValue = value;
  }
  public resetTls() {
    this._tls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsInput() {
    return this._tls.internalValue;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface SourceInputWefConnections {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#output Source#output}
  */
  readonly output: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#pipeline Source#pipeline}
  */
  readonly pipeline?: string;
}

export function sourceInputWefConnectionsToTerraform(struct?: SourceInputWefConnections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    output: cdktf.stringToTerraform(struct!.output),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
  }
}


export function sourceInputWefConnectionsToHclTerraform(struct?: SourceInputWefConnections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    output: {
      value: cdktf.stringToHclTerraform(struct!.output),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputWefConnectionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): SourceInputWefConnections | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._output !== undefined) {
      hasAnyValues = true;
      internalValueResult.output = this._output;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputWefConnections | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._output = undefined;
      this._pipeline = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._output = value.output;
      this._pipeline = value.pipeline;
    }
  }

  // output - computed: false, optional: false, required: true
  private _output?: string; 
  public get output() {
    return this.getStringAttribute('output');
  }
  public set output(value: string) {
    this._output = value;
  }
  // Temporarily expose input value. Use with caution.
  public get outputInput() {
    return this._output;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }
}

export class SourceInputWefConnectionsList extends cdktf.ComplexList {
  public internalValue? : SourceInputWefConnections[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): SourceInputWefConnectionsOutputReference {
    return new SourceInputWefConnectionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface SourceInputWefMetadata {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#name Source#name}
  */
  readonly name: string;
  /**
  * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#value Source#value}
  */
  readonly value: string;
}

export function sourceInputWefMetadataToTerraform(struct?: SourceInputWefMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function sourceInputWefMetadataToHclTerraform(struct?: SourceInputWefMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputWefMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): SourceInputWefMetadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputWefMetadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class SourceInputWefMetadataList extends cdktf.ComplexList {
  public internalValue? : SourceInputWefMetadata[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): SourceInputWefMetadataOutputReference {
    return new SourceInputWefMetadataOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface SourceInputWefPq {
  /**
  * The number of events to send downstream before committing that Stream has read them. Default: 42
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#commit_frequency Source#commit_frequency}
  */
  readonly commitFrequency?: number;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#compress Source#compress}
  */
  readonly compress?: string;
  /**
  * The maximum number of events to hold in memory before writing the events to disk. Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_buffer_size Source#max_buffer_size}
  */
  readonly maxBufferSize?: number;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc. Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_file_size Source#max_file_size}
  */
  readonly maxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_size Source#max_size}
  */
  readonly maxSize?: string;
  /**
  * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine. Default: "always"; must be one of ["smart", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#mode Source#mode}
  */
  readonly mode?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#path Source#path}
  */
  readonly path?: string;
}

export function sourceInputWefPqToTerraform(struct?: SourceInputWefPq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    commit_frequency: cdktf.numberToTerraform(struct!.commitFrequency),
    compress: cdktf.stringToTerraform(struct!.compress),
    max_buffer_size: cdktf.numberToTerraform(struct!.maxBufferSize),
    max_file_size: cdktf.stringToTerraform(struct!.maxFileSize),
    max_size: cdktf.stringToTerraform(struct!.maxSize),
    mode: cdktf.stringToTerraform(struct!.mode),
    path: cdktf.stringToTerraform(struct!.path),
  }
}


export function sourceInputWefPqToHclTerraform(struct?: SourceInputWefPq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    commit_frequency: {
      value: cdktf.numberToHclTerraform(struct!.commitFrequency),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    compress: {
      value: cdktf.stringToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_buffer_size: {
      value: cdktf.numberToHclTerraform(struct!.maxBufferSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.maxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_size: {
      value: cdktf.stringToHclTerraform(struct!.maxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputWefPqOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SourceInputWefPq | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._commitFrequency !== undefined) {
      hasAnyValues = true;
      internalValueResult.commitFrequency = this._commitFrequency;
    }
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._maxBufferSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBufferSize = this._maxBufferSize;
    }
    if (this._maxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxFileSize = this._maxFileSize;
    }
    if (this._maxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxSize = this._maxSize;
    }
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputWefPq | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._commitFrequency = undefined;
      this._compress = undefined;
      this._maxBufferSize = undefined;
      this._maxFileSize = undefined;
      this._maxSize = undefined;
      this._mode = undefined;
      this._path = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._commitFrequency = value.commitFrequency;
      this._compress = value.compress;
      this._maxBufferSize = value.maxBufferSize;
      this._maxFileSize = value.maxFileSize;
      this._maxSize = value.maxSize;
      this._mode = value.mode;
      this._path = value.path;
    }
  }

  // commit_frequency - computed: true, optional: true, required: false
  private _commitFrequency?: number; 
  public get commitFrequency() {
    return this.getNumberAttribute('commit_frequency');
  }
  public set commitFrequency(value: number) {
    this._commitFrequency = value;
  }
  public resetCommitFrequency() {
    this._commitFrequency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commitFrequencyInput() {
    return this._commitFrequency;
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: string; 
  public get compress() {
    return this.getStringAttribute('compress');
  }
  public set compress(value: string) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // max_buffer_size - computed: true, optional: true, required: false
  private _maxBufferSize?: number; 
  public get maxBufferSize() {
    return this.getNumberAttribute('max_buffer_size');
  }
  public set maxBufferSize(value: number) {
    this._maxBufferSize = value;
  }
  public resetMaxBufferSize() {
    this._maxBufferSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBufferSizeInput() {
    return this._maxBufferSize;
  }

  // max_file_size - computed: true, optional: true, required: false
  private _maxFileSize?: string; 
  public get maxFileSize() {
    return this.getStringAttribute('max_file_size');
  }
  public set maxFileSize(value: string) {
    this._maxFileSize = value;
  }
  public resetMaxFileSize() {
    this._maxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxFileSizeInput() {
    return this._maxFileSize;
  }

  // max_size - computed: true, optional: true, required: false
  private _maxSize?: string; 
  public get maxSize() {
    return this.getStringAttribute('max_size');
  }
  public set maxSize(value: string) {
    this._maxSize = value;
  }
  public resetMaxSize() {
    this._maxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxSizeInput() {
    return this._maxSize;
  }

  // mode - computed: true, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // path - computed: true, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }
}
export interface SourceInputWefSubscriptionsMetadata {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#name Source#name}
  */
  readonly name: string;
  /**
  * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#value Source#value}
  */
  readonly value: string;
}

export function sourceInputWefSubscriptionsMetadataToTerraform(struct?: SourceInputWefSubscriptionsMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function sourceInputWefSubscriptionsMetadataToHclTerraform(struct?: SourceInputWefSubscriptionsMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputWefSubscriptionsMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): SourceInputWefSubscriptionsMetadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputWefSubscriptionsMetadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class SourceInputWefSubscriptionsMetadataList extends cdktf.ComplexList {
  public internalValue? : SourceInputWefSubscriptionsMetadata[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): SourceInputWefSubscriptionsMetadataOutputReference {
    return new SourceInputWefSubscriptionsMetadataOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface SourceInputWefSubscriptions {
  /**
  * Interval (in seconds) over which the endpoint should collect events before sending them to Stream. Default: 60
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#batch_timeout Source#batch_timeout}
  */
  readonly batchTimeout?: number;
  /**
  * Receive compressed events from the source. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#compress Source#compress}
  */
  readonly compress?: boolean | cdktf.IResolvable;
  /**
  * Content format in which the endpoint should deliver events. Default: "Raw"; must be one of ["Raw", "RenderedText"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#content_format Source#content_format}
  */
  readonly contentFormat?: string;
  /**
  * Maximum time (in seconds) between endpoint checkins before considering it unavailable. Default: 60
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#heartbeat_interval Source#heartbeat_interval}
  */
  readonly heartbeatInterval?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#id Source#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id: string;
  /**
  * The RFC-3066 locale the Windows clients should use when sending events. Defaults to "en-US". Default: "en-US"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#locale Source#locale}
  */
  readonly locale?: string;
  /**
  * Fields to add to events ingested under this subscription
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#metadata Source#metadata}
  */
  readonly metadata?: SourceInputWefSubscriptionsMetadata[] | cdktf.IResolvable;
  /**
  * Default: "simple"; must be one of ["simple", "xml"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#query_selector Source#query_selector}
  */
  readonly querySelector?: string;
  /**
  * Newly subscribed endpoints will send previously existing events. Disable to receive new events only. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#read_existing_events Source#read_existing_events}
  */
  readonly readExistingEvents?: boolean | cdktf.IResolvable;
  /**
  * Keep track of which events have been received, resuming from that point after a re-subscription. This setting takes precedence over 'Read existing events'. See [Cribl Docs](https://docs.cribl.io/stream/sources-wef/#subscriptions) for more details. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#send_bookmarks Source#send_bookmarks}
  */
  readonly sendBookmarks?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#subscription_name Source#subscription_name}
  */
  readonly subscriptionName: string;
  /**
  * The DNS names of the endpoints that should forward these events. You may use wildcards, such as *.mydomain.com. Default: ["*"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#targets Source#targets}
  */
  readonly targets?: string[];
  /**
  * Version UUID for this subscription. If any subscription parameters are modified, this value will change.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#version Source#version}
  */
  readonly version?: string;
}

export function sourceInputWefSubscriptionsToTerraform(struct?: SourceInputWefSubscriptions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    batch_timeout: cdktf.numberToTerraform(struct!.batchTimeout),
    compress: cdktf.booleanToTerraform(struct!.compress),
    content_format: cdktf.stringToTerraform(struct!.contentFormat),
    heartbeat_interval: cdktf.numberToTerraform(struct!.heartbeatInterval),
    id: cdktf.stringToTerraform(struct!.id),
    locale: cdktf.stringToTerraform(struct!.locale),
    metadata: cdktf.listMapper(sourceInputWefSubscriptionsMetadataToTerraform, false)(struct!.metadata),
    query_selector: cdktf.stringToTerraform(struct!.querySelector),
    read_existing_events: cdktf.booleanToTerraform(struct!.readExistingEvents),
    send_bookmarks: cdktf.booleanToTerraform(struct!.sendBookmarks),
    subscription_name: cdktf.stringToTerraform(struct!.subscriptionName),
    targets: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.targets),
    version: cdktf.stringToTerraform(struct!.version),
  }
}


export function sourceInputWefSubscriptionsToHclTerraform(struct?: SourceInputWefSubscriptions | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    batch_timeout: {
      value: cdktf.numberToHclTerraform(struct!.batchTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    compress: {
      value: cdktf.booleanToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    content_format: {
      value: cdktf.stringToHclTerraform(struct!.contentFormat),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    heartbeat_interval: {
      value: cdktf.numberToHclTerraform(struct!.heartbeatInterval),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    locale: {
      value: cdktf.stringToHclTerraform(struct!.locale),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    metadata: {
      value: cdktf.listMapperHcl(sourceInputWefSubscriptionsMetadataToHclTerraform, false)(struct!.metadata),
      isBlock: true,
      type: "list",
      storageClassType: "SourceInputWefSubscriptionsMetadataList",
    },
    query_selector: {
      value: cdktf.stringToHclTerraform(struct!.querySelector),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    read_existing_events: {
      value: cdktf.booleanToHclTerraform(struct!.readExistingEvents),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    send_bookmarks: {
      value: cdktf.booleanToHclTerraform(struct!.sendBookmarks),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    subscription_name: {
      value: cdktf.stringToHclTerraform(struct!.subscriptionName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    targets: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.targets),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    version: {
      value: cdktf.stringToHclTerraform(struct!.version),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputWefSubscriptionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): SourceInputWefSubscriptions | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._batchTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.batchTimeout = this._batchTimeout;
    }
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._contentFormat !== undefined) {
      hasAnyValues = true;
      internalValueResult.contentFormat = this._contentFormat;
    }
    if (this._heartbeatInterval !== undefined) {
      hasAnyValues = true;
      internalValueResult.heartbeatInterval = this._heartbeatInterval;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._locale !== undefined) {
      hasAnyValues = true;
      internalValueResult.locale = this._locale;
    }
    if (this._metadata?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadata = this._metadata?.internalValue;
    }
    if (this._querySelector !== undefined) {
      hasAnyValues = true;
      internalValueResult.querySelector = this._querySelector;
    }
    if (this._readExistingEvents !== undefined) {
      hasAnyValues = true;
      internalValueResult.readExistingEvents = this._readExistingEvents;
    }
    if (this._sendBookmarks !== undefined) {
      hasAnyValues = true;
      internalValueResult.sendBookmarks = this._sendBookmarks;
    }
    if (this._subscriptionName !== undefined) {
      hasAnyValues = true;
      internalValueResult.subscriptionName = this._subscriptionName;
    }
    if (this._targets !== undefined) {
      hasAnyValues = true;
      internalValueResult.targets = this._targets;
    }
    if (this._version !== undefined) {
      hasAnyValues = true;
      internalValueResult.version = this._version;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputWefSubscriptions | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._batchTimeout = undefined;
      this._compress = undefined;
      this._contentFormat = undefined;
      this._heartbeatInterval = undefined;
      this._id = undefined;
      this._locale = undefined;
      this._metadata.internalValue = undefined;
      this._querySelector = undefined;
      this._readExistingEvents = undefined;
      this._sendBookmarks = undefined;
      this._subscriptionName = undefined;
      this._targets = undefined;
      this._version = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._batchTimeout = value.batchTimeout;
      this._compress = value.compress;
      this._contentFormat = value.contentFormat;
      this._heartbeatInterval = value.heartbeatInterval;
      this._id = value.id;
      this._locale = value.locale;
      this._metadata.internalValue = value.metadata;
      this._querySelector = value.querySelector;
      this._readExistingEvents = value.readExistingEvents;
      this._sendBookmarks = value.sendBookmarks;
      this._subscriptionName = value.subscriptionName;
      this._targets = value.targets;
      this._version = value.version;
    }
  }

  // batch_timeout - computed: true, optional: true, required: false
  private _batchTimeout?: number; 
  public get batchTimeout() {
    return this.getNumberAttribute('batch_timeout');
  }
  public set batchTimeout(value: number) {
    this._batchTimeout = value;
  }
  public resetBatchTimeout() {
    this._batchTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get batchTimeoutInput() {
    return this._batchTimeout;
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: boolean | cdktf.IResolvable; 
  public get compress() {
    return this.getBooleanAttribute('compress');
  }
  public set compress(value: boolean | cdktf.IResolvable) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // content_format - computed: true, optional: true, required: false
  private _contentFormat?: string; 
  public get contentFormat() {
    return this.getStringAttribute('content_format');
  }
  public set contentFormat(value: string) {
    this._contentFormat = value;
  }
  public resetContentFormat() {
    this._contentFormat = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get contentFormatInput() {
    return this._contentFormat;
  }

  // heartbeat_interval - computed: true, optional: true, required: false
  private _heartbeatInterval?: number; 
  public get heartbeatInterval() {
    return this.getNumberAttribute('heartbeat_interval');
  }
  public set heartbeatInterval(value: number) {
    this._heartbeatInterval = value;
  }
  public resetHeartbeatInterval() {
    this._heartbeatInterval = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get heartbeatIntervalInput() {
    return this._heartbeatInterval;
  }

  // id - computed: false, optional: false, required: true
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // locale - computed: true, optional: true, required: false
  private _locale?: string; 
  public get locale() {
    return this.getStringAttribute('locale');
  }
  public set locale(value: string) {
    this._locale = value;
  }
  public resetLocale() {
    this._locale = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get localeInput() {
    return this._locale;
  }

  // metadata - computed: false, optional: true, required: false
  private _metadata = new SourceInputWefSubscriptionsMetadataList(this, "metadata", false);
  public get metadata() {
    return this._metadata;
  }
  public putMetadata(value: SourceInputWefSubscriptionsMetadata[] | cdktf.IResolvable) {
    this._metadata.internalValue = value;
  }
  public resetMetadata() {
    this._metadata.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataInput() {
    return this._metadata.internalValue;
  }

  // query_selector - computed: true, optional: true, required: false
  private _querySelector?: string; 
  public get querySelector() {
    return this.getStringAttribute('query_selector');
  }
  public set querySelector(value: string) {
    this._querySelector = value;
  }
  public resetQuerySelector() {
    this._querySelector = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get querySelectorInput() {
    return this._querySelector;
  }

  // read_existing_events - computed: true, optional: true, required: false
  private _readExistingEvents?: boolean | cdktf.IResolvable; 
  public get readExistingEvents() {
    return this.getBooleanAttribute('read_existing_events');
  }
  public set readExistingEvents(value: boolean | cdktf.IResolvable) {
    this._readExistingEvents = value;
  }
  public resetReadExistingEvents() {
    this._readExistingEvents = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get readExistingEventsInput() {
    return this._readExistingEvents;
  }

  // send_bookmarks - computed: true, optional: true, required: false
  private _sendBookmarks?: boolean | cdktf.IResolvable; 
  public get sendBookmarks() {
    return this.getBooleanAttribute('send_bookmarks');
  }
  public set sendBookmarks(value: boolean | cdktf.IResolvable) {
    this._sendBookmarks = value;
  }
  public resetSendBookmarks() {
    this._sendBookmarks = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sendBookmarksInput() {
    return this._sendBookmarks;
  }

  // subscription_name - computed: false, optional: false, required: true
  private _subscriptionName?: string; 
  public get subscriptionName() {
    return this.getStringAttribute('subscription_name');
  }
  public set subscriptionName(value: string) {
    this._subscriptionName = value;
  }
  // Temporarily expose input value. Use with caution.
  public get subscriptionNameInput() {
    return this._subscriptionName;
  }

  // targets - computed: true, optional: true, required: false
  private _targets?: string[]; 
  public get targets() {
    return this.getListAttribute('targets');
  }
  public set targets(value: string[]) {
    this._targets = value;
  }
  public resetTargets() {
    this._targets = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get targetsInput() {
    return this._targets;
  }

  // version - computed: false, optional: true, required: false
  private _version?: string; 
  public get version() {
    return this.getStringAttribute('version');
  }
  public set version(value: string) {
    this._version = value;
  }
  public resetVersion() {
    this._version = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get versionInput() {
    return this._version;
  }
}

export class SourceInputWefSubscriptionsList extends cdktf.ComplexList {
  public internalValue? : SourceInputWefSubscriptions[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): SourceInputWefSubscriptionsOutputReference {
    return new SourceInputWefSubscriptionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface SourceInputWefTls {
  /**
  * Server path containing CA certificates (in PEM format) to use. Can reference $ENV_VARS. If multiple certificates are present in a .pem, each must directly certify the one preceding it.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#ca_path Source#ca_path}
  */
  readonly caPath: string;
  /**
  * Path on server containing certificates to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#cert_path Source#cert_path}
  */
  readonly certPath: string;
  /**
  * Name of the predefined certificate
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#certificate_name Source#certificate_name}
  */
  readonly certificateName?: string;
  /**
  * Regex matching allowable common names in peer certificates' subject attribute. Default: "/.* /"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#common_name_regex Source#common_name_regex}
   *
  * Note: The above comment contained a comment block ending sequence (* followed by /). We have introduced a space between to prevent syntax errors. Please ignore the space.
  */
  readonly commonNameRegex?: string;
  /**
  * Enable TLS. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#disabled Source#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * Parsed as JSON.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#keytab Source#keytab}
  */
  readonly keytab?: string;
  /**
  * must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_version Source#max_version}
  */
  readonly maxVersion?: string;
  /**
  * must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#min_version Source#min_version}
  */
  readonly minVersion?: string;
  /**
  * Enable OCSP check of certificate. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#ocsp_check Source#ocsp_check}
  */
  readonly ocspCheck?: boolean | cdktf.IResolvable;
  /**
  * If enabled, checks will fail on any OCSP error. Otherwise, checks will fail only when a certificate is revoked, ignoring other errors. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#ocsp_check_fail_close Source#ocsp_check_fail_close}
  */
  readonly ocspCheckFailClose?: boolean | cdktf.IResolvable;
  /**
  * Passphrase to use to decrypt private key
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#passphrase Source#passphrase}
  */
  readonly passphrase?: string;
  /**
  * Parsed as JSON.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#principal Source#principal}
  */
  readonly principal?: string;
  /**
  * Path on server containing the private key to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#priv_key_path Source#priv_key_path}
  */
  readonly privKeyPath: string;
  /**
  * Required for WEF certificate authentication. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#reject_unauthorized Source#reject_unauthorized}
  */
  readonly rejectUnauthorized?: boolean | cdktf.IResolvable;
  /**
  * Required for WEF certificate authentication. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#request_cert Source#request_cert}
  */
  readonly requestCert?: boolean | cdktf.IResolvable;
}

export function sourceInputWefTlsToTerraform(struct?: SourceInputWefTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ca_path: cdktf.stringToTerraform(struct!.caPath),
    cert_path: cdktf.stringToTerraform(struct!.certPath),
    certificate_name: cdktf.stringToTerraform(struct!.certificateName),
    common_name_regex: cdktf.stringToTerraform(struct!.commonNameRegex),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    keytab: cdktf.stringToTerraform(struct!.keytab),
    max_version: cdktf.stringToTerraform(struct!.maxVersion),
    min_version: cdktf.stringToTerraform(struct!.minVersion),
    ocsp_check: cdktf.booleanToTerraform(struct!.ocspCheck),
    ocsp_check_fail_close: cdktf.booleanToTerraform(struct!.ocspCheckFailClose),
    passphrase: cdktf.stringToTerraform(struct!.passphrase),
    principal: cdktf.stringToTerraform(struct!.principal),
    priv_key_path: cdktf.stringToTerraform(struct!.privKeyPath),
    reject_unauthorized: cdktf.booleanToTerraform(struct!.rejectUnauthorized),
    request_cert: cdktf.booleanToTerraform(struct!.requestCert),
  }
}


export function sourceInputWefTlsToHclTerraform(struct?: SourceInputWefTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ca_path: {
      value: cdktf.stringToHclTerraform(struct!.caPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    cert_path: {
      value: cdktf.stringToHclTerraform(struct!.certPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    certificate_name: {
      value: cdktf.stringToHclTerraform(struct!.certificateName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    common_name_regex: {
      value: cdktf.stringToHclTerraform(struct!.commonNameRegex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    keytab: {
      value: cdktf.stringToHclTerraform(struct!.keytab),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_version: {
      value: cdktf.stringToHclTerraform(struct!.maxVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    min_version: {
      value: cdktf.stringToHclTerraform(struct!.minVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ocsp_check: {
      value: cdktf.booleanToHclTerraform(struct!.ocspCheck),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    ocsp_check_fail_close: {
      value: cdktf.booleanToHclTerraform(struct!.ocspCheckFailClose),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    passphrase: {
      value: cdktf.stringToHclTerraform(struct!.passphrase),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    principal: {
      value: cdktf.stringToHclTerraform(struct!.principal),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    priv_key_path: {
      value: cdktf.stringToHclTerraform(struct!.privKeyPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reject_unauthorized: {
      value: cdktf.booleanToHclTerraform(struct!.rejectUnauthorized),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    request_cert: {
      value: cdktf.booleanToHclTerraform(struct!.requestCert),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputWefTlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SourceInputWefTls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._caPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.caPath = this._caPath;
    }
    if (this._certPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.certPath = this._certPath;
    }
    if (this._certificateName !== undefined) {
      hasAnyValues = true;
      internalValueResult.certificateName = this._certificateName;
    }
    if (this._commonNameRegex !== undefined) {
      hasAnyValues = true;
      internalValueResult.commonNameRegex = this._commonNameRegex;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._keytab !== undefined) {
      hasAnyValues = true;
      internalValueResult.keytab = this._keytab;
    }
    if (this._maxVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxVersion = this._maxVersion;
    }
    if (this._minVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.minVersion = this._minVersion;
    }
    if (this._ocspCheck !== undefined) {
      hasAnyValues = true;
      internalValueResult.ocspCheck = this._ocspCheck;
    }
    if (this._ocspCheckFailClose !== undefined) {
      hasAnyValues = true;
      internalValueResult.ocspCheckFailClose = this._ocspCheckFailClose;
    }
    if (this._passphrase !== undefined) {
      hasAnyValues = true;
      internalValueResult.passphrase = this._passphrase;
    }
    if (this._principal !== undefined) {
      hasAnyValues = true;
      internalValueResult.principal = this._principal;
    }
    if (this._privKeyPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.privKeyPath = this._privKeyPath;
    }
    if (this._rejectUnauthorized !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectUnauthorized = this._rejectUnauthorized;
    }
    if (this._requestCert !== undefined) {
      hasAnyValues = true;
      internalValueResult.requestCert = this._requestCert;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputWefTls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._caPath = undefined;
      this._certPath = undefined;
      this._certificateName = undefined;
      this._commonNameRegex = undefined;
      this._disabled = undefined;
      this._keytab = undefined;
      this._maxVersion = undefined;
      this._minVersion = undefined;
      this._ocspCheck = undefined;
      this._ocspCheckFailClose = undefined;
      this._passphrase = undefined;
      this._principal = undefined;
      this._privKeyPath = undefined;
      this._rejectUnauthorized = undefined;
      this._requestCert = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._caPath = value.caPath;
      this._certPath = value.certPath;
      this._certificateName = value.certificateName;
      this._commonNameRegex = value.commonNameRegex;
      this._disabled = value.disabled;
      this._keytab = value.keytab;
      this._maxVersion = value.maxVersion;
      this._minVersion = value.minVersion;
      this._ocspCheck = value.ocspCheck;
      this._ocspCheckFailClose = value.ocspCheckFailClose;
      this._passphrase = value.passphrase;
      this._principal = value.principal;
      this._privKeyPath = value.privKeyPath;
      this._rejectUnauthorized = value.rejectUnauthorized;
      this._requestCert = value.requestCert;
    }
  }

  // ca_path - computed: false, optional: false, required: true
  private _caPath?: string; 
  public get caPath() {
    return this.getStringAttribute('ca_path');
  }
  public set caPath(value: string) {
    this._caPath = value;
  }
  // Temporarily expose input value. Use with caution.
  public get caPathInput() {
    return this._caPath;
  }

  // cert_path - computed: false, optional: false, required: true
  private _certPath?: string; 
  public get certPath() {
    return this.getStringAttribute('cert_path');
  }
  public set certPath(value: string) {
    this._certPath = value;
  }
  // Temporarily expose input value. Use with caution.
  public get certPathInput() {
    return this._certPath;
  }

  // certificate_name - computed: false, optional: true, required: false
  private _certificateName?: string; 
  public get certificateName() {
    return this.getStringAttribute('certificate_name');
  }
  public set certificateName(value: string) {
    this._certificateName = value;
  }
  public resetCertificateName() {
    this._certificateName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certificateNameInput() {
    return this._certificateName;
  }

  // common_name_regex - computed: true, optional: true, required: false
  private _commonNameRegex?: string; 
  public get commonNameRegex() {
    return this.getStringAttribute('common_name_regex');
  }
  public set commonNameRegex(value: string) {
    this._commonNameRegex = value;
  }
  public resetCommonNameRegex() {
    this._commonNameRegex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commonNameRegexInput() {
    return this._commonNameRegex;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // keytab - computed: false, optional: true, required: false
  private _keytab?: string; 
  public get keytab() {
    return this.getStringAttribute('keytab');
  }
  public set keytab(value: string) {
    this._keytab = value;
  }
  public resetKeytab() {
    this._keytab = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keytabInput() {
    return this._keytab;
  }

  // max_version - computed: false, optional: true, required: false
  private _maxVersion?: string; 
  public get maxVersion() {
    return this.getStringAttribute('max_version');
  }
  public set maxVersion(value: string) {
    this._maxVersion = value;
  }
  public resetMaxVersion() {
    this._maxVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxVersionInput() {
    return this._maxVersion;
  }

  // min_version - computed: false, optional: true, required: false
  private _minVersion?: string; 
  public get minVersion() {
    return this.getStringAttribute('min_version');
  }
  public set minVersion(value: string) {
    this._minVersion = value;
  }
  public resetMinVersion() {
    this._minVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get minVersionInput() {
    return this._minVersion;
  }

  // ocsp_check - computed: true, optional: true, required: false
  private _ocspCheck?: boolean | cdktf.IResolvable; 
  public get ocspCheck() {
    return this.getBooleanAttribute('ocsp_check');
  }
  public set ocspCheck(value: boolean | cdktf.IResolvable) {
    this._ocspCheck = value;
  }
  public resetOcspCheck() {
    this._ocspCheck = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ocspCheckInput() {
    return this._ocspCheck;
  }

  // ocsp_check_fail_close - computed: true, optional: true, required: false
  private _ocspCheckFailClose?: boolean | cdktf.IResolvable; 
  public get ocspCheckFailClose() {
    return this.getBooleanAttribute('ocsp_check_fail_close');
  }
  public set ocspCheckFailClose(value: boolean | cdktf.IResolvable) {
    this._ocspCheckFailClose = value;
  }
  public resetOcspCheckFailClose() {
    this._ocspCheckFailClose = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ocspCheckFailCloseInput() {
    return this._ocspCheckFailClose;
  }

  // passphrase - computed: false, optional: true, required: false
  private _passphrase?: string; 
  public get passphrase() {
    return this.getStringAttribute('passphrase');
  }
  public set passphrase(value: string) {
    this._passphrase = value;
  }
  public resetPassphrase() {
    this._passphrase = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passphraseInput() {
    return this._passphrase;
  }

  // principal - computed: false, optional: true, required: false
  private _principal?: string; 
  public get principal() {
    return this.getStringAttribute('principal');
  }
  public set principal(value: string) {
    this._principal = value;
  }
  public resetPrincipal() {
    this._principal = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get principalInput() {
    return this._principal;
  }

  // priv_key_path - computed: false, optional: false, required: true
  private _privKeyPath?: string; 
  public get privKeyPath() {
    return this.getStringAttribute('priv_key_path');
  }
  public set privKeyPath(value: string) {
    this._privKeyPath = value;
  }
  // Temporarily expose input value. Use with caution.
  public get privKeyPathInput() {
    return this._privKeyPath;
  }

  // reject_unauthorized - computed: true, optional: true, required: false
  private _rejectUnauthorized?: boolean | cdktf.IResolvable; 
  public get rejectUnauthorized() {
    return this.getBooleanAttribute('reject_unauthorized');
  }
  public set rejectUnauthorized(value: boolean | cdktf.IResolvable) {
    this._rejectUnauthorized = value;
  }
  public resetRejectUnauthorized() {
    this._rejectUnauthorized = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectUnauthorizedInput() {
    return this._rejectUnauthorized;
  }

  // request_cert - computed: true, optional: true, required: false
  private _requestCert?: boolean | cdktf.IResolvable; 
  public get requestCert() {
    return this.getBooleanAttribute('request_cert');
  }
  public set requestCert(value: boolean | cdktf.IResolvable) {
    this._requestCert = value;
  }
  public resetRequestCert() {
    this._requestCert = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestCertInput() {
    return this._requestCert;
  }
}
export interface SourceInputWef {
  /**
  * Allow events to be ingested even if their MachineID does not match the client certificate CN. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#allow_machine_id_mismatch Source#allow_machine_id_mismatch}
  */
  readonly allowMachineIdMismatch?: boolean | cdktf.IResolvable;
  /**
  * How to authenticate incoming client connections. Default: "clientCert"; must be one of ["clientCert", "kerberos"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#auth_method Source#auth_method}
  */
  readonly authMethod?: string;
  /**
  * SHA1 fingerprint expected by the client, if it does not match the first certificate in the configured CA chain
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#ca_fingerprint Source#ca_fingerprint}
  */
  readonly caFingerprint?: string;
  /**
  * Add request headers to events in the __headers field. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#capture_headers Source#capture_headers}
  */
  readonly captureHeaders?: boolean | cdktf.IResolvable;
  /**
  * Direct connections to Destinations, and optionally via a Pipeline or a Pack
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#connections Source#connections}
  */
  readonly connections?: SourceInputWefConnections[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#description Source#description}
  */
  readonly description?: string;
  /**
  * Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#disabled Source#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * Expose the /cribl_health endpoint, which returns 200 OK when this Source is healthy. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#enable_health_check Source#enable_health_check}
  */
  readonly enableHealthCheck?: boolean | cdktf.IResolvable;
  /**
  * Preserve the client’s original IP address in the __srcIpPort field when connecting through an HTTP proxy that supports the X-Forwarded-For header. This does not apply to TCP-layer Proxy Protocol v1/v2. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#enable_proxy_header Source#enable_proxy_header}
  */
  readonly enableProxyHeader?: boolean | cdktf.IResolvable;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#environment Source#environment}
  */
  readonly environment?: string;
  /**
  * Address to bind on. Defaults to 0.0.0.0 (all addresses). Default: "0.0.0.0"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#host Source#host}
  */
  readonly host?: string;
  /**
  * Unique ID for this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#id Source#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * Messages from matched IP addresses will be processed, unless also matched by the denylist. Default: "/.* /"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#ip_allowlist_regex Source#ip_allowlist_regex}
   *
  * Note: The above comment contained a comment block ending sequence (* followed by /). We have introduced a space between to prevent syntax errors. Please ignore the space.
  */
  readonly ipAllowlistRegex?: string;
  /**
  * Messages from matched IP addresses will be ignored. This takes precedence over the allowlist. Default: "/^$/"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#ip_denylist_regex Source#ip_denylist_regex}
  */
  readonly ipDenylistRegex?: string;
  /**
  * After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes). Default: 90
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#keep_alive_timeout Source#keep_alive_timeout}
  */
  readonly keepAliveTimeout?: number;
  /**
  * Path to the keytab file containing the service principal credentials. @{product} will use `/etc/krb5.keytab` if not provided.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#keytab Source#keytab}
  */
  readonly keytab?: string;
  /**
  * Log a warning if the client certificate authority (CA) fingerprint does not match the expected value. A mismatch prevents Cribl from receiving events from the Windows Event Forwarder. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#log_fingerprint_mismatch Source#log_fingerprint_mismatch}
  */
  readonly logFingerprintMismatch?: boolean | cdktf.IResolvable;
  /**
  * Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput. Default: 256
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_active_req Source#max_active_req}
  */
  readonly maxActiveReq?: number;
  /**
  * Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited). Default: 0
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_requests_per_socket Source#max_requests_per_socket}
  */
  readonly maxRequestsPerSocket?: number;
  /**
  * Fields to add to events from this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#metadata Source#metadata}
  */
  readonly metadata?: SourceInputWefMetadata[] | cdktf.IResolvable;
  /**
  * Pipeline to process data from this Source before sending it through the Routes
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#pipeline Source#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Port to listen on. Default: 5986
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#port Source#port}
  */
  readonly port?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#pq Source#pq}
  */
  readonly pq?: SourceInputWefPq;
  /**
  * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers). Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#pq_enabled Source#pq_enabled}
  */
  readonly pqEnabled?: boolean | cdktf.IResolvable;
  /**
  * Kerberos principal used for authentication, typically in the form HTTP/<hostname>@<REALM>
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#principal Source#principal}
  */
  readonly principal?: string;
  /**
  * Select whether to send data to Routes, or directly to Destinations. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#send_to_routes Source#send_to_routes}
  */
  readonly sendToRoutes?: boolean | cdktf.IResolvable;
  /**
  * How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0. Default: 0
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#socket_timeout Source#socket_timeout}
  */
  readonly socketTimeout?: number;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#streamtags Source#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Subscriptions to events on forwarding endpoints
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#subscriptions Source#subscriptions}
  */
  readonly subscriptions: SourceInputWefSubscriptions[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#tls Source#tls}
  */
  readonly tls?: SourceInputWefTls;
  /**
  * must be "wef"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#type Source#type}
  */
  readonly type?: string;
}

export function sourceInputWefToTerraform(struct?: SourceInputWef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    allow_machine_id_mismatch: cdktf.booleanToTerraform(struct!.allowMachineIdMismatch),
    auth_method: cdktf.stringToTerraform(struct!.authMethod),
    ca_fingerprint: cdktf.stringToTerraform(struct!.caFingerprint),
    capture_headers: cdktf.booleanToTerraform(struct!.captureHeaders),
    connections: cdktf.listMapper(sourceInputWefConnectionsToTerraform, false)(struct!.connections),
    description: cdktf.stringToTerraform(struct!.description),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    enable_health_check: cdktf.booleanToTerraform(struct!.enableHealthCheck),
    enable_proxy_header: cdktf.booleanToTerraform(struct!.enableProxyHeader),
    environment: cdktf.stringToTerraform(struct!.environment),
    host: cdktf.stringToTerraform(struct!.host),
    id: cdktf.stringToTerraform(struct!.id),
    ip_allowlist_regex: cdktf.stringToTerraform(struct!.ipAllowlistRegex),
    ip_denylist_regex: cdktf.stringToTerraform(struct!.ipDenylistRegex),
    keep_alive_timeout: cdktf.numberToTerraform(struct!.keepAliveTimeout),
    keytab: cdktf.stringToTerraform(struct!.keytab),
    log_fingerprint_mismatch: cdktf.booleanToTerraform(struct!.logFingerprintMismatch),
    max_active_req: cdktf.numberToTerraform(struct!.maxActiveReq),
    max_requests_per_socket: cdktf.numberToTerraform(struct!.maxRequestsPerSocket),
    metadata: cdktf.listMapper(sourceInputWefMetadataToTerraform, false)(struct!.metadata),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    port: cdktf.numberToTerraform(struct!.port),
    pq: sourceInputWefPqToTerraform(struct!.pq),
    pq_enabled: cdktf.booleanToTerraform(struct!.pqEnabled),
    principal: cdktf.stringToTerraform(struct!.principal),
    send_to_routes: cdktf.booleanToTerraform(struct!.sendToRoutes),
    socket_timeout: cdktf.numberToTerraform(struct!.socketTimeout),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    subscriptions: cdktf.listMapper(sourceInputWefSubscriptionsToTerraform, false)(struct!.subscriptions),
    tls: sourceInputWefTlsToTerraform(struct!.tls),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function sourceInputWefToHclTerraform(struct?: SourceInputWef | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    allow_machine_id_mismatch: {
      value: cdktf.booleanToHclTerraform(struct!.allowMachineIdMismatch),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    auth_method: {
      value: cdktf.stringToHclTerraform(struct!.authMethod),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ca_fingerprint: {
      value: cdktf.stringToHclTerraform(struct!.caFingerprint),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    capture_headers: {
      value: cdktf.booleanToHclTerraform(struct!.captureHeaders),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    connections: {
      value: cdktf.listMapperHcl(sourceInputWefConnectionsToHclTerraform, false)(struct!.connections),
      isBlock: true,
      type: "list",
      storageClassType: "SourceInputWefConnectionsList",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    enable_health_check: {
      value: cdktf.booleanToHclTerraform(struct!.enableHealthCheck),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    enable_proxy_header: {
      value: cdktf.booleanToHclTerraform(struct!.enableProxyHeader),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    host: {
      value: cdktf.stringToHclTerraform(struct!.host),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ip_allowlist_regex: {
      value: cdktf.stringToHclTerraform(struct!.ipAllowlistRegex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ip_denylist_regex: {
      value: cdktf.stringToHclTerraform(struct!.ipDenylistRegex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    keep_alive_timeout: {
      value: cdktf.numberToHclTerraform(struct!.keepAliveTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    keytab: {
      value: cdktf.stringToHclTerraform(struct!.keytab),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    log_fingerprint_mismatch: {
      value: cdktf.booleanToHclTerraform(struct!.logFingerprintMismatch),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    max_active_req: {
      value: cdktf.numberToHclTerraform(struct!.maxActiveReq),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_requests_per_socket: {
      value: cdktf.numberToHclTerraform(struct!.maxRequestsPerSocket),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    metadata: {
      value: cdktf.listMapperHcl(sourceInputWefMetadataToHclTerraform, false)(struct!.metadata),
      isBlock: true,
      type: "list",
      storageClassType: "SourceInputWefMetadataList",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    pq: {
      value: sourceInputWefPqToHclTerraform(struct!.pq),
      isBlock: true,
      type: "struct",
      storageClassType: "SourceInputWefPq",
    },
    pq_enabled: {
      value: cdktf.booleanToHclTerraform(struct!.pqEnabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    principal: {
      value: cdktf.stringToHclTerraform(struct!.principal),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    send_to_routes: {
      value: cdktf.booleanToHclTerraform(struct!.sendToRoutes),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    socket_timeout: {
      value: cdktf.numberToHclTerraform(struct!.socketTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    subscriptions: {
      value: cdktf.listMapperHcl(sourceInputWefSubscriptionsToHclTerraform, false)(struct!.subscriptions),
      isBlock: true,
      type: "list",
      storageClassType: "SourceInputWefSubscriptionsList",
    },
    tls: {
      value: sourceInputWefTlsToHclTerraform(struct!.tls),
      isBlock: true,
      type: "struct",
      storageClassType: "SourceInputWefTls",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputWefOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SourceInputWef | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._allowMachineIdMismatch !== undefined) {
      hasAnyValues = true;
      internalValueResult.allowMachineIdMismatch = this._allowMachineIdMismatch;
    }
    if (this._authMethod !== undefined) {
      hasAnyValues = true;
      internalValueResult.authMethod = this._authMethod;
    }
    if (this._caFingerprint !== undefined) {
      hasAnyValues = true;
      internalValueResult.caFingerprint = this._caFingerprint;
    }
    if (this._captureHeaders !== undefined) {
      hasAnyValues = true;
      internalValueResult.captureHeaders = this._captureHeaders;
    }
    if (this._connections?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.connections = this._connections?.internalValue;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._enableHealthCheck !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableHealthCheck = this._enableHealthCheck;
    }
    if (this._enableProxyHeader !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableProxyHeader = this._enableProxyHeader;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._host !== undefined) {
      hasAnyValues = true;
      internalValueResult.host = this._host;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._ipAllowlistRegex !== undefined) {
      hasAnyValues = true;
      internalValueResult.ipAllowlistRegex = this._ipAllowlistRegex;
    }
    if (this._ipDenylistRegex !== undefined) {
      hasAnyValues = true;
      internalValueResult.ipDenylistRegex = this._ipDenylistRegex;
    }
    if (this._keepAliveTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.keepAliveTimeout = this._keepAliveTimeout;
    }
    if (this._keytab !== undefined) {
      hasAnyValues = true;
      internalValueResult.keytab = this._keytab;
    }
    if (this._logFingerprintMismatch !== undefined) {
      hasAnyValues = true;
      internalValueResult.logFingerprintMismatch = this._logFingerprintMismatch;
    }
    if (this._maxActiveReq !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxActiveReq = this._maxActiveReq;
    }
    if (this._maxRequestsPerSocket !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxRequestsPerSocket = this._maxRequestsPerSocket;
    }
    if (this._metadata?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadata = this._metadata?.internalValue;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._pq?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pq = this._pq?.internalValue;
    }
    if (this._pqEnabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqEnabled = this._pqEnabled;
    }
    if (this._principal !== undefined) {
      hasAnyValues = true;
      internalValueResult.principal = this._principal;
    }
    if (this._sendToRoutes !== undefined) {
      hasAnyValues = true;
      internalValueResult.sendToRoutes = this._sendToRoutes;
    }
    if (this._socketTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.socketTimeout = this._socketTimeout;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._subscriptions?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.subscriptions = this._subscriptions?.internalValue;
    }
    if (this._tls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tls = this._tls?.internalValue;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputWef | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._allowMachineIdMismatch = undefined;
      this._authMethod = undefined;
      this._caFingerprint = undefined;
      this._captureHeaders = undefined;
      this._connections.internalValue = undefined;
      this._description = undefined;
      this._disabled = undefined;
      this._enableHealthCheck = undefined;
      this._enableProxyHeader = undefined;
      this._environment = undefined;
      this._host = undefined;
      this._id = undefined;
      this._ipAllowlistRegex = undefined;
      this._ipDenylistRegex = undefined;
      this._keepAliveTimeout = undefined;
      this._keytab = undefined;
      this._logFingerprintMismatch = undefined;
      this._maxActiveReq = undefined;
      this._maxRequestsPerSocket = undefined;
      this._metadata.internalValue = undefined;
      this._pipeline = undefined;
      this._port = undefined;
      this._pq.internalValue = undefined;
      this._pqEnabled = undefined;
      this._principal = undefined;
      this._sendToRoutes = undefined;
      this._socketTimeout = undefined;
      this._streamtags = undefined;
      this._subscriptions.internalValue = undefined;
      this._tls.internalValue = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._allowMachineIdMismatch = value.allowMachineIdMismatch;
      this._authMethod = value.authMethod;
      this._caFingerprint = value.caFingerprint;
      this._captureHeaders = value.captureHeaders;
      this._connections.internalValue = value.connections;
      this._description = value.description;
      this._disabled = value.disabled;
      this._enableHealthCheck = value.enableHealthCheck;
      this._enableProxyHeader = value.enableProxyHeader;
      this._environment = value.environment;
      this._host = value.host;
      this._id = value.id;
      this._ipAllowlistRegex = value.ipAllowlistRegex;
      this._ipDenylistRegex = value.ipDenylistRegex;
      this._keepAliveTimeout = value.keepAliveTimeout;
      this._keytab = value.keytab;
      this._logFingerprintMismatch = value.logFingerprintMismatch;
      this._maxActiveReq = value.maxActiveReq;
      this._maxRequestsPerSocket = value.maxRequestsPerSocket;
      this._metadata.internalValue = value.metadata;
      this._pipeline = value.pipeline;
      this._port = value.port;
      this._pq.internalValue = value.pq;
      this._pqEnabled = value.pqEnabled;
      this._principal = value.principal;
      this._sendToRoutes = value.sendToRoutes;
      this._socketTimeout = value.socketTimeout;
      this._streamtags = value.streamtags;
      this._subscriptions.internalValue = value.subscriptions;
      this._tls.internalValue = value.tls;
      this._type = value.type;
    }
  }

  // allow_machine_id_mismatch - computed: true, optional: true, required: false
  private _allowMachineIdMismatch?: boolean | cdktf.IResolvable; 
  public get allowMachineIdMismatch() {
    return this.getBooleanAttribute('allow_machine_id_mismatch');
  }
  public set allowMachineIdMismatch(value: boolean | cdktf.IResolvable) {
    this._allowMachineIdMismatch = value;
  }
  public resetAllowMachineIdMismatch() {
    this._allowMachineIdMismatch = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get allowMachineIdMismatchInput() {
    return this._allowMachineIdMismatch;
  }

  // auth_method - computed: true, optional: true, required: false
  private _authMethod?: string; 
  public get authMethod() {
    return this.getStringAttribute('auth_method');
  }
  public set authMethod(value: string) {
    this._authMethod = value;
  }
  public resetAuthMethod() {
    this._authMethod = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authMethodInput() {
    return this._authMethod;
  }

  // ca_fingerprint - computed: false, optional: true, required: false
  private _caFingerprint?: string; 
  public get caFingerprint() {
    return this.getStringAttribute('ca_fingerprint');
  }
  public set caFingerprint(value: string) {
    this._caFingerprint = value;
  }
  public resetCaFingerprint() {
    this._caFingerprint = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get caFingerprintInput() {
    return this._caFingerprint;
  }

  // capture_headers - computed: true, optional: true, required: false
  private _captureHeaders?: boolean | cdktf.IResolvable; 
  public get captureHeaders() {
    return this.getBooleanAttribute('capture_headers');
  }
  public set captureHeaders(value: boolean | cdktf.IResolvable) {
    this._captureHeaders = value;
  }
  public resetCaptureHeaders() {
    this._captureHeaders = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get captureHeadersInput() {
    return this._captureHeaders;
  }

  // connections - computed: false, optional: true, required: false
  private _connections = new SourceInputWefConnectionsList(this, "connections", false);
  public get connections() {
    return this._connections;
  }
  public putConnections(value: SourceInputWefConnections[] | cdktf.IResolvable) {
    this._connections.internalValue = value;
  }
  public resetConnections() {
    this._connections.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectionsInput() {
    return this._connections.internalValue;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // enable_health_check - computed: true, optional: true, required: false
  private _enableHealthCheck?: boolean | cdktf.IResolvable; 
  public get enableHealthCheck() {
    return this.getBooleanAttribute('enable_health_check');
  }
  public set enableHealthCheck(value: boolean | cdktf.IResolvable) {
    this._enableHealthCheck = value;
  }
  public resetEnableHealthCheck() {
    this._enableHealthCheck = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableHealthCheckInput() {
    return this._enableHealthCheck;
  }

  // enable_proxy_header - computed: true, optional: true, required: false
  private _enableProxyHeader?: boolean | cdktf.IResolvable; 
  public get enableProxyHeader() {
    return this.getBooleanAttribute('enable_proxy_header');
  }
  public set enableProxyHeader(value: boolean | cdktf.IResolvable) {
    this._enableProxyHeader = value;
  }
  public resetEnableProxyHeader() {
    this._enableProxyHeader = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableProxyHeaderInput() {
    return this._enableProxyHeader;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // host - computed: true, optional: true, required: false
  private _host?: string; 
  public get host() {
    return this.getStringAttribute('host');
  }
  public set host(value: string) {
    this._host = value;
  }
  public resetHost() {
    this._host = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostInput() {
    return this._host;
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // ip_allowlist_regex - computed: true, optional: true, required: false
  private _ipAllowlistRegex?: string; 
  public get ipAllowlistRegex() {
    return this.getStringAttribute('ip_allowlist_regex');
  }
  public set ipAllowlistRegex(value: string) {
    this._ipAllowlistRegex = value;
  }
  public resetIpAllowlistRegex() {
    this._ipAllowlistRegex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ipAllowlistRegexInput() {
    return this._ipAllowlistRegex;
  }

  // ip_denylist_regex - computed: true, optional: true, required: false
  private _ipDenylistRegex?: string; 
  public get ipDenylistRegex() {
    return this.getStringAttribute('ip_denylist_regex');
  }
  public set ipDenylistRegex(value: string) {
    this._ipDenylistRegex = value;
  }
  public resetIpDenylistRegex() {
    this._ipDenylistRegex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ipDenylistRegexInput() {
    return this._ipDenylistRegex;
  }

  // keep_alive_timeout - computed: true, optional: true, required: false
  private _keepAliveTimeout?: number; 
  public get keepAliveTimeout() {
    return this.getNumberAttribute('keep_alive_timeout');
  }
  public set keepAliveTimeout(value: number) {
    this._keepAliveTimeout = value;
  }
  public resetKeepAliveTimeout() {
    this._keepAliveTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keepAliveTimeoutInput() {
    return this._keepAliveTimeout;
  }

  // keytab - computed: false, optional: true, required: false
  private _keytab?: string; 
  public get keytab() {
    return this.getStringAttribute('keytab');
  }
  public set keytab(value: string) {
    this._keytab = value;
  }
  public resetKeytab() {
    this._keytab = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keytabInput() {
    return this._keytab;
  }

  // log_fingerprint_mismatch - computed: true, optional: true, required: false
  private _logFingerprintMismatch?: boolean | cdktf.IResolvable; 
  public get logFingerprintMismatch() {
    return this.getBooleanAttribute('log_fingerprint_mismatch');
  }
  public set logFingerprintMismatch(value: boolean | cdktf.IResolvable) {
    this._logFingerprintMismatch = value;
  }
  public resetLogFingerprintMismatch() {
    this._logFingerprintMismatch = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get logFingerprintMismatchInput() {
    return this._logFingerprintMismatch;
  }

  // max_active_req - computed: true, optional: true, required: false
  private _maxActiveReq?: number; 
  public get maxActiveReq() {
    return this.getNumberAttribute('max_active_req');
  }
  public set maxActiveReq(value: number) {
    this._maxActiveReq = value;
  }
  public resetMaxActiveReq() {
    this._maxActiveReq = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxActiveReqInput() {
    return this._maxActiveReq;
  }

  // max_requests_per_socket - computed: true, optional: true, required: false
  private _maxRequestsPerSocket?: number; 
  public get maxRequestsPerSocket() {
    return this.getNumberAttribute('max_requests_per_socket');
  }
  public set maxRequestsPerSocket(value: number) {
    this._maxRequestsPerSocket = value;
  }
  public resetMaxRequestsPerSocket() {
    this._maxRequestsPerSocket = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxRequestsPerSocketInput() {
    return this._maxRequestsPerSocket;
  }

  // metadata - computed: false, optional: true, required: false
  private _metadata = new SourceInputWefMetadataList(this, "metadata", false);
  public get metadata() {
    return this._metadata;
  }
  public putMetadata(value: SourceInputWefMetadata[] | cdktf.IResolvable) {
    this._metadata.internalValue = value;
  }
  public resetMetadata() {
    this._metadata.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataInput() {
    return this._metadata.internalValue;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // port - computed: true, optional: true, required: false
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  public resetPort() {
    this._port = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // pq - computed: false, optional: true, required: false
  private _pq = new SourceInputWefPqOutputReference(this, "pq");
  public get pq() {
    return this._pq;
  }
  public putPq(value: SourceInputWefPq) {
    this._pq.internalValue = value;
  }
  public resetPq() {
    this._pq.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqInput() {
    return this._pq.internalValue;
  }

  // pq_enabled - computed: true, optional: true, required: false
  private _pqEnabled?: boolean | cdktf.IResolvable; 
  public get pqEnabled() {
    return this.getBooleanAttribute('pq_enabled');
  }
  public set pqEnabled(value: boolean | cdktf.IResolvable) {
    this._pqEnabled = value;
  }
  public resetPqEnabled() {
    this._pqEnabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqEnabledInput() {
    return this._pqEnabled;
  }

  // principal - computed: false, optional: true, required: false
  private _principal?: string; 
  public get principal() {
    return this.getStringAttribute('principal');
  }
  public set principal(value: string) {
    this._principal = value;
  }
  public resetPrincipal() {
    this._principal = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get principalInput() {
    return this._principal;
  }

  // send_to_routes - computed: true, optional: true, required: false
  private _sendToRoutes?: boolean | cdktf.IResolvable; 
  public get sendToRoutes() {
    return this.getBooleanAttribute('send_to_routes');
  }
  public set sendToRoutes(value: boolean | cdktf.IResolvable) {
    this._sendToRoutes = value;
  }
  public resetSendToRoutes() {
    this._sendToRoutes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sendToRoutesInput() {
    return this._sendToRoutes;
  }

  // socket_timeout - computed: true, optional: true, required: false
  private _socketTimeout?: number; 
  public get socketTimeout() {
    return this.getNumberAttribute('socket_timeout');
  }
  public set socketTimeout(value: number) {
    this._socketTimeout = value;
  }
  public resetSocketTimeout() {
    this._socketTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get socketTimeoutInput() {
    return this._socketTimeout;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // subscriptions - computed: false, optional: false, required: true
  private _subscriptions = new SourceInputWefSubscriptionsList(this, "subscriptions", false);
  public get subscriptions() {
    return this._subscriptions;
  }
  public putSubscriptions(value: SourceInputWefSubscriptions[] | cdktf.IResolvable) {
    this._subscriptions.internalValue = value;
  }
  // Temporarily expose input value. Use with caution.
  public get subscriptionsInput() {
    return this._subscriptions.internalValue;
  }

  // tls - computed: false, optional: true, required: false
  private _tls = new SourceInputWefTlsOutputReference(this, "tls");
  public get tls() {
    return this._tls;
  }
  public putTls(value: SourceInputWefTls) {
    this._tls.internalValue = value;
  }
  public resetTls() {
    this._tls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsInput() {
    return this._tls.internalValue;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface SourceInputWinEventLogsConnections {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#output Source#output}
  */
  readonly output: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#pipeline Source#pipeline}
  */
  readonly pipeline?: string;
}

export function sourceInputWinEventLogsConnectionsToTerraform(struct?: SourceInputWinEventLogsConnections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    output: cdktf.stringToTerraform(struct!.output),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
  }
}


export function sourceInputWinEventLogsConnectionsToHclTerraform(struct?: SourceInputWinEventLogsConnections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    output: {
      value: cdktf.stringToHclTerraform(struct!.output),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputWinEventLogsConnectionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): SourceInputWinEventLogsConnections | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._output !== undefined) {
      hasAnyValues = true;
      internalValueResult.output = this._output;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputWinEventLogsConnections | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._output = undefined;
      this._pipeline = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._output = value.output;
      this._pipeline = value.pipeline;
    }
  }

  // output - computed: false, optional: false, required: true
  private _output?: string; 
  public get output() {
    return this.getStringAttribute('output');
  }
  public set output(value: string) {
    this._output = value;
  }
  // Temporarily expose input value. Use with caution.
  public get outputInput() {
    return this._output;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }
}

export class SourceInputWinEventLogsConnectionsList extends cdktf.ComplexList {
  public internalValue? : SourceInputWinEventLogsConnections[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): SourceInputWinEventLogsConnectionsOutputReference {
    return new SourceInputWinEventLogsConnectionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface SourceInputWinEventLogsMetadata {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#name Source#name}
  */
  readonly name: string;
  /**
  * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#value Source#value}
  */
  readonly value: string;
}

export function sourceInputWinEventLogsMetadataToTerraform(struct?: SourceInputWinEventLogsMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function sourceInputWinEventLogsMetadataToHclTerraform(struct?: SourceInputWinEventLogsMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputWinEventLogsMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): SourceInputWinEventLogsMetadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputWinEventLogsMetadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class SourceInputWinEventLogsMetadataList extends cdktf.ComplexList {
  public internalValue? : SourceInputWinEventLogsMetadata[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): SourceInputWinEventLogsMetadataOutputReference {
    return new SourceInputWinEventLogsMetadataOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface SourceInputWinEventLogsPq {
  /**
  * The number of events to send downstream before committing that Stream has read them. Default: 42
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#commit_frequency Source#commit_frequency}
  */
  readonly commitFrequency?: number;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#compress Source#compress}
  */
  readonly compress?: string;
  /**
  * The maximum number of events to hold in memory before writing the events to disk. Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_buffer_size Source#max_buffer_size}
  */
  readonly maxBufferSize?: number;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc. Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_file_size Source#max_file_size}
  */
  readonly maxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_size Source#max_size}
  */
  readonly maxSize?: string;
  /**
  * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine. Default: "always"; must be one of ["smart", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#mode Source#mode}
  */
  readonly mode?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#path Source#path}
  */
  readonly path?: string;
}

export function sourceInputWinEventLogsPqToTerraform(struct?: SourceInputWinEventLogsPq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    commit_frequency: cdktf.numberToTerraform(struct!.commitFrequency),
    compress: cdktf.stringToTerraform(struct!.compress),
    max_buffer_size: cdktf.numberToTerraform(struct!.maxBufferSize),
    max_file_size: cdktf.stringToTerraform(struct!.maxFileSize),
    max_size: cdktf.stringToTerraform(struct!.maxSize),
    mode: cdktf.stringToTerraform(struct!.mode),
    path: cdktf.stringToTerraform(struct!.path),
  }
}


export function sourceInputWinEventLogsPqToHclTerraform(struct?: SourceInputWinEventLogsPq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    commit_frequency: {
      value: cdktf.numberToHclTerraform(struct!.commitFrequency),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    compress: {
      value: cdktf.stringToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_buffer_size: {
      value: cdktf.numberToHclTerraform(struct!.maxBufferSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.maxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_size: {
      value: cdktf.stringToHclTerraform(struct!.maxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputWinEventLogsPqOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SourceInputWinEventLogsPq | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._commitFrequency !== undefined) {
      hasAnyValues = true;
      internalValueResult.commitFrequency = this._commitFrequency;
    }
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._maxBufferSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBufferSize = this._maxBufferSize;
    }
    if (this._maxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxFileSize = this._maxFileSize;
    }
    if (this._maxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxSize = this._maxSize;
    }
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputWinEventLogsPq | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._commitFrequency = undefined;
      this._compress = undefined;
      this._maxBufferSize = undefined;
      this._maxFileSize = undefined;
      this._maxSize = undefined;
      this._mode = undefined;
      this._path = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._commitFrequency = value.commitFrequency;
      this._compress = value.compress;
      this._maxBufferSize = value.maxBufferSize;
      this._maxFileSize = value.maxFileSize;
      this._maxSize = value.maxSize;
      this._mode = value.mode;
      this._path = value.path;
    }
  }

  // commit_frequency - computed: true, optional: true, required: false
  private _commitFrequency?: number; 
  public get commitFrequency() {
    return this.getNumberAttribute('commit_frequency');
  }
  public set commitFrequency(value: number) {
    this._commitFrequency = value;
  }
  public resetCommitFrequency() {
    this._commitFrequency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commitFrequencyInput() {
    return this._commitFrequency;
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: string; 
  public get compress() {
    return this.getStringAttribute('compress');
  }
  public set compress(value: string) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // max_buffer_size - computed: true, optional: true, required: false
  private _maxBufferSize?: number; 
  public get maxBufferSize() {
    return this.getNumberAttribute('max_buffer_size');
  }
  public set maxBufferSize(value: number) {
    this._maxBufferSize = value;
  }
  public resetMaxBufferSize() {
    this._maxBufferSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBufferSizeInput() {
    return this._maxBufferSize;
  }

  // max_file_size - computed: true, optional: true, required: false
  private _maxFileSize?: string; 
  public get maxFileSize() {
    return this.getStringAttribute('max_file_size');
  }
  public set maxFileSize(value: string) {
    this._maxFileSize = value;
  }
  public resetMaxFileSize() {
    this._maxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxFileSizeInput() {
    return this._maxFileSize;
  }

  // max_size - computed: true, optional: true, required: false
  private _maxSize?: string; 
  public get maxSize() {
    return this.getStringAttribute('max_size');
  }
  public set maxSize(value: string) {
    this._maxSize = value;
  }
  public resetMaxSize() {
    this._maxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxSizeInput() {
    return this._maxSize;
  }

  // mode - computed: true, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // path - computed: true, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }
}
export interface SourceInputWinEventLogs {
  /**
  * The maximum number of events to read in one polling interval. A batch size higher than 500 can cause delays when pulling from multiple event logs. (Applicable for pre-4.8.0 nodes that use Windows Tools). Default: 500
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#batch_size Source#batch_size}
  */
  readonly batchSize?: number;
  /**
  * Direct connections to Destinations, and optionally via a Pipeline or a Pack
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#connections Source#connections}
  */
  readonly connections?: SourceInputWinEventLogsConnections[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#description Source#description}
  */
  readonly description?: string;
  /**
  * Enable to use built-in tools (PowerShell for JSON, wevtutil for XML) to collect event logs instead of native API (default) [Learn more](https://docs.cribl.io/edge/sources-windows-event-logs/#advanced-settings). Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#disable_native_module Source#disable_native_module}
  */
  readonly disableNativeModule?: boolean | cdktf.IResolvable;
  /**
  * Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#disabled Source#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#environment Source#environment}
  */
  readonly environment?: string;
  /**
  * Format of individual events. Default: "json"; must be one of ["json", "xml"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#event_format Source#event_format}
  */
  readonly eventFormat?: string;
  /**
  * Unique ID for this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#id Source#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * Time, in seconds, between checking for new entries (Applicable for pre-4.8.0 nodes that use Windows Tools). Default: 10
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#interval Source#interval}
  */
  readonly interval?: number;
  /**
  * Enter the event logs to collect. Run "Get-WinEvent -ListLog *" in PowerShell to see the available logs. Default: ["Application","Security","System"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#log_names Source#log_names}
  */
  readonly logNames?: string[];
  /**
  * The maximum number of bytes in an event before it is flushed to the pipelines. Default: 51200
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_event_bytes Source#max_event_bytes}
  */
  readonly maxEventBytes?: number;
  /**
  * Fields to add to events from this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#metadata Source#metadata}
  */
  readonly metadata?: SourceInputWinEventLogsMetadata[] | cdktf.IResolvable;
  /**
  * Pipeline to process data from this Source before sending it through the Routes
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#pipeline Source#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#pq Source#pq}
  */
  readonly pq?: SourceInputWinEventLogsPq;
  /**
  * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers). Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#pq_enabled Source#pq_enabled}
  */
  readonly pqEnabled?: boolean | cdktf.IResolvable;
  /**
  * Read all stored and future event logs, or only future events. Default: "oldest"; must be one of ["oldest", "newest"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#read_mode Source#read_mode}
  */
  readonly readMode?: string;
  /**
  * Select whether to send data to Routes, or directly to Destinations. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#send_to_routes Source#send_to_routes}
  */
  readonly sendToRoutes?: boolean | cdktf.IResolvable;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#streamtags Source#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * must be "win_event_logs"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#type Source#type}
  */
  readonly type: string;
}

export function sourceInputWinEventLogsToTerraform(struct?: SourceInputWinEventLogs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    batch_size: cdktf.numberToTerraform(struct!.batchSize),
    connections: cdktf.listMapper(sourceInputWinEventLogsConnectionsToTerraform, false)(struct!.connections),
    description: cdktf.stringToTerraform(struct!.description),
    disable_native_module: cdktf.booleanToTerraform(struct!.disableNativeModule),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    environment: cdktf.stringToTerraform(struct!.environment),
    event_format: cdktf.stringToTerraform(struct!.eventFormat),
    id: cdktf.stringToTerraform(struct!.id),
    interval: cdktf.numberToTerraform(struct!.interval),
    log_names: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.logNames),
    max_event_bytes: cdktf.numberToTerraform(struct!.maxEventBytes),
    metadata: cdktf.listMapper(sourceInputWinEventLogsMetadataToTerraform, false)(struct!.metadata),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    pq: sourceInputWinEventLogsPqToTerraform(struct!.pq),
    pq_enabled: cdktf.booleanToTerraform(struct!.pqEnabled),
    read_mode: cdktf.stringToTerraform(struct!.readMode),
    send_to_routes: cdktf.booleanToTerraform(struct!.sendToRoutes),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function sourceInputWinEventLogsToHclTerraform(struct?: SourceInputWinEventLogs | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    batch_size: {
      value: cdktf.numberToHclTerraform(struct!.batchSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    connections: {
      value: cdktf.listMapperHcl(sourceInputWinEventLogsConnectionsToHclTerraform, false)(struct!.connections),
      isBlock: true,
      type: "list",
      storageClassType: "SourceInputWinEventLogsConnectionsList",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disable_native_module: {
      value: cdktf.booleanToHclTerraform(struct!.disableNativeModule),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    event_format: {
      value: cdktf.stringToHclTerraform(struct!.eventFormat),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    interval: {
      value: cdktf.numberToHclTerraform(struct!.interval),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    log_names: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.logNames),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    max_event_bytes: {
      value: cdktf.numberToHclTerraform(struct!.maxEventBytes),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    metadata: {
      value: cdktf.listMapperHcl(sourceInputWinEventLogsMetadataToHclTerraform, false)(struct!.metadata),
      isBlock: true,
      type: "list",
      storageClassType: "SourceInputWinEventLogsMetadataList",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq: {
      value: sourceInputWinEventLogsPqToHclTerraform(struct!.pq),
      isBlock: true,
      type: "struct",
      storageClassType: "SourceInputWinEventLogsPq",
    },
    pq_enabled: {
      value: cdktf.booleanToHclTerraform(struct!.pqEnabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    read_mode: {
      value: cdktf.stringToHclTerraform(struct!.readMode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    send_to_routes: {
      value: cdktf.booleanToHclTerraform(struct!.sendToRoutes),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputWinEventLogsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SourceInputWinEventLogs | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._batchSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.batchSize = this._batchSize;
    }
    if (this._connections?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.connections = this._connections?.internalValue;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._disableNativeModule !== undefined) {
      hasAnyValues = true;
      internalValueResult.disableNativeModule = this._disableNativeModule;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._eventFormat !== undefined) {
      hasAnyValues = true;
      internalValueResult.eventFormat = this._eventFormat;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._interval !== undefined) {
      hasAnyValues = true;
      internalValueResult.interval = this._interval;
    }
    if (this._logNames !== undefined) {
      hasAnyValues = true;
      internalValueResult.logNames = this._logNames;
    }
    if (this._maxEventBytes !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxEventBytes = this._maxEventBytes;
    }
    if (this._metadata?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadata = this._metadata?.internalValue;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._pq?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pq = this._pq?.internalValue;
    }
    if (this._pqEnabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqEnabled = this._pqEnabled;
    }
    if (this._readMode !== undefined) {
      hasAnyValues = true;
      internalValueResult.readMode = this._readMode;
    }
    if (this._sendToRoutes !== undefined) {
      hasAnyValues = true;
      internalValueResult.sendToRoutes = this._sendToRoutes;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputWinEventLogs | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._batchSize = undefined;
      this._connections.internalValue = undefined;
      this._description = undefined;
      this._disableNativeModule = undefined;
      this._disabled = undefined;
      this._environment = undefined;
      this._eventFormat = undefined;
      this._id = undefined;
      this._interval = undefined;
      this._logNames = undefined;
      this._maxEventBytes = undefined;
      this._metadata.internalValue = undefined;
      this._pipeline = undefined;
      this._pq.internalValue = undefined;
      this._pqEnabled = undefined;
      this._readMode = undefined;
      this._sendToRoutes = undefined;
      this._streamtags = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._batchSize = value.batchSize;
      this._connections.internalValue = value.connections;
      this._description = value.description;
      this._disableNativeModule = value.disableNativeModule;
      this._disabled = value.disabled;
      this._environment = value.environment;
      this._eventFormat = value.eventFormat;
      this._id = value.id;
      this._interval = value.interval;
      this._logNames = value.logNames;
      this._maxEventBytes = value.maxEventBytes;
      this._metadata.internalValue = value.metadata;
      this._pipeline = value.pipeline;
      this._pq.internalValue = value.pq;
      this._pqEnabled = value.pqEnabled;
      this._readMode = value.readMode;
      this._sendToRoutes = value.sendToRoutes;
      this._streamtags = value.streamtags;
      this._type = value.type;
    }
  }

  // batch_size - computed: true, optional: true, required: false
  private _batchSize?: number; 
  public get batchSize() {
    return this.getNumberAttribute('batch_size');
  }
  public set batchSize(value: number) {
    this._batchSize = value;
  }
  public resetBatchSize() {
    this._batchSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get batchSizeInput() {
    return this._batchSize;
  }

  // connections - computed: false, optional: true, required: false
  private _connections = new SourceInputWinEventLogsConnectionsList(this, "connections", false);
  public get connections() {
    return this._connections;
  }
  public putConnections(value: SourceInputWinEventLogsConnections[] | cdktf.IResolvable) {
    this._connections.internalValue = value;
  }
  public resetConnections() {
    this._connections.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectionsInput() {
    return this._connections.internalValue;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // disable_native_module - computed: true, optional: true, required: false
  private _disableNativeModule?: boolean | cdktf.IResolvable; 
  public get disableNativeModule() {
    return this.getBooleanAttribute('disable_native_module');
  }
  public set disableNativeModule(value: boolean | cdktf.IResolvable) {
    this._disableNativeModule = value;
  }
  public resetDisableNativeModule() {
    this._disableNativeModule = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disableNativeModuleInput() {
    return this._disableNativeModule;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // event_format - computed: true, optional: true, required: false
  private _eventFormat?: string; 
  public get eventFormat() {
    return this.getStringAttribute('event_format');
  }
  public set eventFormat(value: string) {
    this._eventFormat = value;
  }
  public resetEventFormat() {
    this._eventFormat = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get eventFormatInput() {
    return this._eventFormat;
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // interval - computed: true, optional: true, required: false
  private _interval?: number; 
  public get interval() {
    return this.getNumberAttribute('interval');
  }
  public set interval(value: number) {
    this._interval = value;
  }
  public resetInterval() {
    this._interval = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get intervalInput() {
    return this._interval;
  }

  // log_names - computed: true, optional: true, required: false
  private _logNames?: string[]; 
  public get logNames() {
    return this.getListAttribute('log_names');
  }
  public set logNames(value: string[]) {
    this._logNames = value;
  }
  public resetLogNames() {
    this._logNames = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get logNamesInput() {
    return this._logNames;
  }

  // max_event_bytes - computed: true, optional: true, required: false
  private _maxEventBytes?: number; 
  public get maxEventBytes() {
    return this.getNumberAttribute('max_event_bytes');
  }
  public set maxEventBytes(value: number) {
    this._maxEventBytes = value;
  }
  public resetMaxEventBytes() {
    this._maxEventBytes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxEventBytesInput() {
    return this._maxEventBytes;
  }

  // metadata - computed: false, optional: true, required: false
  private _metadata = new SourceInputWinEventLogsMetadataList(this, "metadata", false);
  public get metadata() {
    return this._metadata;
  }
  public putMetadata(value: SourceInputWinEventLogsMetadata[] | cdktf.IResolvable) {
    this._metadata.internalValue = value;
  }
  public resetMetadata() {
    this._metadata.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataInput() {
    return this._metadata.internalValue;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // pq - computed: false, optional: true, required: false
  private _pq = new SourceInputWinEventLogsPqOutputReference(this, "pq");
  public get pq() {
    return this._pq;
  }
  public putPq(value: SourceInputWinEventLogsPq) {
    this._pq.internalValue = value;
  }
  public resetPq() {
    this._pq.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqInput() {
    return this._pq.internalValue;
  }

  // pq_enabled - computed: true, optional: true, required: false
  private _pqEnabled?: boolean | cdktf.IResolvable; 
  public get pqEnabled() {
    return this.getBooleanAttribute('pq_enabled');
  }
  public set pqEnabled(value: boolean | cdktf.IResolvable) {
    this._pqEnabled = value;
  }
  public resetPqEnabled() {
    this._pqEnabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqEnabledInput() {
    return this._pqEnabled;
  }

  // read_mode - computed: true, optional: true, required: false
  private _readMode?: string; 
  public get readMode() {
    return this.getStringAttribute('read_mode');
  }
  public set readMode(value: string) {
    this._readMode = value;
  }
  public resetReadMode() {
    this._readMode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get readModeInput() {
    return this._readMode;
  }

  // send_to_routes - computed: true, optional: true, required: false
  private _sendToRoutes?: boolean | cdktf.IResolvable; 
  public get sendToRoutes() {
    return this.getBooleanAttribute('send_to_routes');
  }
  public set sendToRoutes(value: boolean | cdktf.IResolvable) {
    this._sendToRoutes = value;
  }
  public resetSendToRoutes() {
    this._sendToRoutes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sendToRoutesInput() {
    return this._sendToRoutes;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface SourceInputWindowsMetricsConnections {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#output Source#output}
  */
  readonly output: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#pipeline Source#pipeline}
  */
  readonly pipeline?: string;
}

export function sourceInputWindowsMetricsConnectionsToTerraform(struct?: SourceInputWindowsMetricsConnections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    output: cdktf.stringToTerraform(struct!.output),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
  }
}


export function sourceInputWindowsMetricsConnectionsToHclTerraform(struct?: SourceInputWindowsMetricsConnections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    output: {
      value: cdktf.stringToHclTerraform(struct!.output),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputWindowsMetricsConnectionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): SourceInputWindowsMetricsConnections | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._output !== undefined) {
      hasAnyValues = true;
      internalValueResult.output = this._output;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputWindowsMetricsConnections | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._output = undefined;
      this._pipeline = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._output = value.output;
      this._pipeline = value.pipeline;
    }
  }

  // output - computed: false, optional: false, required: true
  private _output?: string; 
  public get output() {
    return this.getStringAttribute('output');
  }
  public set output(value: string) {
    this._output = value;
  }
  // Temporarily expose input value. Use with caution.
  public get outputInput() {
    return this._output;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }
}

export class SourceInputWindowsMetricsConnectionsList extends cdktf.ComplexList {
  public internalValue? : SourceInputWindowsMetricsConnections[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): SourceInputWindowsMetricsConnectionsOutputReference {
    return new SourceInputWindowsMetricsConnectionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface SourceInputWindowsMetricsHostCustomCpu {
  /**
  * Generate metrics for all CPU states. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#detail Source#detail}
  */
  readonly detail?: boolean | cdktf.IResolvable;
  /**
  * Select the level of details for CPU metrics. Default: "basic"; must be one of ["basic", "all", "custom", "disabled"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#mode Source#mode}
  */
  readonly mode?: string;
  /**
  * Generate metrics for each CPU. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#per_cpu Source#per_cpu}
  */
  readonly perCpu?: boolean | cdktf.IResolvable;
  /**
  * Generate raw, monotonic CPU time counters. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#time Source#time}
  */
  readonly time?: boolean | cdktf.IResolvable;
}

export function sourceInputWindowsMetricsHostCustomCpuToTerraform(struct?: SourceInputWindowsMetricsHostCustomCpu | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    detail: cdktf.booleanToTerraform(struct!.detail),
    mode: cdktf.stringToTerraform(struct!.mode),
    per_cpu: cdktf.booleanToTerraform(struct!.perCpu),
    time: cdktf.booleanToTerraform(struct!.time),
  }
}


export function sourceInputWindowsMetricsHostCustomCpuToHclTerraform(struct?: SourceInputWindowsMetricsHostCustomCpu | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    detail: {
      value: cdktf.booleanToHclTerraform(struct!.detail),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    per_cpu: {
      value: cdktf.booleanToHclTerraform(struct!.perCpu),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    time: {
      value: cdktf.booleanToHclTerraform(struct!.time),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputWindowsMetricsHostCustomCpuOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SourceInputWindowsMetricsHostCustomCpu | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._detail !== undefined) {
      hasAnyValues = true;
      internalValueResult.detail = this._detail;
    }
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._perCpu !== undefined) {
      hasAnyValues = true;
      internalValueResult.perCpu = this._perCpu;
    }
    if (this._time !== undefined) {
      hasAnyValues = true;
      internalValueResult.time = this._time;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputWindowsMetricsHostCustomCpu | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._detail = undefined;
      this._mode = undefined;
      this._perCpu = undefined;
      this._time = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._detail = value.detail;
      this._mode = value.mode;
      this._perCpu = value.perCpu;
      this._time = value.time;
    }
  }

  // detail - computed: true, optional: true, required: false
  private _detail?: boolean | cdktf.IResolvable; 
  public get detail() {
    return this.getBooleanAttribute('detail');
  }
  public set detail(value: boolean | cdktf.IResolvable) {
    this._detail = value;
  }
  public resetDetail() {
    this._detail = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get detailInput() {
    return this._detail;
  }

  // mode - computed: true, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // per_cpu - computed: true, optional: true, required: false
  private _perCpu?: boolean | cdktf.IResolvable; 
  public get perCpu() {
    return this.getBooleanAttribute('per_cpu');
  }
  public set perCpu(value: boolean | cdktf.IResolvable) {
    this._perCpu = value;
  }
  public resetPerCpu() {
    this._perCpu = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get perCpuInput() {
    return this._perCpu;
  }

  // time - computed: true, optional: true, required: false
  private _time?: boolean | cdktf.IResolvable; 
  public get time() {
    return this.getBooleanAttribute('time');
  }
  public set time(value: boolean | cdktf.IResolvable) {
    this._time = value;
  }
  public resetTime() {
    this._time = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeInput() {
    return this._time;
  }
}
export interface SourceInputWindowsMetricsHostCustomDisk {
  /**
  * Select the level of details for disk metrics. Default: "basic"; must be one of ["basic", "all", "custom", "disabled"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#mode Source#mode}
  */
  readonly mode?: string;
  /**
  * Generate separate metrics for each volume. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#per_volume Source#per_volume}
  */
  readonly perVolume?: boolean | cdktf.IResolvable;
  /**
  * Windows volumes to include/exclude. E.g.: C:, !E:, etc. Wildcards and ! (not) operators are supported. All volumes are included if this list is empty. Default: ["!HarddiskVolume*","*"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#volumes Source#volumes}
  */
  readonly volumes?: string[];
}

export function sourceInputWindowsMetricsHostCustomDiskToTerraform(struct?: SourceInputWindowsMetricsHostCustomDisk | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    mode: cdktf.stringToTerraform(struct!.mode),
    per_volume: cdktf.booleanToTerraform(struct!.perVolume),
    volumes: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.volumes),
  }
}


export function sourceInputWindowsMetricsHostCustomDiskToHclTerraform(struct?: SourceInputWindowsMetricsHostCustomDisk | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    per_volume: {
      value: cdktf.booleanToHclTerraform(struct!.perVolume),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    volumes: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.volumes),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputWindowsMetricsHostCustomDiskOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SourceInputWindowsMetricsHostCustomDisk | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._perVolume !== undefined) {
      hasAnyValues = true;
      internalValueResult.perVolume = this._perVolume;
    }
    if (this._volumes !== undefined) {
      hasAnyValues = true;
      internalValueResult.volumes = this._volumes;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputWindowsMetricsHostCustomDisk | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._mode = undefined;
      this._perVolume = undefined;
      this._volumes = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._mode = value.mode;
      this._perVolume = value.perVolume;
      this._volumes = value.volumes;
    }
  }

  // mode - computed: true, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // per_volume - computed: true, optional: true, required: false
  private _perVolume?: boolean | cdktf.IResolvable; 
  public get perVolume() {
    return this.getBooleanAttribute('per_volume');
  }
  public set perVolume(value: boolean | cdktf.IResolvable) {
    this._perVolume = value;
  }
  public resetPerVolume() {
    this._perVolume = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get perVolumeInput() {
    return this._perVolume;
  }

  // volumes - computed: true, optional: true, required: false
  private _volumes?: string[]; 
  public get volumes() {
    return this.getListAttribute('volumes');
  }
  public set volumes(value: string[]) {
    this._volumes = value;
  }
  public resetVolumes() {
    this._volumes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get volumesInput() {
    return this._volumes;
  }
}
export interface SourceInputWindowsMetricsHostCustomMemory {
  /**
  * Generate metrics for all memory states. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#detail Source#detail}
  */
  readonly detail?: boolean | cdktf.IResolvable;
  /**
  * Select the level of details for memory metrics. Default: "basic"; must be one of ["basic", "all", "custom", "disabled"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#mode Source#mode}
  */
  readonly mode?: string;
}

export function sourceInputWindowsMetricsHostCustomMemoryToTerraform(struct?: SourceInputWindowsMetricsHostCustomMemory | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    detail: cdktf.booleanToTerraform(struct!.detail),
    mode: cdktf.stringToTerraform(struct!.mode),
  }
}


export function sourceInputWindowsMetricsHostCustomMemoryToHclTerraform(struct?: SourceInputWindowsMetricsHostCustomMemory | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    detail: {
      value: cdktf.booleanToHclTerraform(struct!.detail),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputWindowsMetricsHostCustomMemoryOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SourceInputWindowsMetricsHostCustomMemory | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._detail !== undefined) {
      hasAnyValues = true;
      internalValueResult.detail = this._detail;
    }
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputWindowsMetricsHostCustomMemory | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._detail = undefined;
      this._mode = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._detail = value.detail;
      this._mode = value.mode;
    }
  }

  // detail - computed: true, optional: true, required: false
  private _detail?: boolean | cdktf.IResolvable; 
  public get detail() {
    return this.getBooleanAttribute('detail');
  }
  public set detail(value: boolean | cdktf.IResolvable) {
    this._detail = value;
  }
  public resetDetail() {
    this._detail = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get detailInput() {
    return this._detail;
  }

  // mode - computed: true, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }
}
export interface SourceInputWindowsMetricsHostCustomNetwork {
  /**
  * Generate full network metrics. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#detail Source#detail}
  */
  readonly detail?: boolean | cdktf.IResolvable;
  /**
  * Network interfaces to include/exclude. All interfaces are included if this list is empty. Default: ["!6to4*","!*Debug*","!*Virtual*","!*Tunneling*","!*IP-HTTPS*","*"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#devices Source#devices}
  */
  readonly devices?: string[];
  /**
  * Select the level of details for network metrics. Default: "basic"; must be one of ["basic", "all", "custom", "disabled"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#mode Source#mode}
  */
  readonly mode?: string;
  /**
  * Generate separate metrics for each interface. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#per_interface Source#per_interface}
  */
  readonly perInterface?: boolean | cdktf.IResolvable;
}

export function sourceInputWindowsMetricsHostCustomNetworkToTerraform(struct?: SourceInputWindowsMetricsHostCustomNetwork | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    detail: cdktf.booleanToTerraform(struct!.detail),
    devices: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.devices),
    mode: cdktf.stringToTerraform(struct!.mode),
    per_interface: cdktf.booleanToTerraform(struct!.perInterface),
  }
}


export function sourceInputWindowsMetricsHostCustomNetworkToHclTerraform(struct?: SourceInputWindowsMetricsHostCustomNetwork | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    detail: {
      value: cdktf.booleanToHclTerraform(struct!.detail),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    devices: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.devices),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    per_interface: {
      value: cdktf.booleanToHclTerraform(struct!.perInterface),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputWindowsMetricsHostCustomNetworkOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SourceInputWindowsMetricsHostCustomNetwork | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._detail !== undefined) {
      hasAnyValues = true;
      internalValueResult.detail = this._detail;
    }
    if (this._devices !== undefined) {
      hasAnyValues = true;
      internalValueResult.devices = this._devices;
    }
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._perInterface !== undefined) {
      hasAnyValues = true;
      internalValueResult.perInterface = this._perInterface;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputWindowsMetricsHostCustomNetwork | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._detail = undefined;
      this._devices = undefined;
      this._mode = undefined;
      this._perInterface = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._detail = value.detail;
      this._devices = value.devices;
      this._mode = value.mode;
      this._perInterface = value.perInterface;
    }
  }

  // detail - computed: true, optional: true, required: false
  private _detail?: boolean | cdktf.IResolvable; 
  public get detail() {
    return this.getBooleanAttribute('detail');
  }
  public set detail(value: boolean | cdktf.IResolvable) {
    this._detail = value;
  }
  public resetDetail() {
    this._detail = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get detailInput() {
    return this._detail;
  }

  // devices - computed: true, optional: true, required: false
  private _devices?: string[]; 
  public get devices() {
    return this.getListAttribute('devices');
  }
  public set devices(value: string[]) {
    this._devices = value;
  }
  public resetDevices() {
    this._devices = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get devicesInput() {
    return this._devices;
  }

  // mode - computed: true, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // per_interface - computed: true, optional: true, required: false
  private _perInterface?: boolean | cdktf.IResolvable; 
  public get perInterface() {
    return this.getBooleanAttribute('per_interface');
  }
  public set perInterface(value: boolean | cdktf.IResolvable) {
    this._perInterface = value;
  }
  public resetPerInterface() {
    this._perInterface = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get perInterfaceInput() {
    return this._perInterface;
  }
}
export interface SourceInputWindowsMetricsHostCustomSystem {
  /**
  * Generate metrics for all system information. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#detail Source#detail}
  */
  readonly detail?: boolean | cdktf.IResolvable;
  /**
  * Select the level of details for system metrics. Default: "basic"; must be one of ["basic", "all", "custom", "disabled"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#mode Source#mode}
  */
  readonly mode?: string;
}

export function sourceInputWindowsMetricsHostCustomSystemToTerraform(struct?: SourceInputWindowsMetricsHostCustomSystem | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    detail: cdktf.booleanToTerraform(struct!.detail),
    mode: cdktf.stringToTerraform(struct!.mode),
  }
}


export function sourceInputWindowsMetricsHostCustomSystemToHclTerraform(struct?: SourceInputWindowsMetricsHostCustomSystem | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    detail: {
      value: cdktf.booleanToHclTerraform(struct!.detail),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputWindowsMetricsHostCustomSystemOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SourceInputWindowsMetricsHostCustomSystem | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._detail !== undefined) {
      hasAnyValues = true;
      internalValueResult.detail = this._detail;
    }
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputWindowsMetricsHostCustomSystem | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._detail = undefined;
      this._mode = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._detail = value.detail;
      this._mode = value.mode;
    }
  }

  // detail - computed: true, optional: true, required: false
  private _detail?: boolean | cdktf.IResolvable; 
  public get detail() {
    return this.getBooleanAttribute('detail');
  }
  public set detail(value: boolean | cdktf.IResolvable) {
    this._detail = value;
  }
  public resetDetail() {
    this._detail = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get detailInput() {
    return this._detail;
  }

  // mode - computed: true, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }
}
export interface SourceInputWindowsMetricsHostCustom {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#cpu Source#cpu}
  */
  readonly cpu?: SourceInputWindowsMetricsHostCustomCpu;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#disk Source#disk}
  */
  readonly disk?: SourceInputWindowsMetricsHostCustomDisk;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#memory Source#memory}
  */
  readonly memory?: SourceInputWindowsMetricsHostCustomMemory;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#network Source#network}
  */
  readonly network?: SourceInputWindowsMetricsHostCustomNetwork;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#system Source#system}
  */
  readonly systemAttribute?: SourceInputWindowsMetricsHostCustomSystem;
}

export function sourceInputWindowsMetricsHostCustomToTerraform(struct?: SourceInputWindowsMetricsHostCustom | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    cpu: sourceInputWindowsMetricsHostCustomCpuToTerraform(struct!.cpu),
    disk: sourceInputWindowsMetricsHostCustomDiskToTerraform(struct!.disk),
    memory: sourceInputWindowsMetricsHostCustomMemoryToTerraform(struct!.memory),
    network: sourceInputWindowsMetricsHostCustomNetworkToTerraform(struct!.network),
    system: sourceInputWindowsMetricsHostCustomSystemToTerraform(struct!.systemAttribute),
  }
}


export function sourceInputWindowsMetricsHostCustomToHclTerraform(struct?: SourceInputWindowsMetricsHostCustom | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    cpu: {
      value: sourceInputWindowsMetricsHostCustomCpuToHclTerraform(struct!.cpu),
      isBlock: true,
      type: "struct",
      storageClassType: "SourceInputWindowsMetricsHostCustomCpu",
    },
    disk: {
      value: sourceInputWindowsMetricsHostCustomDiskToHclTerraform(struct!.disk),
      isBlock: true,
      type: "struct",
      storageClassType: "SourceInputWindowsMetricsHostCustomDisk",
    },
    memory: {
      value: sourceInputWindowsMetricsHostCustomMemoryToHclTerraform(struct!.memory),
      isBlock: true,
      type: "struct",
      storageClassType: "SourceInputWindowsMetricsHostCustomMemory",
    },
    network: {
      value: sourceInputWindowsMetricsHostCustomNetworkToHclTerraform(struct!.network),
      isBlock: true,
      type: "struct",
      storageClassType: "SourceInputWindowsMetricsHostCustomNetwork",
    },
    system: {
      value: sourceInputWindowsMetricsHostCustomSystemToHclTerraform(struct!.systemAttribute),
      isBlock: true,
      type: "struct",
      storageClassType: "SourceInputWindowsMetricsHostCustomSystem",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputWindowsMetricsHostCustomOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SourceInputWindowsMetricsHostCustom | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._cpu?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.cpu = this._cpu?.internalValue;
    }
    if (this._disk?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.disk = this._disk?.internalValue;
    }
    if (this._memory?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.memory = this._memory?.internalValue;
    }
    if (this._network?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.network = this._network?.internalValue;
    }
    if (this._system?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.systemAttribute = this._system?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputWindowsMetricsHostCustom | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._cpu.internalValue = undefined;
      this._disk.internalValue = undefined;
      this._memory.internalValue = undefined;
      this._network.internalValue = undefined;
      this._system.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._cpu.internalValue = value.cpu;
      this._disk.internalValue = value.disk;
      this._memory.internalValue = value.memory;
      this._network.internalValue = value.network;
      this._system.internalValue = value.systemAttribute;
    }
  }

  // cpu - computed: false, optional: true, required: false
  private _cpu = new SourceInputWindowsMetricsHostCustomCpuOutputReference(this, "cpu");
  public get cpu() {
    return this._cpu;
  }
  public putCpu(value: SourceInputWindowsMetricsHostCustomCpu) {
    this._cpu.internalValue = value;
  }
  public resetCpu() {
    this._cpu.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get cpuInput() {
    return this._cpu.internalValue;
  }

  // disk - computed: false, optional: true, required: false
  private _disk = new SourceInputWindowsMetricsHostCustomDiskOutputReference(this, "disk");
  public get disk() {
    return this._disk;
  }
  public putDisk(value: SourceInputWindowsMetricsHostCustomDisk) {
    this._disk.internalValue = value;
  }
  public resetDisk() {
    this._disk.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get diskInput() {
    return this._disk.internalValue;
  }

  // memory - computed: false, optional: true, required: false
  private _memory = new SourceInputWindowsMetricsHostCustomMemoryOutputReference(this, "memory");
  public get memory() {
    return this._memory;
  }
  public putMemory(value: SourceInputWindowsMetricsHostCustomMemory) {
    this._memory.internalValue = value;
  }
  public resetMemory() {
    this._memory.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get memoryInput() {
    return this._memory.internalValue;
  }

  // network - computed: false, optional: true, required: false
  private _network = new SourceInputWindowsMetricsHostCustomNetworkOutputReference(this, "network");
  public get network() {
    return this._network;
  }
  public putNetwork(value: SourceInputWindowsMetricsHostCustomNetwork) {
    this._network.internalValue = value;
  }
  public resetNetwork() {
    this._network.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get networkInput() {
    return this._network.internalValue;
  }

  // system - computed: false, optional: true, required: false
  private _system = new SourceInputWindowsMetricsHostCustomSystemOutputReference(this, "system");
  public get systemAttribute() {
    return this._system;
  }
  public putSystemAttribute(value: SourceInputWindowsMetricsHostCustomSystem) {
    this._system.internalValue = value;
  }
  public resetSystemAttribute() {
    this._system.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get systemAttributeInput() {
    return this._system.internalValue;
  }
}
export interface SourceInputWindowsMetricsHost {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#custom Source#custom}
  */
  readonly custom?: SourceInputWindowsMetricsHostCustom;
  /**
  * Select level of detail for host metrics. Default: "basic"; must be one of ["basic", "all", "custom", "disabled"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#mode Source#mode}
  */
  readonly mode?: string;
}

export function sourceInputWindowsMetricsHostToTerraform(struct?: SourceInputWindowsMetricsHost | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    custom: sourceInputWindowsMetricsHostCustomToTerraform(struct!.custom),
    mode: cdktf.stringToTerraform(struct!.mode),
  }
}


export function sourceInputWindowsMetricsHostToHclTerraform(struct?: SourceInputWindowsMetricsHost | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    custom: {
      value: sourceInputWindowsMetricsHostCustomToHclTerraform(struct!.custom),
      isBlock: true,
      type: "struct",
      storageClassType: "SourceInputWindowsMetricsHostCustom",
    },
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputWindowsMetricsHostOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SourceInputWindowsMetricsHost | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._custom?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.custom = this._custom?.internalValue;
    }
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputWindowsMetricsHost | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._custom.internalValue = undefined;
      this._mode = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._custom.internalValue = value.custom;
      this._mode = value.mode;
    }
  }

  // custom - computed: false, optional: true, required: false
  private _custom = new SourceInputWindowsMetricsHostCustomOutputReference(this, "custom");
  public get custom() {
    return this._custom;
  }
  public putCustom(value: SourceInputWindowsMetricsHostCustom) {
    this._custom.internalValue = value;
  }
  public resetCustom() {
    this._custom.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get customInput() {
    return this._custom.internalValue;
  }

  // mode - computed: true, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }
}
export interface SourceInputWindowsMetricsMetadata {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#name Source#name}
  */
  readonly name: string;
  /**
  * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#value Source#value}
  */
  readonly value: string;
}

export function sourceInputWindowsMetricsMetadataToTerraform(struct?: SourceInputWindowsMetricsMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function sourceInputWindowsMetricsMetadataToHclTerraform(struct?: SourceInputWindowsMetricsMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputWindowsMetricsMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): SourceInputWindowsMetricsMetadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputWindowsMetricsMetadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class SourceInputWindowsMetricsMetadataList extends cdktf.ComplexList {
  public internalValue? : SourceInputWindowsMetricsMetadata[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): SourceInputWindowsMetricsMetadataOutputReference {
    return new SourceInputWindowsMetricsMetadataOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface SourceInputWindowsMetricsPersistence {
  /**
  * Default: "gzip"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#compress Source#compress}
  */
  readonly compress?: string;
  /**
  * Path to use to write metrics. Defaults to $CRIBL_HOME/state/windows_metrics. Default: "$CRIBL_HOME/state/windows_metrics"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#dest_path Source#dest_path}
  */
  readonly destPath?: string;
  /**
  * Spool metrics to disk for Cribl Edge and Search. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#enable Source#enable}
  */
  readonly enable?: boolean | cdktf.IResolvable;
  /**
  * Maximum disk space allowed to be consumed (examples: 420MB, 4GB). When limit is reached, older data will be deleted. Default: "1GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_data_size Source#max_data_size}
  */
  readonly maxDataSize?: string;
  /**
  * Maximum amount of time to retain data (examples: 2h, 4d). When limit is reached, older data will be deleted. Default: "24h"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_data_time Source#max_data_time}
  */
  readonly maxDataTime?: string;
  /**
  * Time span for each file bucket. Default: "10m"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#time_window Source#time_window}
  */
  readonly timeWindow?: string;
}

export function sourceInputWindowsMetricsPersistenceToTerraform(struct?: SourceInputWindowsMetricsPersistence | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    compress: cdktf.stringToTerraform(struct!.compress),
    dest_path: cdktf.stringToTerraform(struct!.destPath),
    enable: cdktf.booleanToTerraform(struct!.enable),
    max_data_size: cdktf.stringToTerraform(struct!.maxDataSize),
    max_data_time: cdktf.stringToTerraform(struct!.maxDataTime),
    time_window: cdktf.stringToTerraform(struct!.timeWindow),
  }
}


export function sourceInputWindowsMetricsPersistenceToHclTerraform(struct?: SourceInputWindowsMetricsPersistence | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    compress: {
      value: cdktf.stringToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    dest_path: {
      value: cdktf.stringToHclTerraform(struct!.destPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    enable: {
      value: cdktf.booleanToHclTerraform(struct!.enable),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    max_data_size: {
      value: cdktf.stringToHclTerraform(struct!.maxDataSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_data_time: {
      value: cdktf.stringToHclTerraform(struct!.maxDataTime),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    time_window: {
      value: cdktf.stringToHclTerraform(struct!.timeWindow),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputWindowsMetricsPersistenceOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SourceInputWindowsMetricsPersistence | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._destPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.destPath = this._destPath;
    }
    if (this._enable !== undefined) {
      hasAnyValues = true;
      internalValueResult.enable = this._enable;
    }
    if (this._maxDataSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxDataSize = this._maxDataSize;
    }
    if (this._maxDataTime !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxDataTime = this._maxDataTime;
    }
    if (this._timeWindow !== undefined) {
      hasAnyValues = true;
      internalValueResult.timeWindow = this._timeWindow;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputWindowsMetricsPersistence | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._compress = undefined;
      this._destPath = undefined;
      this._enable = undefined;
      this._maxDataSize = undefined;
      this._maxDataTime = undefined;
      this._timeWindow = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._compress = value.compress;
      this._destPath = value.destPath;
      this._enable = value.enable;
      this._maxDataSize = value.maxDataSize;
      this._maxDataTime = value.maxDataTime;
      this._timeWindow = value.timeWindow;
    }
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: string; 
  public get compress() {
    return this.getStringAttribute('compress');
  }
  public set compress(value: string) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // dest_path - computed: true, optional: true, required: false
  private _destPath?: string; 
  public get destPath() {
    return this.getStringAttribute('dest_path');
  }
  public set destPath(value: string) {
    this._destPath = value;
  }
  public resetDestPath() {
    this._destPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get destPathInput() {
    return this._destPath;
  }

  // enable - computed: true, optional: true, required: false
  private _enable?: boolean | cdktf.IResolvable; 
  public get enable() {
    return this.getBooleanAttribute('enable');
  }
  public set enable(value: boolean | cdktf.IResolvable) {
    this._enable = value;
  }
  public resetEnable() {
    this._enable = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableInput() {
    return this._enable;
  }

  // max_data_size - computed: true, optional: true, required: false
  private _maxDataSize?: string; 
  public get maxDataSize() {
    return this.getStringAttribute('max_data_size');
  }
  public set maxDataSize(value: string) {
    this._maxDataSize = value;
  }
  public resetMaxDataSize() {
    this._maxDataSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxDataSizeInput() {
    return this._maxDataSize;
  }

  // max_data_time - computed: true, optional: true, required: false
  private _maxDataTime?: string; 
  public get maxDataTime() {
    return this.getStringAttribute('max_data_time');
  }
  public set maxDataTime(value: string) {
    this._maxDataTime = value;
  }
  public resetMaxDataTime() {
    this._maxDataTime = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxDataTimeInput() {
    return this._maxDataTime;
  }

  // time_window - computed: true, optional: true, required: false
  private _timeWindow?: string; 
  public get timeWindow() {
    return this.getStringAttribute('time_window');
  }
  public set timeWindow(value: string) {
    this._timeWindow = value;
  }
  public resetTimeWindow() {
    this._timeWindow = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get timeWindowInput() {
    return this._timeWindow;
  }
}
export interface SourceInputWindowsMetricsPq {
  /**
  * The number of events to send downstream before committing that Stream has read them. Default: 42
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#commit_frequency Source#commit_frequency}
  */
  readonly commitFrequency?: number;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#compress Source#compress}
  */
  readonly compress?: string;
  /**
  * The maximum number of events to hold in memory before writing the events to disk. Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_buffer_size Source#max_buffer_size}
  */
  readonly maxBufferSize?: number;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc. Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_file_size Source#max_file_size}
  */
  readonly maxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_size Source#max_size}
  */
  readonly maxSize?: string;
  /**
  * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine. Default: "always"; must be one of ["smart", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#mode Source#mode}
  */
  readonly mode?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#path Source#path}
  */
  readonly path?: string;
}

export function sourceInputWindowsMetricsPqToTerraform(struct?: SourceInputWindowsMetricsPq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    commit_frequency: cdktf.numberToTerraform(struct!.commitFrequency),
    compress: cdktf.stringToTerraform(struct!.compress),
    max_buffer_size: cdktf.numberToTerraform(struct!.maxBufferSize),
    max_file_size: cdktf.stringToTerraform(struct!.maxFileSize),
    max_size: cdktf.stringToTerraform(struct!.maxSize),
    mode: cdktf.stringToTerraform(struct!.mode),
    path: cdktf.stringToTerraform(struct!.path),
  }
}


export function sourceInputWindowsMetricsPqToHclTerraform(struct?: SourceInputWindowsMetricsPq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    commit_frequency: {
      value: cdktf.numberToHclTerraform(struct!.commitFrequency),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    compress: {
      value: cdktf.stringToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_buffer_size: {
      value: cdktf.numberToHclTerraform(struct!.maxBufferSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.maxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_size: {
      value: cdktf.stringToHclTerraform(struct!.maxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputWindowsMetricsPqOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SourceInputWindowsMetricsPq | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._commitFrequency !== undefined) {
      hasAnyValues = true;
      internalValueResult.commitFrequency = this._commitFrequency;
    }
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._maxBufferSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBufferSize = this._maxBufferSize;
    }
    if (this._maxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxFileSize = this._maxFileSize;
    }
    if (this._maxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxSize = this._maxSize;
    }
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputWindowsMetricsPq | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._commitFrequency = undefined;
      this._compress = undefined;
      this._maxBufferSize = undefined;
      this._maxFileSize = undefined;
      this._maxSize = undefined;
      this._mode = undefined;
      this._path = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._commitFrequency = value.commitFrequency;
      this._compress = value.compress;
      this._maxBufferSize = value.maxBufferSize;
      this._maxFileSize = value.maxFileSize;
      this._maxSize = value.maxSize;
      this._mode = value.mode;
      this._path = value.path;
    }
  }

  // commit_frequency - computed: true, optional: true, required: false
  private _commitFrequency?: number; 
  public get commitFrequency() {
    return this.getNumberAttribute('commit_frequency');
  }
  public set commitFrequency(value: number) {
    this._commitFrequency = value;
  }
  public resetCommitFrequency() {
    this._commitFrequency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commitFrequencyInput() {
    return this._commitFrequency;
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: string; 
  public get compress() {
    return this.getStringAttribute('compress');
  }
  public set compress(value: string) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // max_buffer_size - computed: true, optional: true, required: false
  private _maxBufferSize?: number; 
  public get maxBufferSize() {
    return this.getNumberAttribute('max_buffer_size');
  }
  public set maxBufferSize(value: number) {
    this._maxBufferSize = value;
  }
  public resetMaxBufferSize() {
    this._maxBufferSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBufferSizeInput() {
    return this._maxBufferSize;
  }

  // max_file_size - computed: true, optional: true, required: false
  private _maxFileSize?: string; 
  public get maxFileSize() {
    return this.getStringAttribute('max_file_size');
  }
  public set maxFileSize(value: string) {
    this._maxFileSize = value;
  }
  public resetMaxFileSize() {
    this._maxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxFileSizeInput() {
    return this._maxFileSize;
  }

  // max_size - computed: true, optional: true, required: false
  private _maxSize?: string; 
  public get maxSize() {
    return this.getStringAttribute('max_size');
  }
  public set maxSize(value: string) {
    this._maxSize = value;
  }
  public resetMaxSize() {
    this._maxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxSizeInput() {
    return this._maxSize;
  }

  // mode - computed: true, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // path - computed: true, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }
}
export interface SourceInputWindowsMetricsProcessSets {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#filter Source#filter}
  */
  readonly filter: string;
  /**
  * Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#include_children Source#include_children}
  */
  readonly includeChildren?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#name Source#name}
  */
  readonly name: string;
}

export function sourceInputWindowsMetricsProcessSetsToTerraform(struct?: SourceInputWindowsMetricsProcessSets | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    filter: cdktf.stringToTerraform(struct!.filter),
    include_children: cdktf.booleanToTerraform(struct!.includeChildren),
    name: cdktf.stringToTerraform(struct!.name),
  }
}


export function sourceInputWindowsMetricsProcessSetsToHclTerraform(struct?: SourceInputWindowsMetricsProcessSets | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    filter: {
      value: cdktf.stringToHclTerraform(struct!.filter),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    include_children: {
      value: cdktf.booleanToHclTerraform(struct!.includeChildren),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputWindowsMetricsProcessSetsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): SourceInputWindowsMetricsProcessSets | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._filter !== undefined) {
      hasAnyValues = true;
      internalValueResult.filter = this._filter;
    }
    if (this._includeChildren !== undefined) {
      hasAnyValues = true;
      internalValueResult.includeChildren = this._includeChildren;
    }
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputWindowsMetricsProcessSets | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._filter = undefined;
      this._includeChildren = undefined;
      this._name = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._filter = value.filter;
      this._includeChildren = value.includeChildren;
      this._name = value.name;
    }
  }

  // filter - computed: false, optional: false, required: true
  private _filter?: string; 
  public get filter() {
    return this.getStringAttribute('filter');
  }
  public set filter(value: string) {
    this._filter = value;
  }
  // Temporarily expose input value. Use with caution.
  public get filterInput() {
    return this._filter;
  }

  // include_children - computed: true, optional: true, required: false
  private _includeChildren?: boolean | cdktf.IResolvable; 
  public get includeChildren() {
    return this.getBooleanAttribute('include_children');
  }
  public set includeChildren(value: boolean | cdktf.IResolvable) {
    this._includeChildren = value;
  }
  public resetIncludeChildren() {
    this._includeChildren = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get includeChildrenInput() {
    return this._includeChildren;
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }
}

export class SourceInputWindowsMetricsProcessSetsList extends cdktf.ComplexList {
  public internalValue? : SourceInputWindowsMetricsProcessSets[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): SourceInputWindowsMetricsProcessSetsOutputReference {
    return new SourceInputWindowsMetricsProcessSetsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface SourceInputWindowsMetricsProcess {
  /**
  * Configure sets to collect process metrics
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#sets Source#sets}
  */
  readonly sets?: SourceInputWindowsMetricsProcessSets[] | cdktf.IResolvable;
}

export function sourceInputWindowsMetricsProcessToTerraform(struct?: SourceInputWindowsMetricsProcess | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    sets: cdktf.listMapper(sourceInputWindowsMetricsProcessSetsToTerraform, false)(struct!.sets),
  }
}


export function sourceInputWindowsMetricsProcessToHclTerraform(struct?: SourceInputWindowsMetricsProcess | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    sets: {
      value: cdktf.listMapperHcl(sourceInputWindowsMetricsProcessSetsToHclTerraform, false)(struct!.sets),
      isBlock: true,
      type: "list",
      storageClassType: "SourceInputWindowsMetricsProcessSetsList",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputWindowsMetricsProcessOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SourceInputWindowsMetricsProcess | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._sets?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.sets = this._sets?.internalValue;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputWindowsMetricsProcess | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._sets.internalValue = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._sets.internalValue = value.sets;
    }
  }

  // sets - computed: false, optional: true, required: false
  private _sets = new SourceInputWindowsMetricsProcessSetsList(this, "sets", false);
  public get sets() {
    return this._sets;
  }
  public putSets(value: SourceInputWindowsMetricsProcessSets[] | cdktf.IResolvable) {
    this._sets.internalValue = value;
  }
  public resetSets() {
    this._sets.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get setsInput() {
    return this._sets.internalValue;
  }
}
export interface SourceInputWindowsMetrics {
  /**
  * Direct connections to Destinations, and optionally via a Pipeline or a Pack
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#connections Source#connections}
  */
  readonly connections?: SourceInputWindowsMetricsConnections[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#description Source#description}
  */
  readonly description?: string;
  /**
  * Enable to use built-in tools (PowerShell) to collect metrics instead of native API (default) [Learn more](https://docs.cribl.io/edge/sources-windows-metrics/#advanced-tab). Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#disable_native_module Source#disable_native_module}
  */
  readonly disableNativeModule?: boolean | cdktf.IResolvable;
  /**
  * Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#disabled Source#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#environment Source#environment}
  */
  readonly environment?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#host Source#host}
  */
  readonly host?: SourceInputWindowsMetricsHost;
  /**
  * Unique ID for this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#id Source#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id: string;
  /**
  * Time, in seconds, between consecutive metric collections. Default is 10 seconds. Default: 10
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#interval Source#interval}
  */
  readonly interval?: number;
  /**
  * Fields to add to events from this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#metadata Source#metadata}
  */
  readonly metadata?: SourceInputWindowsMetricsMetadata[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#persistence Source#persistence}
  */
  readonly persistence?: SourceInputWindowsMetricsPersistence;
  /**
  * Pipeline to process data from this Source before sending it through the Routes
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#pipeline Source#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#pq Source#pq}
  */
  readonly pq?: SourceInputWindowsMetricsPq;
  /**
  * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers). Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#pq_enabled Source#pq_enabled}
  */
  readonly pqEnabled?: boolean | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#process Source#process}
  */
  readonly process?: SourceInputWindowsMetricsProcess;
  /**
  * Select whether to send data to Routes, or directly to Destinations. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#send_to_routes Source#send_to_routes}
  */
  readonly sendToRoutes?: boolean | cdktf.IResolvable;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#streamtags Source#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * must be "windows_metrics"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#type Source#type}
  */
  readonly type: string;
}

export function sourceInputWindowsMetricsToTerraform(struct?: SourceInputWindowsMetrics | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    connections: cdktf.listMapper(sourceInputWindowsMetricsConnectionsToTerraform, false)(struct!.connections),
    description: cdktf.stringToTerraform(struct!.description),
    disable_native_module: cdktf.booleanToTerraform(struct!.disableNativeModule),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    environment: cdktf.stringToTerraform(struct!.environment),
    host: sourceInputWindowsMetricsHostToTerraform(struct!.host),
    id: cdktf.stringToTerraform(struct!.id),
    interval: cdktf.numberToTerraform(struct!.interval),
    metadata: cdktf.listMapper(sourceInputWindowsMetricsMetadataToTerraform, false)(struct!.metadata),
    persistence: sourceInputWindowsMetricsPersistenceToTerraform(struct!.persistence),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    pq: sourceInputWindowsMetricsPqToTerraform(struct!.pq),
    pq_enabled: cdktf.booleanToTerraform(struct!.pqEnabled),
    process: sourceInputWindowsMetricsProcessToTerraform(struct!.process),
    send_to_routes: cdktf.booleanToTerraform(struct!.sendToRoutes),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function sourceInputWindowsMetricsToHclTerraform(struct?: SourceInputWindowsMetrics | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    connections: {
      value: cdktf.listMapperHcl(sourceInputWindowsMetricsConnectionsToHclTerraform, false)(struct!.connections),
      isBlock: true,
      type: "list",
      storageClassType: "SourceInputWindowsMetricsConnectionsList",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disable_native_module: {
      value: cdktf.booleanToHclTerraform(struct!.disableNativeModule),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    host: {
      value: sourceInputWindowsMetricsHostToHclTerraform(struct!.host),
      isBlock: true,
      type: "struct",
      storageClassType: "SourceInputWindowsMetricsHost",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    interval: {
      value: cdktf.numberToHclTerraform(struct!.interval),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    metadata: {
      value: cdktf.listMapperHcl(sourceInputWindowsMetricsMetadataToHclTerraform, false)(struct!.metadata),
      isBlock: true,
      type: "list",
      storageClassType: "SourceInputWindowsMetricsMetadataList",
    },
    persistence: {
      value: sourceInputWindowsMetricsPersistenceToHclTerraform(struct!.persistence),
      isBlock: true,
      type: "struct",
      storageClassType: "SourceInputWindowsMetricsPersistence",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq: {
      value: sourceInputWindowsMetricsPqToHclTerraform(struct!.pq),
      isBlock: true,
      type: "struct",
      storageClassType: "SourceInputWindowsMetricsPq",
    },
    pq_enabled: {
      value: cdktf.booleanToHclTerraform(struct!.pqEnabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    process: {
      value: sourceInputWindowsMetricsProcessToHclTerraform(struct!.process),
      isBlock: true,
      type: "struct",
      storageClassType: "SourceInputWindowsMetricsProcess",
    },
    send_to_routes: {
      value: cdktf.booleanToHclTerraform(struct!.sendToRoutes),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputWindowsMetricsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SourceInputWindowsMetrics | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._connections?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.connections = this._connections?.internalValue;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._disableNativeModule !== undefined) {
      hasAnyValues = true;
      internalValueResult.disableNativeModule = this._disableNativeModule;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._host?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.host = this._host?.internalValue;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._interval !== undefined) {
      hasAnyValues = true;
      internalValueResult.interval = this._interval;
    }
    if (this._metadata?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadata = this._metadata?.internalValue;
    }
    if (this._persistence?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.persistence = this._persistence?.internalValue;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._pq?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pq = this._pq?.internalValue;
    }
    if (this._pqEnabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqEnabled = this._pqEnabled;
    }
    if (this._process?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.process = this._process?.internalValue;
    }
    if (this._sendToRoutes !== undefined) {
      hasAnyValues = true;
      internalValueResult.sendToRoutes = this._sendToRoutes;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputWindowsMetrics | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._connections.internalValue = undefined;
      this._description = undefined;
      this._disableNativeModule = undefined;
      this._disabled = undefined;
      this._environment = undefined;
      this._host.internalValue = undefined;
      this._id = undefined;
      this._interval = undefined;
      this._metadata.internalValue = undefined;
      this._persistence.internalValue = undefined;
      this._pipeline = undefined;
      this._pq.internalValue = undefined;
      this._pqEnabled = undefined;
      this._process.internalValue = undefined;
      this._sendToRoutes = undefined;
      this._streamtags = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._connections.internalValue = value.connections;
      this._description = value.description;
      this._disableNativeModule = value.disableNativeModule;
      this._disabled = value.disabled;
      this._environment = value.environment;
      this._host.internalValue = value.host;
      this._id = value.id;
      this._interval = value.interval;
      this._metadata.internalValue = value.metadata;
      this._persistence.internalValue = value.persistence;
      this._pipeline = value.pipeline;
      this._pq.internalValue = value.pq;
      this._pqEnabled = value.pqEnabled;
      this._process.internalValue = value.process;
      this._sendToRoutes = value.sendToRoutes;
      this._streamtags = value.streamtags;
      this._type = value.type;
    }
  }

  // connections - computed: false, optional: true, required: false
  private _connections = new SourceInputWindowsMetricsConnectionsList(this, "connections", false);
  public get connections() {
    return this._connections;
  }
  public putConnections(value: SourceInputWindowsMetricsConnections[] | cdktf.IResolvable) {
    this._connections.internalValue = value;
  }
  public resetConnections() {
    this._connections.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectionsInput() {
    return this._connections.internalValue;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // disable_native_module - computed: true, optional: true, required: false
  private _disableNativeModule?: boolean | cdktf.IResolvable; 
  public get disableNativeModule() {
    return this.getBooleanAttribute('disable_native_module');
  }
  public set disableNativeModule(value: boolean | cdktf.IResolvable) {
    this._disableNativeModule = value;
  }
  public resetDisableNativeModule() {
    this._disableNativeModule = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disableNativeModuleInput() {
    return this._disableNativeModule;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // host - computed: false, optional: true, required: false
  private _host = new SourceInputWindowsMetricsHostOutputReference(this, "host");
  public get host() {
    return this._host;
  }
  public putHost(value: SourceInputWindowsMetricsHost) {
    this._host.internalValue = value;
  }
  public resetHost() {
    this._host.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostInput() {
    return this._host.internalValue;
  }

  // id - computed: false, optional: false, required: true
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // interval - computed: true, optional: true, required: false
  private _interval?: number; 
  public get interval() {
    return this.getNumberAttribute('interval');
  }
  public set interval(value: number) {
    this._interval = value;
  }
  public resetInterval() {
    this._interval = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get intervalInput() {
    return this._interval;
  }

  // metadata - computed: false, optional: true, required: false
  private _metadata = new SourceInputWindowsMetricsMetadataList(this, "metadata", false);
  public get metadata() {
    return this._metadata;
  }
  public putMetadata(value: SourceInputWindowsMetricsMetadata[] | cdktf.IResolvable) {
    this._metadata.internalValue = value;
  }
  public resetMetadata() {
    this._metadata.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataInput() {
    return this._metadata.internalValue;
  }

  // persistence - computed: false, optional: true, required: false
  private _persistence = new SourceInputWindowsMetricsPersistenceOutputReference(this, "persistence");
  public get persistence() {
    return this._persistence;
  }
  public putPersistence(value: SourceInputWindowsMetricsPersistence) {
    this._persistence.internalValue = value;
  }
  public resetPersistence() {
    this._persistence.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get persistenceInput() {
    return this._persistence.internalValue;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // pq - computed: false, optional: true, required: false
  private _pq = new SourceInputWindowsMetricsPqOutputReference(this, "pq");
  public get pq() {
    return this._pq;
  }
  public putPq(value: SourceInputWindowsMetricsPq) {
    this._pq.internalValue = value;
  }
  public resetPq() {
    this._pq.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqInput() {
    return this._pq.internalValue;
  }

  // pq_enabled - computed: true, optional: true, required: false
  private _pqEnabled?: boolean | cdktf.IResolvable; 
  public get pqEnabled() {
    return this.getBooleanAttribute('pq_enabled');
  }
  public set pqEnabled(value: boolean | cdktf.IResolvable) {
    this._pqEnabled = value;
  }
  public resetPqEnabled() {
    this._pqEnabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqEnabledInput() {
    return this._pqEnabled;
  }

  // process - computed: false, optional: true, required: false
  private _process = new SourceInputWindowsMetricsProcessOutputReference(this, "process");
  public get process() {
    return this._process;
  }
  public putProcess(value: SourceInputWindowsMetricsProcess) {
    this._process.internalValue = value;
  }
  public resetProcess() {
    this._process.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get processInput() {
    return this._process.internalValue;
  }

  // send_to_routes - computed: true, optional: true, required: false
  private _sendToRoutes?: boolean | cdktf.IResolvable; 
  public get sendToRoutes() {
    return this.getBooleanAttribute('send_to_routes');
  }
  public set sendToRoutes(value: boolean | cdktf.IResolvable) {
    this._sendToRoutes = value;
  }
  public resetSendToRoutes() {
    this._sendToRoutes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sendToRoutesInput() {
    return this._sendToRoutes;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // type - computed: false, optional: false, required: true
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface SourceInputWizConnections {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#output Source#output}
  */
  readonly output: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#pipeline Source#pipeline}
  */
  readonly pipeline?: string;
}

export function sourceInputWizConnectionsToTerraform(struct?: SourceInputWizConnections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    output: cdktf.stringToTerraform(struct!.output),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
  }
}


export function sourceInputWizConnectionsToHclTerraform(struct?: SourceInputWizConnections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    output: {
      value: cdktf.stringToHclTerraform(struct!.output),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputWizConnectionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): SourceInputWizConnections | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._output !== undefined) {
      hasAnyValues = true;
      internalValueResult.output = this._output;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputWizConnections | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._output = undefined;
      this._pipeline = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._output = value.output;
      this._pipeline = value.pipeline;
    }
  }

  // output - computed: false, optional: false, required: true
  private _output?: string; 
  public get output() {
    return this.getStringAttribute('output');
  }
  public set output(value: string) {
    this._output = value;
  }
  // Temporarily expose input value. Use with caution.
  public get outputInput() {
    return this._output;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }
}

export class SourceInputWizConnectionsList extends cdktf.ComplexList {
  public internalValue? : SourceInputWizConnections[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): SourceInputWizConnectionsOutputReference {
    return new SourceInputWizConnectionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface SourceInputWizContentConfig {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#content_description Source#content_description}
  */
  readonly contentDescription?: string;
  /**
  * The name of the Wiz query
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#content_type Source#content_type}
  */
  readonly contentType: string;
  /**
  * Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#enabled Source#enabled}
  */
  readonly enabled?: boolean | cdktf.IResolvable;
}

export function sourceInputWizContentConfigToTerraform(struct?: SourceInputWizContentConfig | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    content_description: cdktf.stringToTerraform(struct!.contentDescription),
    content_type: cdktf.stringToTerraform(struct!.contentType),
    enabled: cdktf.booleanToTerraform(struct!.enabled),
  }
}


export function sourceInputWizContentConfigToHclTerraform(struct?: SourceInputWizContentConfig | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    content_description: {
      value: cdktf.stringToHclTerraform(struct!.contentDescription),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    content_type: {
      value: cdktf.stringToHclTerraform(struct!.contentType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    enabled: {
      value: cdktf.booleanToHclTerraform(struct!.enabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputWizContentConfigOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): SourceInputWizContentConfig | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._contentDescription !== undefined) {
      hasAnyValues = true;
      internalValueResult.contentDescription = this._contentDescription;
    }
    if (this._contentType !== undefined) {
      hasAnyValues = true;
      internalValueResult.contentType = this._contentType;
    }
    if (this._enabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.enabled = this._enabled;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputWizContentConfig | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._contentDescription = undefined;
      this._contentType = undefined;
      this._enabled = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._contentDescription = value.contentDescription;
      this._contentType = value.contentType;
      this._enabled = value.enabled;
    }
  }

  // content_description - computed: false, optional: true, required: false
  private _contentDescription?: string; 
  public get contentDescription() {
    return this.getStringAttribute('content_description');
  }
  public set contentDescription(value: string) {
    this._contentDescription = value;
  }
  public resetContentDescription() {
    this._contentDescription = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get contentDescriptionInput() {
    return this._contentDescription;
  }

  // content_type - computed: false, optional: false, required: true
  private _contentType?: string; 
  public get contentType() {
    return this.getStringAttribute('content_type');
  }
  public set contentType(value: string) {
    this._contentType = value;
  }
  // Temporarily expose input value. Use with caution.
  public get contentTypeInput() {
    return this._contentType;
  }

  // enabled - computed: true, optional: true, required: false
  private _enabled?: boolean | cdktf.IResolvable; 
  public get enabled() {
    return this.getBooleanAttribute('enabled');
  }
  public set enabled(value: boolean | cdktf.IResolvable) {
    this._enabled = value;
  }
  public resetEnabled() {
    this._enabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enabledInput() {
    return this._enabled;
  }
}

export class SourceInputWizContentConfigList extends cdktf.ComplexList {
  public internalValue? : SourceInputWizContentConfig[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): SourceInputWizContentConfigOutputReference {
    return new SourceInputWizContentConfigOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface SourceInputWizMetadata {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#name Source#name}
  */
  readonly name: string;
  /**
  * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#value Source#value}
  */
  readonly value: string;
}

export function sourceInputWizMetadataToTerraform(struct?: SourceInputWizMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function sourceInputWizMetadataToHclTerraform(struct?: SourceInputWizMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputWizMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): SourceInputWizMetadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputWizMetadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class SourceInputWizMetadataList extends cdktf.ComplexList {
  public internalValue? : SourceInputWizMetadata[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): SourceInputWizMetadataOutputReference {
    return new SourceInputWizMetadataOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface SourceInputWizPq {
  /**
  * The number of events to send downstream before committing that Stream has read them. Default: 42
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#commit_frequency Source#commit_frequency}
  */
  readonly commitFrequency?: number;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#compress Source#compress}
  */
  readonly compress?: string;
  /**
  * The maximum number of events to hold in memory before writing the events to disk. Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_buffer_size Source#max_buffer_size}
  */
  readonly maxBufferSize?: number;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc. Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_file_size Source#max_file_size}
  */
  readonly maxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_size Source#max_size}
  */
  readonly maxSize?: string;
  /**
  * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine. Default: "always"; must be one of ["smart", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#mode Source#mode}
  */
  readonly mode?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#path Source#path}
  */
  readonly path?: string;
}

export function sourceInputWizPqToTerraform(struct?: SourceInputWizPq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    commit_frequency: cdktf.numberToTerraform(struct!.commitFrequency),
    compress: cdktf.stringToTerraform(struct!.compress),
    max_buffer_size: cdktf.numberToTerraform(struct!.maxBufferSize),
    max_file_size: cdktf.stringToTerraform(struct!.maxFileSize),
    max_size: cdktf.stringToTerraform(struct!.maxSize),
    mode: cdktf.stringToTerraform(struct!.mode),
    path: cdktf.stringToTerraform(struct!.path),
  }
}


export function sourceInputWizPqToHclTerraform(struct?: SourceInputWizPq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    commit_frequency: {
      value: cdktf.numberToHclTerraform(struct!.commitFrequency),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    compress: {
      value: cdktf.stringToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_buffer_size: {
      value: cdktf.numberToHclTerraform(struct!.maxBufferSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.maxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_size: {
      value: cdktf.stringToHclTerraform(struct!.maxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputWizPqOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SourceInputWizPq | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._commitFrequency !== undefined) {
      hasAnyValues = true;
      internalValueResult.commitFrequency = this._commitFrequency;
    }
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._maxBufferSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBufferSize = this._maxBufferSize;
    }
    if (this._maxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxFileSize = this._maxFileSize;
    }
    if (this._maxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxSize = this._maxSize;
    }
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputWizPq | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._commitFrequency = undefined;
      this._compress = undefined;
      this._maxBufferSize = undefined;
      this._maxFileSize = undefined;
      this._maxSize = undefined;
      this._mode = undefined;
      this._path = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._commitFrequency = value.commitFrequency;
      this._compress = value.compress;
      this._maxBufferSize = value.maxBufferSize;
      this._maxFileSize = value.maxFileSize;
      this._maxSize = value.maxSize;
      this._mode = value.mode;
      this._path = value.path;
    }
  }

  // commit_frequency - computed: true, optional: true, required: false
  private _commitFrequency?: number; 
  public get commitFrequency() {
    return this.getNumberAttribute('commit_frequency');
  }
  public set commitFrequency(value: number) {
    this._commitFrequency = value;
  }
  public resetCommitFrequency() {
    this._commitFrequency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commitFrequencyInput() {
    return this._commitFrequency;
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: string; 
  public get compress() {
    return this.getStringAttribute('compress');
  }
  public set compress(value: string) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // max_buffer_size - computed: true, optional: true, required: false
  private _maxBufferSize?: number; 
  public get maxBufferSize() {
    return this.getNumberAttribute('max_buffer_size');
  }
  public set maxBufferSize(value: number) {
    this._maxBufferSize = value;
  }
  public resetMaxBufferSize() {
    this._maxBufferSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBufferSizeInput() {
    return this._maxBufferSize;
  }

  // max_file_size - computed: true, optional: true, required: false
  private _maxFileSize?: string; 
  public get maxFileSize() {
    return this.getStringAttribute('max_file_size');
  }
  public set maxFileSize(value: string) {
    this._maxFileSize = value;
  }
  public resetMaxFileSize() {
    this._maxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxFileSizeInput() {
    return this._maxFileSize;
  }

  // max_size - computed: true, optional: true, required: false
  private _maxSize?: string; 
  public get maxSize() {
    return this.getStringAttribute('max_size');
  }
  public set maxSize(value: string) {
    this._maxSize = value;
  }
  public resetMaxSize() {
    this._maxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxSizeInput() {
    return this._maxSize;
  }

  // mode - computed: true, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // path - computed: true, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }
}
export interface SourceInputWizRetryRules {
  /**
  * List of HTTP codes that trigger a retry. Leave empty to use the default list of 429 and 503. Default: [429,503]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#codes Source#codes}
  */
  readonly codes?: number[];
  /**
  * Honor any Retry-After header that specifies a delay (in seconds) or a timestamp after which to retry the request. The delay is limited to 20 seconds, even if the Retry-After header specifies a longer delay. When disabled, all Retry-After headers are ignored. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#enable_header Source#enable_header}
  */
  readonly enableHeader?: boolean | cdktf.IResolvable;
  /**
  * Time interval between failed request and first retry (kickoff). Maximum allowed value is 20,000 ms (1/3 minute). Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#interval Source#interval}
  */
  readonly interval?: number;
  /**
  * The maximum number of times to retry a failed HTTP request. Default: 5
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#limit Source#limit}
  */
  readonly limit?: number;
  /**
  * Base for exponential backoff, e.g., base 2 means that retries will occur after 2, then 4, then 8 seconds, and so on. Default: 2
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#multiplier Source#multiplier}
  */
  readonly multiplier?: number;
  /**
  * Retry request when a connection reset (ECONNRESET) error occurs. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#retry_connect_reset Source#retry_connect_reset}
  */
  readonly retryConnectReset?: boolean | cdktf.IResolvable;
  /**
  * Make a single retry attempt when a connection timeout (ETIMEDOUT) error occurs. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#retry_connect_timeout Source#retry_connect_timeout}
  */
  readonly retryConnectTimeout?: boolean | cdktf.IResolvable;
  /**
  * The algorithm to use when performing HTTP retries. Default: "backoff"; must be one of ["none", "backoff", "static"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#type Source#type}
  */
  readonly type?: string;
}

export function sourceInputWizRetryRulesToTerraform(struct?: SourceInputWizRetryRules | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    codes: cdktf.listMapper(cdktf.numberToTerraform, false)(struct!.codes),
    enable_header: cdktf.booleanToTerraform(struct!.enableHeader),
    interval: cdktf.numberToTerraform(struct!.interval),
    limit: cdktf.numberToTerraform(struct!.limit),
    multiplier: cdktf.numberToTerraform(struct!.multiplier),
    retry_connect_reset: cdktf.booleanToTerraform(struct!.retryConnectReset),
    retry_connect_timeout: cdktf.booleanToTerraform(struct!.retryConnectTimeout),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function sourceInputWizRetryRulesToHclTerraform(struct?: SourceInputWizRetryRules | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    codes: {
      value: cdktf.listMapperHcl(cdktf.numberToHclTerraform, false)(struct!.codes),
      isBlock: false,
      type: "list",
      storageClassType: "numberList",
    },
    enable_header: {
      value: cdktf.booleanToHclTerraform(struct!.enableHeader),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    interval: {
      value: cdktf.numberToHclTerraform(struct!.interval),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    limit: {
      value: cdktf.numberToHclTerraform(struct!.limit),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    multiplier: {
      value: cdktf.numberToHclTerraform(struct!.multiplier),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    retry_connect_reset: {
      value: cdktf.booleanToHclTerraform(struct!.retryConnectReset),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    retry_connect_timeout: {
      value: cdktf.booleanToHclTerraform(struct!.retryConnectTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputWizRetryRulesOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SourceInputWizRetryRules | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._codes !== undefined) {
      hasAnyValues = true;
      internalValueResult.codes = this._codes;
    }
    if (this._enableHeader !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableHeader = this._enableHeader;
    }
    if (this._interval !== undefined) {
      hasAnyValues = true;
      internalValueResult.interval = this._interval;
    }
    if (this._limit !== undefined) {
      hasAnyValues = true;
      internalValueResult.limit = this._limit;
    }
    if (this._multiplier !== undefined) {
      hasAnyValues = true;
      internalValueResult.multiplier = this._multiplier;
    }
    if (this._retryConnectReset !== undefined) {
      hasAnyValues = true;
      internalValueResult.retryConnectReset = this._retryConnectReset;
    }
    if (this._retryConnectTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.retryConnectTimeout = this._retryConnectTimeout;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputWizRetryRules | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._codes = undefined;
      this._enableHeader = undefined;
      this._interval = undefined;
      this._limit = undefined;
      this._multiplier = undefined;
      this._retryConnectReset = undefined;
      this._retryConnectTimeout = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._codes = value.codes;
      this._enableHeader = value.enableHeader;
      this._interval = value.interval;
      this._limit = value.limit;
      this._multiplier = value.multiplier;
      this._retryConnectReset = value.retryConnectReset;
      this._retryConnectTimeout = value.retryConnectTimeout;
      this._type = value.type;
    }
  }

  // codes - computed: true, optional: true, required: false
  private _codes?: number[]; 
  public get codes() {
    return this.getNumberListAttribute('codes');
  }
  public set codes(value: number[]) {
    this._codes = value;
  }
  public resetCodes() {
    this._codes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get codesInput() {
    return this._codes;
  }

  // enable_header - computed: true, optional: true, required: false
  private _enableHeader?: boolean | cdktf.IResolvable; 
  public get enableHeader() {
    return this.getBooleanAttribute('enable_header');
  }
  public set enableHeader(value: boolean | cdktf.IResolvable) {
    this._enableHeader = value;
  }
  public resetEnableHeader() {
    this._enableHeader = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableHeaderInput() {
    return this._enableHeader;
  }

  // interval - computed: true, optional: true, required: false
  private _interval?: number; 
  public get interval() {
    return this.getNumberAttribute('interval');
  }
  public set interval(value: number) {
    this._interval = value;
  }
  public resetInterval() {
    this._interval = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get intervalInput() {
    return this._interval;
  }

  // limit - computed: true, optional: true, required: false
  private _limit?: number; 
  public get limit() {
    return this.getNumberAttribute('limit');
  }
  public set limit(value: number) {
    this._limit = value;
  }
  public resetLimit() {
    this._limit = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get limitInput() {
    return this._limit;
  }

  // multiplier - computed: true, optional: true, required: false
  private _multiplier?: number; 
  public get multiplier() {
    return this.getNumberAttribute('multiplier');
  }
  public set multiplier(value: number) {
    this._multiplier = value;
  }
  public resetMultiplier() {
    this._multiplier = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get multiplierInput() {
    return this._multiplier;
  }

  // retry_connect_reset - computed: true, optional: true, required: false
  private _retryConnectReset?: boolean | cdktf.IResolvable; 
  public get retryConnectReset() {
    return this.getBooleanAttribute('retry_connect_reset');
  }
  public set retryConnectReset(value: boolean | cdktf.IResolvable) {
    this._retryConnectReset = value;
  }
  public resetRetryConnectReset() {
    this._retryConnectReset = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get retryConnectResetInput() {
    return this._retryConnectReset;
  }

  // retry_connect_timeout - computed: true, optional: true, required: false
  private _retryConnectTimeout?: boolean | cdktf.IResolvable; 
  public get retryConnectTimeout() {
    return this.getBooleanAttribute('retry_connect_timeout');
  }
  public set retryConnectTimeout(value: boolean | cdktf.IResolvable) {
    this._retryConnectTimeout = value;
  }
  public resetRetryConnectTimeout() {
    this._retryConnectTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get retryConnectTimeoutInput() {
    return this._retryConnectTimeout;
  }

  // type - computed: true, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface SourceInputWiz {
  /**
  * The audience to use when requesting an OAuth token for a custom auth URL. When not specified, `wiz-api` will be used.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#auth_audience_override Source#auth_audience_override}
  */
  readonly authAudienceOverride?: string;
  /**
  * Enter client secret directly, or select a stored secret. Default: "manual"; must be one of ["manual", "secret"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#auth_type Source#auth_type}
  */
  readonly authType?: string;
  /**
  * The authentication URL to generate an OAuth token
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#auth_url Source#auth_url}
  */
  readonly authUrl: string;
  /**
  * The client ID of the Wiz application
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#client_id Source#client_id}
  */
  readonly clientId: string;
  /**
  * The client secret of the Wiz application
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#client_secret Source#client_secret}
  */
  readonly clientSecret?: string;
  /**
  * Direct connections to Destinations, and optionally via a Pipeline or a Pack
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#connections Source#connections}
  */
  readonly connections?: SourceInputWizConnections[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#content_config Source#content_config}
  */
  readonly contentConfig?: SourceInputWizContentConfig[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#description Source#description}
  */
  readonly description?: string;
  /**
  * Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#disabled Source#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * The Wiz GraphQL API endpoint. Example: https://api.us1.app.wiz.io/graphql. Default: "https://api.<region>.app.wiz.io/graphql"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#endpoint Source#endpoint}
  */
  readonly endpoint?: string;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#environment Source#environment}
  */
  readonly environment?: string;
  /**
  * Unique ID for this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#id Source#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * When enabled, this job's artifacts are not counted toward the Worker Group's finished job artifacts limit. Artifacts will be removed only after the Collector's configured time to live. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#ignore_group_jobs_limit Source#ignore_group_jobs_limit}
  */
  readonly ignoreGroupJobsLimit?: boolean | cdktf.IResolvable;
  /**
  * How often workers should check in with the scheduler to keep job subscription alive. Default: 30
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#keep_alive_time Source#keep_alive_time}
  */
  readonly keepAliveTime?: number;
  /**
  * The number of Keep Alive Time periods before an inactive worker will have its job subscription revoked. Default: 3
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_missed_keep_alives Source#max_missed_keep_alives}
  */
  readonly maxMissedKeepAlives?: number;
  /**
  * Fields to add to events from this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#metadata Source#metadata}
  */
  readonly metadata?: SourceInputWizMetadata[] | cdktf.IResolvable;
  /**
  * Pipeline to process data from this Source before sending it through the Routes
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#pipeline Source#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#pq Source#pq}
  */
  readonly pq?: SourceInputWizPq;
  /**
  * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers). Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#pq_enabled Source#pq_enabled}
  */
  readonly pqEnabled?: boolean | cdktf.IResolvable;
  /**
  * HTTP request inactivity timeout. Use 0 to disable. Default: 300
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#request_timeout Source#request_timeout}
  */
  readonly requestTimeout?: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#retry_rules Source#retry_rules}
  */
  readonly retryRules?: SourceInputWizRetryRules;
  /**
  * Select whether to send data to Routes, or directly to Destinations. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#send_to_routes Source#send_to_routes}
  */
  readonly sendToRoutes?: boolean | cdktf.IResolvable;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#streamtags Source#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Select or create a stored text secret
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#text_secret Source#text_secret}
  */
  readonly textSecret?: string;
  /**
  * Time to keep the job's artifacts on disk after job completion. This also affects how long a job is listed in the Job Inspector. Default: "4h"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#ttl Source#ttl}
  */
  readonly ttl?: string;
  /**
  * must be "wiz"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#type Source#type}
  */
  readonly type?: string;
}

export function sourceInputWizToTerraform(struct?: SourceInputWiz | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    auth_audience_override: cdktf.stringToTerraform(struct!.authAudienceOverride),
    auth_type: cdktf.stringToTerraform(struct!.authType),
    auth_url: cdktf.stringToTerraform(struct!.authUrl),
    client_id: cdktf.stringToTerraform(struct!.clientId),
    client_secret: cdktf.stringToTerraform(struct!.clientSecret),
    connections: cdktf.listMapper(sourceInputWizConnectionsToTerraform, false)(struct!.connections),
    content_config: cdktf.listMapper(sourceInputWizContentConfigToTerraform, false)(struct!.contentConfig),
    description: cdktf.stringToTerraform(struct!.description),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    endpoint: cdktf.stringToTerraform(struct!.endpoint),
    environment: cdktf.stringToTerraform(struct!.environment),
    id: cdktf.stringToTerraform(struct!.id),
    ignore_group_jobs_limit: cdktf.booleanToTerraform(struct!.ignoreGroupJobsLimit),
    keep_alive_time: cdktf.numberToTerraform(struct!.keepAliveTime),
    max_missed_keep_alives: cdktf.numberToTerraform(struct!.maxMissedKeepAlives),
    metadata: cdktf.listMapper(sourceInputWizMetadataToTerraform, false)(struct!.metadata),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    pq: sourceInputWizPqToTerraform(struct!.pq),
    pq_enabled: cdktf.booleanToTerraform(struct!.pqEnabled),
    request_timeout: cdktf.numberToTerraform(struct!.requestTimeout),
    retry_rules: sourceInputWizRetryRulesToTerraform(struct!.retryRules),
    send_to_routes: cdktf.booleanToTerraform(struct!.sendToRoutes),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    text_secret: cdktf.stringToTerraform(struct!.textSecret),
    ttl: cdktf.stringToTerraform(struct!.ttl),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function sourceInputWizToHclTerraform(struct?: SourceInputWiz | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    auth_audience_override: {
      value: cdktf.stringToHclTerraform(struct!.authAudienceOverride),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    auth_type: {
      value: cdktf.stringToHclTerraform(struct!.authType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    auth_url: {
      value: cdktf.stringToHclTerraform(struct!.authUrl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    client_id: {
      value: cdktf.stringToHclTerraform(struct!.clientId),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    client_secret: {
      value: cdktf.stringToHclTerraform(struct!.clientSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    connections: {
      value: cdktf.listMapperHcl(sourceInputWizConnectionsToHclTerraform, false)(struct!.connections),
      isBlock: true,
      type: "list",
      storageClassType: "SourceInputWizConnectionsList",
    },
    content_config: {
      value: cdktf.listMapperHcl(sourceInputWizContentConfigToHclTerraform, false)(struct!.contentConfig),
      isBlock: true,
      type: "list",
      storageClassType: "SourceInputWizContentConfigList",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    endpoint: {
      value: cdktf.stringToHclTerraform(struct!.endpoint),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ignore_group_jobs_limit: {
      value: cdktf.booleanToHclTerraform(struct!.ignoreGroupJobsLimit),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    keep_alive_time: {
      value: cdktf.numberToHclTerraform(struct!.keepAliveTime),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_missed_keep_alives: {
      value: cdktf.numberToHclTerraform(struct!.maxMissedKeepAlives),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    metadata: {
      value: cdktf.listMapperHcl(sourceInputWizMetadataToHclTerraform, false)(struct!.metadata),
      isBlock: true,
      type: "list",
      storageClassType: "SourceInputWizMetadataList",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pq: {
      value: sourceInputWizPqToHclTerraform(struct!.pq),
      isBlock: true,
      type: "struct",
      storageClassType: "SourceInputWizPq",
    },
    pq_enabled: {
      value: cdktf.booleanToHclTerraform(struct!.pqEnabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    request_timeout: {
      value: cdktf.numberToHclTerraform(struct!.requestTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    retry_rules: {
      value: sourceInputWizRetryRulesToHclTerraform(struct!.retryRules),
      isBlock: true,
      type: "struct",
      storageClassType: "SourceInputWizRetryRules",
    },
    send_to_routes: {
      value: cdktf.booleanToHclTerraform(struct!.sendToRoutes),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    text_secret: {
      value: cdktf.stringToHclTerraform(struct!.textSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ttl: {
      value: cdktf.stringToHclTerraform(struct!.ttl),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputWizOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SourceInputWiz | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._authAudienceOverride !== undefined) {
      hasAnyValues = true;
      internalValueResult.authAudienceOverride = this._authAudienceOverride;
    }
    if (this._authType !== undefined) {
      hasAnyValues = true;
      internalValueResult.authType = this._authType;
    }
    if (this._authUrl !== undefined) {
      hasAnyValues = true;
      internalValueResult.authUrl = this._authUrl;
    }
    if (this._clientId !== undefined) {
      hasAnyValues = true;
      internalValueResult.clientId = this._clientId;
    }
    if (this._clientSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.clientSecret = this._clientSecret;
    }
    if (this._connections?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.connections = this._connections?.internalValue;
    }
    if (this._contentConfig?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.contentConfig = this._contentConfig?.internalValue;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._endpoint !== undefined) {
      hasAnyValues = true;
      internalValueResult.endpoint = this._endpoint;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._ignoreGroupJobsLimit !== undefined) {
      hasAnyValues = true;
      internalValueResult.ignoreGroupJobsLimit = this._ignoreGroupJobsLimit;
    }
    if (this._keepAliveTime !== undefined) {
      hasAnyValues = true;
      internalValueResult.keepAliveTime = this._keepAliveTime;
    }
    if (this._maxMissedKeepAlives !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxMissedKeepAlives = this._maxMissedKeepAlives;
    }
    if (this._metadata?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadata = this._metadata?.internalValue;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._pq?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pq = this._pq?.internalValue;
    }
    if (this._pqEnabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqEnabled = this._pqEnabled;
    }
    if (this._requestTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.requestTimeout = this._requestTimeout;
    }
    if (this._retryRules?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.retryRules = this._retryRules?.internalValue;
    }
    if (this._sendToRoutes !== undefined) {
      hasAnyValues = true;
      internalValueResult.sendToRoutes = this._sendToRoutes;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._textSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.textSecret = this._textSecret;
    }
    if (this._ttl !== undefined) {
      hasAnyValues = true;
      internalValueResult.ttl = this._ttl;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputWiz | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._authAudienceOverride = undefined;
      this._authType = undefined;
      this._authUrl = undefined;
      this._clientId = undefined;
      this._clientSecret = undefined;
      this._connections.internalValue = undefined;
      this._contentConfig.internalValue = undefined;
      this._description = undefined;
      this._disabled = undefined;
      this._endpoint = undefined;
      this._environment = undefined;
      this._id = undefined;
      this._ignoreGroupJobsLimit = undefined;
      this._keepAliveTime = undefined;
      this._maxMissedKeepAlives = undefined;
      this._metadata.internalValue = undefined;
      this._pipeline = undefined;
      this._pq.internalValue = undefined;
      this._pqEnabled = undefined;
      this._requestTimeout = undefined;
      this._retryRules.internalValue = undefined;
      this._sendToRoutes = undefined;
      this._streamtags = undefined;
      this._textSecret = undefined;
      this._ttl = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._authAudienceOverride = value.authAudienceOverride;
      this._authType = value.authType;
      this._authUrl = value.authUrl;
      this._clientId = value.clientId;
      this._clientSecret = value.clientSecret;
      this._connections.internalValue = value.connections;
      this._contentConfig.internalValue = value.contentConfig;
      this._description = value.description;
      this._disabled = value.disabled;
      this._endpoint = value.endpoint;
      this._environment = value.environment;
      this._id = value.id;
      this._ignoreGroupJobsLimit = value.ignoreGroupJobsLimit;
      this._keepAliveTime = value.keepAliveTime;
      this._maxMissedKeepAlives = value.maxMissedKeepAlives;
      this._metadata.internalValue = value.metadata;
      this._pipeline = value.pipeline;
      this._pq.internalValue = value.pq;
      this._pqEnabled = value.pqEnabled;
      this._requestTimeout = value.requestTimeout;
      this._retryRules.internalValue = value.retryRules;
      this._sendToRoutes = value.sendToRoutes;
      this._streamtags = value.streamtags;
      this._textSecret = value.textSecret;
      this._ttl = value.ttl;
      this._type = value.type;
    }
  }

  // auth_audience_override - computed: false, optional: true, required: false
  private _authAudienceOverride?: string; 
  public get authAudienceOverride() {
    return this.getStringAttribute('auth_audience_override');
  }
  public set authAudienceOverride(value: string) {
    this._authAudienceOverride = value;
  }
  public resetAuthAudienceOverride() {
    this._authAudienceOverride = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authAudienceOverrideInput() {
    return this._authAudienceOverride;
  }

  // auth_type - computed: true, optional: true, required: false
  private _authType?: string; 
  public get authType() {
    return this.getStringAttribute('auth_type');
  }
  public set authType(value: string) {
    this._authType = value;
  }
  public resetAuthType() {
    this._authType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authTypeInput() {
    return this._authType;
  }

  // auth_url - computed: false, optional: false, required: true
  private _authUrl?: string; 
  public get authUrl() {
    return this.getStringAttribute('auth_url');
  }
  public set authUrl(value: string) {
    this._authUrl = value;
  }
  // Temporarily expose input value. Use with caution.
  public get authUrlInput() {
    return this._authUrl;
  }

  // client_id - computed: false, optional: false, required: true
  private _clientId?: string; 
  public get clientId() {
    return this.getStringAttribute('client_id');
  }
  public set clientId(value: string) {
    this._clientId = value;
  }
  // Temporarily expose input value. Use with caution.
  public get clientIdInput() {
    return this._clientId;
  }

  // client_secret - computed: false, optional: true, required: false
  private _clientSecret?: string; 
  public get clientSecret() {
    return this.getStringAttribute('client_secret');
  }
  public set clientSecret(value: string) {
    this._clientSecret = value;
  }
  public resetClientSecret() {
    this._clientSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get clientSecretInput() {
    return this._clientSecret;
  }

  // connections - computed: false, optional: true, required: false
  private _connections = new SourceInputWizConnectionsList(this, "connections", false);
  public get connections() {
    return this._connections;
  }
  public putConnections(value: SourceInputWizConnections[] | cdktf.IResolvable) {
    this._connections.internalValue = value;
  }
  public resetConnections() {
    this._connections.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectionsInput() {
    return this._connections.internalValue;
  }

  // content_config - computed: false, optional: true, required: false
  private _contentConfig = new SourceInputWizContentConfigList(this, "content_config", false);
  public get contentConfig() {
    return this._contentConfig;
  }
  public putContentConfig(value: SourceInputWizContentConfig[] | cdktf.IResolvable) {
    this._contentConfig.internalValue = value;
  }
  public resetContentConfig() {
    this._contentConfig.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get contentConfigInput() {
    return this._contentConfig.internalValue;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // endpoint - computed: true, optional: true, required: false
  private _endpoint?: string; 
  public get endpoint() {
    return this.getStringAttribute('endpoint');
  }
  public set endpoint(value: string) {
    this._endpoint = value;
  }
  public resetEndpoint() {
    this._endpoint = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get endpointInput() {
    return this._endpoint;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // ignore_group_jobs_limit - computed: true, optional: true, required: false
  private _ignoreGroupJobsLimit?: boolean | cdktf.IResolvable; 
  public get ignoreGroupJobsLimit() {
    return this.getBooleanAttribute('ignore_group_jobs_limit');
  }
  public set ignoreGroupJobsLimit(value: boolean | cdktf.IResolvable) {
    this._ignoreGroupJobsLimit = value;
  }
  public resetIgnoreGroupJobsLimit() {
    this._ignoreGroupJobsLimit = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ignoreGroupJobsLimitInput() {
    return this._ignoreGroupJobsLimit;
  }

  // keep_alive_time - computed: true, optional: true, required: false
  private _keepAliveTime?: number; 
  public get keepAliveTime() {
    return this.getNumberAttribute('keep_alive_time');
  }
  public set keepAliveTime(value: number) {
    this._keepAliveTime = value;
  }
  public resetKeepAliveTime() {
    this._keepAliveTime = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keepAliveTimeInput() {
    return this._keepAliveTime;
  }

  // max_missed_keep_alives - computed: true, optional: true, required: false
  private _maxMissedKeepAlives?: number; 
  public get maxMissedKeepAlives() {
    return this.getNumberAttribute('max_missed_keep_alives');
  }
  public set maxMissedKeepAlives(value: number) {
    this._maxMissedKeepAlives = value;
  }
  public resetMaxMissedKeepAlives() {
    this._maxMissedKeepAlives = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxMissedKeepAlivesInput() {
    return this._maxMissedKeepAlives;
  }

  // metadata - computed: false, optional: true, required: false
  private _metadata = new SourceInputWizMetadataList(this, "metadata", false);
  public get metadata() {
    return this._metadata;
  }
  public putMetadata(value: SourceInputWizMetadata[] | cdktf.IResolvable) {
    this._metadata.internalValue = value;
  }
  public resetMetadata() {
    this._metadata.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataInput() {
    return this._metadata.internalValue;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // pq - computed: false, optional: true, required: false
  private _pq = new SourceInputWizPqOutputReference(this, "pq");
  public get pq() {
    return this._pq;
  }
  public putPq(value: SourceInputWizPq) {
    this._pq.internalValue = value;
  }
  public resetPq() {
    this._pq.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqInput() {
    return this._pq.internalValue;
  }

  // pq_enabled - computed: true, optional: true, required: false
  private _pqEnabled?: boolean | cdktf.IResolvable; 
  public get pqEnabled() {
    return this.getBooleanAttribute('pq_enabled');
  }
  public set pqEnabled(value: boolean | cdktf.IResolvable) {
    this._pqEnabled = value;
  }
  public resetPqEnabled() {
    this._pqEnabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqEnabledInput() {
    return this._pqEnabled;
  }

  // request_timeout - computed: true, optional: true, required: false
  private _requestTimeout?: number; 
  public get requestTimeout() {
    return this.getNumberAttribute('request_timeout');
  }
  public set requestTimeout(value: number) {
    this._requestTimeout = value;
  }
  public resetRequestTimeout() {
    this._requestTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestTimeoutInput() {
    return this._requestTimeout;
  }

  // retry_rules - computed: false, optional: true, required: false
  private _retryRules = new SourceInputWizRetryRulesOutputReference(this, "retry_rules");
  public get retryRules() {
    return this._retryRules;
  }
  public putRetryRules(value: SourceInputWizRetryRules) {
    this._retryRules.internalValue = value;
  }
  public resetRetryRules() {
    this._retryRules.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get retryRulesInput() {
    return this._retryRules.internalValue;
  }

  // send_to_routes - computed: true, optional: true, required: false
  private _sendToRoutes?: boolean | cdktf.IResolvable; 
  public get sendToRoutes() {
    return this.getBooleanAttribute('send_to_routes');
  }
  public set sendToRoutes(value: boolean | cdktf.IResolvable) {
    this._sendToRoutes = value;
  }
  public resetSendToRoutes() {
    this._sendToRoutes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sendToRoutesInput() {
    return this._sendToRoutes;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // text_secret - computed: false, optional: true, required: false
  private _textSecret?: string; 
  public get textSecret() {
    return this.getStringAttribute('text_secret');
  }
  public set textSecret(value: string) {
    this._textSecret = value;
  }
  public resetTextSecret() {
    this._textSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get textSecretInput() {
    return this._textSecret;
  }

  // ttl - computed: true, optional: true, required: false
  private _ttl?: string; 
  public get ttl() {
    return this.getStringAttribute('ttl');
  }
  public set ttl(value: string) {
    this._ttl = value;
  }
  public resetTtl() {
    this._ttl = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ttlInput() {
    return this._ttl;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
export interface SourceInputZscalerHecAuthTokensMetadata {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#name Source#name}
  */
  readonly name: string;
  /**
  * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#value Source#value}
  */
  readonly value: string;
}

export function sourceInputZscalerHecAuthTokensMetadataToTerraform(struct?: SourceInputZscalerHecAuthTokensMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function sourceInputZscalerHecAuthTokensMetadataToHclTerraform(struct?: SourceInputZscalerHecAuthTokensMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputZscalerHecAuthTokensMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): SourceInputZscalerHecAuthTokensMetadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputZscalerHecAuthTokensMetadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class SourceInputZscalerHecAuthTokensMetadataList extends cdktf.ComplexList {
  public internalValue? : SourceInputZscalerHecAuthTokensMetadata[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): SourceInputZscalerHecAuthTokensMetadataOutputReference {
    return new SourceInputZscalerHecAuthTokensMetadataOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface SourceInputZscalerHecAuthTokens {
  /**
  * Enter the values you want to allow in the HEC event index field at the token level. Supports wildcards. To skip validation, leave blank.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#allowed_indexes_at_token Source#allowed_indexes_at_token}
  */
  readonly allowedIndexesAtToken?: string[];
  /**
  * Select Manual to enter an auth token directly, or select Secret to use a text secret to authenticate. Default: "manual"; must be one of ["manual", "secret"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#auth_type Source#auth_type}
  */
  readonly authType?: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#description Source#description}
  */
  readonly description?: string;
  /**
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#enabled Source#enabled}
  */
  readonly enabled?: boolean | cdktf.IResolvable;
  /**
  * Fields to add to events referencing this token
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#metadata Source#metadata}
  */
  readonly metadata?: SourceInputZscalerHecAuthTokensMetadata[] | cdktf.IResolvable;
  /**
  * Parsed as JSON.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#token Source#token}
  */
  readonly token: string;
  /**
  * Parsed as JSON.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#token_secret Source#token_secret}
  */
  readonly tokenSecret?: string;
}

export function sourceInputZscalerHecAuthTokensToTerraform(struct?: SourceInputZscalerHecAuthTokens | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    allowed_indexes_at_token: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.allowedIndexesAtToken),
    auth_type: cdktf.stringToTerraform(struct!.authType),
    description: cdktf.stringToTerraform(struct!.description),
    enabled: cdktf.booleanToTerraform(struct!.enabled),
    metadata: cdktf.listMapper(sourceInputZscalerHecAuthTokensMetadataToTerraform, false)(struct!.metadata),
    token: cdktf.stringToTerraform(struct!.token),
    token_secret: cdktf.stringToTerraform(struct!.tokenSecret),
  }
}


export function sourceInputZscalerHecAuthTokensToHclTerraform(struct?: SourceInputZscalerHecAuthTokens | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    allowed_indexes_at_token: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.allowedIndexesAtToken),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    auth_type: {
      value: cdktf.stringToHclTerraform(struct!.authType),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    enabled: {
      value: cdktf.booleanToHclTerraform(struct!.enabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    metadata: {
      value: cdktf.listMapperHcl(sourceInputZscalerHecAuthTokensMetadataToHclTerraform, false)(struct!.metadata),
      isBlock: true,
      type: "list",
      storageClassType: "SourceInputZscalerHecAuthTokensMetadataList",
    },
    token: {
      value: cdktf.stringToHclTerraform(struct!.token),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    token_secret: {
      value: cdktf.stringToHclTerraform(struct!.tokenSecret),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputZscalerHecAuthTokensOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): SourceInputZscalerHecAuthTokens | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._allowedIndexesAtToken !== undefined) {
      hasAnyValues = true;
      internalValueResult.allowedIndexesAtToken = this._allowedIndexesAtToken;
    }
    if (this._authType !== undefined) {
      hasAnyValues = true;
      internalValueResult.authType = this._authType;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._enabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.enabled = this._enabled;
    }
    if (this._metadata?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadata = this._metadata?.internalValue;
    }
    if (this._token !== undefined) {
      hasAnyValues = true;
      internalValueResult.token = this._token;
    }
    if (this._tokenSecret !== undefined) {
      hasAnyValues = true;
      internalValueResult.tokenSecret = this._tokenSecret;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputZscalerHecAuthTokens | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._allowedIndexesAtToken = undefined;
      this._authType = undefined;
      this._description = undefined;
      this._enabled = undefined;
      this._metadata.internalValue = undefined;
      this._token = undefined;
      this._tokenSecret = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._allowedIndexesAtToken = value.allowedIndexesAtToken;
      this._authType = value.authType;
      this._description = value.description;
      this._enabled = value.enabled;
      this._metadata.internalValue = value.metadata;
      this._token = value.token;
      this._tokenSecret = value.tokenSecret;
    }
  }

  // allowed_indexes_at_token - computed: false, optional: true, required: false
  private _allowedIndexesAtToken?: string[]; 
  public get allowedIndexesAtToken() {
    return this.getListAttribute('allowed_indexes_at_token');
  }
  public set allowedIndexesAtToken(value: string[]) {
    this._allowedIndexesAtToken = value;
  }
  public resetAllowedIndexesAtToken() {
    this._allowedIndexesAtToken = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get allowedIndexesAtTokenInput() {
    return this._allowedIndexesAtToken;
  }

  // auth_type - computed: true, optional: true, required: false
  private _authType?: string; 
  public get authType() {
    return this.getStringAttribute('auth_type');
  }
  public set authType(value: string) {
    this._authType = value;
  }
  public resetAuthType() {
    this._authType = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authTypeInput() {
    return this._authType;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // enabled - computed: true, optional: true, required: false
  private _enabled?: boolean | cdktf.IResolvable; 
  public get enabled() {
    return this.getBooleanAttribute('enabled');
  }
  public set enabled(value: boolean | cdktf.IResolvable) {
    this._enabled = value;
  }
  public resetEnabled() {
    this._enabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enabledInput() {
    return this._enabled;
  }

  // metadata - computed: false, optional: true, required: false
  private _metadata = new SourceInputZscalerHecAuthTokensMetadataList(this, "metadata", false);
  public get metadata() {
    return this._metadata;
  }
  public putMetadata(value: SourceInputZscalerHecAuthTokensMetadata[] | cdktf.IResolvable) {
    this._metadata.internalValue = value;
  }
  public resetMetadata() {
    this._metadata.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataInput() {
    return this._metadata.internalValue;
  }

  // token - computed: false, optional: false, required: true
  private _token?: string; 
  public get token() {
    return this.getStringAttribute('token');
  }
  public set token(value: string) {
    this._token = value;
  }
  // Temporarily expose input value. Use with caution.
  public get tokenInput() {
    return this._token;
  }

  // token_secret - computed: false, optional: true, required: false
  private _tokenSecret?: string; 
  public get tokenSecret() {
    return this.getStringAttribute('token_secret');
  }
  public set tokenSecret(value: string) {
    this._tokenSecret = value;
  }
  public resetTokenSecret() {
    this._tokenSecret = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tokenSecretInput() {
    return this._tokenSecret;
  }
}

export class SourceInputZscalerHecAuthTokensList extends cdktf.ComplexList {
  public internalValue? : SourceInputZscalerHecAuthTokens[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): SourceInputZscalerHecAuthTokensOutputReference {
    return new SourceInputZscalerHecAuthTokensOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface SourceInputZscalerHecConnections {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#output Source#output}
  */
  readonly output: string;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#pipeline Source#pipeline}
  */
  readonly pipeline?: string;
}

export function sourceInputZscalerHecConnectionsToTerraform(struct?: SourceInputZscalerHecConnections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    output: cdktf.stringToTerraform(struct!.output),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
  }
}


export function sourceInputZscalerHecConnectionsToHclTerraform(struct?: SourceInputZscalerHecConnections | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    output: {
      value: cdktf.stringToHclTerraform(struct!.output),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputZscalerHecConnectionsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): SourceInputZscalerHecConnections | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._output !== undefined) {
      hasAnyValues = true;
      internalValueResult.output = this._output;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputZscalerHecConnections | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._output = undefined;
      this._pipeline = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._output = value.output;
      this._pipeline = value.pipeline;
    }
  }

  // output - computed: false, optional: false, required: true
  private _output?: string; 
  public get output() {
    return this.getStringAttribute('output');
  }
  public set output(value: string) {
    this._output = value;
  }
  // Temporarily expose input value. Use with caution.
  public get outputInput() {
    return this._output;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }
}

export class SourceInputZscalerHecConnectionsList extends cdktf.ComplexList {
  public internalValue? : SourceInputZscalerHecConnections[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): SourceInputZscalerHecConnectionsOutputReference {
    return new SourceInputZscalerHecConnectionsOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface SourceInputZscalerHecMetadata {
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#name Source#name}
  */
  readonly name: string;
  /**
  * JavaScript expression to compute field's value, enclosed in quotes or backticks. (Can evaluate to a constant.)
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#value Source#value}
  */
  readonly value: string;
}

export function sourceInputZscalerHecMetadataToTerraform(struct?: SourceInputZscalerHecMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    name: cdktf.stringToTerraform(struct!.name),
    value: cdktf.stringToTerraform(struct!.value),
  }
}


export function sourceInputZscalerHecMetadataToHclTerraform(struct?: SourceInputZscalerHecMetadata | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    name: {
      value: cdktf.stringToHclTerraform(struct!.name),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    value: {
      value: cdktf.stringToHclTerraform(struct!.value),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputZscalerHecMetadataOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param complexObjectIndex the index of this item in the list
  * @param complexObjectIsFromSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string, complexObjectIndex: number, complexObjectIsFromSet: boolean) {
    super(terraformResource, terraformAttribute, complexObjectIsFromSet, complexObjectIndex);
  }

  public get internalValue(): SourceInputZscalerHecMetadata | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._name !== undefined) {
      hasAnyValues = true;
      internalValueResult.name = this._name;
    }
    if (this._value !== undefined) {
      hasAnyValues = true;
      internalValueResult.value = this._value;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputZscalerHecMetadata | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._name = undefined;
      this._value = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._name = value.name;
      this._value = value.value;
    }
  }

  // name - computed: false, optional: false, required: true
  private _name?: string; 
  public get name() {
    return this.getStringAttribute('name');
  }
  public set name(value: string) {
    this._name = value;
  }
  // Temporarily expose input value. Use with caution.
  public get nameInput() {
    return this._name;
  }

  // value - computed: false, optional: false, required: true
  private _value?: string; 
  public get value() {
    return this.getStringAttribute('value');
  }
  public set value(value: string) {
    this._value = value;
  }
  // Temporarily expose input value. Use with caution.
  public get valueInput() {
    return this._value;
  }
}

export class SourceInputZscalerHecMetadataList extends cdktf.ComplexList {
  public internalValue? : SourceInputZscalerHecMetadata[] | cdktf.IResolvable

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  * @param wrapsSet whether the list is wrapping a set (will add tolist() to be able to access an item via an index)
  */
  constructor(protected terraformResource: cdktf.IInterpolatingParent, protected terraformAttribute: string, protected wrapsSet: boolean) {
    super(terraformResource, terraformAttribute, wrapsSet)
  }

  /**
  * @param index the index of the item to return
  */
  public get(index: number): SourceInputZscalerHecMetadataOutputReference {
    return new SourceInputZscalerHecMetadataOutputReference(this.terraformResource, this.terraformAttribute, index, this.wrapsSet);
  }
}
export interface SourceInputZscalerHecPq {
  /**
  * The number of events to send downstream before committing that Stream has read them. Default: 42
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#commit_frequency Source#commit_frequency}
  */
  readonly commitFrequency?: number;
  /**
  * Codec to use to compress the persisted data. Default: "none"; must be one of ["none", "gzip"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#compress Source#compress}
  */
  readonly compress?: string;
  /**
  * The maximum number of events to hold in memory before writing the events to disk. Default: 1000
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_buffer_size Source#max_buffer_size}
  */
  readonly maxBufferSize?: number;
  /**
  * The maximum size to store in each queue file before closing and optionally compressing. Enter a numeral with units of KB, MB, etc. Default: "1 MB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_file_size Source#max_file_size}
  */
  readonly maxFileSize?: string;
  /**
  * The maximum disk space that the queue can consume (as an average per Worker Process) before queueing stops. Enter a numeral with units of KB, MB, etc. Default: "5GB"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_size Source#max_size}
  */
  readonly maxSize?: string;
  /**
  * With Smart mode, PQ will write events to the filesystem only when it detects backpressure from the processing engine. With Always On mode, PQ will always write events directly to the queue before forwarding them to the processing engine. Default: "always"; must be one of ["smart", "always"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#mode Source#mode}
  */
  readonly mode?: string;
  /**
  * The location for the persistent queue files. To this field's value, the system will append: /<worker-id>/inputs/<input-id>. Default: "$CRIBL_HOME/state/queues"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#path Source#path}
  */
  readonly path?: string;
}

export function sourceInputZscalerHecPqToTerraform(struct?: SourceInputZscalerHecPq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    commit_frequency: cdktf.numberToTerraform(struct!.commitFrequency),
    compress: cdktf.stringToTerraform(struct!.compress),
    max_buffer_size: cdktf.numberToTerraform(struct!.maxBufferSize),
    max_file_size: cdktf.stringToTerraform(struct!.maxFileSize),
    max_size: cdktf.stringToTerraform(struct!.maxSize),
    mode: cdktf.stringToTerraform(struct!.mode),
    path: cdktf.stringToTerraform(struct!.path),
  }
}


export function sourceInputZscalerHecPqToHclTerraform(struct?: SourceInputZscalerHecPq | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    commit_frequency: {
      value: cdktf.numberToHclTerraform(struct!.commitFrequency),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    compress: {
      value: cdktf.stringToHclTerraform(struct!.compress),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_buffer_size: {
      value: cdktf.numberToHclTerraform(struct!.maxBufferSize),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_file_size: {
      value: cdktf.stringToHclTerraform(struct!.maxFileSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    max_size: {
      value: cdktf.stringToHclTerraform(struct!.maxSize),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    mode: {
      value: cdktf.stringToHclTerraform(struct!.mode),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    path: {
      value: cdktf.stringToHclTerraform(struct!.path),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputZscalerHecPqOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SourceInputZscalerHecPq | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._commitFrequency !== undefined) {
      hasAnyValues = true;
      internalValueResult.commitFrequency = this._commitFrequency;
    }
    if (this._compress !== undefined) {
      hasAnyValues = true;
      internalValueResult.compress = this._compress;
    }
    if (this._maxBufferSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxBufferSize = this._maxBufferSize;
    }
    if (this._maxFileSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxFileSize = this._maxFileSize;
    }
    if (this._maxSize !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxSize = this._maxSize;
    }
    if (this._mode !== undefined) {
      hasAnyValues = true;
      internalValueResult.mode = this._mode;
    }
    if (this._path !== undefined) {
      hasAnyValues = true;
      internalValueResult.path = this._path;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputZscalerHecPq | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._commitFrequency = undefined;
      this._compress = undefined;
      this._maxBufferSize = undefined;
      this._maxFileSize = undefined;
      this._maxSize = undefined;
      this._mode = undefined;
      this._path = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._commitFrequency = value.commitFrequency;
      this._compress = value.compress;
      this._maxBufferSize = value.maxBufferSize;
      this._maxFileSize = value.maxFileSize;
      this._maxSize = value.maxSize;
      this._mode = value.mode;
      this._path = value.path;
    }
  }

  // commit_frequency - computed: true, optional: true, required: false
  private _commitFrequency?: number; 
  public get commitFrequency() {
    return this.getNumberAttribute('commit_frequency');
  }
  public set commitFrequency(value: number) {
    this._commitFrequency = value;
  }
  public resetCommitFrequency() {
    this._commitFrequency = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commitFrequencyInput() {
    return this._commitFrequency;
  }

  // compress - computed: true, optional: true, required: false
  private _compress?: string; 
  public get compress() {
    return this.getStringAttribute('compress');
  }
  public set compress(value: string) {
    this._compress = value;
  }
  public resetCompress() {
    this._compress = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get compressInput() {
    return this._compress;
  }

  // max_buffer_size - computed: true, optional: true, required: false
  private _maxBufferSize?: number; 
  public get maxBufferSize() {
    return this.getNumberAttribute('max_buffer_size');
  }
  public set maxBufferSize(value: number) {
    this._maxBufferSize = value;
  }
  public resetMaxBufferSize() {
    this._maxBufferSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxBufferSizeInput() {
    return this._maxBufferSize;
  }

  // max_file_size - computed: true, optional: true, required: false
  private _maxFileSize?: string; 
  public get maxFileSize() {
    return this.getStringAttribute('max_file_size');
  }
  public set maxFileSize(value: string) {
    this._maxFileSize = value;
  }
  public resetMaxFileSize() {
    this._maxFileSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxFileSizeInput() {
    return this._maxFileSize;
  }

  // max_size - computed: true, optional: true, required: false
  private _maxSize?: string; 
  public get maxSize() {
    return this.getStringAttribute('max_size');
  }
  public set maxSize(value: string) {
    this._maxSize = value;
  }
  public resetMaxSize() {
    this._maxSize = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxSizeInput() {
    return this._maxSize;
  }

  // mode - computed: true, optional: true, required: false
  private _mode?: string; 
  public get mode() {
    return this.getStringAttribute('mode');
  }
  public set mode(value: string) {
    this._mode = value;
  }
  public resetMode() {
    this._mode = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get modeInput() {
    return this._mode;
  }

  // path - computed: true, optional: true, required: false
  private _path?: string; 
  public get path() {
    return this.getStringAttribute('path');
  }
  public set path(value: string) {
    this._path = value;
  }
  public resetPath() {
    this._path = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pathInput() {
    return this._path;
  }
}
export interface SourceInputZscalerHecTls {
  /**
  * Path on server containing CA certificates to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#ca_path Source#ca_path}
  */
  readonly caPath?: string;
  /**
  * Path on server containing certificates to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#cert_path Source#cert_path}
  */
  readonly certPath?: string;
  /**
  * The name of the predefined certificate
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#certificate_name Source#certificate_name}
  */
  readonly certificateName?: string;
  /**
  * Parsed as JSON.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#common_name_regex Source#common_name_regex}
  */
  readonly commonNameRegex?: string;
  /**
  * Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#disabled Source#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_version Source#max_version}
  */
  readonly maxVersion?: string;
  /**
  * must be one of ["TLSv1", "TLSv1.1", "TLSv1.2", "TLSv1.3"]
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#min_version Source#min_version}
  */
  readonly minVersion?: string;
  /**
  * Passphrase to use to decrypt private key
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#passphrase Source#passphrase}
  */
  readonly passphrase?: string;
  /**
  * Path on server containing the private key to use. PEM format. Can reference $ENV_VARS.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#priv_key_path Source#priv_key_path}
  */
  readonly privKeyPath?: string;
  /**
  * Parsed as JSON.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#reject_unauthorized Source#reject_unauthorized}
  */
  readonly rejectUnauthorized?: string;
  /**
  * Require clients to present their certificates. Used to perform client authentication using SSL certs. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#request_cert Source#request_cert}
  */
  readonly requestCert?: boolean | cdktf.IResolvable;
}

export function sourceInputZscalerHecTlsToTerraform(struct?: SourceInputZscalerHecTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    ca_path: cdktf.stringToTerraform(struct!.caPath),
    cert_path: cdktf.stringToTerraform(struct!.certPath),
    certificate_name: cdktf.stringToTerraform(struct!.certificateName),
    common_name_regex: cdktf.stringToTerraform(struct!.commonNameRegex),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    max_version: cdktf.stringToTerraform(struct!.maxVersion),
    min_version: cdktf.stringToTerraform(struct!.minVersion),
    passphrase: cdktf.stringToTerraform(struct!.passphrase),
    priv_key_path: cdktf.stringToTerraform(struct!.privKeyPath),
    reject_unauthorized: cdktf.stringToTerraform(struct!.rejectUnauthorized),
    request_cert: cdktf.booleanToTerraform(struct!.requestCert),
  }
}


export function sourceInputZscalerHecTlsToHclTerraform(struct?: SourceInputZscalerHecTls | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    ca_path: {
      value: cdktf.stringToHclTerraform(struct!.caPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    cert_path: {
      value: cdktf.stringToHclTerraform(struct!.certPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    certificate_name: {
      value: cdktf.stringToHclTerraform(struct!.certificateName),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    common_name_regex: {
      value: cdktf.stringToHclTerraform(struct!.commonNameRegex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    max_version: {
      value: cdktf.stringToHclTerraform(struct!.maxVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    min_version: {
      value: cdktf.stringToHclTerraform(struct!.minVersion),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    passphrase: {
      value: cdktf.stringToHclTerraform(struct!.passphrase),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    priv_key_path: {
      value: cdktf.stringToHclTerraform(struct!.privKeyPath),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    reject_unauthorized: {
      value: cdktf.stringToHclTerraform(struct!.rejectUnauthorized),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    request_cert: {
      value: cdktf.booleanToHclTerraform(struct!.requestCert),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputZscalerHecTlsOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SourceInputZscalerHecTls | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._caPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.caPath = this._caPath;
    }
    if (this._certPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.certPath = this._certPath;
    }
    if (this._certificateName !== undefined) {
      hasAnyValues = true;
      internalValueResult.certificateName = this._certificateName;
    }
    if (this._commonNameRegex !== undefined) {
      hasAnyValues = true;
      internalValueResult.commonNameRegex = this._commonNameRegex;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._maxVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxVersion = this._maxVersion;
    }
    if (this._minVersion !== undefined) {
      hasAnyValues = true;
      internalValueResult.minVersion = this._minVersion;
    }
    if (this._passphrase !== undefined) {
      hasAnyValues = true;
      internalValueResult.passphrase = this._passphrase;
    }
    if (this._privKeyPath !== undefined) {
      hasAnyValues = true;
      internalValueResult.privKeyPath = this._privKeyPath;
    }
    if (this._rejectUnauthorized !== undefined) {
      hasAnyValues = true;
      internalValueResult.rejectUnauthorized = this._rejectUnauthorized;
    }
    if (this._requestCert !== undefined) {
      hasAnyValues = true;
      internalValueResult.requestCert = this._requestCert;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputZscalerHecTls | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._caPath = undefined;
      this._certPath = undefined;
      this._certificateName = undefined;
      this._commonNameRegex = undefined;
      this._disabled = undefined;
      this._maxVersion = undefined;
      this._minVersion = undefined;
      this._passphrase = undefined;
      this._privKeyPath = undefined;
      this._rejectUnauthorized = undefined;
      this._requestCert = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._caPath = value.caPath;
      this._certPath = value.certPath;
      this._certificateName = value.certificateName;
      this._commonNameRegex = value.commonNameRegex;
      this._disabled = value.disabled;
      this._maxVersion = value.maxVersion;
      this._minVersion = value.minVersion;
      this._passphrase = value.passphrase;
      this._privKeyPath = value.privKeyPath;
      this._rejectUnauthorized = value.rejectUnauthorized;
      this._requestCert = value.requestCert;
    }
  }

  // ca_path - computed: false, optional: true, required: false
  private _caPath?: string; 
  public get caPath() {
    return this.getStringAttribute('ca_path');
  }
  public set caPath(value: string) {
    this._caPath = value;
  }
  public resetCaPath() {
    this._caPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get caPathInput() {
    return this._caPath;
  }

  // cert_path - computed: false, optional: true, required: false
  private _certPath?: string; 
  public get certPath() {
    return this.getStringAttribute('cert_path');
  }
  public set certPath(value: string) {
    this._certPath = value;
  }
  public resetCertPath() {
    this._certPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certPathInput() {
    return this._certPath;
  }

  // certificate_name - computed: false, optional: true, required: false
  private _certificateName?: string; 
  public get certificateName() {
    return this.getStringAttribute('certificate_name');
  }
  public set certificateName(value: string) {
    this._certificateName = value;
  }
  public resetCertificateName() {
    this._certificateName = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get certificateNameInput() {
    return this._certificateName;
  }

  // common_name_regex - computed: false, optional: true, required: false
  private _commonNameRegex?: string; 
  public get commonNameRegex() {
    return this.getStringAttribute('common_name_regex');
  }
  public set commonNameRegex(value: string) {
    this._commonNameRegex = value;
  }
  public resetCommonNameRegex() {
    this._commonNameRegex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get commonNameRegexInput() {
    return this._commonNameRegex;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // max_version - computed: false, optional: true, required: false
  private _maxVersion?: string; 
  public get maxVersion() {
    return this.getStringAttribute('max_version');
  }
  public set maxVersion(value: string) {
    this._maxVersion = value;
  }
  public resetMaxVersion() {
    this._maxVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxVersionInput() {
    return this._maxVersion;
  }

  // min_version - computed: false, optional: true, required: false
  private _minVersion?: string; 
  public get minVersion() {
    return this.getStringAttribute('min_version');
  }
  public set minVersion(value: string) {
    this._minVersion = value;
  }
  public resetMinVersion() {
    this._minVersion = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get minVersionInput() {
    return this._minVersion;
  }

  // passphrase - computed: false, optional: true, required: false
  private _passphrase?: string; 
  public get passphrase() {
    return this.getStringAttribute('passphrase');
  }
  public set passphrase(value: string) {
    this._passphrase = value;
  }
  public resetPassphrase() {
    this._passphrase = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get passphraseInput() {
    return this._passphrase;
  }

  // priv_key_path - computed: false, optional: true, required: false
  private _privKeyPath?: string; 
  public get privKeyPath() {
    return this.getStringAttribute('priv_key_path');
  }
  public set privKeyPath(value: string) {
    this._privKeyPath = value;
  }
  public resetPrivKeyPath() {
    this._privKeyPath = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get privKeyPathInput() {
    return this._privKeyPath;
  }

  // reject_unauthorized - computed: false, optional: true, required: false
  private _rejectUnauthorized?: string; 
  public get rejectUnauthorized() {
    return this.getStringAttribute('reject_unauthorized');
  }
  public set rejectUnauthorized(value: string) {
    this._rejectUnauthorized = value;
  }
  public resetRejectUnauthorized() {
    this._rejectUnauthorized = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get rejectUnauthorizedInput() {
    return this._rejectUnauthorized;
  }

  // request_cert - computed: true, optional: true, required: false
  private _requestCert?: boolean | cdktf.IResolvable; 
  public get requestCert() {
    return this.getBooleanAttribute('request_cert');
  }
  public set requestCert(value: boolean | cdktf.IResolvable) {
    this._requestCert = value;
  }
  public resetRequestCert() {
    this._requestCert = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestCertInput() {
    return this._requestCert;
  }
}
export interface SourceInputZscalerHec {
  /**
  * Optionally, list HTTP headers that @{product} will send to allowed origins as "Access-Control-Allow-Headers" in a CORS preflight response. Use "*" to allow all headers.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#access_control_allow_headers Source#access_control_allow_headers}
  */
  readonly accessControlAllowHeaders?: string[];
  /**
  * Optionally, list HTTP origins to which @{product} should send CORS (cross-origin resource sharing) Access-Control-Allow-* headers. Supports wildcards.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#access_control_allow_origin Source#access_control_allow_origin}
  */
  readonly accessControlAllowOrigin?: string[];
  /**
  * How often request activity is logged at the `info` level. A value of 1 would log every request, 10 every 10th request, etc. Default: 100
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#activity_log_sample_rate Source#activity_log_sample_rate}
  */
  readonly activityLogSampleRate?: number;
  /**
  * List values allowed in HEC event index field. Leave blank to skip validation. Supports wildcards. The values here can expand index validation at the token level.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#allowed_indexes Source#allowed_indexes}
  */
  readonly allowedIndexes?: string[];
  /**
  * Shared secrets to be provided by any client (Authorization: <token>). If empty, unauthorized access is permitted.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#auth_tokens Source#auth_tokens}
  */
  readonly authTokens?: SourceInputZscalerHecAuthTokens[] | cdktf.IResolvable;
  /**
  * Add request headers to events, in the __headers field. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#capture_headers Source#capture_headers}
  */
  readonly captureHeaders?: boolean | cdktf.IResolvable;
  /**
  * Direct connections to Destinations, and optionally via a Pipeline or a Pack
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#connections Source#connections}
  */
  readonly connections?: SourceInputZscalerHecConnections[] | cdktf.IResolvable;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#description Source#description}
  */
  readonly description?: string;
  /**
  * Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#disabled Source#disabled}
  */
  readonly disabled?: boolean | cdktf.IResolvable;
  /**
  * Enable to emit per-token (<prefix>.http.perToken) and summary (<prefix>.http.summary) request metrics. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#emit_token_metrics Source#emit_token_metrics}
  */
  readonly emitTokenMetrics?: boolean | cdktf.IResolvable;
  /**
  * Parsed as JSON.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#enable_health_check Source#enable_health_check}
  */
  readonly enableHealthCheck?: string;
  /**
  * Extract the client IP and port from PROXY protocol v1/v2. When enabled, the X-Forwarded-For header is ignored. Disable to use the X-Forwarded-For header for client IP extraction. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#enable_proxy_header Source#enable_proxy_header}
  */
  readonly enableProxyHeader?: boolean | cdktf.IResolvable;
  /**
  * Optionally, enable this config only on a specified Git branch. If empty, will be enabled everywhere.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#environment Source#environment}
  */
  readonly environment?: string;
  /**
  * Whether to enable Zscaler HEC acknowledgements. Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#hec_acks Source#hec_acks}
  */
  readonly hecAcks?: boolean | cdktf.IResolvable;
  /**
  * Absolute path on which to listen for the Zscaler HTTP Event Collector API requests. This input supports the /event endpoint. Default: "/services/collector"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#hec_api Source#hec_api}
  */
  readonly hecApi?: string;
  /**
  * Address to bind on. Defaults to 0.0.0.0 (all addresses). Default: "0.0.0.0"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#host Source#host}
  */
  readonly host?: string;
  /**
  * Unique ID for this input
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#id Source#id}
  *
  * Please be aware that the id field is automatically added to all resources in Terraform providers using a Terraform provider SDK version below 2.
  * If you experience problems setting this value it might not be settable. Please take a look at the provider documentation to ensure it should be settable.
  */
  readonly id?: string;
  /**
  * Messages from matched IP addresses will be processed, unless also matched by the denylist. Default: "/.* /"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#ip_allowlist_regex Source#ip_allowlist_regex}
   *
  * Note: The above comment contained a comment block ending sequence (* followed by /). We have introduced a space between to prevent syntax errors. Please ignore the space.
  */
  readonly ipAllowlistRegex?: string;
  /**
  * Messages from matched IP addresses will be ignored. This takes precedence over the allowlist. Default: "/^$/"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#ip_denylist_regex Source#ip_denylist_regex}
  */
  readonly ipDenylistRegex?: string;
  /**
  * After the last response is sent, @{product} will wait this long for additional data before closing the socket connection. Minimum 1 second, maximum 600 seconds (10 minutes). Default: 5
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#keep_alive_timeout Source#keep_alive_timeout}
  */
  readonly keepAliveTimeout?: number;
  /**
  * Maximum number of active requests allowed per Worker Process. Set to 0 for unlimited. Caution: Increasing the limit above the default value, or setting it to unlimited, may degrade performance and reduce throughput. Default: 256
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_active_req Source#max_active_req}
  */
  readonly maxActiveReq?: number;
  /**
  * Maximum number of requests per socket before @{product} instructs the client to close the connection. Default is 0 (unlimited). Default: 0
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#max_requests_per_socket Source#max_requests_per_socket}
  */
  readonly maxRequestsPerSocket?: number;
  /**
  * Fields to add to every event. May be overridden by fields added at the token or request level.
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#metadata Source#metadata}
  */
  readonly metadata?: SourceInputZscalerHecMetadata[] | cdktf.IResolvable;
  /**
  * Pipeline to process data from this Source before sending it through the Routes
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#pipeline Source#pipeline}
  */
  readonly pipeline?: string;
  /**
  * Port to listen on
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#port Source#port}
  */
  readonly port: number;
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#pq Source#pq}
  */
  readonly pq?: SourceInputZscalerHecPq;
  /**
  * Use a disk queue to minimize data loss when connected services block. See [Cribl Docs](https://docs.cribl.io/stream/persistent-queues) for PQ defaults (Cribl-managed Cloud Workers) and configuration options (on-prem and hybrid Workers). Default: false
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#pq_enabled Source#pq_enabled}
  */
  readonly pqEnabled?: boolean | cdktf.IResolvable;
  /**
  * How long to wait for an incoming request to complete before aborting it. Use 0 to disable. Default: 0
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#request_timeout Source#request_timeout}
  */
  readonly requestTimeout?: number;
  /**
  * Select whether to send data to Routes, or directly to Destinations. Default: true
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#send_to_routes Source#send_to_routes}
  */
  readonly sendToRoutes?: boolean | cdktf.IResolvable;
  /**
  * How long @{product} should wait before assuming that an inactive socket has timed out. To wait forever, set to 0. Default: 0
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#socket_timeout Source#socket_timeout}
  */
  readonly socketTimeout?: number;
  /**
  * Tags for filtering and grouping in @{product}. Default: []
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#streamtags Source#streamtags}
  */
  readonly streamtags?: string[];
  /**
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#tls Source#tls}
  */
  readonly tls?: SourceInputZscalerHecTls;
  /**
  * must be "zscaler_hec"
  *
  * Docs at Terraform Registry: {@link https://registry.terraform.io/providers/criblio/criblio/1.18.8/docs/resources/source#type Source#type}
  */
  readonly type?: string;
}

export function sourceInputZscalerHecToTerraform(struct?: SourceInputZscalerHec | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  return {
    access_control_allow_headers: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.accessControlAllowHeaders),
    access_control_allow_origin: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.accessControlAllowOrigin),
    activity_log_sample_rate: cdktf.numberToTerraform(struct!.activityLogSampleRate),
    allowed_indexes: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.allowedIndexes),
    auth_tokens: cdktf.listMapper(sourceInputZscalerHecAuthTokensToTerraform, false)(struct!.authTokens),
    capture_headers: cdktf.booleanToTerraform(struct!.captureHeaders),
    connections: cdktf.listMapper(sourceInputZscalerHecConnectionsToTerraform, false)(struct!.connections),
    description: cdktf.stringToTerraform(struct!.description),
    disabled: cdktf.booleanToTerraform(struct!.disabled),
    emit_token_metrics: cdktf.booleanToTerraform(struct!.emitTokenMetrics),
    enable_health_check: cdktf.stringToTerraform(struct!.enableHealthCheck),
    enable_proxy_header: cdktf.booleanToTerraform(struct!.enableProxyHeader),
    environment: cdktf.stringToTerraform(struct!.environment),
    hec_acks: cdktf.booleanToTerraform(struct!.hecAcks),
    hec_api: cdktf.stringToTerraform(struct!.hecApi),
    host: cdktf.stringToTerraform(struct!.host),
    id: cdktf.stringToTerraform(struct!.id),
    ip_allowlist_regex: cdktf.stringToTerraform(struct!.ipAllowlistRegex),
    ip_denylist_regex: cdktf.stringToTerraform(struct!.ipDenylistRegex),
    keep_alive_timeout: cdktf.numberToTerraform(struct!.keepAliveTimeout),
    max_active_req: cdktf.numberToTerraform(struct!.maxActiveReq),
    max_requests_per_socket: cdktf.numberToTerraform(struct!.maxRequestsPerSocket),
    metadata: cdktf.listMapper(sourceInputZscalerHecMetadataToTerraform, false)(struct!.metadata),
    pipeline: cdktf.stringToTerraform(struct!.pipeline),
    port: cdktf.numberToTerraform(struct!.port),
    pq: sourceInputZscalerHecPqToTerraform(struct!.pq),
    pq_enabled: cdktf.booleanToTerraform(struct!.pqEnabled),
    request_timeout: cdktf.numberToTerraform(struct!.requestTimeout),
    send_to_routes: cdktf.booleanToTerraform(struct!.sendToRoutes),
    socket_timeout: cdktf.numberToTerraform(struct!.socketTimeout),
    streamtags: cdktf.listMapper(cdktf.stringToTerraform, false)(struct!.streamtags),
    tls: sourceInputZscalerHecTlsToTerraform(struct!.tls),
    type: cdktf.stringToTerraform(struct!.type),
  }
}


export function sourceInputZscalerHecToHclTerraform(struct?: SourceInputZscalerHec | cdktf.IResolvable): any {
  if (!cdktf.canInspect(struct) || cdktf.Tokenization.isResolvable(struct)) { return struct; }
  if (cdktf.isComplexElement(struct)) {
    throw new Error("A complex element was used as configuration, this is not supported: https://cdk.tf/complex-object-as-configuration");
  }
  const attrs = {
    access_control_allow_headers: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.accessControlAllowHeaders),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    access_control_allow_origin: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.accessControlAllowOrigin),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    activity_log_sample_rate: {
      value: cdktf.numberToHclTerraform(struct!.activityLogSampleRate),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    allowed_indexes: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.allowedIndexes),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    auth_tokens: {
      value: cdktf.listMapperHcl(sourceInputZscalerHecAuthTokensToHclTerraform, false)(struct!.authTokens),
      isBlock: true,
      type: "list",
      storageClassType: "SourceInputZscalerHecAuthTokensList",
    },
    capture_headers: {
      value: cdktf.booleanToHclTerraform(struct!.captureHeaders),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    connections: {
      value: cdktf.listMapperHcl(sourceInputZscalerHecConnectionsToHclTerraform, false)(struct!.connections),
      isBlock: true,
      type: "list",
      storageClassType: "SourceInputZscalerHecConnectionsList",
    },
    description: {
      value: cdktf.stringToHclTerraform(struct!.description),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    disabled: {
      value: cdktf.booleanToHclTerraform(struct!.disabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    emit_token_metrics: {
      value: cdktf.booleanToHclTerraform(struct!.emitTokenMetrics),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    enable_health_check: {
      value: cdktf.stringToHclTerraform(struct!.enableHealthCheck),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    enable_proxy_header: {
      value: cdktf.booleanToHclTerraform(struct!.enableProxyHeader),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    environment: {
      value: cdktf.stringToHclTerraform(struct!.environment),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    hec_acks: {
      value: cdktf.booleanToHclTerraform(struct!.hecAcks),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    hec_api: {
      value: cdktf.stringToHclTerraform(struct!.hecApi),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    host: {
      value: cdktf.stringToHclTerraform(struct!.host),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    id: {
      value: cdktf.stringToHclTerraform(struct!.id),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ip_allowlist_regex: {
      value: cdktf.stringToHclTerraform(struct!.ipAllowlistRegex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    ip_denylist_regex: {
      value: cdktf.stringToHclTerraform(struct!.ipDenylistRegex),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    keep_alive_timeout: {
      value: cdktf.numberToHclTerraform(struct!.keepAliveTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_active_req: {
      value: cdktf.numberToHclTerraform(struct!.maxActiveReq),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    max_requests_per_socket: {
      value: cdktf.numberToHclTerraform(struct!.maxRequestsPerSocket),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    metadata: {
      value: cdktf.listMapperHcl(sourceInputZscalerHecMetadataToHclTerraform, false)(struct!.metadata),
      isBlock: true,
      type: "list",
      storageClassType: "SourceInputZscalerHecMetadataList",
    },
    pipeline: {
      value: cdktf.stringToHclTerraform(struct!.pipeline),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
    port: {
      value: cdktf.numberToHclTerraform(struct!.port),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    pq: {
      value: sourceInputZscalerHecPqToHclTerraform(struct!.pq),
      isBlock: true,
      type: "struct",
      storageClassType: "SourceInputZscalerHecPq",
    },
    pq_enabled: {
      value: cdktf.booleanToHclTerraform(struct!.pqEnabled),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    request_timeout: {
      value: cdktf.numberToHclTerraform(struct!.requestTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    send_to_routes: {
      value: cdktf.booleanToHclTerraform(struct!.sendToRoutes),
      isBlock: false,
      type: "simple",
      storageClassType: "boolean",
    },
    socket_timeout: {
      value: cdktf.numberToHclTerraform(struct!.socketTimeout),
      isBlock: false,
      type: "simple",
      storageClassType: "number",
    },
    streamtags: {
      value: cdktf.listMapperHcl(cdktf.stringToHclTerraform, false)(struct!.streamtags),
      isBlock: false,
      type: "list",
      storageClassType: "stringList",
    },
    tls: {
      value: sourceInputZscalerHecTlsToHclTerraform(struct!.tls),
      isBlock: true,
      type: "struct",
      storageClassType: "SourceInputZscalerHecTls",
    },
    type: {
      value: cdktf.stringToHclTerraform(struct!.type),
      isBlock: false,
      type: "simple",
      storageClassType: "string",
    },
  };

  // remove undefined attributes
  return Object.fromEntries(Object.entries(attrs).filter(([_, value]) => value !== undefined && value.value !== undefined));
}

export class SourceInputZscalerHecOutputReference extends cdktf.ComplexObject {
  private isEmptyObject = false;
  private resolvableValue?: cdktf.IResolvable;

  /**
  * @param terraformResource The parent resource
  * @param terraformAttribute The attribute on the parent resource this class is referencing
  */
  public constructor(terraformResource: cdktf.IInterpolatingParent, terraformAttribute: string) {
    super(terraformResource, terraformAttribute, false);
  }

  public get internalValue(): SourceInputZscalerHec | cdktf.IResolvable | undefined {
    if (this.resolvableValue) {
      return this.resolvableValue;
    }
    let hasAnyValues = this.isEmptyObject;
    const internalValueResult: any = {};
    if (this._accessControlAllowHeaders !== undefined) {
      hasAnyValues = true;
      internalValueResult.accessControlAllowHeaders = this._accessControlAllowHeaders;
    }
    if (this._accessControlAllowOrigin !== undefined) {
      hasAnyValues = true;
      internalValueResult.accessControlAllowOrigin = this._accessControlAllowOrigin;
    }
    if (this._activityLogSampleRate !== undefined) {
      hasAnyValues = true;
      internalValueResult.activityLogSampleRate = this._activityLogSampleRate;
    }
    if (this._allowedIndexes !== undefined) {
      hasAnyValues = true;
      internalValueResult.allowedIndexes = this._allowedIndexes;
    }
    if (this._authTokens?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.authTokens = this._authTokens?.internalValue;
    }
    if (this._captureHeaders !== undefined) {
      hasAnyValues = true;
      internalValueResult.captureHeaders = this._captureHeaders;
    }
    if (this._connections?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.connections = this._connections?.internalValue;
    }
    if (this._description !== undefined) {
      hasAnyValues = true;
      internalValueResult.description = this._description;
    }
    if (this._disabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.disabled = this._disabled;
    }
    if (this._emitTokenMetrics !== undefined) {
      hasAnyValues = true;
      internalValueResult.emitTokenMetrics = this._emitTokenMetrics;
    }
    if (this._enableHealthCheck !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableHealthCheck = this._enableHealthCheck;
    }
    if (this._enableProxyHeader !== undefined) {
      hasAnyValues = true;
      internalValueResult.enableProxyHeader = this._enableProxyHeader;
    }
    if (this._environment !== undefined) {
      hasAnyValues = true;
      internalValueResult.environment = this._environment;
    }
    if (this._hecAcks !== undefined) {
      hasAnyValues = true;
      internalValueResult.hecAcks = this._hecAcks;
    }
    if (this._hecApi !== undefined) {
      hasAnyValues = true;
      internalValueResult.hecApi = this._hecApi;
    }
    if (this._host !== undefined) {
      hasAnyValues = true;
      internalValueResult.host = this._host;
    }
    if (this._id !== undefined) {
      hasAnyValues = true;
      internalValueResult.id = this._id;
    }
    if (this._ipAllowlistRegex !== undefined) {
      hasAnyValues = true;
      internalValueResult.ipAllowlistRegex = this._ipAllowlistRegex;
    }
    if (this._ipDenylistRegex !== undefined) {
      hasAnyValues = true;
      internalValueResult.ipDenylistRegex = this._ipDenylistRegex;
    }
    if (this._keepAliveTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.keepAliveTimeout = this._keepAliveTimeout;
    }
    if (this._maxActiveReq !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxActiveReq = this._maxActiveReq;
    }
    if (this._maxRequestsPerSocket !== undefined) {
      hasAnyValues = true;
      internalValueResult.maxRequestsPerSocket = this._maxRequestsPerSocket;
    }
    if (this._metadata?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.metadata = this._metadata?.internalValue;
    }
    if (this._pipeline !== undefined) {
      hasAnyValues = true;
      internalValueResult.pipeline = this._pipeline;
    }
    if (this._port !== undefined) {
      hasAnyValues = true;
      internalValueResult.port = this._port;
    }
    if (this._pq?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.pq = this._pq?.internalValue;
    }
    if (this._pqEnabled !== undefined) {
      hasAnyValues = true;
      internalValueResult.pqEnabled = this._pqEnabled;
    }
    if (this._requestTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.requestTimeout = this._requestTimeout;
    }
    if (this._sendToRoutes !== undefined) {
      hasAnyValues = true;
      internalValueResult.sendToRoutes = this._sendToRoutes;
    }
    if (this._socketTimeout !== undefined) {
      hasAnyValues = true;
      internalValueResult.socketTimeout = this._socketTimeout;
    }
    if (this._streamtags !== undefined) {
      hasAnyValues = true;
      internalValueResult.streamtags = this._streamtags;
    }
    if (this._tls?.internalValue !== undefined) {
      hasAnyValues = true;
      internalValueResult.tls = this._tls?.internalValue;
    }
    if (this._type !== undefined) {
      hasAnyValues = true;
      internalValueResult.type = this._type;
    }
    return hasAnyValues ? internalValueResult : undefined;
  }

  public set internalValue(value: SourceInputZscalerHec | cdktf.IResolvable | undefined) {
    if (value === undefined) {
      this.isEmptyObject = false;
      this.resolvableValue = undefined;
      this._accessControlAllowHeaders = undefined;
      this._accessControlAllowOrigin = undefined;
      this._activityLogSampleRate = undefined;
      this._allowedIndexes = undefined;
      this._authTokens.internalValue = undefined;
      this._captureHeaders = undefined;
      this._connections.internalValue = undefined;
      this._description = undefined;
      this._disabled = undefined;
      this._emitTokenMetrics = undefined;
      this._enableHealthCheck = undefined;
      this._enableProxyHeader = undefined;
      this._environment = undefined;
      this._hecAcks = undefined;
      this._hecApi = undefined;
      this._host = undefined;
      this._id = undefined;
      this._ipAllowlistRegex = undefined;
      this._ipDenylistRegex = undefined;
      this._keepAliveTimeout = undefined;
      this._maxActiveReq = undefined;
      this._maxRequestsPerSocket = undefined;
      this._metadata.internalValue = undefined;
      this._pipeline = undefined;
      this._port = undefined;
      this._pq.internalValue = undefined;
      this._pqEnabled = undefined;
      this._requestTimeout = undefined;
      this._sendToRoutes = undefined;
      this._socketTimeout = undefined;
      this._streamtags = undefined;
      this._tls.internalValue = undefined;
      this._type = undefined;
    }
    else if (cdktf.Tokenization.isResolvable(value)) {
      this.isEmptyObject = false;
      this.resolvableValue = value;
    }
    else {
      this.isEmptyObject = Object.keys(value).length === 0;
      this.resolvableValue = undefined;
      this._accessControlAllowHeaders = value.accessControlAllowHeaders;
      this._accessControlAllowOrigin = value.accessControlAllowOrigin;
      this._activityLogSampleRate = value.activityLogSampleRate;
      this._allowedIndexes = value.allowedIndexes;
      this._authTokens.internalValue = value.authTokens;
      this._captureHeaders = value.captureHeaders;
      this._connections.internalValue = value.connections;
      this._description = value.description;
      this._disabled = value.disabled;
      this._emitTokenMetrics = value.emitTokenMetrics;
      this._enableHealthCheck = value.enableHealthCheck;
      this._enableProxyHeader = value.enableProxyHeader;
      this._environment = value.environment;
      this._hecAcks = value.hecAcks;
      this._hecApi = value.hecApi;
      this._host = value.host;
      this._id = value.id;
      this._ipAllowlistRegex = value.ipAllowlistRegex;
      this._ipDenylistRegex = value.ipDenylistRegex;
      this._keepAliveTimeout = value.keepAliveTimeout;
      this._maxActiveReq = value.maxActiveReq;
      this._maxRequestsPerSocket = value.maxRequestsPerSocket;
      this._metadata.internalValue = value.metadata;
      this._pipeline = value.pipeline;
      this._port = value.port;
      this._pq.internalValue = value.pq;
      this._pqEnabled = value.pqEnabled;
      this._requestTimeout = value.requestTimeout;
      this._sendToRoutes = value.sendToRoutes;
      this._socketTimeout = value.socketTimeout;
      this._streamtags = value.streamtags;
      this._tls.internalValue = value.tls;
      this._type = value.type;
    }
  }

  // access_control_allow_headers - computed: false, optional: true, required: false
  private _accessControlAllowHeaders?: string[]; 
  public get accessControlAllowHeaders() {
    return this.getListAttribute('access_control_allow_headers');
  }
  public set accessControlAllowHeaders(value: string[]) {
    this._accessControlAllowHeaders = value;
  }
  public resetAccessControlAllowHeaders() {
    this._accessControlAllowHeaders = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get accessControlAllowHeadersInput() {
    return this._accessControlAllowHeaders;
  }

  // access_control_allow_origin - computed: false, optional: true, required: false
  private _accessControlAllowOrigin?: string[]; 
  public get accessControlAllowOrigin() {
    return this.getListAttribute('access_control_allow_origin');
  }
  public set accessControlAllowOrigin(value: string[]) {
    this._accessControlAllowOrigin = value;
  }
  public resetAccessControlAllowOrigin() {
    this._accessControlAllowOrigin = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get accessControlAllowOriginInput() {
    return this._accessControlAllowOrigin;
  }

  // activity_log_sample_rate - computed: true, optional: true, required: false
  private _activityLogSampleRate?: number; 
  public get activityLogSampleRate() {
    return this.getNumberAttribute('activity_log_sample_rate');
  }
  public set activityLogSampleRate(value: number) {
    this._activityLogSampleRate = value;
  }
  public resetActivityLogSampleRate() {
    this._activityLogSampleRate = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get activityLogSampleRateInput() {
    return this._activityLogSampleRate;
  }

  // allowed_indexes - computed: false, optional: true, required: false
  private _allowedIndexes?: string[]; 
  public get allowedIndexes() {
    return this.getListAttribute('allowed_indexes');
  }
  public set allowedIndexes(value: string[]) {
    this._allowedIndexes = value;
  }
  public resetAllowedIndexes() {
    this._allowedIndexes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get allowedIndexesInput() {
    return this._allowedIndexes;
  }

  // auth_tokens - computed: false, optional: true, required: false
  private _authTokens = new SourceInputZscalerHecAuthTokensList(this, "auth_tokens", false);
  public get authTokens() {
    return this._authTokens;
  }
  public putAuthTokens(value: SourceInputZscalerHecAuthTokens[] | cdktf.IResolvable) {
    this._authTokens.internalValue = value;
  }
  public resetAuthTokens() {
    this._authTokens.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get authTokensInput() {
    return this._authTokens.internalValue;
  }

  // capture_headers - computed: true, optional: true, required: false
  private _captureHeaders?: boolean | cdktf.IResolvable; 
  public get captureHeaders() {
    return this.getBooleanAttribute('capture_headers');
  }
  public set captureHeaders(value: boolean | cdktf.IResolvable) {
    this._captureHeaders = value;
  }
  public resetCaptureHeaders() {
    this._captureHeaders = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get captureHeadersInput() {
    return this._captureHeaders;
  }

  // connections - computed: false, optional: true, required: false
  private _connections = new SourceInputZscalerHecConnectionsList(this, "connections", false);
  public get connections() {
    return this._connections;
  }
  public putConnections(value: SourceInputZscalerHecConnections[] | cdktf.IResolvable) {
    this._connections.internalValue = value;
  }
  public resetConnections() {
    this._connections.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get connectionsInput() {
    return this._connections.internalValue;
  }

  // description - computed: false, optional: true, required: false
  private _description?: string; 
  public get description() {
    return this.getStringAttribute('description');
  }
  public set description(value: string) {
    this._description = value;
  }
  public resetDescription() {
    this._description = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get descriptionInput() {
    return this._description;
  }

  // disabled - computed: true, optional: true, required: false
  private _disabled?: boolean | cdktf.IResolvable; 
  public get disabled() {
    return this.getBooleanAttribute('disabled');
  }
  public set disabled(value: boolean | cdktf.IResolvable) {
    this._disabled = value;
  }
  public resetDisabled() {
    this._disabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get disabledInput() {
    return this._disabled;
  }

  // emit_token_metrics - computed: true, optional: true, required: false
  private _emitTokenMetrics?: boolean | cdktf.IResolvable; 
  public get emitTokenMetrics() {
    return this.getBooleanAttribute('emit_token_metrics');
  }
  public set emitTokenMetrics(value: boolean | cdktf.IResolvable) {
    this._emitTokenMetrics = value;
  }
  public resetEmitTokenMetrics() {
    this._emitTokenMetrics = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get emitTokenMetricsInput() {
    return this._emitTokenMetrics;
  }

  // enable_health_check - computed: false, optional: true, required: false
  private _enableHealthCheck?: string; 
  public get enableHealthCheck() {
    return this.getStringAttribute('enable_health_check');
  }
  public set enableHealthCheck(value: string) {
    this._enableHealthCheck = value;
  }
  public resetEnableHealthCheck() {
    this._enableHealthCheck = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableHealthCheckInput() {
    return this._enableHealthCheck;
  }

  // enable_proxy_header - computed: true, optional: true, required: false
  private _enableProxyHeader?: boolean | cdktf.IResolvable; 
  public get enableProxyHeader() {
    return this.getBooleanAttribute('enable_proxy_header');
  }
  public set enableProxyHeader(value: boolean | cdktf.IResolvable) {
    this._enableProxyHeader = value;
  }
  public resetEnableProxyHeader() {
    this._enableProxyHeader = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get enableProxyHeaderInput() {
    return this._enableProxyHeader;
  }

  // environment - computed: false, optional: true, required: false
  private _environment?: string; 
  public get environment() {
    return this.getStringAttribute('environment');
  }
  public set environment(value: string) {
    this._environment = value;
  }
  public resetEnvironment() {
    this._environment = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get environmentInput() {
    return this._environment;
  }

  // hec_acks - computed: true, optional: true, required: false
  private _hecAcks?: boolean | cdktf.IResolvable; 
  public get hecAcks() {
    return this.getBooleanAttribute('hec_acks');
  }
  public set hecAcks(value: boolean | cdktf.IResolvable) {
    this._hecAcks = value;
  }
  public resetHecAcks() {
    this._hecAcks = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hecAcksInput() {
    return this._hecAcks;
  }

  // hec_api - computed: true, optional: true, required: false
  private _hecApi?: string; 
  public get hecApi() {
    return this.getStringAttribute('hec_api');
  }
  public set hecApi(value: string) {
    this._hecApi = value;
  }
  public resetHecApi() {
    this._hecApi = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hecApiInput() {
    return this._hecApi;
  }

  // host - computed: true, optional: true, required: false
  private _host?: string; 
  public get host() {
    return this.getStringAttribute('host');
  }
  public set host(value: string) {
    this._host = value;
  }
  public resetHost() {
    this._host = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get hostInput() {
    return this._host;
  }

  // id - computed: false, optional: true, required: false
  private _id?: string; 
  public get id() {
    return this.getStringAttribute('id');
  }
  public set id(value: string) {
    this._id = value;
  }
  public resetId() {
    this._id = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get idInput() {
    return this._id;
  }

  // ip_allowlist_regex - computed: true, optional: true, required: false
  private _ipAllowlistRegex?: string; 
  public get ipAllowlistRegex() {
    return this.getStringAttribute('ip_allowlist_regex');
  }
  public set ipAllowlistRegex(value: string) {
    this._ipAllowlistRegex = value;
  }
  public resetIpAllowlistRegex() {
    this._ipAllowlistRegex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ipAllowlistRegexInput() {
    return this._ipAllowlistRegex;
  }

  // ip_denylist_regex - computed: true, optional: true, required: false
  private _ipDenylistRegex?: string; 
  public get ipDenylistRegex() {
    return this.getStringAttribute('ip_denylist_regex');
  }
  public set ipDenylistRegex(value: string) {
    this._ipDenylistRegex = value;
  }
  public resetIpDenylistRegex() {
    this._ipDenylistRegex = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get ipDenylistRegexInput() {
    return this._ipDenylistRegex;
  }

  // keep_alive_timeout - computed: true, optional: true, required: false
  private _keepAliveTimeout?: number; 
  public get keepAliveTimeout() {
    return this.getNumberAttribute('keep_alive_timeout');
  }
  public set keepAliveTimeout(value: number) {
    this._keepAliveTimeout = value;
  }
  public resetKeepAliveTimeout() {
    this._keepAliveTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get keepAliveTimeoutInput() {
    return this._keepAliveTimeout;
  }

  // max_active_req - computed: true, optional: true, required: false
  private _maxActiveReq?: number; 
  public get maxActiveReq() {
    return this.getNumberAttribute('max_active_req');
  }
  public set maxActiveReq(value: number) {
    this._maxActiveReq = value;
  }
  public resetMaxActiveReq() {
    this._maxActiveReq = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxActiveReqInput() {
    return this._maxActiveReq;
  }

  // max_requests_per_socket - computed: true, optional: true, required: false
  private _maxRequestsPerSocket?: number; 
  public get maxRequestsPerSocket() {
    return this.getNumberAttribute('max_requests_per_socket');
  }
  public set maxRequestsPerSocket(value: number) {
    this._maxRequestsPerSocket = value;
  }
  public resetMaxRequestsPerSocket() {
    this._maxRequestsPerSocket = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get maxRequestsPerSocketInput() {
    return this._maxRequestsPerSocket;
  }

  // metadata - computed: false, optional: true, required: false
  private _metadata = new SourceInputZscalerHecMetadataList(this, "metadata", false);
  public get metadata() {
    return this._metadata;
  }
  public putMetadata(value: SourceInputZscalerHecMetadata[] | cdktf.IResolvable) {
    this._metadata.internalValue = value;
  }
  public resetMetadata() {
    this._metadata.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get metadataInput() {
    return this._metadata.internalValue;
  }

  // pipeline - computed: false, optional: true, required: false
  private _pipeline?: string; 
  public get pipeline() {
    return this.getStringAttribute('pipeline');
  }
  public set pipeline(value: string) {
    this._pipeline = value;
  }
  public resetPipeline() {
    this._pipeline = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pipelineInput() {
    return this._pipeline;
  }

  // port - computed: false, optional: false, required: true
  private _port?: number; 
  public get port() {
    return this.getNumberAttribute('port');
  }
  public set port(value: number) {
    this._port = value;
  }
  // Temporarily expose input value. Use with caution.
  public get portInput() {
    return this._port;
  }

  // pq - computed: false, optional: true, required: false
  private _pq = new SourceInputZscalerHecPqOutputReference(this, "pq");
  public get pq() {
    return this._pq;
  }
  public putPq(value: SourceInputZscalerHecPq) {
    this._pq.internalValue = value;
  }
  public resetPq() {
    this._pq.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqInput() {
    return this._pq.internalValue;
  }

  // pq_enabled - computed: true, optional: true, required: false
  private _pqEnabled?: boolean | cdktf.IResolvable; 
  public get pqEnabled() {
    return this.getBooleanAttribute('pq_enabled');
  }
  public set pqEnabled(value: boolean | cdktf.IResolvable) {
    this._pqEnabled = value;
  }
  public resetPqEnabled() {
    this._pqEnabled = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get pqEnabledInput() {
    return this._pqEnabled;
  }

  // request_timeout - computed: true, optional: true, required: false
  private _requestTimeout?: number; 
  public get requestTimeout() {
    return this.getNumberAttribute('request_timeout');
  }
  public set requestTimeout(value: number) {
    this._requestTimeout = value;
  }
  public resetRequestTimeout() {
    this._requestTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get requestTimeoutInput() {
    return this._requestTimeout;
  }

  // send_to_routes - computed: true, optional: true, required: false
  private _sendToRoutes?: boolean | cdktf.IResolvable; 
  public get sendToRoutes() {
    return this.getBooleanAttribute('send_to_routes');
  }
  public set sendToRoutes(value: boolean | cdktf.IResolvable) {
    this._sendToRoutes = value;
  }
  public resetSendToRoutes() {
    this._sendToRoutes = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get sendToRoutesInput() {
    return this._sendToRoutes;
  }

  // socket_timeout - computed: true, optional: true, required: false
  private _socketTimeout?: number; 
  public get socketTimeout() {
    return this.getNumberAttribute('socket_timeout');
  }
  public set socketTimeout(value: number) {
    this._socketTimeout = value;
  }
  public resetSocketTimeout() {
    this._socketTimeout = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get socketTimeoutInput() {
    return this._socketTimeout;
  }

  // streamtags - computed: true, optional: true, required: false
  private _streamtags?: string[]; 
  public get streamtags() {
    return this.getListAttribute('streamtags');
  }
  public set streamtags(value: string[]) {
    this._streamtags = value;
  }
  public resetStreamtags() {
    this._streamtags = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get streamtagsInput() {
    return this._streamtags;
  }

  // tls - computed: false, optional: true, required: false
  private _tls = new SourceInputZscalerHecTlsOutputReference(this, "tls");
  public get tls() {
    return this._tls;
  }
  public putTls(value: SourceInputZscalerHecTls) {
    this._tls.internalValue = value;
  }
  public resetTls() {
    this._tls.internalValue = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get tlsInput() {
    return this._tls.internalValue;
  }

  // type - computed: false, optional: true, required: false
  private _type?: string; 
  public get type() {
    return this.getStringAttribute('type');
  }
  public set type(value: string) {
    this._type = value;
  }
  public resetType() {
    this._type = undefined;
  }
  // Temporarily expose input value. Use with caution.
  public get typeInput() {
    return this._type;
  }
}
